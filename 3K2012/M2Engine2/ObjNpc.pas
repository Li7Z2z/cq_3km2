unit ObjNpc;  // 这个是处理NPC角色的

interface
uses
  Windows, Classes, SysUtils, StrUtils, ObjBase, Grobal2, SDK, IniFiles;

const
  CMD_RACE_0 = 0; //self
  CMD_RACE_1 = 1; //hero
  CMD_RACE_2 = 2; //Master
  CMD_RACE_3 = 3; //mon
  CMD_RACE_4 = 4; //obj
{  CMD_RACE_5 = 5;
  CMD_RACE_6 = 6;
  CMD_RACE_7 = 7;
  CMD_RACE_8 = 8;
  CMD_RACE_9 = 9;}

type
  TNormNpc = class;

  TUpgradeInfo = record
    sUserName: string[14];//升级物品的人物名
    UserItem: TUserItem;
    btDc: Byte;
    btSc: Byte;
    btMc: Byte;
    btDura: Byte;
    n2C: Integer;//未使用
    dtTime: TDateTime;
    dwGetBackTick: LongWord;
    n3C: Integer;//未使用
  end;
  pTUpgradeInfo = ^TUpgradeInfo;
  TItemPrice = record
    wIndex: Word;
    nPrice: Integer;
  end;
  pTItemPrice = ^TItemPrice;
  TGoods = record
    sItemName: string[14];//物品名
    nCount: Integer;//数量
    dwRefillTime: LongWord;//刷新时间
    dwRefillTick: LongWord;//刷新间隔
  end;
  pTGoods = ^TGoods;

  TSellItemPrice = record
    wIndex: Word;
    nPrice: Integer;
  end;
  pTSellItemPrice = ^TSellItemPrice;

  TScriptObject = class//20090926增加，支持NPC命令扩展
  private
    ScriptList: array of string;
    ScriptCmd: array of Integer;
  public
    function Cmd(sCmd: string): string;
    function GetBaseObject(NPC: TNormNpc; PlayObject: TPlayObject): TBaseObject;
  end;

  TQuestActionInfo = record
    Script: TScriptObject;//NPC命令扩展 20090926
    nCMDCode: Integer;
    sParam1: string;
    nParam1: Integer;
    sParam2: string;
    nParam2: Integer;
    sParam3: string;
    nParam3: Integer;
    sParam4: string;
    nParam4: Integer;
    sParam5: string;
    nParam5: Integer;
    sParam6: string;
    nParam6: Integer;
    sParam7: string;
    nParam7: Integer;
    sParam8: string;
    nParam8: Integer;
  end;
  pTQuestActionInfo = ^TQuestActionInfo;
  TQuestConditionInfo = record
    Script: TScriptObject;
    nCMDCode: Integer;
    sParam1: string;
    nParam1: Integer;
    sParam2: string;
    nParam2: Integer;
    sParam3: string;
    nParam3: Integer;
    sParam4: string;
    nParam4: Integer;
    sParam5: string;
    nParam5: Integer;
    sParam6: string;
    nParam6: Integer;
    sParam7: string;
    nParam7: Integer;
    sParam8: string;
    nParam8: Integer;
  end;
  pTQuestConditionInfo = ^TQuestConditionInfo;

  TSayingProcedure = record
    ConditionList: TList;
    ActionList: TList;
    sSayMsg: string;
    ElseActionList: TList;
    sElseSayMsg: string;
  end;
  pTSayingProcedure = ^TSayingProcedure;

  TSayingRecord = record
    sLabel: string;
    ProcedureList: TList;
    boExtJmp: Boolean; //是否允许外部跳转
  end;
  pTSayingRecord = ^TSayingRecord;

  TNormNpc = class(TAnimalObject)
    m_nFlag: ShortInt;//用于标识此NPC是否有效，用于重新加载NPC列表(-1 为无效)
    m_ScriptList: TList; //
    m_sFilePath: string; //脚本文件所在目录
    m_boIsHide: Boolean; //此NPC是否是隐藏的，不显示在地图中
    m_boIsQuest: Boolean; //NPC类型为地图任务型的，加载脚本时的脚本文件名为 角色名-地图号.txt
    m_sPath: string;
    m_boNpcAutoChangeColor: Boolean;//是否变色
    m_dwNpcAutoChangeColorTick: LongWord;//变色间隔
    m_dwNpcAutoChangeColorTime: LongWord;//变色时间
    m_nNpcAutoChangeIdx: Integer;
    m_boGotoCount: Word;//执行Goto的次数
    m_sRefresAppr: string;//变量外观
    m_WinType:Integer;
  private
    procedure ScriptActionError(PlayObject: TPlayObject; sErrMsg: string; QuestActionInfo: pTQuestActionInfo; sCmd: string);
    procedure ScriptConditionError(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo; sCmd: string);
    procedure ExeAction(PlayObject: TPlayObject; sParam1, sParam2, sParam3: string; nParam1, nParam2, nParam3: Integer);
    procedure ActionOfChangeLevel(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfMarry(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfMaster(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfUnMarry(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfUnMaster(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfGiveItem(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfGetMarry(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfGetMaster(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfClearSkill(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfAddRandomMapGate(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//增加地图连接 20090503
    procedure ActionOfDelRandomMapGate(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//删除地图连接 20090503
    procedure ActionOfMirrorMap(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//增加镜像地图
    //Add By TasNat at: 2012-03-17 11:39:17
    procedure ActionOfUnMirrorMap(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//删除镜像地图
    procedure ActionOfClearMapItem(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//清理地图物品
    procedure ActionOfIncreaseSkillLevel(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//调整强化等级
    procedure ActionOfClearBagItems(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//清理背包物品
    function ConditionOfCheckIsInGroup(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检测地图范围指定怪物数量
    function ConditionOfCheckRangeMonEx(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检测地图范围指定怪物数量
    function ConditionOfCheckBagItems(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检测背包是否有某些物品
    //End Add
    procedure ActionOfReLoadCastle(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//初始化沙城配置
    procedure ActionOfDelNoJobSkill(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfDelSkill(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfAddSkill(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//增加技能  支持英雄
    procedure ActionOfADDGUILDMEMBER(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//添加行会成员//20080427
    procedure ActionOfDELGUILDMEMBER(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//删除行会成员（删除掌门无效）//20080427
    procedure ActionOfChangeSkillLevelEx(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfSkillLevel(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//调整人物技能等级
    procedure ActionOfHeroSkillLevel(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//调整英雄技能等级 20080415
    procedure ActionOfChangePkPoint(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfChangeExp(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfChangeCattleGasExp(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//调整人物牛气值 20090519
    procedure ActionOfChangeItemDura(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//调整装备持久
    procedure ActionOfSortHumVarToFile(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//人物自定义变量排序
    {$IF M2Version <> 2}
    function ReQuestBuildDivision(PlayObject: TPlayObject; sDivisionName: string): Integer;//创建师门
    procedure ActionOfADDDIVISIONMEMBER(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//添加师门成员
    procedure ActionOfDELDIVISIONMEMBER(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//删除师门成员（删除掌门无效）
    procedure ActionOfOpenSavvyHeart(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//打开领悟心法窗口(学习龙卫心法-999级)
    procedure ActionOfOpenApplyDivision(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//打开申请加入门派窗口
    procedure ActionOfSavvyHeart(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//弟子领悟师门心法
    procedure ActionOfChangeDivisionPoint(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//调整门派人气值
    procedure ActionOfChangeHeartPoint(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//调整弟子传承心法经验
    procedure ActionOfIncHeartPoint(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//龙卫心法吸收心法经验，并减少累积经验(传承心法无效)

    procedure ActionOfGiveFengHao(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//给予称号
    procedure ActionOfRecycFengHao(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//回收称号
    procedure ActionOfChangeFengHaoTime(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//调整称号时长
    procedure ActionOfGiveFengHaoAgree(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//设置称号发送确认信息
    procedure ActionOfREADSKILLNG(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//学习内功
    procedure ActionOfClearNGSkill(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//清除人物的所有内功技能  20090428
    procedure ActionOfChangeNGExp(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//调整内功经验 20081002
    procedure ActionOfCHANGENGLEVEL(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//调整内功等级 20081004
    function ConditionOfCHECKNGLEVEL(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查角色内功等级 20081223
    function ConditionOfCHANGREADNG(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查是否学过内功 20081002
    procedure ActionOfOPENEXPCRYSTAL(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//客户端显示天地结晶 20090131
    procedure ActionOfCLOSEEXPCRYSTAL(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//客户端关闭天地结晶 20090131
    procedure ActionOfGETEXPTOCRYSTAL(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//取提天地结晶中的经验(只提取可提取的经验) 20090202
    procedure ActionOfQUERYREFINEITEM(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//打开淬炼窗口 20080502
    {$IFEND}
    procedure ActionOfOpenRefineArmyDrum(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfOpenMakeKimNeedle(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//客户端显示锻练金针窗口 20090615
    procedure ActionOfTakeKimNeedle(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//收回包裹指定叠加物品 20090615
    procedure ActionOfGiveKimNeedle(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//给指定的叠加物品 20090615
    procedure ActionOfChangeAttatckMode(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//改变人物的攻击模式
    {$IF M2Version = 1}
    procedure ActionOfOPENLIANQI(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//打开炼气窗口
    procedure ActionOfCHANGEJINGYUAN(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//调整人物精元值
    procedure ActionOfOpen4BatterSkill(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//开启第四个连击技能 20100720
    procedure ActionOfOpenHeroPuls(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//开通英雄经脉
    procedure ActionOfOpenPulse(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//打通指定脉穴 20090623
    procedure ActionOfChangePulseLevel(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//改变络经等级 20090624
    procedure ActionOfChangeHeroPulsExp(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//改变英雄经络修炼点
    {$IFEND}
    procedure ActionOfOPENCATTLEGAS(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//客户端显示牛气管图标 20090518
    procedure ActionOfCLOSECATTLEGAS(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//客户端关闭牛气管图标 20090518

    procedure ActionOfSENDTIMEMSG(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//时间到触发QF段(客户端显示信息) 20090124
    procedure ActionOfSENDMSGWINDOWS(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//时间到触发QF段 20090124
    procedure ActionOfCLOSEMSGWINDOWS(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//关闭客户端'!'图标的显示 20090126
    procedure ActionOfGetMonthsDay(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//取当前月份天数 20110304
    procedure ActionOfGETGROUPCOUNT(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//取组队成员数 20090125
    procedure ActionOfChangeCreditPoint(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfCHANGEGUILDMEMBERCOUNT(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//调整行会成员上限 20090115
    procedure ActionOfCHANGEGUILDFOUNTAIN(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//调整行会酒泉 20081007
    procedure ActionOfTAGMAPINFO(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//记路标石 20081019
    procedure ActionOfCreateDir(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//创建路径 20090616
    procedure ActionOfCopyFileTxt(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//复制文本文件 20090824
    procedure ActionOfTAGMAPMOVE(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//移动到记路标石记录的地图XY  20081019
    procedure ActionOfChangeCreditGlory(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfChangeJob(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfClearNameList(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfMission(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfMobPlace(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo; nX, nY, nCount, nRange: Integer);
    procedure ActionOfSetMemberType(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfSetMemberLevel(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfGameGold(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);

    procedure ActionOfGameDiaMond(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo); //调整金刚石动作 20071226
    procedure ActionOfGameGird(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo); //调整灵符动作  20071226
    procedure ActionOfHeroLoyal(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo); //调整英雄的忠诚度  20080109
    procedure ActionOfCHANGEHEROTRANPOINT(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//调整英雄技能升级点数 20080512
    procedure ActionOfCHANGETRANPOINT(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//调整英雄技能升级点数
    procedure ActionOfCHANGEHUMABILITY(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//调整人物属性 20080609
//-------------------------酒馆相关---------------------------------------------
    procedure ActionOfSAVEHERO(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//寄放英雄
    procedure ActionOfGETHERO(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//取回英雄
    procedure ActionOfAssessmentHero(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//评定英雄
    procedure ActionOfCLOSEDRINK(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//关闭斗酒窗口
    procedure ActionOfPLAYDRINKMSG(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//斗酒窗口说话信息 20080514
    procedure ActionOfOPENPLAYDRINK(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//指定人物喝酒 20080514
//------------------------------------------------------------------------------
    procedure ActionOfGamePoint(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfAutoAddGameGold(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo; nPoint, nTime: Integer);
    procedure ActionOfAutoSubGameGold(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo; nPoint, nTime: Integer);
    procedure ActionOfChangeHairStyle(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfLineMsg(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfCreateFile(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//创建文本文件 20081226
    procedure ActionOfDeleteFile(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//删除指定文件
//------------------------------------------------------------------------------
//20080105 特殊公告
    procedure ActionOfSendTopMsg(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//顶端滚动公告
    procedure ActionOfSendCenterMsg(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//屏幕居中显示公告
    procedure ActionOfSendEditTopMsg(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//聊天框顶端公告
    procedure ActionOfPetsMonHappLog(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//打开宠物喂养日志
    procedure ActionOfCHANGEPETSMONHAPP(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//调整人物宠物的快乐度
//------------------------------------------------------------------------------
    procedure ActionOfOPENMAKEWINE(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//打开酿酒窗口 20080619
    procedure ActionOfGETGOODMAKEWINE(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//取回酿好的酒 20080620
    procedure ActionOfDECMAKEWINETIME(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//减少酿酒的时间 20080620
    procedure ActionOfMAKEWINENPCMOVE(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//酿酒NPC的走动 20080621
    procedure ActionOfFOUNTAIN(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//设置泉水喷发 20080624
    procedure ActionOfSETGUILDFOUNTAIN(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//开启/关闭行会泉水仓库20080625
    procedure ActionOfGIVEGUILDFOUNTAIN(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//领取行会酒水 20080625
//------------------------------------------------------------------------------
    procedure ActionOfCHALLENGMAPMOVE(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//挑战地图移动 20080705
    procedure ActionOfGETCHALLENGEBAKITEM(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//没有挑战地图可移动,则退回抵押的物品 20080705
//------------------------------------------------------------------------------
    procedure ActionOfHEROLOGOUT(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//在线英雄下线 20080716
    procedure ActionOfGETSORTNAME(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//取指定排行榜指定排名的玩家名字 20080531
    procedure ActionOfWEBBROWSER(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//连接指定网站网址 20080602
    procedure ActionOfPALYVIDEO(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//播放指定的视频文件 20100929
    procedure ActionOfADDATTACKSABUKALL(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//设置所有行会攻城 20080609
    procedure ActionOfKICKALLPLAY(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//踢除服务器所有人物 20080609
    procedure ActionOfREPAIRALL(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//修理全身装备 20080613
    procedure ActionOfCHANGESKILL(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//修改魔法ID 20080624
    procedure ActionOfCHANGESKILLEX(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//转换魔法ID
    procedure ActionOfAUTOGOTOXY(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//自动寻路 20080617
    procedure ActionOfOPENBOOKS(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//卧龙 20080119
    procedure ActionOfOPENYBDEAL(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//开通元宝交易 20080316
    procedure ActionOfQUERYYBSELL(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//查询正在出售的物品 20080317
    procedure ActionOfQUERYYBDEAL(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//查询可以的购买物品 20080317

    procedure ActionOfTHROUGHHUM(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//改变穿人模式 20080221
    procedure ActionOfSetItemsLight(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//装备发光设置 20080223
    procedure ActionOfOpenDragonBox(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//打开卧龙宝藏 20080306
    procedure ActionOfOpenHeroAutoPractice(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//打开英雄自我修炼窗口
    procedure ActionOfStopHeroAutoPractice(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//停止英雄自我修炼

    procedure ActionOfGOHOME(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//移动到回城点 20080503
    procedure ActionOfTHROWITEM(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//将指定物品刷新到指定地图坐标范围内 20080508
    procedure ActionOfNPCGIVEITEM(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//在NPC范围内爆出物品 20090425
    procedure ActionOfCLEARCODELIST(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);//删除指定文本里的编码 20080410
    procedure ActionOfGetRandomName(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//从文件中随机取文本 20080126
    procedure ActionOfHCall(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//通过脚本命令让别人执行QManage.txt中的脚本 20080422
    procedure ActionOfINCASTLEWARAY(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//检测人物是否在攻城期间的范围内，在则BB叛变 20080422
    procedure ActionOfGIVESTATEITEM(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//给予带绑定状态装备 20080312
    procedure ActionOfSETITEMSTATE(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//设置装备绑定状态 20080312
    procedure ActionOfChangeNameColor(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfClearPassword(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfReNewLevel(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfChangeGender(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfKillSlave(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfKillMonExpRate(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfPowerRate(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//设置攻击力倍数
    procedure ActionOfChangeMode(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//改变管理模式
    procedure ActionOfChangeModeEX(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//改变人物状态
    procedure ActionOfChangePerMission(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfKill(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfKick(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfBonusPoint(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfRestReNewLevel(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfDelMarry(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfDelMaster(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfDELAPPRENTICE(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//删除徒弟 20090208
    procedure ActionOfHIGHLEVELKILLMONFIXEXP(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//一定时间内高等级杀怪经验不变 20090213
    procedure ActionOfChangHearMsgColor(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//改变发言时文字颜色 20090221
    procedure ActionOfSetOnTimer(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfSetOffTimer(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    {$IF M2Version <> 2}
    function ConditionOfIsDivisionMaster(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查玩家是否为门派掌门
    function ConditionOfIsDivisionHeart(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查玩家是否为门派弟子
    function ConditionOfCheckHeartExp(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查累积经验是否达到心法吸收值
    function ConditionOfCheckHeartSkill(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查是否学过心法
    function ConditionOfCheckDivisionPoint(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检测门派人气值
    procedure ActionOfSendShinyMsg(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//通知客户端使"成长任务"按键发亮 20100801
    procedure ActionOfQMissionGoto(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//触发QMission-0.txt脚本段 20100801
    procedure ActionOfJudge(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//打开品评窗口 20100830
    procedure ActionOfCHANGEPROFICIENCY(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//调整人物熟练度
    function ConditionOfCheckFengHao(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检测玩家是否有指定的称号
    function ConditionOfCheckFengHaoCount(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查玩家所有称号的数量
    function ConditionOfCheckFengHaoListCount(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查玩家护花使者或主宰龙卫的数量
    function ConditionOfCheckGuildStarDay(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查行会之星的授于时间
    {$IFEND}
    procedure ActionOfTakeItmeCountDura(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//收回指定名称物品(按数量，持久) 20090912
    procedure ActionOfTAKEMINE(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//收回指定名称的矿名(按数量，纯度)
    procedure ActionOfTAKEBAGITEM(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//收回指定名称的物品(按数量，升级次数)
    procedure ActionOfGiveBAGITEM(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//给指定名称的物品(按数量，升级次数，且增加对属性点)
    procedure ActionOfTakeMakeWine(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//收回指定属性的酒(按品质、酒精度、酒等级)
    procedure ActionOfClearNeedItems(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfClearMakeItems(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfUpgradeItems(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfUpgradeItemsEx(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfMonGenEx(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfClearMapMon(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfMapMoveSlaveName(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfLoadPetsMonSet(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfSetMapMode(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfPkZone(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfRestBonusPoint(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfTakeCastleGold(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfHumanHP(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfHumanMP(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfGuildBuildPoint(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfGuildAuraePoint(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfGuildstabilityPoint(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfGuildFlourishPoint(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfOpenMagicBox(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfSetRankLevelName(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfGmExecute(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfGuildChiefItemCount(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfAddNameDateList(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfDelNameDateList(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfMobFireBurn(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfMessageBox(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfSetScriptFlag(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfAutoGetExp(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfRecallmob(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//脚本召唤宝宝
    procedure ActionOfRECALLMOBEX(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//20080122 召唤宝宝
    procedure ActionOfMOVEMOBTO(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//20080123 将指定坐标的怪物移动到新坐标
    procedure ActionOfCLEARITEMMAP(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//20080124 清除地图物品
    procedure ActionOfVar(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfLoadVar(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfSaveVar(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfCalcVar(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfNotLineAddPiont(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfKickNotLineAddPiont(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfStartTakeGold(PlayObject: TPlayObject);
    procedure ActionOfAnsiReplaceText(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfEncodeText(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfUseBonusPoint(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfRepairItem(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfTakeOnItem(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfTakeOffItem(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
{$IF HEROVERSION = 1}
    procedure ActionOfCreateHero(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfDeleteHero(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfChangeHeroLevel(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);

    procedure ActionOfChangeHeroJob(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfClearHeroSkill(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfChangeHeroPKPoint(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfChangeHeroExp(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
{$IFEND}
    procedure ActionOfAIStart(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfAIStop(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfAILogOn(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfAILogOnEx(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    //procedure ActionOfLoadRobotConfig(BaseObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
    procedure ActionOfGIVEMINE(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//给矿石 20080330
    function ConditionOfCheckGroupJob(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckGroupMap(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckGroupFlag(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckSelfSort(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckHitMonName(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckGroupCount(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckPoseDir(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckPoseLevel(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckPoseGender(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckPoseMarry(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckLevelEx(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查玩家等级
    function ConditionOfCheckSlaveCount(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckBonusPoint(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckAccountIPList(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckNameIPList(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckMarry(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckMarryCount(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckMaster(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfHaveMaster(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckPoseMaster(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfPoseHaveMaster(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckIsMaster(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckPoseIsMaster(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckHaveGuild(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckIsGuildMaster(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckIsCastleaGuild(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckIsCastleMaster(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckMemberType(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckMemBerLevel(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckGameGold(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCHECKSTRINGLENGTH(PlayObject: TPlayObject;QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查字符串的长度 20090105
    //检查金刚石条件 20071227
    function ConditionOfCheckGameDiaMond(PlayObject: TPlayObject;QuestConditionInfo: pTQuestConditionInfo): Boolean;
    //检查灵符条件 20071227
    function ConditionOfCheckGameGird(PlayObject: TPlayObject;QuestConditionInfo: pTQuestConditionInfo): Boolean;
    //检查荣誉值 20080511
    function ConditionOfCheckGameGLORY(PlayObject: TPlayObject;QuestConditionInfo: pTQuestConditionInfo): Boolean;
    //检查技能等级 20080512
    function ConditionOfCHECKSKILLLEVEL(PlayObject: TPlayObject;QuestConditionInfo: pTQuestConditionInfo): Boolean;
    //检查地图指定坐标指定名称怪物数量 20080123
    function ConditionOfCHECKMAPMOBCOUNT(PlayObject: TPlayObject;QuestConditionInfo: pTQuestConditionInfo): Boolean;
    //检查人物周围自己宝宝数量 20080425
    function ConditionOfCHECKSIDESLAVENAME(PlayObject: TPlayObject;QuestConditionInfo: pTQuestConditionInfo): Boolean;
    //检测当前日期是否小于大于等于指定的日期 20080416
    function ConditionOfCHECKCURRENTDATE(PlayObject: TPlayObject;QuestConditionInfo: pTQuestConditionInfo): Boolean;
    //检测师傅（或徒弟）是否在线 20080416
    function ConditionOfCHECKMASTERONLINE(PlayObject: TPlayObject;QuestConditionInfo: pTQuestConditionInfo): Boolean;
    //检测夫妻一方是否在线 20080416
    function ConditionOfCHECKDEARONLINE(PlayObject: TPlayObject;QuestConditionInfo: pTQuestConditionInfo): Boolean;
    //检测师傅（或徒弟）是否在指定地图 20080416
    function ConditionOfCHECKMASTERONMAP(PlayObject: TPlayObject;QuestConditionInfo: pTQuestConditionInfo): Boolean;
    //检测夫妻一方是否在指定地图 20080416
    function ConditionOfCHECKDEARONMAP(PlayObject: TPlayObject;QuestConditionInfo: pTQuestConditionInfo): Boolean;
    //检测对面是否为自己的徒弟 20080416
    function ConditionOfCHECKPOSEISPRENTICE(PlayObject: TPlayObject;QuestConditionInfo: pTQuestConditionInfo): Boolean;
    //检查是否在攻城期间 20080422
    function ConditionOfCHECKCASTLEWAR(PlayObject: TPlayObject;QuestConditionInfo: pTQuestConditionInfo): Boolean;

    function ConditionOfFINDMAPPATH(PlayObject: TPlayObject;QuestConditionInfo: pTQuestConditionInfo): Boolean; //设置地图的起终XY值 20080124
    //检测英雄的忠诚度 20080109
    function ConditionOfCHECKHEROLOYAL(PlayObject: TPlayObject;QuestConditionInfo: pTQuestConditionInfo): Boolean;
    //判断是否在酿哪种酒 20080620
    function ConditionOfISONMAKEWINE(PlayObject: TPlayObject;QuestConditionInfo: pTQuestConditionInfo): Boolean;
    //判断是否开启行会泉水仓库 20080625
    function ConditionOfCHECKGUILDFOUNTAIN(PlayObject: TPlayObject;QuestConditionInfo: pTQuestConditionInfo): Boolean;

    function ConditionOfCheckGamePoint(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckNameListPostion(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckReNewLevel(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckSlaveLevel(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCHECKSLAVETOPEST(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckSlaveName(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckCreditPoint(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckOfGuild(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckPayMent(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckUseItem(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckBagSize(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;


    function ConditionOfCheckDC(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckMC(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckSC(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckHP(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckMP(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckItemType(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckExp(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckCastleGold(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckPasswordErrorCount(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfIsLockPassword(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfIsLockStorage(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckGuildBuildPoint(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckGuildAuraePoint(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckStabilityPoint(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckFlourishPoint(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckContribution(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckRangeMonCount(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    //检测地图命令  20080426
    function ConditionOfISONMAP(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    //检查人物身上物品的附加属性值  20080426
    function ConditionOfCheckItemAddValue(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckItemAddValueEx(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckInMapRange(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckIsAttackGuild(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckIsDefenseGuild(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckCastleDoorStatus(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckIsAttackAllyGuild(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckIsDefenseAllyGuild(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckCastleChageDay(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckCastleWarDay(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckOnlineLongMin(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckChiefItemCount(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckNameDateList(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckMapHumanCount(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckMapHumAICount(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckMapMonCount(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckVar(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckServerName(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckMapName(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckSafeZone(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckSkill(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查人物技能
    function ConditionOfHEROCHECKSKILL(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查英雄技能 20080423
    function ConditionOfAnsiContainsText(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCompareText(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckMonMapCount(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckStationTime(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckHasHero(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckDeputyHero(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查召唤出来的英雄是否为副将英雄
    function ConditionOfCheckHeroAutoPractice(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查副将英雄是否正在自我修炼
    function ConditionOfCheckHeroOnline(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckHeroLevel(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCHECKMINE(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检测矿纯度 20080324
    function ConditionOfCHECKHEARMSGCOLOR(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检测人物是否正在使用改变颜色功能
    function ConditionOfMapHumIsSameGuild(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检测当前地图中的人物是否属于同一个行会 20090307
    function ConditionOfCHECKOnlinePlayCount(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckPlaylvl(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckPlayJob(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function ConditionOfCheckPlaySex(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;

    function ConditionOfCheckAutoAddExpPlay(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查服务器挂机人数 20090719
    function ConditionOfCheckAIPlay(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查服务器假人数
    function ConditionOfCheckMap(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查地图是否存在
    function ConditionOfCheckItmeCountDura(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查物品数量以及持久值 20090913
    function ConditionOfCHECKITEMLEVEL(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查装备升级次数 20080816
    function ConditionOfCHECKBAGITEMLEVEL(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查包裹中装备升级次数
    function ConditionOfCHECKMAKEWINE(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检测酒的属性 20080806
    function ConditionOfCHECKHEROPKPOINT(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检测英雄PK值  20080304
    Function ConditionOfCheckHumInRange(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    Function ConditionOfCheckKimNeele(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查包裹是否有指定叠加物品
{$IF M2Version = 1}
    function ConditionOfCHECK4BATTERSKILL(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查是否开启第四连击
    function ConditionOfCheckHeroOpenPuls(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查英雄是否开通经脉系统(英雄不在线，没学内功都将为F)
    function ConditionOfCheckHeroPulsExp(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查英雄经络修炼点
    function ConditionOfCheckHumanPulse(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查是否跨穴点击 20090623
    function ConditionOfCheckOpenPulseLevel(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查打通穴位所需内功等级 20090623
    function ConditionOfCheckPulseLevel(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查各经络等级
{$IFEND}
    function ConditionOfCHECKPKPOINT(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检测PK值  20080506
    function ConditionOfCHECKCODELIST(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检测文本里的编码  20080410
    function ConditionOfCHECKITEMSTATE(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查装备绑定状态  20080312
    function ConditionOfCHECKITEMSNAME(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检查指定装备位置是否带有指定的物品 20080825
    function ConditionOfCHECKGUILDMEMBERCOUNT(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检测行会成员上限 20090115
    function ConditionOfCHECKGUILDCOUNT(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检测行会成员人数 20090607
    function ConditionOfCHECKGUILDFOUNTAINValue(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检测行会酒泉数 20081017
    function ConditionOfISHIGH(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;//检测服务器最高属性人物命令  20080313
    function ConditionOfCheckHeroJob(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
    function GetDynamicVarList(PlayObject: TPlayObject; sType: string; var sName: string): TList;
    function GetValValue(PlayObject: TPlayObject; sMsg: string; var sValue: string): Boolean; overload;
    function GetValValue(PlayObject: TPlayObject; sMsg: string; var nValue: Integer): Boolean; overload;

    function SetValValue(PlayObject: TPlayObject; sMsg: string; sValue: string): Boolean; overload;
    function SetValValue(PlayObject: TPlayObject; sMsg: string; nValue: Integer): Boolean; overload;

    function GetVarValueNew(PlayObject: TPlayObject; sData: string; var sValue: string): Boolean;
  public
    constructor Create(); override;
    destructor Destroy; override;
    procedure Initialize(); override;
    function Operate(ProcessMsg: pTProcessMessage): Boolean; override;
    procedure Run; override;
    procedure Click(PlayObject: TPlayObject); virtual;
    procedure UserSelect(PlayObject: TPlayObject; sData: string); virtual;
    procedure GetVariableText(PlayObject: TPlayObject; var sMsg: string; sVariable: string); virtual;
    function GetLineVariableText(PlayObject: TPlayObject; sMsg: string): string;
    procedure GotoLable(AObject: TPlayObject; sLabel: string; boExtJmp, boMmission: Boolean);
    function sub_49ADB8(sMsg, sStr, sText: string): string;
    procedure LoadNpcScript();
    procedure ClearScript(); virtual;
    procedure SendMsgToUser(PlayObject: TPlayObject; sMsg: string);
    procedure SendCustemMsg(PlayObject: TPlayObject; sMsg: string); virtual;
  end;
  
  TMerchant = class(TNormNpc)
    m_boRefreshName: Boolean;//刷新NPC名字(使用全局变量命名时) 20101224
    m_sScript: string;
    m_nPriceRate: Integer; //物品价格倍率 默认为 100%
    m_boCastle: Boolean;//是否属于城堡
    dwRefillGoodsTick: LongWord;
    dwClearExpreUpgradeTick: LongWord;
    m_ItemTypeList: TList; //NPC买卖物品类型列表，脚本中前面的 +1 +30 之类的
    m_RefillGoodsList: TList;
    m_GoodsList: TList;
    m_ItemPriceList: TList;//物品价格列表

    m_UpgradeWeaponList: TList;//武器升级列表
    m_boCanMove: Boolean;//是否可以移动
    m_dwMoveTime: LongWord;//移动时间
    m_dwMoveTick: LongWord;//移动间隔
    m_boBuy: Boolean;//是否可买卖
    m_boSell: Boolean;//NPC是否接收 玩家卖物品
    m_boMakeDrug: Boolean;
    m_boPrices: Boolean;
    m_boStorage: Boolean;
    m_boGetback: Boolean;//可以仓库取回物品
    m_boBigStorage: Boolean;
    m_boBigGetBack: Boolean;

    m_boUserLevelOrder: Boolean;
    m_boWarrorLevelOrder: Boolean;
    m_boWizardLevelOrder: Boolean;
    m_boTaoistLevelOrder: Boolean;
    m_boMasterCountOrder: Boolean;

    m_boGetNextPage: Boolean;
    m_boGetPreviousPage: Boolean;
    m_boCqFirHero: Boolean;//NPC 英雄相关NPC
    m_boBuHero: Boolean;//酒馆英雄相关NPC 20080514
    m_boPlayMakeWine: Boolean;//酿酒NPC
    m_boPlayDrink: Boolean;//玩家向NPC请酒,斗酒 20080515
    m_boYBDeal: Boolean;//NPC 元宝寄售属性 20080316
    m_boNewSignedItem : Boolean;//新鉴定用 By TasNat at: 2012-04-13 15:43:27
    m_boUpgradenow: Boolean;//武器升级
    m_boGetBackupgnow: Boolean;
    m_boRepair: Boolean;
    m_boArmsTear: Boolean;//武器拆卸赤炎石 20100708
    m_boArmsExchange: Boolean;//武器兑换卷轴碎片 20100809
    m_boS_repair: Boolean;
    m_boSendmsg: Boolean;
    m_boGetMarry: Boolean;
    m_boGetMaster: Boolean;
    m_boUseItemName: Boolean;

    //m_boGetSellGold: Boolean;//20080416 去掉拍卖功能
    //m_boSellOff: Boolean;//20080416 去掉拍卖功能
    //m_boBuyOff: Boolean;//20080416 去掉拍卖功能
    m_boofflinemsg: Boolean;
    m_boDealGold: Boolean;
  private
    procedure ClearExpreUpgradeListData();
    function GetRefillList(nIndex: Integer): TList;
    procedure AddItemPrice(nIndex, nPrice: Integer);
    function GetSellItemPrice(nPrice: Integer): Integer;
    function AddItemToGoodsList(UserItem: pTUserItem): Boolean;
    procedure GetBackupgWeapon(User: TPlayObject);
    procedure UpgradeWapon(User: TPlayObject);
    procedure ChangeUseItemName(PlayObject: TPlayObject; sLabel, sItemName: string);
    procedure SaveUpgradingList;
    //procedure GetMarry(PlayObject: TPlayObject; sDearName: string); //未使用 20080411
  public
    constructor Create(); override;
    destructor Destroy; override;
    function GetItemPrice(nIndex: Integer): Integer;
    function GetUserPrice(PlayObject: TPlayObject; nPrice: Integer): Integer;//取用户价格
    function CheckItemType(nStdMode: Integer): Boolean;
    procedure CheckItemPrice(nIndex: Integer);
    function GetUserItemPrice(UserItem: pTUserItem): Integer;
    function Operate(ProcessMsg: pTProcessMessage): Boolean; override;
    procedure Run; override;
    procedure UserSelect(PlayObject: TPlayObject; sData: string); override;
    procedure LoadNPCData();
    procedure SaveNPCData();
    procedure LoadUpgradeList();
    procedure RefillGoods();
    procedure LoadNpcScript();
    procedure Click(PlayObject: TPlayObject); override;
    procedure ClearScript(); override;
    procedure ClearData();
    procedure GetVariableText(PlayObject: TPlayObject; var sMsg: string; sVariable: string); override; //FFE9
    procedure ClientBuyItem(PlayObject: TPlayObject; sItemName: string; nInt: Integer);
    procedure ClientGetDetailGoodsList(PlayObject: TPlayObject; sItemName: string; nInt: Integer);
    {$IF M2Version <> 2}
    procedure ClientQueryArmsExchangeCount(PlayObject: TPlayObject; UserItem: pTUserItem);//取装备可交换的卷轴碎片数量 20100812
    function ClientArmsExhangeItem(PlayObject: TPlayObject; UserItem: pTUserItem): Boolean;//客户端兑换卷轴碎片 20100812
    {$IFEND}
    procedure ClientQuerySellPrice(PlayObject: TPlayObject; UserItem: pTUserItem);
    function ClientSellItem(PlayObject: TPlayObject; UserItem: pTUserItem): Boolean;
    procedure ClientMakeDrugItem(PlayObject: TPlayObject; sItemName: string);
    procedure ClientQueryRepairCost(PlayObject: TPlayObject; UserItem: pTUserItem);
    function ClientRepairItem(PlayObject: TPlayObject; UserItem: pTUserItem): Boolean;
    procedure SendCustemMsg(PlayObject: TPlayObject; sMsg: string); override;    
      //20080416 去掉拍卖功能
    {procedure ClientGetDetailSellGoodsList(PlayObject: TPlayObject; sItemName: string; nInt: Integer); //004A26F0
    function ClientSellOffItem(PlayObject: TPlayObject; SellOffInfo: pTSellOffInfo; sName: string): Boolean; //004A1CD8
    procedure ClientBuySellOffItem(PlayObject: TPlayObject; sItemName: string; nInt: Integer); //004A2334 }
  end;
  TGuildOfficial = class(TNormNpc)
  private
    function ReQuestBuildGuild(PlayObject: TPlayObject; sGuildName: string): Integer;//创建行会
    function ReQuestGuildWar(PlayObject: TPlayObject; sGuildName: string): Integer;
    procedure DoNate(PlayObject: TPlayObject);
    procedure ReQuestCastleWar(PlayObject: TPlayObject; sIndex: string);
  public
    constructor Create(); override;
    destructor Destroy; override;
    procedure GetVariableText(PlayObject: TPlayObject; var sMsg: string; sVariable: string); override; //FFE9
    procedure Run; override; //FFFB
    procedure Click(PlayObject: TPlayObject); override; //FFEB
    procedure UserSelect(PlayObject: TPlayObject; sData: string); override; //FFEA
    procedure SendCustemMsg(PlayObject: TPlayObject; sMsg: string); override;
  end;
  TTrainer = class(TNormNpc) //练功师
    m_dw568: LongWord;
    n56C: Integer;//练功师受攻击时统计总破坏力
    n570: Integer;
  private
  public
    constructor Create(); override;
    destructor Destroy; override;
    function Operate(ProcessMsg: pTProcessMessage): Boolean; override;
    procedure Run; override;
  end;
  //  TCastleManager = class(TMerchant)
  TCastleOfficial = class(TMerchant)
  private
    procedure HireArcher(sIndex: string; PlayObject: TPlayObject);//聘请弓箭手
    procedure HireGuard(sIndex: string; PlayObject: TPlayObject);//聘请守卫
    procedure RepairDoor(PlayObject: TPlayObject);
    procedure RepairWallNow(nWallIndex: Integer; PlayObject: TPlayObject);
  public
    constructor Create(); override;
    destructor Destroy; override;
    procedure Click(PlayObject: TPlayObject); override;
    procedure UserSelect(PlayObject: TPlayObject; sData: string); override;
    procedure GetVariableText(PlayObject: TPlayObject; var sMsg: string; sVariable: string); override;
    procedure SendCustemMsg(PlayObject: TPlayObject; sMsg: string); override;
  end;
implementation

uses Castle, M2Share, HUtil32, LocalDB, Envir, Guild, EDcode, ObjMon2, UsrEngn,
  Event, PlugIn, ObjPlayMon, ObjHero, PlugOfEngine, svMain, ObjAIPlayObject,
  MapPoint, ObjMon, Division;

function TScriptObject.GetBaseObject(NPC: TNormNpc; PlayObject: TPlayObject): TBaseObject;
var
  I: Integer;
  sCharName: string;
//  OnlineUser: TPlayObject;
  BaseObject: TBaseObject;
  sValue: string;
begin
  if Length(ScriptCmd) <= 0 then begin
    Result := PlayObject;
  end else begin
    BaseObject := PlayObject;
    for I := 0 to Length(ScriptCmd) - 1 do begin
      case ScriptCmd[I] of
        CMD_RACE_0: begin //self 自已
            BaseObject := PlayObject;
          end;
        CMD_RACE_1: begin //hero 英雄
            if (BaseObject <> nil) and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
              {$IF HEROVERSION = 1}
              BaseObject := TPlayObject(BaseObject).m_MyHero;
              {$IFEND}
            end else begin
              BaseObject := nil;
              Break;
            end;
          end;
        CMD_RACE_2: begin //Master
            {if (BaseObject <> nil) then begin
              BaseObject := BaseObject.m_Master;
            end else begin
              BaseObject := nil;
              Break;
            end;}
          end;
        CMD_RACE_3: begin //mon
           { if (BaseObject <> nil) then begin
              BaseObject := ActorObject.m_KillTargetCret;
            end else begin
              BaseObject := nil;
              Break;
            end; }
          end;
        CMD_RACE_4: begin //obj
            if (BaseObject <> nil) then begin
              case BaseObject.m_btRaceServer of
                RC_PLAYOBJECT: begin
                    NPC.GetVarValueNew(TPlayObject(BaseObject), ScriptList[I], sValue);
                    sCharName := sValue;
                  end;
                RC_HEROOBJECT: begin
                    if BaseObject.m_Master <> nil then begin
                      NPC.GetVarValueNew(TPlayObject(BaseObject.m_Master), ScriptList[I], sValue);
                      sCharName := sValue;
                    end;
                  end;
                else sCharName := ScriptList[I];
              end;
              BaseObject := UserEngine.GetPlayObject(sCharName);
            end else begin
              BaseObject := nil;
              Break;
            end;
          end;
      else Break;
      end;
    end;
    Result := BaseObject;
  end;
end;

function TScriptObject.Cmd(sCmd: string): string;
var
  TempList: TStringList;
  sCheckType: string;
  I: Integer;
begin
  SetLength(ScriptCmd, 0);
  SetLength(ScriptList, 0);
  Result := sCmd;
  if Pos('.', sCmd) > 0 then begin
    TempList := TStringList.Create;
    try
      ExtractStrings(['.'], [], PChar(sCmd), TempList);
      Result := UpperCase(Trim(TempList.Strings[TempList.Count - 1]));
      TempList.Delete(TempList.Count - 1);
      TempList.Strings[0] := UpperCase(Trim(TempList.Strings[0]));
      if TempList.Strings[0] <> 'SELF' then TempList.Insert(0, 'SELF');
      SetLength(ScriptCmd, TempList.Count);
      SetLength(ScriptList, TempList.Count);
      for I := 0 to TempList.Count - 1 do begin
        sCheckType := UpperCase(Trim(TempList.Strings[I]));
        if sCheckType = 'SELF' then begin//自已
          ScriptCmd[I] := CMD_RACE_0;
        end else
          if (sCheckType = 'H') or (sCheckType = 'HERO') then begin//英雄
          ScriptCmd[I] := CMD_RACE_1;
        {end else
          if UpperCase(Trim(TempList.Strings[I])) = 'MASTER' then begin
          ScriptCmd[I] := CMD_RACE_2;
        end else
          if UpperCase(Trim(TempList.Strings[I])) = 'MON' then begin
          ScriptCmd[I] := CMD_RACE_3;}
        end else begin
          ScriptCmd[I] := CMD_RACE_4;
        end;
        ScriptList[I] := UpperCase(Trim(TempList.Strings[I]));
      end;
    finally
      TempList.Free;
    end;
  end;
end;

procedure TCastleOfficial.Click(PlayObject: TPlayObject);
begin
  try
    if m_Castle = nil then begin
      PlayObject.SysMsg('NPC不属于城堡！！！', c_Red, t_Hint);
      Exit;
    end;
    if TUserCastle(m_Castle).IsMasterGuild(TGUild(PlayObject.m_MyGuild)) or (PlayObject.m_btPermission >= 3) then
      inherited;
  except
    MainOutMessage(Format('{%s} TCastleOfficial.Click',[g_sExceptionVer]));
  end;
end;

procedure TCastleOfficial.GetVariableText(PlayObject: TPlayObject;
  var sMsg: string; sVariable: string);
var
  sText: string;
  CastleDoor: TCastleDoor;
begin
  try
    inherited;
    if m_Castle = nil then begin
      sMsg := '????';
      Exit;
    end;
    if sVariable = '$CASTLEGOLD' then begin
      sText := IntToStr(TUserCastle(m_Castle).m_nTotalGold);
      sMsg := sub_49ADB8(sMsg, '<$CASTLEGOLD>', sText);
    end else
      if sVariable = '$TODAYINCOME' then begin
      sText := IntToStr(TUserCastle(m_Castle).m_nTodayIncome);
      sMsg := sub_49ADB8(sMsg, '<$TODAYINCOME>', sText);
    end else
      if sVariable = '$CASTLEDOORSTATE' then begin
      CastleDoor := TCastleDoor(TUserCastle(m_Castle).m_MainDoor.BaseObject);
      if CastleDoor.m_boDeath then sText := '损坏'
      else if CastleDoor.m_boOpened then sText := '开启'
      else sText := '关闭';
      sMsg := sub_49ADB8(sMsg, '<$CASTLEDOORSTATE>', sText);
    end else
      if sVariable = '$REPAIRDOORGOLD' then begin
      sText := IntToStr(g_Config.nRepairDoorPrice);
      sMsg := sub_49ADB8(sMsg, '<$REPAIRDOORGOLD>', sText);
    end else
      if sVariable = '$REPAIRWALLGOLD' then begin
      sText := IntToStr(g_Config.nRepairWallPrice);
      sMsg := sub_49ADB8(sMsg, '<$REPAIRWALLGOLD>', sText);
    end else
      if sVariable = '$GUARDFEE' then begin
      sText := IntToStr(g_Config.nHireGuardPrice);
      sMsg := sub_49ADB8(sMsg, '<$GUARDFEE>', sText);
    end else
      if sVariable = '$ARCHERFEE' then begin
      sText := IntToStr(g_Config.nHireArcherPrice);
      sMsg := sub_49ADB8(sMsg, '<$ARCHERFEE>', sText);
    end else
      if sVariable = '$GUARDRULE' then begin
      sText := '无效';
      sMsg := sub_49ADB8(sMsg, '<$GUARDRULE>', sText);
    end;
  except
    MainOutMessage(Format('{%s} TCastleOfficial.GetVariableText',[g_sExceptionVer]));
  end;
end;

procedure TCastleOfficial.UserSelect(PlayObject: TPlayObject; sData: string);
var
  s18, s20, sMsg, sLabel: string;
  boCanJmp: Boolean;
resourcestring
  sExceptionMsg = '{%s} TCastleManager::UserSelect... ';
begin
  inherited;
  try
    //    PlayObject.m_nScriptGotoCount:=0;
    if m_Castle = nil then begin
      PlayObject.SysMsg('NPC不属于城堡！！！', c_Red, t_Hint);
      Exit;
    end;
    if (sData <> '') and (sData[1] = '@') then begin
      sMsg := GetValidStr3(sData, sLabel, [#13]);
      s18 := '';
      PlayObject.m_sScriptLable := sData;
      if TUserCastle(m_Castle).IsMasterGuild(TGUild(PlayObject.m_MyGuild)) {and (PlayObject.IsGuildMaster)} then begin//20080803 修改
        boCanJmp := PlayObject.LableIsCanJmp(sLabel);
        if CompareText(sLabel, sSL_SENDMSG) = 0 then begin
          if sMsg = '' then Exit;
        end;
        GotoLable(PlayObject, sLabel, not boCanJmp, False);
        //GotoLable(PlayObject,sLabel,not PlayObject.LableIsCanJmp(sLabel));
        if not boCanJmp then Exit;
        if CompareText(sLabel, sSL_SENDMSG) = 0 then begin
          SendCustemMsg(PlayObject, sMsg);
          PlayObject.SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, s18);
        end else
          if CompareText(sLabel, sCASTLENAME) = 0 then begin
            if PlayObject.IsGuildMaster then begin//20080803 增加
              sMsg := Trim(sMsg);
              if sMsg <> '' then begin
                TUserCastle(m_Castle).m_sName := sMsg;
                TUserCastle(m_Castle).Save;
                TUserCastle(m_Castle).m_MasterGuild.RefMemberName;
                s18 := '城堡名称更改成功...';
              end else begin
                s18 := '城堡名称更改失败！！！';
              end;
              PlayObject.SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, s18);
            end;
        end else
          if CompareText(sLabel, sWITHDRAWAL) = 0 then begin//取回金币
          case TUserCastle(m_Castle).WithDrawalGolds(PlayObject, Str_ToInt(sMsg, 0)) of
            -4: s18 := '输入的金币数不正确！！！';
            -3: s18 := '您无法携带更多的东西了。';
            -2: s18 := '该城内没有这么多金币.';
            -1: s18 := '只有行会 ' + TUserCastle(m_Castle).m_sOwnGuild + ' 的掌门人才能使用！！！';
            1: GotoLable(PlayObject, sMAIN, False, False);
          end;
          PlayObject.SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, s18);
        end else
          if CompareText(sLabel, sRECEIPTS) = 0 then begin//沙巴克存资金
          case TUserCastle(m_Castle).ReceiptGolds(PlayObject, Str_ToInt(sMsg, 0)) of
            -4: s18 := '输入的金币数不正确！！！';
            -3: s18 := '您已经达到在城内存放货物的限制了。';
            -2: s18 := '您没有那么多金币.';
            -1: s18 := '只有行会 ' + TUserCastle(m_Castle).m_sOwnGuild + ' 的掌门人才能使用！！！';
            1: GotoLable(PlayObject, sMAIN, False, False);
          end;
          PlayObject.SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, s18);
        end else
          if CompareText(sLabel, sOPENMAINDOOR) = 0 then begin//打开城门
          if PlayObject.IsGuildMaster then TUserCastle(m_Castle).MainDoorControl(False);//20080803 增加
        end else
          if CompareText(sLabel, sCLOSEMAINDOOR) = 0 then begin//关闭城门
          if PlayObject.IsGuildMaster then TUserCastle(m_Castle).MainDoorControl(True);//20080803 增加
        end else
          if CompareText(sLabel, sREPAIRDOORNOW) = 0 then begin//马上修复城门
            if PlayObject.IsGuildMaster then begin//20080803 增加
              RepairDoor(PlayObject);
              GotoLable(PlayObject, sMAIN, False, False);
            end;
        end else
          if CompareText(sLabel, sREPAIRWALLNOW1) = 0 then begin//修城墙一
            if PlayObject.IsGuildMaster then begin//20080803 增加
              RepairWallNow(1, PlayObject);
              GotoLable(PlayObject, sMAIN, False, False);
            end;
        end else
          if CompareText(sLabel, sREPAIRWALLNOW2) = 0 then begin//修城墙二
            if PlayObject.IsGuildMaster then begin//20080803 增加
              RepairWallNow(2, PlayObject);
              GotoLable(PlayObject, sMAIN, False, False);
            end;
        end else
          if CompareText(sLabel, sREPAIRWALLNOW3) = 0 then begin//修城墙三
            if PlayObject.IsGuildMaster then begin//20080803 增加
              RepairWallNow(3, PlayObject);
              GotoLable(PlayObject, sMAIN, False, False);
            end;
        end else
          if CompareLStr(sLabel, sHIREGUARDNOW, 13{Length(sHIREGUARDNOW)}) then begin
            if PlayObject.IsGuildMaster then begin//20080803 增加
              s20 := Copy(sLabel, Length(sHIREGUARDNOW) + 1, Length(sLabel));
              HireGuard(s20, PlayObject);
              PlayObject.SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '');
              //GotoLable(PlayObject,sHIREGUARDOK,False);
            end;
        end else
          if CompareLStr(sLabel, sHIREARCHERNOW, 13{Length(sHIREARCHERNOW)}) then begin
            if PlayObject.IsGuildMaster then begin//20080803 增加
              s20 := Copy(sLabel, Length(sHIREARCHERNOW) + 1, Length(sLabel));
              HireArcher(s20, PlayObject);
              PlayObject.SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '');
            end;
        end else
          if CompareText(sLabel, sEXIT) = 0 then begin
          PlayObject.SendMsg(Self, RM_MERCHANTDLGCLOSE, 0, Integer(Self), 0, 0, '');
        end else
          if CompareText(sLabel, sBACK) = 0 then begin
          if PlayObject.m_sScriptGoBackLable = '' then PlayObject.m_sScriptGoBackLable := sMAIN;
          GotoLable(PlayObject, PlayObject.m_sScriptGoBackLable, False, False);
        end;
      end else begin
        s18 := '您没有权利使用';
        PlayObject.SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, s18);
      end;
    end;
  except
    MainOutMessage(Format(sExceptionMsg,[g_sExceptionVer]));
  end;
  //  inherited;
end;

procedure TCastleOfficial.HireGuard(sIndex: string; PlayObject: TPlayObject);
var
  n10: Integer;
  ObjUnit: pTObjUnit;
begin
try
  if m_Castle = nil then begin
    PlayObject.SysMsg('NPC不属于城堡！！！', c_Red, t_Hint);
    Exit;
  end;
  if TUserCastle(m_Castle).m_nTotalGold >= g_Config.nHireGuardPrice then begin
    n10 := Str_ToInt(sIndex, 0) - 1;
    if n10 <= MAXCALSTEGUARD then begin
      if TUserCastle(m_Castle).m_Guard[n10].BaseObject = nil then begin
        if not TUserCastle(m_Castle).m_boUnderWar then begin
          ObjUnit := @TUserCastle(m_Castle).m_Guard[n10];
          ObjUnit.BaseObject := UserEngine.RegenMonsterByName(TUserCastle(m_Castle).m_sMapName, ObjUnit.nX, ObjUnit.nY, ObjUnit.sName);
          if ObjUnit.BaseObject <> nil then begin
            if TUserCastle(m_Castle).m_nTotalGold >= g_Config.nHireGuardPrice then begin//20090424 修改
              Dec(TUserCastle(m_Castle).m_nTotalGold, g_Config.nHireGuardPrice);
            end else TUserCastle(m_Castle).m_nTotalGold:= 0;
            ObjUnit.BaseObject.m_Castle := TUserCastle(m_Castle);
            TGuardUnit(ObjUnit.BaseObject).m_nX550 := ObjUnit.nX;
            TGuardUnit(ObjUnit.BaseObject).m_nY554 := ObjUnit.nY;
            TGuardUnit(ObjUnit.BaseObject).m_nDirection := 3;
            PlayObject.SysMsg('雇佣成功.', c_Green, t_Hint);
          end;
        end else begin
          PlayObject.SysMsg('现在无法雇佣！！！', c_Red, t_Hint);
        end;
      end else begin
         PlayObject.SysMsg('早已雇佣！！！', c_Red, t_Hint);//20080803 增加
      end;
    end else begin
      PlayObject.SysMsg('指令错误！！！', c_Red, t_Hint);
    end;
  end else begin
    PlayObject.SysMsg('城内资金不足！！！', c_Red, t_Hint);
  end;
  {
  if UserCastle.m_nTotalGold >= g_Config.nHireGuardPrice then begin
    n10:=Str_ToInt(sIndex,0) - 1;
    if n10 <= MAXCALSTEGUARD then begin
      if UserCastle.m_Guard[n10].BaseObject = nil then begin
        if not UserCastle.m_boUnderWar then begin
          ObjUnit:=@UserCastle.m_Guard[n10];
          ObjUnit.BaseObject:=UserEngine.RegenMonsterByName(UserCastle.m_sMapName,
                                                          ObjUnit.nX,
                                                          ObjUnit.nY,
                                                          ObjUnit.sName);
          if ObjUnit.BaseObject <> nil then begin
            Dec(UserCastle.m_nTotalGold,g_Config.nHireGuardPrice);
            ObjUnit.BaseObject.m_Castle:=UserCastle;
            TGuardUnit(ObjUnit.BaseObject).m_nX550:=ObjUnit.nX;
            TGuardUnit(ObjUnit.BaseObject).m_nY554:=ObjUnit.nY;
            TGuardUnit(ObjUnit.BaseObject).m_n558:=3;
            PlayObject.SysMsg('雇佣成功.',c_Green,t_Hint);
          end;

        end else begin
          PlayObject.SysMsg('现在无法雇佣！！！',c_Red,t_Hint);
        end;
      end
    end else begin
      PlayObject.SysMsg('指令错误！！！',c_Red,t_Hint);
    end;
  end else begin
    PlayObject.SysMsg('城内资金不足！！！',c_Red,t_Hint);
  end;
  }
except
  MainOutMessage(Format('{%s} TCastleOfficial.HireGuard',[g_sExceptionVer]));
end;
end;

procedure TCastleOfficial.HireArcher(sIndex: string; PlayObject: TPlayObject);
var
  n10: Integer;
  ObjUnit: pTObjUnit;
begin
  try
    if m_Castle = nil then begin
      PlayObject.SysMsg('NPC不属于城堡！！！', c_Red, t_Hint);
      Exit;
    end;
    if TUserCastle(m_Castle).m_nTotalGold >= g_Config.nHireArcherPrice then begin
      n10 := Str_ToInt(sIndex, 0) - 1;
      if n10 <= MAXCASTLEARCHER then begin
        if TUserCastle(m_Castle).m_Archer[n10].BaseObject = nil then begin
          if not TUserCastle(m_Castle).m_boUnderWar then begin
            ObjUnit := @TUserCastle(m_Castle).m_Archer[n10];
            ObjUnit.BaseObject := UserEngine.RegenMonsterByName(TUserCastle(m_Castle).m_sMapName, ObjUnit.nX, ObjUnit.nY, ObjUnit.sName);
            if ObjUnit.BaseObject <> nil then begin
              if TUserCastle(m_Castle).m_nTotalGold >= g_Config.nHireArcherPrice then begin
                Dec(TUserCastle(m_Castle).m_nTotalGold, g_Config.nHireArcherPrice);
              end else TUserCastle(m_Castle).m_nTotalGold:= 0;
              ObjUnit.BaseObject.m_Castle := TUserCastle(m_Castle);
              TGuardUnit(ObjUnit.BaseObject).m_nX550 := ObjUnit.nX;
              TGuardUnit(ObjUnit.BaseObject).m_nY554 := ObjUnit.nY;
              TGuardUnit(ObjUnit.BaseObject).m_nDirection := 3;
              PlayObject.SysMsg('雇佣成功.', c_Green, t_Hint);
            end;
          end else begin
            PlayObject.SysMsg('现在无法雇佣！！！', c_Red, t_Hint);
          end;
        end else begin
          PlayObject.SysMsg('早已雇佣！！！', c_Red, t_Hint);
        end;
      end else begin
        PlayObject.SysMsg('指令错误！！！', c_Red, t_Hint);
      end;
    end else begin
      PlayObject.SysMsg('城内资金不足！！！', c_Red, t_Hint);
    end;
    {
    if UserCastle.m_nTotalGold >= g_Config.nHireArcherPrice then begin
      n10:=Str_ToInt(sIndex,0) - 1;
      if n10 <= MAXCASTLEARCHER then begin
        if UserCastle.m_Archer[n10].BaseObject = nil then begin
          if not UserCastle.m_boUnderWar then begin
            ObjUnit:=@UserCastle.m_Archer[n10];
            ObjUnit.BaseObject:=UserEngine.RegenMonsterByName(UserCastle.m_sMapName,
                                                            ObjUnit.nX,
                                                            ObjUnit.nY,
                                                            ObjUnit.sName);
            if ObjUnit.BaseObject <> nil then begin
              Dec(UserCastle.m_nTotalGold,g_Config.nHireArcherPrice);
              ObjUnit.BaseObject.m_Castle:=UserCastle;
              TGuardUnit(ObjUnit.BaseObject).m_nX550:=ObjUnit.nX;
              TGuardUnit(ObjUnit.BaseObject).m_nY554:=ObjUnit.nY;
              TGuardUnit(ObjUnit.BaseObject).m_n558:=3;
              PlayObject.SysMsg('雇佣成功.',c_Green,t_Hint);
            end;

          end else begin
            PlayObject.SysMsg('现在无法雇佣！！！',c_Red,t_Hint);
          end;
        end else begin
          PlayObject.SysMsg('早已雇佣！！！',c_Red,t_Hint);
        end;
      end else begin
        PlayObject.SysMsg('指令错误！！！',c_Red,t_Hint);
      end;
    end else begin
      PlayObject.SysMsg('城内资金不足！！！',c_Red,t_Hint);
    end;
    }
  except
    MainOutMessage(Format('{%s} TCastleOfficial.HireArcher',[g_sExceptionVer]));
  end;
end;
{ TMerchant }
//增加物品价格
procedure TMerchant.AddItemPrice(nIndex: Integer; nPrice: Integer);
var
  ItemPrice: pTItemPrice;
begin
  try
    New(ItemPrice);
    ItemPrice.wIndex := nIndex;
    ItemPrice.nPrice := nPrice;
    m_ItemPriceList.Add(ItemPrice);
    FrmDB.SaveGoodPriceRecord(Self, m_sScript + '-' + m_sMapName);
  except
    MainOutMessage(Format('{%s} TMerchant.AddItemPrice',[g_sExceptionVer]));
  end;
end;
//检查物品价格
procedure TMerchant.CheckItemPrice(nIndex: Integer);
var
  I: Integer;
  ItemPrice: pTItemPrice;
  //n10: Integer;
  StdItem: pTStdItem;
begin
try
  if m_ItemPriceList.Count > 0 then begin//20080629
    for I := 0 to m_ItemPriceList.Count - 1 do begin
      ItemPrice := m_ItemPriceList.Items[I];
      if ItemPrice = nil then Continue;
      if ItemPrice.wIndex = nIndex then begin
        {n10 := ItemPrice.nPrice; //20110529 注释
        if Round(n10 * 1.1) > n10 then begin
          n10 := Round(n10 * 1.1);
        end else Inc(n10);}
        Exit;
      end;
    end;
  end;
  StdItem := UserEngine.GetStdItem(nIndex);
  if StdItem <> nil then begin//增加物品价格
    AddItemPrice(nIndex, Round(StdItem.Price * 1.1));//物品价格为DB库的1.1倍
  end;
except
  MainOutMessage(Format('{%s} TMerchant.CheckItemPrice',[g_sExceptionVer]));
end;
end;

function TMerchant.GetRefillList(nIndex: Integer): TList;
var
  I: Integer;
  List: TList;
begin
  Result := nil;
  try  
    if nIndex <= 0 then Exit;
    if m_GoodsList.Count > 0 then begin
      for I := 0 to m_GoodsList.Count - 1 do begin
        List := TList(m_GoodsList.Items[I]);
        if List = nil then Continue;
        if List.Count > 0 then begin
          if pTUserItem(List.Items[0]).wIndex = nIndex then begin
            Result := List;
            Break;
          end;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TMerchant.GetRefillList',[g_sExceptionVer]));
  end;
end;
//刷新NPC出售物品列表 占CPU
procedure TMerchant.RefillGoods;
  procedure RefillItems(var List: TList; sItemName: string; nInt: Integer);
  var
    I: Integer;
    UserItem: pTUserItem;
  begin
    if nInt <= 0 then Exit;//20110529
    if List = nil then begin
      List := TList.Create;
      m_GoodsList.Add(List);
    end;
    for I := 0 to nInt - 1 do begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
        List.Insert(0, UserItem);
      end else Dispose(UserItem);
    end;
  end;
  procedure DelReFillItem(var List: TList; nInt: Integer);
  var
    I: Integer;
  begin
    for I := List.Count - 1 downto 0 do begin
      if (nInt <= 0) or (List.Count <= 0) then Break;
      if pTUserItem(List.Items[I]) <> nil then begin
        Dispose(pTUserItem(List.Items[I]));
      end;
      List.Delete(I);
      Dec(nInt);
    end;
  end;
var
  I, II: Integer;
  Goods: pTGoods;
  nIndex, nRefillCount: Integer;
  RefillList, RefillList20: TList;
  bo21: Boolean;
resourcestring
  sExceptionMsg = '{%s} TMerchant::RefillGoods %s/%d:%d';
begin
  try
    if m_RefillGoodsList.Count > 0 then begin//20081008
      for I := 0 to m_RefillGoodsList.Count - 1 do begin
        Goods := m_RefillGoodsList.Items[I];
        if Goods = nil then Continue;
        if Goods <> nil then begin
          if (GetTickCount - Goods.dwRefillTick) > Goods.dwRefillTime then begin
            Goods.dwRefillTick := GetTickCount();
            nIndex := UserEngine.GetStdItemIdx(Goods.sItemName);
            if nIndex >= 0 then begin
              RefillList := GetRefillList(nIndex);
              nRefillCount := 0;
              if RefillList <> nil then nRefillCount := RefillList.Count;
              if Goods.nCount > nRefillCount then begin//数量不够则创建
                CheckItemPrice(nIndex);//检查价格，如不存在则创建
                RefillItems(RefillList, Goods.sItemName, Goods.nCount - nRefillCount);
                FrmDB.SaveGoodRecord(Self, m_sScript + '-' + m_sMapName);
                FrmDB.SaveGoodPriceRecord(Self, m_sScript + '-' + m_sMapName);
              end;
              if Goods.nCount < nRefillCount then begin //超过总数则删除多余物品
                DelReFillItem(RefillList, nRefillCount - Goods.nCount);
                FrmDB.SaveGoodRecord(Self, m_sScript + '-' + m_sMapName);
                FrmDB.SaveGoodPriceRecord(Self, m_sScript + '-' + m_sMapName);
              end;
            end;
          end;
        end;
      end;//for
    end;
    if m_GoodsList.Count > 0 then begin
      for I := 0 to m_GoodsList.Count - 1 do begin
        RefillList20 := TList(m_GoodsList.Items[I]);
        if RefillList20 = nil then Continue;
        if RefillList20.Count > 1000 then begin
          bo21 := False;
          if m_RefillGoodsList.Count > 0 then begin
            for II := 0 to m_RefillGoodsList.Count - 1 do begin
              Goods := m_RefillGoodsList.Items[II];
              if Goods = nil then Continue;
              nIndex := UserEngine.GetStdItemIdx(Goods.sItemName);
              if (pTItemPrice(RefillList20.Items[0]) <> nil) then begin//20090129 修改
                if (pTItemPrice(RefillList20.Items[0]).wIndex = nIndex) then begin
                  bo21 := True;
                  Break;
                end;
              end;
            end;
          end;
          if not bo21 then begin
            DelReFillItem(RefillList20, RefillList20.Count - 1000);
          end else begin
            DelReFillItem(RefillList20, RefillList20.Count - 5000);
          end;
        end;
      end;//for
    end;
  except
    on E: Exception do
      MainOutMessage(Format(sExceptionMsg, [g_sExceptionVer, m_sCharName, m_nCurrX, m_nCurrY]));
  end;
end;
//检查物品类型
function TMerchant.CheckItemType(nStdMode: Integer): Boolean;
var
  I: Integer;
begin
  Result := False;
  try
    if m_ItemTypeList.Count > 0 then begin//20080629
      for I := 0 to m_ItemTypeList.Count - 1 do begin
        if Integer(m_ItemTypeList.Items[I]) = nStdMode then begin
          Result := True;
          Break;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TMerchant.CheckItemType',[g_sExceptionVer]));
  end;
end;
//取物品价格
function TMerchant.GetItemPrice(nIndex: Integer): Integer;
var
  I: Integer;
  ItemPrice: pTItemPrice;
  StdItem: pTStdItem;
begin
  Result := -1;
  try
    if m_ItemPriceList.Count > 0 then begin//如果存在出售列表中，则直接取价格
      for I := 0 to m_ItemPriceList.Count - 1 do begin
        ItemPrice := m_ItemPriceList.Items[I];
        if ItemPrice = nil then Continue;
        if ItemPrice.wIndex = nIndex then begin
          Result := ItemPrice.nPrice;
          Break;
        end;
      end; // for
    end;
    if Result < 0 then begin
      StdItem := UserEngine.GetStdItem(nIndex);
      if StdItem <> nil then begin
        if CheckItemType(StdItem.StdMode) then Result := StdItem.Price;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TMerchant.GetItemPrice',[g_sExceptionVer]));
  end;
end;
//保存升级武器列表
procedure TMerchant.SaveUpgradingList();
begin
  try
    FrmDB.SaveUpgradeWeaponRecord(m_sScript + '-' + m_sMapName, m_UpgradeWeaponList);
  except
    MainOutMessage('保存升级列表失败 - ' + m_sCharName);
  end;
end;
//升级武器
procedure TMerchant.UpgradeWapon(User: TPlayObject);
  procedure sub_4A0218(ItemList: TList; var btDc: Byte; var btSc: Byte; var btMc: Byte; var btDura: Byte);
  var
    I, II: Integer;
    DuraList: TList;
    UserItem: pTUserItem;
    StdItem: pTStdItem;
    StdItem80: TStdItem;
    DelItemList: TStringList;
    nDc, nSc, nMc, nDcMin, nDcMax, nScMin, nScMax, nMcMin, nMcMax, nDura, nItemCount: Integer;
  begin
    nDcMin := 0;
    nDcMax := 0;
    nScMin := 0;
    nScMax := 0;
    nMcMin := 0;
    nMcMax := 0;
    nDura := 0;
    nItemCount := 0;
    DelItemList := nil;
    DuraList := TList.Create;
    if ItemList.Count > 0 then begin//20080627
      for I := ItemList.Count - 1 downto 0 do begin
        if ItemList.Count <= 0 then Break;//20091113 增加
        UserItem := ItemList.Items[I];
        if UserItem <> nil then begin//20090326
          if UserEngine.GetStdItemName(UserItem.wIndex) = g_Config.sBlackStone then begin//是否是矿石
            DuraList.Add(Pointer(Round(UserItem.Dura / 1.0E3)));
            if DelItemList = nil then DelItemList := TStringList.Create;
            DelItemList.AddObject(g_Config.sBlackStone, TObject(UserItem.MakeIndex));
            Dispose(UserItem);
            ItemList.Delete(I);
          end else begin
            if IsUpgradeWaponUseItem(UserItem.wIndex) then begin
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem <> nil then begin
                StdItem80 := StdItem^;
                ItemUnit.GetItemAddValue(UserItem, StdItem80);
                nDc := 0;
                nSc := 0;
                nMc := 0;
                case StdItem80.StdMode of
                  19, 20, 21, 28: begin//项链
                      nDc := HiWord(StdItem80.DC) + LoWord(StdItem80.DC);
                      nSc := HiWord(StdItem80.SC) + LoWord(StdItem80.SC);
                      nMc := HiWord(StdItem80.MC) + LoWord(StdItem80.MC);
                    end;
                  22, 23, 27: begin//戒指 20100513
                      nDc := HiWord(StdItem80.DC) + LoWord(StdItem80.DC);
                      nSc := HiWord(StdItem80.SC) + LoWord(StdItem80.SC);
                      nMc := HiWord(StdItem80.MC) + LoWord(StdItem80.MC);
                    end;
                  24, 26: begin//手套
                      nDc := HiWord(StdItem80.DC) + LoWord(StdItem80.DC) + 1;
                      nSc := HiWord(StdItem80.SC) + LoWord(StdItem80.SC) + 1;
                      nMc := HiWord(StdItem80.MC) + LoWord(StdItem80.MC) + 1;
                    end;
                end;
                if nDcMin < nDc then begin
                  nDcMax := nDcMin;
                  nDcMin := nDc;
                end else begin
                  if nDcMax < nDc then nDcMax := nDc;
                end;
                if nScMin < nSc then begin
                  nScMax := nScMin;
                  nScMin := nSc;
                end else begin
                  if nScMax < nSc then nScMax := nSc;
                end;
                if nMcMin < nMc then begin
                  nMcMax := nMcMin;
                  nMcMin := nMc;
                end else begin
                  if nMcMax < nMc then nMcMax := nMc;
                end;
                if DelItemList = nil then DelItemList := TStringList.Create;
                DelItemList.AddObject(StdItem.Name, TObject(UserItem.MakeIndex));
                if StdItem.NeedIdentify = 1 then
                  AddGameDataLog('26' + #9 + User.m_sMapName + #9 +
                    IntToStr(User.m_nCurrX) + #9 + IntToStr(User.m_nCurrY) + #9 +
                    User.m_sCharName + #9 +StdItem.Name + #9 +
                    IntToStr(UserItem.MakeIndex) + #9 +
                    '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                    '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                    '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                    '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                    '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                    IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                    IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                    IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                    IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                Dispose(UserItem);
                ItemList.Delete(I);
              end;
            end;
          end;
        end;
      end; // for
    end;
    for I := 0 to DuraList.Count - 1 do begin
      if DuraList.Count <= 0 then Break;
      for II := DuraList.Count - 1 downto I + 1 do begin
        if Integer(DuraList.Items[II]) > Integer(DuraList.Items[II - 1]) then
          DuraList.Exchange(II, II - 1);
      end; // for
    end; // for
    if DuraList.Count > 0 then begin//20080627
      for I := 0 to DuraList.Count - 1 do begin
        nDura := nDura + Integer(DuraList.Items[I]);
        Inc(nItemCount);
        if nItemCount >= 5 then Break;
      end;
    end;
    btDura := Round(_MIN(5, nItemCount) + _MIN(5, nItemCount) * ((nDura / nItemCount) / 5.0));
    btDc := nDcMin div 5 + nDcMax div 3;
    btSc := nScMin div 5 + nScMax div 3;
    btMc := nMcMin div 5 + nMcMax div 3;
    if DelItemList <> nil then
      User.SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelItemList), 0, 0, '');
    if DuraList <> nil then DuraList.Free;
  end;
var
  I: Integer;
  bo0D: Boolean;
  UpgradeInfo: pTUpgradeInfo;
  StdItem: pTStdItem;
begin
  try
    bo0D := False;
    if m_UpgradeWeaponList.Count > 0 then begin//20080629
      for I := 0 to m_UpgradeWeaponList.Count - 1 do begin
        UpgradeInfo := m_UpgradeWeaponList.Items[I];
        if UpgradeInfo <> nil then begin//20090326
          if UpgradeInfo.sUserName = User.m_sCharName then begin
            GotoLable(User, sUPGRADEING, False, False);
            Exit;
          end;
        end;
      end;
    end;
    if (User.m_UseItems[U_WEAPON].wIndex <> 0) and (User.m_nGold >= g_Config.nUpgradeWeaponPrice) and
      (User.CheckItems(g_Config.sBlackStone) <> nil) and (not (User.m_UseItems[U_WEAPON].AddValue[0] in [1..3])) then begin//限时物品,绑定物品不能交)
      User.DecGold(g_Config.nUpgradeWeaponPrice);
      if m_boCastle or g_Config.boGetAllNpcTax then begin
        if m_Castle <> nil then begin
          TUserCastle(m_Castle).IncRateGold(g_Config.nUpgradeWeaponPrice);
        end else
          if g_Config.boGetAllNpcTax then begin
          g_CastleManager.IncRateGold(g_Config.nUpgradeWeaponPrice);
        end;
      end;
      User.GoldChanged();
      New(UpgradeInfo);
      FillChar(UpgradeInfo^, SizeOf(TUpgradeInfo), #0);//20080724 增加
      UpgradeInfo.sUserName := User.m_sCharName;
      UpgradeInfo.UserItem := User.m_UseItems[U_WEAPON];
      StdItem := UserEngine.GetStdItem(User.m_UseItems[U_WEAPON].wIndex);

      if StdItem <> nil then begin//20090326
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog('25' + #9 +
            User.m_sMapName + #9 +
            IntToStr(User.m_nCurrX) + #9 + IntToStr(User.m_nCurrY) + #9 +
            User.m_sCharName + #9 + StdItem.Name + #9 +
            IntToStr(User.m_UseItems[U_WEAPON].MakeIndex) + #9 +
            '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
            '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
            '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
            '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
            '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
            IntToStr(User.m_UseItems[U_WEAPON].btValue[0])+'/'+IntToStr(User.m_UseItems[U_WEAPON].btValue[1])+'/'+IntToStr(User.m_UseItems[U_WEAPON].btValue[2])+'/'+
            IntToStr(User.m_UseItems[U_WEAPON].btValue[3])+'/'+IntToStr(User.m_UseItems[U_WEAPON].btValue[4])+'/'+IntToStr(User.m_UseItems[U_WEAPON].btValue[5])+'/'+
            IntToStr(User.m_UseItems[U_WEAPON].btValue[6])+'/'+IntToStr(User.m_UseItems[U_WEAPON].btValue[7])+'/'+IntToStr(User.m_UseItems[U_WEAPON].btValue[8])+'/'+
            IntToStr(User.m_UseItems[U_WEAPON].btValue[14])+ #9 + IntToStr(User.m_UseItems[U_WEAPON].Dura)+'/'+IntToStr(User.m_UseItems[U_WEAPON].DuraMax));
      end;
      User.ClearCopyItem(0, User.m_UseItems[U_WEAPON].wIndex, User.m_UseItems[U_WEAPON].MakeIndex);//清理包裹和仓库复制物品 20080816
      User.SendDelItems(@User.m_UseItems[U_WEAPON]);
      User.m_UseItems[U_WEAPON].wIndex := 0;
      User.RecalcAbilitys();
      User.CompareSuitItem(False);//200080729 套装
      User.FeatureChanged();
      User.SendMsg(User, RM_ABILITY, 0, 0, 0, 0, '');
      sub_4A0218(User.m_ItemList, UpgradeInfo.btDc, UpgradeInfo.btSc, UpgradeInfo.btMc, UpgradeInfo.btDura);
      UpgradeInfo.dtTime := Now();
      UpgradeInfo.dwGetBackTick := GetTickCount();
      m_UpgradeWeaponList.Add(UpgradeInfo);
      SaveUpgradingList();//保存武器升级列表
      bo0D := True;
    end;
    if bo0D then GotoLable(User, sUPGRADEOK, False, False)
    else GotoLable(User, sUPGRADEFAIL, False, False);
  except
    MainOutMessage(Format('{%s} TMerchant.UpgradeWapon',[g_sExceptionVer]));
  end;
end;
//升级武器,取回武器
procedure TMerchant.GetBackupgWeapon(User: TPlayObject);
var
  I: Integer;
  UpgradeInfo: pTUpgradeInfo;
  n10, n18, n1C, n90: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
  try
    n18 := 0;
    UpgradeInfo := nil;
    if not User.IsEnoughBag then begin//背包已经满
      GotoLable(User, sGETBACKUPGFULL, False, False);
      Exit;
    end;
    for I := m_UpgradeWeaponList.Count - 1 downto 0 do begin
      if m_UpgradeWeaponList.Count <= 0 then Break;
      if pTUpgradeInfo(m_UpgradeWeaponList.Items[I]).sUserName = User.m_sCharName then begin
        n18 := 1;
        if ((GetTickCount - pTUpgradeInfo(m_UpgradeWeaponList.Items[I]).dwGetBackTick) > g_Config.dwUPgradeWeaponGetBackTime) or (User.m_btPermission >= 4) then begin
          UpgradeInfo := m_UpgradeWeaponList.Items[I];
          m_UpgradeWeaponList.Delete(I);
          SaveUpgradingList();//保存武器升级列表
          n18 := 2;
          Break;
        end;
      end;
    end;//for

    if (UpgradeInfo <> nil) and (n18 = 2) then begin//20080915 修改
      case UpgradeInfo.btDura of //
        0..8: begin 
            //n14:=_MAX(3000,UpgradeInfo.UserItem.DuraMax shr 1);
            if UpgradeInfo.UserItem.DuraMax > 3000 then begin
              Dec(UpgradeInfo.UserItem.DuraMax, 3000);
            end else begin
              UpgradeInfo.UserItem.DuraMax := UpgradeInfo.UserItem.DuraMax shr 1;
            end;
            if UpgradeInfo.UserItem.Dura > UpgradeInfo.UserItem.DuraMax then
              UpgradeInfo.UserItem.Dura := UpgradeInfo.UserItem.DuraMax;
          end;
        9..15: begin 
            if Random(UpgradeInfo.btDura) < 6 then begin
              if UpgradeInfo.UserItem.DuraMax > 1000 then
                Dec(UpgradeInfo.UserItem.DuraMax, 1000);
              if UpgradeInfo.UserItem.Dura > UpgradeInfo.UserItem.DuraMax then
                UpgradeInfo.UserItem.Dura := UpgradeInfo.UserItem.DuraMax;
            end;
          end;
        18..255: begin
            case Random(UpgradeInfo.btDura - 18) of
              1..4: Inc(UpgradeInfo.UserItem.DuraMax, 1000);
              5..7: Inc(UpgradeInfo.UserItem.DuraMax, 2000);
              8..255: Inc(UpgradeInfo.UserItem.DuraMax, 4000)
            end;
          end;
      end; // case
      if (UpgradeInfo.btDc = UpgradeInfo.btMc) and (UpgradeInfo.btMc = UpgradeInfo.btSc) then begin
        n1C := Random(3);
      end else begin
        n1C := -1;
      end;
      if ((UpgradeInfo.btDc >= UpgradeInfo.btMc) and (UpgradeInfo.btDc >= UpgradeInfo.btSc)) or (n1C = 0) then begin//加攻击
        n90 := _MIN(11, UpgradeInfo.btDc);
        n10 := _MIN(85, n90 shl 3 - n90 + 10 + UpgradeInfo.UserItem.btValue[3] - UpgradeInfo.UserItem.btValue[4] + User.m_nBodyLuckLevel);
        //      n10:=_MIN(85,n90 * 8 - n90 + 10 + UpgradeInfo.UserItem.btValue[3] - UpgradeInfo.UserItem.btValue[4] + User.m_nBodyLuckLevel);

        if Random(g_Config.nUpgradeWeaponDCRate) < n10 then begin //if Random(100) < n10 then begin
          UpgradeInfo.UserItem.btValue[10] := 10;

          if (n10 > 63) and (Random(g_Config.nUpgradeWeaponDCTwoPointRate) = 0) then //if (n10 > 63) and (Random(30) = 0) then
            UpgradeInfo.UserItem.btValue[10] := 11;

          if (n10 > 79) and (Random(g_Config.nUpgradeWeaponDCThreePointRate) = 0) then //if (n10 > 79) and (Random(200) = 0) then
            UpgradeInfo.UserItem.btValue[10] := 12;
        end else UpgradeInfo.UserItem.btValue[10] := 1; 
      end;
      if ((UpgradeInfo.btMc >= UpgradeInfo.btDc) and (UpgradeInfo.btMc >= UpgradeInfo.btSc)) or (n1C = 1) then begin//加魔法
        n90 := _MIN(11, UpgradeInfo.btMc);
        n10 := _MIN(85, n90 shl 3 - n90 + 10 + UpgradeInfo.UserItem.btValue[3] - UpgradeInfo.UserItem.btValue[4] + User.m_nBodyLuckLevel);

        if Random(g_Config.nUpgradeWeaponMCRate) < n10 then begin //if Random(100) < n10 then begin
          UpgradeInfo.UserItem.btValue[10] := 20;

          if (n10 > 63) and (Random(g_Config.nUpgradeWeaponMCTwoPointRate) = 0) then //if (n10 > 63) and (Random(30) = 0) then
            UpgradeInfo.UserItem.btValue[10] := 21;

          if (n10 > 79) and (Random(g_Config.nUpgradeWeaponMCThreePointRate) = 0) then //if (n10 > 79) and (Random(200) = 0) then
            UpgradeInfo.UserItem.btValue[10] := 22;
        end else UpgradeInfo.UserItem.btValue[10] := 1;
      end;
      if ((UpgradeInfo.btSc >= UpgradeInfo.btMc) and (UpgradeInfo.btSc >= UpgradeInfo.btDc)) or (n1C = 2) then begin//加道术
        n90 := _MIN(11, UpgradeInfo.btMc);
        n10 := _MIN(85, n90 shl 3 - n90 + 10 + UpgradeInfo.UserItem.btValue[3] - UpgradeInfo.UserItem.btValue[4] + User.m_nBodyLuckLevel);

        if Random(g_Config.nUpgradeWeaponSCRate) < n10 then begin //if Random(100) < n10 then begin
          UpgradeInfo.UserItem.btValue[10] := 30;

          if (n10 > 63) and (Random(g_Config.nUpgradeWeaponSCTwoPointRate) = 0) then //if (n10 > 63) and (Random(30) = 0) then
            UpgradeInfo.UserItem.btValue[10] := 31;

          if (n10 > 79) and (Random(g_Config.nUpgradeWeaponSCThreePointRate) = 0) then //if (n10 > 79) and (Random(200) = 0) then
            UpgradeInfo.UserItem.btValue[10] := 32;
        end else UpgradeInfo.UserItem.btValue[10] := 1;
      end;
      New(UserItem);
      FillChar(UserItem^, SizeOf(TUserItem), #0);//20080820 增加
      UserItem^ := UpgradeInfo.UserItem;
      UserItem.btValue[9] := _MIN(255, UserItem.btValue[9] + 1);//累积升级次数 20080816
      Dispose(UpgradeInfo);
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin//20090326
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog('24' + #9 + User.m_sMapName + #9 +
            IntToStr(User.m_nCurrX) + #9 + IntToStr(User.m_nCurrY) + #9 +
            User.m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 +
            '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
            '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
            '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
            '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
            '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
            IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
            IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
            IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
            IntToStr(UserItem.btValue[14])+ #9 + IntToStr(UserItem.Dura)+'/'+IntToStr(UserItem.DuraMax));
      end;
      User.ClearCopyItem(0, UserItem.wIndex, UserItem.MakeIndex);//清理包裹和仓库复制物品 20080816
      User.AddItemToBag(UserItem);
      User.SendAddItem(UserItem);
    end;
    case n18 of //
      0: GotoLable(User, sGETBACKUPGFAIL, False, False);
      1: GotoLable(User, sGETBACKUPGING, False, False);
      2: GotoLable(User, sGETBACKUPGOK, False, False);
    end; // case
  except
    MainOutMessage(Format('{%s} TMerchant.GetBackupgWeapon',[g_sExceptionVer]));
  end;
end;
//取用户价格
function TMerchant.GetUserPrice(PlayObject: TPlayObject; nPrice: Integer): Integer; //0049F6E0
var
  n14: Integer;
begin
  {
  if m_boCastle then begin
    if UserCastle.IsMasterGuild(TGuild(PlayObject.m_MyGuild)) then begin
      n14:=_MAX(60,ROUND(m_nPriceRate * 8.0000000000000000001e-1));//80%
      Result:=ROUND(nPrice / 1.0e2 * n14); //100
    end else begin
      Result:=ROUND(nPrice / 1.0e2 * m_nPriceRate);
    end;
  end else begin
    Result:=ROUND(nPrice / 1.0e2 * m_nPriceRate);
  end;
  }
  if m_boCastle then begin
    //    if UserCastle.IsMasterGuild(TGuild(PlayObject.m_MyGuild)) then begin
    if (m_Castle <> nil) and TUserCastle(m_Castle).IsMasterGuild(TGUild(PlayObject.m_MyGuild)) then begin
      n14 := _MAX(60, Round(m_nPriceRate * (g_Config.nCastleMemberPriceRate / 100))); //80%
      Result := Round(nPrice / 100 * n14); //100
    end else begin
      Result := Round(nPrice / 100 * m_nPriceRate);
    end;
  end else begin
    Result := Round(nPrice / 100 * m_nPriceRate);
  end;
end;

procedure TMerchant.UserSelect(PlayObject: TPlayObject; sData: string);
  procedure SuperRepairItem(User: TPlayObject);
  begin
    User.SendMsg(Self, RM_SENDUSERSREPAIR, 0, Integer(Self), 0, 0, '');
  end;
  procedure BuyItem(User: TPlayObject; nInt: Integer);//NPC买物品
  var
    I, n10, nStock, nPrice: Integer;
    nSubMenu: ShortInt;
    sSENDMSG, sName: string;
    UserItem: pTUserItem;
    StdItem: pTStdItem;
    List14: TList;
  begin
    sSENDMSG := '';
    n10 := 0;
    if m_GoodsList.Count > 0 then begin//20080629
      for I := 0 to m_GoodsList.Count - 1 do begin
        List14 := TList(m_GoodsList.Items[I]);
        if List14 = nil then Continue;
        UserItem := List14.Items[0];
        if UserItem = nil then Continue;
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem <> nil then begin
          //取自定义物品名称
          sName := '';
          if UserItem.btValue[13] = 1 then
            sName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sName = '' then
            sName := StdItem.Name;

          nPrice := GetUserPrice(User, GetItemPrice(UserItem.wIndex));
          if nPrice <= 0 then Continue;//过滤价格为0的物品 20081130
          nStock := List14.Count;
          if (StdItem.StdMode <= 4) or
            (StdItem.StdMode = 42) or
            (StdItem.StdMode = 31) then nSubMenu := 0
          else nSubMenu := 1;
          sSENDMSG := sSENDMSG + sName + '/' + IntToStr(nSubMenu) + '/' + IntToStr(nPrice) + '/' + IntToStr(nStock) + '/';
          Inc(n10);
        end;
      end; // for
    end;
    User.SendMsg(Self, RM_SENDGOODSLIST, 0, Integer(Self), n10, 0, sSENDMSG);
  end;

 { procedure BuySellItem(User: TPlayObject); //拍卖物品列表   //20080416 去掉拍卖功能
  var
    I, n18, nStock, nSubMenu, nSellGold: Integer;
    List20: TList;
    s1C, sName: string;
    SellOffInfo: pTSellOffInfo;
    StdItem: pTStdItem;
  begin
    s1C := '';
    n18 := 0;
    List20 := TList.Create;
    g_SellOffGoodList.GetSellOffGoodList(List20);
    for I := 0 to List20.Count - 1 do begin
      if List20.Count <= 0 then Break;
      SellOffInfo := List20.Items[I];
      if SellOffInfo = nil then Continue;
      StdItem := UserEngine.GetStdItem(SellOffInfo.UseItems.wIndex);
      if StdItem <> nil then begin
        //取自定义物品名称
        sName := '';
        if SellOffInfo.UseItems.btValue[13] = 1 then
          sName := ItemUnit.GetCustomItemName(SellOffInfo.UseItems.MakeIndex, SellOffInfo.UseItems.wIndex);
        if sName = '' then
          sName := StdItem.Name;
        nStock := List20.Count;
        if (StdItem.StdMode <= 4) or
          (StdItem.StdMode = 42) or
          (StdItem.StdMode = 31) then nSubMenu := 0
        else nSubMenu := 1;
        if CompareText(SellOffInfo.sCharName, User.m_sCharName) = 0 then nSellGold := -SellOffInfo.nSellGold else nSellGold := SellOffInfo.nSellGold;
        s1C := s1C + sName + '/' + IntToStr(nSubMenu) + '/' + IntToStr(nSellGold) + '/' + IntToStr(nStock) + '/';
        Inc(n18);
      end;
    end;
    User.SendMsg(Self, RM_SENDSELLOFFGOODSLIST, 0, Integer(Self), n18, 0, s1C);
    List20.Free;
  end;  }

 { procedure GetSellGold(User: TPlayObject);//拍卖物品价格  //20080416 去掉拍卖功能
  var
    I: Integer;
    nSellGold: Integer;
    nRate: Integer;
    nSellGoldCount: Integer;
    nRateCount: Integer;
    s1C: string;
    SellOffInfo: pTSellOffInfo;
    n18: Integer;
    List20: TList;
//    bo01: Boolean;
  begin
    nSellGoldCount := 0;
    nRateCount := 0;
    s1C := '';
    List20 := TList.Create;
    g_SellOffGoldList.GetUserSellOffGoldListByChrName(User.m_sCharName, List20);
    for I := 0 to List20.Count - 1 do begin
      if List20.Count <= 0 then Break;
      SellOffInfo := pTSellOffInfo(List20.Items[I]);
      if SellOffInfo = nil then Continue;
      if g_Config.nUserSellOffTax > 0 then begin
        nRate := SellOffInfo.nSellGold * g_Config.nUserSellOffTax div 100;
        nSellGold := SellOffInfo.nSellGold - nRate;
      end else begin
        nSellGold := SellOffInfo.nSellGold;
        nRate := 0;
      end;
      s1C := '物品:' + UserEngine.GetStdItemName(SellOffInfo.UseItems.wIndex) + ' 金额:' + IntToStr(nSellGold) + ' 税:' + IntToStr(nRate) + g_Config.sGameGoldName + ' 拍卖日期:' + DateTimeToStr(SellOffInfo.dSellDateTime);
      User.SysMsg(s1C, c_Green, t_Hint);
      Inc(User.m_nGameGold, nSellGold);
      Inc(nSellGoldCount, nSellGold);
      User.GameGoldChanged;
      Inc(nRateCount, nRate);
      Inc(n18);
      g_SellOffGoldList.DelSellOffGoldItem(SellOffInfo.UseItems.MakeIndex);
    end;
    if n18 > 0 then begin
      s1C := '总金额:' + IntToStr(nSellGoldCount) + ' 税:' + IntToStr(nRateCount) + g_Config.sGameGoldName;
      User.SysMsg(s1C, c_Green, t_Hint);
    end;
    //g_SellOffGoldList.SaveSellOffGoldList();
    //MainOutMessage('List20.Count:'+IntToStr(List20.Count));
    List20.Free;
  end;  }

  procedure RemoteMsg(User: TPlayObject; sLabel, sMsg: string); //接受歌曲
  var
    sSENDMSG: string;
    TargetObject: TPlayObject;
  begin
    sMsg := Trim(sMsg);
    if sMsg <> '' then begin
      TargetObject := UserEngine.GetPlayObject(sMsg);
      if TargetObject <> nil then begin
        if TargetObject.m_boRemoteMsg then begin
          sLabel := Copy(sLabel, 2, Length(sLabel) - 1);
          sSENDMSG := '您的好友 ' + User.m_sCharName + ' 给您发送音乐\ \<播放歌曲/' + sLabel + '>\';
          SendMsgToUser(TargetObject, sSENDMSG);
        end else begin
          User.SysMsg(sMsg + '您的好友 ' + TargetObject.m_sCharName + ' 拒绝接受歌曲！！！', c_Red, t_Hint);
        end;
      end else begin
        User.SysMsg(sMsg + g_sUserNotOnLine {'  没有在线！！！'}, {c_Red}c_Green, t_Hint);//20101022 修改
      end;
    end;
  end;
 //挂机留言
  procedure AutoGetExp(User: TPlayObject; sMsg: string);
  begin
    User.m_sAutoSendMsg := sMsg;
  end;

  procedure DealGold(User: TPlayObject; sMsg: string);
  var
    PoseHuman: TPlayObject;
    nGameGold: Integer;
  begin
    nGameGold := Str_ToInt(sMsg, -1);
    if User.m_nDealGoldPose <> 1 then begin
      GotoLable(User, '@dealgoldPlayError', False, False);
      Exit;
    end;
    User.m_nDealGoldPose := 2;
    if nGameGold <= 0 then begin
      GotoLable(User, '@dealgoldInputFail', False, False);
    end else begin
      if User.m_nGameGold >= nGameGold then begin
        PoseHuman := TPlayObject(User.GetPoseCreate());
        if (PoseHuman <> nil) and (TPlayObject(PoseHuman.GetPoseCreate) = User) and (PoseHuman.m_btRaceServer = RC_PLAYOBJECT) then begin
          //Inc(PoseHuman.m_nGameGold, nGameGold);
          if PoseHuman.m_nGameGold + nGameGold < High(Integer) then begin//20091124 修改
            Inc(PoseHuman.m_nGameGold, nGameGold);
          end else begin
            PoseHuman.m_nGameGold := High(Integer);
          end;
          if User.m_nGameGold >= nGameGold then begin//20090424 修改
            Dec(User.m_nGameGold, nGameGold);
          end else User.m_nGameGold:= 0;
          PoseHuman.GameGoldChanged;
          User.GameGoldChanged;
          if g_boGameLogGameGold then
            AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD,
                PoseHuman.m_sMapName,
                PoseHuman.m_nCurrX,
                PoseHuman.m_nCurrY,
                PoseHuman.m_sCharName,
                g_Config.sGameGoldName,
                PoseHuman.m_nGameGold,
                '转账'+'('+inttostr(nGameGold)+')',
                User.m_sCharName]));
          SendMsgToUser(User, '转帐成功：' + #10 + '转出' + g_Config.sGameGoldName + '：' + IntToStr(nGameGold) + #9 + '当前' + g_Config.sGameGoldName + '：' + IntToStr(User.m_nGameGold));
          SendMsgToUser(PoseHuman, '转帐成功：' + #10 + '增加' + g_Config.sGameGoldName + '：' + IntToStr(nGameGold) + #9 + '当前' + g_Config.sGameGoldName + '：' + IntToStr(PoseHuman.m_nGameGold));
        end else begin
          GotoLable(User, '@dealgoldpost', False, False);
        end;
      end else begin
        GotoLable(User, '@dealgoldFail', False, False);
      end;
    end;
  end;

  procedure SellItem(User: TPlayObject);
  begin
    User.SendMsg(Self, RM_SENDUSERSELL, 0, Integer(Self), 0, 0, '');
  end;
  procedure SellSellItem(User: TPlayObject);
  begin
    User.SendMsg(Self, RM_SENDUSERSELLOFFITEM, 0, Integer(Self), 0, 0, '');
  end;
  procedure RepairItem(User: TPlayObject);
  begin
    User.SendMsg(Self, RM_SENDUSERREPAIR, 0, Integer(Self), 0, 0, '');
  end;
  {$IF M2Version <> 2}
  procedure ArmsTearItem(User: TPlayObject);//武器拆卸赤炎石 20100708
  begin
    User.SendMsg(Self, RM_SENDUSERARMSTEAR, 0, Integer(Self), 0, 0, '');
  end;
  procedure ArmsExchange(User: TPlayObject);//武器兑换卷轴碎片 20100809
  begin
    User.SendMsg(Self, RM_SENDUSERARMSEXCHANGE, 0, Integer(Self), 0, 0, '');
  end;
  {$IFEND} 
  procedure MakeDurg(User: TPlayObject);
  var
    I: Integer;
    List14: TList;
    UserItem: pTUserItem;
    StdItem: pTStdItem;
    sSENDMSG: string;
  begin
    sSENDMSG := '';
    if m_GoodsList.Count > 0 then begin//20080629
      for I := 0 to m_GoodsList.Count - 1 do begin
        List14 := TList(m_GoodsList.Items[I]);
        if List14.Count <= 0 then Continue; //0807 增加，防止在制药物品列表为空时出错
        UserItem := List14.Items[0];
        if UserItem = nil then Continue;
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem <> nil then begin
          sSENDMSG := sSENDMSG + StdItem.Name + '/' + IntToStr(0) + '/' + IntToStr(g_Config.nMakeDurgPrice) + '/' + IntToStr(1) + '/';
        end;
      end;
    end;
    if sSENDMSG <> '' then
      User.SendMsg(Self, RM_USERMAKEDRUGITEMLIST, 0, Integer(Self), 0, 0, sSENDMSG);
  end;
  procedure ItemPrices(User: TPlayObject); //
  begin

  end;
  procedure Storage(User: TPlayObject);//存移动仓库
  begin
    User.m_dwStorageType:= 1;//打开的仓库类型 1-移动仓库 2-无限仓库 20090901
    User.SendMsg(Self, RM_USERSTORAGEITEM, 0, Integer(Self), 0, 0, '');
  end;
  procedure GetBack(User: TPlayObject);//取移动仓库物品
  begin
    User.m_dwStorageType:= 1;//打开的仓库类型 1-移动仓库 2-无限仓库 20090901
    User.SendMsg(Self, RM_USERGETBACKITEM, 0, Integer(Self), 0, 0, '');
  end;
  procedure BigStorage(User: TPlayObject);//存无限仓库
  begin
    User.m_dwStorageType:= 2;//打开的仓库类型 1-移动仓库 2-无限仓库 20090901
    User.SendMsg(Self, RM_USERSTORAGEITEM, 0, Integer(Self), 0, 0, '');
  end;
  procedure BigGetBack(User: TPlayObject);//取无限仓库
  begin
    User.m_dwStorageType:= 2;//打开的仓库类型 1-移动仓库 2-无限仓库 20090901
    User.m_nBigStoragePage := 0;
    User.SendMsg(Self, RM_USERBIGGETBACKITEM, User.m_nBigStoragePage, Integer(Self), 0, 0, '');
  end;
  procedure GetPreviousPage(User: TPlayObject);
  begin
    if User.m_nBigStoragePage > 0 then
      Dec(User.m_nBigStoragePage)
    else User.m_nBigStoragePage := 0;
    User.SendMsg(Self, RM_USERBIGGETBACKITEM, User.m_nBigStoragePage, Integer(Self), 0, 0, '');
  end;
  procedure GetNextPage(User: TPlayObject);
  begin
    Inc(User.m_nBigStoragePage);
    User.SendMsg(Self, RM_USERBIGGETBACKITEM, User.m_nBigStoragePage, Integer(Self), 0, 0, '');
  end;

  procedure UserLevelOrder(User: TPlayObject);
  begin
    User.m_nSelPlayOrderType := 0;
    User.m_nPlayOrderPage := 0;
    User.SendDelayMsg(Self, RM_USERLEVELORDER, 0, 0, 0, 0, '', 100);
  end;

  procedure WarrorLevelOrder(User: TPlayObject);
  begin
    User.m_nSelPlayOrderType := 1;
    User.m_nPlayOrderPage := 0;
    User.SendDelayMsg(Self, RM_USERLEVELORDER, 0, 0, 0, 0, '', 100);
  end;

  procedure WizardLevelOrder(User: TPlayObject);
  begin
    User.m_nSelPlayOrderType := 2;
    User.m_nPlayOrderPage := 0;
    User.SendDelayMsg(Self, RM_USERLEVELORDER, 0, 0, 0, 0, '', 100);
  end;

  procedure TaoistLevelOrder(User: TPlayObject);
  begin
    User.m_nSelPlayOrderType := 3;
    User.m_nPlayOrderPage := 0;
    User.SendDelayMsg(Self, RM_USERLEVELORDER, 0, 0, 0, 0, '', 100);
  end;

  procedure MasterCountOrder(User: TPlayObject);
  begin
    User.m_nSelPlayOrderType := 4;
    User.m_nPlayOrderPage := 0;
    User.SendDelayMsg(Self, RM_USERLEVELORDER, 0, 0, 0, 0, '', 100);
  end;

  procedure LevelOrderHomePage(User: TPlayObject);
  begin
    User.m_nPlayOrderPage := 0;
    User.SendDelayMsg(Self, RM_USERLEVELORDER, 0, 0, 0, 0, '', 100);
  end;

  procedure LevelOrderPreviousPage(User: TPlayObject);
  begin
    if User.m_nPlayOrderPage > 0 then
      Dec(User.m_nPlayOrderPage)
    else
      User.m_nPlayOrderPage := 0;
    User.SendDelayMsg(Self, RM_USERLEVELORDER, 0, 0, 0, 0, '', 100);
  end;

  procedure LevelOrderNextPage(User: TPlayObject);
  var
    //PlayObjectList: TStringList;
    Count: Integer;
  begin
    {PlayObjectList := GetPlayObjectOrderList(User.m_nSelPlayOrderType);
    if PlayObjectList <> nil then begin
      if GetPageCount(PlayObjectList.Count) > User.m_nPlayOrderPage then begin
        Inc(User.m_nPlayOrderPage);
      end;
      User.SendDelayMsg(Self, RM_USERLEVELORDER, 0, 0, 0, 0, '', 100);
    end;}
    Count:= GetPlayObjectOrderList(User.m_nSelPlayOrderType);
    if Count > 0 then begin
      if GetPageCount(Count) > User.m_nPlayOrderPage then begin
        Inc(User.m_nPlayOrderPage);
      end;
      User.SendDelayMsg(Self, RM_USERLEVELORDER, 0, 0, 0, 0, '', 100);
    end;
  end;

  procedure LevelOrderLastPage(User: TPlayObject);
  var
    //PlayObjectList: TStringList;
    Count: Integer;
  begin
    {PlayObjectList := GetPlayObjectOrderList(User.m_nSelPlayOrderType);
    if PlayObjectList <> nil then begin
      User.m_nPlayOrderPage := GetPageCount(PlayObjectList.Count);
      User.SendDelayMsg(Self, RM_USERLEVELORDER, 0, 0, 0, 0, '', 100);
    end;}
    Count := GetPlayObjectOrderList(User.m_nSelPlayOrderType);
    if Count > 0 then begin
      User.m_nPlayOrderPage := GetPageCount(Count);
      User.SendDelayMsg(Self, RM_USERLEVELORDER, 0, 0, 0, 0, '', 100);
    end;
  end;

  procedure MyLevelOrder(User: TPlayObject);
  begin
    User.m_boGetMyLevelOrder := True;
    User.SendDelayMsg(Self, RM_USERLEVELORDER, 0, 0, 0, 0, '', 100);
  end;
  {$IF HEROVERSION = 1}
  procedure MakeHeroName(User: TPlayObject; sLabel, sMsg: string);//制造英雄名字(白日门) 20080315
  var
    sGotoLabel: string;
    //sSrcMsg: string;
    //DestMsg: array[0..256] of Char;
  begin
    if User.m_boWaitHeroDate then Exit;
    if (User.m_boHasHero) or (User.m_sHeroCharName <> '') then begin//20080521
      GotoLable(User, '@HaveHero', False, False);
    end else begin
      if (Length(sMsg) > 0) and (Length(sMsg) < 15) then begin
        if not IsFilterMsg(sMsg) then begin //文字过滤 20080729
          User.m_sTempHeroCharName :='';
          GotoLable(User, '@HeroNameFilter', False, False);
          Exit;
        end;
        {if Assigned(zPlugOfEngine.PlayObjectFilterMsg) then begin
          sSrcMsg := Trim(sMsg);
          FillChar(DestMsg, SizeOf(DestMsg), 0);//20080524
          if zPlugOfEngine.PlayObjectFilterMsg(User, PChar(sSrcMsg), @DestMsg) then begin//文字过滤
              sMsg := StrPas(PChar(@DestMsg));//20080524
          end else begin
            User.m_sTempHeroCharName :='';
            GotoLable(User, '@HeroNameFilter', False);
            Exit;
          end;
        end; }
        User.m_sTempHeroCharName := Trim(sMsg);
        sGotoLabel := Copy(sLabel, 2, Length(sLabel) - 1);
        GotoLable(User, sGotoLabel, False, False);//跳转到创建英雄标签
      end else begin
        User.m_sHeroCharName := '';
        GotoLable(User, '@HeroNameFilter', False, False);
      end;
    end;
  end;
  //制造卧龙英雄名字 20080514 
  procedure MakeBuHeroName(User: TPlayObject; sLabel, sMsg: string);
  var
    sGotoLabel: string;
    //sSrcMsg: string;
    //DestMsg: array[0..256] of Char;
  begin
    if User.m_boWaitHeroDate then Exit;
    if (User.m_boHasHeroTwo) or (User.m_sHeroCharName <> '') then begin//20080521
      GotoLable(User, '@HaveHero', False, False);
    end else begin
      if (Length(sMsg) > 0) and (Length(sMsg) < 15) then begin
        if not IsFilterMsg(sMsg) then begin //文字过滤 20080729
          User.m_sTempHeroCharName := '';
          GotoLable(User, '@HeroNameFilter', False, False);
          Exit;
        end;
        {if Assigned(zPlugOfEngine.PlayObjectFilterMsg) then begin
          sSrcMsg := Trim(sMsg);
          FillChar(DestMsg, SizeOf(DestMsg), 0);//20080524
          if zPlugOfEngine.PlayObjectFilterMsg(User, PChar(sSrcMsg), @DestMsg) then begin//文字过滤
              sMsg := StrPas(PChar(@DestMsg));//20080524
           end else begin
              User.m_sTempHeroCharName := '';
              GotoLable(User, '@HeroNameFilter', False);
              Exit;
          end;
        end;}
        User.m_sTempHeroCharName := sMsg;
        sGotoLabel := sLabel{Copy(sLabel, 2, Length(sLabel) - 1)};
        GotoLable(User, sGotoLabel, False, False);//跳转到创建英雄标签
      end else begin
        User.m_sHeroCharName := '';
        GotoLable(User, '@HeroNameFilter', False, False);
      end;
    end;
  end;
  {$IFEND}
  procedure PlayDrink(User: TPlayObject);//请酒,斗酒 20080515
  begin
    User.SendMsg(Self, RM_SENDUSERPLAYDRINK, 0, Integer(Self), 0, 0, '');
  end;
  procedure OpenDealOffForm(User: TPlayObject);//打开出售物品窗口 20080316
  begin
    if User.bo_YBDEAL then begin
      if not User.SellOffInTime(0) then begin
        User.SendMsg(Self, RM_SENDDEALOFFFORM, 0, Integer(Self), 0, 0, '');
        User.GetBackSellOffItems();
      end else User.SendMsg(self, RM_MERCHANTSAY, 0, 0, 0, 1, m_sCharName + '/您还有元宝服务正在进行！！\ \<返回/@main>');
    end else User.SendMsg(self, RM_MERCHANTSAY, 0, 0, 0, 1, m_sCharName + '/您未开通元宝服务,请先开通元宝服务！！\ \<返回/@main>');
  end;

  procedure OpenKampoDlgNew(User: TPlayObject);//打开出售物品窗口 20080316
  begin
    User.SendMsg(Self, RM_OpenKampoDlgNew, 0, Integer(Self), 0, 0, '');
  end;
  
  procedure PlugOfPlayObjectUserSelect(PlayObject: TPlayObject; pszLabel, pszData: String);//20080729
  var
    sLabel, sData: string;
    nData, nData1: Integer;
    nLength: Integer;
  begin
    try
      if CompareLStr(pszLabel,'@@InPutString',13) then begin
        nLength := CompareText(pszLabel, '@@InPutString');
        if nLength > 0 then begin
          sLabel := Copy(pszLabel, {length('@@InPutString') + 1}14, nLength);//20090818 修改
          sData := pszData;
          if {not}IsFilterMsg(sData) then begin//过滤信息 20080808
            nData:= Str_ToInt(sLabel, 0);
            if (nData > 99) or (nData < 0) then nData:= 0;
            PlayObject.m_sString[nData] := sData;
            GotoLable(PlayObject, '@InPutString' + inttostr(nData), False, False);
          end else begin
            GotoLable( PlayObject, '@MsgFilter', False, False);
          end;
          Exit;
        end;
      end else
      if CompareLStr(pszLabel, '@@InPutInteger',14) then begin
        nLength := CompareText(pszLabel, '@@InPutInteger');
        if nLength > 0 then begin
          sLabel := Copy(pszLabel, {length('@@InPutInteger') + 1}15, nLength);//20090818 修改
          nData := Str_ToInt(pszData, -1);
          nData1:= Str_ToInt(sLabel, 0);
          if (nData1 > 99) or (nData1 < 0) then nData1:= 0;//20081008
          PlayObject.m_nInteger[nData1] := nData;
          GotoLable(PlayObject, '@InPutInteger' + sLabel, False, False);
        end;
      end;
    except
      MainOutMessage(Format('{%s} PlugOfPlayObjectUserSelect',[g_sExceptionVer]));
    end;
  end;
var
  sLabel, s18, sMsg: string;
  boCanJmp: Boolean;
  sChangeUseItemName: string;
  nCode: Integer;
resourcestring
  sExceptionMsg = '{%s} TMerchant::UserSelect... Data:%s Code:%d';
begin
  inherited;
  if not (ClassNameIs(TMerchant.ClassName)) then Exit; //如果类名不是 TMerchant 则不执行以下处理函数
  nCode:= 39;
  try
    if not m_boCastle or not ((m_Castle <> nil) and TUserCastle(m_Castle).m_boUnderWar) and (PlayObject <> nil) then begin
      nCode:= 40;
      if not PlayObject.m_boDeath and (sData <> '') and (sData[1] = '@') then begin
        sMsg := GetValidStr3(sData, sLabel, [#13]);
        s18 := '';
        nCode:= 41;
        PlayObject.m_sScriptLable := sData;
        nCode:= 42;
        boCanJmp := PlayObject.LableIsCanJmp(sLabel);
        nCode:= 43;
        if CompareText(sLabel, sSL_SENDMSG) = 0 then begin
          nCode:= 1;
          if sMsg = '' then Exit;
        end;
        if CompareLStr(sLabel, sUSEITEMNAME, 13{Length(sUSEITEMNAME)}) then begin //检测装备
          nCode:= 2;
          if sMsg <> '' then begin
            if g_Config.boChangeUseItemNameByPlayName then begin
              sChangeUseItemName := PlayObject.m_sCharName + '的' + sMsg;
            end else begin
              sChangeUseItemName := g_Config.sChangeUseItemName + sMsg;
            end;
            if Length(sChangeUseItemName) > 14 then begin
              SendMsgToUser(PlayObject, '[失败] 名称太长！！！');
              Exit;
            end;
          end;
        end;
        nCode:= 44;
        if PlayObject= nil then Exit;//20080908 增加
        nCode:= 47;
        if PlayObject.m_boGhost then Exit;//20080826 增加
        nCode:= 45;
        GotoLable(PlayObject, sLabel, not boCanJmp, False);
        nCode:= 46;
        if not boCanJmp then Exit;
        s18 := Copy(sLabel, 1, Length(sRMST));
        if CompareText(sLabel, sSL_SENDMSG) = 0 then begin
          nCode:= 3;
          if m_boSendmsg then SendCustemMsg(PlayObject, sMsg);
        end else
          if CompareText(sLabel, sSUPERREPAIR) = 0 then begin
          nCode:= 4;
          if m_boS_repair then SuperRepairItem(PlayObject);
        end else
          if CompareText(sLabel, sBUY) = 0 then begin
          nCode:= 5;
          if m_boBuy then BuyItem(PlayObject, 0);
        end else
          if CompareText(s18, sRMST) = 0 then begin //接受歌曲
          nCode:= 6;
          if m_boofflinemsg then RemoteMsg(PlayObject, sLabel, sMsg);
        end else
          if CompareText(sLabel, sofflinemsg) = 0 then begin //离线挂机
          nCode:= 7;
          if m_boofflinemsg then AutoGetExp(PlayObject, sMsg);
        end else
        {  if CompareText(sLabel, sGETSELLGOLD) = 0 then begin  //20080416 去掉拍卖功能
          if m_boGetSellGold then GetSellGold(PlayObject);
        end else  
          if CompareText(sLabel, sBUYOFF) = 0 then begin
          if m_boBuyOff then BuySellItem(PlayObject);
        end else
          if CompareText(sLabel, sSELLOFF) = 0 then begin
          if m_boBuyOff then SellSellItem(PlayObject);
        end else  }
          if CompareText(sLabel, sdealgold) = 0 then begin
          nCode:= 8;
          if m_boDealGold then DealGold(PlayObject, sMsg);
        end else
          if CompareText(sLabel, sSELL) = 0 then begin//玩家向NPC卖物品 
          nCode:= 9;
          if m_boSell then SellItem(PlayObject);
        end else
          if CompareText(sLabel, sREPAIR) = 0 then begin
          nCode:= 10;
          if m_boRepair then RepairItem(PlayObject);
        end else
        {$IF M2Version <> 2}
          if CompareText(sLabel, sArmsTear) = 0 then begin//武器拆卸赤炎石 20100708
          nCode:= 39;
          if m_boArmsTear then ArmsTearItem(PlayObject);
        end else
          if CompareText(sLabel, sArmsExchange) = 0 then begin////武器兑换卷轴碎片 20100809
          nCode:= 39;
          if m_boArmsExchange then ArmsExchange(PlayObject);
        end else
        if CompareText(sLabel, sBUILDDIVISIONNOW) = 0 then begin
          ReQuestBuildDivision(PlayObject, sMsg);//创建师门
        end else
        {$IFEND}
          if CompareText(sLabel, sMAKEDURG) = 0 then begin
          nCode:= 11;
          if m_boMakeDrug then MakeDurg(PlayObject);
        end else
          if CompareText(sLabel, sPRICES) = 0 then begin
          nCode:= 12;
          if m_boPrices then ItemPrices(PlayObject);
        end else
          if CompareText(sLabel, sSTORAGE) = 0 then begin
          nCode:= 13;
          if m_boStorage then Storage(PlayObject);
        end else
          if CompareText(sLabel, sGETBACK) = 0 then begin
          nCode:= 14;
          if m_boGetback then GetBack(PlayObject);
        end else
          if CompareText(sLabel, sBIGSTORAGE) = 0 then begin
          nCode:= 15;
          if m_boBigStorage then BigStorage(PlayObject);
        end else
          if CompareText(sLabel, sBIGGETBACK) = 0 then begin
          nCode:= 16;
          if m_boBigGetBack then BigGetBack(PlayObject);
        end else
          if CompareText(sLabel, sGETPREVIOUSPAGE) = 0 then begin
          nCode:= 17;
          if m_boBigGetBack then GetPreviousPage(PlayObject);
        end else
          if CompareText(sLabel, sGETNEXTPAGE) = 0 then begin
          nCode:= 18;
          if m_boBigGetBack then GetNextPage(PlayObject);
        end else
          if CompareText(sLabel, sUserLevelOrder) = 0 then begin
          nCode:= 19;
          if m_boUserLevelOrder then UserLevelOrder(PlayObject);
        end else
          if CompareText(sLabel, sWarrorLevelOrder) = 0 then begin
          nCode:= 20;
          if m_boWarrorLevelOrder then WarrorLevelOrder(PlayObject);
        end else
          if CompareText(sLabel, sWizardLevelOrder) = 0 then begin
          nCode:= 21;
          if m_boWizardLevelOrder then WizardLevelOrder(PlayObject);
        end else
          if CompareText(sLabel, sTaoistLevelOrder) = 0 then begin
          nCode:= 22;
          if m_boTaoistLevelOrder then TaoistLevelOrder(PlayObject);
        end else
          if CompareText(sLabel, sMasterCountOrder) = 0 then begin
          nCode:= 23;
          if m_boMasterCountOrder then MasterCountOrder(PlayObject);
        end else
          if CompareText(sLabel, sLevelOrderHomePage) = 0 then begin
          nCode:= 24;
          LevelOrderHomePage(PlayObject);
        end else
          if CompareText(sLabel, sLevelOrderPreviousPage) = 0 then begin
          nCode:= 25;
          LevelOrderPreviousPage(PlayObject);
        end else
          if CompareText(sLabel, sLevelOrderNextPage) = 0 then begin
          nCode:= 26;
          LevelOrderNextPage(PlayObject);
        end else
          if CompareText(sLabel, sLevelOrderLastPage) = 0 then begin
          nCode:= 27;
          LevelOrderLastPage(PlayObject);
        end else
          if CompareText(sLabel, sMyLevelOrder) = 0 then begin
          nCode:= 28;
          MyLevelOrder(PlayObject);
        end else
          if CompareText(sLabel, sDealYBme) = 0 then begin //元宝寄售:出售物品 20080316
          nCode:= 29;
          if m_boYBDeal then OpenDealOffForm(PlayObject);//打开出售物品窗口
        end else
          if CompareText(sLabel, sKAMPODLGNEW) = 0 then begin //元宝寄售:出售物品 20080316
          nCode:= 29;
          //if m_boNewSignedItem then
          OpenKampoDlgNew(PlayObject);//打开出售物品窗口
        end else
{$IF HEROVERSION = 1}
          if CompareText(sLabel, sLyCreateHero) = 0 then begin
          nCode:= 30;
          //if m_boCqFirHero then
          MakeHeroName(PlayObject, sLabel, sMsg);
        end else
          if CompareText(sLabel, sBuHero) = 0 then begin //酒馆英雄NPC 20080514
          nCode:= 39;
          if m_boBuHero then MakeBuHeroName(PlayObject, sLabel, sMsg);
        end else
          if CompareText(sLabel, sPlayDrink) = 0 then begin//玩家向NPC请酒,斗酒 20080515
          nCode:= 40;
          if m_boPlayDrink then PlayDrink(PlayObject);
        end else
{$IFEND}
          if CompareText(sLabel, sUPGRADENOW) = 0 then begin
          nCode:= 31;
          if m_boUpgradenow then UpgradeWapon(PlayObject);//武器升级
        end else
          if CompareText(sLabel, sGETBACKUPGNOW) = 0 then begin
          nCode:= 32;
          if m_boGetBackupgnow then GetBackupgWeapon(PlayObject);
        end else
          if CompareText(sLabel, sGETMARRY) = 0 then begin
          nCode:= 33;
          if m_boGetMarry then GetBackupgWeapon(PlayObject);
        end else
          if CompareText(sLabel, sGETMASTER) = 0 then begin
          nCode:= 34;
          if m_boGetMaster then GetBackupgWeapon(PlayObject);
        end else
          if CompareLStr(sLabel, sUSEITEMNAME, 13{Length(sUSEITEMNAME)}) then begin
          nCode:= 35;
          if m_boUseItemName then ChangeUseItemName(PlayObject, sLabel, sMsg);
        end else
          if CompareText(sLabel, sEXIT) = 0 then begin
          nCode:= 36;
          PlayObject.SendMsg(Self, RM_MERCHANTDLGCLOSE, 0, Integer(Self), 0, 0, '');
        end else
          if CompareText(sLabel, sBACK) = 0 then begin
          nCode:= 37;
          if PlayObject.m_sScriptGoBackLable = '' then PlayObject.m_sScriptGoBackLable := sMAIN;
          GotoLable(PlayObject, PlayObject.m_sScriptGoBackLable, False, False);
        end else begin
          {if Assigned(zPlugOfEngine.PlayObjectUserSelect) then begin
            nCode:= 38;
            zPlugOfEngine.PlayObjectUserSelect(Self, PlayObject, PChar(sLabel), PChar(sMsg));
          end; }
          nCode:= 38;
          PlugOfPlayObjectUserSelect(PlayObject, PChar(sLabel), PChar(sMsg));//20080729
        end;
      end;
    end;
  except
    MainOutMessage(Format(sExceptionMsg, [g_sExceptionVer, sData, nCode]));
  end;
end;

procedure TMerchant.Run();
var
  nCheckCode: Integer;
resourcestring                   
  sExceptionMsg1 = '{%s} TMerchant::Run... Code:%d';
  sExceptionMsg2 = '{%s} TMerchant::Run -> Move Code:%d';
begin
  nCheckCode := 0;
  try
    if (GetTickCount - dwRefillGoodsTick) > 30000 then begin
      dwRefillGoodsTick := GetTickCount();
      RefillGoods();//刷新NPC出售物品列表 占CPU，运行后30秒 20110528
    end;

    nCheckCode := 1;
    if (GetTickCount - dwClearExpreUpgradeTick) > 600000{10 * 60 * 1000} then begin
      dwClearExpreUpgradeTick := GetTickCount();
      ClearExpreUpgradeListData();
    end;
    nCheckCode := 2;
    if Random(50) = 0 then begin
      TurnTo(Random(8));
    end else begin
      if Random(50) = 0 then
        SendRefMsg(RM_HIT, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
    end;
    nCheckCode := 3;
    if m_boCastle and (m_Castle <> nil) and TUserCastle(m_Castle).m_boUnderWar then begin
      if not m_boFixedHideMode then begin
        SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, '');
        m_boFixedHideMode := True;
      end;
    end else begin
      if m_boFixedHideMode then begin
        m_boFixedHideMode := False;
        SendRefMsg(RM_HIT, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
      end;
    end;
    nCheckCode := 4;
  except
    on E: Exception do begin
      MainOutMessage(Format(sExceptionMsg1, [g_sExceptionVer, nCheckCode]));
    end;
  end;
  try
    if m_boCanMove then begin//NPC移动
      if (GetTickCount - m_dwMoveTick > m_dwMoveTime * 1000) then begin
        m_dwMoveTick := GetTickCount();
        SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
        MapRandomMove(m_sMapName, 0);
      end;
    end;
  except
    on E: Exception do begin
      MainOutMessage(Format(sExceptionMsg2, [g_sExceptionVer, nCheckCode]));
    end;
  end;
  inherited;
end;

function TMerchant.Operate(ProcessMsg: pTProcessMessage): Boolean;
begin
  Result := inherited Operate(ProcessMsg);
end;

procedure TMerchant.LoadNPCData;
var
  sFile: string;
begin
try
  sFile := m_sScript + '-' + m_sMapName;
  FrmDB.LoadGoodRecord(Self, sFile);
  FrmDB.LoadGoodPriceRecord(Self, sFile);
  LoadUpgradeList();
except
  MainOutMessage(Format('{%s} TMerchant.LoadNPCData',[g_sExceptionVer]));
end;
end;

procedure TMerchant.SaveNPCData;
var
  sFile: string;
begin
try
  sFile := m_sScript + '-' + m_sMapName;
  FrmDB.SaveGoodRecord(Self, sFile);
  FrmDB.SaveGoodPriceRecord(Self, sFile);
except
  MainOutMessage(Format('{%s} TMerchant.SaveNPCData',[g_sExceptionVer]));
end;
end;

constructor TMerchant.Create;
begin
  inherited;
  m_boRefreshName:= False;//刷新NPC名字(使用全局变量命名时) 20101224
  m_btRaceImg := RCC_MERCHANT;//角色外观
  m_wAppr := 0;
  m_nPriceRate := 100;
  m_boCastle := False;
  m_ItemTypeList := TList.Create;
  m_RefillGoodsList := TList.Create;
  m_GoodsList := TList.Create;
  m_ItemPriceList := TList.Create;
  m_UpgradeWeaponList := TList.Create;

  dwRefillGoodsTick := GetTickCount();
  dwClearExpreUpgradeTick := GetTickCount();
  m_boBuy := False;
  m_boSell := False;
  m_boMakeDrug := False;
  m_boPrices := False;
  m_boStorage := False;
  m_boGetback := False;
  m_boBigStorage := False;
  m_boBigGetBack := False;
  m_boGetNextPage := False;
  m_boGetPreviousPage := False;
  m_boCqFirHero := False;
  m_boBuHero := False;//20080514
  m_boPlayMakeWine:= False;//酿酒NPC 20080619

  m_boUserLevelOrder := False;
  m_boWarrorLevelOrder := False;
  m_boWizardLevelOrder := False;
  m_boTaoistLevelOrder := False;
  m_boMasterCountOrder := False;

  m_boUpgradenow := False;
  m_boGetBackupgnow := False;
  m_boRepair := False;
  m_boArmsTear := False;
  m_boArmsExchange := False;
  m_boS_repair := False;
  m_boGetMarry := False;
  m_boGetMaster := False;
  m_boUseItemName := False;

  //m_boGetSellGold := False;//20080416 去掉拍卖功能
  //m_boSellOff := False;//20080416 去掉拍卖功能
  //m_boBuyOff := False;//20080416 去掉拍卖功能
  m_boofflinemsg := False;
  m_boDealGold := False;
  m_dwMoveTick := GetTickCount();
end;

destructor TMerchant.Destroy;
var
  I: Integer;
  II: Integer;
  List: TList;
  nCode: Byte;//20080727
begin
  nCode:= 0;
  try
    nCode:= 1;
    m_ItemTypeList.Free;
    nCode:= 2;
    if m_RefillGoodsList.Count > 0 then begin//20080629
      for I := 0 to m_RefillGoodsList.Count - 1 do begin
        if pTGoods(m_RefillGoodsList.Items[I]) <> nil then
          Dispose(pTGoods(m_RefillGoodsList.Items[I]));
      end;
    end;
    m_RefillGoodsList.Free;

    nCode:= 3;
    if m_GoodsList.Count > 0 then begin//20080629
      for I := 0 to m_GoodsList.Count - 1 do begin
        List := TList(m_GoodsList.Items[I]);
        if List.Count > 0 then begin//20080629
          for II := 0 to List.Count - 1 do begin
            if pTUserItem(List.Items[II]) <> nil then Dispose(pTUserItem(List.Items[II]));
          end;
        end;
        List.Free;
      end;
    end;
    m_GoodsList.Free;

    nCode:= 4;
    if m_ItemPriceList.Count > 0 then begin//20080629
      for I := 0 to m_ItemPriceList.Count - 1 do begin
        if pTItemPrice(m_ItemPriceList.Items[I]) <> nil then
          Dispose(pTItemPrice(m_ItemPriceList.Items[I]));
      end;
    end;
    m_ItemPriceList.Free;

    nCode:= 5;
    if m_UpgradeWeaponList.Count > 0 then begin//20080629
      for I := 0 to m_UpgradeWeaponList.Count - 1 do begin
        if pTUpgradeInfo(m_UpgradeWeaponList.Items[I]) <> nil then
          Dispose(pTUpgradeInfo(m_UpgradeWeaponList.Items[I]));
      end;
    end;
    m_UpgradeWeaponList.Free;

    inherited;
  except
    MainOutMessage(Format('{%s} TMerchant.Destroy Code:%d',[g_sExceptionVer, nCode]));
  end;
end;

procedure TMerchant.ClearExpreUpgradeListData;
var
  I: Integer;
  UpgradeInfo: pTUpgradeInfo;
begin
  try
    for I := m_UpgradeWeaponList.Count - 1 downto 0 do begin
      if m_UpgradeWeaponList.Count <= 0 then Break;
      UpgradeInfo := m_UpgradeWeaponList.Items[I];
      if UpgradeInfo = nil then Continue;
      if Integer(Round(Now - UpgradeInfo.dtTime)) >= g_Config.nClearExpireUpgradeWeaponDays then begin
        Dispose(UpgradeInfo);
        m_UpgradeWeaponList.Delete(I);
      end;
    end;
  except
    MainOutMessage(Format('{%s} TMerchant.ClearExpreUpgradeListData',[g_sExceptionVer]));
  end;
end;

procedure TMerchant.LoadNpcScript;
var
  SC: string;
begin
  m_ItemTypeList.Clear;
  m_sPath := sMarket_Def;
  SC := m_sScript + '-' + m_sMapName;
  FrmDB.LoadScriptFile(Self, sMarket_Def, SC, True);
end;

procedure TMerchant.Click(PlayObject: TPlayObject);
begin
  try
    if (not m_boGhost) then begin//20090101
      if PlayObject <> nil then begin
        if PlayObject.m_btRaceServer = RC_PLAYOBJECT then begin//20090102 增加
          inherited;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TMerchant.Click',[g_sExceptionVer]));
  end;
end;

procedure TMerchant.GetVariableText(PlayObject: TPlayObject;
  var sMsg: string; sVariable: string);
var
  sText: string;
begin
  inherited;
  try
    if sVariable = '$PRICERATE' then begin
      sText := IntToStr(m_nPriceRate);
      sMsg := sub_49ADB8(sMsg, '<$PRICERATE>', sText);
    end;
    if sVariable = '$UPGRADEWEAPONFEE' then begin
      sText := IntToStr(g_Config.nUpgradeWeaponPrice);
      sMsg := sub_49ADB8(sMsg, '<$UPGRADEWEAPONFEE>', sText);
    end;
    if sVariable = '$USERWEAPON' then begin
      if PlayObject.m_UseItems[U_WEAPON].wIndex <> 0 then begin
        sText := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_WEAPON].wIndex);
      end else begin
        sText := '';
      end;
      sMsg := sub_49ADB8(sMsg, '<$USERWEAPON>', sText);
    end;
  except
    MainOutMessage(Format('{%s} TMerchant.GetVariableText',[g_sExceptionVer]));
  end;
end;
//取使用物品的价格
function TMerchant.GetUserItemPrice(UserItem: pTUserItem): Integer;
var
  n10: Integer;
  StdItem: pTStdItem;
  n20: real;
  nC: Integer;
  n14: Integer;
begin
  try
    n10 := GetItemPrice(UserItem.wIndex);
    if n10 > 0 then begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if (StdItem <> nil) then begin//20090203
        if (StdItem.StdMode > 4) and (StdItem.DuraMax > 0) and (UserItem.DuraMax > 0) then begin
          if StdItem.StdMode = 40 then begin //肉
            if UserItem.Dura <= UserItem.DuraMax then begin
              n20 := (n10 / 2.0 / UserItem.DuraMax * (UserItem.DuraMax - UserItem.Dura));
              n10 := _MAX(2, Round(n10 - n20));
            end else begin
              n10 := n10 + Round(n10 / UserItem.DuraMax * 2.0 * (UserItem.DuraMax - UserItem.Dura));
            end;
          end;
          if (StdItem.StdMode = 43) then begin//矿石
            if UserItem.DuraMax < 10000 then UserItem.DuraMax := 10000;
           { if UserItem.Dura <= UserItem.DuraMax then begin
              n20 := (n10 / 2.0 / UserItem.DuraMax * (UserItem.DuraMax - UserItem.Dura));
              n10 := _MAX(2, Round(n10 - n20));
            end else begin
              n10 := n10 + Round(n10 / UserItem.DuraMax * 1.3 * (UserItem.DuraMax - UserItem.Dura));
            end; }
            //20090203 修改，修正当前持久大于最大持久时，价格比小纯度的矿石还低
            n20 := (n10 / 2.0 / UserItem.DuraMax * (UserItem.DuraMax - UserItem.Dura));
            n10 := _MAX(2, Round(n10 - n20));
          end;
          if (StdItem.StdMode = 17) then begin//针物品 20090726
            if UserItem.Dura > 0 then n10 := n10 * UserItem.Dura;
          end;
          if StdItem.StdMode > 4 then begin
            n14 := 0;
            nC := 0;
            while (True) do begin
              try//20101126 防止死循环
                if (StdItem.StdMode = 5) or (StdItem.StdMode = 6) then begin
                  if (nC <> 4) or (nC <> 9) then begin
                    if nC = 6 then begin
                      if UserItem.btValue[nC] > 10 then begin
                        n14 := n14 + (UserItem.btValue[nC] - 10) * 2;
                      end;
                    end else begin
                      n14 := n14 + UserItem.btValue[nC];
                    end;
                  end;
                end else begin
                  Inc(n14, UserItem.btValue[nC]);
                end;
              except
              end;
              Inc(nC);
              if nC >= 8 then Break;
            end;
            if n14 > 0 then begin
              n10 := n10 div 5 * n14;
            end;
            n10 := Round(n10 / StdItem.DuraMax * UserItem.DuraMax);
            n20 := (n10 / 2.0 / UserItem.DuraMax * (UserItem.DuraMax - UserItem.Dura));
            n10 := _MAX(2, Round(n10 - n20));
          end;
        end;
      end;
    end;
    Result := n10;
  except
    MainOutMessage(Format('{%s} TMerchant.GetUserItemPrice',[g_sExceptionVer]));
  end;
end;
//客户端购买物品
procedure TMerchant.ClientBuyItem(PlayObject: TPlayObject; sItemName: string;
  nInt: Integer);
var
  I, II: Integer;
  bo29: Boolean;
  List20: TList;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  n1C, nPrice: Integer;
  sUserItemName: string;
begin
  try
    bo29 := False;
    n1C := 1;
    //I := 0;
    //while True do begin //for i := 0 to m_GoodsList.Count - 1 do begin
    if m_GoodsList.Count > 0 then begin
      for I := 0 to m_GoodsList.Count - 1 do begin//20081008 替换
        //if I >= m_GoodsList.Count then Break;
        //if m_GoodsList.Count <= 0 then Break;
        if bo29 then Break;
        List20 := TList(m_GoodsList.Items[I]);
        if List20 = nil then Continue;
        if List20.Count <= 0 then Continue;
        UserItem := List20.Items[0];
        if CheckIsOKItem(UserItem) then Break;//检查变态物品 20081008
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem <> nil then begin
          if PlayObject.IsAddWeightAvailable(StdItem.Weight) then begin
            if sUserItemName = sItemName then begin
              //II := 0;
              //while True do begin //for ii := 0 to List20.Count - 1 do begin
              if List20.Count > 0 then begin
                for II := 0 to List20.Count - 1 do begin
                  //if II >= List20.Count then Break;
                  if List20.Count <= 0 then Break;
                  UserItem := List20.Items[II];
                  if (StdItem.StdMode <= 4) or (StdItem.StdMode = 42) or (StdItem.StdMode = 31) or
                     (UserItem.MakeIndex = nInt) then begin
                    nPrice := GetUserPrice(PlayObject, GetUserItemPrice(UserItem));
                    if (PlayObject.m_nGold >= nPrice) and (nPrice > 0) then begin
                      if PlayObject.AddItemToBag(UserItem) then begin
                        Dec(PlayObject.m_nGold, nPrice);
                        if m_boCastle or g_Config.boGetAllNpcTax then begin
                          if m_Castle <> nil then begin
                            TUserCastle(m_Castle).IncRateGold(nPrice);
                          end else
                            if g_Config.boGetAllNpcTax then begin
                            g_CastleManager.IncRateGold(g_Config.nUpgradeWeaponPrice);
                          end;
                        end;
                        {if m_boCastle or g_Config.boGetAllNpcTax then
                          UserCastle.IncRateGold(nPrice); }
                        if (StdItem.StdMode = 2) and (StdItem.AniCount = 21) then  UserItem.Dura:=0; //20080211  魔令包和祝福罐,则把当前持久设置为0
                        if (StdItem.StdMode = 51) and ((StdItem.Shape = 0) or (StdItem.Shape = 1) or (StdItem.Shape = 2)) then UserItem.Dura:=0; //20080221  聚灵珠,内功珠,则把当前持久设置为0
                        PlayObject.SendAddItem(UserItem);
                        if StdItem.NeedIdentify = 1 then
                          AddGameDataLog('9' + #9 + PlayObject.m_sMapName + #9 +
                            IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                            PlayObject.m_sCharName + #9 + StdItem.Name + #9 +
                            IntToStr(UserItem.MakeIndex) + #9 +
                            '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                            '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                            '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                            '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                            '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                            IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                            IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                            IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                            IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);

                        List20.Delete(II);
                        if List20.Count <= 0 then begin
                          List20.Free;
                          m_GoodsList.Delete(I);
                        end;
                        n1C := 0;
                      end else n1C := 2;
                    end else n1C := 3;
                    bo29 := True;
                    Break;
                  end;
                  //Inc(II);
                end;
              end;
            end;
          end else n1C := 2; //004A2639
        end;
        //Inc(I);
      end; // for
    end;
    if n1C = 0 then begin
      PlayObject.SendMsg(Self, RM_BUYITEM_SUCCESS, 0, PlayObject.m_nGold, nInt, 0, '');
      PlayObject.GoldChanged(); //更新客户端金币 20080417
    end else begin
      PlayObject.SendMsg(Self, RM_BUYITEM_FAIL, 0, n1C, 0, 0, '');
    end;
  except
    MainOutMessage(Format('{%s} TMerchant.ClientBuyItem',[g_sExceptionVer]));
  end;
end;
//取NPC出售物品属性
procedure TMerchant.ClientGetDetailGoodsList(PlayObject: TPlayObject; sItemName: string;
  nInt: Integer);
var
  I, II, n18: Integer;
  List20: TList;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  s1C: string;
  nCode: Byte;//20081009
begin
  Try
    nCode:= 0;
    if PlayObject.m_nSoftVersionDateEx = 0 then begin
      n18 := 0;
      if m_GoodsList.Count > 0 then begin//20080629
        for I := 0 to m_GoodsList.Count - 1 do begin
          List20 := TList(m_GoodsList.Items[I]);
          if List20 = nil then Continue;
          if List20.Count <= 0 then Continue;
          nCode:= 1;
          UserItem := List20.Items[0];
          if UserItem = nil then Continue;
          nCode:= 2;
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) and (CompareText(StdItem.Name, sItemName) = 0) then begin
            if (List20.Count - 1) < nInt then begin
              nInt := _MAX(0, List20.Count - 10);
            end;
            nCode:= 3;
            for II := List20.Count - 1 downto 0 do begin
              if List20.Count <= 0 then Break;
              UserItem := List20.Items[II];
              nCode:= 4;
              if UserItem <> nil then begin
                nCode:= 5;
                CopyStdItemToOStdItem(StdItem, @OClientItem.s);
                nCode:= 6;
                OClientItem.Dura := UserItem.Dura;
                OClientItem.DuraMax := GetUserPrice(PlayObject, GetUserItemPrice(UserItem));
                OClientItem.MakeIndex := UserItem.MakeIndex;
                s1C := s1C + EncodeBuffer(@OClientItem, SizeOf(TOClientItem)) + '/';
                Inc(n18);
                if n18 >= 10 then Break;
              end;
            end;
            Break;
          end;
        end;//for
      end;
      nCode:= 7;
      PlayObject.SendMsg(Self, RM_SENDDETAILGOODSLIST, 0, Integer(Self), n18, nInt, s1C);
    end else begin
      nCode:= 8;
      n18 := 0;
      if m_GoodsList.Count > 0 then begin//20080629
        for I := 0 to m_GoodsList.Count - 1 do begin
          List20 := TList(m_GoodsList.Items[I]);
          if List20 = nil then Continue;
          if List20.Count <= 0 then Continue;
          nCode:= 9;
          UserItem := List20.Items[0];
          if UserItem = nil then Continue;
          nCode:= 10;
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) and (StdItem.Name = sItemName) then begin

            if nInt > List20.Count - 10 then
              nInt := List20.Count - 10;
            if nInt < 0 then
              nInt := 0;
            nCode:= 11;
            //for II := List20.Count - 1 downto 0 do begin
            //修复不支持翻页By TasNat at: 2012-11-11 20:39:37
            for II := nInt to _MIN(nInt + 10, List20.Count - 1) do begin
              UserItem := List20.Items[II];
              nCode:= 12;
              if CheckIsOKItem(UserItem) then Continue;//检查变态物品 20081009
              nCode:= 13;
              if UserItem <> nil then begin
                nCode:= 14;
                ClientItem.s := StdItem^;
                {$IF M2Version <> 2}
                if (StdItem.StdMode = 5) or (StdItem.StdMode = 6) then begin//武器暴击等级 20101021
                  ClientItem.s.NeedIdentify:= _MIN(High(Byte),UserItem.btValue[11] + UserItem.btValue[20]);
                end;
                if (StdItem.StdMode = 44) and (StdItem.shape = 255) then begin//神秘卷轴
                  ClientItem.s.NeedIdentify:= UserItem.btValue[0];
                end;
                {$IFEND}
                ClientItem.Dura := UserItem.Dura;
                ClientItem.DuraMax := GetUserPrice(PlayObject, GetUserItemPrice(UserItem));
                ClientItem.MakeIndex := UserItem.MakeIndex;
                //Modified By TasNat at: 2012-04-12 09:28:18
                ClientItem.btAppraisalLevel :=   UserItem.btAppraisalLevel;
                ClientItem.btUnKnowValueCount := UserItem.btUnKnowValueCount;
                Move(UserItem.btAppraisalValue, ClientItem.btAppraisalValue, SizeOf(UserItem.btAppraisalValue));
                Move(UserItem.btUnKnowValue, ClientItem.btUnKnowValue, SizeOf(ClientItem.btUnKnowValue));//20100822
                ClientItem.BindValue:= UserItem.AddValue[0];//20110622
                ClientItem.MaxDate:= UserItem.MaxDate;//20110622
                if ClientItem.BindValue = 0 then begin//禁止交易,扔物品,显示绑定 20110626
                  if (CheckItemValue(UserItem ,1) and CheckItemValue(UserItem ,0)) or
                    (GetCheckItemList(0, StdItem.Name) and GetCheckItemList(1, StdItem.Name)) then
                    ClientItem.BindValue := 3;
                end;
                s1C := s1C + EncodeBuffer(@ClientItem, SizeOf(ClientItem)) + '/';
                Inc(n18);
                if n18 >= 10 then Break;
              end;
            end;
            Break;
          end;
        end;//for
      end;
      nCode:= 15;
      PlayObject.SendMsg(Self, RM_SENDDETAILGOODSLIST, 0, Integer(Self), n18, nInt, s1C);
    end;
  except
    on E: Exception do begin
      MainOutMessage(Format('{%s} TMerchant.ClientGetDetailGoodsList Code:%d',[g_sExceptionVer, nCode]));
    end;  
  end;
end;
{$IF M2Version <> 2}
//取装备可交换的卷轴碎片数量 20100812
procedure TMerchant.ClientQueryArmsExchangeCount(PlayObject: TPlayObject; UserItem: pTUserItem);
var
  nC: Integer;
  StdItem: pTStdItem;
begin
  nC:= 0;
  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
  if StdItem <> nil then begin
    if CanArmsExchangeItem(StdItem.Name) then nC := GetArmsExchangeItemCount(StdItem.Name);
  end;
  PlayObject.SendMsg(Self, RM_SENDARMSEXCHANGEPRICE, 0, nC, 0, 0, '');
end;
//客户端兑换卷轴碎片 20100812
function TMerchant.ClientArmsExhangeItem(PlayObject: TPlayObject; UserItem: pTUserItem): Boolean;
var
  nPrice: Integer;
  StdItem, StdItem1: pTStdItem;
  UserItem1: pTUserItem;
begin
  Result := False;
  try
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then begin
      if CanArmsExchangeItem(StdItem.Name) then nPrice := GetArmsExchangeItemCount(StdItem.Name);
    end;
    if (nPrice > 0) then begin
      New(UserItem1);
      if UserEngine.CopyToUserItemFromName(g_Config.sArmsExchangeItme, UserItem1) then begin//给予卷轴碎片
        UserItem1.Dura:= nPrice;
        if UserItem1.Dura > UserItem1.DuraMax then UserItem1.Dura:= UserItem1.DuraMax;
        if not PlayObject.AutoItemMerger(UserItem1) then begin//自动合并物品
          PlayObject.m_ItemList.Add(UserItem1);
          PlayObject.SendAddItem(UserItem1);
          StdItem1 := UserEngine.GetStdItem(UserItem1.wIndex);
          if StdItem1.NeedIdentify = 1 then
            AddGameDataLog('9' + #9 + PlayObject.m_sMapName + #9 +
              IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
              PlayObject.m_sCharName + #9 + StdItem1.Name + #9 +
              IntToStr(UserItem1.MakeIndex) + #9 +
              IntToStr(UserItem1.Dura)+'/'+IntToStr(UserItem1.DuraMax)+ #9 + m_sCharName+ '(兑换)');
        end;
        PlayObject.SendMsg(Self, RM_USERARMSEXCHANGE_OK, 0, 0, 0, 0, '');
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog('10' + #9 + PlayObject.m_sMapName + #9 +
            IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
            PlayObject.m_sCharName + #9 + StdItem.Name + #9 +
            IntToStr(UserItem.MakeIndex) + #9 +
            IntToStr(UserItem.Dura)+'/'+IntToStr(UserItem.DuraMax)+ #9 + m_sCharName+ '(兑换)');
        if g_sArmsExhangeItemHintMsg <> '' then PlayObject.SysMsg(Format_ToStr(g_sArmsExhangeItemHintMsg,[g_Config.sArmsExchangeItme, nPrice]), c_Blue, t_Hint);
        Result := True;
      end else begin
        Dispose(UserItem1);
      end;
    end else begin
      PlayObject.SendMsg(Self, RM_USERARMSEXCHANGE_FAIL, 0, 0, 0, 0, '');
    end;
  except
    MainOutMessage(Format('{%s} TMerchant.ClientArmsExhangeItem',[g_sExceptionVer]));
  end;
end;
{$IFEND}
procedure TMerchant.ClientQuerySellPrice(PlayObject: TPlayObject; UserItem: pTUserItem);
var
  nC: Integer;
begin
  try
    nC := GetSellItemPrice(GetUserItemPrice(UserItem));
    if (nC >= 0) then begin
      PlayObject.SendMsg(Self, RM_SENDBUYPRICE, 0, nC, 0, 0, '');
    end else begin
      PlayObject.SendMsg(Self, RM_SENDBUYPRICE, 0, 0, 0, 0, '');
    end;
  except
    MainOutMessage(Format('{%s} TMerchant.ClientQuerySellPrice',[g_sExceptionVer]));
  end;
end;
//取出售物品的价格
function TMerchant.GetSellItemPrice(nPrice: Integer): Integer;
begin
  Result := Round(nPrice / 2.0);
end;
//客户端出售物品
function TMerchant.ClientSellItem(PlayObject: TPlayObject; UserItem: pTUserItem): Boolean;
  function sub_4A1C84(UserItem: pTUserItem): Boolean;
  var
    StdItem: pTStdItem;
  begin
    Result := True;
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if (StdItem <> nil) then begin
      if ((StdItem.StdMode = 25) or (StdItem.StdMode = 30)) then begin
        if UserItem.Dura < 4000 then Result := False;
      end;
    end;
  end;
var
  nPrice: Integer;
  StdItem: pTStdItem;
begin
  try
    Result := False;
    nPrice := GetSellItemPrice(GetUserItemPrice(UserItem));
    if (nPrice > 0) and sub_4A1C84(UserItem) then begin
      if PlayObject.IncGold(nPrice) then begin
       { if m_boCastle or g_Config.boGetAllNpcTax then
          UserCastle.IncRateGold(nPrice);  }
        if m_boCastle or g_Config.boGetAllNpcTax then begin
          if m_Castle <> nil then begin
            TUserCastle(m_Castle).IncRateGold(nPrice);
          end else
            if g_Config.boGetAllNpcTax then begin
            g_CastleManager.IncRateGold(g_Config.nUpgradeWeaponPrice);
          end;
        end;
        PlayObject.GoldChanged(); //更新客户端金币 20090427 移动位置，修正出售后，左上角无提示
        PlayObject.SendMsg(Self, RM_USERSELLITEM_OK, 0, PlayObject.m_nGold, 0, 0, '');
        AddItemToGoodsList(UserItem);
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem <> nil then begin
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('10' + #9 + PlayObject.m_sMapName + #9 +
              IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
              PlayObject.m_sCharName + #9 + StdItem.Name + #9 +
              IntToStr(UserItem.MakeIndex) + #9 +
              '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
              '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
              '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
              '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
              '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
              IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
              IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
              IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
              IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
        end;
        Result := True;
      end else begin
        PlayObject.SendMsg(Self, RM_USERSELLITEM_FAIL, 0, 0, 0, 0, '');
      end;
    end else begin
      PlayObject.SendMsg(Self, RM_USERSELLITEM_FAIL, 0, 0, 0, 0, '');
    end;
  except
    MainOutMessage(Format('{%s} TMerchant.ClientSellItem',[g_sExceptionVer]));
  end;
end;
//增加物品到销售表中
function TMerchant.AddItemToGoodsList(UserItem: pTUserItem): Boolean;
var
  ItemList: TList;
begin
  try
    Result := False;           //检查变态物品 20081010
    if (UserItem.Dura <= 0) or CheckIsOKItem(UserItem) then Exit;
    ItemList := GetRefillList(UserItem.wIndex);
    if ItemList = nil then begin
      ItemList := TList.Create;
      m_GoodsList.Add(ItemList);
    end;
    ItemList.Insert(0, UserItem);
    Result := True;
  except
    MainOutMessage(Format('{%s} TMerchant.AddItemToGoodsList',[g_sExceptionVer]));
  end;
end;
////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////拍卖/////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
(*//拍卖物品名称 持久是否大于0  价格如果是自己的为负  数量   //20080416 去掉拍卖功能
procedure TMerchant.ClientGetDetailSellGoodsList(PlayObject: TPlayObject; sItemName: string;
  nInt: Integer); //004A26F0
var
  {I,} II, n18: Integer;
  List20: TList;
  StdItem: pTStdItem;
  //ClientItem: TClientItem;
  ClientEffecItem: TClientEffecItem;
  OClientItem: TOClientItem;
  s1C: string;
  SellOffInfo: pTSellOffInfo;
//  nPrice: Integer;
begin
  if PlayObject.m_nSoftVersionDateEx = 0 then begin
    n18 := 0;
    s1C := '';
    g_SellOffGoodList.GetUserSellOffGoodListByItemName(sItemName, List20);
    if List20 <> nil then begin
      SellOffInfo := List20.Items[0];
      if SellOffInfo = nil then Exit;
      StdItem := UserEngine.GetStdItem(SellOffInfo.UseItems.wIndex);
      if StdItem <> nil then begin
        if (List20.Count - 1) < nInt then begin
          nInt := _MAX(0, List20.Count - 10);
        end;
        for II := List20.Count - 1 downto 0 do begin
          if List20.Count <= 0 then Break;
          SellOffInfo := pTSellOffInfo(List20.Items[II]);
          if SellOffInfo = nil then Continue;
          CopyStdItemToOStdItem(StdItem, @OClientItem.s);
          if CompareText(PlayObject.m_sCharName, SellOffInfo.sCharName) = 0 then begin
            OClientItem.s.Price := -SellOffInfo.nSellGold;
          end else begin
            OClientItem.s.Price := SellOffInfo.nSellGold;
          end;
          OClientItem.Dura := SellOffInfo.UseItems.Dura;
          OClientItem.DuraMax := SellOffInfo.UseItems.DuraMax;
          OClientItem.MakeIndex := SellOffInfo.UseItems.MakeIndex;
          s1C := s1C + EncodeBuffer(@OClientItem, SizeOf(TOClientItem)) + '/';
          Inc(n18);
        end;
      end;
    end;
    PlayObject.SendMsg(Self, RM_SENDSELLOFFITEMLIST, 0, Integer(Self), n18, nInt, s1C);
  end else begin
    n18 := 0;
    s1C := '';
    g_SellOffGoodList.GetUserSellOffGoodListByItemName(sItemName, List20);
    if List20 <> nil then begin
      SellOffInfo := List20.Items[0];
      if SellOffInfo = nil then Exit;
      StdItem := UserEngine.GetStdItem(SellOffInfo.UseItems.wIndex);
      if StdItem <> nil then begin
        if (List20.Count - 1) < nInt then begin
          nInt := _MAX(0, List20.Count - 10);
        end;
        for II := List20.Count - 1 downto 0 do begin
          if List20.Count <= 0 then Break;
          SellOffInfo := List20.Items[II];
          ClientEffecItem.s := StdItem^;
          if SellOffInfo = nil then Continue;
          if CompareText(PlayObject.m_sCharName, SellOffInfo.sCharName) = 0 then begin
            ClientEffecItem.s.Price := -SellOffInfo.nSellGold;
          end else begin
            ClientEffecItem.s.Price := SellOffInfo.nSellGold;
          end;
          ClientEffecItem.Dura := SellOffInfo.UseItems.Dura;
          ClientEffecItem.DuraMax := SellOffInfo.UseItems.DuraMax;
          ClientEffecItem.MakeIndex := SellOffInfo.UseItems.MakeIndex;
          s1C := s1C + EncodeBuffer(@ClientEffecItem, SizeOf(TClientEffecItem)) + '/';
          Inc(n18);
        end;
      end;
    end;
  end;
  PlayObject.SendMsg(Self, RM_SENDSELLOFFITEMLIST, 0, Integer(Self), n18, nInt, s1C);
end;

procedure TMerchant.ClientBuySellOffItem(PlayObject: TPlayObject; sItemName: string;
  nInt: Integer);
var
//  I, II: Integer;
  bo29: Boolean;
//  List20: TList;
//  ItemPrice: pTItemPrice;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  n1C{, nPrice}: Integer;
//  sUserItemName: string;
  SellOffInfo: pTSellOffInfo;
  AddSellOffInfo: pTSellOffInfo;
  OnlinePlayObject: TPlayObject;
begin
  //n1C = 1 物品已经拍卖了  n1C = 2 无法携带更多的物品 n1C = 3 没有足够的元宝购买物品
  bo29 := False;
  n1C := 1;
  if (bo29) then Exit;
  g_SellOffGoodList.GetUserSellOffItem(sItemName, nInt, SellOffInfo, StdItem);
  if (SellOffInfo <> nil) and (StdItem <> nil) then begin
    if (SellOffInfo.UserItem.AddValue[0] = 1) and (GetHoursCount(SellOffInfo.UserItem.MaxDate, Now) <= 0) then begin //删除到期装备
      g_SellList.Delete(SellOffInfo, True);
      Exit;
    end;
    if PlayObject.IsAddWeightAvailable(StdItem.Weight) then begin
      if CompareText(PlayObject.m_sCharName, SellOffInfo.sCharName) = 0 then begin
        New(UserItem);
        UserItem^ := SellOffInfo.UseItems;
        {UserItem^.MakeIndex := SellOffInfo.UseItems.MakeIndex;
        UserItem^.wIndex := SellOffInfo.UseItems.MakeIndex;
        UserItem^.Dura := SellOffInfo.UseItems.Dura;
        UserItem^.DuraMax := SellOffInfo.UseItems.DuraMax;
        UserItem^.btValue := SellOffInfo.UseItems.btValue; }
        if PlayObject.AddItemToBag(UserItem) then begin
          PlayObject.SendAddItem(UserItem);
          g_SellOffGoodList.DelSellOffItem(UserItem.MakeIndex);
          bo29 := True;
          n1C := 0;
        end else n1C := 2;
      end else
        if (PlayObject.m_nGameGold >= SellOffInfo.nSellGold) and (SellOffInfo.nSellGold > 0) then begin
        New(UserItem);
        UserItem^ := SellOffInfo.UseItems;
        {UserItem.MakeIndex := SellOffInfo.UseItems.MakeIndex;
        UserItem.wIndex := SellOffInfo.UseItems.MakeIndex;
        UserItem.Dura := SellOffInfo.UseItems.Dura;
        UserItem.DuraMax := SellOffInfo.UseItems.DuraMax;
        UserItem.btValue := SellOffInfo.UseItems.btValue; }
        if PlayObject.AddItemToBag(UserItem) then begin
          Dec(PlayObject.m_nGameGold, SellOffInfo.nSellGold);
          PlayObject.SendAddItem(UserItem);
          New(AddSellOffInfo);
          AddSellOffInfo^ := SellOffInfo^;
          {AddSellOffInfo.sCharName := SellOffInfo.sCharName;
          AddSellOffInfo.dSellDateTime := SellOffInfo.dSellDateTime;
          AddSellOffInfo.nSellGold := SellOffInfo.nSellGold;
          AddSellOffInfo.n := SellOffInfo.n;
          AddSellOffInfo.UseItems := SellOffInfo.UseItems;
          AddSellOffInfo.n1 := SellOffInfo.n1;  }
          g_SellOffGoldList.AddItemToSellOffGoldList(AddSellOffInfo);
          g_SellOffGoodList.DelSellOffItem(UserItem.MakeIndex);
          PlayObject.GameGoldChanged;
          OnlinePlayObject := UserEngine.GetPlayObject(SellOffInfo.sCharName);
          if OnlinePlayObject <> nil then begin
            OnlinePlayObject.SysMsg(PlayObject.m_sCharName + ' 购买了你的 ' + sItemName, c_Red, t_Hint);
          end;
          n1C := 0;
        end else n1C := 2;
      end else n1C := 3;
      bo29 := True;
    end else n1C := 2;
  end;
  if n1C = 0 then begin
    PlayObject.SendMsg(Self, RM_SENDBUYSELLOFFITEM_OK, 0, PlayObject.m_nGameGold, nInt, 0, '');
  end else begin
    PlayObject.SendMsg(Self, RM_SENDBUYSELLOFFITEM_FAIL, 0, n1C, 0, 0, '');
  end;
end;
//客户端寄售物品
function TMerchant.ClientSellOffItem(PlayObject: TPlayObject;
  SellOffInfo: pTSellOffInfo; sName: string): Boolean;
  function sub_4A1C84(UserItem: pTUserItem): Boolean;
  var
    StdItem: pTStdItem;
  begin
    Result := True;
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if (StdItem <> nil) and ((StdItem.StdMode = 25) or (StdItem.StdMode = 30)) then begin
      if UserItem.Dura < 4000 then Result := False;
    end;
  end;
//var
//  nPrice: Integer;
//  StdItem: pTStdItem;
begin
  Result := False;
  if not CanSellOffItem(sName) then begin
    PlayObject.SendMsg(Self, RM_SENDUSERSELLOFFITEM_FAIL, 0, -4, 0, 0, ''); //不允许拍卖
    Dispose(SellOffInfo);
    Exit;
  end;
  if g_SellOffGoodList.GetUserLimitSellOffCount(SellOffInfo.sCharName) then begin //超过限制数量
    PlayObject.SendMsg(Self, RM_SENDUSERSELLOFFITEM_FAIL, 0, -3, 0, 0, ''); //超过限制数量
    Dispose(SellOffInfo);
    Exit;
  end;
  if sub_4A1C84(@SellOffInfo.UseItems) then begin
    if g_SellOffGoodList.AddItemToSellOffGoodsList(SellOffInfo) then begin
      PlayObject.SendMsg(Self, RM_SENDUSERSELLOFFITEM_OK, 0, 0, 0, 0, '');
      //g_SellOffGoodList.SaveSellOffGoodList();
      Result := True;
    end else begin
      PlayObject.SendMsg(Self, RM_SENDUSERSELLOFFITEM_FAIL, 0, -1, 0, 0, '');
    end;
  end else begin //004A1EA0
    PlayObject.SendMsg(Self, RM_SENDUSERSELLOFFITEM_FAIL, 0, -2, 0, 0, '');
  end;
end;
///////////////////////////////////////拍卖///////////////////////////////////// *)
//客户端取制造的药品,制造毒药(其它物品)
procedure TMerchant.ClientMakeDrugItem(PlayObject: TPlayObject; sItemName: string);
  function sub_4A28FC(PlayObject: TPlayObject; sItemName: string): Boolean;
  var
    I, II, n1C: Integer;
    List10: TStringList;
    s20: string;
    List28: TStringList;
    UserItem: pTUserItem;
  begin
    Result := False;
    List10 := GetMakeItemInfo(sItemName);
    if List10 = nil then Exit;
    Result := True;
    if List10.Count > 0 then begin//20080629
      for I := 0 to List10.Count - 1 do begin
        s20 := List10.Strings[I];
        n1C := Integer(List10.Objects[I]);
        if PlayObject.m_ItemList.Count > 0 then begin
          for II := 0 to PlayObject.m_ItemList.Count - 1 do begin
            if UserEngine.GetStdItemName(pTUserItem(PlayObject.m_ItemList.Items[II]).wIndex) = s20 then Dec(n1C);
          end;
        end;
        if n1C > 0 then begin
          Result := False;
          Break;
        end;
      end; // for
    end;
    if Result then begin
      List28 := nil;
      if List10.Count > 0 then begin//20080629
        for I := 0 to List10.Count - 1 do begin
          s20 := List10.Strings[I];
          n1C := Integer(List10.Objects[I]);
          if PlayObject.m_ItemList.Count > 0 then begin//20081008
            for II := PlayObject.m_ItemList.Count - 1 downto 0 do begin
              if n1C <= 0 then Break;
              if PlayObject.m_ItemList.Count <= 0 then Break;
              UserItem := PlayObject.m_ItemList.Items[II];
              if UserItem = nil then Continue;
              if UserEngine.GetStdItemName(UserItem.wIndex) = s20 then begin
                if List28 = nil then List28 := TStringList.Create;
                List28.AddObject(s20, TObject(UserItem.MakeIndex));
                Dispose(UserItem);
                PlayObject.m_ItemList.Delete(II);
                Dec(n1C);
              end;
            end;
          end;
        end;//for
      end;
      if List28 <> nil then begin
        PlayObject.SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(List28), 0, 0, '');
      end;
    end;
  end;
var
  I: Integer;
  List1C: TList;
  MakeItem, UserItem: pTUserItem;
  StdItem: pTStdItem;
  n14: Integer;
begin
try
  n14 := 1;
  if m_GoodsList.Count > 0 then begin//20080629
    for I := 0 to m_GoodsList.Count - 1 do begin
      List1C := TList(m_GoodsList.Items[I]);
      if List1C = nil then Continue;
      if List1C.Count <= 0 then Continue;
      MakeItem := List1C.Items[0];
      if MakeItem = nil then Continue;
      StdItem := UserEngine.GetStdItem(MakeItem.wIndex);
      if (StdItem <> nil) and (StdItem.Name = sItemName) then begin
        if PlayObject.m_nGold >= g_Config.nMakeDurgPrice then begin
          if sub_4A28FC(PlayObject, sItemName) then begin
            New(UserItem);
            UserEngine.CopyToUserItemFromName(sItemName, UserItem);
            if PlayObject.AddItemToBag(UserItem) then begin
              Dec(PlayObject.m_nGold, g_Config.nMakeDurgPrice);
              PlayObject.SendAddItem(UserItem);
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem.NeedIdentify = 1 then
                AddGameDataLog('2' + #9 + PlayObject.m_sMapName + #9 +
                  IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                  PlayObject.m_sCharName + #9 + StdItem.Name + #9 +
                  IntToStr(UserItem.MakeIndex) + #9 +
                  '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                  '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                  '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                  '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                  '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                  IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                  IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                  IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                  IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
              n14 := 0;
              Break;
            end else begin
              Dispose(UserItem);
              n14 := 2;
            end;
          end else n14 := 4;
        end else n14 := 3;
      end;
    end; // for
  end;
  if n14 = 0 then begin
    PlayObject.SendMsg(Self, RM_MAKEDRUG_SUCCESS, 0, PlayObject.m_nGold, 0, 0, '');
  end else begin
    PlayObject.SendMsg(Self, RM_MAKEDRUG_FAIL, 0, n14, 0, 0, '');
  end;
except
  MainOutMessage(Format('{%s} TMerchant.ClientMakeDrugItem',[g_sExceptionVer]));
end;
end;
//客户查询修复所需成本
procedure TMerchant.ClientQueryRepairCost(PlayObject: TPlayObject; UserItem: pTUserItem);
var
  nPrice, nRepairPrice: Integer;
begin
try
  nPrice := GetUserPrice(PlayObject, GetUserItemPrice(UserItem));
  if (nPrice > 0) and (UserItem.DuraMax > UserItem.Dura) then begin
    if UserItem.DuraMax > 0 then begin
      nRepairPrice := Round(nPrice div 3 / UserItem.DuraMax * (UserItem.DuraMax - UserItem.Dura));
    end else begin
      nRepairPrice := nPrice;
    end;
    if (PlayObject.m_sScriptLable = sSUPERREPAIR) then begin
      if m_boS_repair then nRepairPrice := nRepairPrice * g_Config.nSuperRepairPriceRate {3}
      else nRepairPrice := -1;
    end else begin
      if not m_boRepair then nRepairPrice := -1;
    end;
    PlayObject.SendMsg(Self, RM_SENDREPAIRCOST, 0, nRepairPrice, 0, 0, '');
  end else begin
    PlayObject.SendMsg(Self, RM_SENDREPAIRCOST, 0, -1, 0, 0, '');
  end;
except
  MainOutMessage(Format('{%s} TMerchant.ClientQueryRepairCost',[g_sExceptionVer]));
end;
end;
//修理物品
function TMerchant.ClientRepairItem(PlayObject: TPlayObject; UserItem: pTUserItem): Boolean;
var
  nPrice, nRepairPrice: Integer;
  StdItem: pTStdItem;
  boCanRepair: Boolean;
begin
  try
    Result := False;
    boCanRepair := True;
    if (PlayObject.m_sScriptLable = sSUPERREPAIR) and not m_boS_repair then begin
      boCanRepair := False;
    end;
    if (PlayObject.m_sScriptLable <> sSUPERREPAIR) and not m_boRepair then begin
      boCanRepair := False;
    end;
    if PlayObject.m_sScriptLable = '@fail_s_repair' then begin
      SendMsgToUser(PlayObject, '对不起, 我不能修复这个物品\ \ \<Main/@main>');
      PlayObject.SendMsg(Self, RM_USERREPAIRITEM_FAIL, 0, 0, 0, 0, '');
      Exit;
    end;
    nPrice := GetUserPrice(PlayObject, GetUserItemPrice(UserItem));
    if PlayObject.m_sScriptLable = sSUPERREPAIR then begin
      nPrice := nPrice * g_Config.nSuperRepairPriceRate {3};
    end;
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then begin
      if boCanRepair and (nPrice > 0) and (UserItem.DuraMax > UserItem.Dura) and (StdItem.StdMode <> 43) and (StdItem.StdMode <> 51) and (StdItem.StdMode <> 17) and (StdItem.StdMode <> 2) and (StdItem.StdMode <> 7) and (StdItem.StdMode <> 25) then begin//20090814 增加51分类
        if UserItem.DuraMax > 0 then begin
          nRepairPrice := Round(nPrice div 3 / UserItem.DuraMax * (UserItem.DuraMax - UserItem.Dura));
        end else begin
          nRepairPrice := nPrice;
        end;
        if PlayObject.DecGold(nRepairPrice) then begin
          //if m_boCastle or g_Config.boGetAllNpcTax then UserCastle.IncRateGold(nRepairPrice);
          if m_boCastle or g_Config.boGetAllNpcTax then begin
            if m_Castle <> nil then begin
              TUserCastle(m_Castle).IncRateGold(nRepairPrice);
            end else
              if g_Config.boGetAllNpcTax then begin
              g_CastleManager.IncRateGold(g_Config.nUpgradeWeaponPrice);
            end;
          end;
          if PlayObject.m_sScriptLable = sSUPERREPAIR then begin
            UserItem.Dura := UserItem.DuraMax;
            PlayObject.SendMsg(Self, RM_USERREPAIRITEM_OK, 0, PlayObject.m_nGold, UserItem.Dura, UserItem.DuraMax, '');
            PlayObject.GoldChanged(); //更新客户端金币 20080417
            GotoLable(PlayObject, sSUPERREPAIROK, False, False);
          end else begin
            Dec(UserItem.DuraMax, (UserItem.DuraMax - UserItem.Dura) div g_Config.nRepairItemDecDura {30});
            UserItem.Dura := UserItem.DuraMax;
            PlayObject.SendMsg(Self, RM_USERREPAIRITEM_OK, 0, PlayObject.m_nGold, UserItem.Dura, UserItem.DuraMax, '');
            PlayObject.GoldChanged(); //更新客户端金币 20080417
            GotoLable(PlayObject, sREPAIROK, False, False);
          end;
          Result := True;
        end else PlayObject.SendMsg(Self, RM_USERREPAIRITEM_FAIL, 0, 0, 0, 0, '');
      end else PlayObject.SendMsg(Self, RM_USERREPAIRITEM_FAIL, 0, 0, 0, 0, '');
    end;
  except
    MainOutMessage(Format('{%s} TMerchant.ClientRepairItem',[g_sExceptionVer]));
  end;
end;

procedure TMerchant.ClearScript;
begin
  m_boBuy := False;
  m_boSell := False;
  m_boMakeDrug := False;
  m_boPrices := False;
  m_boStorage := False;
  m_boGetback := False;
  m_boBigStorage := False;
  m_boBigGetBack := False;
  m_boGetNextPage := False;
  m_boGetPreviousPage := False;
  m_boCqFirHero := False;
  m_boBuHero := False;//20080514
  m_boPlayMakeWine:= False;//酿酒NPC 20080619
  m_boUserLevelOrder := False;
  m_boWarrorLevelOrder := False;
  m_boWizardLevelOrder := False;
  m_boTaoistLevelOrder := False;
  m_boMasterCountOrder := False;

  m_boUpgradenow := False;
  m_boGetBackupgnow := False;
  m_boRepair := False;
  m_boArmsTear := False;
  m_boArmsExchange := False;
  m_boS_repair := False;
  m_boGetMarry := False;
  m_boGetMaster := False;
  m_boUseItemName := False;

  //m_boGetSellGold := False;//20080416 去掉拍卖功能
  //m_boSellOff := False;//20080416 去掉拍卖功能
  //m_boBuyOff := False;//20080416 去掉拍卖功能
  m_boofflinemsg := False;
  m_boDealGold := False;
  inherited ClearScript;
end;

procedure TMerchant.LoadUpgradeList;
var
  I: Integer;
begin
  try
    if m_UpgradeWeaponList.Count > 0 then begin//20080629
      for I := 0 to m_UpgradeWeaponList.Count - 1 do begin
        if pTUpgradeInfo(m_UpgradeWeaponList.Items[I]) <> nil then
          Dispose(pTUpgradeInfo(m_UpgradeWeaponList.Items[I]));
      end; // for
    end;
    m_UpgradeWeaponList.Clear;

    FrmDB.LoadUpgradeWeaponRecord(m_sScript + '-' + m_sMapName, m_UpgradeWeaponList);
  except
    MainOutMessage('读取武器升级列表失败 - ' + m_sCharName);
  end;
end;
{未使用 20080411
procedure TMerchant.GetMarry(PlayObject: TPlayObject; sDearName: string);
var
  MarryHuman: TPlayObject;
begin
  MarryHuman := UserEngine.GetPlayObject(sDearName);
  if (MarryHuman <> nil) and
    (MarryHuman.m_PEnvir = PlayObject.m_PEnvir) and
    (abs(PlayObject.m_nCurrX - MarryHuman.m_nCurrX) < 5) and
    (abs(PlayObject.m_nCurrY - MarryHuman.m_nCurrY) < 5) then begin
    SendMsgToUser(MarryHuman, PlayObject.m_sCharName + ' 向你求婚，你是否愿意嫁给他为妻？');
  end else begin
    Self.SendMsgToUser(PlayObject, sDearName + ' 没有在你身边，你的请求无效！！！');
  end;
end; }

procedure TMerchant.SendCustemMsg(PlayObject: TPlayObject; sMsg: string);
begin
  inherited;
end;

//清除临时文件，包括交易库存，价格表
procedure TMerchant.ClearData;
var
  I, II: Integer;
  UserItem: pTUserItem;
  ItemList: TList;
  ItemPrice: pTItemPrice;
resourcestring
  sExceptionMsg = '{%s} TMerchant::ClearData';
begin
  try
    if m_GoodsList.Count > 0 then begin//20080629
      for I := 0 to m_GoodsList.Count - 1 do begin
        ItemList := TList(m_GoodsList.Items[I]);
        if ItemList = nil then Continue;
        if ItemList.Count > 0 then begin//20080627
          for II := 0 to ItemList.Count - 1 do begin
            UserItem := ItemList.Items[II];
            if UserItem <> nil then Dispose(UserItem);
          end;
        end;
        ItemList.Free;
      end;//for
    end;
    m_GoodsList.Clear;
    if m_ItemPriceList.Count > 0 then begin//20080627
      for I := 0 to m_ItemPriceList.Count - 1 do begin
        ItemPrice := m_ItemPriceList.Items[I];
        if ItemPrice <> nil then Dispose(ItemPrice);
      end;
    end;
    m_ItemPriceList.Clear;
    SaveNPCData();
  except
    on E: Exception do begin
      MainOutMessage(Format(sExceptionMsg,[g_sExceptionVer]));
      //MainOutMessage(E.Message);
    end;
  end;
end;

procedure TMerchant.ChangeUseItemName(PlayObject: TPlayObject; sLabel, sItemName: string);
var
  sWhere: string;
  btWhere: Byte;
  UserItem: pTUserItem;
  sMsg: string;
  sChangeUseItemName: string;
begin
  try
    if not PlayObject.m_boChangeItemNameFlag then begin
      Exit;
    end;
    PlayObject.m_boChangeItemNameFlag := False;
    sWhere := Copy(sLabel, 14{Length(sUSEITEMNAME) + 1}, Length(sLabel) - 13{Length(sUSEITEMNAME)});
    btWhere := Str_ToInt(sWhere, -1);
    if btWhere in [Low(THumanUseItems)..High(THumanUseItems)] then begin//9格装备+4格装备
      UserItem := @PlayObject.m_UseItems[btWhere];
      if UserItem.wIndex = 0 then begin
        sMsg := Format(g_sYourUseItemIsNul, [GetUseItemName(btWhere)]);
        PlayObject.SendMsg(Self, RM_MENU_OK, 0, Integer(PlayObject), 0, 0, sMsg);
        Exit;
      end;
      if UserItem.btValue[13] = 1 then begin
        ItemUnit.DelCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      end;
      if sItemName <> '' then begin
        if g_Config.boChangeUseItemNameByPlayName then begin
          sChangeUseItemName := PlayObject.m_sCharName + '的' + sItemName;
        end else begin
          sChangeUseItemName := g_Config.sChangeUseItemName + sItemName;
        end;
        ItemUnit.AddCustomItemName(UserItem.MakeIndex, UserItem.wIndex, sChangeUseItemName);
        UserItem.btValue[13] := 1;
      end else begin
        ItemUnit.DelCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        UserItem.btValue[13] := 0;
      end;
      ItemUnit.SaveCustomItemName();
      PlayObject.SendMsg(PlayObject, RM_SENDUSEITEMS, 0, 0, 0, 0, '');
      PlayObject.SendMsg(Self, RM_MENU_OK, 0, Integer(PlayObject), 0, 0, '');
    end;
  except
    MainOutMessage(Format('{%s} TMerchant.ChangeUseItemName',[g_sExceptionVer]));
  end;
end;

{ TTrainer 练功师}

constructor TTrainer.Create;
begin
  inherited;
  m_dw568 := GetTickCount();
  m_btAntiPoison := 0;//20080826 增加
  n56C := 0;
  n570 := 0;
end;

destructor TTrainer.Destroy;
begin
  inherited;
end;

function TTrainer.Operate(ProcessMsg: pTProcessMessage): Boolean;
begin
  Result := False;
  if (ProcessMsg.wIdent = RM_STRUCK) or (ProcessMsg.wIdent = RM_MAGSTRUCK) then begin
  //if (ProcessMsg.wIdent = RM_10101) or (ProcessMsg.wIdent = RM_MAGSTRUCK) then begin
    if (ProcessMsg.BaseObject = Self) { and (ProcessMsg.nParam3 <> 0)} then begin
      Inc(n56C, ProcessMsg.wParam);
      m_dw568 := GetTickCount();
      Inc(n570);
      ProcessSayMsg('破坏力为 ' + IntToStr(ProcessMsg.wParam) + ',平均值为 ' + IntToStr(n56C div n570));
    end;
  end;
  if (ProcessMsg.wIdent = RM_MAGSTRUCK) then Result := inherited Operate(ProcessMsg);
end;

procedure TTrainer.Run;
begin
  m_WAbil.HP := m_WAbil.MaxHP;
  if n570 > 0 then begin
    if (GetTickCount - m_dw568) > 3000{3 * 1000} then begin
      ProcessSayMsg('总破坏力为  ' + IntToStr(n56C) + ',平均值为 ' + IntToStr(n56C div n570));
      n570 := 0;
      n56C := 0;
    end;
  end;
  inherited;
end;
{ TNormNpc } //20101012 修改
function TNormNpc.GetVarValueNew(PlayObject: TPlayObject; sData: string; var sValue: string): Boolean;
var
  sName: string;
begin
  Result:= False;
  sValue := sData;
  if sData = '' then Exit;
  if (sData[1] = '<') and (sData[Length(sData)] = '>') then begin
    sData := ArrestStringEx(sData, '<', '>', sName);
    if sName <> '' then begin
      GetVariableText(PlayObject, sValue, sName);
      Result:= True;
    end;
  end else begin
    if GetValValue(PlayObject, sData, sValue) then Result:= True;
  end;
end;

procedure TNormNpc.ActionOfAddNameDateList(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I: Integer;
  LoadList: TStringList;
  boFound: Boolean;
  sListFileName, sLineText, sHumName, sDate: string;
begin
  sListFileName := g_Config.sEnvirDir + m_sPath + QuestActionInfo.sParam1;
  LoadList := TStringList.Create;
  if FileExists(sListFileName) then begin
    try
      LoadList.LoadFromFile(sListFileName);
    except
      MainOutMessage('文件读取失败1.... => ' + sListFileName);
    end;
  end;
  try
    boFound := False;
    if LoadList.Count > 0 then begin//20080629
      for I := 0 to LoadList.Count - 1 do begin
        sLineText := Trim(LoadList.Strings[I]);
        sLineText := GetValidStr3(sLineText, sHumName, [' ', #9]);
        sLineText := GetValidStr3(sLineText, sDate, [' ', #9]);
        if CompareText(sHumName, PlayObject.m_sCharName) = 0 then begin
          LoadList.Strings[I] := PlayObject.m_sCharName + #9 + DateToStr(Date);
          boFound := True;
          Break;
        end;
      end;
    end;
    if not boFound then LoadList.Add(PlayObject.m_sCharName + #9 + DateToStr(Date));

    LoadList.SaveToFile(sListFileName);
  except
    MainOutMessage('文件保存失败 => ' + sListFileName);
  end;
  LoadList.Free;
end;

procedure TNormNpc.ActionOfDelNameDateList(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I: Integer;
  LoadList: TStringList;
  sLineText, sListFileName, sHumName, sDate: string;
  boFound: Boolean;
begin
  sListFileName := g_Config.sEnvirDir + m_sPath + QuestActionInfo.sParam1;
  LoadList := TStringList.Create;
  if FileExists(sListFileName) then begin
    try
      LoadList.LoadFromFile(sListFileName);
    except
      MainOutMessage('文件读取失败2.... => ' + sListFileName);
      LoadList.Free;
      Exit;
    end;
  end;
  boFound := False;
  if LoadList.Count > 0 then begin//20080629
    for I := 0 to LoadList.Count - 1 do begin
      sLineText := Trim(LoadList.Strings[I]);
      sLineText := GetValidStr3(sLineText, sHumName, [' ', #9]);
      sLineText := GetValidStr3(sLineText, sDate, [' ', #9]);
      if CompareText(sHumName, PlayObject.m_sCharName) = 0 then begin
        LoadList.Delete(I);
        boFound := True;
        Break;
      end;
    end;
  end;
  if boFound then begin
    try
      LoadList.SaveToFile(sListFileName);
    except
      MainOutMessage('文件保存失败  => ' + sListFileName);
    end;
  end;
  LoadList.Free;
end;
//功能：脚本增加技能。
//格式：ADDSKILL 技能名称 技能等级 HERO 是否提示(0/1)(加参数HERO,即是增加英雄技能)
procedure TNormNpc.ActionOfAddSkill(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  Magic: pTMagic;
  UserMagic: pTUserMagic;
  nLevel: Integer;
  sMagicName: string;
  nType: Byte;
  nMaxExp: LongWord;
begin
  try
    sMagicName:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//20090708 支持变量
    nLevel := Str_ToInt(QuestActionInfo.sParam2, 0);
    nType:= Str_ToInt(QuestActionInfo.sParam4, 0);
    if CompareText(QuestActionInfo.sParam3, 'HERO') = 0 then begin
      {$IF HEROVERSION = 1}
      if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then begin //20080519
        //ScriptActionError(PlayObject, '', QuestActionInfo, sSC_ADDSKILL);//20100121 注释
        Exit;
      end;
      Magic := UserEngine.FindHeroMagic(sMagicName);
      if Magic <> nil then begin
        if PlayObject.m_MyHero <> nil then begin
          if Magic.wMagicId = SKILL_75 then begin
            if not PlayObject.m_MyHero.m_boProtectionDefence then begin
              PlayObject.m_MyHero.m_boProtectionDefence:= True; //是否学过护体神盾
              PlayObject.HeroAddSkillFunc(Magic.wMagicId);//英雄学技能触发
              if g_Config.boShowScriptActionMsg and (nType = 0) then begin
                THeroObject(PlayObject.m_MyHero).SysMsg('[英雄] '+Magic.sMagicName + '练习成功。', c_Green, t_Hint);
              end;
            end;
            Exit;
          end;
          if not PlayObject.m_MyHero.IsTrainingSkill(Magic.wMagicId) then begin
            if (Magic.sDescr = '内功') or (Magic.wMagicId = SKILL_95) then begin
              {$IF M2Version <> 2}
              if (not THeroObject(PlayObject.m_MyHero).m_boTrainingNG) then Exit;//没有内功心法,则不能学内功技能 20081001
              {$ELSE}
              Exit;
              {$IFEND}
            end;
            {$IF M2Version = 1}
            if Magic.sDescr = '连击' then begin
              if (not THeroObject(PlayObject.m_MyHero).m_boTrainingNG) or
                (not THeroObject(PlayObject.m_MyHero).m_boOpenHumanPulseArr) then Exit;//没有内功心法
              THeroObject(PlayObject.m_MyHero).m_boTrainBatterSkill:= True;//是否学习过连击技能 20090915
              THeroObject(PlayObject.m_MyHero).m_nUseBatterTick:= GetTickCount();//使用连击的计时
            end;
            {$IFEND}
            case Magic.wMagicId of
              SKILL_FIRECHARM,SKILL_FIRESWORD,SKILL_45,SKILL_66,SKILL_88..SKILL_94: nLevel := _MIN(4, nLevel);
              SKILL_68: nLevel := _MIN(100, nLevel);
              SKILL_71: nLevel := _MIN(99, nLevel);
              SKILL_95: nLevel := _MIN(64, nLevel);//斗转星移最高64级
              SKILL_100: nLevel := _MIN(15, nLevel);
              SKILL_104: nLevel := _MIN(100, nLevel);
              else nLevel := _MIN(3, nLevel);
            end;
            New(UserMagic);
            UserMagic.MagicInfo := Magic;
            UserMagic.wMagIdx := Magic.wMagicId;
            UserMagic.btKey := 0;
            UserMagic.btLevel := nLevel;
            UserMagic.nTranPoint := 0;
            UserMagic.btLevelEx:= 0;
            PlayObject.m_MyHero.m_MagicList.Add(UserMagic);
            {$IF M2Version = 1}
            if (UserMagic.MagicInfo.wMagicId > 75) and (UserMagic.MagicInfo.wMagicId < 88) then begin//连击技能才处理
              THeroObject(PlayObject.m_MyHero).m_BatterMagicList.Add(UserMagic);
            end;
            {$IFEND}
            THeroObject(PlayObject.m_MyHero).SendAddMagic(UserMagic);
            THeroObject(PlayObject.m_MyHero).RecalcAbilitys();//20081213 修改
            PlayObject.m_MyHero.CompareSuitItem(False);//200080729 套装
            {$IF M2Version = 1}
            if Magic.wMagicId = SKILL_95 then begin
              THeroObject(PlayObject.m_MyHero).m_boOpenupSkill95:= False;
              THeroObject(PlayObject.m_MyHero).SendMsg(PlayObject.m_MyHero, RM_HEROABILITY, 0, 0, 0, 0, '');//斗转星移则更新斗转值
            end;
            {$IFEND}
            PlayObject.HeroAddSkillFunc(Magic.wMagicId);//英雄学技能触发  20080828
            if g_Config.boShowScriptActionMsg and (Magic.sDescr <> '连击') and (nType = 0) then begin//20110113 连击技能不提示
              THeroObject(PlayObject.m_MyHero).SysMsg('[英雄] '+Magic.sMagicName + '练习成功。', c_Green, t_Hint);
            end;
          end;
        end;
      end else begin
        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_ADDSKILL);
      end;
      {$IFEND}
    end else begin
      Magic := UserEngine.FindMagic(sMagicName);
      if Magic <> nil then begin
        case Magic.wMagicId of
          SKILL_75: begin
            if not PlayObject.m_boProtectionDefence then begin
              PlayObject.m_boProtectionDefence:= True; //是否学过护体神盾
              PlayObject.AddSkillFunc(Magic.wMagicId);//人物学技能触发
              if g_Config.boShowScriptActionMsg and (nType = 0) then
                PlayObject.SysMsg(Magic.sMagicName + '练习成功。', c_Green, t_Hint);
            end;
            Exit;
          end;
          {$IF M2Version <> 2}
          SKILL_105: if (PlayObject.m_MagicSkill_106 <> nil) or (not PlayObject.m_boTrainingNG) then Exit;
          SKILL_106: if (PlayObject.m_MagicSkill_105 <> nil) or (not PlayObject.m_boTrainingNG) then Exit;
          {$IFEND}
        end;
        if not PlayObject.IsTrainingSkill(Magic.wMagicId) then begin
          {$IF M2Version <> 2}
          if ((Magic.sDescr = '内功') or (Magic.sDescr = '连击') or (Magic.wMagicId = SKILL_95) or (Magic.wMagicId = SKILL_105))
            and (not PlayObject.m_boTrainingNG) then Exit;//没有内功心法,则不能学内功技能和连击技能 20090624
          {$IFEND}
          case Magic.wMagicId of
            SKILL_FIRECHARM,SKILL_FIRESWORD,SKILL_45,SKILL_66,SKILL_88..SKILL_94: nLevel := _MIN(4, nLevel);
            SKILL_68: nLevel := _MIN(100, nLevel);
            SKILL_71: nLevel := _MIN(99, nLevel);
            SKILL_95: nLevel := _MIN(64, nLevel);//斗转星移最高64级
            SKILL_100: nLevel := _MIN(15, nLevel);
            SKILL_104: nLevel := _MIN(100, nLevel);
            SKILL_105: nLevel := _MIN(100, nLevel);
            SKILL_106, SKILL_107, SKILL_108, SKILL_109: nLevel := _MIN(9, nLevel);
            else nLevel := _MIN(3, nLevel);
          end;
          New(UserMagic);
          UserMagic.MagicInfo := Magic;
          UserMagic.wMagIdx := Magic.wMagicId;
          UserMagic.btKey := 0;
          UserMagic.btLevel := nLevel;
          UserMagic.nTranPoint := 0;
          UserMagic.btLevelEx:= 0;
          PlayObject.m_MagicList.Add(UserMagic);
          PlayObject.SendAddMagic(UserMagic);
          PlayObject.RecalcAbilitys();
          PlayObject.CompareSuitItem(False);//200080828 套装
          {$IF M2Version <> 2}
          if Magic.wMagicId = SKILL_105 then begin
            PlayObject.m_sHeartName:= Magic.sMagicName;//心法名称
            PlayObject.m_nHeartType:= 0;//心法类型
          end;
          {$IFEND}
          {$IF M2Version = 1}
          if Magic.wMagicId = SKILL_95 then begin
            PlayObject.m_boOpenupSkill95:= False;
            PlayObject.SendMsg(PlayObject, RM_ABILITY, 0, 0, 0, 0, '');//斗转星移则更新斗转值
          end;
          {$IFEND}
          PlayObject.AddSkillFunc(Magic.wMagicId);//人物学技能触发  20080828
          {$IF M2Version = 1}
          if not PlayObject.m_boTrainBatterSkill then begin
            if Magic.sDescr = '连击' then begin
              PlayObject.m_boTrainBatterSkill:= True;//是否学习过连击技能 20090702
              PlayObject.m_boSendCanBatterMsg:= False;
              PlayObject.m_nUseBatterTick:= GetTickCount();
            end;
          end;
          {$IFEND}
          if g_Config.boShowScriptActionMsg and (Magic.sDescr <> '连击') and (nType = 0) then
            PlayObject.SysMsg(Magic.sMagicName + '练习成功。', c_Green, t_Hint);
        end;
      end else begin
        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_ADDSKILL);
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfAddSkill',[g_sExceptionVer]));
  end;
end;

//功能：添加行会成员  20080427
//格式：ADDGUILDMEMBER 行会名称 人物名称
procedure TNormNpc.ActionOfADDGUILDMEMBER(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  sGuildName,UserName:String;
  Guild: TGuild;
  PlayHum: TPlayObject;
begin
  try
    sGuildName:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1);
    UserName:= GetLineVariableText(PlayObject, QuestActionInfo.sParam2);
    if (sGuildName = '') or (UserName = '') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_ADDGUILDMEMBER);
      Exit;
    end;

    PlayHum := UserEngine.GetPlayObject(UserName);
    Guild:= g_GuildManager.FindGuild(sGuildName);
    if Guild <> nil then begin
      if (PlayHum <> nil) and (not PlayHum.m_boNotOnlineAddExp){ and (PlayHum.m_boAllowGuild) }then begin //人物存在,不是离线挂机,允许加入行会
        if not Guild.IsMember(UserName) then begin //不是行会成员
          if (PlayHum.m_MyGuild = nil) then begin
            if not Guild.IsFull then begin//人物没有行会,并且要加入的行会人员没有满 20110305修改
              Guild.AddMember(PlayHum);
              //UserEngine.SendServerGroupMsg(SS_207, nServerIndex, Guild.sGuildName); //20101022 注释
              PlayHum.m_MyGuild := Guild;
              PlayHum.m_sGuildRankName := Guild.GetRankName(PlayHum, PlayHum.m_nGuildRankNo);
              PlayHum.RefShowName();
              PlayHum.SysMsg('您已加入行会: ' + Guild.sGuildName + ' 当前封号为: ' + PlayHum.m_sGuildRankName, c_Green, t_Hint);
            end;
          end;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfADDGUILDMEMBER',[g_sExceptionVer]));
  end;
end;

//功能：删除行会成员（删除掌门无效）//20080427
//格式：DELGUILDMEMBER 行会名称 人物名称
procedure TNormNpc.ActionOfDELGUILDMEMBER(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  sGuildName,UserName:String;
  Guild: TGuild;
  PlayHum: TPlayObject;
begin
try
  sGuildName:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1);
  UserName:= GetLineVariableText(PlayObject, QuestActionInfo.sParam2);
  if (sGuildName = '') or (UserName = '') then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_DELGUILDMEMBER);
    Exit;
  end;

  PlayHum := UserEngine.GetPlayObject(UserName);
  Guild:= g_GuildManager.FindGuild(sGuildName);
  if Guild <> nil then begin
    if (PlayHum <> nil) and (not PlayHum.m_boNotOnlineAddExp){ and (PlayHum.m_boAllowGuild) }then begin //人物存在,不是离线挂机,允许加入行会
      if Guild.IsMember(UserName) and (PlayHum.m_nGuildRankNo <> 1) then begin //是行会成员
        if Guild.DelMember(UserName) then begin
          PlayHum.m_MyGuild := nil;
          PlayHum.RefRankInfo(0, '');
          PlayHum.RefShowName();
          //UserEngine.SendServerGroupMsg(SS_207, nServerIndex, Guild.sGuildName);//20101022 注释
        end;
      end;
    end;
  end else begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_DELGUILDMEMBER);
    Exit;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfDELGUILDMEMBER',[g_sExceptionVer]));
end;
end;

procedure TNormNpc.ActionOfAutoAddGameGold(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo; nPoint, nTime: Integer);
begin
try
  if CompareText(QuestActionInfo.sParam1, 'START') = 0 then begin
    if (nPoint > 0) and (nTime > 0) then begin
      PlayObject.m_nIncGameGold := nPoint;
      PlayObject.m_dwIncGameGoldTime := LongWord(nTime * 1000);
      PlayObject.m_dwIncGameGoldTick := GetTickCount();
      PlayObject.m_boIncGameGold := True;
      Exit;
    end;
  end;
  if CompareText(QuestActionInfo.sParam1, 'STOP') = 0 then begin
    PlayObject.m_boIncGameGold := False;
    Exit;
  end;
  ScriptActionError(PlayObject, '', QuestActionInfo, sSC_AUTOADDGAMEGOLD);
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfAutoAddGameGold',[g_sExceptionVer]));
end;
end;

//SETAUTOGETEXP 时间 点数 是否安全区 地图号
procedure TNormNpc.ActionOfAutoGetExp(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  nTime, nPoint: Integer;
  boIsSafeZone: Boolean;
  sMAP: string;
  Envir: TEnvirnoment;
begin
  try
    Envir := nil;
    nTime := Str_ToInt(QuestActionInfo.sParam1, -1);
    nPoint := Str_ToInt(QuestActionInfo.sParam2, -1);
    boIsSafeZone := QuestActionInfo.sParam3[1] = '1';
    sMAP := QuestActionInfo.sParam4;
    if sMAP <> '' then begin
      Envir := g_MapManager.FindMap(sMAP);
    end;
    if (nTime <= 0) or (nPoint <= 0) or ((sMAP <> '') and (Envir = nil)) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_SETAUTOGETEXP);
      Exit;
    end;
    PlayObject.m_boAutoGetExpInSafeZone := boIsSafeZone;
    PlayObject.m_AutoGetExpEnvir := Envir;
    PlayObject.m_nAutoGetExpTime := nTime * 1000;
    PlayObject.m_nAutoGetExpPoint := nPoint;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfAutoGetExp',[g_sExceptionVer]));
  end;
end;

procedure TNormNpc.ActionOfAutoSubGameGold(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo; nPoint, nTime: Integer);
begin
  try
    if CompareText(QuestActionInfo.sParam1, 'START') = 0 then begin
      if (nPoint > 0) and (nTime > 0) then begin
        PlayObject.m_nDecGameGold := nPoint;
        PlayObject.m_dwDecGameGoldTime := LongWord(nTime * 1000);
        PlayObject.m_dwDecGameGoldTick := 0;
        PlayObject.m_boDecGameGold := True;
        Exit;
      end;
    end;
    if CompareText(QuestActionInfo.sParam1, 'STOP') = 0 then begin
      PlayObject.m_boDecGameGold := False;
      Exit;
    end;
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_AUTOSUBGAMEGOLD);
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfAutoSubGameGold',[g_sExceptionVer]));
  end;
end;
//功能：创建文件夹  20090616
//格式：CreateDir 文件夹名
procedure TNormNpc.ActionOfCreateDir(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//创建路径 20090616
var
  sDirName: String;
begin
  try
    sDirName:= GetLineVariableText(PlayObject,QuestActionInfo.sParam1);//文件夹名
    if (sDirName = '') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CREATEDIR);
      Exit;
    end;
    if sDirName <> '' then begin
      if sDirName[1] = '\' then sDirName := Copy(sDirName, 2, Length(sDirName) - 1);
      if sDirName[2] = '\' then sDirName := Copy(sDirName, 3, Length(sDirName) - 2);
      if sDirName[3] = '\' then sDirName := Copy(sDirName, 4, Length(sDirName) - 3);
    end;
    sDirName:= g_Config.sEnvirDir + sDirName;
    ForceDirectories(sDirName);
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfCreateDir',[g_sExceptionVer]));
  end;
end;
//功能：复制文本文件  20090824
//格式：CopyFileTxt 源文件 目标文件
//说明：如果文件不存在，则不能复制
procedure TNormNpc.ActionOfCopyFileTxt(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  sSourceName, sFileName: String;
  sLoadList: TStringList;
begin
  try
    sSourceName:= GetLineVariableText(PlayObject,QuestActionInfo.sParam1);//源文件
    sFileName:= GetLineVariableText(PlayObject,QuestActionInfo.sParam2);//目标文件
    if (sSourceName = '') or (sFileName = '') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_COPYFILETXT);
      Exit;
    end;
    if sSourceName <> '' then begin
      if sSourceName[1] = '\' then sSourceName := Copy(sSourceName, 2, Length(sSourceName) - 1);
      if sSourceName[2] = '\' then sSourceName := Copy(sSourceName, 3, Length(sSourceName) - 2);
      if sSourceName[3] = '\' then sSourceName := Copy(sSourceName, 4, Length(sSourceName) - 3);
    end;
    if sFileName <> '' then begin
      if sFileName[1] = '\' then sFileName := Copy(sFileName, 2, Length(sFileName) - 1);
      if sFileName[2] = '\' then sFileName := Copy(sFileName, 3, Length(sFileName) - 2);
      if sFileName[3] = '\' then sFileName := Copy(sFileName, 4, Length(sFileName) - 3);
    end;
    sSourceName:= g_Config.sEnvirDir + sSourceName;
    sFileName:= g_Config.sEnvirDir + sFileName;
    sLoadList := TStringList.Create;
    try
      if FileExists(sSourceName) then begin
        try
          sLoadList.LoadFromFile(sSourceName);
        except
          MainOutMessage('文件读取失败(CopyFileTxt) => ' + sSourceName);
        end;
        sLoadList.SaveToFile(sFileName);
      end;
    finally
      sLoadList.Free;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfCopyFileTxt',[g_sExceptionVer]));
  end;
end;
//功能:记路标石 20081019
//格式:TAGMAPINFO 记路(1-6)
procedure TNormNpc.ActionOfTAGMAPINFO(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nTpye, I:Byte;
  IniFile: TIniFile;//Ini文件
  sFileName: String;
begin
  try
    nTpye:= QuestActionInfo.nParam1;
    if (nTpye <= 0) or (nTpye > 6) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_TAGMAPINFO);
      Exit;
    end;
    PlayObject.m_TagMapInfos[nTpye].TagMapName:= PlayObject.m_sMapName;
    PlayObject.m_TagMapInfos[nTpye].TagX:= PlayObject.m_nCurrX;
    PlayObject.m_TagMapInfos[nTpye].TagY:= PlayObject.m_nCurrY;
    //保存到文件里
    sFileName :=  g_Config.sEnvirDir + 'UserData';
    if not DirectoryExists(sFileName) then CreateDir(sFileName); //目录不存在,则创建
    sFileName := sFileName+'\HumRecallPoint.txt';
    IniFile := TIniFile.Create(sFileName);
    Try
      for I:= 1 to 6 do begin
        IniFile.Writestring(PlayObject.m_sCharName,'记录'+inttostr(I),
                           PlayObject.m_TagMapInfos[I].TagMapName+','+
                           IntToStr(PlayObject.m_TagMapInfos[I].TagX)+','+
                           IntToStr(PlayObject.m_TagMapInfos[I].TagY));
      end;
    finally
      IniFile.Free;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfTAGMAPINFO',[g_sExceptionVer]));
  end;
end;

//功能:移动到记路标石记录的地图XY  20081019
//格式: TAGMAPMOVE 记路(1-6)
procedure TNormNpc.ActionOfTAGMAPMOVE(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nTpye:Byte;
  Envir: TEnvirnoment;
begin
try
  nTpye:= QuestActionInfo.nParam1;
  if (nTpye <= 0) or (nTpye > 6) then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_TAGMAPMOVE);
    Exit;
  end;

  if (PlayObject.m_TagMapInfos[nTpye].TagX <> 0) or (PlayObject.m_TagMapInfos[nTpye].TagY <> 0) then begin
    Envir := g_MapManager.FindMap(PlayObject.m_TagMapInfos[nTpye].TagMapName);
    if Envir <> nil then begin
      if Envir.CanWalk(PlayObject.m_TagMapInfos[nTpye].TagX, PlayObject.m_TagMapInfos[nTpye].TagY, True) then begin
        PlayObject.SpaceMove(PlayObject.m_TagMapInfos[nTpye].TagMapName, PlayObject.m_TagMapInfos[nTpye].TagX, PlayObject.m_TagMapInfos[nTpye].TagY, 0);
      end else begin
        PlayObject.SysMsg(Format(g_sGameCommandPositionMoveCanotMoveToMap1,
                         [PlayObject.m_TagMapInfos[nTpye].TagMapName, PlayObject.m_TagMapInfos[nTpye].TagX, PlayObject.m_TagMapInfos[nTpye].TagY]), c_Green, t_Hint);
      end;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfTAGMAPMOVE',[g_sExceptionVer]));
end;
end;
//功能：调整行会成员上限
//格式：CHANGEGUILDMEMBERCOUNT +\-\= 人数(65535)
procedure TNormNpc.ActionOfCHANGEGUILDMEMBERCOUNT(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nMemberCount: Integer;
  cMethod: Char;
begin
  try
    nMemberCount:=Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2),-1);
    if (nMemberCount < 0) or (nMemberCount > 65535) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEGUILDMEMBERCOUNT);
      Exit;
    end;
    cMethod := QuestActionInfo.sParam1[1];
    if PlayObject.m_MyGuild <> nil then begin
      case cMethod of
        '=': begin
            if nMemberCount >= 0 then begin
              TGUild(PlayObject.m_MyGuild).m_nGuildMemberCount := nMemberCount;
              TGUild(PlayObject.m_MyGuild).SaveGuildInfoFile;//保存行会文件
            end;
          end;
        '-': begin
            if TGUild(PlayObject.m_MyGuild).m_nGuildMemberCount > nMemberCount then begin
              Dec(TGUild(PlayObject.m_MyGuild).m_nGuildFountain, nMemberCount);
            end else begin
              TGUild(PlayObject.m_MyGuild).m_nGuildMemberCount := 0;
            end;
            TGUild(PlayObject.m_MyGuild).SaveGuildInfoFile;//保存行会文件
          end;
        '+': begin
            if TGUild(PlayObject.m_MyGuild).m_nGuildMemberCount + nMemberCount > High(Word) then begin
              TGUild(PlayObject.m_MyGuild).m_nGuildMemberCount:= High(Word);
            end else Inc(TGUild(PlayObject.m_MyGuild).m_nGuildMemberCount, nMemberCount);
            TGUild(PlayObject.m_MyGuild).SaveGuildInfoFile;//保存行会文件
          end;
      else begin
          ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEGUILDMEMBERCOUNT);
          Exit;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfCHANGEGUILDMEMBERCOUNT',[g_sExceptionVer]));
  end;
end;

//功能：行会酒泉数据的调整
//格式：CHANGEGUILDFOUNTAIN +\-\= 点数
procedure TNormNpc.ActionOfCHANGEGUILDFOUNTAIN(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nPoint: Integer;
  cMethod: Char;
begin
try
  nPoint:=Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2),-1);
  if (nPoint < 0) then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEGUILDFOUNTAIN);
    Exit;
  end;
  cMethod := QuestActionInfo.sParam1[1];
  if PlayObject.m_MyGuild <> nil then begin
    //if TGUild(PlayObject.m_MyGuild).boGuildFountainOpen then begin//行会泉水仓库开启
      case cMethod of
        '=': begin
            if nPoint >= 0 then begin
              TGUild(PlayObject.m_MyGuild).m_nGuildFountain := nPoint;
              TGUild(PlayObject.m_MyGuild).SaveGuildInfoFile;//保存行会文件 20090101
            end;
          end;
        '-': begin
            if TGUild(PlayObject.m_MyGuild).m_nGuildFountain > nPoint then begin
              Dec(TGUild(PlayObject.m_MyGuild).m_nGuildFountain, nPoint);
            end else begin
              TGUild(PlayObject.m_MyGuild).m_nGuildFountain := 0;
            end;
            TGUild(PlayObject.m_MyGuild).SaveGuildInfoFile;//保存行会文件 20090101
          end;
        '+': begin
            Inc(TGUild(PlayObject.m_MyGuild).m_nGuildFountain, nPoint);
            TGUild(PlayObject.m_MyGuild).SaveGuildInfoFile;//保存行会文件 20090101
          end;
      else begin
          ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEGUILDFOUNTAIN);
          Exit;
        end;
      end;

    //end else GotoLable(PlayObject, '@GIVEFOUNTAINColse', False);//行会酒泉关闭
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfCHANGEGUILDFOUNTAIN',[g_sExceptionVer]));
end;
end;

//调整声望 20080118
procedure TNormNpc.ActionOfChangeCreditPoint(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nCreditPoint: Integer;
  cMethod: Char;
begin
  try
    nCreditPoint:=Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2),-1);//20080430

    if (nCreditPoint < 0) and (not GetValValue(PlayObject, QuestActionInfo.sParam2, nCreditPoint)) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CREDITPOINT);
      Exit;
    end;

    cMethod := QuestActionInfo.sParam1[1];
    case cMethod of
      '=': begin
          if nCreditPoint >= 0 then begin
            PlayObject.m_btCreditPoint := nCreditPoint;
            PlayObject.GameGoldChanged();
          end;
        end;
      '-': begin
          if PlayObject.m_btCreditPoint > nCreditPoint then begin
            Dec(PlayObject.m_btCreditPoint, nCreditPoint);
          end else begin
            PlayObject.m_btCreditPoint := 0;
          end;
          PlayObject.GameGoldChanged();
        end;
      '+': begin
          Inc(PlayObject.m_btCreditPoint, nCreditPoint);
          PlayObject.GameGoldChanged();
        end;
    else begin
        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CREDITPOINT);
        Exit;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeCreditPoint',[g_sExceptionVer]));
  end;
end;

//调整荣誉值 20080511
procedure TNormNpc.ActionOfChangeCreditGlory(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nGameGlory: Integer;
  nOldGameGlory: Integer;
  cMethod: Char;
begin
  try
    nOldGameGlory := PlayObject.m_btGameGlory;
    nGameGlory:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2),-1);//20080430
    if (nGameGlory < 0) and (not GetValValue(PlayObject, QuestActionInfo.sParam2, nGameGlory)) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_GAMEGLORY);
      Exit;
    end;

    cMethod := QuestActionInfo.sParam1[1];
    case cMethod of
      '=': begin
          if (nGameGlory >= 0) then begin
            //nGameGlory := _MIN(High(PlayObject.m_btGameGlory), nGameGlory);//20080512 //20080809 修改
            PlayObject.m_btGameGlory := nGameGlory;
          end;
        end;
      '-': begin
          //nGameGlory := _MAX(0, PlayObject.m_btGameGlory - nGameGlory);
          //nGameGlory := _MIN(High(PlayObject.m_btGameGlory), nGameGlory);//20080512
          //PlayObject.m_btGameGlory := nGameGlory;
          PlayObject.m_btGameGlory := _MAX(0, PlayObject.m_btGameGlory - nGameGlory); //20080809 修改
        end;
      '+': begin
          //nGameGlory := _MAX(0, PlayObject.m_btGameGlory + nGameGlory);
          //nGameGlory := _MIN(High(PlayObject.m_btGameGlory), nGameGlory);//20080512
          //PlayObject.m_btGameGlory := nGameGlory;
          PlayObject.m_btGameGlory := _MIN(High(PlayObject.m_btGameGlory), PlayObject.m_btGameGlory + nGameGlory); //20080809 修改
        end;
    end;
    //'%d'#9'%s'#9'%d'#9'%d'#9'%s'#9'%s'#9'%d'#9'%s'#9'%s'
    if g_boGameLogGameGlory then begin
      AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GameGlory,
        PlayObject.m_sMapName,
          PlayObject.m_nCurrX,
          PlayObject.m_nCurrY,
          PlayObject.m_sCharName,
          g_Config.sGameGlory,
          PlayObject.m_btGameGlory,
          cMethod+'('+inttostr(nGameGlory)+')',
          m_sCharName]));
    end;
    if nOldGameGlory <> PlayObject.m_btGameGlory then PlayObject.GameGloryChanged;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeCreditGlory',[g_sExceptionVer]));
  end;
end;

//调整经验 英雄存在,则按比配分经验给英雄  20080320
//格式: ChangeExp 操作符(+/-/=) 经验点 类型(0/1/2/3/4) 限制英雄等级
//当操作符为+时,类型  0-主体经验保持不变,英雄分配一定经验
//                    1-英雄在线也不分配经验
//                    2-主体经验减比例分配给英雄
//                    3-按实际经验值分配(不考虑等级限制),英雄分配一定经验
//                    4-按实际经验值分配(不考虑等级限制),英雄在线也不分配经验
procedure TNormNpc.ActionOfChangeExp(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  cMethod: Char;
  dwInt, nMaxExp, nExp: Int64;
  nHeroLevel: Word;
  nCode, K, J:Byte;//20081109
begin
  nCode:= 0;
  Try
    if (PlayObject = nil) then Exit;//20081109
    nCode:= 1;
    nExp:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1); //20080430
    J:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam3),0);//是否分配经验给英雄 20101027
    nHeroLevel:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam4), 65535);
    if (nExp < 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEEXP);
      Exit;
    end;
    nCode:= 2;
    cMethod := QuestActionInfo.sParam1[1];
    case cMethod of
      '=': begin
          nCode:= 3;
          if nExp >= 0 then begin
            if PlayObject.m_Abil.Level < g_Config.nLimitExpLevel then begin//是否超过限制等级20080715
              nCode:= 4;
              PlayObject.m_Abil.nExp := nExp;
            end else begin
              nCode:= 5;
              PlayObject.m_Abil.nExp := g_Config.nLimitExpValue;
            end;
            if not PlayObject.m_boNotOnlineAddExp then
              PlayObject.SendMsg(PlayObject, RM_WINEXP, 0, 0, 1{0-提示 1-不提示}, 0, '');
          end;
        end;
      '-': begin
          nCode:= 6;
          if PlayObject.m_Abil.nExp > nExp then begin
            nCode:= 7;
            Dec(PlayObject.m_Abil.nExp, nExp);
          end else begin
            nCode:= 8;
            PlayObject.m_Abil.nExp := 0;
          end;
          if not PlayObject.m_boNotOnlineAddExp then
            PlayObject.SendMsg(PlayObject, RM_WINEXP, 0, 0, 1{0-提示 1-不提示}, 0, '');
        end;
      '+': begin
          nCode:= 9;
          if PlayObject.m_Abil.Level < g_Config.nLimitExpLevel then begin//是否超过限制等级
            nCode:= 10;
            if PlayObject.m_Abil.Level >= 1000 then begin//20090323 等级分配经验
              nExp:= Round(nExp * (g_Config.dwLevelToExpRate[1000] / 100));
              if nExp <= 0 then nExp:= 1;
            end else begin
              nExp:= Round(nExp * (g_Config.dwLevelToExpRate[PlayObject.m_Abil.Level] / 100));
              if nExp <= 0 then nExp:= 1;
            end;
          end else begin
            if (J <> 3) and (J <> 4) then nExp := g_Config.nLimitExpValue;
          end;
          nCode:= 11;
          PlayObject.GetExpToItem(nExp);
          {$IF HEROVERSION = 1}
          nCode:= 12;
          if (PlayObject.m_MyHero <> nil) and (J <> 1) and (J <> 4) and
            (PlayObject.m_MyHero.m_Abil.Level < nHeroLevel) then begin
            if (not PlayObject.m_MyHero.m_boGhost) and (PlayObject.m_MyHero.m_Abil.Level < g_Config.nLimitExpLevelHero) then begin//20090310 增加
              nCode:= 13;
              THeroObject(PlayObject.m_MyHero).GetExp(abs(Round((g_Config.nHeroNoKillMonExpRate / 100) * nExp)), 0);//20081018 修改
              if J = 2 then
                nExp:= abs(Round(((100 - g_Config.nHeroNoKillMonExpRate) / 100) * nExp));//20081018 修改
            end;
          end;
          {$IFEND}
          nCode:= 15;
          PlayObject.m_GetExp:= nExp;//人物取得的经验,$GetExp变量使用 20090102
          if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(PlayObject, '@GetExp', False, False);//取经验触发 20090102
          dwInt := nExp;
          PlayObject.SendMsg(PlayObject, RM_WINEXP, 0, 0, 0, 0, EncodeExp(PlayObject.m_Abil.nExp, dwInt));
          {$IF M2Version <> 2}
          PlayObject.GetExpToCrystal(dwInt, 0);//取经验到天地结晶中 20090202
          {$IFEND}
          nCode:= 18;
          try
          if PlayObject.m_Magic68Skill <> nil then begin//学过酒气护体 20080825
            if PlayObject.m_Magic68Skill.btLevel < 100 then Inc(PlayObject.m_Magic68Skill.nTranPoint, dwInt);
            nCode:= 19;
            nMaxExp:= PlayObject.GetSkill68Exp(PlayObject.m_Magic68Skill.btLevel);
            if PlayObject.m_Magic68Skill.nTranPoint >= nMaxExp then begin//超过升级经验,则升级技能
              Dec(PlayObject.m_Magic68Skill.nTranPoint, nMaxExp);
              nCode:= 20;
              if PlayObject.m_Magic68Skill.btLevel < 100 then Inc(PlayObject.m_Magic68Skill.btLevel);
            end;
            nCode:= 21;
            if PlayObject.m_Magic68Skill.btLevel < 101 then begin
              nMaxExp:= PlayObject.GetSkill68Exp(PlayObject.m_Magic68Skill.btLevel);
              PlayObject.SendMsg(PlayObject, RM_MAGIC_LVEXP, PlayObject.m_Magic68Skill.MagicInfo.wMagicId, nMaxExp, PlayObject.m_Magic68Skill.btLevel, PlayObject.m_Magic68Skill.nTranPoint, '');
            end;
          end;
          except//屏蔽酒气护体导致的错误By TasNat at: 2012-11-10 12:47:18

          end;
          nCode:= 22;
          if PlayObject.m_Abil.nExp >= nExp then begin
            if (High(Int64) - PlayObject.m_Abil.nExp) < nExp then begin
              dwInt := High(Int64) - PlayObject.m_Abil.nExp;
              nExp:= nExp - dwInt;
            end else nExp:= 0;
          end else begin
            if (High(Int64) - nExp) < PlayObject.m_Abil.nExp then begin
              dwInt := High(Int64) - nExp;
              nExp:= nExp - dwInt;
            end else nExp:= 0;
          end;
          Inc(PlayObject.m_Abil.nExp, dwInt);
          dwInt:=0;
          if PlayObject.m_Abil.nMaxExp > PlayObject.m_Abil.nExp then begin
            if nExp > 0 then begin
              dwInt:= (PlayObject.m_Abil.nMaxExp - PlayObject.m_Abil.nExp);
              if dwInt > 0 then begin
                if dwInt > nExp then begin
                  Inc(PlayObject.m_Abil.nExp, nExp);
                  nExp:= 0;
                end else begin
                  Inc(PlayObject.m_Abil.nExp, dwInt);
                  nExp:= nExp - dwInt;
                end;
              end;
            end;
          end;
          nCode:= 16;
          if (PlayObject.m_Abil.Level < MAXUPLEVEL) and
            (PlayObject.m_Abil.Level < g_Config.nLimitExpLevel) then begin//20110925 达到等级上限时不处理
            if g_Config.boContinuousUpLevel then begin
              K:= 0;
              while (PlayObject.m_Abil.nExp >= PlayObject.m_Abil.nMaxExp) do begin//20100408 循环处理升级
                if K >= 8 then Break;
                Inc(K);
                if PlayObject.m_Abil.nExp <= 0 then begin
                  PlayObject.m_Abil.nExp:= 0;
                  Break;
                end;
              //if PlayObject.m_Abil.Exp >= PlayObject.m_Abil.MaxExp then begin//20080825
                Dec(PlayObject.m_Abil.nExp, PlayObject.m_Abil.nMaxExp);
                if nExp > 0 then begin
                  Inc(PlayObject.m_Abil.nExp, nExp);
                  nExp:= 0;
                end;
                nCode:= 17;
                if (PlayObject.m_Abil.Level < MAXUPLEVEL) and (PlayObject.m_Abil.Level < g_Config.nLimitExpLevel) then begin
                  Inc(PlayObject.m_Abil.Level);//增加限制等级
                  if (PlayObject.m_sMasterName <> '') and not PlayObject.m_boMaster then begin//自动出师 20100408
                    if PlayObject.m_Abil.Level >= g_Config.nMasterOKLevel then PlayObject.CheckMaster(True);
                  end;
                end;
                if PlayObject.m_Abil.Level < g_Config.nLimitExpLevel then PlayObject.HasLevelUp(PlayObject.m_Abil.Level - 1);//增加限制等级
                if not PlayObject.m_boAI then begin
                  AddGameDataLog('12' + #9 + PlayObject.m_sMapName + #9 + IntToStr(PlayObject.m_nCurrX) + #9 +//人物升级记录日志
                    IntToStr(PlayObject.m_nCurrY) + #9 +
                    m_sCharName + #9 + IntToStr(PlayObject.m_Abil.nExp)+'/'+IntToStr(PlayObject.m_Abil.nMaxExp) + #9 + IntToStr(PlayObject.m_Abil.Level) + #9 + '1' + #9 + '(调整经验)');
                end;
              end;
            end else begin
              if PlayObject.m_Abil.nExp >= PlayObject.m_Abil.nMaxExp then begin
                Dec(PlayObject.m_Abil.nExp, PlayObject.m_Abil.nMaxExp);
                if nExp > 0 then begin
                  Inc(PlayObject.m_Abil.nExp, nExp);
                  nExp:= 0;
                end;
                nCode:= 17;
                if (PlayObject.m_Abil.Level < MAXUPLEVEL) and (PlayObject.m_Abil.Level < g_Config.nLimitExpLevel) then begin
                  Inc(PlayObject.m_Abil.Level);//增加限制等级
                  if (PlayObject.m_sMasterName <> '') and not PlayObject.m_boMaster then begin//自动出师 20100408
                    if PlayObject.m_Abil.Level >= g_Config.nMasterOKLevel then PlayObject.CheckMaster(True);
                  end;
                end;
                if PlayObject.m_Abil.Level < g_Config.nLimitExpLevel then PlayObject.HasLevelUp(PlayObject.m_Abil.Level - 1);//增加限制等级
                if not PlayObject.m_boAI then begin
                  AddGameDataLog('12' + #9 + PlayObject.m_sMapName + #9 + IntToStr(PlayObject.m_nCurrX) + #9 +//人物升级记录日志
                    IntToStr(PlayObject.m_nCurrY) + #9 +
                    m_sCharName + #9 + IntToStr(PlayObject.m_Abil.nExp)+'/'+IntToStr(PlayObject.m_Abil.nMaxExp) + #9 + IntToStr(PlayObject.m_Abil.Level) + #9 + '1' + #9 + '(调整经验)');
                end;
              end;
            end;
          end;
        end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeExp Code:%d',[g_sExceptionVer, nCode]));
  end;
end;

//功能:调整人物牛气值 20090519
//格式:CHANGECATTLEGASEXP 控制符(=,+,-) 牛气值点数
procedure TNormNpc.ActionOfChangeCattleGasExp(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nExp: LongWord;
  cMethod: Char;
  dwInt: LongWord;
begin
  try
    nExp:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);
    if (nExp < 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGECATTLEGASEXP);
      Exit;
    end;
    cMethod := QuestActionInfo.sParam1[1];
    if not PlayObject.m_boShowCattleGas then Exit;//地图没有显示牛气管则不进行操作
    case cMethod of
      '=': begin
          if nExp >= 0 then PlayObject.m_CattleGasExp := nExp;
        end;
      '-': begin
          if PlayObject.m_CattleGasExp > LongWord(nExp) then begin
            Dec(PlayObject.m_CattleGasExp, LongWord(nExp));
          end else begin
            PlayObject.m_CattleGasExp := 0;
          end;
        end;
      '+': begin
          dwInt := LongWord(nExp);
          PlayObject.GetCattleGasExp(dwInt);//取得牛气值
        end;
    end;//case
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeCattleGasExp',[g_sExceptionVer]));
  end;
end;

//功能:调整装备持久上限 20110219
//格式:CHANGEITEMDURA 位置(0-13) 控制符(=,+,-) 持久点数(0-65000)
procedure TNormNpc.ActionOfChangeItemDura(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nDura, nWhere: Word;
  cMethod: Char;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
  try
    nWhere := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam1),-1);
    nDura:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam3),-1);
    if (nDura < 0) or (nDura > 65000) or (nWhere < 0) or {$IF M2Version <> 2}(nWhere > High(THumanUseItems)){$ELSE}(nWhere > High(THumItems)){$IFEND} then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEITEMDURA);
      Exit;
    end;
    UserItem := @PlayObject.m_UseItems[nWhere];
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if (UserItem.wIndex <= 0) or (StdItem = nil) then Exit;
    cMethod := QuestActionInfo.sParam2[1];
    case cMethod of
      '=': begin
          if nDura >= 0 then UserItem.DuraMax := nDura;
          if UserItem.Dura > UserItem.DuraMax then UserItem.Dura := UserItem.DuraMax;
          PlayObject.SendMsg(PlayObject, RM_DURACHANGE, nWhere, UserItem.Dura, UserItem.DuraMax, 0, '');
        end;
      '-': begin
          if UserItem.DuraMax > nDura then begin
            Dec(UserItem.DuraMax, nDura);
            if UserItem.Dura > UserItem.DuraMax then UserItem.Dura := UserItem.DuraMax;
            PlayObject.SendMsg(PlayObject, RM_DURACHANGE, nWhere, UserItem.Dura, UserItem.DuraMax, 0, '');
          end else begin
            UserItem.DuraMax := 0;
            if UserItem.Dura > UserItem.DuraMax then UserItem.Dura := UserItem.DuraMax;
            if g_Config.boItmeAutoOver then begin//持久0物品消失
              PlayObject.SendDelItems(@PlayObject.m_UseItems[nWhere]);
              if StdItem.NeedIdentify = 1 then//
                AddGameDataLog('6' + #9 + PlayObject.m_sMapName + #9 +
                  IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                  PlayObject.m_sCharName + #9 + StdItem.Name + #9 +
                  IntToStr(PlayObject.m_UseItems[nWhere].MakeIndex) + #9 +
                  'NPC'+ #9 + 'ChangeItemDura');
              PlayObject.m_UseItems[nWhere].wIndex := 0;
              PlayObject.FeatureChanged();
            end else PlayObject.SendMsg(PlayObject, RM_DURACHANGE, nWhere, UserItem.Dura, UserItem.DuraMax, 0, '');
            PlayObject.RecalcAbilitys();
            PlayObject.CompareSuitItem(False);
          end;
        end;
      '+': begin
          Inc(UserItem.DuraMax, nDura);
          if UserItem.Dura > UserItem.DuraMax then UserItem.Dura := UserItem.DuraMax;
          PlayObject.SendMsg(PlayObject, RM_DURACHANGE, nWhere, UserItem.Dura, UserItem.DuraMax, 0, '');
        end;
    end;//case
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeItemDura',[g_sExceptionVer]));
  end;
end;
//按数字大小倒排序的函数
function DescCompareInt(List: TStringList; I1, I2: Integer): Integer;
begin
  I1 := StrToIntDef(List[I1], 0);
  I2 := StrToIntDef(List[I2], 0);
  if I1 > I2 then Result:=-1
  else if I1 < I2 then Result:=1
  else Result:=0;
end;
//升序
function DescCompareInt1(List: TStringList; I1, I2: Integer): Integer;
begin
  I1 := StrToIntDef(List[I1], 0);
  I2 := StrToIntDef(List[I2], 0);
  if I1 > I2 then Result:=1
  else if I1 < I2 then Result:=-1
  else Result:=0;
end;
//功能: 排序人物自定义变量
//格式: SortHumVarToFile 变量名 变量路径 排序模式(0,1) 保存路径
//说明: 排序模式 0=升序,1=降序
procedure TNormNpc.ActionOfSortHumVarToFile(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
  function Add_space(Str: string; Size: Integer): string;
  begin
    Result := Str;
    if Length(Str) >= Size then Exit;
    while Length(Result) < Size do Result := Result + ' ';
  end;
var
  I, nVar: Integer;
  sVarName, sFileName, sSaveName, sName, sAspace: string;
  IniFile: TIniFile;
  LoadList, LoadListA, SaveList: TStringList;
  boOrder: Boolean;
  CharName: pTCharName;
begin
  try
    sVarName := GetLineVariableText(PlayObject, QuestActionInfo.sParam1);
    sFileName := GetLineVariableText(PlayObject, QuestActionInfo.sParam2);//变量路径
    boOrder:= QuestActionInfo.sParam3 = '0';//排序模式 0=升序,1=降序
    sSaveName := GetLineVariableText(PlayObject, QuestActionInfo.sParam4);//保存路径
    if sFileName <> '' then begin
      if sFileName[1] = '\' then sFileName := Copy(sFileName, 2, Length(sFileName) - 1); //处理文件路径
      if sFileName[2] = '\' then sFileName := Copy(sFileName, 3, Length(sFileName) - 2);
      if sFileName[3] = '\' then sFileName := Copy(sFileName, 4, Length(sFileName) - 3);
    end;
    sFileName:= g_Config.sEnvirDir + sFileName;
    if sSaveName <> '' then begin
      if sSaveName[1] = '\' then sSaveName := Copy(sSaveName, 2, Length(sSaveName) - 1); //处理文件路径
      if sSaveName[2] = '\' then sSaveName := Copy(sSaveName, 3, Length(sSaveName) - 2);
      if sSaveName[3] = '\' then sSaveName := Copy(sSaveName, 4, Length(sSaveName) - 3);
    end;
    sSaveName:= g_Config.sEnvirDir + sSaveName;
    if (sVarName = '') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSORTHUMVARTOFILE);
      Exit;
    end;
    LoadListA:= TStringList.Create;
    try
      LoadList := TStringList.Create;
      IniFile := TIniFile.Create(sFileName);
      try
        IniFile.ReadSections(LoadList);
        if LoadList.Count > 0 then begin
          for I := 0 to LoadList.Count - 1 do begin
            sName:= LoadList.Strings[I];//角色名
            if sName <> '' then begin
              nVar:= IniFile.ReadInteger(sName, sVarName, -1);
              if (nVar > -1) then begin
                New(CharName);
                FillChar(CharName^, SizeOf(TCharName), 0);
                CharName^ := sName;
                LoadListA.AddObject(IntToStr(nVar), TObject(CharName));
              end;
            end;
          end;
        end;
      finally
        LoadList.Free;
        IniFile.free;
      end;
      if LoadListA.Count > 0 then begin
        if boOrder then LoadListA.CustomSort(DescCompareInt1)
        else LoadListA.CustomSort(DescCompareInt);
        SaveList:= TStringList.Create;
        try
          for I := 0 to LoadListA.Count - 1 do begin
            CharName := pTCharName(LoadListA.Objects[I]);
            sName := CharName^;
            sAspace := Add_space(sName, ACTORNAMELEN + 2);
            SaveList.Add(sAspace + LoadListA.Strings[I]);
            if CharName <> nil then Dispose(CharName);
          end;
          SaveList.SaveToFile(sSaveName);
        finally
          SaveList.Free;
        end;
      end;
    finally
      LoadListA.Free;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfSortHumVarToFile',[g_sExceptionVer]));
  end;
end;
{$IF M2Version <> 2}
//创建师门
function TNormNpc.ReQuestBuildDivision(PlayObject: TPlayObject; sDivisionName: string): Integer;
begin
  try
    Result := 0;
    sDivisionName := Trim(sDivisionName);
    if sDivisionName = '' then Result := -4;
    if PlayObject.m_MyDivision = nil then begin
      if PlayObject.m_Abil.Level < g_Config.nBuildDivisionLevel then Result := -2; //'等级不足'
    end else Result := -1; //'您已经加入其它师门。'
    if Length(sDivisionName) > 14 then Result := -3;//名字长度超过
    if PlayObject.m_MagicSkill_105 <> nil then begin//已有龙卫心法
      if Result = 0 then begin
        if g_DivisionManager.AddDivision(sDivisionName, PlayObject) then begin
          PlayObject.m_MyDivision := g_DivisionManager.MemberOfDivision(PlayObject.m_sCharName);
          if PlayObject.m_MyDivision <> nil then begin
            if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(PlayObject, '@CreateDivision', False, False);//创建师门触发
          end;
        end else Result := -6;
      end;
    end else Result := -5;
    if Result >= 0 then begin
      PlayObject.SendMsg(Self, RM_BUILDDIVISION_OK, 0, 0, 0, 0, '');
    end else begin
      PlayObject.SendMsg(Self, RM_BUILDDIVISION_FAIL, 0, Result, 0, 0, '');
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ReQuestBuildDivision',[g_sExceptionVer]));
  end;
end;

//功能：添加师门成员
//格式：ADDDIVISIONMEMBER 师门名称 人物名称
procedure TNormNpc.ActionOfADDDIVISIONMEMBER(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  sDivisionName,UserName:String;
  Division: TDivision;
  PlayHum: TPlayObject;
begin
  try
    sDivisionName:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1);
    UserName:= GetLineVariableText(PlayObject, QuestActionInfo.sParam2);
    if (sDivisionName = '') or (UserName = '') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_ADDDIVISIONMEMBER);
      Exit;
    end;
    Division:= g_DivisionManager.FindDivision(sDivisionName);
    if Division <> nil then begin
      PlayHum := UserEngine.GetPlayObjectEx1(UserName);
      if (PlayHum <> nil) and (not PlayHum.m_boNotOnlineAddExp) then begin //人物存在,不是离线挂机
        if not Division.IsMember(UserName) then begin //不是师门成员
          if (PlayHum.m_MyDivision = nil) then begin
            if not Division.IsFull then begin//师门没有行会,并且要加入的师门人员没有满
              if Division.AddMember(PlayHum, UserName) then begin
                if Division.DelApplyMember(PlayHum.m_sCharName) then//清除申请列表数据
                  g_DivisionManager.SaveUserApplyList(PlayHum.m_sCharName, '');//保存申请入门的名单
                PlayHum.m_MyDivision := Division;
                if Division.nDivisonType = 0 then
                  PlayHum.SysMsg(Format('%s同意了你的入派的请求',[Division.GetChiefName]), c_Green, t_Hint)
                else PlayHum.SysMsg(Format('%s同意了你的入派的请求',[Division.sDivisionName]), c_Green, t_Hint);
              end;
            end;
          end;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfADDDIVISIONMEMBER',[g_sExceptionVer]));
  end;
end;

//功能：删除师门成员（删除掌门无效）
//格式：DELDIVISIONMEMBER 师门名称 人物名称
procedure TNormNpc.ActionOfDELDIVISIONMEMBER(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  sDivisionName,UserName:String;
  Division: TDivision;
  PlayHum: TPlayObject;
begin
  try
    sDivisionName:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1);
    UserName:= GetLineVariableText(PlayObject, QuestActionInfo.sParam2);
    if (sDivisionName = '') or (UserName = '') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_DELDIVISIONMEMBER);
      Exit;
    end;
    Division:= g_DivisionManager.FindDivision(sDivisionName);
    if Division <> nil then begin
      PlayHum := UserEngine.GetPlayObjectEx1(UserName);
      if (PlayHum <> nil) and (not PlayHum.m_boNotOnlineAddExp) then begin //人物存在,不是离线挂机
        if Division.IsMember(UserName) and (PlayHum.m_sCharName <> Division.GetChiefName) then begin //是成员,且不是掌门
          if Division.DelMember(UserName) then begin
            PlayHum.m_MyDivision := nil;
            if (PlayHum.m_MagicSkill_105 = nil) then begin
              PlayHum.m_sHeartName:='';//心法名称
              PlayHum.RecalcAbilitys();
              PlayHum.CompareSuitItem(False);
              PlayHum.SendMsg(PlayHum, RM_ABILITY, 0, 0, 0, 0, '');
            end;

            if Division.nDivisonType = 0 then
              PlayHum.SysMsg(Format('您退出了门派%s',[Division.sDivisionName]), c_Green, t_Hint)
            else PlayHum.SysMsg('您退出了公共师门', c_Green, t_Hint);
          end;
        end;
      end;
    end else begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_DELDIVISIONMEMBER);
      Exit;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfDELDIVISIONMEMBER',[g_sExceptionVer]));
  end;
end;
//功能:打开领悟心法窗口(学习龙卫心法-999级)
//格式:OPENSAVVYHEART
procedure TNormNpc.ActionOfOpenSavvyHeart(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
begin
  try
    if (not PlayObject.m_boDeath) and (not PlayObject.m_boGhost) then begin
      if PlayObject.m_boTrainingNG then begin
        if (PlayObject.m_Abil.Level >= g_Config.nSavvyHeartNeedLevel) then begin
          if (PlayObject.IsTrainingSkill(SKILL_106)) then begin
            PlayObject.SysMsg('您已学有传承心法,不能进行龙卫心法领悟！', c_Green, t_Say);
            Exit;
          end;
          if (not PlayObject.IsTrainingSkill(SKILL_105)) then begin
            if (PlayObject.m_MyDivision <> nil) then begin
              PlayObject.SysMsg('您已加入门派,不能进行龙卫心法领悟！', c_Green, t_Say);
              Exit;
            end;
            PlayObject.SendMsg(Self, RM_OPENSAVVYHEART, 0, 0, g_Config.nSavvyHeartNeedLevel, 0, '');
          end else begin//更换心法
            PlayObject.SendMsg(Self, RM_OPENSAVVYHEART, 1{更换心法}, PlayObject.m_nHeartType{当前心法类型}, g_Config.nSavvyHeartNeedLevel, 0, '');
          end;
        end else PlayObject.SysMsg(Format('您的等级不足%d,不能进行龙卫心法领悟！',[g_Config.nSavvyHeartNeedLevel]), c_Green, t_Say);
      end else PlayObject.SysMsg('您没学过内功心法,不能进行龙卫心法领悟！', c_Green, t_Say);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfOpenSavvyHeart',[g_sExceptionVer]));
  end;
end;
//功能:打开申请加入门派窗口
//格式:OPENAPPLYDIVISION
procedure TNormNpc.ActionOfOpenApplyDivision(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I:Integer;
  sDivisionName, sSendText: string;
  Division: TDivision;
  ClientDivisionInfo: TClientDivisionInfo;
  nType: Byte;//0-全显示"申请加入" 1-根据结构字段显示"取消申请" 2-不显示"申请加入","取消申请"
begin
  try
    PlayObject.m_nApplyDivisionPage:= 0;//申请入门派当前页数
    sDivisionName:= g_DivisionManager.LoadUserApplyInfo(PlayObject.m_sCharName);//查询是否正在进行申请
    if sDivisionName <> '' then nType:= 1;
    if PlayObject.m_MyDivision <> nil then nType:= 2;//已加入过门派
    sSendText:= '';
    for I := 0 to g_DivisionManager.DivisionList.Count - 1 do begin
      if (I > 4) then Break;
      Division := TDivision(g_DivisionManager.DivisionList.Items[I]);
      if Division <> nil then begin
        ClientDivisionInfo.sDivisionName:= Division.sDivisionName;
        ClientDivisionInfo.sChrName:= Division.GetChiefName();
        ClientDivisionInfo.nPopularity:= Division.nPopularity;
        case nType of
          0, 2: ClientDivisionInfo.nStatus:= nType;
          1: begin
            if CompareText(ClientDivisionInfo.sDivisionName, sDivisionName)= 0 then
              ClientDivisionInfo.nStatus:= 1
            else ClientDivisionInfo.nStatus:= 2;
          end;
        end;
        if Division.nDivisonType = 1 then ClientDivisionInfo.sChrName:='';//公共门派无师父名
        sSendText := sSendText + EncodeBuffer(@ClientDivisionInfo, SizeOf(TClientDivisionInfo)) + '/';
      end;
    end;//for
    PlayObject.SendMsg(PlayObject, RM_QUERYDIVISIONLIST, 0, 0, 0, 0, sSendText);
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfOpenApplyDivision',[g_sExceptionVer]));
  end;
end;
//功能:弟子领悟师门心法
//格式:SAVVYHEART
procedure TNormNpc.ActionOfSavvyHeart(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  Magic: pTMagic;
  UserMagic: pTUserMagic;
begin
  try
    if (PlayObject.m_MyDivision <> nil) and (PlayObject.m_boTrainingNG) then begin
      if (PlayObject.m_Abil.Level >= g_Config.nUpHeartNeedLevel[0]) then begin
        if (not PlayObject.IsTrainingSkill(SKILL_105)) and (not PlayObject.IsTrainingSkill(SKILL_106)) then begin
          Magic := UserEngine.FindMagic(SKILL_106);
          if Magic <> nil then begin
            New(UserMagic);
            UserMagic.MagicInfo := Magic;
            UserMagic.wMagIdx := Magic.wMagicId;
            UserMagic.btKey := 0;
            UserMagic.btLevel := 1;
            UserMagic.nTranPoint := 0;
            UserMagic.btLevelEx:= 0;
            PlayObject.m_MagicList.Add(UserMagic);
            PlayObject.m_sHeartName:= '传承'+TDivision(PlayObject.m_MyDivision).sHeartName;//心法名称
            PlayObject.m_nHeartType:= TDivision(PlayObject.m_MyDivision).nHeartTpye;//心法类型
            PlayObject.m_Contribution:= 0;//贡献值
            PlayObject.SendAddMagic(UserMagic);
            PlayObject.RecalcAbilitys();
            PlayObject.CompareSuitItem(False);
            PlayObject.SendMsg(PlayObject, RM_ABILITY, 0, 0, 0, 0, '');
            PlayObject.AddSkillFunc(Magic.wMagicId);//人物学技能触发
            PlayObject.SysMsg(sSavvyHeartOK, c_Blue, t_Say);
            PlayObject.SendRefMsg(RM_10205, 36, 0{X}, 0{Y}, 0, '');//显示特殊效果(龙升天效果)
            PlayObject.DoSendHeartInfo();//发送心法相关数据
          end;
        end;
      end else PlayObject.SysMsg(Format('您的等级不足%d,不能进行领悟传承心法！',[g_Config.nUpHeartNeedLevel[0]]), c_Green, t_Say);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfSavvyHeart',[g_sExceptionVer]));
  end;
end;
//功能:调整门派人气值
//格式:CHANGEDIVISIONPOINT 操作符(+,-,=) 点数
procedure TNormNpc.ActionOfChangeDivisionPoint(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  nPoint, nInt: Integer;
  cMethod: Char;
begin
  try
    nPoint:=Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2),-1);
    if (nPoint < 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEDIVISIONPOINT);
      Exit;
    end;
    cMethod := QuestActionInfo.sParam1[1];
    if PlayObject.m_MyDivision <> nil then begin
      case cMethod of
        '=': begin
            if nPoint >= 0 then begin
              TDivision(PlayObject.m_MyDivision).nPopularity := nPoint;
              TDivision(PlayObject.m_MyDivision).SaveDivisionInfoFile;
            end;
          end;
        '-': begin
            nInt:= TDivision(PlayObject.m_MyDivision).nPopularity;
            if nInt > nPoint then begin
              Dec(nInt, nPoint);
              TDivision(PlayObject.m_MyDivision).nPopularity:= nInt;
            end else begin
              TDivision(PlayObject.m_MyDivision).nPopularity := 0;
            end;
            TDivision(PlayObject.m_MyDivision).SaveDivisionInfoFile;
          end;
        '+': begin
            nInt:= TDivision(PlayObject.m_MyDivision).nPopularity;
            Inc(nInt, nPoint);
            TDivision(PlayObject.m_MyDivision).nPopularity:= nInt;
            TDivision(PlayObject.m_MyDivision).SaveDivisionInfoFile;
          end;
      else begin
        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEDIVISIONPOINT);
        Exit;
        end;
      end;
      PlayObject.SendDefMessage(SM_UPDIVISIONPONT, TDivision(PlayObject.m_MyDivision).nPopularity, 0, 0, 0, '');
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeDivisionPoint',[g_sExceptionVer]));
  end;
end;

//功能:调整心法经验,'+'时同时累积门派人气值
//格式:CHANGEHEARTPOINT 操作符(+,-,=) 点数
procedure TNormNpc.ActionOfChangeHeartPoint(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  nMaxExp: LongWord;
  nPoint, nInt: Integer;
  cMethod: Char;
begin
  try
    nPoint:=Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2),-1);
    if (nPoint < 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEHEARTPOINT);
      Exit;
    end;
    cMethod := QuestActionInfo.sParam1[1];
    case cMethod of
      '=': begin
          if PlayObject.m_MagicSkill_106 <> nil then begin
            if PlayObject.m_MyDivision <> nil then begin
              if (nPoint >= 0) then PlayObject.m_MagicSkill_106.nTranPoint := nPoint;
            end;
          end else
          if PlayObject.m_MagicSkill_105 <> nil then begin
            if (nPoint >= 0) then PlayObject.m_MagicSkill_105.nTranPoint := nPoint;
          end;
        end;
      '-': begin
          if PlayObject.m_MagicSkill_106 <> nil then begin
            if PlayObject.m_MyDivision <> nil then begin
              nPoint := _MAX(0, PlayObject.m_MagicSkill_106.nTranPoint - nPoint);
              if nPoint < 0 then nPoint := 0;
              PlayObject.m_MagicSkill_106.nTranPoint := nPoint;
            end;
          end else
          if PlayObject.m_MagicSkill_105 <> nil then begin
            nPoint := _MAX(0, PlayObject.m_MagicSkill_105.nTranPoint - nPoint);
            if nPoint < 0 then nPoint := 0;
            PlayObject.m_MagicSkill_105.nTranPoint := nPoint;
          end;
        end;
      '+': begin
          if PlayObject.m_MagicSkill_106 <> nil then begin
            if PlayObject.m_MyDivision <> nil then begin
              if (High(LongWord) - PlayObject.m_Contribution) < nPoint then begin//人气贡献值
                PlayObject.m_Contribution := High(LongWord);
              end else Inc(PlayObject.m_Contribution, nPoint);
              TDivision(PlayObject.m_MyDivision).RefMemberName(PlayObject.m_sCharName);

              nInt:= TDivision(PlayObject.m_MyDivision).nHeartLevel;
              if PlayObject.m_MagicSkill_106.btLevel < 9 then begin
                if (PlayObject.m_MagicSkill_106.btLevel < nInt) and
                  (PlayObject.m_Abil.Level >= g_Config.nUpHeartNeedLevel[PlayObject.m_MagicSkill_106.btLevel]) then begin
                  PlayObject.SendDelayMsg(PlayObject, RM_WINCATTLEGASEXP, 0, nPoint, 1{0-牛气值 1-心法经验}, 0, '',1000);//左下角显示心法经验获得
                  nPoint := _MAX(0, PlayObject.m_MagicSkill_106.nTranPoint + nPoint);
                  PlayObject.m_MagicSkill_106.nTranPoint := nPoint;
                  if PlayObject.m_MagicSkill_106.btLevel > 0 then
                    nMaxExp:= PlayObject.m_MagicSkill_106.MagicInfo.MaxTrain[0] +
                             PlayObject.m_MagicSkill_106.btLevel * ( PlayObject.m_MagicSkill_106.MagicInfo.MaxTrain[2]-  PlayObject.m_MagicSkill_106.MagicInfo.MaxTrain[1])
                  else nMaxExp:= PlayObject.m_MagicSkill_106.MagicInfo.MaxTrain[0];

                  if PlayObject.m_MagicSkill_106.nTranPoint >= nMaxExp then begin//超过升级经验,则升级技能
                    Dec(PlayObject.m_MagicSkill_106.nTranPoint, nMaxExp);
                    Inc(PlayObject.m_MagicSkill_106.btLevel);
                    PlayObject.HeartLevelUpFunc;//增加心法升级触发 By TasNat at: 2012-10-17 10:45:43
                    PlayObject.RecalcAbilitys();
                    PlayObject.CompareSuitItem(False);
                    PlayObject.SendMsg(PlayObject, RM_ABILITY, 0, 0, 0, 0, '');
                    PlayObject.DoSendHeartInfo();//发送心法相关数据
                  end;
                  nInt:= TDivision(PlayObject.m_MyDivision).nPopularity;
                  Inc(nInt, nPoint);
                  TDivision(PlayObject.m_MyDivision).nPopularity:= nInt;
                  TDivision(PlayObject.m_MyDivision).SaveDivisionInfoFile;
                end;
              end;
            end;
          end else begin
            if PlayObject.m_MagicSkill_105 <> nil then begin
              PlayObject.SendDelayMsg(PlayObject, RM_WINCATTLEGASEXP, 0, nPoint, 1{0-牛气值 1-心法经验}, 0, '',1000);//左下角显示心法经验获得
              if PlayObject.m_MyDivision <> nil then begin
                if (High(LongWord) - PlayObject.m_Contribution) < nPoint then begin//人气贡献值
                  PlayObject.m_Contribution := High(LongWord);
                end else Inc(PlayObject.m_Contribution, nPoint);
                TDivision(PlayObject.m_MyDivision).RefMemberName(PlayObject.m_sCharName);

                nInt:= TDivision(PlayObject.m_MyDivision).nPopularity;
                Inc(nInt, nPoint);
                TDivision(PlayObject.m_MyDivision).nPopularity:= nInt;
                TDivision(PlayObject.m_MyDivision).SaveDivisionInfoFile;
              end;

              if (PlayObject.m_MagicSkill_105.btLevel < 100) then begin
                nPoint := _MAX(0, PlayObject.m_MagicSkill_105.nTranPoint + nPoint);
                PlayObject.m_MagicSkill_105.nTranPoint := nPoint;
                if not PlayObject.CheckMagicLevelup(PlayObject.m_MagicSkill_105) then begin
                  nMaxExp := PlayObject.m_MagicSkill_105.MagicInfo.MaxTrain[0] + PlayObject.m_MagicSkill_105.btLevel * (PlayObject.m_MagicSkill_105.MagicInfo.MaxTrain[2]-PlayObject.m_MagicSkill_105.MagicInfo.MaxTrain[1]);
                  PlayObject.SendDelayMsg(PlayObject, RM_MAGIC_LVEXP, PlayObject.m_MagicSkill_105.MagicInfo.wMagicId, nMaxExp, PlayObject.m_MagicSkill_105.btLevel, PlayObject.m_MagicSkill_105.nTranPoint, '', 500);
                end else PlayObject.HeartLevelUpFunc;//增加心法升级触发 By TasNat at: 2012-10-17 10:45:43
              end;
            end;
          end;
        end;
    else begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEHEARTPOINT);
      Exit;
      end;
    end;
    if PlayObject.m_MagicSkill_106 <> nil then begin
      if PlayObject.m_MyDivision <> nil then begin
        nInt:= TDivision(PlayObject.m_MyDivision).nHeartLevel;
        if (PlayObject.m_MagicSkill_106.btLevel < nInt) then begin
          if PlayObject.m_MagicSkill_106.btLevel > 0 then
            nMaxExp:= PlayObject.m_MagicSkill_106.MagicInfo.MaxTrain[0] +
               PlayObject.m_MagicSkill_106.btLevel * ( PlayObject.m_MagicSkill_106.MagicInfo.MaxTrain[3]-  PlayObject.m_MagicSkill_106.MagicInfo.MaxTrain[2])
          else nMaxExp:= PlayObject.m_MagicSkill_106.MagicInfo.MaxTrain[0];
          PlayObject.SendDelayMsg(PlayObject, RM_MAGIC_LVEXP, PlayObject.m_MagicSkill_106.MagicInfo.wMagicId, nMaxExp, PlayObject.m_MagicSkill_106.btLevel, PlayObject.m_MagicSkill_106.nTranPoint, '', 500);
        end else begin
          nMaxExp:= PlayObject.m_MagicSkill_106.MagicInfo.MaxTrain[0] +
              nInt * ( PlayObject.m_MagicSkill_106.MagicInfo.MaxTrain[3]-  PlayObject.m_MagicSkill_106.MagicInfo.MaxTrain[2]);
          PlayObject.SendDelayMsg(PlayObject, RM_MAGIC_LVEXP, PlayObject.m_MagicSkill_106.MagicInfo.wMagicId, nMaxExp, PlayObject.m_MagicSkill_106.btLevel, PlayObject.m_MagicSkill_106.nTranPoint, '', 500);
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeHeartPoint',[g_sExceptionVer]));
  end;
end;

//功能:龙卫心法吸收心法经验，并减少累积经验(传承心法无效)
//格式:INCHEARTPOINT
procedure TNormNpc.ActionOfIncHeartPoint(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  nExp : Int64;
begin
  if (PlayObject.m_Abil.nExp >= g_Config.nIncHeartPointNeedExp * 10000) and
    (PlayObject.m_MagicSkill_105 <> nil) and (PlayObject.m_boTrainingNG) then begin
    nExp := g_Config.nIncHeartPointNeedExp * 10000;
    PlayObject.IncHeartPoint(nExp);
  end;
end;
//-----------------------------------------------------------------------------
//功能：给予玩家称号
//格式：GIVEFENGHAO 角色名 称号名 设置角色名
procedure TNormNpc.ActionOfGiveFengHao(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  I: Integer;
  HumTitleDB, HumTitleDB1: pTHumTitleDB;
  THumTitle1: THumTitleDB;
  sFengHaoName, s20, sName, sSetName, sFileName: string;
  boHaveFengHao: Boolean;
  nTpye, nCode: Byte;
  PoseHuman, PoseHuman1: TPlayObject;
  HumTitle: THumTitle;
begin
  nCode:= 0;
  Try
    sFengHaoName := GetLineVariableText(PlayObject, QuestActionInfo.sParam2);//称号名
    sSetName:= GetLineVariableText(PlayObject,QuestActionInfo.sParam3);
    sName:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1);
    if (sName = '') or (sFengHaoName = '') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sGIVEFENGHAO);
      Exit;
    end;
    nCode:= 1;
    PoseHuman := UserEngine.GetPlayObject(sName);//检查是否在线
    if PoseHuman = nil then Exit;
    boHaveFengHao:= False;
    nCode:= 2;
    HumTitleDB:= UserEngine.GetHumTitle(sFengHaoName);
    if HumTitleDB <> nil then begin
      THumTitle1:= HumTitleDB^;
      if not PoseHuman.CheckFengHaoNeed(THumTitle1) then Exit; //检查是否可以得到称号 20110313
      nCode:= 3;
      for I := Low(THumTitles) to High(THumTitles) do begin//判断人物是否有同样的称号
        nCode:= 4;
        if (PoseHuman.m_wHumTitles[I].wIndex > 0) and (PoseHuman.m_wHumTitles[I].MakeIndex > 0) then begin
          nCode:= 5;
          HumTitleDB1:= UserEngine.GetHumTitle(PoseHuman.m_wHumTitles[I].wIndex);
          if HumTitleDB1 <> nil then begin
            nCode:= 6;
            if (HumTitleDB1.sTitleName = sFengHaoName) and
               (HumTitleDB1.StdMode = HumTitleDB.StdMode) then begin
              boHaveFengHao:= True;
              Break;
            end;
          end;
        end;
      end;
      if not boHaveFengHao then begin
        nCode:= 7;
        if sSetName <> '' then begin//检查设置人是否在线
          PoseHuman1 := UserEngine.GetPlayObject(sSetName);//检查是否在线
          nCode:= 8;
          if PoseHuman1 = nil then Exit;
        end;
        nCode:= 9;
        for I := Low(THumTitles) to High(THumTitles) do begin
          nCode:= 10;
          if (PoseHuman.m_wHumTitles[I].wIndex > 0) and (PoseHuman.m_wHumTitles[I].MakeIndex > 0) then Continue;//继续
          nCode:= 11;             
          if UserEngine.CopyToFengHaoFromName(sFengHaoName, @HumTitle) then begin
            nCode:= 12;
            case HumTitleDB.AniCount of
              2: begin//主宰龙卫
                nCode:= 13;
                if (PoseHuman1 <> nil) and (PoseHuman <> nil) then begin
                  nCode:= 26;
                  if (PoseHuman.m_sCharName <> PoseHuman1.m_sCharName) and
                    (PoseHuman1.m_ComradeList.Count < 10) and PoseHuman1.m_boFengHaoDominate then begin
                    nCode:= 14;
                    HumTitle.sChrName:= PoseHuman1.m_sCharName;
                    if PoseHuman1.m_ComradeList.IndexOf(PoseHuman.m_sCharName) = -1 then begin//20110406 增加
                      PoseHuman1.m_ComradeList.Add(PoseHuman.m_sCharName);
                      nCode:= 15;
                      PoseHuman1.SaveFengHaoList(g_Config.sEnvirDir + 'UserData\FengHao\Comrade', PoseHuman1.m_ComradeList);
                    end;
                  end else Exit;
                end else Exit;
              end;
              3: begin//护花使者
                nCode:= 16;
                if (PoseHuman1 <> nil) and (PoseHuman <> nil) then begin
                  nCode:= 27;
                  if (PoseHuman.m_sCharName <> PoseHuman1.m_sCharName) and
                    (PoseHuman1.m_HuhuaList.Count < 10) and PoseHuman1.m_boFengHaoMagicEffect then begin
                    nCode:= 17;
                    HumTitle.sChrName:= PoseHuman1.m_sCharName;
                    if PoseHuman1.m_HuhuaList.IndexOf(PoseHuman.m_sCharName) = -1 then begin//20110406 增加
                      PoseHuman1.m_HuhuaList.Add(PoseHuman.m_sCharName);
                      nCode:= 18;
                      PoseHuman1.SaveFengHaoList(g_Config.sEnvirDir + 'UserData\FengHao\HuHua', PoseHuman1.m_HuhuaList);
                    end;
                  end else Exit;
                end else Exit;
              end;
              5: PoseHuman.m_nDieCount:= 0;//巅峰勇士类
              7: begin//传奇之星，清空列表
                nCode:= 19;
                PoseHuman.m_HuhuaList.Clear;
                sFileName :=  g_Config.sEnvirDir + 'UserData\FengHao\HuHua';
                if not DirectoryExists(sFileName) then ForceDirectories(sFileName); //目录不存在,则创建
                nCode:= 20;
                sFileName := sFileName+'\'+PoseHuman.m_sCharName+'.txt';
                if FileExists(sFileName) then DeleteFile(sFileName);
              end;
              8: begin//行会之星
                if PoseHuman.m_MyGuild <> nil then begin
                  TGUild(PoseHuman.m_MyGuild).m_GuildStarDate := Now();
                  TGUild(PoseHuman.m_MyGuild).SaveGuildInfoFile;//保存行会文件
                end else Exit;
              end;
              9: begin//玛法主宰者
                nCode:= 21;
                PoseHuman.m_ComradeList.Clear;
                sFileName :=  g_Config.sEnvirDir + 'UserData\FengHao\Comrade';
                if not DirectoryExists(sFileName) then ForceDirectories(sFileName); //目录不存在,则创建
                nCode:= 22;
                sFileName := sFileName+'\'+PoseHuman.m_sCharName+'.txt';
                if FileExists(sFileName) then DeleteFile(sFileName);
              end;
            end;
            nCode:= 23;
            PoseHuman.m_boFengHaoAgree:= False;
            PoseHuman.m_nFenghaotype:= 0;
            PoseHuman.m_sFenghaoName:= '';
            PoseHuman.m_wHumTitles[I]:= HumTitle;
            PoseHuman.m_boCanTitle:= True;
            PoseHuman.m_dwUseTitleTick := GetTickCount();
            PoseHuman.RecalcAbilitys();
            PoseHuman.CompareSuitItem(False);
            PoseHuman.SendMsg(PoseHuman, RM_ABILITY, 0, 0, 0, 0, '');
            PoseHuman.SendMsg(PoseHuman, RM_SENDHUMTITLES, 0, 0, 0, 0, '');//发送称号数据
            nCode:= 24;
            PoseHuman.RefShowName();
            s20 := Format('恭喜：%s 获得了称号：%s！', [PoseHuman.m_sCharName, sFengHaoName]);
            nCode:= 25;
            UserEngine.SendBroadCastMsgExt(s20, t_System);
          end;
          Break;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfGiveFengHao Code:%d',[g_sExceptionVer, nCode]));
  end;
end;

//功能：回收玩家称号
//格式：RECYCFENGHAO 角色名 称号名
procedure TNormNpc.ActionOfRecycFengHao(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  I, nIdx: Integer;
  HumTitleDB, HumTitleDB1: pTHumTitleDB;
  sFengHaoName, sName, sFileName: string;
  PoseHuman, PoseHuman1: TPlayObject;
  LoadList: TStringList;
begin
  try
    sFengHaoName := GetLineVariableText(PlayObject, QuestActionInfo.sParam2);//称号名
    sName:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1);
    if (sName = '') or (sFengHaoName = '') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sRECYCFENGHAO);
      Exit;
    end;
    PoseHuman := UserEngine.GetPlayObject(sName);//检查是否在线
    if PoseHuman = nil then Exit;
    HumTitleDB:= UserEngine.GetHumTitle(sFengHaoName);
    if HumTitleDB <> nil then begin
      for I := Low(THumTitles) to High(THumTitles) do begin//判断人物是否有同样的称号
        if (PoseHuman.m_wHumTitles[I].wIndex > 0) and (PoseHuman.m_wHumTitles[I].MakeIndex > 0) then begin
          HumTitleDB1:= UserEngine.GetHumTitle(PoseHuman.m_wHumTitles[I].wIndex);
          if HumTitleDB1 <> nil then begin
            if (HumTitleDB1.sTitleName = sFengHaoName) and
               (HumTitleDB1.StdMode = HumTitleDB.StdMode) then begin
              if PoseHuman.m_wHumTitles[I].boUseTitle then begin
                PoseHuman.m_boUseIitleIdx:= 0;
                PoseHuman.m_sUseIitleName:= '';
              end;
              PoseHuman.m_wHumTitles[I].MakeIndex:= 0;
              PoseHuman.m_wHumTitles[I].wIndex:= 0;
              PoseHuman.m_wHumTitles[I].boUseTitle:= False;
              PoseHuman.m_wHumTitles[I].wDura:= 0;
              PoseHuman.m_wHumTitles[I].wMaxDura:= 0;
              case HumTitleDB.AniCount of
                2: begin//主宰龙卫
                  if PoseHuman.m_wHumTitles[I].sChrName <> '' then begin
                    PoseHuman1 := UserEngine.GetPlayObject(PoseHuman.m_wHumTitles[I].sChrName);//检查是否在线
                    if PoseHuman1 <> nil then begin
                      nIdx:= PoseHuman1.m_ComradeList.IndexOf(PoseHuman.m_sCharName);
                      if nIdx > -1 then begin
                        PoseHuman1.m_ComradeList.Delete(nIdx);
                        PoseHuman1.SaveFengHaoList(g_Config.sEnvirDir + 'UserData\FengHao\Comrade', PoseHuman1.m_ComradeList);
                      end;
                    end else begin
                      sFileName := g_Config.sEnvirDir + 'UserData\FengHao\Comrade\'+PoseHuman.m_wHumTitles[I].sChrName+'.txt';
                      if FileExists(sFileName) then begin
                        try
                          LoadList:= TStringList.Create;
                          LoadList.LoadFromFile(sFileName);
                          nIdx:= LoadList.IndexOf(PoseHuman.m_sCharName);
                          if nIdx > -1 then begin
                            LoadList.Delete(nIdx);
                            LoadList.SaveToFile(sFileName);
                          end;
                        finally
                          LoadList.Free;
                        end;
                      end;
                    end;
                  end;
                end;
                3: begin//护花使者
                  if PoseHuman.m_wHumTitles[I].sChrName <> '' then begin
                    PoseHuman1 := UserEngine.GetPlayObject(PoseHuman.m_wHumTitles[I].sChrName);//检查是否在线
                    if PoseHuman1 <> nil then begin
                      nIdx:= PoseHuman1.m_HuhuaList.IndexOf(PoseHuman.m_sCharName);
                      if nIdx > -1 then begin
                        PoseHuman1.m_HuhuaList.Delete(nIdx);
                        PoseHuman1.SaveFengHaoList(g_Config.sEnvirDir + 'UserData\FengHao\HuHua', PoseHuman1.m_HuhuaList);
                      end;
                    end else begin
                      sFileName := g_Config.sEnvirDir + 'UserData\FengHao\HuHua\'+PoseHuman.m_wHumTitles[I].sChrName+'.txt';
                      if FileExists(sFileName) then begin
                        try
                          LoadList:= TStringList.Create;
                          LoadList.LoadFromFile(sFileName);
                          nIdx:= LoadList.IndexOf(PoseHuman.m_sCharName);
                          if nIdx > -1 then begin
                            LoadList.Delete(nIdx);
                            LoadList.SaveToFile(sFileName);
                          end;
                        finally
                          LoadList.Free;
                        end;
                      end;
                    end;
                  end;
                end;
                7: begin//传奇之星，清空列表
                  PoseHuman.m_HuhuaList.Clear;
                  sFileName :=  g_Config.sEnvirDir + 'UserData\FengHao\HuHua';
                  if not DirectoryExists(sFileName) then ForceDirectories(sFileName); //目录不存在,则创建
                  sFileName := sFileName+'\'+PoseHuman.m_sCharName+'.txt';
                  if FileExists(sFileName) then DeleteFile(sFileName);
                end;
                9: begin//玛法主宰者
                  PoseHuman.m_ComradeList.Clear;
                  sFileName :=  g_Config.sEnvirDir + 'UserData\FengHao\Comrade';
                  if not DirectoryExists(sFileName) then ForceDirectories(sFileName); //目录不存在,则创建
                  sFileName := sFileName+'\'+PoseHuman.m_sCharName+'.txt';
                  if FileExists(sFileName) then DeleteFile(sFileName);
                end;
              end;
              PoseHuman.m_wHumTitles[I].sChrName:='';//需处理认命类称号
              PoseHuman.SysMsg(Format('您失去了称号：%s',[HumTitleDB.sTitleName]), c_Green, t_Hint);
              PoseHuman.SendMsg(PoseHuman, RM_SENDHUMTITLES, 0, 0, 0, 0, '');
              PoseHuman.RecalcAbilitys();
              PoseHuman.CompareSuitItem(False);//套装
              PoseHuman.SendMsg(PoseHuman, RM_ABILITY, 0, 0, 0, 0, '');
              PoseHuman.RefShowName();
              if g_FunctionNPC <> nil then begin
                g_FunctionNPC.GotoLable(PoseHuman, '@FengHaoFunc' + IntToStr(HumTitleDB.idx), False, False);
              end;
              Break;
            end;
          end;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfRecycFengHao',[g_sExceptionVer]));
  end;
end;
//功能:调整称号的使用时长
//格式:CHANGEFENGHAOTIME 称号名 操作符(+,-,=) 小时(1-65535)
procedure TNormNpc.ActionOfChangeFengHaoTime(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  I, nTime: Integer;
  HumTitleDB: pTHumTitleDB;
  sFengHaoName: string;
  cMethod: Char;
begin
  try
    sFengHaoName := GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//称号名
    nTime:=Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3),-1);
    if (nTime < 0) or (nTime > 65535) or (sFengHaoName = '') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sCHANGEFENGHAOTIME);
      Exit;
    end;
    cMethod := QuestActionInfo.sParam2[1];
    for I := Low(THumTitles) to High(THumTitles) do begin//判断人物是指定的称号
      if (PlayObject.m_wHumTitles[I].wIndex > 0) and (PlayObject.m_wHumTitles[I].MakeIndex > 0) then begin
        HumTitleDB:= UserEngine.GetHumTitle(PlayObject.m_wHumTitles[I].wIndex);
        if HumTitleDB <> nil then begin
          if (HumTitleDB.sTitleName = sFengHaoName) then begin
            if HumTitleDB.StdMode = 0 then begin//限时称号
              case cMethod of
                '=': begin
                    PlayObject.m_wHumTitles[I].ApplyDate:= IncDayHour(Now(), nTime);//到期时间
                  end;
                '-': begin
                    PlayObject.m_wHumTitles[I].ApplyDate:= DecDayHour(PlayObject.m_wHumTitles[I].ApplyDate, nTime);//到期时间
                  end;
                '+': begin
                    PlayObject.m_wHumTitles[I].ApplyDate:= IncDayHour(PlayObject.m_wHumTitles[I].ApplyDate, nTime);//到期时间
                  end;
              else begin
                  ScriptActionError(PlayObject, '', QuestActionInfo, sCHANGEFENGHAOTIME);
                  Exit;
                end;
              end;//case
            end;
            PlayObject.SendMsg(PlayObject, RM_SENDHUMTITLES, 0, 0, 0, 0, '');
            Break;
          end;
        end;
      end;
    end;//For
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeFengHaoTime',[g_sExceptionVer]));
  end;
end;
//功能：设置称号发送确认信息(即设置主宰龙卫或护花使者时，让对方是否同意)
//格式: GIVEFENGHAOAGREE 角色名 类型(1-255)
//说明：执行命令时，会设置对方的变量<$SETFENGHAOHUM>--即设置人变量
//      类型用于触发脚本段标识,即称号的idx字段,确认后执行,QF段 @FENGHAOAGREE+类型
procedure TNormNpc.ActionOfGiveFengHaoAgree(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  nType: Byte;
  sName, sFengHaoName: string;
  PoseHuman: TPlayObject;
  HumTitleDB: pTHumTitleDB;
begin
  try
    sName:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//角色名
    nType:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),0);//类型
    if (sName = '') or (nType > 255) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sGIVEFENGHAOAGREE);
      Exit;
    end;
    PoseHuman := UserEngine.GetPlayObject(sName);//检查是否在线
    if PoseHuman = nil then Exit;
    if not PoseHuman.m_boFengHaoAgree then begin
      HumTitleDB:= UserEngine.GetHumTitle((nType + 1));
      if HumTitleDB <> nil then begin
        PoseHuman.m_boFengHaoAgree:= True;
        PoseHuman.m_nFenghaotype:= nType;
        PoseHuman.m_sFenghaoName:= PlayObject.m_sCharName;
        sFengHaoName:= HumTitleDB.sTitleName;
        PoseHuman.SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(PlayObject), 9, 0, Format('%s正在对您进行任命%s称号，你是否同意？',[PlayObject.m_sCharName, sFengHaoName]));
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfGiveFengHaoAgree',[g_sExceptionVer]));
  end;
end;
//功能:NPC学习内功 20081002
//格式:READSKILLNG Hero
procedure TNormNpc.ActionOfREADSKILLNG(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var nLevel:Byte;
begin
  try
    if CompareText(QuestActionInfo.sParam1, 'HERO') = 0 then begin//英雄学习
      {$IF HEROVERSION = 1}
      if (PlayObject.m_MyHero <> nil) and (PlayObject.m_boTrainingNG) then begin//主号学过,英雄才能学习
        if not THeroObject(PlayObject.m_MyHero).m_boTrainingNG then begin//没学过内功
          THeroObject(PlayObject.m_MyHero).m_boTrainingNG:= True;
          THeroObject(PlayObject.m_MyHero).m_NGLevel := 1;
          THeroObject(PlayObject.m_MyHero).m_ExpSkill69 := 0;//内功当前经验 20081204
          THeroObject(PlayObject.m_MyHero).SendNGData;//发送内功数据 20081005
          PlayObject.m_MyHero.SendRefMsg(RM_MYSHOW, ET_OBJECTLEVELUP,0, 0, 0, ''); //人物升级动画  20081221
          GotoLable(PlayObject, '@ReadNGHeroOK', False, False);
        end else GotoLable(PlayObject, '@ReadNGHeroFail', False, False);
      end else GotoLable(PlayObject, '@ReadNGHeroFail', False, False);
      {$IFEND}
    end else begin
      if not PlayObject.m_boTrainingNG then begin//没学过内功
        PlayObject.m_boTrainingNG:= True;
        PlayObject.m_NGLevel := 1;
        PlayObject.m_ExpSkill69 := 0;//内功当前经验 20081204
        PlayObject.SendNGData;//发送内功数据 20081005
        PlayObject.SendRefMsg(RM_MYSHOW, ET_OBJECTLEVELUP,0, 0, 0, ''); //人物升级动画  20081221
        GotoLable(PlayObject, '@ReadNGOK', False, False);
{$IF M2Version = 1}
        //发送第一个穴位打通所需的等级 20090719
        nLevel:= g_Config.dwPulsePointNGLevel[PlayObject.m_wHumanPulseArr[0].nPulsePoint];
        PlayObject.SendMsg(PlayObject, RM_SENDUSERPULSESHINY, 0, 1, nLevel, 0, '');
{$IFEND}
      end else GotoLable(PlayObject, '@ReadNGFail', False, False);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfREADSKILLNG',[g_sExceptionVer]));
  end;
end;

//功能：清除人物的所有内功技能  20090428
//格式：CLEARNGSKILL  (加参数HERO,即是删除英雄内功技能,空则是人物内功技能)
procedure TNormNpc.ActionOfClearNGSkill(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I: Integer;
  UserMagic: pTUserMagic;
begin
  try
    if CompareText(QuestActionInfo.sParam1, 'HERO') = 0 then begin
      {$IF HEROVERSION = 1}
      if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then begin
        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CLEARNGSKILL);
        Exit;
      end;
      if PlayObject.m_MyHero <> nil then begin
        if THeroObject(PlayObject.m_MyHero).m_boTrainingNG then begin
          THeroObject(PlayObject.m_MyHero).m_boTrainingNG:= False;
          THeroObject(PlayObject.m_MyHero).m_NGLevel:= 0;
          THeroObject(PlayObject.m_MyHero).m_ExpSkill69:= 0;//内功心法当前经验
          THeroObject(PlayObject.m_MyHero).m_MaxExpSkill69:= 0;//内功心法升级经验
          THeroObject(PlayObject.m_MyHero).m_Skill69NH:= 0;//当前内力值
          THeroObject(PlayObject.m_MyHero).m_Skill69MaxNH:= 0;//最大内力值
          for I := PlayObject.m_MyHero.m_MagicList.Count - 1 downto 0 do begin
            if PlayObject.m_MyHero.m_MagicList.Count <= 0 then Break;
            UserMagic := PlayObject.m_MyHero.m_MagicList.Items[I];
            if UserMagic <> nil then begin
              if (UserMagic.MagicInfo.sDescr = '内功')then begin
                PlayObject.m_MyHero.m_MagicList.Delete(I);
                THeroObject(PlayObject.m_MyHero).SendDelMagic(UserMagic);
                //PlayObject.m_MyHero.m_MagicOfDelList.Add(UserMagic);
                //防止释放内存后的非法访问 By TasNat at: 2012-03-11 11:36:00
                Dispose(UserMagic);
              end;
            end;
          end;
          THeroObject(PlayObject.m_MyHero).RecalcAbilitys();//20081213 修改
          PlayObject.m_MyHero.CompareSuitItem(False);//200080729 套装
        end;
      end;
      {$IFEND}
    end else begin
      if PlayObject.m_boTrainingNG then begin
        PlayObject.m_boTrainingNG:= False;
        PlayObject.m_NGLevel:= 0;
        PlayObject.m_ExpSkill69:= 0;//内功心法当前经验
        PlayObject.m_MaxExpSkill69:= 0;//内功心法升级经验
        PlayObject.m_Skill69NH:= 0;//当前内力值
        PlayObject.m_Skill69MaxNH:= 0;//最大内力值
        for I := PlayObject.m_MagicList.Count - 1 downto 0 do begin
          if PlayObject.m_MagicList.Count <= 0 then Break;//20080917
          UserMagic := PlayObject.m_MagicList.Items[I];
          if UserMagic <> nil then begin
            if (UserMagic.MagicInfo.sDescr = '内功')then begin
              PlayObject.SendDelMagic(UserMagic);
              //PlayObject.m_MagicOfDelList.Add(UserMagic);
              //防止释放内存后的非法访问 By TasNat at: 2012-03-11 11:36:00
              Dispose(UserMagic);
              PlayObject.m_MagicList.Delete(I);
            end;
          end;
        end;
        PlayObject.RecalcAbilitys();
        PlayObject.CompareSuitItem(False);//200080729 套装
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfClearNGSkill',[g_sExceptionVer]));
  end;
end;

//功能:调整内功经验 20081002
//格式:CHANGENGEXP 控制符(=,+,-) 经验点数 Hero
procedure TNormNpc.ActionOfChangeNGExp(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nExp, dwInt: LongWord;
  cMethod: Char;
  nTempExp: integer;
  nCode: Byte;
begin
  try
    nCode:= 0;
    nExp:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),0);
    if (nExp <= 0) then begin//20110722 修改
      if (not GetValValue(PlayObject, QuestActionInfo.sParam2, nTempExp)) then begin
        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_ChangeNGExp);
        Exit;
      end;
      nExp:= nTempExp;
      if (nExp < 0) then begin
        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_ChangeNGExp);
        Exit;
      end;
    end;
    nCode:= 1;
    cMethod := QuestActionInfo.sParam1[1];
    if CompareText(QuestActionInfo.sParam3, 'HERO') = 0 then begin
      {$IF HEROVERSION = 1}
      nCode:= 2;
      if PlayObject.m_MyHero <> nil then begin
        nCode:= 3;
        if (not PlayObject.m_MyHero.m_boDeath) and (not PlayObject.m_MyHero.m_boGhost) then begin//20110722 增加
          nCode:= 4;
          if not THeroObject(PlayObject.m_MyHero).m_boTrainingNG then Exit;
          case cMethod of
            '=': begin
                nCode:= 5;
                if nExp >= 0 then THeroObject(PlayObject.m_MyHero).m_ExpSkill69 := nExp;
                THeroObject(PlayObject.m_MyHero).SendNGData;//发送内功数据 20081204
              end;
            '-': begin
                nCode:= 6;
                if THeroObject(PlayObject.m_MyHero).m_ExpSkill69 > LongWord(nExp) then begin
                  Dec(THeroObject(PlayObject.m_MyHero).m_ExpSkill69, LongWord(nExp));
                end else begin
                  THeroObject(PlayObject.m_MyHero).m_ExpSkill69 := 0;
                end;
                THeroObject(PlayObject.m_MyHero).SendNGData;//发送内功数据 20081204
              end;
            '+': begin
                nCode:= 7;
                dwInt := LongWord(nExp);
                THeroObject(PlayObject.m_MyHero).GetNGExp(dwInt, 1);
              end;
          end;//case
        end;
      end;
      {$IFEND}
    end else begin
      nCode:= 8;
      if not PlayObject.m_boTrainingNG then Exit;
      case cMethod of
        '=': begin
            nCode:= 9;
            if nExp >= 0 then PlayObject.m_ExpSkill69 := nExp;
            PlayObject.SendNGData;//发送内功数据 20081204
          end;
        '-': begin
            nCode:= 10;
            if PlayObject.m_ExpSkill69 > LongWord(nExp) then begin
              Dec(PlayObject.m_ExpSkill69, LongWord(nExp));
            end else begin
              PlayObject.m_ExpSkill69 := 0;
            end;
            PlayObject.SendNGData;//发送内功数据 20081204
          end;
        '+': begin
            nCode:= 11;
            dwInt := LongWord(nExp);
            PlayObject.GetNGExp(dwInt,1);
          end;
      end;//case
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeNGExp Code:%d',[g_sExceptionVer, nCode]));
  end;
end;

//功能:调整人物内力等级 20081004
//格式:CHANGENGLEVEL 控制符(=,+,-) 等级数(1-255) Hero
procedure TNormNpc.ActionOfCHANGENGLEVEL(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nLv, nLEVEL: Word;
  boChgOK: Boolean;
  cMethod: Char;
begin
try
  boChgOK := False;
  nLEVEL:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);
  if (nLEVEL < 0) or (nLEVEL > g_Config.nLimitExpNGLevel) then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGENGLEVEL);
    Exit;
  end;
  cMethod := QuestActionInfo.sParam1[1];
  if CompareText(QuestActionInfo.sParam3, 'HERO') = 0 then begin
    {$IF HEROVERSION = 1}
    if PlayObject.m_MyHero <> nil then begin
      if not THeroObject(PlayObject.m_MyHero).m_boTrainingNG then Exit;
      case cMethod of
        '=': begin
            if (nLevel > 0) and (nLevel <= g_Config.nLimitExpNGLevel) then begin
              THeroObject(PlayObject.m_MyHero).m_NGLevel := nLEVEL;
              boChgOK := True;
            end;
          end;
        '-': begin
            nLv := _MAX(0, THeroObject(PlayObject.m_MyHero).m_NGLevel - nLevel);
            THeroObject(PlayObject.m_MyHero).m_NGLevel := nLv;
            boChgOK := True;
          end;
        '+': begin
            nLv := _MIN(g_Config.nLimitExpNGLevel, THeroObject(PlayObject.m_MyHero).m_NGLevel + nLevel);
            THeroObject(PlayObject.m_MyHero).m_NGLevel := nLv;
            boChgOK := True;
          end;
      end;//case
      if boChgOK then begin
        THeroObject(PlayObject.m_MyHero).SendNGData;//发送内功数据 20081005
        THeroObject(PlayObject.m_MyHero).SendRefMsg(RM_MYSHOW, ET_OBJECTLEVELUP,0, 0, 0, ''); //人物升级动画  20090719
        AddGameDataLog('17' + #9 + PlayObject.m_MyHero.m_sMapName + #9 + //等级调整记录日志
          IntToStr(PlayObject.m_MyHero.m_nCurrX) + #9 +
          IntToStr(PlayObject.m_MyHero.m_nCurrY)+ #9 +
          PlayObject.m_MyHero.m_sCharName + #9 +
          IntToStr(THeroObject(PlayObject.m_MyHero).m_NGLevel) + #9 +
          '英雄内功' + #9 +
          cMethod+'('+IntToStr(nLevel)+')' + #9 +
          m_sCharName);
      end;
    end;
    {$IFEND}
  end else begin
    if not PlayObject.m_boTrainingNG then Exit;
    case cMethod of
      '=': begin
          if (nLevel > 0) and (nLevel <= g_Config.nLimitExpNGLevel) then begin
            PlayObject.m_NGLevel := nLEVEL;
            boChgOK := True;
          end;
        end;
      '-': begin
          nLv := _MAX(0, PlayObject.m_NGLevel - nLevel);
          PlayObject.m_NGLevel := nLv;
          boChgOK := True;
        end;
      '+': begin
          nLv := _MIN(g_Config.nLimitExpNGLevel, PlayObject.m_NGLevel + nLevel);
          PlayObject.m_NGLevel := nLv;
          boChgOK := True;
        end;
    end;//case
    if boChgOK then begin
      PlayObject.SendNGData;//发送内功数据 20081005
      PlayObject.SendRefMsg(RM_MYSHOW, ET_OBJECTLEVELUP,0, 0, 0, ''); //人物升级动画 20090719
      AddGameDataLog('17' + #9 + PlayObject.m_sMapName + #9 + //等级调整记录日志
        IntToStr(PlayObject.m_nCurrX) + #9 +
        IntToStr(PlayObject.m_nCurrY)+ #9 +
        PlayObject.m_sCharName + #9 +
        IntToStr(PlayObject.m_NGLevel) + #9 +
        '内功' + #9 +
        cMethod+'('+IntToStr(nLevel)+')' + #9 +
        m_sCharName);
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfCHANGENGLEVEL',[g_sExceptionVer]));
end;
end;
//-----------------------------------------------------------------------------
//功能:检查角色内功等级
//格式:CHECKNGLEVEL 操作符(<,>,=) 等级数 Hero
function TNormNpc.ConditionOfCHECKNGLEVEL(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nLevel: Word;
  cMethod: Char;
begin
  try
    Result := False;
    nLEVEL:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),0);
    if (nLEVEL <= 0) or (nLEVEL > g_Config.nLimitExpNGLevel) then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sCHECKNGLEVEL);
      Exit;
    end;
    cMethod := QuestConditionInfo.sParam1[1];
    if CompareText(QuestConditionInfo.sParam3, 'HERO') = 0 then begin
      {$IF HEROVERSION = 1}
      if PlayObject.m_MyHero <> nil then begin
        if THeroObject(PlayObject.m_MyHero).m_boTrainingNG then begin
          case cMethod of
            '=': if THeroObject(PlayObject.m_MyHero).m_NGLevel = nLevel then Result := True;
            '>': if THeroObject(PlayObject.m_MyHero).m_NGLevel > nLevel then Result := True;
            '<': if THeroObject(PlayObject.m_MyHero).m_NGLevel < nLevel then Result := True;
          else if THeroObject(PlayObject.m_MyHero).m_NGLevel >= nLevel then Result := True;
          end;
        end;
      end;
      {$IFEND}
    end else begin
      if PlayObject.m_boTrainingNG then begin
        case cMethod of
          '=': if PlayObject.m_NGLevel = nLevel then Result := True;
          '>': if PlayObject.m_NGLevel > nLevel then Result := True;
          '<': if PlayObject.m_NGLevel < nLevel then Result := True;
        else if PlayObject.m_NGLevel >= nLevel then Result := True;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKNGLEVEL',[g_sExceptionVer]));
  end;
end;
//功能:检查角色是否学过内功 20081002
//格式:CHANGREADNG Hero
function TNormNpc.ConditionOfCHANGREADNG(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
try
  Result := False;
  if CompareText(QuestConditionInfo.sParam1, 'HERO') = 0 then begin
    {$IF HEROVERSION = 1}
    if PlayObject.m_MyHero <> nil then begin
      if THeroObject(PlayObject.m_MyHero).m_boTrainingNG then Result := True;
    end;
    {$IFEND}
  end else begin
    if PlayObject.m_boTrainingNG then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHANGREADNG',[g_sExceptionVer]));
end;
end;

//功能：客户端显示天地结晶图标
//格式：OPENEXPCRYSTAL 是否清空变量
procedure TNormNpc.ActionOfOPENEXPCRYSTAL(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
begin
  try
    PlayObject.m_boShowExpCrystal:= True;//是否显示天地结晶图标 20090131
    if QuestActionInfo.sParam1 = '' then begin
      with PlayObject do begin
        m_CrystalLevel:= 1;//天地结晶等级 20090131
        m_CrystalExp:= 0;//天地结晶当前经验 20090131
        m_CrystalMaxExp:= 0;//天地结晶升级经验 20090131
        m_CrystalNGExp:= 0;//天地结晶当前内功经验 20090131
        m_CrystalNGMaxExp:= 0;//天地结晶内功升级经验 20090131
        m_boGetExpCrystalExp := False;//是否可以提取经验 20090201
        m_nGetCrystalExp:= 0;//可提取天地结晶经验 20090201
        m_nGetCrystalNGExp:= 0;//天可提取地结晶内功经验 20090201
      end;
      //发消息显示天地结晶图标
      PlayObject.SendMsg(PlayObject, RM_OPENEXPCRYSTAL, 0, 2, 0, 0, '');
    end else begin
      //发消息显示天地结晶图标
      PlayObject.SendMsg(PlayObject, RM_OPENEXPCRYSTAL, 0, 2, 1, 0, '');
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfOPENEXPCRYSTAL',[g_sExceptionVer]));
  end;
end;

//功能：客户端关闭天地结晶图标
//格式：CLOSEEXPCRYSTAL
procedure TNormNpc.ActionOfCLOSEEXPCRYSTAL(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
begin
  try
    if PlayObject.m_boShowExpCrystal then begin
      PlayObject.m_boShowExpCrystal:= False;//是否显示天地结晶图标 20090131
      PlayObject.m_CrystalLevel:= 1;//天地结晶等级 20090131
      PlayObject.m_CrystalExp:= 0;//天地结晶当前经验 20090131
      PlayObject.m_CrystalMaxExp:= 0;//天地结晶升级经验 20090131
      PlayObject.m_CrystalNGExp:= 0;//天地结晶当前内功经验 20090131
      PlayObject.m_CrystalNGMaxExp:= 0;//天地结晶内功升级经验 20090131
      PlayObject.m_boGetExpCrystalExp := False;//是否可以提取经验 20090201
      PlayObject.m_nGetCrystalExp:= 0;//可提取天地结晶经验 20090201
      PlayObject.m_nGetCrystalNGExp:= 0;//天可提取地结晶内功经验 20090201
      //发消息关闭天地结晶图标
      PlayObject.SendMsg(PlayObject, RM_OPENEXPCRYSTAL, 0, 1, 0, 0, '');
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfCLOSEEXPCRYSTAL',[g_sExceptionVer]));
  end;
end;
//功能：取提天地结晶中的经验(只提取可提取的经验)
//格式：GETEXPTOCRYSTAL
procedure TNormNpc.ActionOfGETEXPTOCRYSTAL(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
begin
  try
    PlayObject.ClientGetExpTCrystal;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfGETEXPTOCRYSTAL',[g_sExceptionVer]));
  end;
end;

//-----------------------------------------------------------------------------
//功能：打开淬炼功能窗口
//格式:QUERYREFINEITEM
procedure TNormNpc.ActionOfQUERYREFINEITEM(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
begin
try
  if (not PlayObject.m_boDeath) and (not PlayObject.m_boGhost) then begin
    PlayObject.SendMsg(Self, RM_QUERYREFINEITEM, 0, 0, 0, 0, '');
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfQUERYREFINEITEM',[g_sExceptionVer]));
end;
end;
{$IFEND}

// 还没有明白这个为什么发消息 By TasNat at: 2012-05-23 16:04:16   
procedure TNormNpc.ActionOfOpenRefineArmyDrum(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
begin
  try
    if (not PlayObject.m_boDeath) and (not PlayObject.m_boGhost) then
      PlayObject.SendMsg(Self, RM_OpenRefineArmyDrum, 0, 0, 0, 0, QuestActionInfo.sParam1);
  except
    MainOutMessage(Format('{%s} ActionOfOpenRefineArmyDrum',[g_sExceptionVer]));
  end;
end;

{$IF M2Version = 1}
//功能：打开炼气功能窗口
//格式: OPENLIANQI 类型(0-普通练气 1-强化练气)
procedure TNormNpc.ActionOfOPENLIANQI(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  nType: Byte;
begin
  nType := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam1), 0);
  try
    if (not PlayObject.m_boDeath) and (not PlayObject.m_boGhost) then begin
      case nType of
        0: PlayObject.SendMsg(Self, RM_OPENLIANQI, 0, 0, PlayObject.m_JingYuanValue, g_Config.nJingYuanValue, '');//普通练气
        1: PlayObject.SendMsg(Self, RM_OPENLIANQI, 1, g_Config.nLianqiGameGird{强化所需灵符}, PlayObject.m_JingYuanValue{当前精元值}, g_Config.nJingYuanValue{精元值上限}, '');//强化练气
      end;
      PlayObject.m_boLianQiConditions:= False;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfOPENLIANQI',[g_sExceptionVer]));
  end;
end;
//功能：调整人物精元值
//格式：CHANGEJINGYUAN 操作符(+/-/=) 点数
procedure TNormNpc.ActionOfCHANGEJINGYUAN(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  nValue, nCount: Word;
  cMethod: Char;
  boSend: Boolean;
begin
  nCount:= 0;
  try
    nValue := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2), -1);
    if (nValue < 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sCHANGEJINGYUAN);
      Exit;
    end;
    cMethod := QuestActionInfo.sParam1[1];
    case cMethod of
      '=': begin
        if nValue >= 0 then begin
          PlayObject.m_JingYuanValue:= _MIN(g_Config.nJingYuanValue, nValue);
          boSend:= True;
        end;
      end;
      '-': begin
        if PlayObject.m_JingYuanValue > nValue then begin
          Dec(PlayObject.m_JingYuanValue, nValue);
          boSend:= True;
        end else begin
          PlayObject.m_JingYuanValue := 0;
          boSend:= True;
        end;
      end;
      '+': begin
        if g_Config.nJingYuanValue >= PlayObject.m_JingYuanValue + nValue then nCount:= nValue;
        PlayObject.m_JingYuanValue :=_MIN(g_Config.nJingYuanValue, PlayObject.m_JingYuanValue + nValue);
        boSend:= True;
      end;
    end;
    if boSend then PlayObject.SendMsg(PlayObject, RM_SENDJINGYUANVALUE, 0, nCount, 0, 0, '');//更新人物精元值
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionCHANGEJINGYUAN',[g_sExceptionVer]));
  end;
end;
//功能：开启第四个连击技能 20100720
//格式：OPEN4BATTERSKILL hero
procedure TNormNpc.ActionOfOpen4BatterSkill(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
begin
  if CompareText(QuestActionInfo.sParam1, 'HERO') = 0 then begin//英雄
    {$IF HEROVERSION = 1}
    if PlayObject.m_MyHero <> nil then begin
      if THeroObject(PlayObject.m_MyHero).m_boTrainingNG and THeroObject(PlayObject.m_MyHero).m_boTrainBatterSkill then begin//学过内功以及学有连击技能
        THeroObject(PlayObject.m_MyHero).m_boUser4BatterSkill:= True;//开启第四格连击
        PlayObject.SendMsg(PlayObject.m_MyHero, RM_OPEN4BATTERSKILL, 0, 1, 0, 0, '');
      end;
    end;
    {$IFEND}
  end else begin
    if PlayObject.m_boTrainingNG and PlayObject.m_boTrainBatterSkill then begin//学过内功以及学有连击技能
      PlayObject.m_boUser4BatterSkill:= True;//开启第四格连击
      PlayObject.SendMsg(PlayObject, RM_OPEN4BATTERSKILL, 0, 0, 0, 0, '');
    end;
  end;
end;

//功能：开通英雄经脉
//格式：OPENHEROPULS
procedure TNormNpc.ActionOfOpenHeroPuls(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  nLevel:Byte;
begin
  {$IF HEROVERSION = 1}
  if PlayObject.m_MyHero <> nil then begin
    if THeroObject(PlayObject.m_MyHero).m_boTrainingNG then begin//学过内功
      THeroObject(PlayObject.m_MyHero).m_boOpenHumanPulseArr:= True;
      //发送第一个穴位打通所需的等级
      nLevel:= g_Config.dwPulsePointNGLevel[THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[0].nPulsePoint];
      PlayObject.SendMsg(PlayObject, RM_SENDUSERPULSESHINY, 1, 1, nLevel, 0,'');//20091102 修改
    end;
  end;
  {$IFEND}
end;
//功能：打通指定脉穴 20090623
//格式: OPENPULSE 经络(0..4) 穴位(1..5) hero
procedure TNormNpc.ActionOfOpenPulse(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  nPulse, nPoint: Byte;
begin
  try
    nPulse := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam1), -1);//经络
    nPoint := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2), -1);//穴位
    if (nPulse < 0) or (nPulse > 4) or (nPoint <= 0) or (nPoint > 5)  then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_OPENPULSE);
      Exit;
    end;
    
    if CompareText(QuestActionInfo.sParam3, 'HERO') = 0 then begin//英雄
      {$IF HEROVERSION = 1}
      if (PlayObject.m_MyHero <> nil) then begin
        if THeroObject(PlayObject.m_MyHero).m_boTrainingNG and THeroObject(PlayObject.m_MyHero).m_boOpenHumanPulseArr and (nPoint < 6) then begin//学过内功
          case nPulse of
            0..3: begin
              if not THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].boOpenPulse then begin//经络未打通
                THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].nPulsePoint:= nPoint;
                if nPoint >= 5 then begin
                  THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].boOpenPulse:= True;
                  case nPulse of
                    0: THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].dwUpPulseLevelExp:= g_Config.dwExpHeroPulsNeedExps0[0];
                    1: THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].dwUpPulseLevelExp:= g_Config.dwExpHeroPulsNeedExps1[0];
                    2: THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].dwUpPulseLevelExp:= g_Config.dwExpHeroPulsNeedExps2[0];
                    3: THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].dwUpPulseLevelExp:= g_Config.dwExpHeroPulsNeedExps3[0];
                  end;
                  PlayObject.m_MyHero.SendRefMsg(RM_10205, 16, 0{X}, 0{Y}, 0, '');//打通经络自身动画
                end else PlayObject.m_MyHero.SendRefMsg(RM_10205, 13, 0{X}, 0{Y}, 0, '');//打通穴位自身动画
                THeroObject(PlayObject.m_MyHero).SendUpdataPulseArr(nPulse);//发送更新脉穴数据
                THeroObject(PlayObject.m_MyHero).SendUserPulsePulsePoint(nPulse, True);//发送脉穴对应穴位发亮以及所需的内功等级
              end;
            end;
            4: begin//奇经
              with THeroObject(PlayObject.m_MyHero) do begin
                m_wHumanPulseArr[nPulse].nPulsePoint:= nPoint;
                SendRefMsg(RM_10205, 23, 0{X}, 0{Y}, 0, '');//打通穴位自身动画
                SendUpdataPulseArr(nPulse);//发送更新脉穴数据
              end;
            end;
          end;
        end;
      end;
      {$IFEND}
    end else begin
      if PlayObject.m_boTrainingNG and (nPoint < 6) then begin//学过内功
        case nPulse of
          0..3: begin
            if not PlayObject.m_wHumanPulseArr[nPulse].boOpenPulse then begin//经络未打通
              PlayObject.m_wHumanPulseArr[nPulse].nPulsePoint:= nPoint;
              if nPoint >= 5 then begin
                PlayObject.m_wHumanPulseArr[nPulse].boOpenPulse:= True;
                PlayObject.SendRefMsg(RM_10205, 16, 0{X}, 0{Y}, 0, '');//打通经络自身动画 20090702
              end else PlayObject.SendRefMsg(RM_10205, 13, 0{X}, 0{Y}, 0, '');//打通穴位自身动画 20090628
              PlayObject.SendUpdataPulseArr(nPulse);//发送更新脉穴数据
              PlayObject.SendUserPulsePulsePoint(nPulse, True);//发送脉穴对应穴位发亮以及所需的内功等级 20090624
            end;
          end;
          4: begin//奇经
            PlayObject.m_wHumanPulseArr[nPulse].nPulsePoint:= nPoint;
            PlayObject.SendRefMsg(RM_10205, 23, 0{X}, 0{Y}, 0, '');//打通穴位自身动画
            PlayObject.SendUpdataPulseArr(nPulse);//发送更新脉穴数据
          end;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfOpenPulse',[g_sExceptionVer]));
  end;
end;
//功能：改变络经等级
//格式：CHANGEPULSELEVEL 经络(0..3) 控制符(+,-,=) 等级(0..5) Hero
procedure TNormNpc.ActionOfChangePulseLevel(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  nPulse, nLevel, nLv: Byte;
  cMethod: Char;
  boChgOK: Boolean;
begin
  try
    nPulse := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam1), -1);//经络
    nLevel :=  Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3), -1);//等级
    if (nPulse < 0) or (nPulse > 3) or (nLevel < 0) or (nLevel > 5)  then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEPULSELEVEL);
      Exit;
    end;
    cMethod := QuestActionInfo.sParam2[1];
    if CompareText(QuestActionInfo.sParam4, 'HERO') = 0 then begin//英雄
      {$IF HEROVERSION = 1}
      if (PlayObject.m_MyHero <> nil) then begin
        if THeroObject(PlayObject.m_MyHero).m_boTrainingNG and THeroObject(PlayObject.m_MyHero).m_boOpenHumanPulseArr then begin//学过内功
          case cMethod of
            '=': begin
                THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel := nLevel;
                boChgOK := True;
              end;
            '-': begin
                nLv := _MAX(0, THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel - nLevel);
                THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel := nLv;
                boChgOK := True;
              end;
            '+': begin
                nLv := _MAX(0, THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel + nLevel);
                nLv := _MIN(5, nLv);
                THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel := nLv;
                PlayObject.m_MyHero.SendRefMsg(RM_10205, 17, 0{X}, 0{Y}, 0, '');//修炼经络自身动画
                boChgOK := True;
              end;
          end;//case
          if boChgOK then begin
            if (THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel < 5) then begin
              case nPulse of
                0:THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].dwUpPulseLevelExp:= g_Config.dwExpHeroPulsNeedExps0[THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel];
                1:THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].dwUpPulseLevelExp:= g_Config.dwExpHeroPulsNeedExps1[THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel];
                2:THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].dwUpPulseLevelExp:= g_Config.dwExpHeroPulsNeedExps2[THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel];
                3:THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].dwUpPulseLevelExp:= g_Config.dwExpHeroPulsNeedExps3[THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel];
              end;
            end;
            THeroObject(PlayObject.m_MyHero).SendUpdataPulseArr(nPulse);//更新客户端显示
            AddGameDataLog('17' + #9 + PlayObject.m_MyHero.m_sMapName + #9 + //等级调整记录日志
              IntToStr(PlayObject.m_MyHero.m_nCurrX) + #9 +
              IntToStr(PlayObject.m_MyHero.m_nCurrY)+ #9 +
              PlayObject.m_MyHero.m_sCharName + #9 +
              IntToStr(THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel) + #9 +
              '0' + #9 +
              cMethod+'('+IntToStr(nLevel)+')经络' + #9 +
              m_sCharName);
          end;
        end;
      end;
      {$IFEND}
    end else begin
      case cMethod of
        '=': begin
            PlayObject.m_wHumanPulseArr[nPulse].nPulseLevel := nLevel;
            boChgOK := True;
          end;
        '-': begin
            nLv := _MAX(0, PlayObject.m_wHumanPulseArr[nPulse].nPulseLevel - nLevel);
            PlayObject.m_wHumanPulseArr[nPulse].nPulseLevel := nLv;
            boChgOK := True;
          end;
        '+': begin
            nLv := _MAX(0, PlayObject.m_wHumanPulseArr[nPulse].nPulseLevel + nLevel);
            nLv := _MIN(5, nLv);
            PlayObject.m_wHumanPulseArr[nPulse].nPulseLevel := nLv;
            PlayObject.SendRefMsg(RM_10205, 17, 0{X}, 0{Y}, 0, '');//修炼经络自身动画 20090702
            boChgOK := True;
          end;
      end;
      if boChgOK then begin
        PlayObject.SendUpdataPulseArr(nPulse);//更新客户端显示
        AddGameDataLog('17' + #9 + PlayObject.m_sMapName + #9 + //等级调整记录日志
          IntToStr(PlayObject.m_nCurrX) + #9 +
          IntToStr(PlayObject.m_nCurrY)+ #9 +
          PlayObject.m_sCharName + #9 +
          IntToStr(PlayObject.m_wHumanPulseArr[nPulse].nPulseLevel) + #9 +
          '0' + #9 +
          cMethod+'('+IntToStr(nLevel)+')经络' + #9 +
          m_sCharName);
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangePulseLevel',[g_sExceptionVer]));
  end;
end;

//功能：改变英雄经络修炼点
//格式：CHANGEHEROPULSEXP 控制符(+,-,=) 经验值
procedure TNormNpc.ActionOfChangeHeroPulsExp(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  nExp, dwInt: LongWord;
  cMethod: Char;
//  nCode: byte;
begin
  {$IF HEROVERSION = 1}
  try
    if PlayObject.m_MyHero <> nil then begin
      if (not PlayObject.m_MyHero.m_boDeath) and (not PlayObject.m_MyHero.m_boGhost) then begin
        if THeroObject(PlayObject.m_MyHero).m_boTrainingNG and THeroObject(PlayObject.m_MyHero).m_boOpenHumanPulseArr then begin
          nExp:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);
          if (nExp < 0) then begin
            ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEHEROPULSEXP);
            Exit;
          end;
          //if THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[0].boOpenPulse then begin//20091101 注释
            cMethod := QuestActionInfo.sParam1[1];
            case cMethod of
              '=': begin
                  THeroObject(PlayObject.m_MyHero).m_ExpPuls:= nExp;
                end;
              '-': begin
                  if THeroObject(PlayObject.m_MyHero).m_ExpPuls > LongWord(nExp) then begin
                    Dec(THeroObject(PlayObject.m_MyHero).m_ExpPuls, LongWord(nExp));
                  end else begin
                    THeroObject(PlayObject.m_MyHero).m_ExpPuls := 0;
                  end;
                end;
              '+': begin
                  dwInt := LongWord(nExp);
                  if THeroObject(PlayObject.m_MyHero).m_ExpPuls >= LongWord(nExp) then begin
                    if (High(LongWord) - THeroObject(PlayObject.m_MyHero).m_ExpPuls) < LongWord(nExp) then begin
                      dwInt := High(LongWord) - THeroObject(PlayObject.m_MyHero).m_ExpPuls;
                    end;
                  end else begin
                    if (High(LongWord) - LongWord(nExp)) < THeroObject(PlayObject.m_MyHero).m_ExpPuls then begin
                      dwInt := High(LongWord) - LongWord(nExp);
                    end;
                  end;
                  THeroObject(PlayObject.m_MyHero).m_ExpPuls := THeroObject(PlayObject.m_MyHero).m_ExpPuls + dwInt;
                end;
            end;//case
            THeroObject(PlayObject.m_MyHero).SendGetPulsExp(dwInt);//发送经络经验
          //end;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeHeroPulsExp',[g_sExceptionVer]));
  end;
  {$IFEND}
end;
{$IFEND}
//功能：客户端显示锻练金针窗口 20090615
//格式：OPENMAKEKIMNEEDLE
procedure TNormNpc.ActionOfOpenMakeKimNeedle(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
begin
  try
    if not PlayObject.m_boGhost then begin
      PlayObject.SendMsg(PlayObject, RM_OPENMAKEKIMNEEDLE, 0, 0, 0, 0, '');
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfOpenMakeKimNeedle',[g_sExceptionVer]));
  end;
end;
//功能：收回包裹指定叠加物品 20090615
//格式：TAKEKIMNEEDLE 物品名称 数量 hero
procedure TNormNpc.ActionOfTakeKimNeedle(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  sItemName: string;
  nItemCount,I: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
  try
    sItemName := GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//物品名称
    nItemCount := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2),0);//数量
    if (nItemCount < 0) or (sItemName = '') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_TAKEKIMNEEDLE);
      Exit;
    end;
    if CompareText(QuestActionInfo.sParam3, 'HERO') = 0 then begin
      {$IF HEROVERSION = 1}
      if PlayObject.m_MyHero <> nil then begin
        if (not PlayObject.m_MyHero.m_boDeath) and (not PlayObject.m_MyHero.m_boGhost) then begin
          for I := PlayObject.m_MyHero.m_ItemList.Count - 1 downto 0 do begin
            if nItemCount <= 0 then Break;
            if PlayObject.m_MyHero.m_ItemList.Count <= 0 then Break;
            UserItem := PlayObject.m_MyHero.m_ItemList.Items[I];
            if UserItem = nil then Continue;
            if (CompareText(UserEngine.GetStdItemName(UserItem.wIndex), sItemName) = 0) and (UserItem.MakeIndex > 0) then begin
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem <> nil then begin
                if StdItem.StdMode = 17 then begin
                  if UserItem.Dura >= nItemCount then begin
                    UserItem.Dura:= UserItem.Dura - nItemCount;
                    nItemCount:= 0;
                    if UserItem.Dura <= 0 then begin//删除物品
                      if StdItem.NeedIdentify = 1 then
                        AddGameDataLog('10' + #9 + PlayObject.m_MyHero.m_sMapName + #9 +
                          IntToStr(PlayObject.m_MyHero.m_nCurrX) + #9 + IntToStr(PlayObject.m_MyHero.m_nCurrY) + #9 +
                          PlayObject.m_MyHero.m_sCharName + #9 + sItemName + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                          '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                          '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                          '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                          '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                          '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                          IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                          IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                          IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                          IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                      PlayObject.m_MyHero.m_ItemList.Delete(I);
                      THeroObject(PlayObject.m_MyHero).SendDelItems(UserItem);
                      UserItem.MakeIndex:= 0;
                      UserItem.wIndex:= 0;
                      //DisPoseAndNil(UserItem);
                      DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 By TasNat at: 2012-03-17
                      UserItem := nil;
                    end else begin
                      THeroObject(PlayObject.m_MyHero).SendUpdateItem(UserItem);//更新物品
                    end;
                    Break;
                  end else begin
                    Dec(nItemCount,UserItem.Dura);
                    UserItem.Dura:= 0;
                    if StdItem.NeedIdentify = 1 then
                      AddGameDataLog('10' + #9 + PlayObject.m_MyHero.m_sMapName + #9 +
                        IntToStr(PlayObject.m_MyHero.m_nCurrX) + #9 + IntToStr(PlayObject.m_MyHero.m_nCurrY) + #9 +
                        PlayObject.m_MyHero.m_sCharName + #9 + sItemName + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                        '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                        '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                        '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                        '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                        '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                        IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                        IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                        IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                        IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                    PlayObject.m_MyHero.m_ItemList.Delete(I);
                    THeroObject(PlayObject.m_MyHero).SendDelItems(UserItem);
                    UserItem.MakeIndex:= 0;
                    UserItem.wIndex:= 0;
                    //DisPoseAndNil(UserItem);
                    DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 By TasNat at: 2012-03-17
                    UserItem := nil;
                  end;
                end;
              end;//if StdItem <> nil
            end;
          end;
        end;//1
      end;
      {$IFEND}
    end else begin
      for I := PlayObject.m_ItemList.Count - 1 downto 0 do begin
        if nItemCount <= 0 then Break;
        if PlayObject.m_ItemList.Count <= 0 then Break;
        UserItem := PlayObject.m_ItemList.Items[I];
        if UserItem = nil then Continue;
        if (CompareText(UserEngine.GetStdItemName(UserItem.wIndex), sItemName) = 0) and (UserItem.MakeIndex > 0) then begin
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem <> nil then begin
            if StdItem.StdMode = 17 then begin
              if UserItem.Dura >= nItemCount then begin
                UserItem.Dura:= UserItem.Dura - nItemCount;
                nItemCount:= 0;
                if UserItem.Dura <= 0 then begin//删除物品
                  if StdItem.NeedIdentify = 1 then
                    AddGameDataLog('10' + #9 + PlayObject.m_sMapName + #9 +
                      IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                      PlayObject.m_sCharName + #9 + sItemName + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                      '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                      '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                      '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                      '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                      '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                      IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                      IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                      IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                      IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                  PlayObject.m_ItemList.Delete(I);
                  PlayObject.SendDelItems(UserItem);
                  UserItem.MakeIndex:= 0;
                  UserItem.wIndex:= 0;
                  //DisPoseAndNil(UserItem);
                  DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 By TasNat at: 2012-03-17
                  UserItem := nil;

                end else begin
                  PlayObject.SendUpdateItem(UserItem);//更新物品
                end;
                Break;
              end else begin
                Dec(nItemCount,UserItem.Dura);
                UserItem.Dura:= 0;
                if StdItem.NeedIdentify = 1 then
                  AddGameDataLog('10' + #9 + PlayObject.m_sMapName + #9 +
                    IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                    PlayObject.m_sCharName + #9 + sItemName + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                    '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                    '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                    '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                    '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                    '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                    IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                    IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                    IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                    IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                PlayObject.m_ItemList.Delete(I);
                PlayObject.SendDelItems(UserItem);
                UserItem.MakeIndex:= 0;
                UserItem.wIndex:= 0;
                //DisPoseAndNil(UserItem);
                DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 By TasNat at: 2012-03-17
                UserItem := nil;
              end;
            end;
          end;//if StdItem <> nil
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfTakeKimNeedle',[g_sExceptionVer]));
  end;
end;
//功能：给指定的叠加物品 20090615
//格式：GIVEKIMNEEDLE 物品名称 数量 hero
procedure TNormNpc.ActionOfGiveKimNeedle(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  sItemName: string;
  nItemCount: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
  try
    sItemName := GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//物品名称
    nItemCount := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2),0);//数量
    if (sItemName = '') or (nItemCount <= 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_GIVEKIMNEEDLE);
      Exit;
    end;
    if CompareText(QuestActionInfo.sParam3, 'HERO') = 0 then begin
      {$IF HEROVERSION = 1}
      if PlayObject.m_MyHero <> nil then begin
        if (not PlayObject.m_MyHero.m_boDeath) and (not PlayObject.m_MyHero.m_boGhost) then begin
          if UserEngine.GetStdItemIdx(sItemName) > 0 then begin
            New(UserItem);
            if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem <> nil then begin
                if StdItem.StdMode = 17 then begin
                  UserItem.Dura:= nItemCount;
                  if UserItem.Dura > UserItem.DuraMax then UserItem.Dura:= UserItem.DuraMax;
                    if THeroObject(PlayObject.m_MyHero).IsEnoughBag then begin
                      PlayObject.m_MyHero.m_ItemList.Add(UserItem);
                      THeroObject(PlayObject.m_MyHero).SendAddItem(UserItem);
                      if StdItem.NeedIdentify = 1 then
                        AddGameDataLog('9' + #9 + PlayObject.m_MyHero.m_sMapName + #9 +
                          IntToStr(PlayObject.m_MyHero.m_nCurrX) + #9 + IntToStr(PlayObject.m_MyHero.m_nCurrY) + #9 +
                          PlayObject.m_MyHero.m_sCharName + #9 + sItemName + #9 +
                          IntToStr(UserItem.MakeIndex) + #9 +
                          IntToStr(UserItem.Dura)+'/'+IntToStr(UserItem.DuraMax)+ #9 + m_sCharName);
                    end else begin
                      if PlayObject.IsEnoughBag then begin//主人包裹未满
                        PlayObject.m_ItemList.Add(UserItem);
                        PlayObject.SendAddItem(UserItem);
                        if StdItem.NeedIdentify = 1 then
                          AddGameDataLog('9' + #9 + PlayObject.m_sMapName + #9 +
                            IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                            PlayObject.m_sCharName + #9 + sItemName + #9 +
                            IntToStr(UserItem.MakeIndex) + #9 +
                            IntToStr(UserItem.Dura)+'/'+IntToStr(UserItem.DuraMax)+ #9 + m_sCharName);
                      end else begin//包裹满则扔到地上
                        if StdItem.NeedIdentify = 1 then
                          AddGameDataLog('9' + #9 + PlayObject.m_sMapName + #9 +
                            IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                            PlayObject.m_sCharName + #9 + sItemName + #9 +
                            IntToStr(UserItem.MakeIndex) + #9 +
                            IntToStr(UserItem.Dura)+'/'+IntToStr(UserItem.DuraMax)+ #9 + m_sCharName);
                        PlayObject.DropItemDown(UserItem, 3, False, False, PlayObject, PlayObject);
                        Dispose(UserItem);//修复内存泄露By TasNat at: 2012-06-01 12:10:51
                      end;
                    end;
                end else Dispose(UserItem);
              end else Dispose(UserItem);
            end else Dispose(UserItem);
          end;
        end;
      end;  
      {$IFEND}
    end else begin
      if UserEngine.GetStdItemIdx(sItemName) > 0 then begin
        New(UserItem);
        if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem <> nil then begin
            if StdItem.StdMode = 17 then begin
              UserItem.Dura:= nItemCount;
              if UserItem.Dura > UserItem.DuraMax then UserItem.Dura:= UserItem.DuraMax;
              if not PlayObject.AutoItemMerger(UserItem) then begin//自动合并物品 20091126
                if PlayObject.IsEnoughBag then begin
                  PlayObject.m_ItemList.Add(UserItem);
                  PlayObject.SendAddItem(UserItem);
                  if StdItem.NeedIdentify = 1 then
                    AddGameDataLog('9' + #9 + PlayObject.m_sMapName + #9 +
                      IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                      PlayObject.m_sCharName + #9 + sItemName + #9 +
                      IntToStr(UserItem.MakeIndex) + #9 +
                      IntToStr(UserItem.Dura)+'/'+IntToStr(UserItem.DuraMax)+ #9 + m_sCharName);
                end else begin//包裹满则扔到地上
                  if StdItem.NeedIdentify = 1 then
                    AddGameDataLog('9' + #9 + PlayObject.m_sMapName + #9 +
                      IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                      PlayObject.m_sCharName + #9 + sItemName + #9 +
                      IntToStr(UserItem.MakeIndex) + #9 +
                      IntToStr(UserItem.Dura)+'/'+IntToStr(UserItem.DuraMax)+ #9 + m_sCharName);
                  PlayObject.DropItemDown(UserItem, 3, False, False, PlayObject, PlayObject);
                  Dispose(UserItem);//修复内存泄露By TasNat at: 2012-06-01 12:10:51
                end;
              end;
            end else Dispose(UserItem);
          end else Dispose(UserItem);
        end else Dispose(UserItem);
      end;
//--------------------------------------------------
      {if PlayObject.IsEnoughBag then begin
        New(UserItem);
        if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem <> nil then begin
            if StdItem.StdMode = 17 then begin
              UserItem.Dura:= nItemCount;
              if UserItem.Dura > UserItem.DuraMax then UserItem.Dura:= UserItem.DuraMax;
              if not PlayObject.AutoItemMerger(UserItem) then begin//自动合并物品 20091126
                PlayObject.m_ItemList.Add(UserItem);
                PlayObject.SendAddItem(UserItem);
                if StdItem.NeedIdentify = 1 then
                  AddGameDataLog('9' + #9 + PlayObject.m_sMapName + #9 +
                    IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                    PlayObject.m_sCharName + #9 + sItemName + #9 +
                    IntToStr(UserItem.MakeIndex) + #9 +
                    IntToStr(UserItem.Dura)+'/'+IntToStr(UserItem.DuraMax)+ #9 + m_sCharName);
              end;
            end else Dispose(UserItem);
          end;
        end else Dispose(UserItem);
      end else begin//包裹满则扔到地上
        New(UserItem);
        if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem <> nil then begin
            if StdItem.StdMode = 17 then begin
              UserItem.Dura:= nItemCount;
              if UserItem.Dura > UserItem.DuraMax then UserItem.Dura:= UserItem.DuraMax;
              if StdItem.NeedIdentify = 1 then
                AddGameDataLog('9' + #9 + PlayObject.m_sMapName + #9 +
                  IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                  PlayObject.m_sCharName + #9 + sItemName + #9 +
                  IntToStr(UserItem.MakeIndex) + #9 +
                  IntToStr(UserItem.Dura)+'/'+IntToStr(UserItem.DuraMax)+ #9 + m_sCharName);
              PlayObject.DropItemDown(UserItem, 3, False, False, PlayObject, PlayObject);
            end else Dispose(UserItem);
          end else Dispose(UserItem);
        end else Dispose(UserItem);
      end;}
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfGiveKimNeedle',[g_sExceptionVer]));
  end;
end;
//功能：改变人物的攻击模式
//格式: CHANGEATTATCKMODE 模式(0..7)
procedure TNormNpc.ActionOfChangeAttatckMode(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nMode: Byte;
begin
  try
    nMode:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam1), -1);
    if (nMode >= 0) and (nMode <= {$IF M2Version <> 2}HAM_DIVISION{$ELSE}HAM_PKATTACK{$IFEND}) then
      PlayObject.m_btAttatckMode := nMode;
    case PlayObject.m_btAttatckMode of         //20080228改攻击模式
      HAM_ALL:begin //20080331 加入聊天框中提示
           PlayObject.SendMsg(PlayObject, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfAll); //[攻击模式: 全体攻击]
           PlayObject.SysMsg(sAttackModeOfAll, c_Green, t_Hint); //[攻击模式: 全体攻击]
         end;
      HAM_PEACE:begin
           PlayObject.SendMsg(PlayObject, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfPeaceful); //[攻击模式: 和平攻击]
           PlayObject.SysMsg(sAttackModeOfPeaceful, c_Green, t_Hint); //[攻击模式: 和平攻击]
         end;
      HAM_DEAR:begin
           PlayObject.SendMsg(PlayObject, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfDear); //[攻击模式: 夫妻攻击]
           PlayObject.SysMsg(sAttackModeOfDear, c_Green, t_Hint); //[攻击模式: 夫妻攻击]
         end;
      HAM_MASTER:begin
           PlayObject.SendMsg(PlayObject, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfMaster); //[攻击模式: 师徒攻击]
           PlayObject.SysMsg(sAttackModeOfMaster, c_Green, t_Hint); //[攻击模式: 师徒攻击]
         end;
      HAM_GROUP:begin
           PlayObject.SendMsg(PlayObject, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfGroup); //[攻击模式: 编组攻击]
           PlayObject.SysMsg(sAttackModeOfGroup, c_Green, t_Hint); //[攻击模式: 编组攻击]
         end;
      HAM_GUILD:begin
           PlayObject.SendMsg(PlayObject, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfGuild); //[攻击模式: 行会攻击]
           PlayObject.SysMsg(sAttackModeOfGuild, c_Green, t_Hint); //[攻击模式: 行会攻击]
         end;
      HAM_PKATTACK:begin
           PlayObject.SendMsg(PlayObject, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfRedWhite); //[攻击模式: 红名攻击]
           PlayObject.SysMsg(sAttackModeOfRedWhite, c_Green, t_Hint); //[攻击模式: 红名攻击]
         end;
      {$IF M2Version <> 2}
      HAM_DIVISION: begin
           PlayObject.SendMsg(PlayObject, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfDivision); //[攻击模式: 师门攻击]
           PlayObject.SysMsg(sAttackModeOfDivision, c_Green, t_Hint); //[攻击模式: 师门攻击]
         end;
      {$IFEND}
    end;
    if PlayObject.m_MyHero <> nil then PlayObject.m_MyHero.m_btAttatckMode := PlayObject.m_btAttatckMode;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeAttatckMode',[g_sExceptionVer]));
  end;
end;
//功能：客户端显示牛气管图标
//格式：OPENCATTLEGAS 是否清空变量
procedure TNormNpc.ActionOfOPENCATTLEGAS(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
begin
  try
    PlayObject.m_boShowCattleGas:= True;//是否显示气牛管图标
    if QuestActionInfo.sParam1 = '' then begin
      with PlayObject do begin
        m_CattleGasLevel:= 0;//牛气等级
        m_CattleGasExp:= 0;//当前牛气值
        m_CattleGasMaxExp:= 0;//牛气值升级经验
      end;
      //发消息显示牛气管图标
      PlayObject.SendMsg(PlayObject, RM_OPENCATTLEGAS, 0, 2, 0, 0, '');
    end else begin
      if PlayObject.m_CattleGasLevel <= 0 then PlayObject.m_CattleGasLevel:= 1;
      //发消息显示牛气管图标
      PlayObject.SendMsg(PlayObject, RM_OPENCATTLEGAS, 0, 2, 1, PlayObject.m_CattleGasLevel{牛气管等级}, '');//发送牛气管等级 20110715 增加
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfOPENCATTLEGAS',[g_sExceptionVer]));
  end;
end;
//功能：客户端关闭牛气管图标
//格式：CLOSECATTLEGAS
procedure TNormNpc.ActionOfCLOSECATTLEGAS(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
begin
  try
    if PlayObject.m_boShowCattleGas then begin
      PlayObject.m_boShowCattleGas:= False;//是否显示气牛管图标
      PlayObject.m_CattleGasLevel:= 1;//牛气等级
      PlayObject.m_CattleGasExp:= 0;//当前牛气值
      PlayObject.m_CattleGasMaxExp:= 0;//牛气值升级经验
      //发消息关闭牛气管图标
      PlayObject.SendMsg(PlayObject, RM_OPENCATTLEGAS, 0, 1, 0, 0, '');
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfCLOSECATTLEGAS',[g_sExceptionVer]));
  end;
end;

//功能：时间到触发QF段 20090124
//格式：SENDTIMEMSG 消息内容 时间 字颜色 QF触发段 换地图是否显示
//例：SENDTIMEMSG 火龙殿任务还剩%s秒结束... 300 251 @触发测试
//说明：300代表时间(秒)  251代表颜色 @触发测试 触发QFunction-0.txt
procedure TNormNpc.ActionOfSENDTIMEMSG(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nTime: Integer;
  FColor: Byte;
  sQFStr, sMsg: string;
  boForMapShowHint: Boolean;
begin
  try
    sMsg:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1);
    nTime:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2), -1);//时间(秒)
    FColor:= _MIN(255, Str_ToInt(QuestActionInfo.sParam3, 0));//字颜色
    sQFStr:= GetLineVariableText(PlayObject,QuestActionInfo.sParam4);//触发QFunction-0.txt段
    boForMapShowHint:= Str_ToInt(QuestActionInfo.sParam5, 0) <> 0;//换地图是否还显示倒计时信息 20090128
    if (sMsg = '') or (sQFStr = '') or (nTime < 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_SENDTIMEMSG);
      Exit;
    end;
    //设置人物的时间
    PlayObject.m_dwUserTick[0]:= nTime;
    PlayObject.m_sMapQFStr:= sQFStr;//SENDTIMEMSG命令设置的触发段 20090124
    PlayObject.m_boForMapShowHint:= boForMapShowHint;//换地图是否还显示倒计时信息 20090128
    PlayObject.m_dwUserTick[3]:= 0;//20090129 
    //发送显示信息给客户端
    PlayObject.SendMsg(PlayObject, RM_MOVEMESSAGE, 2{倒记时消息}, FColor, 0, nTime, sMsg);//客户端显示倒计时(快捷键上方显示) 20090126
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfSENDTIMEMSG',[g_sExceptionVer]));
  end;
end;

//功能：时间到后进入QFunction-0.txt 指定的触发段,发消息给客户端显示'!'号图标
//格式：SENDMSGWINDOWS 时间  QF解发段
//例：  SENDMSGWINDOWS 300 @提示窗的触发
//说明：300代表时间(秒)  @提示窗的触发 触发QFunction-0.txt
procedure TNormNpc.ActionOfSENDMSGWINDOWS(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nTime: Integer;
  sQFStr: string;
begin
  try
    nTime:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam1), -1);//时间(秒)
    sQFStr:= GetLineVariableText(PlayObject,QuestActionInfo.sParam2);//触发QFunction-0.txt段
    if (sQFStr = '') or (nTime < 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_SENDMSGWINDOWS);
      Exit;
    end;
    //设置人物的时间
    PlayObject.m_dwUserTick[2]:= nTime;
    PlayObject.m_sMapQFStr1:= sQFStr;//SENDMSGWINDOWS命令设置的触发段 20090124
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfSENDMSGWINDOWS',[g_sExceptionVer]));
  end;
end;

//功能：关闭客户端'!'图标的显示 20090126
//格式：CLOSEMSGWINDOWS
procedure TNormNpc.ActionOfCLOSEMSGWINDOWS(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
begin
  try
    PlayObject.m_sMapQFStr1:= '';//20090816 增加
    PlayObject.SendMsg(PlayObject, RM_HIDESIGHICON, 0, 0, 0, 0, '');//发消息给客户端关闭图标的显示
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfCLOSEMSGWINDOWS',[g_sExceptionVer]));
  end;
end;

//功能：取当前月份天数 20110304
//格式：GETMONTHSDAY 变量
procedure TNormNpc.ActionOfGetMonthsDay(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
 nDayCount: Integer;
begin
  try
    nDayCount:= GetMonthsDay(Now());
    SetValValue(PlayObject, QuestActionInfo.sParam1, nDayCount);
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfGetMonthsDay',[g_sExceptionVer]));
  end;
end;  

//功能：取组队成员数
//格式：GETGROUPCOUNT 变量
procedure TNormNpc.ActionOfGETGROUPCOUNT(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
 nGroupCount: Integer;
begin
  try
    if (PlayObject.m_GroupOwner <> nil) then begin//有组队
      if PlayObject.m_GroupOwner.m_GroupMembers.Count > 0 then begin
        nGroupCount:= PlayObject.m_GroupOwner.m_GroupMembers.Count;
      end;
    end;
    SetValValue(PlayObject, QuestActionInfo.sParam1, nGroupCount);
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfGETGROUPCOUNT',[g_sExceptionVer]));
  end;
end;

//改变发型
//格式：HAIRSTYLE 发型 hero
procedure TNormNpc.ActionOfChangeHairStyle(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nHair: Integer;
begin
  try
    nHair := Str_ToInt(QuestActionInfo.sParam1, -1);
    if CompareText(QuestActionInfo.sParam2, 'HERO') = 0 then begin
      {$IF HEROVERSION = 1}
      if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then Exit;
      if PlayObject.m_MyHero <> nil then begin
        PlayObject.m_MyHero.m_btHair := nHair;
        PlayObject.m_MyHero.FeatureChanged;
      end;
      {$IFEND}
    end else begin
      if (QuestActionInfo.sParam1 <> '') and (nHair >= 0) then begin
        PlayObject.m_btHair := nHair;
        PlayObject.FeatureChanged;
      end else begin
        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_HAIRSTYLE);
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeHairStyle',[g_sExceptionVer]));
  end;
end;
//改变职业(转职)
//格式：CHANGEJOB 职业(Warrior/WIZARD/TAOIST) 是否清连击变量(1-全部初始 2-清空经络修炼等级)
procedure TNormNpc.ActionOfChangeJob(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nJob, I: Integer;
  nType: Byte;
begin
  try
    nJob := -1;
    if CompareLStr(QuestActionInfo.sParam1, 'WARRIOR'{sWARRIOR}, 3) then nJob := 0;
    if CompareLStr(QuestActionInfo.sParam1, 'WIZARD'{sWIZARD}, 3) then nJob := 1;
    if CompareLStr(QuestActionInfo.sParam1, 'TAOIST'{sTAOS}, 3) then nJob := 2;
    //if CompareLStr(QuestActionInfo.sParam1, 'ASSASSIN', 3) then nJob := 3;//刺客 20080929
    nType:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2),0);//操作类型

    if nJob < 0 then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEJOB);
      Exit;
    end;

    if PlayObject.m_btJob <> nJob then begin
      PlayObject.m_btJob := nJob;
      PlayObject.HasLevelUp(0);
    end;
    Case nType of
      1: begin//初始所有连击变量
        {$IF M2Version = 1}
        FillChar(PlayObject.m_wHumanPulseArr, SizeOf(THumanPulseInfo), #0);
        PlayObject.SendUserPulseArr;//更新客户端显示
        PlayObject.m_boTrainBatterSkill:= False;
        PlayObject.m_boUser4BatterSkill:= False;//使用第四格连击 20100720
        {$IFEND}
        PlayObject.m_PulseAddAC:= 0;//防御上限
        PlayObject.m_PulseAddAC1:= 0;//防御下限
        PlayObject.m_PulseAddMAC:= 0;//魔御上限
        PlayObject.m_PulseAddMAC1:= 0;//魔御下限
        PlayObject.m_nDecDamage:= 0;//吸收伤害
      end;
      2: begin//初始经络修练等级
        {$IF M2Version = 1}
        for I := Low(PlayObject.m_wHumanPulseArr) to High(PlayObject.m_wHumanPulseArr) do begin
          PlayObject.m_wHumanPulseArr[I].nPulseLevel := 0;
        end;
        {$IFEND}
        PlayObject.m_PulseAddAC:= 0;//防御上限
        PlayObject.m_PulseAddAC1:= 0;//防御下限
        PlayObject.m_PulseAddMAC:= 0;//魔御上限
        PlayObject.m_PulseAddMAC1:= 0;//魔御下限
        PlayObject.m_nDecDamage:= 0;//吸收伤害
        {$IF M2Version = 1}
        PlayObject.m_boTrainBatterSkill:= False;
        PlayObject.m_boUser4BatterSkill:= False;//使用第四格连击 20100720
        PlayObject.SendUserPulseArr;//更新客户端显示
        {$IFEND}
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeJob',[g_sExceptionVer]));
  end;
end;
//改变等级
procedure TNormNpc.ActionOfChangeLevel(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  boChgOK: Boolean;
  nLevel: Integer;
  nLv: Integer;
  nOldLevel: Integer;
  cMethod: Char;
begin
try
  boChgOK := False;
  nOldLevel := PlayObject.m_Abil.Level;
  nLevel := Str_ToInt(QuestActionInfo.sParam2, -1);
  if (nLevel < 0) and (not GetValValue(PlayObject, QuestActionInfo.sParam2, nLevel)) then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGELEVEL);
    Exit;
  end;
  cMethod := QuestActionInfo.sParam1[1];
  case cMethod of
    '=': begin
        if (nLevel > 0) and (nLevel <= MAXLEVEL) then begin
          PlayObject.m_Abil.Level := nLevel;
          boChgOK := True;
        end;
      end;
    '-': begin
        nLv := _MAX(0, PlayObject.m_Abil.Level - nLevel);
        nLv := _MIN(MAXLEVEL, nLv);
        PlayObject.m_Abil.Level := nLv;
        boChgOK := True;
      end;
    '+': begin
        nLv := _MAX(0, PlayObject.m_Abil.Level + nLevel);
        nLv := _MIN(MAXLEVEL, nLv);
        PlayObject.m_Abil.Level := nLv;
        boChgOK := True;
      end;
  end;
  if boChgOK then begin
    PlayObject.HasLevelUp(nOldLevel);
    AddGameDataLog('17' + #9 + PlayObject.m_sMapName + #9 + //等级调整记录日志 20080911
      IntToStr(PlayObject.m_nCurrX) + #9 +
      IntToStr(PlayObject.m_nCurrY)+ #9 +
      PlayObject.m_sCharName + #9 +
      IntToStr(PlayObject.m_Abil.Level) + #9 +
      '0' + #9 +
      cMethod+'('+IntToStr(nLevel)+')' + #9 +
      m_sCharName);
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeLevel',[g_sExceptionVer]));
end;
end;
//调整PK值
procedure TNormNpc.ActionOfChangePkPoint(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nPKPOINT: Integer;
  nPoint: Integer;
  nOldPKLevel: Integer;
  cMethod: Char;
begin
  try
    nOldPKLevel := PlayObject.PKLevel;
    nPKPOINT:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);//20080430

    if (nPKPOINT < 0) and (not GetValValue(PlayObject, QuestActionInfo.sParam2, nPKPOINT)) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEPKPOINT);
      Exit;
    end;
    cMethod := QuestActionInfo.sParam1[1];
    case cMethod of
      '=': begin
          if (nPKPOINT >= 0) then begin
            PlayObject.m_nPkPoint := nPKPOINT;
          end;
        end;
      '-': begin
          nPoint := _MAX(0, PlayObject.m_nPkPoint - nPKPOINT);
          PlayObject.m_nPkPoint := nPoint;
        end;
      '+': begin
          nPoint := _MAX(0, PlayObject.m_nPkPoint + nPKPOINT);
          PlayObject.m_nPkPoint := nPoint;
        end;
    end;
    if nOldPKLevel <> PlayObject.PKLevel then PlayObject.RefNameColor;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangePkPoint',[g_sExceptionVer]));
  end;
end;
//功能：清除地图怪物
//格式：CLEARMAPMON 地图号 怪种族ID
procedure TNormNpc.ActionOfClearMapMon(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  MonList: TList;
  mon: TBaseObject;
  II, nRace: Integer;
  sMap: String;
begin
  try
    MonList := TList.Create;
    try
      sMap:= QuestActionInfo.sParam1;
      if (sMap <> '') and (sMap[1] = '<') and (sMap[2] = '$') then//增加支持<$Str()> 20080422
         sMap := GetLineVariableText(PlayObject, QuestActionInfo.sParam1)
      else GetValValue(PlayObject, QuestActionInfo.sParam1, sMap);
      nRace:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2), 0);
     // sMap:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1); //地图支持变量 20080419
      UserEngine.GetMapMonster(g_MapManager.FindMap(sMap), MonList);
      if MonList.Count > 0 then begin//20080629
        for II := 0 to MonList.Count - 1 do begin
          mon := TBaseObject(MonList.Items[II]);
          if mon <> nil then begin
            if GetNoClearMonList(mon.m_sCharName) then Continue;
            if nRace = 0 then begin
              if (mon.m_Master <> nil) and (mon.m_btRaceServer <> 135) then Continue;//135的宝宝不要清除
              mon.m_boNoItem := True;
              mon.m_WAbil.HP := 0;
              mon.MakeGhost;
            end else begin
              if (mon.m_btRaceServer = nRace) then begin
                mon.m_boNoItem := True;
                mon.m_WAbil.HP := 0;
                mon.MakeGhost;
              end;
            end;
          end;
        end;
      end;
    finally
      MonList.Free;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfClearMapMon',[g_sExceptionVer]));
  end;
end;
//功能:传送到指定宝宝的身边
//格式:MAPMOVESLAVENAME 下属名字
procedure TNormNpc.ActionOfMapMoveSlaveName(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I, nX, nY, n1C, oleDir: Integer;
  sSlaveName: string;
  BaseObject: TBaseObject;
begin
  try
    sSlaveName:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1);
    if sSlaveName = '' then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_MAPMOVESLAVENAME);
      Exit;
    end;
    if PlayObject.m_SlaveList.Count > 0 then begin
      for I := 0 to PlayObject.m_SlaveList.Count - 1 do begin
        BaseObject := TBaseObject(PlayObject.m_SlaveList.Items[I]);
        if CompareText(sSlaveName, BaseObject.m_sCharName) = 0 then begin
          if (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) and
            (BaseObject.m_PEnvir <> nil) then begin
            oleDir:= BaseObject.m_btDirection;
            n1C:= 0;
            BaseObject.GetFrontPosition(nX, nY);
            while (True) do begin
              try
                if not BaseObject.m_PEnvir.CanWalk(nX, nY, False) then begin//如果坐标无法走，计算可以走到的坐标上
                  BaseObject.m_btDirection := (oleDir + n1C) mod 8;
                  BaseObject.GetFrontPosition(nX, nY);
                end else Break;
              except
              end;
              Inc(n1C);
              if n1C >= 9 then Break;
            end;
            PlayObject.SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
            PlayObject.SpaceMove(BaseObject.m_sMapName, nX, nY, 0);
          end;
          Break;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfMapMoveSlaveName',[g_sExceptionVer]));
  end;
end;

//功能:加载宠物配置文本
//格式:LOADPETSMONSET 配置路径
procedure TNormNpc.ActionOfLoadPetsMonSet(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  LoadList: TStringList;
  sFileName, sName, sMonName, sMap: string;
  IniFile: TIniFile;
  I, nHapp: Integer;
begin
  try
    sFileName := GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//路径支持变量
    if sFileName <> '' then begin
      if sFileName[1] = '\' then sFileName := Copy(sFileName, 2, Length(sFileName) - 1);
      if sFileName[2] = '\' then sFileName := Copy(sFileName, 3, Length(sFileName) - 2);
      if sFileName[3] = '\' then sFileName := Copy(sFileName, 4, Length(sFileName) - 3);
    end;
    sFileName := g_Config.sEnvirDir + sFileName;
    if FileExists(sFileName) then begin
      UserEngine.m_M2AutoAddPetsMon.Clear;
      LoadList := TStringList.Create;
      IniFile := TIniFile.Create(sFileName);
      try
        IniFile.ReadSections(LoadList);
        if LoadList.Count > 0 then begin
          for I := 0 to LoadList.Count - 1 do begin
            sName:= LoadList.Strings[I];
            if sName <> '' then begin
              sMonName:= IniFile.ReadString(sName,'宠物', '');
              nHapp:= IniFile.ReadInteger(sName,'快乐度', 0);
              sMap:= IniFile.ReadString(sName,'配置', '');
              if (sMonName <>'') and (sMap <>'') then begin
                UserEngine.m_M2AutoAddPetsMon.Add(Format('%s %s %d %s',[sName, sMonName, nHapp, sMap]));
              end;
            end;
          end;
        end;
      finally
        LoadList.Free;
        IniFile.free;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfLoadPetsMonSet',[g_sExceptionVer]));
  end;
end;

//清空文件内容(并带创建文件)
procedure TNormNpc.ActionOfClearNameList(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  LoadList: TStringList;
  sListFileName,s01: string;
begin
  s01 := GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//20080602 路径支持变量
  if s01 <> '' then begin
    if s01[1] = '\' then s01 := Copy(s01, 2, Length(s01) - 1);
    if s01[2] = '\' then s01 := Copy(s01, 3, Length(s01) - 2);
    if s01[3] = '\' then s01 := Copy(s01, 4, Length(s01) - 3);
  end;
  sListFileName := g_Config.sEnvirDir {+ m_sPath} + s01;//20090102
  LoadList := TStringList.Create;
  try
    LoadList.Clear;
    try
      LoadList.SaveToFile(sListFileName);
    except
      MainOutMessage('文件保存失败 => ' + sListFileName);
    end;
  finally
    LoadList.Free;
  end;
end;
//功能：清除人物的所有技能。  20080423
//格式：CLEARSKILL 参数一，为1时，则不清理通用技能(移形换位,先天元力,酒气护体,倚天辟地,护体神盾,强身术，神秘解读，神龙附体) (加参数一HERO,即是删除英雄技能,空则是人物技能)
procedure TNormNpc.ActionOfClearSkill(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I: Integer;
  UserMagic: pTUserMagic;
  boNotClearGeneral: boolean;
begin
  boNotClearGeneral:= False;
  try
    if CompareText(QuestActionInfo.sParam1, 'HERO') = 0 then begin
      {$IF HEROVERSION = 1}
      boNotClearGeneral:= CompareText(QuestActionInfo.sParam2, '1') = 0;
      if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then begin //20080519
        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CLEARSKILL);
        Exit;
      end;
      if PlayObject.m_MyHero <> nil then begin
        for I := PlayObject.m_MyHero.m_MagicList.Count - 1 downto 0 do begin
          if PlayObject.m_MyHero.m_MagicList.Count <= 0 then Break;
          UserMagic := PlayObject.m_MyHero.m_MagicList.Items[I];
          if boNotClearGeneral then begin
            if UserMagic.wMagIdx in [SKILL_56,SKILL_67,SKILL_68,SKILL_69,SKILL_75,SKILL_99, SKILL_101, SKILL_102] then Continue;//继续 移形换位,先天元力,酒气护体,倚天辟地,护体神盾,强身术,神龙附体,唯我独尊
          end;
          PlayObject.m_MyHero.m_MagicList.Delete(I);
          THeroObject(PlayObject.m_MyHero).SendDelMagic(UserMagic);
          //PlayObject.m_MyHero.m_MagicOfDelList.Add(UserMagic);
          //防止释放内存后的非法访问 By TasNat at: 2012-03-11 11:3
          Dispose(UserMagic);
        end;
        THeroObject(PlayObject.m_MyHero).RecalcAbilitys();//20081213 修改
        PlayObject.m_MyHero.CompareSuitItem(False);//200080729 套装
      end;
      {$IFEND} 
    end else begin
      boNotClearGeneral:= CompareText(QuestActionInfo.sParam1, '1') = 0;//是否清理通用技能 20100704
      for I := PlayObject.m_MagicList.Count - 1 downto 0 do begin
        if PlayObject.m_MagicList.Count <= 0 then Break;//20080917
        UserMagic := PlayObject.m_MagicList.Items[I];
        if boNotClearGeneral then begin
          if UserMagic.wMagIdx in [SKILL_56,SKILL_67,SKILL_68,SKILL_69,SKILL_75, SKILL_100, SKILL_101, SKILL_102] then Continue;//继续 移形换位,先天元力,酒气护体,倚天辟地,护体神盾,神秘解读,神龙附体,唯我独尊
        end;
        PlayObject.SendDelMagic(UserMagic);
        //防止释放内存后的非法访问 By TasNat at: 2012-03-11 11:3
        //PlayObject.m_MagicOfDelList.Add(UserMagic);
        Dispose(UserMagic);
        PlayObject.m_MagicList.Delete(I);
      end;
      PlayObject.RecalcAbilitys();
      PlayObject.CompareSuitItem(False);//200080729 套装
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfClearSkill',[g_sExceptionVer]));
  end;
end;

//功能：增加地图连接 20090503
//格式：ADDRANDOMMAPGATE 地图名称 地图坐标X 地图坐标Y 到达地图名称 到达地图坐标X 到达地图坐标Y 是否互传(0/1)
//是否互传 1-可以互传
procedure TNormNpc.ActionOfAddRandomMapGate(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  nX, nY, nXX, nYY, nType:Integer;
  sMapA, sMapB: String;
begin
  try
    sMapA:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1); //地图ID 支持变量
    nX:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2), -1);//X
    nY:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3), -1);//Y

    sMapB:= GetLineVariableText(PlayObject, QuestActionInfo.sParam4); //地图ID 支持变量
    nXX:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam5), -1);//X
    nYY:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam6), -1);//Y

    nType:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam7), 0);//两地图是否可以互传
    if (sMapA ='') or (sMapB ='') or (nX < 0) or (nY < 0)  or (nXX < 0) or (nYY < 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_ADDRANDOMMAPGATE);
      Exit;
    end;
    if nType = 1 then begin
      g_MapManager.AddMapRoute(sMapA, nX, nY, sMapB, nXX, nYY);
      g_MapManager.AddMapRoute(sMapB, nXX, nYY, sMapA, nX, nY);
    end else g_MapManager.AddMapRoute(sMapA, nX, nY, sMapB, nXX, nYY);
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfAddRandomMapGate',[g_sExceptionVer]));
  end;
end;

//功能：删除地图连接 20090503
//格式：DELRANDOMMAPGATE 地图名称 地图坐标X 地图坐标Y
procedure TNormNpc.ActionOfDelRandomMapGate(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  nX, nY, I:Integer;
  sMap: String;
  Envir: TEnvirnoment;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  bo1D: Boolean;
begin
  try
    sMap:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1); //地图ID 支持变量
    nX:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2), -1);//X
    nY:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3), -1);//Y
    if (sMap ='') or (nX < 0) or (nY < 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_DELRANDOMMAPGATE);
      Exit;
    end;
    Envir := g_MapManager.FindMap(sMap);//查找地图场景
    if Envir <> nil then begin
      bo1D:= Envir.GetMapCellInfo(nX, nY, MapCellInfo);
      if bo1D and (MapCellInfo.ObjList <> nil) then begin
        if MapCellInfo.ObjList.Count > 0 then begin
          for I := 0 to MapCellInfo.ObjList.Count - 1 do begin
            try
              OSObject := MapCellInfo.ObjList.Items[I];
            except
              OSObject := nil;//20091102 增加
            end;
            if OSObject <> nil then begin
              if (OSObject.btType = OS_GATEOBJECT) and (not OSObject.boObjectDisPose) then begin//20090510 修改
                MapCellInfo.ObjList.Delete(I);//先删除 By TasNat at: 2012-03-17 17:43:29
                OSObject.boObjectDisPose:= True;//20090510 增加
                if pTGateObj(OSObject.CellObj) <> nil then Dispose(pTGateObj(OSObject.CellObj));
                //DisPoseAndNil(OSObject);
                DisPose(OSObject);//本地变量没必要NIL By TasNat at: 2012-03-17
                Break;
              end;
            end;                     
          end;//for
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfDelRandomMapGate',[g_sExceptionVer]));
  end;
end;

//-------------------Add By TasNat at: 2012-03-17 11:36:48-----------------------------

//功能：清理背包物品
//格式：ClearBagItems Hero
procedure TNormNpc.ActionOfClearBagItems(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  Obj : TBaseObject;
begin
  try
    {$IF HEROVERSION = 1}
      if CompareText(QuestActionInfo.sParam1, 'Hero') = 0 then begin//判断英雄的背包
        Obj := PlayObject.m_MyHero;
      end else
      {$IFEND}
      begin
        Obj := PlayObject;
      end;
    if Obj <> nil then begin
      Obj.ClearBagItem;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfClearBagItems',[g_sExceptionVer]));
  end;
end;

//功能：清理地图物品
//格式：ClearMapItem 地图编号 X,Y 范围
procedure TNormNpc.ActionOfClearMapItem(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  nX, nY, nRage, I:Integer;
  sMap: String;
  Envir: TEnvirnoment;
  List : TList;
  MapItem : PTMapItem;
begin
  try
    sMap:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1); //地图编号
    Envir := g_MapManager.FindMap(sMap);
    if Envir = nil then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CLEARMAPITEM);
      Exit;
    end;
    nX := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2), 0);
    nY := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3), 0);
    nRage := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam4), 0);
    Envir.ClearItem(nX, nY, nRage);
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfClearMapItem',[g_sExceptionVer]));
  end;
end;
//调整强化技能等级
//格式：IncreaseSkillLevel 技能名字 操作符 等级
{
Param1 不解释
Param2 不解释
Param3 不解释
}
procedure TNormNpc.ActionOfIncreaseSkillLevel(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  UserMagic : pTUserMagic;
  nLevel : Integer;
  CCode : Char;
  sName : string;
begin
  try
    CCode := '=';
    sName := QuestActionInfo.sParam2;
    if length(sName) = 1 then
      CCode := sName[1];

    sName := GetLineVariableText(PlayObject, QuestActionInfo.sParam3);
    nLevel := Str_ToInt(sName, 0);
    sName := GetLineVariableText(PlayObject, QuestActionInfo.sParam1);
    UserMagic := PlayObject.GetMagicInfo(sName);
    if UserMagic <> nil then begin
      case CCode of
        '=' : UserMagic.btLevelEx := nLevel;
        '-' : UserMagic.btLevelEx := _Max(0, UserMagic.btLevelEx - nLevel);
        '+' : UserMagic.btLevelEx := _Min(9, UserMagic.btLevelEx - nLevel);
      end;
      PlayObject.SendMsg(PlayObject, RM_MAGIC_UPLVEXPEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevelEx, 0, '');
      {$IF M2Version <> 2}
      PlayObject.SysMsg(Format(sIncreaseSkillLevel, [UserMagic.MagicInfo.sMagicName, UserMagic.btLevelEx]), c_Blue, t_Hint);
      {$ifend} 
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfIncreaseSkillLevel',[g_sExceptionVer]));
  end;
end;
//功能：删除镜像地图
//格式：UnMirrorMap 镜像地图编号 人物返回地图编号 延迟时间(秒)
{
Param1 镜像地图编号 必须
Param2 人物返回地图编号 可选 空或者无效则使用原来的 返回地图编号
Param3 延迟时间 可选 空或者无效 <= 0则立即
}
procedure TNormNpc.ActionOfUnMirrorMap(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  nTime:Integer;
  sMap, sHomeMap: String;
  Envir: TEnvirnoment;
begin
  try
    sMap:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1); //镜像地图编号
    sHomeMap:= GetLineVariableText(PlayObject, QuestActionInfo.sParam2);//人物返回地图编号
    nTime := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3), 0);//延迟时间
    Envir := g_MapManager.FindMap(sMap);
    if Envir = nil then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_UNMIRRORMAP);
      Exit;
    end;
    if g_MapManager.FindMap(sHomeMap) <> nil then
      Envir.sMirrorHomeMap := sHomeMap;
    nTime := nTime * 1000;
    Envir.m_dwMirrorMapTick := nTime;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfUnMirrorMap',[g_sExceptionVer]));
  end;
end;


//功能：检测背包是否有某些物品,Hero则判断英雄的背包
//命令：CheckBagItems 列表文件名字 是否是英雄 变量名
function TNormNpc.ConditionOfCheckBagItems(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  Names : TStringList;
  nVarNameNo  : Integer;
  sCurItemName : string;
  Items : TList;
  UserItem : pTUserItem;
  I : Integer;
begin
  try
    Result := False;

    nVarNameNo := GetValNameNo(QuestConditionInfo.sParam3);

    if not FileExists(g_Config.sEnvirDir + QuestConditionInfo.sParam1) then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKBAGSIZE);
      Exit;
    end;
    Names := TStringList.Create;
    Names.LoadFromFile(g_Config.sEnvirDir + QuestConditionInfo.sParam1);
    Names.CaseSensitive := True;
    Names.Sort;//排序加快查找 By TasNat at: 2012-10-17 10:24:03
    try
      {$IF HEROVERSION = 1}
      if QuestConditionInfo.sParam2 = '1' then begin//判断英雄的背包
        Items := PlayObject.m_MyHero.m_ItemList;
      end else
      {$IFEND}
      begin
        Items := PlayObject.m_ItemList;
      end;
      if (Items <> nil) then begin
        for I := 0 to Items.Count - 1 do begin
          UserItem := Items[I];
          if UserItem <> nil then begin
            sCurItemName := UserEngine.GetStdItemName(UserItem.wIndex);
            if (sCurItemName <> '') and (Names.IndexOf(sCurItemName) >= 0) then begin
              if nVarNameNo >= 600 then begin
                case nVarNameNo of
                  600..699: PlayObject.m_sString[nVarNameNo - 600] := sCurItemName;
                  700..799: g_Config.GlobalAVal[nVarNameNo - 700] := sCurItemName;
                  1200..2099: g_Config.GlobalAVal[nVarNameNo - 1100] := sCurItemName;
                end;
              end;
              Result := True;
              Break;
            end;
          end;
        end;
      end;
    finally
      Names.Free;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckBagItems',[g_sExceptionVer]));
  end;
end;


//可以检查队伍中是否有此人
//格式：CheckIsInGroup 人物名
function TNormNpc.ConditionOfCheckIsInGroup(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  sHumName: string;
begin
  try
    Result := (PlayObject.m_GroupOwner <> nil) and (PlayObject.m_GroupOwner.m_GroupMembers <> nil);
    if not Result then Exit;

    sHumName:=GetLineVariableText(PlayObject, QuestConditionInfo.sParam1); //人物名支持变量
    if sHumName = '' then GetValValue(PlayObject, QuestConditionInfo.sParam1, sHumName);
    Result := PlayObject.m_GroupOwner.m_GroupMembers.IndexOf(sHumName) >= 0;

  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckIsInGroup',[g_sExceptionVer]));
  end;
end;

//可以检查一个坐标范围内指定怪物数量
//格式：CheckRangeMonEx 地图号 X坐标 Y坐标 怪物名字 范围 控制符(=,>,<) 数量
function TNormNpc.ConditionOfCheckRangeMonEx(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  sMapName, sMonName: string;
  I, nX, nY, nRange, nCount, nMapRangeCount: Integer;
  cMethod: Char;
  Envir: TEnvirnoment;
  MonList: TList;
  BaseObject: TBaseObject;
  nCode: byte;
begin
  nCode:= 0;
  try
    Result := False;
    sMapName:=GetLineVariableText(PlayObject, QuestConditionInfo.sParam1); //地图支持变量
    nCode:= 1;
    nX := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);
    nY := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam3),-1);
    nCode:= 2;
    sMonName := GetLineVariableText(PlayObject,QuestConditionInfo.sParam4);//怪物名字
    nRange := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam5),-1);
    cMethod := QuestConditionInfo.sParam6[1];
    nCount := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam7),-1);

    nCode:= 3;

    if nX < 0 then GetValValue(PlayObject, QuestConditionInfo.sParam2, nX);
    if nY < 0 then GetValValue(PlayObject, QuestConditionInfo.sParam3, nY);
    if nRange < 0 then GetValValue(PlayObject, QuestConditionInfo.sParam5, nRange);
    if nCount < 0 then GetValValue(PlayObject, QuestConditionInfo.sParam7, nCount);
    if sMonName = '' then GetValValue(PlayObject, QuestConditionInfo.sParam4, sMonName);
    nCode:= 4;
    Envir := g_MapManager.FindMap(sMapName);
    if (Envir = nil) or (nX < 0) or (nY < 0) or (nRange < 0) or (nCount < 0) then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKRANGEMONEx);
      Exit;
    end;
    nCode:= 5;
    MonList := TList.Create;
    try
      nCode:= 6;
      nMapRangeCount := Envir.GetRangeBaseObject(nX, nY, nRange, True, MonList);
      nCode:= 7;
      for I := MonList.Count - 1 downto 0 do begin
        if MonList.Count <= 0 then Break;
        try
          BaseObject := TBaseObject(MonList.Items[I]);
          if BaseObject <> nil then begin
            if (BaseObject.m_btRaceServer < RC_ANIMAL) or
               (BaseObject.m_btRaceServer = RC_ARCHERGUARD) or
               (BaseObject.m_Master <> nil) or
               (BaseObject.m_btRaceServer = RC_NPC) or
               (BaseObject.m_btRaceServer = RC_PEACENPC) or
               (CompareText(BaseObject.m_sCharName, sMonName) = 0)
               then
              Dec(nMapRangeCount);
              //MonList.Delete(I);
          end;
        except
        end;
      end;
      nCode:= 8;
      if nMapRangeCount < 0 then nMapRangeCount:= 0;
      case cMethod of
        '=': if nMapRangeCount = nCount then Result := True;
        '>': if nMapRangeCount > nCount then Result := True;
        '<': if nMapRangeCount < nCount then Result := True;
      else if nMapRangeCount >= nCount then Result := True;
      end;
    finally
      MonList.Free;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckRangeMonEx Code:%d',[g_sExceptionVer, nCode]));
  end;
end;
//-------------------Add End-----------------------------
//功能：增加镜像地图
//格式：MirrorMap 原地图编号 镜像地图编号 镜像地图名 有效时长(秒) 人物返回地图编号
{A，原地图编号，在地图配置文件中存在的地图！
B，新地图编号，临时使用的地图编号，就和镜像地图功能一样！
C，新地图名，这里指客户端显示的名字
D，该地图存在的有效时长(秒)
E，人物退出时返回的地图编号}
procedure TNormNpc.ActionOfMirrorMap(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  nTime:Integer;
  sMap, sMirrorMap, sMirrorName, sHomeMap: String;
  Envir: TEnvirnoment;
begin
  try
    sMap:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1); //原地图编号
    sMirrorMap:= GetLineVariableText(PlayObject, QuestActionInfo.sParam2);//镜像地图编号
    sMirrorName:= GetLineVariableText(PlayObject, QuestActionInfo.sParam3);//镜像地图名
    nTime := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam4), 0);//有效时长
    sHomeMap:= GetLineVariableText(PlayObject, QuestActionInfo.sParam5);//人物返回地图编号
    if (sMap = '') or (sMirrorMap = '') or (sMirrorName = '') or (nTime = 0) or (sHomeMap = '') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_MIRRORMAP);
      Exit;
    end;
    if g_MapManager.FindMap(sMirrorMap) <> nil then Exit;//镜像地图存在则退出
    if g_MapManager.FindMap(sHomeMap) = nil then begin
      ScriptActionError(PlayObject, '人物返回地图不存在', QuestActionInfo, sSC_MIRRORMAP);
      Exit;
    end;    
    Envir:= g_MapManager.FindMap(sMap);
    if Envir = nil then begin
      ScriptActionError(PlayObject, '原地图编号不存在', QuestActionInfo, sSC_MIRRORMAP);
      Exit;
    end;
    g_MapManager.AddMapInfoEx(sMirrorMap, sMirrorName, sHomeMap, nTime, Envir);
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfMirrorMap',[g_sExceptionVer]));
  end;
end;
//功能:初始化沙城配置
//格式：ReLoadCastle
procedure TNormNpc.ActionOfReLoadCastle(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
begin
  try
    g_CastleManager.ReLoadCastle;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfReLoadCastle',[g_sExceptionVer]));
  end;
end;

//清除人物非本职业的所有技能
//格式：DELNOJOBSKILL    (加参数HERO,即是删除英雄技能,空则是人物技能)
procedure TNormNpc.ActionOfDelNoJobSkill(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I: Integer;
  UserMagic: pTUserMagic;
begin
try
  if CompareText(QuestActionInfo.sParam1, 'HERO') = 0 then begin
    {$IF HEROVERSION = 1}
    if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then begin //20080519
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_DELNOJOBSKILL);
      Exit;
    end;
    if PlayObject.m_MyHero <> nil then begin
      for I := PlayObject.m_MyHero.m_MagicList.Count - 1 downto 0 do begin
        if PlayObject.m_MyHero.m_MagicList.Count <= 0 then Break;
        UserMagic := PlayObject.m_MyHero.m_MagicList.Items[I];
        if UserMagic.MagicInfo.btJob <> PlayObject.m_MyHero.m_btJob then begin
          PlayObject.m_MyHero.m_MagicList.Delete(I);
          THeroObject(PlayObject.m_MyHero).SendDelMagic(UserMagic);
          //防止释放内存后的非法访问 By TasNat at: 2012-03-11
          //PlayObject.m_MyHero.m_MagicOfDelList.Add(UserMagic);
          Dispose(UserMagic);
        end;
      end;//for
      THeroObject(PlayObject.m_MyHero).RecalcAbilitys();//20080430
      PlayObject.m_MyHero.CompareSuitItem(False);//200080729 套装
    end;
    {$IFEND}
  end else begin
    for I := PlayObject.m_MagicList.Count - 1 downto 0 do begin
      if PlayObject.m_MagicList.Count <= 0 then Break;
      UserMagic := PlayObject.m_MagicList.Items[I];
      if UserMagic.MagicInfo.btJob <> PlayObject.m_btJob then begin
        PlayObject.SendDelMagic(UserMagic);
        //防止释放内存后的非法访问 By TasNat at: 2012-03-11
        //PlayObject.m_MagicOfDelList.Add(UserMagic);
        Dispose(UserMagic);
        PlayObject.m_MagicList.Delete(I);
      end;
    end;//for
    PlayObject.RecalcAbilitys();//更新属性 By TasNat at: 2012-03-15 11:03:08
    PlayObject.CompareSuitItem(False);//200080729 套装
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfDelNoJobSkill',[g_sExceptionVer]));
end;
end;
//删除技能 20080223
//格式：DELSKILL 技能名称 HERO  (加参数HERO,即是删除英雄技能)
procedure TNormNpc.ActionOfDelSkill(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I: Integer;
  sMagicName: string;
  Magic: pTMagic;
  UserMagic: pTUserMagic;
begin
  try
    sMagicName := GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//20090708 支持变量
    if CompareText(QuestActionInfo.sParam2, 'HERO') = 0 then begin
      {$IF HEROVERSION = 1}
      if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then begin //20080519
        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_DELSKILL);
        Exit;
      end;
      Magic := UserEngine.FindHeroMagic(sMagicName);
      if Magic = nil then begin
        //ScriptActionError(PlayObject, '', QuestActionInfo, sSC_DELSKILL);//20100704 注释
        Exit;
      end;
      if PlayObject.m_MyHero <> nil then begin
        if Magic.wMagicId = SKILL_75 then begin
          PlayObject.m_MyHero.m_boProtectionDefence:= False; //是否学过护体神盾
          Exit;
        end;
        for I := PlayObject.m_MyHero.m_MagicList.Count - 1 downto 0 do begin
          if PlayObject.m_MyHero.m_MagicList.Count <= 0 then Break;
          UserMagic := PlayObject.m_MyHero.m_MagicList.Items[I];
          if (UserMagic.MagicInfo = Magic) or ((UserMagic.MagicInfo.sMagicName = sMagicName) and (UserMagic.btLevel = 4)) then begin//20100412 名字一样也可删除
            PlayObject.m_MyHero.m_MagicList.Delete(I);
            THeroObject(PlayObject.m_MyHero).SendDelMagic(UserMagic);
            //防止释放内存后的非法访问 By TasNat at: 2012-03-11
            //PlayObject.m_MyHero.m_MagicOfDelList.Add(UserMagic);
            Dispose(UserMagic);
            Break;
          end;
        end;//for
        THeroObject(PlayObject.m_MyHero).RecalcAbilitys();//20081213
        PlayObject.m_MyHero.CompareSuitItem(False);//200080729 套装
      end;
      {$IFEND}
    end else begin
      Magic := UserEngine.FindMagic(sMagicName);
      if Magic = nil then begin
        //ScriptActionError(PlayObject, '', QuestActionInfo, sSC_DELSKILL);//20100704 注释
        Exit;
      end;
      if Magic.wMagicId = SKILL_75 then begin
        PlayObject.m_boProtectionDefence:= False; //是否学过护体神盾
        Exit;
      end;
      for I := PlayObject.m_MagicList.Count - 1 downto 0 do begin
        if PlayObject.m_MagicList.Count <= 0 then Break;
        UserMagic := PlayObject.m_MagicList.Items[I];
        if (UserMagic.MagicInfo = Magic) or ((UserMagic.MagicInfo.sMagicName = sMagicName)
          and (UserMagic.btLevel = 4)) then begin//20100412 名字一样也可删除

          PlayObject.m_MagicList.Delete(I);
          PlayObject.SendDelMagic(UserMagic);
          {$IF M2Version <> 2}
          if Magic.wMagicId = SKILL_100 then PlayObject.m_nProficiency:= 0;//神秘解读
          if (Magic.wMagicId = SKILL_105) or (Magic.wMagicId = SKILL_106) then begin
            PlayObject.m_sHeartName:='';//心法名称
            PlayObject.m_nHeartType:= 0;//心法类型
          end;
          {$IFEND}
          //防止释放内存后的非法访问 By TasNat at: 2012-03-11 
          //PlayObject.m_MagicOfDelList.Add(UserMagic);
          Dispose(UserMagic);
          Break;
        end;
      end;//for
      PlayObject.RecalcAbilitys();
      PlayObject.CompareSuitItem(False);//200080729 套装
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfDelSkill',[g_sExceptionVer]));
  end;
end;
//调整游戏币(元宝)
procedure TNormNpc.ActionOfGameGold(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nGameGold: Integer;
  nOldGameGold: Integer;
  cMethod: Char;
begin
  try
    nOldGameGold := PlayObject.m_nGameGold;
    nGameGold:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);//20080430

    if (nGameGold < 0) and (not GetValValue(PlayObject, QuestActionInfo.sParam2, nGameGold)) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_GAMEGOLD);
      Exit;
    end;

    cMethod := QuestActionInfo.sParam1[1];
    case cMethod of
      '=': begin
          if (nGameGold >= 0) then begin
            PlayObject.m_nGameGold := nGameGold;
          end;
        end;
      '-': begin
          PlayObject.m_nGameGold := _MAX(0, PlayObject.m_nGameGold - nGameGold);//20080809 修改
        end;
      '+': begin
          if PlayObject.m_nGameGold >= nGameGold then begin//20090408 增加，防止越界
            if (High(PlayObject.m_nGameGold) - PlayObject.m_nGameGold) < nGameGold then begin
              nGameGold := High(PlayObject.m_nGameGold) - PlayObject.m_nGameGold;
            end;
          end else begin
            if (High(PlayObject.m_nGameGold) - nGameGold) < PlayObject.m_nGameGold then begin
              nGameGold := High(PlayObject.m_nGameGold) - nGameGold;
            end;
          end;
          PlayObject.m_nGameGold :=_MIN(High(PlayObject.m_nGameGold), PlayObject.m_nGameGold + nGameGold);//20080809 修改
        end;
    end;
    //'%d'#9'%s'#9'%d'#9'%d'#9'%s'#9'%s'#9'%d'#9'%s'#9'%s'
    if g_boGameLogGameGold then begin
      AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, PlayObject.m_sMapName,
          PlayObject.m_nCurrX, PlayObject.m_nCurrY, PlayObject.m_sCharName,
          g_Config.sGameGoldName, PlayObject.m_nGameGold,
          cMethod+'('+IntToStr(nGameGold)+')'+IntToStr(nOldGameGold), m_sCharName]));
    end;
    if nOldGameGold <> PlayObject.m_nGameGold then PlayObject.GameGoldChanged;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfGameGold',[g_sExceptionVer]));
  end;
end;
//调整金刚石动作 20071226
procedure TNormNpc.ActionOfGameDiaMond(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nGameDiaMond: Integer;
  nOldGameDiaMond: Integer;
  cMethod: Char;
begin
try
  nOldGameDiaMond := PlayObject.m_nGameDiaMond;
  //nGameDiaMond := Str_ToInt(QuestActionInfo.sParam2, -1); //20080315
  nGameDiaMond:=Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2),-1);//20080430
  
  if (nGameDiaMond < 0) and (not GetValValue(PlayObject, QuestActionInfo.sParam2, nGameDiaMond)) then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_GAMEDIAMOND);
    Exit;
  end;

  cMethod := QuestActionInfo.sParam1[1];
  case cMethod of
    '=': begin
        if (nGameDiaMond >= 0) then begin
          PlayObject.m_nGameDiaMond := nGameDiaMond;
        end;
      end;
    '-': begin
        //nGameDiaMond := _MAX(0, PlayObject.m_nGameDiaMond - nGameDiaMond);
        //PlayObject.m_nGameDiaMond := nGameDiaMond;
        PlayObject.m_nGameDiaMond := _MAX(0, PlayObject.m_nGameDiaMond - nGameDiaMond);//20080809 修改
      end;
    '+': begin
        //nGameDiaMond := _MAX(0, PlayObject.m_nGameDiaMond + nGameDiaMond);
        //PlayObject.m_nGameDiaMond := nGameDiaMond;
        PlayObject.m_nGameDiaMond := _MIN(High(PlayObject.m_nGameDiaMond), PlayObject.m_nGameDiaMond + nGameDiaMond);//20080809 修改
      end;
  end;
  //'%d'#9'%s'#9'%d'#9'%d'#9'%s'#9'%s'#9'%d'#9'%s'#9'%s'
  if g_boGameLogGameDiaMond then begin
    AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GameDiaMond,
      PlayObject.m_sMapName,
        PlayObject.m_nCurrX,
        PlayObject.m_nCurrY,
        PlayObject.m_sCharName,
        g_Config.sGameDiaMond,
        PlayObject.m_nGameDiaMond,
        cMethod+'('+inttostr(nGameDiaMond)+')',
        m_sCharName]));
  end;
  if nOldGameDiaMond <> PlayObject.m_nGameDiaMond then PlayObject.GameGoldChanged;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfGameDiaMond',[g_sExceptionVer]));
end;
end;
//调整灵符动作  20071226
procedure TNormNpc.ActionOfGameGird(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nGameGird: Integer;
  nOldGameGird: Integer;
  cMethod: Char;
begin
  try
    nOldGameGird := PlayObject.m_nGameGird;
    nGameGird:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2),-1);//20080430

    if (nGameGird < 0) and (not GetValValue(PlayObject, QuestActionInfo.sParam2, nGameGird)) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_GameGird);
      Exit;
    end;

    cMethod := QuestActionInfo.sParam1[1];
    case cMethod of
      '=': begin
          if (nGameGird >= 0) then begin
            PlayObject.m_nGameGird := nGameGird;
          end;
        end;
      '-': begin
          PlayObject.m_nGameGird := _MAX(0, PlayObject.m_nGameGird - nGameGird);//20080809 修改
          PlayObject.m_UseGameGird := nGameGird;//20090108 灵符使用计数
          if g_FunctionNPC <> nil then begin//灵符使用触发 20090108
            g_FunctionNPC.GotoLable(PlayObject, '@USEGAMEGIRD', False, False);
          end;
        end;
      '+': begin
          PlayObject.m_nGameGird :=_MIN(High(PlayObject.m_nGameGird), PlayObject.m_nGameGird + nGameGird);//20080809 修改
        end;
    end;
    //'%d'#9'%s'#9'%d'#9'%d'#9'%s'#9'%s'#9'%d'#9'%s'#9'%s'
    if g_boGameLogGameGird then begin
      AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GameGird,
        PlayObject.m_sMapName,
          PlayObject.m_nCurrX,
          PlayObject.m_nCurrY,
          PlayObject.m_sCharName,
          g_Config.sGameGird,
          PlayObject.m_nGameGird,
          cMethod+'('+inttostr(nGameGird)+')',
          m_sCharName]));
    end;
    if nOldGameGird <> PlayObject.m_nGameGird then PlayObject.GameGoldChanged;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfGameGird',[g_sExceptionVer]));
  end;
end;
//---------------------------------------------------------------------------
//调整英雄技能升级点数 20080512
//格式:ChangeHeroTranPoint 技能名 操作符(+ - =) 数值
procedure TNormNpc.ActionOfCHANGEHEROTRANPOINT(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nTranPoint, nOldTranPoint: Integer;
  sMagicName: String;
  cMethod: Char;
  UserMagic: pTUserMagic;
begin
  {$IF HEROVERSION = 1}
  try
    if PlayObject.m_MyHero = nil then Exit;
    sMagicName:= GetLineVariableText(PlayObject,QuestActionInfo.sParam1);
    nTranPoint:=Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3),-1);
    if (nTranPoint < 0) and (not GetValValue(PlayObject, QuestActionInfo.sParam3, nTranPoint)) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEHEROTRANPOINT);
      Exit;
    end;
    cMethod := QuestActionInfo.sParam2[1];
    if (sMagicName = '') and (cMethod = '') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEHEROTRANPOINT);
      Exit;
    end;
    UserMagic:= TPlayObject(PlayObject.m_MyHero).GetMagicInfo(sMagicName);
    if UserMagic <> nil then begin
      nOldTranPoint:= UserMagic.nTranPoint;
      case cMethod of
        '=': begin
          if (nTranPoint >= 0) then UserMagic.nTranPoint := nTranPoint;
         end;
        '-': begin
           nTranPoint := _MAX(0, UserMagic.nTranPoint - nTranPoint);
           if nTranPoint < 0 then nTranPoint := 0;
           UserMagic.nTranPoint := nTranPoint;
         end;
        '+': begin
            {$IF M2Version = 1}
            case UserMagic.wMagIdx of//连击技能 20110122
              SKILL_76, SKILL_77, SKILL_78: begin//三绝杀 双龙破 虎啸诀
                if (UserMagic.btLevel < 6) and (UserMagic.btLevel < THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[0].nPulseLevel) then begin
                  nTranPoint := _MAX(0, UserMagic.nTranPoint + nTranPoint);
                  UserMagic.nTranPoint := nTranPoint;
                end;
              end;
              SKILL_79, SKILL_80, SKILL_81: begin//追心刺 凤舞祭 八卦掌
                if (UserMagic.btLevel < 6) and (UserMagic.btLevel < THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[1].nPulseLevel) then begin
                  nTranPoint := _MAX(0, UserMagic.nTranPoint + nTranPoint);
                  UserMagic.nTranPoint := nTranPoint;
                end;
              end;
              SKILL_82, SKILL_83, SKILL_84: begin//断岳斩 惊雷爆 三焰咒
                if (UserMagic.btLevel < 6) and (UserMagic.btLevel < THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[2].nPulseLevel) then begin
                  nTranPoint := _MAX(0, UserMagic.nTranPoint + nTranPoint);
                  UserMagic.nTranPoint := nTranPoint;
                end;
              end;
              SKILL_85, SKILL_86, SKILL_87: begin//横扫千军 冰天雪地 万剑归宗
                if (UserMagic.btLevel < 6) and (UserMagic.btLevel < THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[3].nPulseLevel) then begin
                  nTranPoint := _MAX(0, UserMagic.nTranPoint + nTranPoint);
                  UserMagic.nTranPoint := nTranPoint;
                end;
              end;
              SKILL_99: begin//强身术
                if (UserMagic.btLevel < 99) then begin
                  nTranPoint := _MAX(0, UserMagic.nTranPoint + nTranPoint);
                  UserMagic.nTranPoint := nTranPoint;
                end;
              end;
              else begin
              {$IFEND}
                if (UserMagic.btLevel < 3) and (UserMagic.MagicInfo.TrainLevel[UserMagic.btLevel] <= PlayObject.m_MyHero.m_Abil.Level) then begin
                  nTranPoint := _MAX(0, UserMagic.nTranPoint + nTranPoint);
                  UserMagic.nTranPoint := nTranPoint;
                end;
              {$IF M2Version = 1}
              end;
            end;
            {$IFEND}
         end;
      end;//case cMethod of
      if nOldTranPoint <> UserMagic.nTranPoint then begin
        if not THeroObject(PlayObject.m_MyHero).CheckMagicLevelup(UserMagic) then begin
          THeroObject(PlayObject.m_MyHero).SendDelayMsg(PlayObject.m_MyHero, RM_HEROMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 500);
        end;
      end;
    end;//if UserMagic <> nil then begin
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfCHANGEHEROTRANPOINT',[g_sExceptionVer]));
  end;
  {$IFEND}
end;
//调整技能升级点数
//格式:ChangeTranPoint 技能名 操作符(+ - =) 数值
procedure TNormNpc.ActionOfCHANGETRANPOINT(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nTranPoint, nOldTranPoint: Integer;
  sMagicName: String;
  nMaxExp: LongWord;
  cMethod: Char;
  UserMagic: pTUserMagic;
begin
  try
    sMagicName:= GetLineVariableText(PlayObject,QuestActionInfo.sParam1);
    nTranPoint:=Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3),-1);
    if (nTranPoint < 0) and (not GetValValue(PlayObject, QuestActionInfo.sParam3, nTranPoint)) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGETRANPOINT);
      Exit;
    end;
    cMethod := QuestActionInfo.sParam2[1];
    if (sMagicName = '') and (cMethod = '') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGETRANPOINT);
      Exit;
    end;
    UserMagic:= PlayObject.GetMagicInfo(sMagicName);
    if UserMagic <> nil then begin
      nOldTranPoint:= UserMagic.nTranPoint;
      case cMethod of
        '=': begin
          if (nTranPoint >= 0) then UserMagic.nTranPoint := nTranPoint;
         end;
        '-': begin
           nTranPoint := _MAX(0, UserMagic.nTranPoint - nTranPoint);
           if nTranPoint < 0 then nTranPoint := 0;
           UserMagic.nTranPoint := nTranPoint;
         end;
        '+': begin
            case UserMagic.wMagIdx of//连击技能 20110122
              {$IF M2Version <> 2}
              SKILL_105: begin//龙卫心法
                if (UserMagic.btLevel < 100) then begin
                  nTranPoint := _MAX(0, UserMagic.nTranPoint + nTranPoint);
                  UserMagic.nTranPoint := nTranPoint;
                end;
              end;
              {$IFEND}
              {$IF M2Version = 1}
              SKILL_76, SKILL_77, SKILL_78: begin//三绝杀 双龙破 虎啸诀
                if (UserMagic.btLevel < 6) and (UserMagic.btLevel < PlayObject.m_wHumanPulseArr[0].nPulseLevel) then begin
                  nTranPoint := _MAX(0, UserMagic.nTranPoint + nTranPoint);
                  UserMagic.nTranPoint := nTranPoint;
                end;
              end;
              SKILL_79, SKILL_80, SKILL_81: begin//追心刺 凤舞祭 八卦掌
                if (UserMagic.btLevel < 6) and (UserMagic.btLevel < PlayObject.m_wHumanPulseArr[1].nPulseLevel) then begin
                  nTranPoint := _MAX(0, UserMagic.nTranPoint + nTranPoint);
                  UserMagic.nTranPoint := nTranPoint;
                end;
              end;
              SKILL_82, SKILL_83, SKILL_84: begin//断岳斩 惊雷爆 三焰咒
                if (UserMagic.btLevel < 6) and (UserMagic.btLevel < PlayObject.m_wHumanPulseArr[2].nPulseLevel) then begin
                  nTranPoint := _MAX(0, UserMagic.nTranPoint + nTranPoint);
                  UserMagic.nTranPoint := nTranPoint;
                end;
              end;
              SKILL_85, SKILL_86, SKILL_87: begin//横扫千军 冰天雪地 万剑归宗
                if (UserMagic.btLevel < 6) and (UserMagic.btLevel < PlayObject.m_wHumanPulseArr[3].nPulseLevel) then begin
                  nTranPoint := _MAX(0, UserMagic.nTranPoint + nTranPoint);
                  UserMagic.nTranPoint := nTranPoint;
                end;
              end;
              {$IFEND}
              SKILL_100: begin
                if (UserMagic.btLevel < 15) then begin//20110209 修改
                  nTranPoint := _MAX(0, UserMagic.nTranPoint + nTranPoint);
                  UserMagic.nTranPoint := nTranPoint;
                end;
              end;
              else begin
                if (UserMagic.btLevel < 3) and (UserMagic.MagicInfo.TrainLevel[UserMagic.btLevel] <= PlayObject.m_Abil.Level) then begin
                  nTranPoint := _MAX(0, UserMagic.nTranPoint + nTranPoint);
                  UserMagic.nTranPoint := nTranPoint;
                end;
              end;
            end;
         end;
      end;//case cMethod of
      if nOldTranPoint <> UserMagic.nTranPoint then begin
        if not PlayObject.CheckMagicLevelup(UserMagic) then begin
          case UserMagic.wMagIdx of
            SKILL_100: begin
              nMaxExp := 500 + (UserMagic.btLevel * 700);
              PlayObject.SendDelayMsg(PlayObject, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nMaxExp, UserMagic.btLevel, UserMagic.nTranPoint, '', 500);
            end;
            {$IF M2Version <> 2}
            SKILL_105: begin
              nMaxExp := UserMagic.MagicInfo.MaxTrain[0] + UserMagic.btLevel * (UserMagic.MagicInfo.MaxTrain[2]-UserMagic.MagicInfo.MaxTrain[1]);
              PlayObject.SendDelayMsg(PlayObject, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nMaxExp, UserMagic.btLevel, UserMagic.nTranPoint, '', 500);
            end;
            {$IFEND}
            else PlayObject.SendDelayMsg(PlayObject, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 500);
          end;//case
        end;
      end;
    end;//if UserMagic <> nil then begin
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfCHANGETRANPOINT',[g_sExceptionVer]));
  end;
end;
//---------------------------------------------------------------------------
//----------------------------酒馆系统---------------------------------------
//寄放英雄  20080513
//英雄必须要在线,成功后,英雄退出,再召唤英雄,没有提示
procedure TNormNpc.ActionOfSAVEHERO(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
begin
  {$IF HEROVERSION = 1}
  try
    if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then begin //20080519 //玩家没有英雄
      if PlayObject.m_boPlayDrink then
         GotoLable(PlayObject, '~PlayDrink_Already_NotHero', False, False)
      else GotoLable(PlayObject, '~PlayDrink_NotHero', False, False);
      Exit;
    end;
    if PlayObject.m_MyHero <> nil then begin //英雄在线,才能进寄放
      if PlayObject.n_HeroSave = 2 then begin
        GotoLable(PlayObject, '@NoSaveHero'+inttostr(PlayObject.n_myHeroTpye), False, False);
        Exit;//评定过主副将英雄则不能再寄存英雄
      end;
      PlayObject.m_sHeroCharName:='';//将主人的英雄名清空,达到不能召唤英雄的目的
      PlayObject.n_HeroSave := 1;//寄放英雄标识
      PlayObject.ClientHeroLogOut(1); //英雄退出,没有提示
      GotoLable(PlayObject, '~PlayDrink_HeroOk', False, False);
    end else begin //英雄不在线
      if PlayObject.m_boPlayDrink then
        GotoLable(PlayObject, '~PlayDrink_Already_HeroBegin', False, False)
      else GotoLable(PlayObject, '~PlayDrink_HeroBegin', False, False);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfSAVEHERO',[g_sExceptionVer]));
  end;
  {$IFEND}
end;
//取回英雄 20080513
//有两个英雄时,需全寄放后,才能取回一个英雄
procedure TNormNpc.ActionOfGETHERO(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
begin
{$IF HEROVERSION = 1}
  try
    if PlayObject.n_HeroSave <> 2 then begin//没评定过英雄
      if (PlayObject.m_sHeroCharName = '') and (PlayObject.m_boHasHero or PlayObject.m_boHasHeroTwo) then begin//身上没有英雄才能取回
         //发消息,显示取回英雄的窗口,选择后,改变主人变量,
         FrontEngine.AddToLoadHeroRcdList(PlayObject.m_sCharName, '', PlayObject, 3, False, 255);
      end else begin
        if g_FunctionNPC <> nil then
           g_FunctionNPC.GotoLable(PlayObject, '@GetHeroBak', False, False);
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfGETHERO',[g_sExceptionVer]));
  end;
{$IFEND}  
end;
//功能：弹出评定主副将窗口
//格式：AssessmentHero
procedure TNormNpc.ActionOfAssessmentHero(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
begin
{$IF HEROVERSION = 1}
  try
    if PlayObject.m_boHasHero and PlayObject.m_boHasHeroTwo and (PlayObject.m_sHeroCharName = '')
       and (PlayObject.m_sDeputyHeroName = '') and (PlayObject.n_HeroSave = 1) then begin
       FrontEngine.AddToLoadHeroRcdList(PlayObject.m_sCharName, '', PlayObject, 4, False, 255);
    end else PlayObject.SendMsg(PlayObject, RM_ASSESSMENTHEROINFO, 0, 0, 0, 0, '');//显示空的窗口
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfAssessmentHero',[g_sExceptionVer]));
  end;
{$IFEND}
end;

//关闭斗酒,请酒窗口 20080514
procedure TNormNpc.ActionOfCLOSEDRINK(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
begin
try
  PlayObject.SendMsg(Self, RM_CLOSEDRINK, 0, 0, 0, 0, '');
  PlayObject.n_DrinkValue[0]:=0;//喝酒的醉酒值 0-NPC 1-玩家 20080517
  PlayObject.n_DrinkValue[1]:=0;
  PlayObject.n_DrinkCount:= 0;//喝酒的次数(斗酒一次最高6次) 20080517
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfCLOSEDRINK',[g_sExceptionVer]));
end;
end;

//斗酒窗口说话信息 20080514
//格式:PLAYDRINKMSG 类型 说话信息
//(设置请酒显示内容) PLAYDRINKMSG 消息位置(1[上面],2[下面]) 消息内容(跟#say一样)
procedure TNormNpc.ActionOfPLAYDRINKMSG(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  nDisplay: Byte;//消息显示的位置
  sMsg: String;//消息内容
begin
try
  nDisplay := Str_ToInt(QuestActionInfo.sParam1, -1);
  sMsg := GetLineVariableText(PlayObject, QuestActionInfo.sParam2);
  if (not nDisplay in [1,2]) or ( sMsg='') then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_PLAYDRINKMSG);
    Exit;
  end;
  PlayObject.SendMsg(Self, RM_PLAYDRINKSAY, 0, 0, 0, nDisplay, sMsg);
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfPLAYDRINKMSG',[g_sExceptionVer]));
end;
end;

//打开酒界面 20080514
//格式:OPENPLAYDRINK 人物头像(0,1,2) 人物名字(0:翔天,1:辰星,2:影月)----(打开请酒界面)
//格式:OPENPLAYDRINK 人物头像(0,1,2) 人物名字(0:翔天,1:辰星,2:影月)  DRINK----(打开斗酒界面)
procedure TNormNpc.ActionOfOPENPLAYDRINK(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  nIcon: Integer;//人物头像
  sName: String;//人物名称
begin
try
  nIcon := Str_ToInt(QuestActionInfo.sParam1, -1);
  sName := GetLineVariableText(PlayObject, QuestActionInfo.sParam2);
  if nIcon < 0 then GetValValue(PlayObject, QuestActionInfo.sParam1, nIcon); //增加变量支持

  if (nIcon < 0) or (nIcon > 3) or ( sName='') then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_OPENPLAYDRINK);
    Exit;
  end;
  if CompareText(QuestActionInfo.sParam3, 'DRINK') = 0 then begin//打开斗酒界面
     PlayObject.SendMsg(Self, RM_OPENPLAYDRINK, 0, 0, 1, nIcon, sName);
     PlayObject.n_DrinkValue[0]:=0;//喝酒的醉酒值 0-NPC 1-玩家 20080517
     PlayObject.n_DrinkValue[1]:=0;
     PlayObject.n_DrinkCount:= 0;//喝酒的次数(斗酒一次最高6次) 20080517
  end else begin//打开请酒界面
    if PlayObject.m_boPlayDrink then begin//已请过酒的直接操作
       GotoLable(PlayObject, '@SaveHero', False, False);
    end else begin//没请过酒的,打开请酒界面
       PlayObject.SendMsg(Self, RM_OPENPLAYDRINK, 0, 0, 2, nIcon, sName);
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfOPENPLAYDRINK',[g_sExceptionVer]));
end;
end;
//---------------------------------------------------------------------------
//功能：调整人物属性 20080609
//格式：CHANGEHUMABILITY 属性(0-14) 操作符(=/-/+) 属性值(1-65535) 时间(秒) HERO
//注意:调整后的属性效果只在人物在线时有效
procedure TNormNpc.ActionOfCHANGEHUMABILITY(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  nValue: Byte;
  cMethod: Char;
  nTime: Integer;
  nValeu1: Word;
begin
  try
    nValue := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam1),-1);
    nValeu1 := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3),0);
    nTime := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam4),0);
    if (nValue > 15) or (nValue < 0) or (nTime = 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEHUMABILITY);
      Exit;
    end;
    cMethod := QuestActionInfo.sParam2[1];
    if (CompareText(QuestActionInfo.sParam5, 'HERO') = 0) then begin//支持英雄 20101212
      {$IF HEROVERSION = 1}
      if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then Exit;
      if PlayObject.m_MyHero <> nil then begin
        case cMethod of
          '=': begin
              case nValue of
                14: begin//不死状态
                  PlayObject.m_MyHero.m_wStatusArrValue[19]:= nValeu1;
                  PlayObject.m_MyHero.m_dwStatusArrTimeOutTick[19]:=GetTickCount + nTime * 1000;
                end;
                9:;
                else begin
                  PlayObject.m_MyHero.m_wStatusArrValue[nValue]:= nValeu1;
                  PlayObject.m_MyHero.m_dwStatusArrTimeOutTick[nValue]:=GetTickCount + nTime * 1000;
                end;
              end;
            end;
          '-': begin
              case nValue of
                14: begin//不死状态
                  PlayObject.m_MyHero.m_wStatusArrValue[19] := _MAX(0,  PlayObject.m_MyHero.m_wStatusArrValue[19] - nValeu1);
                  PlayObject.m_MyHero.m_dwStatusArrTimeOutTick[19]:=GetTickCount + nTime * 1000;
                end;
                9:;
                else begin
                  PlayObject.m_MyHero.m_wStatusArrValue[nValue] := _MAX(0,  PlayObject.m_MyHero.m_wStatusArrValue[nValue] - nValeu1);
                  PlayObject.m_MyHero.m_dwStatusArrTimeOutTick[nValue]:=GetTickCount + nTime * 1000;
                end;
              end;
            end;
          '+': begin
              case nValue of
                14: begin//不死状态
                  PlayObject.m_MyHero.m_wStatusArrValue[19]:= PlayObject.m_MyHero.m_wStatusArrValue[19] + nValeu1;
                  PlayObject.m_MyHero.m_dwStatusArrTimeOutTick[19]:=GetTickCount + nTime * 1000;
                  PlayObject.SysMsg(Format('(英雄) 进入不死状态%d秒',[nTime]), c_Green, t_Hint);
                end;
                9:;
                else begin
                  PlayObject.m_MyHero.m_wStatusArrValue[nValue]:= PlayObject.m_MyHero.m_wStatusArrValue[nValue] + nValeu1;
                  PlayObject.m_MyHero.m_dwStatusArrTimeOutTick[nValue]:=GetTickCount + nTime * 1000;
                end;
              end;
            end;
        end;
        THeroObject(PlayObject.m_MyHero).RecalcAbilitys();
        PlayObject.m_MyHero.CompareSuitItem(False);
        THeroObject(PlayObject.m_MyHero).SendMsg(PlayObject.m_MyHero, RM_HEROABILITY, 0, 0, 0, 0, ''); //发送英雄属性
      end;
      {$IFEND}
    end else begin
      case cMethod of
        '=': begin
            case nValue of
              9: begin
                {$IF M2Version <> 2}
                PlayObject.m_nSetupMaxLeveltoHPMP:= nValeu1;
                {$IFEND}
              end;
              14: begin
                PlayObject.m_wStatusArrValue[19]:= nValeu1;
                PlayObject.m_dwStatusArrTimeOutTick[19]:=GetTickCount + nTime * 1000;
              end;
              else begin
                PlayObject.m_wStatusArrValue[nValue]:= nValeu1;
                PlayObject.m_dwStatusArrTimeOutTick[nValue]:=GetTickCount + nTime * 1000;
              end;
            end;
          end;
        '-': begin
            case nValue of
              9: begin
                {$IF M2Version <> 2}
                PlayObject.m_nSetupMaxLeveltoHPMP:= _MAX(0,  PlayObject.m_nSetupMaxLeveltoHPMP - nValeu1);
                {$IFEND}
              end;
              14: begin
                PlayObject.m_wStatusArrValue[19] := _MAX(0,  PlayObject.m_wStatusArrValue[19] - nValeu1);
                PlayObject.m_dwStatusArrTimeOutTick[19]:=GetTickCount + nTime * 1000;
              end;
              else begin
                PlayObject.m_wStatusArrValue[nValue] := _MAX(0,  PlayObject.m_wStatusArrValue[nValue] - nValeu1);
                PlayObject.m_dwStatusArrTimeOutTick[nValue]:=GetTickCount + nTime * 1000;
              end;
            end;
          end;
        '+': begin
            case nValue of
              9: begin
                {$IF M2Version <> 2}
                PlayObject.m_nSetupMaxLeveltoHPMP:= PlayObject.m_nSetupMaxLeveltoHPMP + nValeu1;
                {$IFEND}
              end;
              14: begin
                PlayObject.m_wStatusArrValue[19]:= PlayObject.m_wStatusArrValue[19] + nValeu1;
                PlayObject.m_dwStatusArrTimeOutTick[19]:=GetTickCount + nTime * 1000;
                PlayObject.SysMsg(Format('进入不死状态%d秒',[nTime]), c_Green, t_Hint);
              end;
              else begin
                PlayObject.m_wStatusArrValue[nValue]:= PlayObject.m_wStatusArrValue[nValue] + nValeu1;
                PlayObject.m_dwStatusArrTimeOutTick[nValue]:=GetTickCount + nTime * 1000;
              end;
            end;
          end;
      end;
      PlayObject.RecalcAbilitys();
      PlayObject.CompareSuitItem(False);//200080729 套装
      PlayObject.SendMsg(PlayObject, RM_ABILITY, 0, 0, 0, 0, '');
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfCHANGEHUMABILITY',[g_sExceptionVer]));
  end;
end;
//---------------------------------------------------------------------------
//调整英雄的忠诚度  20080110
procedure TNormNpc.ActionOfHeroLoyal(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  nLoyal: Integer;
  nOldLoyal: Integer;
  cMethod: Char;
begin
  {$IF HEROVERSION = 1}
  try
    if PlayObject.m_MyHero = nil then Exit;
    nOldLoyal := THeroObject(PlayObject.m_MyHero).m_nLoyal;
    nLoyal := Str_ToInt(QuestActionInfo.sParam2, -1);
    if (nLoyal < 0)and (nLoyal > 10000) and (not GetValValue(PlayObject, QuestActionInfo.sParam2, nLoyal)) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEHEROLOYAL);
      Exit;
    end;

    cMethod := QuestActionInfo.sParam1[1];
    case cMethod of
      '=': begin
          if (nLoyal >= 0) then begin
            THeroObject(PlayObject.m_MyHero).m_nLoyal := nLoyal;
          end;
        end;
      '-': begin
          nLoyal := _MAX(0, THeroObject(PlayObject.m_MyHero).m_nLoyal - nLoyal);
          if nLoyal < 0 then nLoyal := 0; //20080312
          THeroObject(PlayObject.m_MyHero).m_nLoyal := nLoyal;
        end;
      '+': begin
          nLoyal := _MAX(0, THeroObject(PlayObject.m_MyHero).m_nLoyal + nLoyal); //20080312
          if nLoyal > 10000 then nLoyal := 10000;//20080312 修正NPC加忠诚度超过最大值
          THeroObject(PlayObject.m_MyHero).m_nLoyal := nLoyal;
        end;
    end;
    if nOldLoyal <> THeroObject(PlayObject.m_MyHero).m_nLoyal then begin
      PlayObject.GameGoldChanged;
      m_DefMsg := MakeDefaultMsg(SM_HEROABILITY, THeroObject(PlayObject.m_MyHero).m_btGender, 0, THeroObject(PlayObject.m_MyHero).m_btJob, THeroObject(PlayObject.m_MyHero).m_nLoyal, 0);//20080312
      THeroObject(PlayObject.m_MyHero).SendSocket(@m_DefMsg, EncodeBuffer(@THeroObject(PlayObject.m_MyHero).m_WAbil, SizeOf(TAbility)));//20080312
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfHeroLoyal',[g_sExceptionVer]));
  end;
  {$IFEND}
end;
//调整泡点
procedure TNormNpc.ActionOfGamePoint(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nGamePoint: Integer;
  nOldGamePoint: Integer;
  cMethod: Char;
begin
try
  nOldGamePoint := PlayObject.m_nGamePoint;
  //nGamePoint := Str_ToInt(QuestActionInfo.sParam2, -1); //20080320
  nGamePoint:=Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2),-1);//20080430

  if (nGamePoint < 0) and (not GetValValue(PlayObject, QuestActionInfo.sParam2, nGamePoint)) then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_GAMEPOINT);
    Exit;
  end;
  cMethod := QuestActionInfo.sParam1[1];
  case cMethod of
    '=': begin
        if (nGamePoint >= 0) then begin
          PlayObject.m_nGamePoint := nGamePoint;
        end;
      end;
    '-': begin
        nGamePoint := _MAX(0, PlayObject.m_nGamePoint - nGamePoint);
        PlayObject.m_nGamePoint := nGamePoint;
      end;
    '+': begin
        nGamePoint := _MAX(0, PlayObject.m_nGamePoint + nGamePoint);
        PlayObject.m_nGamePoint := nGamePoint;
      end;
  end;
  //'%d'#9'%s'#9'%d'#9'%d'#9'%s'#9'%s'#9'%d'#9'%s'#9'%s'
  if g_boGameLogGamePoint then begin
    AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEPOINT,
      PlayObject.m_sMapName,
        PlayObject.m_nCurrX,
        PlayObject.m_nCurrY,
        PlayObject.m_sCharName,
        g_Config.sGamePointName,
        PlayObject.m_nGamePoint,
        cMethod+'('+inttostr(nGamePoint)+')',
        m_sCharName]));
  end;
  if nOldGamePoint <> PlayObject.m_nGamePoint then PlayObject.GameGoldChanged;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfGamePoint',[g_sExceptionVer]));
end;
end;

procedure TNormNpc.ActionOfGetMarry(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  PoseBaseObject: TBaseObject;
begin
try
  PoseBaseObject := PlayObject.GetPoseCreate();
  if (PoseBaseObject <> nil) and (PoseBaseObject.m_btRaceServer = RC_PLAYOBJECT) and (PoseBaseObject.m_btGender <> PlayObject.m_btGender) then begin
    PlayObject.m_sDearName := PoseBaseObject.m_sCharName;
    PlayObject.RefShowName;
    PoseBaseObject.RefShowName;
  end else begin
    GotoLable(PlayObject, '@MarryError', False, False);
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfGetMarry',[g_sExceptionVer]));
end;
end;

procedure TNormNpc.ActionOfGetMaster(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  PoseBaseObject: TBaseObject;
begin
try
  PoseBaseObject := PlayObject.GetPoseCreate();
  if (PoseBaseObject <> nil) and (PoseBaseObject.m_btRaceServer = RC_PLAYOBJECT) and (PoseBaseObject.m_btGender <> PlayObject.m_btGender) then begin
    PlayObject.m_sMasterName := PoseBaseObject.m_sCharName;
    PlayObject.RefShowName;
    PoseBaseObject.RefShowName;
  end else begin
    GotoLable(PlayObject, '@MasterError', False, False);
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfGetMaster',[g_sExceptionVer]));
end;
end;
//功能：利用NPC发送信息，支持自定义颜色
//格式: SENDMSG 信息类型代码 %s信息内容%d 字体颜色(0-255) 背景颜色(0-255)
{信息类型代码：
    1、发送普通红色广播信息
    2、发送普通红色广播信息，并显示NPC名称
    3、发送普通红色广播信息，并人物NPC名称
    4、在NPC头顶，显示普通说话信息
    5、发送红色信息给人物
    6、发送绿色信息给人物
    7、发送蓝色信息给人物
    8-对行会内成员发送信息
    9-对当前地图所有玩家发送信息 }
procedure TNormNpc.ActionOfLineMsg(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  sMsg, sParam2: string;
  FColor, BColor: Byte;
  boIsCustom: Boolean;
  I: Integer;
  BaseObject: TPlayObject;
begin
  try
    boIsCustom:= False;
    sParam2 := QuestActionInfo.sParam2;
    if (QuestActionInfo.sParam3 <> '') and (QuestActionInfo.sParam4 <> '') then begin//如设置了自定义颜色时
      FColor:= _MIN(255, Str_ToInt(QuestActionInfo.sParam3, 0));
      BColor:= _MIN(255, Str_ToInt(QuestActionInfo.sParam4, 0));
      boIsCustom:= True;
    end;
    GetValValue(PlayObject, QuestActionInfo.sParam2, sParam2);
    sMsg := GetLineVariableText(PlayObject, sParam2);
    sMsg := AnsiReplaceText(sMsg, '%s', PlayObject.m_sCharName);
    sMsg := AnsiReplaceText(sMsg, '%x', IntToStr(PlayObject.m_nCurrX));
    sMsg := AnsiReplaceText(sMsg, '%y', IntToStr(PlayObject.m_nCurrY));
    if PlayObject.m_PEnvir <> nil then
      sMsg := AnsiReplaceText(sMsg, '%m', PlayObject.m_PEnvir.sMapDesc)
    else sMsg := AnsiReplaceText(sMsg, '%m', '????');
    sMsg := AnsiReplaceText(sMsg, '%d', m_sCharName);
    case QuestActionInfo.nParam1 of
      0: begin
        if not boIsCustom then UserEngine.SendBroadCastMsg(sMsg, t_System)
        else UserEngine.SendBroadCastMsg1(sMsg, t_System, FColor, BColor);
      end;//0
      1: begin
        if not boIsCustom then UserEngine.SendBroadCastMsg('(*) ' + sMsg, t_System)//发送普通红色广播信息
        else UserEngine.SendBroadCastMsg1('(*) ' + sMsg, t_System, FColor, BColor);
      end;//1
      2: begin
        if not boIsCustom then UserEngine.SendBroadCastMsg('[' + m_sCharName + ']' + sMsg, t_System)//发送普通红色广播信息，并显示NPC名称
        else UserEngine.SendBroadCastMsg1('[' + m_sCharName + ']' + sMsg, t_System, FColor, BColor);
      end;//2
      3: begin
        if not boIsCustom then UserEngine.SendBroadCastMsg('[' + PlayObject.m_sCharName + ']' + sMsg, t_System)//发送普通红色广播信息，并人物NPC名称
        else UserEngine.SendBroadCastMsg1('[' + PlayObject.m_sCharName + ']' + sMsg, t_System, FColor, BColor);
      end;//3
      4: begin
        if not boIsCustom then ProcessSayMsg(sMsg)//在NPC头顶，显示普通说话信息
        else  ProcessSayMsg1(sMsg, FColor, BColor);
      end;//4
      5: begin
        if not boIsCustom then PlayObject.SysMsg(sMsg, c_Red, t_Say)//发送红色信息给人物
        else PlayObject.SysMsg1(sMsg, c_Red, t_Say, FColor, BColor);
      end;//5
      6: begin
        if not boIsCustom then PlayObject.SysMsg(sMsg, c_Green, t_Say)//发送绿色信息给人物
        else PlayObject.SysMsg1(sMsg, c_Green, t_Say, FColor, BColor);
      end;//6
      7: begin
        if not boIsCustom then PlayObject.SysMsg(sMsg, c_Blue, t_Say)//发送蓝色信息给人物
        else PlayObject.SysMsg1(sMsg, c_Blue, t_Say, FColor, BColor);
      end;//7
      8: if PlayObject.m_MyGuild <> nil then begin
        if not boIsCustom then TGUild(PlayObject.m_MyGuild).SendGuildMsg(sMsg)//发送行会信息
        else TGUild(PlayObject.m_MyGuild).SendGuildMsg1(sMsg, FColor, BColor);
      end;
      9: begin//当前地图玩家可见
        if UserEngine.m_PlayObjectList.Count > 0 then begin
          for I := 0 to UserEngine.m_PlayObjectList.Count - 1 do begin
            BaseObject := TPlayObject(UserEngine.m_PlayObjectList.Objects[I]);
            if BaseObject <> nil then begin
              if {not BaseObject.m_boDeath and} not BaseObject.m_boGhost and//20090716 修改
                (BaseObject.m_PEnvir = PlayObject.m_PEnvir) then begin
                if not boIsCustom then BaseObject.SysMsg(sMsg, c_Red, t_Say)//发送红色信息给人物
                else BaseObject.SysMsg1(sMsg, c_Red, t_Say, FColor, BColor);
              end;
            end;
          end;
        end;
      end;
      else begin
        ScriptActionError(PlayObject, '', QuestActionInfo, sSENDMSG);
      end;  
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfLineMsg',[g_sExceptionVer]));
  end;
end;
//功能：创建文本文件
//格式：CreateFile QuestDiary\NewFile.txt
procedure TNormNpc.ActionOfCreateFile(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  sFileName: string;
  SaveList: TStringList;
begin
  sFileName:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//文本路径
  if sFileName <> '' then begin
    if sFileName[1] = '\' then sFileName := Copy(sFileName, 2, Length(sFileName) - 1);
    if sFileName[2] = '\' then sFileName := Copy(sFileName, 3, Length(sFileName) - 2);
    if sFileName[3] = '\' then sFileName := Copy(sFileName, 4, Length(sFileName) - 3);
  end;
  sFileName:= g_Config.sEnvirDir + sFileName;

  SaveList := TStringList.Create;
  try
    if not FileExists(sFileName) then begin
      try
        SaveList.SaveToFile(sFileName);
      except
        MainOutMessage('文件保存失败 => ' + sFileName);
      end;
    end;
  finally
    SaveList.Free;
  end;
end;
//功能：删除指定文件
//格式：DeleteFile QuestDiary\NewFile.txt
procedure TNormNpc.ActionOfDeleteFile(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  sFileName: string;
begin
  try
    sFileName:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//文本路径
    if sFileName <> '' then begin
      if sFileName[1] = '\' then sFileName := Copy(sFileName, 2, Length(sFileName) - 1);
      if sFileName[2] = '\' then sFileName := Copy(sFileName, 3, Length(sFileName) - 2);
      if sFileName[3] = '\' then sFileName := Copy(sFileName, 4, Length(sFileName) - 3);
    end;
    sFileName:= g_Config.sEnvirDir + sFileName;
    if FileExists(sFileName) then DeleteFile(sFileName);
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfDeleteFile',[g_sExceptionVer]));
  end;
end;
//-------------------------特殊公告-----------------------------------
//功能: 顶端滚动公告 20091110 修改
//格式：SendTopMsg 前景色 背景色 消息文字 模式
//模式 0发给自己 1发送所有人 2发送行会 3发送当前地图
procedure TNormNpc.ActionOfSendTopMsg(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  sMsg: string;
  sParam3: string;
  I, FColor,BColor, nMode:Integer;
  BaseObject: TPlayObject;
begin
  try
    nMode:= -1;
    FColor:=QuestActionInfo.nParam1;
    BColor:=QuestActionInfo.nParam2;
    sParam3 := QuestActionInfo.sParam3;//消息文字
    GetValValue(PlayObject, QuestActionInfo.sParam3, sParam3);
    sMsg := GetLineVariableText(PlayObject, sParam3);
    if QuestActionInfo.sParam4 <> '' then nMode:= Str_ToInt(QuestActionInfo.sParam4, -1);//模式
    case nMode of
      0: PlayObject.SendMsg(PlayObject, RM_MOVEMESSAGE, 0{0为滚动}, FColor, BColor, 0, sMsg);//发给自己
      1: begin
        if UserEngine.m_PlayObjectList.Count > 0 then begin
          for I := 0 to UserEngine.m_PlayObjectList.Count - 1 do begin
            BaseObject := TPlayObject(UserEngine.m_PlayObjectList.Objects[I]);
            if BaseObject <> nil then begin
              if (not BaseObject.m_boGhost) and (not BaseObject.m_boNotOnlineAddExp)
                 and (not BaseObject.m_boAI) then
                BaseObject.SendMsg(BaseObject, RM_MOVEMESSAGE, 0{0为滚动}, FColor, BColor, 0, sMsg);
            end;
          end;
        end;
      end;//1
      2: begin//发送行会
        if PlayObject.m_MyGuild <> nil then begin
          if UserEngine.m_PlayObjectList.Count > 0 then begin
            for I := 0 to UserEngine.m_PlayObjectList.Count - 1 do begin
              BaseObject := TPlayObject(UserEngine.m_PlayObjectList.Objects[I]);
              if BaseObject <> nil then begin
                if (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) and
                  (not BaseObject.m_boNotOnlineAddExp) and (not BaseObject.m_boAI) and
                  TGUild(PlayObject.m_MyGuild).IsMember(BaseObject.m_sCharName) then
                  BaseObject.SendMsg(BaseObject, RM_MOVEMESSAGE, 0{0为滚动}, FColor, BColor, 0, sMsg);
              end;
            end;
          end;
        end;
      end;//2
      3: begin//当前地图
        if UserEngine.m_PlayObjectList.Count > 0 then begin
          for I := 0 to UserEngine.m_PlayObjectList.Count - 1 do begin
            BaseObject := TPlayObject(UserEngine.m_PlayObjectList.Objects[I]);
            if BaseObject <> nil then begin
              if (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) and
                (not BaseObject.m_boNotOnlineAddExp) and (not BaseObject.m_boAI) and
                (BaseObject.m_PEnvir = PlayObject.m_PEnvir) then
                BaseObject.SendMsg(BaseObject, RM_MOVEMESSAGE, 0{0为滚动}, FColor, BColor, 0, sMsg);
            end;
          end;
        end;
      end;//3
      else begin
        PlayObject.SendRefMsg(RM_MOVEMESSAGE, 0{0为滚动}, FColor, BColor, 0, sMsg);//20080704 修改,使别人可以看到消息
      end;
    end;//case
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfSendTopMsg',[g_sExceptionVer]));
  end;
end;

//功能：屏幕居中显示公告 20091128
//格式：SendCenterMsg 前景色 背景色 消息文字 模式 显示时间(秒) 显示位置
//模式 0发给自己 1发送所有人 2发送行会 3发送当前地图
//显示位置 1-中部居中显示 2-顶部居中显示 3-右下角显示 4-快捷栏上居中显示(暂时不写)
procedure TNormNpc.ActionOfSendCenterMsg(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  sMsg, sParam3: string;
  I ,FColor, BColor, nTime, nMode, nShowMode: Integer;
  BaseObject: TPlayObject;
begin
  try
    nMode:= -1;
    FColor:=QuestActionInfo.nParam1;//前景色
    BColor:=QuestActionInfo.nParam2;//背景色
    if QuestActionInfo.sParam4 <> '' then nMode:= Str_ToInt(QuestActionInfo.sParam4, -1);//模式
    nTime:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam5), 0);//时间
    sParam3 := QuestActionInfo.sParam3;//消息文字
    GetValValue(PlayObject, QuestActionInfo.sParam3, sParam3);
    sMsg := GetLineVariableText(PlayObject, sParam3);
    nShowMode:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam6), 1);//显示位置
    if (nShowMode > 3) or (nShowMode <= 0) then nShowMode:= 1;
    case nShowMode of
      2: nShowMode:= 3;
      3: nShowMode:= 6;
      4: nShowMode:= 4;//未支持效果
    end;
    case nMode of
      0: PlayObject.SendMsg(PlayObject, RM_MOVEMESSAGE, nShowMode{0为顶部滚动 1为中部居中 2聊天栏上面倒记时 3顶部居中固定 4快捷栏上显示 5传音筒 6右下角显示}, FColor, BColor, nTime, sMsg);//发给自已
      1: begin//所有在线玩家
        if UserEngine.m_PlayObjectList.Count > 0 then begin
          for I := 0 to UserEngine.m_PlayObjectList.Count - 1 do begin
            BaseObject := TPlayObject(UserEngine.m_PlayObjectList.Objects[I]);
            if BaseObject <> nil then begin
              if (not BaseObject.m_boGhost) and (not BaseObject.m_boNotOnlineAddExp)
                and (not BaseObject.m_boAI) then
                BaseObject.SendMsg(BaseObject, RM_MOVEMESSAGE, nShowMode{0为顶部滚动 1为中部居中 2聊天栏上面倒记时 3顶部居中固定 4快捷栏上显示 5传音筒 6右下角显示}, FColor, BColor, nTime, sMsg);
            end;
          end;
        end;
      end;//1
      2: begin//发送行会
        if PlayObject.m_MyGuild <> nil then begin
          if UserEngine.m_PlayObjectList.Count > 0 then begin//20081008
            for I := 0 to UserEngine.m_PlayObjectList.Count - 1 do begin
              BaseObject := TPlayObject(UserEngine.m_PlayObjectList.Objects[I]);
              if BaseObject <> nil then begin
                if (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) and
                  (not BaseObject.m_boNotOnlineAddExp) and (not BaseObject.m_boAI) and
                  TGUild(PlayObject.m_MyGuild).IsMember(BaseObject.m_sCharName) then
                  BaseObject.SendMsg(BaseObject, RM_MOVEMESSAGE, nShowMode{0为顶部滚动 1为中部居中 2聊天栏上面倒记时 3顶部居中固定 4快捷栏上显示 5传音筒 6右下角显示}, FColor, BColor, nTime, sMsg);//20091110 修改
              end;
            end;
          end;
        end;
      end;//2
      3: begin//当前地图
        if UserEngine.m_PlayObjectList.Count > 0 then begin//20081008
          for I := 0 to UserEngine.m_PlayObjectList.Count - 1 do begin
            BaseObject := TPlayObject(UserEngine.m_PlayObjectList.Objects[I]);
            if BaseObject <> nil then begin
              if (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) and
                (not BaseObject.m_boNotOnlineAddExp) and (not BaseObject.m_boAI) and
                (BaseObject.m_PEnvir = PlayObject.m_PEnvir) then
                BaseObject.SendMsg(BaseObject, RM_MOVEMESSAGE, nShowMode{0为顶部滚动 1为中部居中 2聊天栏上面倒记时 3顶部居中固定 4快捷栏上显示 5传音筒 6右下角显示}, FColor, BColor, nTime, sMsg);//20091110 修改
            end;
          end;
        end;
      end;//3
      else begin
        PlayObject.SendRefMsg(RM_MOVEMESSAGE, nShowMode{0为顶部滚动 1为中部居中 2聊天栏上面倒记时 3顶部居中固定 4快捷栏上显示 5传音筒 6右下角显示}, FColor, BColor, nTime, sMsg);//20080704 修改,使别人可以看到消息
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfSendCenterMsg',[g_sExceptionVer]));
  end;
end;

//功能：聊天框顶端公告
//格式：SendEditTopMsg 前景色 背景色 消息文字 模式 显示时间(秒)
//模式 0发给自己 1发送所有人 2发送行会 3发送当前地图
procedure TNormNpc.ActionOfSendEditTopMsg(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  sMsg: string;
  sParam3: string;
  FColor,BColor:integer;
begin
  try
    FColor:=QuestActionInfo.nParam1;
    BColor:=QuestActionInfo.nParam2;
    sParam3 := QuestActionInfo.sParam3;
    GetValValue(PlayObject, QuestActionInfo.sParam3, sParam3);
    sMsg := GetLineVariableText(PlayObject, sParam3);
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfSendEditTopMsg',[g_sExceptionVer]));
  end;                                     
end;
//功能:调整人物宠物的快乐度
//格式:CHANGEPETSMONHAPP 控制符(=,+,-) 点数
procedure TNormNpc.ActionOfCHANGEPETSMONHAPP(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  nExp: LongWord;
  cMethod: Char;
  BaseObject: TBaseObject;
  I: Integer;
begin
  try
    nExp:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);
    if (nExp < 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sCHANGEPETSMONHAPP);
      Exit;
    end;
    cMethod := QuestActionInfo.sParam1[1];
    if PlayObject.m_sPetsMonName <> '' then begin
      if PlayObject.m_SlaveList.Count > 0 then begin
        for I := 0 to PlayObject.m_SlaveList.Count - 1 do begin
          BaseObject := TBaseObject(PlayObject.m_SlaveList.Items[I]);
          if CompareText(PlayObject.m_sPetsMonName, BaseObject.m_sCharName) = 0 then begin
            if (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) and (BaseObject.m_btRaceServer = 158) then begin
              case cMethod of
                '=': begin
                    TPetsMon(BaseObject).m_nHappiness := nExp;
                    PlayObject.m_nPetsMonHappiness:= nExp;
                  end;
                '-': begin
                    if TPetsMon(BaseObject).m_nHappiness >= nExp then Dec(TPetsMon(BaseObject).m_nHappiness, nExp)
                    else TPetsMon(BaseObject).m_nHappiness:= 0;
                    PlayObject.m_nPetsMonHappiness:= TPetsMon(BaseObject).m_nHappiness;
                    TPetsMon(BaseObject).SaveMasterList(format('你对你的宠物使用了物品,快乐度-%d',[nExp]));
                  end;
                '+': begin
                    if (High(LongWord) - TPetsMon(BaseObject).m_nHappiness) < nExp then begin
                      TPetsMon(BaseObject).m_nHappiness := High(LongWord);
                    end else Inc(TPetsMon(BaseObject).m_nHappiness, nExp);
                    PlayObject.m_nPetsMonHappiness:= TPetsMon(BaseObject).m_nHappiness;
                    TPetsMon(BaseObject).SaveMasterList(format('你对你的宠物使用了普通喂养,快乐度+%d',[nExp]));
                  end;
              end;//case
              PlayObject.SendMsg(PlayObject, RM_UPPETSMONHAPP, 0, PlayObject.m_nPetsMonHappiness, 0, 0, '');
            end;
            Break;
          end;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfCHANGEPETSMONHAPP',[g_sExceptionVer]));
  end;
end;
//功能:打开宠物喂养日志
//格式:PETSMONHAPPLOG
procedure TNormNpc.ActionOfPetsMonHappLog(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  sLog, sFileName: string;
  LoadList: TStringList;
  I:Integer;
begin
  try
    PlayObject.m_nPetsMonHappLogPage:= 0;//宠物快乐度日志当前页数
    sFileName:= Format('%sPetsMon\%d\Log\%s.txt',[g_Config.sEnvirDir, g_Config.GlobalVal[High(g_Config.GlobalVal)], PlayObject.m_sCharName]);
    if PlayObject.m_sPetsMonName <> '' then begin
      sLog:= '';
      if FileExists(sFileName) then begin//文件存在则读取
        LoadList:= TStringList.Create;
        try
          LoadList.LoadFromFile(sFileName);
          for I := 0 to LoadList.Count - 1 do begin
            if (I >= 9) or (Trim(LoadList.Strings[I]) = '') then Break;
            sLog:= sLog + Trim(LoadList.Strings[I])+'\';
          end;
        finally
          LoadList.Free;
        end;
      end;
      PlayObject.SendMsg(PlayObject, RM_PETSMONHAPPLOG, 0, PlayObject.m_nPetsMonHappiness, 0, 0, sLog);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfPetsMonHappLog',[g_sExceptionVer]));
  end;
end;
//------------------------------酿酒系统---------------------------------------
//功能:打开酿酒窗口 20080619
//格式:OPENMAKEWINE X(0,1) 0-酿造普通酒 1-酿造药酒
procedure TNormNpc.ActionOfOPENMAKEWINE(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  nCode: Byte;
  I: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  boIsCanOpenMakeWine: Boolean;
begin
  try
    if TMerchant(self).m_boPlayMakeWine then begin//酿酒NPC标识
      nCode:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam1), 2);//打开窗口标识
      if not nCode in [0,1] then begin
        ScriptActionError(PlayObject, '', QuestActionInfo, sOPENMAKEWINE);
        Exit;
      end;
      boIsCanOpenMakeWine:= False;//是否可以酿酒
      if PlayObject.m_ItemList.Count > 0 then begin
        for I := 0 to PlayObject.m_ItemList.Count - 1 do begin//判断玩家包裹是否有酒器,有则可进行,没有则返回
          UserItem := PlayObject.m_ItemList.Items[I];
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) and (StdItem.StdMode = 12) then begin//有酒器
            boIsCanOpenMakeWine:= True;
            Break;
          end;
        end;
      end;
      if boIsCanOpenMakeWine then begin
        PlayObject.SendMsg(Self, RM_OPENMAKEWINE, 0, nCode, 0, 0, m_sCharName);
      end else begin
        GotoLable(PlayObject, '@NoCanMakeWine', False, False);
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfOPENMAKEWINE',[g_sExceptionVer]));
  end;
end;

//功能:取回酿好的酒 20080620
//格式:GETGOODMAKEWINE
procedure TNormNpc.ActionOfGETGOODMAKEWINE(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  UserItem,UserItem1: pTUserItem;
  StdItem,StdItem1: pTStdItem;
begin
  PlayObject.bo_NPCMove:= False;//是否点击,让NPC走动 20080704
  try
    if TMerchant(self).m_boPlayMakeWine then begin//酿酒NPC标识
      if PlayObject.m_boMakeWine then begin//在NPC处正在酿酒
        //判断酿酒时间是否到,如果到时间则给玩家对应的酒,并且的种类为0时
        if (PlayObject.m_MakeWineTime = 0) and (PlayObject.n_MakeWineItmeType <> 0) then begin
           StdItem := UserEngine.GetMakeWineStdItem(60, PlayObject.n_MakeWineItmeType);
           if (StdItem <> nil) and (StdItem.AniCount = PlayObject.n_MakeWineType) then begin
             New(UserItem);
             if UserEngine.CopyToUserItemFromName(StdItem.Name, UserItem) then begin
                PlayObject.m_boMakeWine:= False;//改变标识,不管包裹满否 20081109
                if PlayObject.IsEnoughBag and PlayObject.IsAddWeightAvailable(StdItem.Weight) then begin//包裹有位置则放到包裹里,没有则扔出物品
                  //改变品质及酒精度
                  UserItem.btValue[0]:= PlayObject.n_MakeWineQuality;//酒的品质
                  UserItem.btValue[1]:= PlayObject.n_MakeWineAlcohol;//酒精度
                  Randomize(); //随机种子
                  if PlayObject.n_MakeWineType = 2 then begin//药酒,有药力值
                    UserItem.btValue[2]:= _MAX( 1,PlayObject.n_MakeWineQuality - 5);//药酒至少可以增加1点药力值 20081210
                  end;
                  if (Random(g_Config.nMakeWineLevelRate) = 0) then begin//一定机率得到酒等级 20091117
                    UserItem.btValue[3]:= _MIN(3 ,1 + Random(3));
                  end;

                  if StdItem.NeedIdentify = 1 then
                    AddGameDataLog('38' + #9 +m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                      IntToStr(m_nCurrY) + #9 + PlayObject.m_sCharName + #9 +StdItem.Name + #9 +
                      IntToStr(UserItem.MakeIndex) + #9 +IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1]) + #9 + m_sCharName);

                  PlayObject.m_ItemList.Add(UserItem);
                  if PlayObject.m_btRaceServer = RC_PLAYOBJECT then begin
                    PlayObject.SendAddItem(UserItem);
                    PlayObject.SendUpdateItem(UserItem);//更新物品
                  end;

                  if (Random(g_Config.nMakeWineRate) = 0) and (PlayObject.n_MakeWineType=1) then begin//一定机率获得酒曲 20080621
                     StdItem1 := UserEngine.GetMakeWineStdItem1(StdItem.Shape);//通过酒的Shape得到酒曲
                     if StdItem1 <> nil then begin
                       New(UserItem1);
                       if UserEngine.CopyToUserItemFromName(StdItem1.Name, UserItem1) then begin
                          if PlayObject.IsEnoughBag and PlayObject.IsAddWeightAvailable(StdItem1.Weight) then begin
                            if StdItem1.NeedIdentify = 1 then
                              AddGameDataLog('38' + #9 +m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                IntToStr(m_nCurrY) + #9 + PlayObject.m_sCharName + #9 +StdItem1.Name + #9 +
                                IntToStr(UserItem1.MakeIndex) + #9 +'1' + #9 + m_sCharName);
                            PlayObject.m_ItemList.Add(UserItem1);
                            if PlayObject.m_btRaceServer = RC_PLAYOBJECT then begin
                              PlayObject.SendAddItem(UserItem1);
                              PlayObject.SendUpdateItem(UserItem1);//更新物品
                            end;
                          end;
                       end else Dispose(UserItem1);
                     end;
                  end;
                  PlayObject.m_MakeWineTime := 0;
                  PlayObject.n_MakeWineItmeType:= 0;
                  PlayObject.n_MakeWineQuality:= 0;//酿酒后,应该可以得到酒的品质 20080620
                  PlayObject.n_MakeWineAlcohol:= 0;//酿酒后,应该可以得到酒的酒精度 20080620
                  if PlayObject.m_PEnvir = m_PEnvir then GotoLable(PlayObject, '@EndMakeWine', False, False);//酿酒完毕 20080711
                end else begin//扔出物品
                  PlayObject.DropItemDown(UserItem, 3, False,False, PlayObject, PlayObject);
                  Dispose(UserItem);//修复内存泄露By TasNat at: 2012-06-01 12:10:51
                end;
             end else Dispose(UserItem);
           end;
        end;
        if (PlayObject.m_MakeWineTime > 0) and (PlayObject.m_PEnvir = m_PEnvir) then GotoLable(PlayObject, '@NoMakeWineTimeOver', False, False);//时间还没有到 20080711
      end else begin
       if PlayObject.m_PEnvir = m_PEnvir then GotoLable(PlayObject, '@NoMakeWine', False, False);//没有酿酒 20080711
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfGETGOODMAKEWINE',[g_sExceptionVer]));
  end;
end;

//功能:减少酿酒的时间 20080620
//格式:DECMAKEWINETIME N(秒) D(1,2) X(0,1)
//参数:D-1普通酒 2-药酒
//     X-0按指定值减少,1-减少时间在1分钟内
procedure TNormNpc.ActionOfDECMAKEWINETIME(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  nMakeWineType,nCode:Byte;
  mMakeWineTime: LongWord;
begin
  mMakeWineTime:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam1), 0);//缩短时间
  nMakeWineType:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2), 0);//酒类型
  nCode:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3), 0);//操作类型
  try
  if TMerchant(self).m_boPlayMakeWine then begin//酿酒NPC标识
    if PlayObject.m_boMakeWine then begin//在NPC处正在酿酒
      if PlayObject.n_MakeWineType = nMakeWineType then begin//酒的类型一致
         case nCode of
           0:begin//按指定的值减少时间
             PlayObject.m_MakeWineTime:=_MAX(0, PlayObject.m_MakeWineTime - mMakeWineTime);
             GotoLable(PlayObject, '@DecMakeWineTimeOK', False, False);
           end;
           1:begin//时间缩短在一分钟内
             PlayObject.m_MakeWineTime:= 60 - Random(10);
             GotoLable(PlayObject, '@DecMakeWineTimeOK', False, False);
           end;
         end;
      end else begin
        GotoLable(PlayObject, '@NoIsInMakeWine', False, False);//没有酿酒
      end;
    end else begin
      GotoLable(PlayObject, '@NoIsInMakeWine', False, False);//没有酿酒
    end;
  end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfDECMAKEWINETIME',[g_sExceptionVer]));
  end;
end;

//功能:酿酒NPC的走动 20080621
//格式:MAKEWINENPCMOVE
procedure TNormNpc.ActionOfMAKEWINENPCMOVE(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
begin
try
  if not PlayObject.bo_NPCMove then begin//是否点击,让NPC走动(防止不停的点击) 20080704
    if PlayObject.m_boMakeWine then begin//在NPC处正在酿酒 20080914
      PlayObject.bo_NPCMove:= True;
      SendRefMsg(RM_NPCWALK, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
    end else begin
      GotoLable(PlayObject, '@NoIsInMakeWine', False, False);//没有酿酒
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfMAKEWINENPCMOVE',[g_sExceptionVer]));
end;
end;

//功能:设置泉水喷发
//格式:FOUNTAIN 地图 X Y 时间(秒)
procedure TNormNpc.ActionOfFOUNTAIN(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  nX, nY, nTime:Integer;
  Envir: TEnvirnoment;
  sMap: String;
  FlowerEvent: TFlowerEvent;
begin
  try
    sMap:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1); //地图ID 支持变量
    nX:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2), 0);//X
    nY:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3), 0);//Y
    nTime:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam4), 0);//Time
    if sMap ='' then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sFOUNTAIN);
      Exit;
    end;

    Envir := g_MapManager.FindMap(sMap);//查找地图场景
    if Envir <> nil then begin
      if g_EventManager.GetEvent(Envir, nX, nY, ET_FOUNTAIN) <> nil then Exit;//如果有场景了,就直接退出
      FlowerEvent := TFlowerEvent.Create(Envir, nX, nY, ET_FOUNTAIN, nTime * 1000);
      g_EventManager.AddEvent(FlowerEvent);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfFOUNTAIN',[g_sExceptionVer]));
  end;
end;

//功能:开启/关闭行会泉水仓库 20080625
//格式:SETGUILDFOUNTAIN 0/1 (0-开,1-关)
procedure TNormNpc.ActionOfSETGUILDFOUNTAIN(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  nCode:Byte;
begin
try
  nCode:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam1), -1);
  if (nCode < 0) and (not nCode in [0,1]) then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSETGUILDFOUNTAIN);
    Exit;
  end;
  if (PlayObject.m_MyGuild <> nil) and (PlayObject.m_nGuildRankNo = 1) then begin
    Case nCode of
      0:begin
         TGUild(PlayObject.m_MyGuild).boChanged:=True;
         TGUild(PlayObject.m_MyGuild).boGuildFountainOpen:= True;
         GotoLable(PlayObject, '@OpenGuildFountain', False, False);
      end;
      1:begin
        TGUild(PlayObject.m_MyGuild).boChanged:=True;
        TGUild(PlayObject.m_MyGuild).boGuildFountainOpen:= False;
        GotoLable(PlayObject, '@CloseGuildFountain', False, False);
      end;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfSETGUILDFOUNTAIN',[g_sExceptionVer]));
end;
end;

//功能:领取行会泉水  20080625
//格式:GIVEGUILDFOUNTAIN 物品名 数量
procedure TNormNpc.ActionOfGIVEGUILDFOUNTAIN(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  sItemName: string;
  nItemCount: Integer;
  I,nDate: Integer;
begin
try
  sItemName := GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//增加变量支持
  nItemCount:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2), -1);//属性 支持变量
  if nItemCount < 0 then nItemCount := QuestActionInfo.nParam2;

  nDate:=Strtoint(FormatDatetime('YYYYMMDD',date));//当前的日期
  if PlayObject.m_MyGuild <> nil then begin
    if TGUild(PlayObject.m_MyGuild).boGuildFountainOpen then begin//行会泉水仓库开启
       if PlayObject.m_GiveGuildFountationDate <> nDate then begin
         if TGUild(PlayObject.m_MyGuild).m_nGuildFountain >=g_Config.nMinGuildFountain then begin//行会蓄量不能少于指定值
            TGUild(PlayObject.m_MyGuild).boChanged:=True;
            TGUild(PlayObject.m_MyGuild).m_nGuildFountain:= _MAX(0, TGUild(PlayObject.m_MyGuild).m_nGuildFountain - g_Config.nDecGuildFountain);
            PlayObject.m_GiveGuildFountationDate := nDate;//领取泉水的日期
            if UserEngine.GetStdItemIdx(sItemName) > 0 then begin
              if not (nItemCount in [1..50]) then nItemCount := 1; //12.28 改上一条
              for I := 0 to nItemCount - 1 do begin //nItemCount 为0时出死循环
                if PlayObject.IsEnoughBag then begin
                  New(UserItem);
                  if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
                    PlayObject.m_ItemList.Add((UserItem));
                    PlayObject.SendAddItem(UserItem);
                    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                    if StdItem.NeedIdentify = 1 then
                      AddGameDataLog('35' + #9 + PlayObject.m_sMapName + #9 +IntToStr(PlayObject.m_nCurrX) + #9 +
                        IntToStr(PlayObject.m_nCurrY) + #9 +PlayObject.m_sCharName + #9 +sItemName + #9 +
                        IntToStr(UserItem.MakeIndex) + #9 +'1' + #9 +m_sCharName);
                  end else Dispose(UserItem);
                end else begin
                  New(UserItem);
                  if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
                    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                    if StdItem.NeedIdentify = 1 then
                      AddGameDataLog('35' + #9 + PlayObject.m_sMapName + #9 +IntToStr(PlayObject.m_nCurrX) + #9 +
                        IntToStr(PlayObject.m_nCurrY) + #9 + PlayObject.m_sCharName + #9 + sItemName + #9 +
                        IntToStr(UserItem.MakeIndex) + #9 +'1' + #9 + m_sCharName);
                    PlayObject.DropItemDown(UserItem, 3, False, False, PlayObject, PlayObject);
                  end;
                  Dispose(UserItem);
                end;
              end;
            end;
            GotoLable(PlayObject, '@GIVEFOUNTAIN_OK', False, False);//领取成功
         end else GotoLable(PlayObject, '@NOGIVEFOUNTAIN', False, False);//行会泉水量不足
      end else GotoLable(PlayObject, '@NOGIVEFOUNTAIN1', False, False);//已领取过泉水
    end else GotoLable(PlayObject, '@GIVEFOUNTAINColse', False, False);//行会酒泉关闭
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfGIVEGUILDFOUNTAIN',[g_sExceptionVer]));
end;
end;

//-----------------------------------------------------------------------------
//功能:挑战地图移动 20080705
//格式:CHALLENGMAPMOVE 地图名 X Y 
procedure TNormNpc.ActionOfCHALLENGMAPMOVE(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  nX, nY:Integer;
  Envir: TEnvirnoment;
  sMap: String;
  m_boMoveOK: Boolean;
begin
  try                                                                              //增加禁锢区域不可用 By TasNat at: 2012-03-08 12:12:50
    if ((PlayObject.m_ChallengeCreat = nil) or (PlayObject.m_ChallengeCreat.InMag113LockRect(PlayObject.m_ChallengeCreat.m_nCurrX, PlayObject.m_ChallengeCreat.m_nCurrY))) or (not PlayObject.m_boChallengeing) or (PlayObject.InMag113LockRect(PlayObject.m_nCurrX, PlayObject.m_nCurrY)) then Exit;
    m_boMoveOK:= False;
    sMap:=GetLineVariableText(PlayObject, QuestActionInfo.sParam1); //地图ID 支持变量
    nX:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2), 0);//X
    nY:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3), 0);//Y
    if sMap ='' then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sCHALLENGMAPMOVE);
      Exit;
    end;
    Envir := g_MapManager.FindMap(sMap);//查找地图场景
    if Envir <> nil then begin//判断地图是否存在,
      m_boMoveOK:= True;
      if Envir.m_boFight4Zone then begin//并且是挑战地图
         {$IF HEROVERSION = 1}
         if PlayObject.m_ChallengeCreat.m_MyHero <> nil then PlayObject.m_ChallengeCreat.ClientHeroLogOut(1); //英雄退出,没有提示
         if PlayObject.m_MyHero <> nil then  PlayObject.ClientHeroLogOut(1); //英雄退出,没有提示
         {$IFEND}
         PlayObject.m_sLastMapName := PlayObject.m_sMapName;//20080706
         PlayObject.m_ChallengeCreat.m_sLastMapName := PlayObject.m_ChallengeCreat.m_sMapName;//20080706
         PlayObject.m_ChallengeCreat.MapRandomMove(sMap, 0);
         PlayObject.MapRandomMove(sMap, 0);
         PlayObject.m_ChallengeTime:= g_Config.nChallengeTime;//挑战计时 20080705
         PlayObject.m_ChallengeCreat.m_ChallengeTime:= g_Config.nChallengeTime;//挑战计时 20080705
      end;//if Envir.m_boFight4Zone
    end else begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sCHALLENGMAPMOVE);
      Exit;
    end;
    if not m_boMoveOK then begin
       if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(PlayObject, '@Challenge_Fail', False, False);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfCHALLENGMAPMOVE',[g_sExceptionVer]));
  end;
end;
//功能:没有挑战地图可移动,则退回抵押的物品
//格式:GETCHALLENGEBAKITEM
procedure TNormNpc.ActionOfGETCHALLENGEBAKITEM(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
begin
  try
    if (PlayObject.m_ChallengeCreat = nil) or (not PlayObject.m_boChallengeing) then Exit;
    PlayObject.m_boChallengeing := False;
    if PlayObject.m_ChallengeCreat <> nil then begin
       PlayObject.m_ChallengeCreat.m_boChallengeing := False;
       PlayObject.m_ChallengeCreat.GetBackChallengeItems();
       PlayObject.m_ChallengeCreat.m_ChallengeCreat:= nil;
       PlayObject.m_ChallengeCreat.m_ChallengeLastTick := GetTickCount();
    end;
    PlayObject.m_ChallengeCreat := nil;
    PlayObject.GetBackChallengeItems();
    PlayObject.m_ChallengeLastTick := GetTickCount();
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfGETCHALLENGEBAKITEM',[g_sExceptionVer]));
  end;
end;
//-----------------------------------------------------------------------------
//功能:人物在线英雄下线  20080716
//格式:HEROLOGOUT
procedure TNormNpc.ActionOfHEROLOGOUT(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
begin
  {$IF HEROVERSION = 1}
  PlayObject.ClientHeroLogOut(0); //英雄退出
  {$IFEND}
end;
//-----------------------------------------------------------------------------
//功能:修改魔法ID,并且等级为4 20080624
//格式:CHANGESKILL 原魔法ID 新魔法ID Hero
procedure TNormNpc.ActionOfCHANGESKILL(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  Magic: pTMagic;
  UserMagic,UserMagic1: pTUserMagic;
  oldMagic,NewMagic: Word;
  I: Integer;
begin
  try
    OldMagic:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam1), 0);
    NewMagic:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2), 0);
    if CompareText(QuestActionInfo.sParam3, 'HERO') = 0 then begin
      {$IF HEROVERSION = 1}
      if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then Exit;
      Magic := UserEngine.FindHeroMagic(NewMagic);
      if Magic <> nil then begin
        if PlayObject.m_MyHero <> nil then begin
          if not PlayObject.m_MyHero.IsTrainingSkill(Magic.wMagicId) then begin
            for I := PlayObject.m_MyHero.m_MagicList.Count - 1 downto 0 do begin
              if PlayObject.m_MyHero.m_MagicList.Count <= 0 then Break;
              UserMagic := PlayObject.m_MyHero.m_MagicList.Items[I];
              if UserMagic <> nil then begin
                if UserMagic.MagicInfo.wMagicId = OldMagic then begin
                  New(UserMagic1);
                  UserMagic1.MagicInfo := Magic;
                  UserMagic1.wMagIdx := Magic.wMagicId;
                  UserMagic1.btKey := UserMagic.btKey;
                  UserMagic1.btLevel := 4;
                  UserMagic1.MagicInfo.btTrainLv := 3;
                  UserMagic1.btLevelEx := 0;//强化等级
                  if UserMagic1.MagicInfo.wMagicId = 68 then UserMagic1.MagicInfo.btTrainLv := 100;//酒气为100级 20090330
                  UserMagic1.nTranPoint := UserMagic1.MagicInfo.MaxTrain[3];
                  PlayObject.m_MyHero.m_MagicList.Delete(I);//内存泄露 By TasNat at: 2012-03-11 11:42:22
                  //防止释放内存后的非法访问 By TasNat at: 2012-03-11
                  //PlayObject.m_MyHero.m_MagicOfDelList.Add(UserMagic);

                  THeroObject(PlayObject.m_MyHero).SendDelMagic(UserMagic);
                  PlayObject.m_MyHero.m_MagicList.Add(UserMagic1);
                  THeroObject(PlayObject.m_MyHero).SendAddMagic(UserMagic1);
                  THeroObject(PlayObject.m_MyHero).RecalcAbilitys();//20081213
                  PlayObject.m_MyHero.CompareSuitItem(False);//200080729 套装
                  Dispose(UserMagic);
                  Break;
                end;
              end;
            end;//for
          end;
        end;
      end;
      {$IFEND}
    end else begin
      Magic := UserEngine.FindMagic(NewMagic);
      if Magic <> nil then begin
        if not PlayObject.IsTrainingSkill(Magic.wMagicId) then begin
          for I := PlayObject.m_MagicList.Count - 1 downto 0 do begin
            if  PlayObject.m_MagicList.Count <= 0 then Break;
            UserMagic := PlayObject.m_MagicList.Items[I];
            if UserMagic <> nil then begin
              if UserMagic.MagicInfo.wMagicId = OldMagic then begin
                New(UserMagic1);
                UserMagic1.MagicInfo := Magic;
                UserMagic1.wMagIdx := Magic.wMagicId;
                UserMagic1.btKey := UserMagic.btKey;
                UserMagic1.btLevel := 4;
                UserMagic1.btLevelEx := UserMagic.btLevelEx;//强化等级
                if UserMagic1.btLevelEx > 9 then UserMagic1.btLevelEx:= 9;                
                UserMagic1.MagicInfo.btTrainLv := 3;
                if UserMagic1.MagicInfo.wMagicId = 68 then UserMagic1.MagicInfo.btTrainLv := 100;//酒气为100级 20090330
                UserMagic1.nTranPoint := UserMagic1.MagicInfo.MaxTrain[3];
                PlayObject.m_MagicList.Delete(I);//内存泄露 By TasNat at: 2012-03-11 11:42:22
                //防止释放内存后的非法访问 By TasNat at: 2012-03-11 
                //PlayObject.m_MagicOfDelList.Add(UserMagic);
                
                PlayObject.SendDelMagic(UserMagic);
                PlayObject.m_MagicList.Add(UserMagic1);
                PlayObject.SendAddMagic(UserMagic1);
                PlayObject.RecalcAbilitys();
                PlayObject.CompareSuitItem(False);//200080729 套装
                Dispose(UserMagic);
                Break;
              end;
            end;
          end;//for
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfCHANGESKILL',[g_sExceptionVer]));
  end;
end;
//功能:转换技能
//格式:CHANGESKILLEX 原技能名 新技能名 Hero
//注：需要有原技能时才能转换，新技能等级与原技能一致
procedure TNormNpc.ActionOfCHANGESKILLEX(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  Magic: pTMagic;
  UserMagic,UserMagic1: pTUserMagic;
  oldMagic, NewMagic: string;
  I: Integer;
begin
  try
    OldMagic:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1);
    NewMagic:= GetLineVariableText(PlayObject, QuestActionInfo.sParam2);
    if CompareText(QuestActionInfo.sParam3, 'HERO') = 0 then begin
      {$IF HEROVERSION = 1}
      if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then Exit;
      Magic := UserEngine.FindHeroMagic(NewMagic);
      if Magic <> nil then begin
        if PlayObject.m_MyHero <> nil then begin
          if not PlayObject.m_MyHero.IsTrainingSkill(Magic.wMagicId) then begin
            for I := PlayObject.m_MyHero.m_MagicList.Count - 1 downto 0 do begin
              if PlayObject.m_MyHero.m_MagicList.Count <= 0 then Break;
              UserMagic := PlayObject.m_MyHero.m_MagicList.Items[I];
              if UserMagic <> nil then begin
                if UserMagic.MagicInfo.sMagicName = OldMagic then begin
                  New(UserMagic1);
                  UserMagic1.MagicInfo := Magic;
                  UserMagic1.wMagIdx := Magic.wMagicId;
                  UserMagic1.btKey := UserMagic.btKey;
                  UserMagic1.btLevel := UserMagic.btLevel;
                  UserMagic1.nTranPoint := 0;
                  UserMagic1.btLevelEx:= 0;
                  PlayObject.m_MyHero.m_MagicList.Delete(I);//内存泄露
                  //防止释放内存后的非法访问 By TasNat at: 2012-03-11
                  //PlayObject.m_MyHero.m_MagicOfDelList.Add(UserMagic);
                  
                  THeroObject(PlayObject.m_MyHero).SendDelMagic(UserMagic);
                  PlayObject.m_MyHero.m_MagicList.Add(UserMagic1);
                  THeroObject(PlayObject.m_MyHero).SendAddMagic(UserMagic1);
                  PlayObject.m_MyHero.RecalcAbilitys();//20081213
                  PlayObject.m_MyHero.CompareSuitItem(False);//200080729 套装
                  Dispose(UserMagic);
                  Break;
                end;
              end;
            end;//for
          end;
        end;
      end;
      {$IFEND}
    end else begin
      Magic := UserEngine.FindMagic(NewMagic);
      if Magic <> nil then begin
        if not PlayObject.IsTrainingSkill(Magic.wMagicId) then begin
          for I := PlayObject.m_MagicList.Count - 1 downto 0 do begin
            if  PlayObject.m_MagicList.Count <= 0 then Break;
            UserMagic := PlayObject.m_MagicList.Items[I];
            if UserMagic <> nil then begin
              if UserMagic.MagicInfo.sMagicName = OldMagic then begin
                New(UserMagic1);
                UserMagic1.MagicInfo := Magic;
                UserMagic1.wMagIdx := Magic.wMagicId;
                UserMagic1.btKey := UserMagic.btKey;
                UserMagic1.btLevel := UserMagic.btLevel;
                UserMagic1.nTranPoint := 0;
                UserMagic1.btLevelEx:= 0;
                PlayObject.m_MagicList.Delete(I);
                //防止释放内存后的非法访问 By TasNat at: 2012-03-11 
                //PlayObject.m_MagicOfDelList.Add(UserMagic);                
                PlayObject.SendDelMagic(UserMagic);
                PlayObject.m_MagicList.Add(UserMagic1);
                PlayObject.SendAddMagic(UserMagic1);
                PlayObject.RecalcAbilitys();
                PlayObject.CompareSuitItem(False);
                Dispose(UserMagic);
                Break;
              end;
            end;
          end;//for
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeSkillEX',[g_sExceptionVer]));
  end;
end;
//-----------------------------------------------------------------------------
//功能:自动寻路 20080617
//格式:AUTOGOTOXY X Y
procedure TNormNpc.ActionOfAUTOGOTOXY(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  nX, nY:Integer;
begin
  try
    nX:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam1), 0);//X
    nY:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2), 0);//Y
    PlayObject.SendMsg(Self, RM_AUTOGOTOXY, 0, nX, nY, 0, '');
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfAUTOGOTOXY',[g_sExceptionVer]));
  end;
end;
//-----------------------------------------------------------------------------
//修理全身装备 20080613
//格式：RepairAll (HERO)
procedure TNormNpc.ActionOfRepairAll(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  nWhere: Integer;
//  sCheckItemName: string;
  StdItem: pTStdItem;
begin
try
  if CompareText(QuestActionInfo.sParam1, 'HERO') = 0 then begin
    {$IF HEROVERSION = 1}
    if PlayObject.m_MyHero <> nil then begin
      for nWhere := Low(THumanUseItems) to High(THumanUseItems) do begin//9格装备+4格装备
        if PlayObject.m_MyHero.m_UseItems[nWhere].wIndex > 0 then begin
          StdItem := UserEngine.GetStdItem(PlayObject.m_MyHero.m_UseItems[nWhere].wIndex);
          if StdItem <> nil then begin
            if ((PlayObject.m_MyHero.m_UseItems[nWhere].DuraMax div 1000) > (PlayObject.m_MyHero.m_UseItems[nWhere].Dura div 1000)) and (StdItem.StdMode<>7) and (StdItem.StdMode<>25) and (StdItem.StdMode<>43) and (StdItem.AniCount<>21) then begin
              if CheckItemValue(@PlayObject.m_MyHero.m_UseItems[nWhere], 3) then Continue //20080314 禁止修
              else
              {if Assigned(zPlugOfEngine.CheckCanRepairItem) then begin
                sCheckItemName := StdItem.Name;
                if not zPlugOfEngine.CheckCanRepairItem(PlayObject, PChar(sCheckItemName)) then Continue;//检查是否是不能修复的物品
              end;}
              if PlayObject.m_MyHero.PlugOfCheckCanItem(3, StdItem.Name, False, 0, 0) then Continue;//禁止物品规则(管理插件功能) 20080729

              PlayObject.m_MyHero.m_UseItems[nWhere].Dura := PlayObject.m_MyHero.m_UseItems[nWhere].DuraMax;
              PlayObject.SendMsg(PlayObject.m_MyHero, RM_HERODURACHANGE, nWhere, PlayObject.m_MyHero.m_UseItems[nWhere].Dura, PlayObject.m_MyHero.m_UseItems[nWhere].DuraMax, 0, '');
            end;//if ((m_UseItems[nWhere].DuraMax div 1000)
          end;//if StdItem <> nil then begin
        end;
      end;
    end;
    {$IFEND}
  end else begin
    for nWhere := Low(THumanUseItems) to High(THumanUseItems) do begin//9格装备+4格装备
      if PlayObject.m_UseItems[nWhere].wIndex > 0 then begin
        StdItem := UserEngine.GetStdItem(PlayObject.m_UseItems[nWhere].wIndex);
        if StdItem <> nil then begin
          if ((PlayObject.m_UseItems[nWhere].DuraMax div 1000) > (PlayObject.m_UseItems[nWhere].Dura div 1000)) and (StdItem.StdMode<>7) and (StdItem.StdMode<>25) and (StdItem.StdMode<>43) and (StdItem.AniCount<>21) then begin
            if CheckItemValue(@PlayObject.m_UseItems[nWhere], 3) then Continue //20080314 禁止修
            else
            {if Assigned(zPlugOfEngine.CheckCanRepairItem) then begin
              sCheckItemName := StdItem.Name;
              if not zPlugOfEngine.CheckCanRepairItem(PlayObject, PChar(sCheckItemName)) then Continue;//检查是否是不能修复的物品
            end; }
            if PlayObject.PlugOfCheckCanItem(3, StdItem.Name, False, 0, 0) then Continue;//禁止物品规则(管理插件功能) 20080729

            PlayObject.m_UseItems[nWhere].Dura := PlayObject.m_UseItems[nWhere].DuraMax;
            PlayObject.SendMsg(PlayObject, RM_DURACHANGE, nWhere, PlayObject.m_UseItems[nWhere].Dura, PlayObject.m_UseItems[nWhere].DuraMax, 0, '');
          end;//if ((m_UseItems[nWhere].DuraMax div 1000)
        end;//if StdItem <> nil then begin
      end;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfRepairAll',[g_sExceptionVer]));
end;
end;
//-----------------------------------------------------------------------------
//踢除服务器所有人物 20080609
//格式:KICKALLPLAY
procedure TNormNpc.ActionOfKICKALLPLAY(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  I: Integer;
begin
try
  if UserEngine.m_PlayObjectList.Count > 0 then begin//20080629
    for I := 0 to UserEngine.m_PlayObjectList.Count - 1 do begin
      TPlayObject(UserEngine.m_PlayObjectList.Objects[I]).m_boKickFlag := True;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfKICKALLPLAY',[g_sExceptionVer]));
end;
end;
//-----------------------------------------------------------------------------
//功能：设置所有行会攻城 20080609
//格式：ADDATTACKSABUKALL 城堡号
procedure TNormNpc.ActionOfADDATTACKSABUKALL(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  Castle: TUserCastle;
  nIndex, I: Integer;
  Guild: TGUild;
  sFileName: string;
  LoadLis: TStringList;
begin
  //20110411 注释
  {nIndex:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam1), 0);//城堡ID
  Castle := g_CastleManager.GetCastle(nIndex);
  if g_GuildManager.GuildList.Count > 0 then begin
    for I := 0 to g_GuildManager.GuildList.Count - 1 do begin
      Guild := TGUild(g_GuildManager.GuildList.Items[I]);
      Castle.AddAttackerInfo(Guild,1);//20110411 注释
      //Castle.m_AttackGuildList.Add(Guild);//加入当前攻城列表 20080816
    end;
  end;}
  try
    nIndex:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam1), 0);//城堡ID
    Castle := g_CastleManager.GetCastle(nIndex);
    if Castle <> nil then begin
      if not DirectoryExists(g_Config.sCastleDir + Castle.m_sConfigDir) then begin
        CreateDir(g_Config.sCastleDir + Castle.m_sConfigDir);
      end;
      sFileName := g_Config.sCastleDir + Castle.m_sConfigDir + '\AttackSabukWall.txt';
      LoadLis := TStringList.Create;
      try
        if g_GuildManager.GuildList.Count > 0 then begin
          for I := 0 to g_GuildManager.GuildList.Count - 1 do begin
            Guild := TGUild(g_GuildManager.GuildList.Items[I]);
            LoadLis.Add(Format('%s    "%s"', [Guild.sGuildName, FormatDateTime('yyyy-mm-dd', Now)]));
          end;
        end;
        try
          LoadLis.SaveToFile(sFileName);
        except
          MainOutMessage(Format('{%s} TNormNpc.ActionOfADDATTACKSABUKALL 保存攻城信息失败:%s',[g_sExceptionVer,sFileName]));
        end;
        Castle.LoadAttackSabukWall;
      finally
        LoadLis.Free;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfADDATTACKSABUKALL',[g_sExceptionVer]));
  end;
end;
//-----------------------------------------------------------------------------
//功能:连接指定网站网址 20080602
//格式:WebBrowser http://www.zhaopk.net
procedure TNormNpc.ActionOfWEBBROWSER(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  Url: string;
begin
try
  Url := GetLineVariableText(PlayObject, QuestActionInfo.sParam1);
  if Url ='' then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sWEBBROWSER);
    Exit;
  end;
  if pos('http://', Url) = 0 then Url := 'http://'+Url;
  PlayObject.SendMsg(Self, RM_Browser, 0, 0, 0, 0, Url);
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfWEBBROWSER',[g_sExceptionVer]));
end;
end;
//播放指定的视频文件 20100929
procedure TNormNpc.ActionOfPALYVIDEO(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  Url: string;
begin
  try
    Url := GetLineVariableText(PlayObject, QuestActionInfo.sParam1);
    if Url ='' then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sPALYVIDEO);
      Exit;
    end;
    if QuestActionInfo.sParam2 <> '' then URL:= URL+' '+QuestActionInfo.sParam2;//防止文件名有空格的情况，如wav\Game over2.wav
    PlayObject.SendMsg(Self, RM_PALYVIDEO, 0, 0, 0, 0, Url);
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfPALYVIDEO',[g_sExceptionVer]));
  end;
end;
//取指定排行榜指定排名的玩家名字 20080531
//格式:GETSORTNAME 变量 Type(排行榜) 名次
//nType 1-等级榜 2-战士榜 3-法师榜 4-道士榜
procedure TNormNpc.ActionOfGETSORTNAME(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  nType: Byte;
  nIndex,n14: Integer;
//  StringList: TStringList;
//  UserLevelSort: pTUserLevelSort;
begin
  try
    n14 := GetValNameNo(QuestActionInfo.sParam1);//变量
    nType:= QuestActionInfo.nParam2;//排行榜类型
    nIndex:= QuestActionInfo.nParam3;//名次
    if (n14 < 600) or (not nType in [1..4]) or (nIndex <= 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sGETSORTNAME);
      Exit;
    end;
    EnterCriticalSection(HumanSortCriticalSection);
    try
      case nType of
        1: begin
          if (nIndex -1) <= g_TaxisAllList.nMaxIdx then begin
            if (n14 >= 600) then begin
              case n14 of
                600..699: PlayObject.m_sString[n14 - 600] := g_TaxisAllList.List[nIndex -1].sChrName;
                700..799: g_Config.GlobalAVal[n14 - 700] := g_TaxisAllList.List[nIndex -1].sChrName;
                1200..2099: g_Config.GlobalAVal[n14 - 1100] := g_TaxisAllList.List[nIndex -1].sChrName;
              end;
            end;
          end;
        end;
        2: begin
          if (nIndex -1) <= g_TaxisWarrList.nMaxIdx then begin
            if (n14 >= 600) then begin
              case n14 of
                600..699: PlayObject.m_sString[n14 - 600] := g_TaxisWarrList.List[nIndex -1].sChrName;
                700..799: g_Config.GlobalAVal[n14 - 700] := g_TaxisWarrList.List[nIndex -1].sChrName;
                1200..2099: g_Config.GlobalAVal[n14 - 1100] := g_TaxisWarrList.List[nIndex -1].sChrName;
              end;
            end;
          end;
        end;
        3: begin
          if (nIndex -1) <= g_TaxisWaidList.nMaxIdx then begin
            if (n14 >= 600) then begin
              case n14 of
                600..699: PlayObject.m_sString[n14 - 600] := g_TaxisWaidList.List[nIndex -1].sChrName;
                700..799: g_Config.GlobalAVal[n14 - 700] := g_TaxisWaidList.List[nIndex -1].sChrName;
                1200..2099: g_Config.GlobalAVal[n14 - 1100] := g_TaxisWaidList.List[nIndex -1].sChrName;
              end;
            end;
          end;
        end;
        4: begin
          if (nIndex -1) <= g_TaxisTaosList.nMaxIdx then begin
            if (n14 >= 600) then begin
              case n14 of
                600..699: PlayObject.m_sString[n14 - 600] := g_TaxisTaosList.List[nIndex -1].sChrName;
                700..799: g_Config.GlobalAVal[n14 - 700] := g_TaxisTaosList.List[nIndex -1].sChrName;
                1200..2099: g_Config.GlobalAVal[n14 - 1100] := g_TaxisTaosList.List[nIndex -1].sChrName;
              end;
            end;
          end;
        end;
      end;
    finally
      LeaveCriticalSection(HumanSortCriticalSection);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfGETSORTNAME',[g_sExceptionVer]));
  end;
end;

//卧龙 20080119
procedure TNormNpc.ActionOfOPENBOOKS(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
begin
try
  if QuestActionInfo.nParam1 in [0..5] then
    PlayObject.SendMsg(Self, RM_OPENBOOKS, 0, QuestActionInfo.nParam1{参数}, 0, 0, '');
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfOPENBOOKS',[g_sExceptionVer]));
end;
end;
//=========================元宝寄售系统=========================================
//开通元宝交易 20080316
procedure TNormNpc.ActionOfOPENYBDEAL(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nGameGold:Integer;
begin
try
  if PlayObject.bo_YBDEAL then begin
    PlayObject.SendMsg(Self, RM_MERCHANTSAY, 0, 0, 0, 1, m_sCharName+'/您已开通寄售服务,不需要再开通！！！\ \<返回/@main>');
    Exit;//如已开通元宝服务则退出
  end;
  nGameGold := Str_ToInt(QuestActionInfo.sParam1, 0);
  if not (nGameGold > 0) then nGameGold:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam1), 0);
  if PlayObject.m_nGameGold >= nGameGold then begin//玩家的元宝数大于或等于开通所需的元宝数
    Dec(PlayObject.m_nGameGold,nGameGold);
    PlayObject.bo_YBDEAL:=True;
    PlayObject.SendMsg(Self, RM_MERCHANTSAY, 0, 0, 0, 1, m_sCharName+'/开通寄售服务成功！！！\ \<返回/@main>');
  end else PlayObject.SendMsg(Self, RM_MERCHANTSAY, 0, 0, 0, 1, m_sCharName+'/您身上没有'+g_Config.sGameGoldName+',或'+g_Config.sGameGoldName+'数不够！！！\ \<返回/@main>');
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfOPENYBDEAL',[g_sExceptionVer]));
end;
end;

//(元宝)查询正在出售的物品 20080317
procedure TNormNpc.ActionOfQUERYYBSELL(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I,K: Integer;
  DealOffInfo: TDealOffInfo;
  sSendStr, sUserItemName: String;
  sClientDealOffInfo: TClientDealOffInfo;
  StdItem: pTStdItem;
  StdItem80: TStdItem;
  bo12: Boolean;
begin
try
  bo12:= False;
  if PlayObject.bo_YBDEAL then begin //已开通元宝服务
    if PlayObject.SellOffInTime(0) then begin
      if sSellOffItemList.Count > 0 then begin//20080629
        for I := 0 to sSellOffItemList.Count - 1 do begin
          DealOffInfo:= pTDealOffInfo(sSellOffItemList.Items[I])^;
          if (CompareText(DealOffInfo.sDealCharName, PlayObject.m_sCharName) = 0 ) and (DealOffInfo.N in [0,3]) then begin
              for K:=0 to 9 do begin
                StdItem := UserEngine.GetStdItem(DealOffInfo.UseItems[K].wIndex);
                if (StdItem = nil) then begin
                  if not bo12 and (DealOffInfo.UseItems[K].MakeIndex > 0 ) and (DealOffInfo.UseItems[K].wIndex=High(Word)) and  //是金刚石
                   (DealOffInfo.UseItems[K].Dura = High(Word)) and (DealOffInfo.UseItems[K].DuraMax = High(Word)) then begin
                     with sClientDealOffInfo.UseItems[K] do begin
                       s.Name:= g_Config.sGameDiaMond{'金刚石'}+'('+Inttostr(DealOffInfo.UseItems[K].MakeIndex)+')';
                       s.Price:= DealOffInfo.UseItems[K].MakeIndex;//金刚石数量
                       Dura := High(Word); //客户端金刚石特征 20080319
                       s.DuraMax := High(Word); //客户端金刚石特征 20080319
                       s.Looks:= High(Word);//不显示图片 20080319
                       bo12:= True;
                     end;
                  end else sClientDealOffInfo.UseItems[K].s.Name :='';
                  Continue;
                end;
                StdItem80:=StdItem^;
                ItemUnit.GetItemAddValue(@DealOffInfo.UseItems[K], StdItem80);
                Move(StdItem80, sClientDealOffInfo.UseItems[K].s, SizeOf(TStdItem));

                //取自定义物品名称
                sUserItemName := '';
                if DealOffInfo.UseItems[K].btValue[13] = 1 then
                  sUserItemName := ItemUnit.GetCustomItemName(DealOffInfo.UseItems[K].MakeIndex, DealOffInfo.UseItems[K].wIndex);
                if (DealOffInfo.UseItems[K].btValue[12] = 1) and (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) then sClientDealOffInfo.UseItems[K].s.Reserved1:=1 //物品发光 20080223
                else sClientDealOffInfo.UseItems[K].s.Reserved1:= 0;

                if sUserItemName <> '' then
                  sClientDealOffInfo.UseItems[K].s.Name := sUserItemName;

                sClientDealOffInfo.UseItems[K].MakeIndex := DealOffInfo.UseItems[K].MakeIndex;
                sClientDealOffInfo.UseItems[K].Dura := DealOffInfo.UseItems[K].Dura;
                sClientDealOffInfo.UseItems[K].DuraMax := DealOffInfo.UseItems[K].DuraMax;
                //Modified By TasNat at: 2012-04-12 09:28:18
                sClientDealOffInfo.UseItems[K].btAppraisalLevel :=   DealOffInfo.UseItems[K].btAppraisalLevel;
                sClientDealOffInfo.UseItems[K].btUnKnowValueCount := DealOffInfo.UseItems[K].btUnKnowValueCount;
                Move(DealOffInfo.UseItems[K].btAppraisalValue, sClientDealOffInfo.UseItems[K].btAppraisalValue, SizeOf(DealOffInfo.UseItems[K].btAppraisalValue));
                Move(DealOffInfo.UseItems[K].btUnKnowValue, sClientDealOffInfo.UseItems[K].btUnKnowValue, SizeOf(sClientDealOffInfo.UseItems[K].btUnKnowValue));//20101024 增加

                Case StdItem.StdMode of
                  {$IF M2Version <> 2}
                  5, 6: begin
                    sClientDealOffInfo.UseItems[K].s.NeedIdentify:= _MIN(High(Byte),DealOffInfo.UseItems[K].btValue[11] + DealOffInfo.UseItems[K].btValue[20]);//武器暴击等级 20100708
                    if PlayObject.CheckItemSpiritMedia(DealOffInfo.UseItems[K]) then begin
                      sClientDealOffInfo.UseItems[K].Aura:= DealOffInfo.UseItems[K].btValue[12];
                      sClientDealOffInfo.UseItems[K].MaxAura:= g_Config.nMaxAuraValue;
                    end;
                  end;
                  44: begin
                    if StdItem.shape = 255 then sClientDealOffInfo.UseItems[K].s.NeedLevel:= DealOffInfo.UseItems[K].btValue[0];
                    if StdItem.Shape = 253 then begin//除魔灵媒
                      sClientDealOffInfo.UseItems[K].Aura:= DealOffInfo.UseItems[K].btValue[11];
                      sClientDealOffInfo.UseItems[K].MaxAura:= g_Config.nMaxAuraValue;
                    end;
                  end;
                  10,11,16,27..30,52,54,55,62,64: begin
                    if PlayObject.CheckItemSpiritMedia(DealOffInfo.UseItems[K]) then begin
                      sClientDealOffInfo.UseItems[K].Aura:= DealOffInfo.UseItems[K].btValue[11];
                      sClientDealOffInfo.UseItems[K].MaxAura:= g_Config.nMaxAuraValue;
                    end;
                  end;
                  {$IFEND}
                  15,19..24, 26:begin
                    if DealOffInfo.UseItems[K].btValue[8] <> 0 then sClientDealOffInfo.UseItems[K].s.Shape := 130;
                    {$IF M2Version <> 2}
                    if PlayObject.CheckItemSpiritMedia(DealOffInfo.UseItems[K]) then begin
                      sClientDealOffInfo.UseItems[K].Aura:= DealOffInfo.UseItems[K].btValue[11];
                      sClientDealOffInfo.UseItems[K].MaxAura:= g_Config.nMaxAuraValue;
                    end;
                    {$IFEND}
                  end;
                  //50: sClientDealOffInfo.UseItems[K].s.Name := sClientDealOffInfo.UseItems[K].s.Name + ' #' + IntToStr(DealOffInfo.UseItems[K].Dura);//20080808 注释
                  60:begin
                    if (StdItem.shape <> 0) then begin//酒类,除烧酒外 20080622
                      if DealOffInfo.UseItems[K].btValue[0] <> 0 then sClientDealOffInfo.UseItems[K].s.AC:=DealOffInfo.UseItems[K].btValue[0];//酒的品质
                      if DealOffInfo.UseItems[K].btValue[1] <> 0 then sClientDealOffInfo.UseItems[K].s.MAC:=DealOffInfo.UseItems[K].btValue[1];//酒的酒精度
                      if DealOffInfo.UseItems[K].btValue[3] > 0 then sClientDealOffInfo.UseItems[K].s.NeedLevel:=DealOffInfo.UseItems[K].btValue[3]//酒等级
                      else sClientDealOffInfo.UseItems[K].s.NeedLevel:= 0;
                    end;
                  end;
                end;
              end;
              sClientDealOffInfo.sDealCharName:= DealOffInfo.sDealCharName;
              sClientDealOffInfo.sBuyCharName:= DealOffInfo.sBuyCharName;
              sClientDealOffInfo.dSellDateTime:= DealOffInfo.dSellDateTime;
              sClientDealOffInfo.nSellGold:= DealOffInfo.nSellGold;
              sClientDealOffInfo.N:= DealOffInfo.N;
              sSendStr := EncodeBuffer(@sClientDealOffInfo, SizeOf(TClientDealOffInfo));
              PlayObject.SendMsg(Self, RM_QUERYYBSELL, 0, 0, 0, 0, sSendStr);
              Break;
          end;
        end;//for
      end;
    end else GotoLable(PlayObject, '@AskYBSellFail', False, False);
  end else PlayObject.SendMsg(PlayObject, RM_MENU_OK, 0, Integer(PlayObject), 0, 0, '您未开通元宝寄售服务,请先开通！！！');
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfQUERYYBSELL',[g_sExceptionVer]));
end;
end;

//(元宝)查询可以的购买物品 20080317
procedure TNormNpc.ActionOfQUERYYBDEAL(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I, K: Integer;
  DealOffInfo: TDealOffInfo;
  sSendStr, sUserItemName: String;
  sClientDealOffInfo: TClientDealOffInfo;
  StdItem: pTStdItem;
  StdItem80: TStdItem;
  bo12: Boolean;
begin
try
  bo12:= False;
  if PlayObject.bo_YBDEAL then begin //已开通元宝服务
    if PlayObject.SellOffInTime(1) then begin
      if sSellOffItemList.Count > 0 then begin//20080629
        for I := 0 to sSellOffItemList.Count - 1 do begin
          DealOffInfo:= pTDealOffInfo(sSellOffItemList.Items[I])^;
          if (CompareText(DealOffInfo.sBuyCharName, PlayObject.m_sCharName) = 0 ) and (DealOffInfo.N = 0) then begin
              for K:=0 to 9 do begin
                StdItem := UserEngine.GetStdItem(DealOffInfo.UseItems[K].wIndex);
                if StdItem = nil then begin
                  if not bo12 and (DealOffInfo.UseItems[K].MakeIndex > 0 ) and (DealOffInfo.UseItems[K].wIndex=High(Word)) and  //是金刚石
                   (DealOffInfo.UseItems[K].Dura = High(Word)) and (DealOffInfo.UseItems[K].DuraMax = High(Word)) then begin
                     with sClientDealOffInfo.UseItems[K] do begin
                       s.Name:= g_Config.sGameDiaMond{'金刚石'}+'('+Inttostr(DealOffInfo.UseItems[K].MakeIndex)+')';
                       s.Price:= DealOffInfo.UseItems[K].MakeIndex;//金刚石数量
                       Dura := High(Word); //客户端金刚石特征 20080319
                       s.DuraMax := High(Word); //客户端金刚石特征 20080319
                       s.Looks:= High(Word);//不显示图片 20080319
                       bo12:= True;
                     end;
                  end else sClientDealOffInfo.UseItems[K].s.Name :='';
                  Continue;
                end;
                StdItem80:=StdItem^;
                ItemUnit.GetItemAddValue(@DealOffInfo.UseItems[K],StdItem80);
                Move(StdItem80, sClientDealOffInfo.UseItems[K].s, SizeOf(TStdItem));

                //取自定义物品名称
                sUserItemName := '';
                if DealOffInfo.UseItems[K].btValue[13] = 1 then
                  sUserItemName := ItemUnit.GetCustomItemName(DealOffInfo.UseItems[K].MakeIndex, DealOffInfo.UseItems[K].wIndex);
                if (DealOffInfo.UseItems[K].btValue[12] = 1) and (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) then sClientDealOffInfo.UseItems[K].s.Reserved1:=1 //物品发光 20080223
                else sClientDealOffInfo.UseItems[K].s.Reserved1:= 0;

                if sUserItemName <> '' then
                  sClientDealOffInfo.UseItems[K].s.Name := sUserItemName;

                sClientDealOffInfo.UseItems[K].MakeIndex := DealOffInfo.UseItems[K].MakeIndex;
                sClientDealOffInfo.UseItems[K].Dura := DealOffInfo.UseItems[K].Dura;
                sClientDealOffInfo.UseItems[K].DuraMax := DealOffInfo.UseItems[K].DuraMax;
                //Modified By TasNat at: 2012-04-12 09:28:18
                sClientDealOffInfo.UseItems[K].btAppraisalLevel :=   DealOffInfo.UseItems[K].btAppraisalLevel;
                sClientDealOffInfo.UseItems[K].btUnKnowValueCount := DealOffInfo.UseItems[K].btUnKnowValueCount;
                Move(DealOffInfo.UseItems[K].btAppraisalValue, sClientDealOffInfo.UseItems[K].btAppraisalValue, SizeOf(DealOffInfo.UseItems[K].btAppraisalValue));

                Move(DealOffInfo.UseItems[K].btUnKnowValue, sClientDealOffInfo.UseItems[K].btUnKnowValue, SizeOf(sClientDealOffInfo.UseItems[K].btUnKnowValue));//20101024 增加

                Case StdItem.StdMode of
                  {$IF M2Version <> 2}
                  5,6: begin
                    sClientDealOffInfo.UseItems[K].s.NeedIdentify:= _MIN(High(Byte),DealOffInfo.UseItems[K].btValue[11] + DealOffInfo.UseItems[K].btValue[20]);//武器暴击等级 20100708
                    if PlayObject.CheckItemSpiritMedia(DealOffInfo.UseItems[K]) then begin
                      sClientDealOffInfo.UseItems[K].Aura:= DealOffInfo.UseItems[K].btValue[12];
                      sClientDealOffInfo.UseItems[K].MaxAura:= g_Config.nMaxAuraValue;
                    end;
                  end;
                  44: begin
                    if StdItem.shape = 255 then sClientDealOffInfo.UseItems[K].s.NeedLevel:= DealOffInfo.UseItems[K].btValue[0];
                    if StdItem.Shape = 253 then begin//除魔灵媒
                      sClientDealOffInfo.UseItems[K].Aura:= DealOffInfo.UseItems[K].btValue[11];
                      sClientDealOffInfo.UseItems[K].MaxAura:= g_Config.nMaxAuraValue;
                    end;
                  end;
                  10,11,16,27..30,52,54,55,62,64: begin
                    if PlayObject.CheckItemSpiritMedia(DealOffInfo.UseItems[K]) then begin
                      sClientDealOffInfo.UseItems[K].Aura:= DealOffInfo.UseItems[K].btValue[11];
                      sClientDealOffInfo.UseItems[K].MaxAura:= g_Config.nMaxAuraValue;
                    end;
                  end;
                  {$IFEND}
                  15, 19..24, 26:begin
                    if DealOffInfo.UseItems[K].btValue[8] <> 0 then sClientDealOffInfo.UseItems[K].s.Shape := 130;
                    {$IF M2Version <> 2}
                    if PlayObject.CheckItemSpiritMedia(DealOffInfo.UseItems[K]) then begin
                      sClientDealOffInfo.UseItems[K].Aura:= DealOffInfo.UseItems[K].btValue[11];
                      sClientDealOffInfo.UseItems[K].MaxAura:= g_Config.nMaxAuraValue;
                    end;
                    {$IFEND}
                  end;
                  //50:sClientDealOffInfo.UseItems[K].s.Name := sClientDealOffInfo.UseItems[K].s.Name + ' #' + IntToStr(DealOffInfo.UseItems[K].Dura); //20080808 注释
                  60:begin
                    if (StdItem.shape <> 0) then begin//酒类,除烧酒外 20080622
                      if DealOffInfo.UseItems[K].btValue[0] <> 0 then sClientDealOffInfo.UseItems[K].s.AC:=DealOffInfo.UseItems[K].btValue[0];//酒的品质
                      if DealOffInfo.UseItems[K].btValue[1] <> 0 then sClientDealOffInfo.UseItems[K].s.MAC:=DealOffInfo.UseItems[K].btValue[1];//酒的酒精度
                      if DealOffInfo.UseItems[K].btValue[3] > 0 then sClientDealOffInfo.UseItems[K].s.NeedLevel:=DealOffInfo.UseItems[K].btValue[3]//酒等级
                      else sClientDealOffInfo.UseItems[K].s.NeedLevel:= 0;
                    end;
                  end;
                end;
              end;
              sClientDealOffInfo.sDealCharName:= DealOffInfo.sDealCharName;
              sClientDealOffInfo.sBuyCharName:= DealOffInfo.sBuyCharName;
              sClientDealOffInfo.dSellDateTime:= DealOffInfo.dSellDateTime;
              sClientDealOffInfo.nSellGold:= DealOffInfo.nSellGold;
              sClientDealOffInfo.N:= DealOffInfo.N;
              sSendStr := EncodeBuffer(@sClientDealOffInfo, SizeOf(TClientDealOffInfo));
              PlayObject.SendMsg(Self, RM_QUERYYBDEAL, 0, 0, 0, 0, sSendStr);
              Break;
          end;
        end;//for
      end;
    end else GotoLable(PlayObject, '@AskYBDealFail', False, False);
  end else PlayObject.SendMsg(PlayObject, RM_MENU_OK, 0, Integer(PlayObject), 0, 0, '您未开通元宝寄售服务,请先开通！！！');
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfQUERYYBDEAL',[g_sExceptionVer]));
end;
end;
//==============================================================================
//改变穿人模式 20080221    THROUGHHUM M S //M:模式[-1=恢复/0=穿人穿怪/1=穿怪/2=穿人] S:时间(秒)
procedure TNormNpc.ActionOfTHROUGHHUM(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  nMode:Integer;
begin
  try
    nMode:= QuestActionInfo.nParam1;//模式[-1=恢复/0=穿人穿怪/1=穿怪/2=穿人]
    PlayObject.dwRunHumanModeTime:= QuestActionInfo.nParam2 * 1000; //时间(秒)

    case nMode of
      -1: begin
          g_Config.boRUNHUMAN := Config.ReadBool('Setup', 'RunHuman', g_Config.boRUNHUMAN);
          g_Config.boRUNMON := Config.ReadBool('Setup', 'RunMon', g_Config.boRUNMON);
        end;
       0: begin
         g_Config.boRUNHUMAN:= True;//穿人
         g_Config.boRUNMON:= True;//穿怪
         PlayObject.dwRunHumanModeTick:= GetTickCount();
         PlayObject.m_boRunHumanMode:= True;
        end;
       1: begin
         g_Config.boRUNMON:= True;//穿怪
         PlayObject.dwRunHumanModeTick:= GetTickCount();
         PlayObject.m_boRunHumanMode:= True;
        end;
       2: begin
         g_Config.boRUNHUMAN:= True;//穿人
         PlayObject.dwRunHumanModeTick:= GetTickCount();
         PlayObject.m_boRunHumanMode:= True;
        end;
    end;
    PlayObject.SendServerConfig;//发送配置信息到客户端
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfTHROUGHHUM',[g_sExceptionVer]));
  end;
end;
//-----------------------------------------------------------------------------
//装备发光设置 20080223   格式:SetItemsLight 装备位置(0-12) 是否发光(1发光，0不发光)
procedure TNormNpc.ActionOfSetItemsLight(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  nItem, nLight:Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
try
  nItem:= Str_ToInt(QuestActionInfo.sParam1, -1);//装备位置
  nLight:= Str_ToInt(QuestActionInfo.sParam2, 0);//是否发光
  if nItem < 0 then GetValValue(PlayObject, QuestActionInfo.sParam1, nItem); //增加变量支持
  if nLight < 0 then GetValValue(PlayObject, QuestActionInfo.sParam2, nLight); //增加变量支持
  if (nItem < 0) or {$IF M2Version <> 2}(nItem > High(THumanUseItems)){$ELSE}(nItem > High(THumItems)){$IFEND} or (not nLight in [0,1]) then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSETITEMSLIGHT);
    Exit;
  end;
  UserItem := @PlayObject.m_UseItems[nItem];
  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
  if (UserItem.wIndex <= 0) or (StdItem = nil) then begin
    //PlayObject.SysMsg('你身上没有戴指定物品！！！', c_Red, t_Hint);
    Exit;
  end;
  if (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) and (StdItem.StdMode <> 10) and (StdItem.StdMode <> 11) and  (StdItem.StdMode <> 15) then begin
     //赋值过程
    UserItem.btValue[12] := nLight;
    PlayObject.SendUpdateItem(UserItem);//更新物品
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfSetItemsLight',[g_sExceptionVer]));
end;
end;
//-----------------------------------------------------------------------------
//打开卧龙宝藏 20080306
//格式:OpenDragonBox 宝箱ID
procedure TNormNpc.ActionOfOpenDragonBox(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  nItem: Integer;
begin
  try
    nItem:= Str_ToInt(QuestActionInfo.sParam1, -1);//宝箱类型
    if nItem < 0 then GetValValue(PlayObject, QuestActionInfo.sParam1, nItem); //增加变量支持
    if nItem < 0 then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sOpenDragonBox);
      Exit;
    end;
    if PlayObject.ClientOpenBoxs(nItem, 0, False, True) then begin//宝箱开启
      PlayObject.n_OpenBoxCount:= 0;
      PlayObject.SendMsg(Self, RM_OPENDRAGONBOXS, 0, 0, 0, 0, '');
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfOpenDragonBox',[g_sExceptionVer]));
  end;
end;
//-----------------------------------------------------------------------------
//功能：打开英雄自我修炼窗口
//格式: OpenHeroAutoPractice
procedure TNormNpc.ActionOfOpenHeroAutoPractice(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
begin
  {$IF HEROVERSION = 1}
  try
    if PlayObject.m_boHasHero and PlayObject.m_boHasHeroTwo and (PlayObject.m_sDeputyHeroName <> '') and PlayObject.m_boCallDeputyHero and (not PlayObject.m_boHeroAutoPractice) then begin
      if PlayObject.m_MyHero <> nil then begin
        if (not PlayObject.m_MyHero.m_boDeath) and (not PlayObject.m_MyHero.m_boGhost) then begin
          PlayObject.SendMsg(Self, RM_OPENHEROAUTOPRA, PlayObject.m_MyHero.m_btJob, PlayObject.m_MyHero.m_btGender, g_Config.nStrength2DecGameGird{中强度灵符数},  g_Config.nStrength3DecGameGird{高强度灵符数}, PlayObject.m_sDeputyHeroName);
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfOpenHeroAutoPractice',[g_sExceptionVer]));
  end;
  {$IFEND}
end;
//功能: 停止英雄自我修炼
//格式：StopHeroAutoPractice
procedure TNormNpc.ActionOfStopHeroAutoPractice(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
begin
  try
    if PlayObject.m_boHeroAutoPractice then begin
      PlayObject.m_boHeroAutoPractice:= False;
      if (PlayObject.m_HeroAutoPracticeTime > 7200) then begin//当超过2小时，机率触发脚本段
        GotoLable(PlayObject, '@StopHeroAuto', False, False);
      end;
      PlayObject.SysMsg('您的副将英雄放养已结束！', c_Blue, t_Hint);
      PlayObject.SysMsg('您的副将英雄自我修炼已结束，召唤副将英雄获得修炼经验或内功经验。', c_Blue, t_Hint);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfStopHeroAutoPractice',[g_sExceptionVer]));
  end;
end;
//-----------------------------------------------------------------------------
//功能：移动到回城点 20080503
//格式:GOHOME
procedure TNormNpc.ActionOfGOHOME(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
begin
try
  if (not PlayObject.m_boDeath) and (not PlayObject.m_boGhost) and (not PlayObject.InMag113LockRect(PlayObject.m_nCurrX, PlayObject.m_nCurrY)) then begin
     PlayObject.MoveToHome();//移动到回城点
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfGOHOME',[g_sExceptionVer]));
end;
end;
//-----------------------------------------------------------------------------
//功能：将指定物品刷新到指定地图坐标范围内 20080508
//格式： THROWITEM 地图 X Y 范围 物品名称 数量
procedure TNormNpc.ActionOfTHROWITEM(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
  function GetDropRandomPosition(nEnvir: TEnvirnoment; nOrgX, nOrgY, nRange: Integer; var nDX: Integer; var nDY: Integer): Boolean;
  var
    I, II, III: Integer;
    nItemCount, n24, n28, n2C: Integer;
  begin
    n24 := 999;
    Result := False;
    n28 := 0; //09/10
    n2C := 0; //09/10
    if nRange <= 0 then nRange:= 1;//20091113 增加
    for I := 1 to nRange do begin
      for II := -I to I do begin
        for III := -I to I do begin
          nDX := nOrgX + Random(nRange) + III;
          nDY := nOrgY + Random(nRange) + II;
          if nEnvir.GetItemEx(nDX, nDY, nItemCount) = nil then begin
            if nEnvir.bo2C then begin
              Result := True;
              Break;
            end;
          end else begin
            if nEnvir.bo2C and (n24 > nItemCount) then begin
              n24 := nItemCount;
              n28 := nDX;
              n2C := nDY;
            end;
          end;
        end;
        if Result then Break;
      end;
      if Result then Break;
    end;
    if not Result then begin
      if n24 < 8 then begin
        nDX := n28;
        nDY := n2C;
      end else begin
        nDX := nOrgX;
        nDY := nOrgY;
      end;
    end;
  end;
var
  sMap, sItemName, sUserItemName: string;
  I, idura, nX, nY, nRange, nCount, dX, dY: Integer;
  Envir: TEnvirnoment;
  MapItem, pr: PTMapItem;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
begin
  try
    sMap:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1); //地图 支持变量
    nX:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2), -1);//X 支持变量
    nY:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam3), -1);//Y 支持变量
    nRange:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam4), -1);//范围 支持变量
    sItemName:= GetLineVariableText(PlayObject,QuestActionInfo.sParam5);//物品名称 支持变量
    nCount:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam6), -1);//数量 支持变量

    if (sMap = '') or (nX < 0) or (nY < 0) or (nRange < 0) or (sItemName = '') or (nCount <= 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sTHROWITEM);
      Exit;
    end;
  
    //if not CanMakeItem(sItemName) then Exit;//是否是禁止制造的物品 20090427
    Envir:= g_MapManager.FindMap(sMap);//查找地图,地图不存在则退出
    if Envir = nil then Exit;
  
    if nCount <= 0 then nCount:= 1;//20081008
    StdItem := UserEngine.GetStdItem(sItemName);
    if StdItem <> nil then begin
      //if PlugOfCheckCanItem(6, StdItem.Name, False, 0, 0) then Exit;//禁止物品规则(永不爆出) 20110529
      for I := 0 to nCount - 1 do begin
        New(UserItem);
        if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
          if UserItem.AddValue[0] = 2 then UserItem.AddValue[0]:= 0;//NPC命令爆出48小时绑定物品不处理 20110707
          if StdItem.StdMode = 40 then begin
            idura := UserItem.Dura;
            idura := idura - 2000;
            if idura < 0 then idura := 0;
            UserItem.Dura := idura;
          end;
          New(MapItem);
          MapItem.UserItem := UserItem^;
          MapItem.Name := StdItem.Name;

          //取自定义物品名称
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then begin
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
            if sUserItemName <> '' then MapItem.Name := sUserItemName;
          end;
          MapItem.Looks := StdItem.Looks;
          if StdItem.StdMode = 45 then MapItem.Looks := GetRandomLook(MapItem.Looks, StdItem.Shape);
          MapItem.AniCount := StdItem.AniCount;
          MapItem.Reserved := 0;
          MapItem.Count := 1;
          MapItem.OfBaseObject := nil;
          MapItem.dwCanPickUpTick := GetTickCount();
          MapItem.DropBaseObject := nil;
          //GetDropPosition(nX, nY, nRange, dx, dy);//取掉物品的位置
          GetDropRandomPosition(Envir, nX, nY, nRange, dx, dy);
          pr := Envir.AddToMap(dx, dy, OS_ITEMOBJECT, TObject(MapItem));
          if pr = MapItem then begin
            SendRefMsg(RM_ITEMSHOW, MapItem.Looks, Integer(MapItem), dx, dy, MapItem.Name);
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('7' + #9 +
                sMap+'(NPC)'+ #9 +
                IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                IntToStr(UserItem.btValue[14])+ #9 + IntToStr(UserItem.Dura)+'/'+IntToStr(UserItem.DuraMax));
          end else begin
            Dispose(MapItem);
            Break;
          end;
        end else Dispose(UserItem);//if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
      end;//for I := 0 to nCount - 1 do begin
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfTHROWITEM',[g_sExceptionVer]));
  end;
end;
//-----------------------------------------------------------------------------
//功能:在指定地图XY内爆出物品(按指定文件爆出物品)，当达到一定时间后，人物才能捡起物品 20090425
//格式：NPCGIVEITEM 地图 X Y 爆率文件全路径(Envir目录下)
procedure TNormNpc.ActionOfNPCGIVEITEM(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
  function GetDropRandomPosition(nEnvir: TEnvirnoment; nOrgX, nOrgY, nRange: Integer; var nDX: Integer; var nDY: Integer): Boolean;
  var
    I, II, III: Integer;
    nItemCount, n24, n28, n2C: Integer;
  begin
    n24 := 999;
    Result := False;
    n28 := 0; //09/10
    n2C := 0; //09/10
    if nRange <= 0 then nRange:=1;//20091113 增加
    for I := 1 to nRange do begin
      for II := -I to I do begin
        for III := -I to I do begin
          nDX := nOrgX {+ Random(nRange)} + III;
          nDY := nOrgY {+ Random(nRange)} + II;
          if nEnvir.GetItemEx(nDX, nDY, nItemCount) = nil then begin
            if nEnvir.bo2C then begin
              Result := True;
              Break;
            end;
          end else begin
            if nEnvir.bo2C and (n24 > nItemCount) then begin
              n24 := nItemCount;
              n28 := nDX;
              n2C := nDY;
            end;
          end;
        end;
        if Result then Break;
      end;
      if Result then Break;
    end;
    if not Result then begin
      if n24 < 8 then begin
        nDX := n28;
        nDY := n2C;
      end else begin
        nDX := nOrgX;
        nDY := nOrgY;
      end;
    end;
  end;
var
  sFileName, s28, sMap, s2C, s30, sUserItemName, s38: String;
  s39, s40, s41: string;
  LoadList, TempList: TStringList;
  I, K, n18, n1C, n20, n21, n22, nX, nY, idura, nCurrX, nCurrY: Integer;
  MapItem, pr: PTMapItem;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  Envir: TEnvirnoment;
begin
  try
    sMap:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1); //地图 支持变量
    nCurrX:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2), -1);//X 支持变量
    nCurrY:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam3), -1);//Y 支持变量
    sFileName:= QuestActionInfo.sParam4;//文本路径
    if (sMap = '') or (nCurrX < 0) or (nCurrY < 0) or (sFileName = '') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sNPCGIVEITEM);
      Exit;
    end;
    if sFileName <> '' then begin
      if sFileName[1] = '\' then sFileName := Copy(sFileName, 2, Length(sFileName) - 1);
      if sFileName[2] = '\' then sFileName := Copy(sFileName, 3, Length(sFileName) - 2);
      if sFileName[3] = '\' then sFileName := Copy(sFileName, 4, Length(sFileName) - 3);
    end;
    sFileName:= g_Config.sEnvirDir + sFileName;
    if FileExists(sFileName) then begin//检查文件是否存在
      Envir:= g_MapManager.FindMap(sMap);//查找地图,地图不存在则退出
      if Envir = nil then Exit;
      LoadList := TStringList.Create;
      LoadList.LoadFromFile(sFileName);
      try
        if LoadList.Count > 0 then begin//20091113 增加
          for I := 0 to LoadList.Count - 1 do begin
            s28 := LoadList.Strings[I];
            if (s28 <> '') and (s28[1] <> ';') then begin
              s28 := GetValidStr3(s28, s30, [' ', '/', #9]);
              n18 := Str_ToInt(s30, -1);//机率值
              s28 := GetValidStr3(s28, s30, [' ', '/', #9]);
              n1C := Str_ToInt(s30, -1);//机率上限值
              s28 := GetValidStr3(s28, s30, [' ', #9]);
              if s30 <> '' then begin
                if s30[1] = '"' then ArrestStringEx(s30, '"', '"', s30);
              end;
              s2C := s30;//物品名称
              s28 := GetValidStr3(s28, s30, [' ', #9]);
              n20 := Str_ToInt(s30, 1);//物品数量
              if (n18 > 0) and (n1C > 0) and (s2C <> '') and (n20 > 0) then begin
                if Random(n1C) <= (n18 - 1) then begin//计算机率 1/10 随机10<=1 即为所得的物品
                  if CompareText(s2C, sSTRING_GOLDNAME) = 0 then begin  //如果是金币
                    New(MapItem);
                    FillChar(MapItem^, SizeOf(TMapItem), #0);
                    MapItem.Name := sSTRING_GOLDNAME;
                    MapItem.Count := n20;
                    MapItem.Looks := GetGoldShape(n20);
                    MapItem.OfBaseObject := Self;
                    MapItem.dwCanPickUpTick := GetTickCount();
                    MapItem.DropBaseObject := Self;

                    GetDropRandomPosition(Envir, nCurrX, nCurrY, 3, nX, nY);
                    pr := Envir.AddToMap(nX, nY, OS_ITEMOBJECT, TObject(MapItem));
                    if pr <> nil then begin
                      if pr <> MapItem then begin
                        Dispose(MapItem);
                        MapItem := pr;
                      end;
                      SendRefMsg(RM_ITEMSHOW, MapItem.Looks, Integer(MapItem), nX, nY, MapItem.Name);
                      if g_boGameLogGold then
                        AddGameDataLog('7' + #9 + sMap +'(NPC)'+ #9 +
                          IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                          m_sCharName + #9 + sSTRING_GOLDNAME + #9 + '#' + #9 +
                          '1' + #9 + IntToStr(n20));
                    end else Dispose(MapItem);
                  end else
                  if CompareLStr(s2C, 'RANDOM', 6) then begin//新模式(爆率) 20110510
                    ArrestStringEx(s2C, '"', '"', s38);
                    if s38 <> '' then begin
                      TempList := TStringList.Create;
                      try
                        ExtractStrings(['|'], [], PChar(s38), TempList);
                        if TempList.Count > 0 then begin
                          for K := 0 to TempList.Count - 1 do begin
                            s39 := TempList.Strings[K];
                            if (s39 <> '') and (s39[1] = '[') then begin
                              s41:= ArrestStringEx(s39, '[', ']', s40);
                              s40 := GetValidStr3(s40, s39, ['/']);
                              n21 := Str_ToInt(s39, -1);
                              n22 := Str_ToInt(s40, -1);
                              if (n21 > 0) and (n22 > 0) and (s41 <> '') then begin
                                if CompareText(s41, sSTRING_GOLDNAME) <> 0 then begin//不是金币
                                  if Random(n22) <= (n21 - 1) then begin//计算机率
                                    StdItem := UserEngine.GetStdItem(s41);
                                    if StdItem <> nil then begin
                                      //if PlugOfCheckCanItem(6, StdItem.Name, False, 0, 0) then Continue;//禁止物品规则(永不爆出) 20110529
                                      New(UserItem);
                                      if UserEngine.CopyToUserItemFromName(s41, UserItem) then begin
                                        if UserItem.AddValue[0] = 2 then UserItem.AddValue[0]:= 0;//爆出48小时绑定物品不处理 20110707
                                        if StdItem.StdMode = 40 then begin
                                          idura := UserItem.Dura;
                                          idura := idura - 2000;
                                          if idura < 0 then idura := 0;
                                          UserItem.Dura := idura;
                                        end;
                                        New(MapItem);
                                        MapItem.UserItem := UserItem^;
                                        MapItem.Name := StdItem.Name;

                                        //取自定义物品名称
                                        sUserItemName := '';
                                        if UserItem.btValue[13] = 1 then begin
                                          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
                                          if sUserItemName <> '' then MapItem.Name := sUserItemName;
                                        end;
                                        MapItem.Looks := StdItem.Looks;
                                        if StdItem.StdMode = 45 then  MapItem.Looks := GetRandomLook(MapItem.Looks, StdItem.Shape);
                                        MapItem.AniCount := StdItem.AniCount;
                                        MapItem.Reserved := 0;
                                        MapItem.Count := 1;
                                        MapItem.OfBaseObject := Self;
                                        MapItem.dwCanPickUpTick := GetTickCount();
                                        MapItem.DropBaseObject := Self;

                                        GetDropRandomPosition(Envir, nCurrX, nCurrY, 3, nX, nY);
                                        pr := Envir.AddToMap(nX, nY, OS_ITEMOBJECT, TObject(MapItem));
                                        if pr = MapItem then begin
                                          SendRefMsg(RM_ITEMSHOW, MapItem.Looks, Integer(MapItem), nX, nY, MapItem.Name);
                                          if StdItem.NeedIdentify = 1 then
                                            AddGameDataLog('7' + #9 +
                                              sMap+'(NPC)'+ #9 +
                                              IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                                              m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                                              '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                                              '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                                              '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                                              '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                                              '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                                              IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                                              IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                                              IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                                              IntToStr(UserItem.btValue[14])+ #9 + IntToStr(UserItem.Dura)+'/'+IntToStr(UserItem.DuraMax));
                                          Break;
                                        end else begin
                                          Dispose(MapItem);
                                          Break;
                                        end;
                                      end else Dispose(UserItem);
                                    end;
                                  end;
                                end;
                              end;
                            end;
                          end;
                        end;
                      finally
                        TempList.Free;
                      end;
                    end;
                  end else begin//非金币
                    StdItem := UserEngine.GetStdItem(s2C);
                    if StdItem <> nil then begin
                      //if PlugOfCheckCanItem(6, StdItem.Name, False, 0, 0) then Continue;//禁止物品规则(永不爆出) 20110529
                      for K := 0 to n20 - 1 do begin
                        New(UserItem);
                        if UserEngine.CopyToUserItemFromName(s2C, UserItem) then begin
                          if UserItem.AddValue[0] = 2 then UserItem.AddValue[0]:= 0;//NPC命令爆出48小时绑定物品不处理 20110707
                          if StdItem.StdMode = 40 then begin
                            idura := UserItem.Dura;
                            idura := idura - 2000;
                            if idura < 0 then idura := 0;
                            UserItem.Dura := idura;
                          end;
                          New(MapItem);
                          MapItem.UserItem := UserItem^;
                          MapItem.Name := StdItem.Name;

                          //取自定义物品名称
                          sUserItemName := '';
                          if UserItem.btValue[13] = 1 then begin
                            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
                            if sUserItemName <> '' then MapItem.Name := sUserItemName;
                          end;
                          MapItem.Looks := StdItem.Looks;
                          if StdItem.StdMode = 45 then  MapItem.Looks := GetRandomLook(MapItem.Looks, StdItem.Shape);
                          MapItem.AniCount := StdItem.AniCount;
                          MapItem.Reserved := 0;
                          MapItem.Count := 1;
                          MapItem.OfBaseObject := Self;
                          MapItem.dwCanPickUpTick := GetTickCount();
                          MapItem.DropBaseObject := Self;

                          GetDropRandomPosition(Envir, nCurrX, nCurrY, 3, nX, nY);
                          pr := Envir.AddToMap(nX, nY, OS_ITEMOBJECT, TObject(MapItem));
                          if pr = MapItem then begin
                            SendRefMsg(RM_ITEMSHOW, MapItem.Looks, Integer(MapItem), nX, nY, MapItem.Name);
                            if StdItem.NeedIdentify = 1 then
                              AddGameDataLog('7' + #9 +
                                sMap+'(NPC)'+ #9 +
                                IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                                m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                                '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                                '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                                '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                                '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                                '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                                IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                                IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                                IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                                IntToStr(UserItem.btValue[14])+ #9 + IntToStr(UserItem.Dura)+'/'+IntToStr(UserItem.DuraMax));
                          end else begin
                            Dispose(MapItem);
                            Break;
                          end;
                        end else Dispose(UserItem);
                      end;//for K := 0 to n20 - 1 do begin
                    end;
                  end;
                end;
              end;
            end;//if (s28 <> '') and (s28[1] <> ';') then begin
          end;//for
        end;
      finally
        LoadList.Free;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfNPCGIVEITEM',[g_sExceptionVer]));
  end;
end;
//-----------------------------------------------------------------------------
//功能:删除指定文本里的编码 20080410
//格式:CLEARCODELIST 玩家变量 文本路径
//例子:CLEARCODELIST <$STR(S1)> ..\questdiary\冲值\500元卡号.txt
procedure TNormNpc.ActionOfCLEARCODELIST(PlayObject: TPlayObject;QuestActionInfo: pTQuestActionInfo);
var
  I: Integer;
  LoadList: TStringList;
  sPlayID , sLine, sFileName: string;
begin
try
  try
    sPlayID := GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//增加变量支持 20080410 用户的变量,即输入的字符
    if (sPlayID = '') then  GetValValue(PlayObject, QuestActionInfo.sParam1, sPlayID);//20080502
    sFileName:= QuestActionInfo.sParam2;//文本路径
    if sFileName <> '' then begin
      if sFileName[1] = '\' then sFileName := Copy(sFileName, 2, Length(sFileName) - 1);
      if sFileName[2] = '\' then sFileName := Copy(sFileName, 3, Length(sFileName) - 2);
      if sFileName[3] = '\' then sFileName := Copy(sFileName, 4, Length(sFileName) - 3);
    end;
    sFileName:= g_Config.sEnvirDir + sFileName;

    LoadList := TStringList.Create;
    if FileExists(sFileName) then begin
      LoadList.LoadFromFile(sFileName);
      if LoadList.Count > 0 then begin//20080629
        for I := 0 to LoadList.Count - 1 do begin
          sLine := Trim(LoadList.Strings[I]);
          if (sLine = '') or (sLine[1] = ';') then Continue;
          if CompareText(sLine, sPlayID) = 0 then begin
            LoadList.Delete(I);
            LoadList.SaveToFile(sFileName);
            Break;
          end;
        end;
      end;
    end else begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sCLEARCODELIST);
    end;
  finally
    LoadList.Free;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfCLEARCODELIST',[g_sExceptionVer]));
end;
end;
//-----------------------------------------------------------------------------
//从文件中随机取文本   格式：GetRandomName 文本(全路径) 字符串变量 指定行
procedure TNormNpc.ActionOfGetRandomName(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
    function GetValNameValue(sVarName: string; var sValue: string; var nValue: Integer; var nDataType: Integer): Boolean;
    var
      n100: Integer;
    begin
      nValue := -1;
      sValue := '';
      nDataType := -1;
      n100 := GetValNameNo(sVarName);
      if n100 >= 0 then begin
        case n100 of
          0..99: begin
              nValue := PlayObject.m_nVal[n100];
              nDataType := 1;
              Result := True;
            end;
          100..199: begin
              nValue := g_Config.GlobalVal[n100 - 100];
              nDataType := 1;
              Result := True;
            end;
          200..299: begin
              nValue := PlayObject.m_DyVal[n100 - 200];
              nDataType := 1;
              Result := True;
            end;
          300..399: begin
              nValue := PlayObject.m_nMval[n100 - 300];
              nDataType := 1;
              Result := True;
            end;
          400..499: begin
              nValue := g_Config.GlobaDyMval[n100 - 400];
              nDataType := 1;
              Result := True;
            end;
          500..599: begin
              nValue := PlayObject.m_nInteger[n100 - 500];
              nDataType := 1;
              Result := True;
            end;
          600..699: begin
              sValue := PlayObject.m_sString[n100 - 600];
              nDataType := 0;
              Result := True;
            end;
          700..799: begin
              sValue := g_Config.GlobalAVal[n100 - 700];
              nDataType := 0;
              Result := True;
            end;
          800..1199:begin//20080903 G变量(100-499)
              nValue := g_Config.GlobalVal[n100 - 700];
              nDataType := 1;
              Result := True;
            end;
          1200..2099:begin//A变量(100-999)
              sValue := g_Config.GlobalAVal[n100 - 1100];
              nDataType := 0;
              Result := True;
            end;
          2100..2599: begin//G变量(500-999)
              nValue := g_Config.GlobalVal[n100 - 1600];
              nDataType := 1;
              Result := True;
            end;
        else begin
            Result := False;
          end;
        end;
      end else Result := False;
    end;
    function SetValNameValue(sVarName: string; sValue: string; nValue: Integer; nDataType: Integer): Boolean;
    var
      n100: Integer;
    begin
      n100 := GetValNameNo(sVarName);
      if n100 >= 0 then begin
        case nDataType of
          1: begin
              case n100 of
                0..99: begin
                    PlayObject.m_nVal[n100] := nValue;
                    Result := True;
                  end;
                100..199: begin
                    g_Config.GlobalVal[n100 - 100] := nValue;
                    Result := True;
                  end;
                200..299: begin
                    PlayObject.m_DyVal[n100 - 200] := nValue;
                    Result := True;
                  end;
                300..399: begin
                    PlayObject.m_nMval[n100 - 300] := nValue;
                    Result := True;
                  end;
                400..499: begin
                    g_Config.GlobaDyMval[n100 - 400] := nValue;
                    Result := True;
                  end;
                500..599: begin
                    PlayObject.m_nInteger[n100 - 500] := nValue;
                    Result := True;
                  end;
                800..1199:begin//20080903 G变量
                    g_Config.GlobalVal[n100 - 700] :=  nValue;
                    Result := True;
                  end;
                2100..2599: begin//G变量(500-999)
                    g_Config.GlobalVal[n100 - 1600] :=  nValue;
                    Result := True;
                  end;
              else begin
                  Result := False;
                end;
              end;
            end;
          0: begin
              case n100 of
                600..699: begin
                    PlayObject.m_sString[n100 - 600] := sValue;
                    Result := True;
                  end;
                700..799: begin
                    g_Config.GlobalAVal[n100 - 700] := sValue;
                    Result := True;
                  end;
                1200..2099:begin//A变量(100-999)
                    g_Config.GlobalAVal[n100 - 1100] := sValue;
                    Result := True;
                  end;
              else begin
                  Result := False;
                end;
              end;
            end;
          3: begin
              case n100 of
                0..99: begin
                    PlayObject.m_nVal[n100] := nValue;
                    Result := True;
                  end;
                100..199: begin
                    g_Config.GlobalVal[n100 - 100] := nValue;
                    Result := True;
                  end;
                200..299: begin
                    PlayObject.m_DyVal[n100 - 200] := nValue;
                    Result := True;
                  end;
                300..399: begin
                    PlayObject.m_nMval[n100 - 300] := nValue;
                    Result := True;
                  end;
                400..499: begin
                    g_Config.GlobaDyMval[n100 - 400] := nValue;
                    Result := True;
                  end;
                500..599: begin
                    PlayObject.m_nInteger[n100 - 500] := nValue;
                    Result := True;
                  end;
                600..699: begin
                    PlayObject.m_sString[n100 - 600] := sValue;
                    Result := True;
                  end;
                700..799: begin
                    g_Config.GlobalAVal[n100 - 700] := sValue;
                    Result := True;
                  end;
                800..1199:begin//20080903 G变量
                    g_Config.GlobalVal[n100 - 700] :=  nValue;
                    Result := True;
                  end;
                1200..2099:begin//A变量(100-999)
                    g_Config.GlobalAVal[n100 - 1100] := sValue;
                    Result := True;
                  end;
                2100..2599: begin//G变量(500-999)
                    g_Config.GlobalVal[n100 - 1600] :=  nValue;
                    Result := True;
                  end;
              else begin
                  Result := False;
                end;
              end;
            end;
        end;

      end else Result := False;
    end;
var
  LoadList: TStringList;
  sFileName, MonName, sValue, sParam2: string;
  I,K, nValue, nDataType, nParam3: Integer;
  boOK: Boolean;
begin
  try
    MonName:='';
    if CompareLStr(QuestActionInfo.sParam2, '<$STR(', 6) then  //20090102 支持字符串变量
      ArrestStringEx(QuestActionInfo.sParam2, '(', ')', sParam2)
    else sParam2 := QuestActionInfo.sParam2;

    nParam3:=Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3),-1);
    if (nParam3 < 0) then begin//读取指定行
      GetValValue(PlayObject, QuestActionInfo.sParam3, nParam3);
      if nParam3 > 0 then boOK:= True;
    end else boOK:= True;

    sFileName := QuestActionInfo.sParam1;//文本(全路径)
    if sFileName <> '' then begin
      if sFileName[1] = '\' then sFileName := Copy(sFileName, 2, Length(sFileName) - 1);
      if sFileName[2] = '\' then sFileName := Copy(sFileName, 3, Length(sFileName) - 2);
      if sFileName[3] = '\' then sFileName := Copy(sFileName, 4, Length(sFileName) - 3);
    end;
    sFileName := GetLineVariableText(PlayObject,sFileName);//文件路径支持变量 20080602
    sFileName := g_Config.sEnvirDir + sFileName;
    if FileExists(sFileName) then begin
      LoadList := TStringList.Create;
      try
        LoadList.LoadFromFile(sFileName);
        if not boOK then begin
          Randomize;//播下随机种子
          if LoadList.Count > 0 then begin//20080629
            for I := 0 to LoadList.Count - 1 do begin
              K:= Random(LoadList.Count);
              MonName:= LoadList.Strings[K];
              if MonName <> '' then break;
            end;
          end;
        end else begin
          if nParam3 <= LoadList.Count then MonName:= LoadList.Strings[nParam3-1];
        end;
      finally
        LoadList.Free;
      end;
    end;
    //if MonName <>'' then begin //传值过程 20090211 有人可能需要赋空值给变量
      if GetValNameValue(sParam2, sValue, nValue, nDataType) then begin
        if not SetValNameValue(sParam2, MonName, nValue, nDataType) then
          ScriptActionError(PlayObject, '', QuestActionInfo, sGetRandomName);
      end;
    //end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfGetRandomName',[g_sExceptionVer]));
  end;
end;
//-----------------------------------------------------------------------------
//通过脚本命令让别人执行QManage.txt中的脚本 20080422
//格式：HCall 人物名称 标签
procedure TNormNpc.ActionOfHCall(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  User:TPlayObject;
  UserName, sLable: String;
begin
  try
    UserName:=GetLineVariableText(PlayObject,QuestActionInfo.sParam1);//人物名称 支持变量
    sLable:=GetLineVariableText(PlayObject,QuestActionInfo.sParam2);//标签 支持变量
    if (UserName ='') or (sLable ='') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sHCall);
      Exit;
    end;

    User := UserEngine.GetPlayObject(UserName);
    if User <> nil then begin
      if g_ManageNPC <> nil then g_ManageNPC.GotoLable(User, sLable, False, False);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfHCall',[g_sExceptionVer]));
  end;
end;
//-----------------------------------------------------------------------------
//检测人物是否在攻城期间的范围内，在则BB叛变 20080422
//格式：INCASTLEWARAY
procedure TNormNpc.ActionOfINCASTLEWARAY(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  Castle: TUserCastle;
  I: Integer;
begin
try
  Castle := g_CastleManager.InCastleWarArea(PlayObject);
  if (Castle <> nil) and Castle.m_boUnderWar then begin
    if PlayObject.m_SlaveList.Count > 0 then begin//20080629
      for I := PlayObject.m_SlaveList.Count - 1 downto 0 do begin
        if PlayObject.m_SlaveList.Count <= 0 then Break;
        if TBaseObject(PlayObject.m_SlaveList.Items[I]).m_btRaceServer <> RC_PLAYMOSTER then //宝宝叛变
           TBaseObject(PlayObject.m_SlaveList.Items[I]).m_dwMasterRoyaltyTick := 0;//叛变时间
      end;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfINCASTLEWARAY',[g_sExceptionVer]));
end;
end;
//-----------------------------------------------------------------------------
//功能：给予带绑定状态装备。主要方便设置不能配带的装备绑定状态
//格式： GIVESTATEITEM 物品名称 项目1 项目2 项目3 项目4 项目5 项目6(0为正常,1为绑定)   20080312
//项目1--给予禁止扔，项目2--禁止交易，项目3--禁止存，项目4--禁止修，项目5--禁止出售,项目6--禁止爆出的装备
procedure TNormNpc.ActionOfGIVESTATEITEM(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  sItmeName: String;
  n1,n2,n3,n4,n5,n6: Byte;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
  try
    sItmeName:= GetLineVariableText(PlayObject,QuestActionInfo.sParam1);//物品名称 支持变量
    n1:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2), -1);//项目1 支持变量
    n2:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam3), -1);//项目2 支持变量
    n3:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam4), -1);//项目3 支持变量
    n4:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam5), -1);//项目4 支持变量
    n5:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam6), -1);//项目5 支持变量
    n6:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam7), -1);//项目6 支持变量

    if (not (n1 in [0, 1])) or (not (n2 in [0, 1])) or (not (n3 in [0, 1])) or
      (not (n4 in [0, 1])) or (not (n5 in [0, 1])) or (not (n6 in [0, 1])) or (sItmeName ='') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sGIVESTATEITEM);
      Exit;
    end;

    if UserEngine.GetStdItemIdx(sItmeName) > 0 then begin
      if PlayObject.IsEnoughBag then begin
        New(UserItem);
        if UserEngine.CopyToUserItemFromName(sItmeName, UserItem) then begin
          PlayObject.SetItemState(UserItem, 0, n1);//禁止扔
          PlayObject.SetItemState(UserItem, 1, n2);//禁止交易
          PlayObject.SetItemState(UserItem, 2, n3);//禁止存
          PlayObject.SetItemState(UserItem, 3, n4);//禁止修
          PlayObject.SetItemState(UserItem, 4, n5);//禁止出售
          PlayObject.SetItemState(UserItem, 5, n6);//禁止爆出
          {UserItem.btValue[14] := n1;
          UserItem.btValue[15] := n2;
          UserItem.btValue[16] := n3;
          UserItem.btValue[17] := n4;
          UserItem.btValue[18] := n5;
          UserItem.btValue[19] := n6; }
          PlayObject.m_ItemList.Add((UserItem));
          PlayObject.SendAddItem(UserItem);
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('9' + #9 + PlayObject.m_sMapName + #9 +
              IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
              PlayObject.m_sCharName + #9 + sItmeName + #9 +
              IntToStr(UserItem.MakeIndex) + #9 +
              '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
              '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
              '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
              '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
              '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
              IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
              IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
              IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
              IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
        end else Dispose(UserItem);
      end else begin
        New(UserItem);
        if UserEngine.CopyToUserItemFromName(sItmeName, UserItem) then begin
          PlayObject.SetItemState(UserItem, 0, n1);//禁止扔
          PlayObject.SetItemState(UserItem, 1, n2);//禁止交易
          PlayObject.SetItemState(UserItem, 2, n3);//禁止存
          PlayObject.SetItemState(UserItem, 3, n4);//禁止修
          PlayObject.SetItemState(UserItem, 4, n5);//禁止出售
          PlayObject.SetItemState(UserItem, 5, n6);//禁止爆出
          {UserItem.btValue[14] := n1;
          UserItem.btValue[15] := n2;
          UserItem.btValue[16] := n3;
          UserItem.btValue[17] := n4;
          UserItem.btValue[18] := n5;
          UserItem.btValue[19] := n6;}
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('9' + #9 + PlayObject.m_sMapName + #9 +
              IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
              PlayObject.m_sCharName + #9 + sItmeName + #9 +
              IntToStr(UserItem.MakeIndex) + #9 +
              '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
              '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
              '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
              '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
              '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
              IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
              IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
              IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
              IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
          PlayObject.DropItemDown(UserItem, 3, False, False, PlayObject, PlayObject{nil}); //20080519 修正M2报错:{异常} TMerchant::UserSelect... Data: @XXXX Code:0
          Dispose(UserItem);//修复内存泄露By TasNat at: 2012-06-01 12:10:51
        end else Dispose(UserItem);
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfGIVESTATEITEM',[g_sExceptionVer]));
  end;
end;
//-----------------------------------------------------------------------------
//功能：设置装备绑定状态。
//格式：SETITEMSTATE 位置(0-13) 项目(0-5) 属性(0为正常,1为绑定) 20080312
//项目: 0 禁止扔1 禁止交易 2 禁止存 3 禁止修 4 禁止出售 5 禁止爆出
procedure TNormNpc.ActionOfSETITEMSTATE(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  n1,n2,n3: Byte;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
try
  n1:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam1), -1);//位置 支持变量
  n2:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2), -1);//项目 支持变量
  n3:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam3), -1);//属性 支持变量

  if (not (n1 in [0..14])) or (not (n2 in [0..5])) or (not (n3 in [0, 1]))then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSETITEMSTATE);
    Exit;
  end;

  UserItem := @PlayObject.m_UseItems[n1];
  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
  if (UserItem.wIndex <= 0) or (StdItem = nil) then begin
    Exit;
  end;

  PlayObject.SetItemState(UserItem, n2, n3);
  {case n2 of //项目
    0:UserItem.btValue[14] := n3;
    1:UserItem.btValue[15] := n3;
    2:UserItem.btValue[16] := n3;
    3:UserItem.btValue[17] := n3;
    4:UserItem.btValue[18] := n3;
    5:UserItem.btValue[19] := n3;
  end;}
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfSETITEMSTATE',[g_sExceptionVer]));
end;
end;
//-----------------------------------------------------------------------------
procedure TNormNpc.ActionOfMarry(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  PoseHuman: TPlayObject;
  sSayMsg: string;
begin
  try
    if PlayObject.m_sDearName <> '' then Exit;
    PoseHuman := TPlayObject(PlayObject.GetPoseCreate());
    if PoseHuman = nil then begin
      GotoLable(PlayObject, '@MarryCheckDir', False, False);
      Exit;
    end;
    if not PoseHuman.m_boMarryMsg then begin
      GotoLable(PlayObject, '@NoMarry', False, False);//对方拒绝求婚
      Exit;
    end;
    if QuestActionInfo.sParam1 = '' then begin
      if PoseHuman.m_btRaceServer <> RC_PLAYOBJECT then begin
        GotoLable(PlayObject, '@HumanTypeErr', False, False);
        Exit;
      end;
      if PoseHuman.GetPoseCreate = PlayObject then begin
        if PlayObject.m_btGender <> PoseHuman.m_btGender then begin
          GotoLable(PlayObject, '@StartMarry', False, False);
          GotoLable(PoseHuman, '@StartMarry', False, False);
          if (PlayObject.m_btGender = 0) and (PoseHuman.m_btGender = 1) then begin
            sSayMsg := AnsiReplaceText(g_sStartMarryManMsg, '%n', m_sCharName);
            sSayMsg := AnsiReplaceText(sSayMsg, '%s', PlayObject.m_sCharName);
            sSayMsg := AnsiReplaceText(sSayMsg, '%d', PoseHuman.m_sCharName);
            UserEngine.SendBroadCastMsg(sSayMsg, t_Say);
            sSayMsg := AnsiReplaceText(g_sStartMarryManAskQuestionMsg, '%n', m_sCharName);
            sSayMsg := AnsiReplaceText(sSayMsg, '%s', PlayObject.m_sCharName);
            sSayMsg := AnsiReplaceText(sSayMsg, '%d', PoseHuman.m_sCharName);
            UserEngine.SendBroadCastMsg(sSayMsg, t_Say);
          end else if (PlayObject.m_btGender = 1) and (PoseHuman.m_btGender = 0) then begin
            sSayMsg := AnsiReplaceText(g_sStartMarryWoManMsg, '%n', m_sCharName);
            sSayMsg := AnsiReplaceText(sSayMsg, '%s', PlayObject.m_sCharName);
            sSayMsg := AnsiReplaceText(sSayMsg, '%d', PoseHuman.m_sCharName);
            UserEngine.SendBroadCastMsg(sSayMsg, t_Say);
            sSayMsg := AnsiReplaceText(g_sStartMarryWoManAskQuestionMsg, '%n', m_sCharName);
            sSayMsg := AnsiReplaceText(sSayMsg, '%s', PlayObject.m_sCharName);
            sSayMsg := AnsiReplaceText(sSayMsg, '%d', PoseHuman.m_sCharName);
            UserEngine.SendBroadCastMsg(sSayMsg, t_Say);
          end;
          PlayObject.m_boStartMarry := True;
          PoseHuman.m_boStartMarry := True;
        end else begin
          GotoLable(PoseHuman, '@MarrySexErr', False, False);
          GotoLable(PlayObject, '@MarrySexErr', False, False);
        end;
      end else begin
        GotoLable(PlayObject, '@MarryDirErr', False, False);
        GotoLable(PoseHuman, '@MarryCheckDir', False, False);
      end;
      Exit;
    end;
    if CompareText(QuestActionInfo.sParam1, 'REQUESTMARRY' {sREQUESTMARRY}) = 0 then begin
      if PlayObject.m_boStartMarry and PoseHuman.m_boStartMarry then begin
        if (PlayObject.m_btGender = 0) and (PoseHuman.m_btGender = 1) then begin
          sSayMsg := AnsiReplaceText(g_sMarryManAnswerQuestionMsg, '%n', m_sCharName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%s', PlayObject.m_sCharName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%d', PoseHuman.m_sCharName);
          UserEngine.SendBroadCastMsg(sSayMsg, t_Say);
          sSayMsg := AnsiReplaceText(g_sMarryManAskQuestionMsg, '%n', m_sCharName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%s', PlayObject.m_sCharName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%d', PoseHuman.m_sCharName);
          UserEngine.SendBroadCastMsg(sSayMsg, t_Say);
          GotoLable(PlayObject, '@WateMarry', False, False);
          GotoLable(PoseHuman, '@RevMarry', False, False);
        end;
      end;
      Exit;
    end;
    if CompareText(QuestActionInfo.sParam1, 'RESPONSEMARRY' {sRESPONSEMARRY}) = 0 then begin
      if (PlayObject.m_btGender = 1) and (PoseHuman.m_btGender = 0) then begin
        if CompareText(QuestActionInfo.sParam2, 'OK') = 0 then begin
          if PlayObject.m_boStartMarry and PoseHuman.m_boStartMarry then begin
            sSayMsg := AnsiReplaceText(g_sMarryWoManAnswerQuestionMsg, '%n', m_sCharName);
            sSayMsg := AnsiReplaceText(sSayMsg, '%s', PlayObject.m_sCharName);
            sSayMsg := AnsiReplaceText(sSayMsg, '%d', PoseHuman.m_sCharName);
            UserEngine.SendBroadCastMsg(sSayMsg, t_Say);
            sSayMsg := AnsiReplaceText(g_sMarryWoManGetMarryMsg, '%n', m_sCharName);
            sSayMsg := AnsiReplaceText(sSayMsg, '%s', PlayObject.m_sCharName);
            sSayMsg := AnsiReplaceText(sSayMsg, '%d', PoseHuman.m_sCharName);
            UserEngine.SendBroadCastMsg(sSayMsg, t_Say);
            GotoLable(PlayObject, '@EndMarry', False, False);
            GotoLable(PoseHuman, '@EndMarry', False, False);
            PlayObject.m_boStartMarry := False;
            PoseHuman.m_boStartMarry := False;
            PlayObject.m_sDearName := PoseHuman.m_sCharName;
            PlayObject.m_DearHuman := PoseHuman;
            PoseHuman.m_sDearName := PlayObject.m_sCharName;
            PoseHuman.m_DearHuman := PlayObject;
            PlayObject.RefShowName;
            PoseHuman.RefShowName;
          end;
        end else begin
          if PlayObject.m_boStartMarry and PoseHuman.m_boStartMarry then begin
            GotoLable(PlayObject, '@EndMarryFail', False, False);
            GotoLable(PoseHuman, '@EndMarryFail', False, False);
            PlayObject.m_boStartMarry := False;
            PoseHuman.m_boStartMarry := False;
            sSayMsg := AnsiReplaceText(g_sMarryWoManDenyMsg, '%n', m_sCharName);
            sSayMsg := AnsiReplaceText(sSayMsg, '%s', PlayObject.m_sCharName);
            sSayMsg := AnsiReplaceText(sSayMsg, '%d', PoseHuman.m_sCharName);
            UserEngine.SendBroadCastMsg(sSayMsg, t_Say);
            sSayMsg := AnsiReplaceText(g_sMarryWoManCancelMsg, '%n', m_sCharName);
            sSayMsg := AnsiReplaceText(sSayMsg, '%s', PlayObject.m_sCharName);
            sSayMsg := AnsiReplaceText(sSayMsg, '%d', PoseHuman.m_sCharName);
            UserEngine.SendBroadCastMsg(sSayMsg, t_Say);
          end;
        end;
      end;
      Exit;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfMarry',[g_sExceptionVer]));
  end;
end;
//收徒或拜师 20090208 修改
procedure TNormNpc.ActionOfMaster(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  PoseHuman: TPlayObject;
  sName: string;
  nLevel: Integer;
begin
  try
    if PlayObject.m_sMasterName <> '' then Exit;
    if (CompareText(QuestActionInfo.sParam1, 'Receiver') = 0) then begin
      sName:= GetLineVariableText(PlayObject, QuestActionInfo.sParam2);
      if sName = '' then Exit;
      nLevel:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3),0);//等级
      PoseHuman := UserEngine.GetPlayObject(sName);//检查是否在线
      if PoseHuman = nil then begin
        GotoLable(PlayObject, '@MasterCheckDir', False, False);//对方没有在线
        Exit;
      end;
      if not PoseHuman.m_boReadMasterMsg then begin
        GotoLable(PlayObject, '@MasterNoRead', False, False);//对方拒绝收徒
        Exit;
      end;
      if (PoseHuman.m_MasterNoList.Count >= g_Config.nMasterCount) then begin //超过可收徒弟数,则退出 20090210
        GotoLable(PlayObject, '@MasterNoRead1', False, False);
        Exit;
      end;
      if PoseHuman.m_btRaceServer <> RC_PLAYOBJECT then begin//不是人物
        GotoLable(PlayObject, '@HumanTypeErr', False, False);//此人不能做师父
        Exit;
      end;
      if PoseHuman.m_Abil.Level > nLevel then begin//等级是否达到做师傅
        if PoseHuman.m_sMasterName = '' then begin
          GotoLable(PlayObject, '@StartGetMaster', False, False);
          GotoLable(PoseHuman, '@StartMaster', False, False);
          PlayObject.m_boStartMaster := True;
          PoseHuman.m_boStartMaster := True;
        end else begin
          GotoLable(PlayObject, '@MasterErr', False, False);
        end;
      end else begin
        GotoLable(PlayObject, '@MasterLevelErr', False, False);
      end;
      Exit;
    end;
    
    if (CompareText(QuestActionInfo.sParam1, 'REQUESTMASTER') = 0) then begin
      sName:= GetLineVariableText(PlayObject, QuestActionInfo.sParam2);
      if sName = '' then Exit;
      PoseHuman := UserEngine.GetPlayObject(sName);//检查是否在线
      if PoseHuman = nil then begin
        GotoLable(PlayObject, '@MasterCheckDir', False, False);//对方没有在线
        Exit;
      end;
      if PlayObject.m_boStartMaster and PoseHuman.m_boStartMaster then begin
        PlayObject.m_PoseBaseObject := PoseHuman;
        PoseHuman.m_PoseBaseObject := PlayObject;
        GotoLable(PlayObject, '@WateMaster', False, False);
        if g_FunctionNPC <> nil then begin
          g_FunctionNPC.GotoLable(PoseHuman, '@RevMaster', False, False);
        end;
      end;
      Exit;
    end;

    if CompareText(QuestActionInfo.sParam1, 'RESPONSEMASTER1') = 0 then begin
      if PlayObject.m_PoseBaseObject <> nil then begin
        if PlayObject.m_PoseBaseObject.m_btRaceServer = RC_PLAYOBJECT then begin//是人物
          if CompareText(QuestActionInfo.sParam2, 'OK') = 0 then begin
            if (PlayObject.m_MasterNoList.Count >= g_Config.nMasterCount) then begin //超过可收徒弟数,则退出 20080530
              GotoLable(TPlayObject(PlayObject.m_PoseBaseObject), '@EndMasterFail', False, False);//提示拜师失败
              GotoLable(PlayObject,'@EndMasterFail', False, False);//提示拜师失败
              PlayObject.m_boStartMaster := False;
              if PlayObject.m_PoseBaseObject <> nil then begin
                TPlayObject(PlayObject.m_PoseBaseObject).m_boStartMaster := False;
                TPlayObject(PlayObject.m_PoseBaseObject).m_PoseBaseObject:= nil;
              end;
              PlayObject.m_PoseBaseObject:= nil;
              Exit;
            end;
            if PlayObject.m_boStartMaster and TPlayObject(PlayObject.m_PoseBaseObject).m_boStartMaster then begin
              GotoLable(PlayObject, '@EndMaster', False, False);
              GotoLable(TPlayObject(PlayObject.m_PoseBaseObject), '@EndMaster', False, False);
              PlayObject.m_boStartMaster := False;
              TPlayObject(PlayObject.m_PoseBaseObject).m_boStartMaster := False;
              PlayObject.m_boMaster := True;//20080512
              PlayObject.AddMaster(PlayObject.m_PoseBaseObject.m_sCharName);//20080530 收徒
              PlayObject.m_MasterList.Add(PlayObject.m_PoseBaseObject);//加入徒弟列表
              TPlayObject(PlayObject.m_PoseBaseObject).m_sMasterName := PlayObject.m_sCharName;
              TPlayObject(PlayObject.m_PoseBaseObject).m_boMaster := False;
              TPlayObject(PlayObject.m_PoseBaseObject).GetMasterNoList;//20080530 取排名
              PlayObject.RefShowName;
              TPlayObject(PlayObject.m_PoseBaseObject).RefShowName;
            end;
          end else begin
            if PlayObject.m_boStartMaster and TPlayObject(PlayObject.m_PoseBaseObject).m_boStartMaster then begin
              GotoLable(PlayObject, '@EndMasterFail', False, False);
              GotoLable(TPlayObject(PlayObject.m_PoseBaseObject), '@EndMasterFail', False, False);
              PlayObject.m_boStartMaster := False;
              TPlayObject(PlayObject.m_PoseBaseObject).m_boStartMaster := False;
            end;
          end;
        end;
        if PlayObject.m_PoseBaseObject <> nil then begin
          TPlayObject(PlayObject.m_PoseBaseObject).m_boStartMaster := False;
          TPlayObject(PlayObject.m_PoseBaseObject).m_PoseBaseObject:= nil;
        end;
        PlayObject.m_boStartMaster := False;
        PlayObject.m_PoseBaseObject:= nil;
      end;
      Exit;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfMaster',[g_sExceptionVer]));
  end;
end;

procedure TNormNpc.ActionOfMessageBox(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  sParam1,Str: string;
begin
  try
    sParam1 := QuestActionInfo.sParam1;
    GetValValue(PlayObject, QuestActionInfo.sParam1, sParam1);
    Str:= GetLineVariableText(PlayObject, sParam1);
    if (QuestActionInfo.sParam2 <> '') and (pos('@',QuestActionInfo.sParam2) > 0) then begin//20090126
      PlayObject.m_sMessageBoxStr1:= QuestActionInfo.sParam2;//MESSAGEBOX命令设置触发段1 20090816
      Str:= Str+'/'+QuestActionInfo.sParam2;
    end;
    if (QuestActionInfo.sParam3 <> '') and (pos('@',QuestActionInfo.sParam3) > 0) then begin//20090126
      PlayObject.m_sMessageBoxStr2:= QuestActionInfo.sParam3;//MESSAGEBOX命令设置触发段2 20090816
      Str:= Str+'/'+QuestActionInfo.sParam3;
    end;
{$IF M2Version = 1}
    if Self = g_BatterNPC then begin
      PlayObject.SendMsg(Self, RM_MENU_OK, 0, Integer(PlayObject), 3, 0, Str);//连击
    end else PlayObject.SendMsg(Self, RM_MENU_OK, 0, Integer(PlayObject), 0, 0, Str);
{$ELSE}
    PlayObject.SendMsg(Self, RM_MENU_OK, 0, Integer(PlayObject), 0, 0, Str);
{$IFEND}
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfMessageBox',[g_sExceptionVer]));
  end;
end;

procedure TNormNpc.ActionOfMission(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nX, nY:Integer;
begin
  try
    nX:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2), -1);//20101204 修改支持变量　
    nY:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam3), -1);//20101204 修改支持变量　　
    if (QuestActionInfo.sParam1 <> '') and ({QuestActionInfo.nParam2}nX > 0) and ({QuestActionInfo.nParam3}nY > 0) then begin
      g_sMissionMap := GetLineVariableText(PlayObject,QuestActionInfo.sParam1);//20080507
      g_nMissionX := {QuestActionInfo.nParam2}nX;
      g_nMissionY := {QuestActionInfo.nParam3}nY;
    end else begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_MISSION);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfMission',[g_sExceptionVer]));
  end;
end;

//MOBFIREBURN MAP X Y TYPE TIME POINT
procedure TNormNpc.ActionOfMobFireBurn(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  sMAP: string;
  nX, nY, nType, nTime, nPoint: Integer;
  FireBurnEvent: TFireBurnEvent;
  Envir: TEnvirnoment;
  OldEnvir: TEnvirnoment;
begin
  try
    sMAP := QuestActionInfo.sParam1;
    nX := Str_ToInt(QuestActionInfo.sParam2, -1);
    nY := Str_ToInt(QuestActionInfo.sParam3, -1);
    nType := Str_ToInt(QuestActionInfo.sParam4, -1);
    nTime := Str_ToInt(QuestActionInfo.sParam5, -1);
    nPoint := Str_ToInt(QuestActionInfo.sParam6, -1);
    if (sMAP = '') or (nX < 0) or (nY < 0) or (nType < 0) or (nTime < 0) or (nPoint < 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_MOBFIREBURN);
      Exit;
    end;
    Envir := g_MapManager.FindMap(sMAP);
    if Envir <> nil then begin
      OldEnvir := PlayObject.m_PEnvir;
      PlayObject.m_PEnvir := Envir;
      FireBurnEvent := TFireBurnEvent.Create(PlayObject, nX, nY, nType, nTime * 1000, nPoint);
      g_EventManager.AddEvent(FireBurnEvent);
      PlayObject.m_PEnvir := OldEnvir;
      Exit;
    end;
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_MOBFIREBURN);
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfMobFireBurn',[g_sExceptionVer]));
  end;
end;
//放置怪物，怪物向集中点集中
//命令格式: MobPlace 怪物名称 怪类型(0普通怪/1内功怪/2英雄经络经验怪) 模式(0/1 1-魔王岭新模式)
procedure TNormNpc.ActionOfMobPlace(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo; nX, nY, nCount, nRange: Integer);
var
  I: Integer;
  nRandX, nRandY: Integer;
  mon: TBaseObject;
  sMonName: string;//20080126
  boIsNGMon, boIsHeroPulsMon: Boolean;
  boMode: Boolean;//是否新模式
begin
  try
    sMonName:= GetLineVariableText(PlayObject,QuestActionInfo.sParam1);//20080126 怪物名,支持变量
    case Str_ToInt(QuestActionInfo.sParam2 , 0) of
      1: boIsNGMon:= True;
      2: boIsHeroPulsMon:= True;
    end;
    if QuestActionInfo.sParam3 <> '' then boMode:= True;
    if nCount <= 0 then nCount:=1;//20080629
    for I := 0 to nCount - 1 do begin
      if boMode and (PlayObject.m_sMapName136 <> '') then begin//20090204 魔王岭使用
        mon := UserEngine.RegenMonsterByName(PlayObject.m_sMapName136, UserEngine.m_nCurrX_136, UserEngine.m_nCurrY_136, sMonName);
        if mon <> nil then begin
          mon.m_boIsNGMonster := boIsNGMon;
          mon.m_boIsHeroPulsExpMon := boIsHeroPulsMon;//英雄经络经验怪
        end else begin
          ScriptActionError(PlayObject, '', QuestActionInfo, sSC_MOBPLACE);
          Break;
        end;
      end else begin
        nRandX := Random(nRange * 2 + 1) + (nX - nRange);
        nRandY := Random(nRange * 2 + 1) + (nY - nRange);
        mon := UserEngine.RegenMonsterByName(g_sMissionMap, nRandX, nRandY, sMonName);
        if mon <> nil then begin
          mon.m_boIsNGMonster := boIsNGMon;
          mon.m_boIsHeroPulsExpMon := boIsHeroPulsMon;//英雄经络经验怪
          mon.m_boMission := True;
          mon.m_nMissionX := g_nMissionX;
          mon.m_nMissionY := g_nMissionY;
        end else begin
          ScriptActionError(PlayObject, '', QuestActionInfo, sSC_MOBPLACE);
          Break;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfMobPlace',[g_sExceptionVer]));
  end;
end;

procedure TNormNpc.ActionOfSetRankLevelName(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
  function SubStrConut(mStr:string;mSub:string):Integer;//判断'<$Str('字符出现字符串中的次数
  begin
    Result:= (Length(mStr) - Length(StringReplace(mStr,mSub, '', [rfReplaceAll])))  div  Length(mSub);
  end;
var
  I, K: Integer;
  DynamicVar: pTDynamicVar;
  DynamicVarList: TList;
  sName: string;
  boVarFound: Boolean;
  sRankLevelName,sTemp,sTemp1: string;
  n10: Integer;
resourcestring
  sVarFound = '变量%s不存在，变量类型:%s';
  sVarTypeError = '变量类型错误，错误类型:%s 当前支持类型(HUMAN、GUILD、GLOBAL)';
begin
  try
    //sRankLevelName := QuestActionInfo.sParam1;
    sRankLevelName := GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//20110426 修改
    if sRankLevelName = '' then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_SETRANKLEVELNAME);
      Exit;
    end;
    if QuestActionInfo.sParam2 <> '' then begin
      boVarFound := False;
      DynamicVarList := GetDynamicVarList(PlayObject, sRankLevelName, sName);
      if DynamicVarList = nil then begin
        ScriptActionError(PlayObject, Format(sVarTypeError, [sRankLevelName]), QuestActionInfo, sSC_SETRANKLEVELNAME);
        Exit;
      end;
      if DynamicVarList.Count > 0 then begin//20080629
        for I := 0 to DynamicVarList.Count - 1 do begin
          DynamicVar := DynamicVarList.Items[I];
          if DynamicVar <> nil then begin//20090328
            if CompareText(DynamicVar.sName, QuestActionInfo.sParam2) = 0 then begin
              case DynamicVar.VarType of
                vInteger: begin
                    sRankLevelName := IntToStr(DynamicVar.nInternet);//20080929 增加
                  end;
                vString: begin
                    sRankLevelName := DynamicVar.sString;
                  end;
              end;
              boVarFound := True;
              Break;
            end;
          end;
        end;//for
      end;
      if not boVarFound then begin
        ScriptActionError(PlayObject, Format(sVarFound, [QuestActionInfo.sParam2, QuestActionInfo.sParam1]), QuestActionInfo, sSC_SETRANKLEVELNAME);
        Exit;
      end;
    end else begin
      I:= SubStrConut(sRankLevelName,'<$STR(');//20080429 修改
      if I > 0 then begin
        sTemp:= sRankLevelName;
        sRankLevelName:='';
        for K:=0 to I - 1 do begin
          sTemp:=ArrestStringEx(sTemp, '(', ')', sTemp1);
          n10 := GetValNameNo(sTemp1);
          if n10 >= 0 then begin
            case n10 of
              600..699: begin
                  if PlayObject.m_sString[n10 - 600] <> '' then begin
                    if sRankLevelName <> '' then sRankLevelName:=sRankLevelName+'\';
                    sRankLevelName := sRankLevelName + PlayObject.m_sString[n10 - 600];
                  end;
                end;
              700..799: begin
                  if g_Config.GlobalAVal[n10 - 700] <> '' then begin
                    if sRankLevelName <> '' then sRankLevelName:=sRankLevelName+'\';
                    sRankLevelName := sRankLevelName + g_Config.GlobalAVal[n10 - 700];
                  end;
                end;
              1200..2099:begin//A变量(100-999)
                  if g_Config.GlobalAVal[n10 - 1100] <> '' then begin
                    if sRankLevelName <> '' then sRankLevelName:=sRankLevelName+'\';
                    sRankLevelName := sRankLevelName + g_Config.GlobalAVal[n10 - 1100];
                  end;
                end;
            end;
          end;
        end;
      end else begin
        n10 := GetValNameNo(sRankLevelName);
        if n10 >= 0 then begin
          case n10 of
            600..699: begin
                sRankLevelName := PlayObject.m_sString[n10 - 600];
              end;
            700..799: begin
                sRankLevelName := g_Config.GlobalAVal[n10 - 700];
              end;
            1200..2099:begin//A变量(100-999)
                sRankLevelName := g_Config.GlobalAVal[n10 - 1100];
              end;
          end;
        end;
      end;
    end;
    if sRankLevelName = '' then begin
      sRankLevelName := g_sRankLevelName;
    end else
      if Pos('%s', sRankLevelName) <= 0 then begin
      sRankLevelName := '%s\' + sRankLevelName;
    end;
    PlayObject.m_sRankLevelName := sRankLevelName;
    PlayObject.RefShowName;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfSetRankLevelName',[g_sExceptionVer]));
  end;
end;

procedure TNormNpc.ActionOfSetScriptFlag(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  boFlag: Boolean;
  nWhere: Integer;
begin
try
  nWhere := Str_ToInt(QuestActionInfo.sParam1, -1);
  boFlag := Str_ToInt(QuestActionInfo.sParam2, -1) = 1;
  case nWhere of
    0: begin
        PlayObject.m_boSendMsgFlag := boFlag;
      end;
    1: begin
        PlayObject.m_boChangeItemNameFlag := boFlag;
      end;
  else begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_SETSCRIPTFLAG);
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfSetScriptFlag',[g_sExceptionVer]));
end;
end;

procedure TNormNpc.ActionOfChangeSkillLevelEx(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I, nMaxLevel, nLevel: Integer;
  Magic: pTMagic;
  UserMagic: pTUserMagic;
  cMethod: Char;
  sMagicName: String;
begin
  try
    nLevel := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3), -1);
    if nLevel < 0 then begin
      if not GetValValue(PlayObject, QuestActionInfo.sParam3, nLevel) then begin
        nLevel := QuestActionInfo.nParam3;
      end;
    end;
    sMagicName:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1);
    if (nLevel < 0) or (nLevel > 9) or (sMagicName = '') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGESKILLLEVELEX);
      Exit;
    end;
    cMethod := QuestActionInfo.sParam2[1];
    if PlayObject.m_MagicList.Count > 0 then begin
      for I := 0 to PlayObject.m_MagicList.Count - 1 do begin
        UserMagic := PlayObject.m_MagicList.Items[I];
        if (CompareText(UserMagic.MagicInfo.sMagicName, sMagicName)= 0) then begin
          case cMethod of
            '=': begin
                if nLevel >= 0 then begin
                  if UserMagic.wMagIdx in [SKILL_YEDO,SKILL_90,SKILL_89,SKILL_ERGUM,
                    SKILL_FIRESWORD,SKILL_74,SKILL_LIGHTENING,SKILL_91,SKILL_SHOOTLIGHTEN,
                    SKILL_EARTHFIRE,SKILL_45,SKILL_92,SKILL_58,SKILL_AMYOUNSUL,SKILL_93,
                    SKILL_FIRECHARM,SKILL_SKELLETON,SKILL_71,SKILL_94,SKILL_59,
                    SKILL_FIREBOOM,SKILL_SNOWWIND,SKILL_HANGMAJINBUB,SKILL_DEJIWONHO] then
                  UserMagic.btLevelEx := _MIN(9, nLevel);
                end;
              end;
            '-': begin
                if UserMagic.wMagIdx in [SKILL_YEDO,SKILL_90,SKILL_89,SKILL_ERGUM,
                  SKILL_FIRESWORD,SKILL_74,SKILL_LIGHTENING,SKILL_91,SKILL_SHOOTLIGHTEN,
                  SKILL_EARTHFIRE,SKILL_45,SKILL_92,SKILL_58,SKILL_AMYOUNSUL,SKILL_93,
                  SKILL_FIRECHARM,SKILL_SKELLETON,SKILL_71,SKILL_94,SKILL_59,
                  SKILL_FIREBOOM,SKILL_SNOWWIND,SKILL_HANGMAJINBUB,SKILL_DEJIWONHO] then begin
                  if UserMagic.btLevelEx >= nLevel then begin
                    Dec(UserMagic.btLevelEx, nLevel);
                  end else begin
                    UserMagic.btLevelEx := 0;
                  end;
                end;
              end;
            '+': begin
                if UserMagic.wMagIdx in [SKILL_YEDO,SKILL_90,SKILL_89,SKILL_ERGUM,
                  SKILL_FIRESWORD,SKILL_74,SKILL_LIGHTENING,SKILL_91,SKILL_SHOOTLIGHTEN,
                  SKILL_EARTHFIRE,SKILL_45,SKILL_92,SKILL_58,SKILL_AMYOUNSUL,SKILL_93,
                  SKILL_FIRECHARM,SKILL_SKELLETON,SKILL_71,SKILL_94,SKILL_59,
                  SKILL_FIREBOOM,SKILL_SNOWWIND,SKILL_HANGMAJINBUB,SKILL_DEJIWONHO] then begin
                  if UserMagic.btLevelEx + nLevel <= 9 then begin
                    Inc(UserMagic.btLevelEx, nLevel);
                  end else begin
                    UserMagic.btLevelEx := 9;
                  end;
                end;
              end;
          end;
          PlayObject.SendDelayMsg(PlayObject, RM_MAGIC_UPLVEXPEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevelEx, 0, '', 100);
          Break;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeSkillLevelEx',[g_sExceptionVer]));
  end;
end;

procedure TNormNpc.ActionOfSkillLevel(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I, nMaxLevel: Integer;
  Magic: pTMagic;
  UserMagic: pTUserMagic;
  nLevel: Integer;
  cMethod: Char;
begin
  try
    nLevel := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3), -1);//等级支持变量 20090507
    if nLevel < 0 then begin//20090507 增加
      if not GetValValue(PlayObject, QuestActionInfo.sParam3, nLevel) then begin //增加变量支持
        nLevel := QuestActionInfo.nParam3;
      end;
    end;
    if nLevel < 0 then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_SKILLLEVEL);
      Exit;
    end;
    cMethod := QuestActionInfo.sParam2[1];
    Magic := UserEngine.FindMagic(QuestActionInfo.sParam1);
    if Magic <> nil then begin
      if PlayObject.m_MagicList.Count > 0 then begin//20080629                                      
        for I := 0 to PlayObject.m_MagicList.Count - 1 do begin
          UserMagic := PlayObject.m_MagicList.Items[I];
          if UserMagic.MagicInfo = Magic then begin
            case cMethod of
              '=': begin
                  if nLevel >= 0 then begin
                    case UserMagic.wMagIdx of
                      SKILL_FIRECHARM,SKILL_FIRESWORD,SKILL_45,SKILL_66,SKILL_88..SKILL_94: nLevel := _MIN(4, nLevel);
                      SKILL_68: nLevel := _MIN(100, nLevel);
                      SKILL_71: nLevel := _MIN(99, nLevel);
                      SKILL_95: begin
                        {$IF M2Version = 1}
                        if PlayObject.m_boOpenupSkill95 then begin
                          nLevel := _MIN(99, nLevel);
                        end else{$IFEND}
                        nLevel := _MIN(64, nLevel);//斗转星移最高64级
                      end;
                      SKILL_100: nLevel := _MIN(15, nLevel);
                      SKILL_104: nLevel := _MIN(100, nLevel);
                      SKILL_105: nLevel := _MIN(100, nLevel);
                      SKILL_106, SKILL_107, SKILL_108, SKILL_109: nLevel := _MIN(9, nLevel);
                      else nLevel := _MIN(3, nLevel);
                    end;
                    UserMagic.btLevel := nLevel;
                  end;
                end;
              '-': begin
                  if UserMagic.btLevel >= nLevel then begin
                    Dec(UserMagic.btLevel, nLevel);
                  end else begin
                    UserMagic.btLevel := 0;
                  end;
                end;
              '+': begin
                  case UserMagic.wMagIdx of
                    SKILL_FIRECHARM,SKILL_FIRESWORD,SKILL_45,SKILL_66,SKILL_88..SKILL_94: nMaxLevel := 4;
                    SKILL_68, SKILL_104, SKILL_105: nMaxLevel := 100;
                    SKILL_106, SKILL_107, SKILL_108,SKILL_109: nMaxLevel := 9;
                    SKILL_71: nMaxLevel := 99;
                    SKILL_95: begin
                      {$IF M2Version = 1}
                      if PlayObject.m_boOpenupSkill95 then begin
                        nMaxLevel := 99;
                      end else{$IFEND}
                      nMaxLevel := 64;//斗转星移最高64级
                    end;
                    SKILL_100: nMaxLevel := 15;
                    else nMaxLevel := 3;
                  end;
                  if UserMagic.btLevel + nLevel <= nMaxLevel then begin
                    Inc(UserMagic.btLevel, nLevel);
                  end else begin
                    UserMagic.btLevel := nMaxLevel;
                  end;
                end;
            end;
            PlayObject.SendDelayMsg(PlayObject, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 100);
            Break;
          end;
        end;//for
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfSkillLevel',[g_sExceptionVer]));
  end;
end;

//调整英雄技能等级 20080415
//HEROSKILLLEVEL 技能名 控制符(=,+,-)  等级数(0-3)
procedure TNormNpc.ActionOfHeroSkillLevel(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I, nMaxLevel: Integer;
  Magic: pTMagic;
  UserMagic: pTUserMagic;
  nLevel: Integer;
  cMethod: Char;
begin
  {$IF HEROVERSION = 1}
  try
    nLevel := Str_ToInt(QuestActionInfo.sParam3, 0);
    if nLevel < 0 then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_HeroSkillLevel);
      Exit;
    end;
    cMethod := QuestActionInfo.sParam2[1];

    if PlayObject.m_MyHero <> nil then begin
      Magic := UserEngine.FindHeroMagic(QuestActionInfo.sParam1);
      if Magic <> nil then begin
        if PlayObject.m_MyHero.m_MagicList.Count > 0 then begin//20080629
          for I := 0 to PlayObject.m_MyHero.m_MagicList.Count - 1 do begin
            UserMagic := PlayObject.m_MyHero.m_MagicList.Items[I];
            if UserMagic.MagicInfo = Magic then begin
              case cMethod of
                '=': begin
                    if nLevel >= 0 then begin
                      case Magic.wMagicId of
                        SKILL_FIRECHARM,SKILL_FIRESWORD,SKILL_45: nLevel := _MIN(4, nLevel);
                        SKILL_95: begin
                          {$IF M2Version = 1}
                          if THEROOBJECT(PlayObject.m_MyHero).m_boOpenupSkill95 then begin
                            nLevel := _MIN(99, nLevel);
                          end else{$IFEND}
                          nLevel := _MIN(64, nLevel);
                        end;
                        SKILL_99: nLevel := _MIN(99, nLevel);
                        SKILL_104: nLevel := _MIN(100, nLevel);
                        else nLevel := _MIN(3, nLevel);
                      end;
                      UserMagic.btLevel := nLevel;
                    end;
                  end;
                '-': begin
                    if UserMagic.btLevel >= nLevel then begin
                      Dec(UserMagic.btLevel, nLevel);
                    end else begin
                      UserMagic.btLevel := 0;
                    end;
                  end;
                '+': begin
                    case Magic.wMagicId of
                      SKILL_FIRECHARM,SKILL_FIRESWORD,SKILL_45: nMaxLevel:= 4;
                      SKILL_95: begin
                        {$IF M2Version = 1}
                        if THEROOBJECT(PlayObject.m_MyHero).m_boOpenupSkill95 then begin
                          nMaxLevel:= 99;
                        end else{$IFEND}
                        nMaxLevel:= 64;
                      end;
                      SKILL_99: nMaxLevel:= 99;
                      SKILL_104: nMaxLevel:= 100;
                      else nMaxLevel:= 3;
                    end;
                    if UserMagic.btLevel + nLevel <= nMaxLevel then begin
                      Inc(UserMagic.btLevel, nLevel);
                    end else begin
                      UserMagic.btLevel := nMaxLevel;
                    end;
                  end;
              end;
              PlayObject.SendDelayMsg(PlayObject, RM_HEROMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 100);
              Break;
            end;
          end;//for
        end;
      end;
    end else begin//英雄不在线
     PlayObject.SysMsg('英雄不在线!', c_Red, t_Hint);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfHeroSkillLevel',[g_sExceptionVer]));
  end;
  {$IFEND}
end;

procedure TNormNpc.ActionOfTakeCastleGold(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nGold: Integer;
begin
  try
    nGold := Str_ToInt(QuestActionInfo.sParam1, -1);
    if nGold < 0 then
      GetValValue(PlayObject, QuestActionInfo.sParam1, nGold);
    if (nGold < 0) or (m_Castle = nil) then
    begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_TAKECASTLEGOLD);
      Exit;
    end;
    if nGold <= TUserCastle(m_Castle).m_nTotalGold then
    begin
      Dec(TUserCastle(m_Castle).m_nTotalGold, nGold);
    end else
    begin
      TUserCastle(m_Castle).m_nTotalGold := 0;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfTakeCastleGol',[g_sExceptionVer]));
  end;
end;


procedure TNormNpc.ActionOfNotLineAddPiont(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var  //离线挂机
  dwAutoGetExpTime: LongWord;
  nAutoGetExpPoint: Integer;
begin
  try
    if (not PlayObject.m_boNotOnlineAddExp) and (not PlayObject.m_boAI) then begin
      dwAutoGetExpTime:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam1), -1);//20090511 支持变量
      nAutoGetExpPoint := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2), -1);//20090511 支持变量
      if (dwAutoGetExpTime < 0) or (nAutoGetExpPoint < 0) then begin
        ScriptActionError(PlayObject, '', QuestActionInfo, sOFFLINEPLAY);
        Exit;
      end;
      
      if dwAutoGetExpTime * 60 > High(LongWord) then begin
        ScriptActionError(PlayObject, '', QuestActionInfo, sOFFLINEPLAY);
        Exit;
      end;
      with PlayObject do begin//20090903 修改
        if m_PEnvir.GetXYObjCount(m_nCurrX, m_nCurrY) > 1 then begin//挂机人物检查是否重叠,如果移动后还是重叠，则不让挂机 20100126
          if not WalkTo(Random(8), False) then Exit;
        end;
        m_dwNotOnlineAddExpTime := dwAutoGetExpTime * 60;//20080812 修改
        m_nNotOnlineAddExpPoint := nAutoGetExpPoint;
        m_boNotOnlineAddExp := True;//是离线挂机
        m_boStartAutoAddExpPoint := True;//是否自动增加经验
        m_dwAutoAddExpPointTimeTick := GetTickCount;
        m_dwAutoAddExpPointTick := GetTickCount;
        m_boKickAutoAddExpUser := False;
        m_boAllowDeal := False; //禁止交易
        m_boAllowGuild := False; //禁止加入行会
        m_boAllowGroup := False; //禁止组队
        m_boCanMasterRecall := False; //禁止师徒传送
        m_boCanDearRecall := False; //禁止夫妻传送
        m_boAllowGuildReCall := False; //禁止行会合一
        m_boAllowGroupReCall := False; //禁止天地合一
        m_boOpenBox:= False;//宝箱初始化 20080415
        m_boFree9YearsBox:= False;//是否取得免费奖励20格箱子
        ClientCloseBoxs();//清空个人箱子列表资源,关闭箱子
        if g_Config.boSafeOffShop and m_boShop then ShopCancel;//禁止挂机摆摊
        ClearViewRange;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfNotLineAddPiont',[g_sExceptionVer]));
  end;
end;


procedure TNormNpc.ActionOfKickNotLineAddPiont(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
begin
  try
    if PlayObject.m_boNotOnlineAddExp then
    begin
      PlayObject.m_boPlayOffLine := False;
      PlayObject.m_boReconnection := False;
      PlayObject.m_boSoftClose := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfKickNotLineAddPiont',[g_sExceptionVer]));
  end;
end;

procedure TNormNpc.ActionOfUnMarry(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  PoseHuman: TPlayObject;
  LoadList: TStringList;
  sUnMarryFileName: string;
begin
try
  if PlayObject.m_sDearName = '' then begin
    GotoLable(PlayObject, '@ExeMarryFail', False, False);
    Exit;
  end;
  PoseHuman := TPlayObject(PlayObject.GetPoseCreate);
  if PoseHuman = nil then begin
    GotoLable(PlayObject, '@UnMarryCheckDir', False, False);
  end;
  if PoseHuman <> nil then begin
    if QuestActionInfo.sParam1 = '' then begin
      if PoseHuman.m_btRaceServer <> RC_PLAYOBJECT then begin
        GotoLable(PlayObject, '@UnMarryTypeErr', False, False);
        Exit;
      end;
      if PoseHuman.GetPoseCreate = PlayObject then begin
        if (PlayObject.m_sDearName = PoseHuman.m_sCharName) {and (PosHum.AddInfo.sDearName = Hum.sName)} then begin
          GotoLable(PlayObject, '@StartUnMarry', False, False);
          GotoLable(PoseHuman, '@StartUnMarry', False, False);
          Exit;
        end;
      end;
    end;
  end;
  if (CompareText(QuestActionInfo.sParam1, 'REQUESTUNMARRY' {sREQUESTUNMARRY}) = 0) then begin
    if (QuestActionInfo.sParam2 = '') then begin
      if PoseHuman <> nil then begin
        PlayObject.m_boStartUnMarry := True;
        if PlayObject.m_boStartUnMarry and PoseHuman.m_boStartUnMarry then begin
          UserEngine.SendBroadCastMsg('[' + m_sCharName + ']: ' + '我宣布' {sUnMarryMsg8} + PoseHuman.m_sCharName + ' ' + '与' {sMarryMsg0} + PlayObject.m_sCharName + ' ' + ' ' + '正式脱离夫妻关系。' {sUnMarryMsg9}, t_Say);
          PlayObject.m_sDearName := '';
          PoseHuman.m_sDearName := '';
          Inc(PlayObject.m_btMarryCount);
          Inc(PoseHuman.m_btMarryCount);
          PlayObject.m_boStartUnMarry := False;
          PoseHuman.m_boStartUnMarry := False;
          PlayObject.RefShowName;
          PoseHuman.RefShowName;
          GotoLable(PlayObject, '@UnMarryEnd', False, False);
          GotoLable(PoseHuman, '@UnMarryEnd', False, False);
        end else begin
          GotoLable(PlayObject, '@WateUnMarry', False, False);
          //          GotoLable(PoseHuman,'@RevUnMarry',False);
        end;
      end;
      Exit;
    end else begin
      //强行离婚
      if (CompareText(QuestActionInfo.sParam2, 'FORCE') = 0) then begin
        UserEngine.SendBroadCastMsg('[' + m_sCharName + ']: ' + '我宣布' {sUnMarryMsg8} + PlayObject.m_sCharName + ' ' + '与' {sMarryMsg0} + PlayObject.m_sDearName + ' ' + ' ' + '已经正式脱离夫妻关系！！！' {sUnMarryMsg9}, t_Say);
        PoseHuman := UserEngine.GetPlayObject(PlayObject.m_sDearName);
        if PoseHuman <> nil then begin
          PoseHuman.m_sDearName := '';
          Inc(PoseHuman.m_btMarryCount);
          PoseHuman.RefShowName;
        end else begin
          sUnMarryFileName := g_Config.sEnvirDir + 'UnMarry.txt';
          LoadList := TStringList.Create;
          if FileExists(sUnMarryFileName) then begin
            LoadList.LoadFromFile(sUnMarryFileName);
          end;
          LoadList.Add(PlayObject.m_sDearName);
          LoadList.SaveToFile(sUnMarryFileName);
          LoadList.Free;
        end;
        PlayObject.m_sDearName := '';
        Inc(PlayObject.m_btMarryCount);
        GotoLable(PlayObject, '@UnMarryEnd', False, False);
        PlayObject.RefShowName;
      end;
      Exit;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfUnMarry',[g_sExceptionVer]));
end;
end;

procedure TNormNpc.ActionOfStartTakeGold(PlayObject: TPlayObject);
var
  PoseHuman: TPlayObject;
begin
  try
    PoseHuman := TPlayObject(PlayObject.GetPoseCreate());
    if (PoseHuman <> nil) and (PoseHuman.GetPoseCreate = PlayObject) and (PoseHuman.m_btRaceServer = RC_PLAYOBJECT) then begin
      PlayObject.m_nDealGoldPose := 1;
      GotoLable(PlayObject, '@startdealgold', False, False);
    end else begin
      GotoLable(PlayObject, '@dealgoldpost', False, False);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfStartTakeGold',[g_sExceptionVer]));
  end;
end;


procedure TNormNpc.ClearScript;
var
  AIII, AIIII: Integer;
  I, II: Integer;
  Script: pTScript;
  SayingRecord: pTSayingRecord;
  SayingProcedure: pTSayingProcedure;
  nCode: Byte; //20090303
  boISok: Boolean;//20090708
begin
  nCode:= 0;
  boISok:= False;
  try
    if m_ScriptList.Count > 0 then begin//20080629
      nCode:= 1;
      for I := 0 to m_ScriptList.Count - 1 do begin
        nCode:= 2;
        Script := m_ScriptList.Items[I];
        if Script <> nil then begin//20090206
          nCode:= 3;
          if Script.RecordList.Count > 0 then begin//20080629
            for II := 0 to Script.RecordList.Count - 1 do begin
              nCode:= 4;
              SayingRecord := Script.RecordList.Items[II];
              if SayingRecord <> nil then begin//20090206
                nCode:= 5;
                if SayingRecord.ProcedureList <> nil then begin//20090424 增加
                  nCode:= 18;
                  try
                    if SayingRecord.ProcedureList.Count > 0 then boISok:= True;
                  except
                    boISok:= False;
                  end;
                  if boISok then begin//20090708
                  //if SayingRecord.ProcedureList.Count > 0 then begin//20080629
                    nCode:= 19;
                    for AIII := 0 to SayingRecord.ProcedureList.Count - 1 do begin
                      nCode:= 6;
                      SayingProcedure := SayingRecord.ProcedureList.Items[AIII];
                      if SayingProcedure <> nil then begin//20090206
                        nCode:= 7;
                        if SayingProcedure.ConditionList.Count > 0 then begin//20080629
                          nCode:= 71;
                          for AIIII := 0 to SayingProcedure.ConditionList.Count - 1 do begin
                            nCode:= 72;
                            if pTQuestConditionInfo(SayingProcedure.ConditionList.Items[AIIII])<> nil then begin
                              nCode:= 73;
                              pTQuestConditionInfo(SayingProcedure.ConditionList.Items[AIIII]).Script.Free;//NPC命令扩展 20090926
                              nCode:= 74;
                              Dispose(pTQuestConditionInfo(SayingProcedure.ConditionList.Items[AIIII]));
                            end;
                          end;
                        end;
                        nCode:= 8;
                        if SayingProcedure.ActionList.Count > 0 then begin//20080629
                          for AIIII := 0 to SayingProcedure.ActionList.Count - 1 do begin
                            if pTQuestActionInfo(SayingProcedure.ActionList.Items[AIIII]) <> nil then begin
                              pTQuestActionInfo(SayingProcedure.ActionList.Items[AIIII]).Script.Free;//NPC命令扩展 20090926
                              Dispose(pTQuestActionInfo(SayingProcedure.ActionList.Items[AIIII]));
                            end;
                          end;
                        end;
                        nCode:= 9;
                        if SayingProcedure.ElseActionList.Count > 0 then begin//20080629
                          for AIIII := 0 to SayingProcedure.ElseActionList.Count - 1 do begin
                            if pTQuestActionInfo(SayingProcedure.ElseActionList.Items[AIIII]) <> nil then begin
                              pTQuestActionInfo(SayingProcedure.ElseActionList.Items[AIIII]).Script.Free;//NPC命令扩展 20090926
                              Dispose(pTQuestActionInfo(SayingProcedure.ElseActionList.Items[AIIII]));
                            end;
                          end;
                        end;
                        nCode:= 10;
                        SayingProcedure.ConditionList.Free;
                        nCode:= 11;
                        SayingProcedure.ActionList.Free;
                        nCode:= 12;
                        SayingProcedure.ElseActionList.Free;
                        nCode:= 13;
                        Dispose(SayingProcedure);
                      end;
                    end; // for
                  end;
                  nCode:= 14;
                  SayingRecord.ProcedureList.Free;
                end;
                nCode:= 15;
                Dispose(SayingRecord);
              end;
            end; // for
          end;
          nCode:= 16;
          Script.RecordList.Free;
          nCode:= 17;
          Dispose(Script);
        end;
      end; // for
    end;
    m_ScriptList.Clear;
  except
    MainOutMessage(Format('{%s} TNormNpc.ClearScript Code:%d',[g_sExceptionVer, nCode]));
  end;
end;

procedure TNormNpc.Click(PlayObject: TPlayObject); //0049EC18
begin
  try
    if not m_boGhost and (PlayObject <> nil) then //20081024 增加
    begin
      PlayObject.m_sScriptCurrLable := '';
      PlayObject.m_sScriptGoBackLable := '';
      PlayObject.m_nScriptGotoCount := 0;
      GotoLable(PlayObject, '@main', False, False);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.Click',[g_sExceptionVer]));
  end;
end;

function TNormNpc.ConditionOfCheckAccountIPList(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  I: Integer;
  LoadList: TStringList;
  sCharName: string;
  sCharAccount: string;
  sCharIPaddr: string;
  sLine: string;
  sName: string;
  sIPaddr: string;
begin
  try
    Result := False;
    LoadList := TStringList.Create;
    try
      sCharName := PlayObject.m_sCharName;
      sCharAccount := PlayObject.m_sUserID;
      sCharIPaddr := PlayObject.m_sIPaddr;
      if FileExists(g_Config.sEnvirDir + QuestConditionInfo.sParam1) then begin
        LoadList.LoadFromFile(g_Config.sEnvirDir + QuestConditionInfo.sParam1);
        if LoadList.Count > 0 then begin//20080629
          for I := 0 to LoadList.Count - 1 do begin
            sLine := LoadList.Strings[I];
            if sLine <> '' then begin
              if sLine[1] = ';' then Continue;
              sIPaddr := GetValidStr3(sLine, sName, [' ', '/', #9]);
              sIPaddr := Trim(sIPaddr);
              if (sName = sCharAccount) and (sIPaddr = sCharIPaddr) then begin
                Result := True;
                Break;
              end;
            end;
          end;
        end;
      end else begin
        ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKACCOUNTIPLIST);
      end;
    finally
      LoadList.Free
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckAccountIPList',[g_sExceptionVer]));
  end;
end;
//功能：检查人物背包空格数,Hero则判断英雄的背包
//命令：CheckBagSize 数量 Hero
function TNormNpc.ConditionOfCheckBagSize(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nSize: Integer;
begin
  try
    Result := False;
    nSize:=Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam1),-1);//20090304
    if nSize < 0 then begin
      if not GetValValue(PlayObject, QuestConditionInfo.sParam1, nSize) then begin //增加变量支持
        nSize := QuestConditionInfo.nParam1;
      end;
    end;
    if (nSize <= 0) or (nSize > MAXHEROBAGITEM) then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKBAGSIZE);
      Exit;
    end;

    if CompareText(QuestConditionInfo.sParam2, 'HERO') = 0 then begin//20080822 判断英雄的背包
      {$IF HEROVERSION = 1}
      if PlayObject.m_MyHero <> nil then begin
        if PlayObject.m_MyHero.m_ItemList.Count + nSize <= MAXHEROBAGITEM then Result := True;
      end;
      {$IFEND}
    end else begin
      if PlayObject.m_ItemList.Count + nSize <= MAXBAGITEM then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckBagSize',[g_sExceptionVer]));
  end;
end;


function TNormNpc.ConditionOfCheckBonusPoint(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nTotlePoint, nCount: Integer;
  cMethod: Char;
begin
try
  Result := False;
  nTotlePoint := PlayObject.m_BonusAbil.DC +
    PlayObject.m_BonusAbil.MC +
    PlayObject.m_BonusAbil.SC +
    PlayObject.m_BonusAbil.AC +
    PlayObject.m_BonusAbil.MAC +
    PlayObject.m_BonusAbil.HP +
    PlayObject.m_BonusAbil.MP +
    PlayObject.m_BonusAbil.Hit +
    PlayObject.m_BonusAbil.Speed +
    PlayObject.m_BonusAbil.X2;
  nTotlePoint := nTotlePoint + PlayObject.m_nBonusPoint;
  cMethod := QuestConditionInfo.sParam1[1];
  if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nCount) then begin //增加变量支持
    nCount := QuestConditionInfo.nParam2;
  end;
  case cMethod of
    '=': if nTotlePoint = nCount then Result := True;
    '>': if nTotlePoint > nCount then Result := True;
    '<': if nTotlePoint < nCount then Result := True;
  else if nTotlePoint >= nCount then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckBonusPoint',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckHP(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethodMin, cMethodMax: Char;
  nMIN, nMax: Integer;
  function CheckHigh(): Boolean;
  begin
    Result := False;
    case cMethodMax of
      '=': begin
          if PlayObject.m_WAbil.MaxHP = nMax then begin
            Result := True;
          end;
        end;
      '>': begin
          if PlayObject.m_WAbil.MaxHP > nMax then begin
            Result := True;
          end;
        end;
      '<': begin
          if PlayObject.m_WAbil.MaxHP < nMax then begin
            Result := True;
          end;
        end;
    else begin
        if PlayObject.m_WAbil.MaxHP >= nMax then begin
          Result := True;
        end;
      end;
    end;
  end;
begin
try
  Result := False;
  cMethodMin := QuestConditionInfo.sParam1[1];
  cMethodMax := QuestConditionInfo.sParam1[3];
  nMIN := Str_ToInt(QuestConditionInfo.sParam2, -1);
  nMax := Str_ToInt(QuestConditionInfo.sParam4, -1);
  if (nMIN < 0) or (nMax < 0) then begin
    ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKHP);
    Exit;
  end;

  case cMethodMin of
    '=': begin
        if (m_WAbil.HP = nMIN) then begin
          Result := CheckHigh;
        end;
      end;
    '>': begin
        if (PlayObject.m_WAbil.HP > nMIN) then begin
          Result := CheckHigh;
        end;
      end;
    '<': begin
        if (PlayObject.m_WAbil.HP < nMIN) then begin
          Result := CheckHigh;
        end;
      end;
  else begin
      if (PlayObject.m_WAbil.HP >= nMIN) then begin
        Result := CheckHigh;
      end;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckHP',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckMP(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethodMin, cMethodMax: Char;
  nMIN, nMax: Integer;
  function CheckHigh(): Boolean;
  begin
    Result := False;
    case cMethodMax of
      '=': begin
          if PlayObject.m_WAbil.MaxMP = nMax then begin
            Result := True;
          end;
        end;
      '>': begin
          if PlayObject.m_WAbil.MaxMP > nMax then begin
            Result := True;
          end;
        end;
      '<': begin
          if PlayObject.m_WAbil.MaxMP < nMax then begin
            Result := True;
          end;
        end;
    else begin
        if PlayObject.m_WAbil.MaxMP >= nMax then begin
          Result := True;
        end;
      end;
    end;
  end;
begin
try
  Result := False;
  cMethodMin := QuestConditionInfo.sParam1[1];
  cMethodMax := QuestConditionInfo.sParam1[3];
  nMIN := Str_ToInt(QuestConditionInfo.sParam2, -1);
  nMax := Str_ToInt(QuestConditionInfo.sParam4, -1);
  if (nMIN < 0) or (nMax < 0) then begin
    ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKMP);
    Exit;
  end;
  case cMethodMin of
    '=': begin
        if (m_WAbil.MP = nMIN) then begin
          Result := CheckHigh;
        end;
      end;
    '>': begin
        if (PlayObject.m_WAbil.MP > nMIN) then begin
          Result := CheckHigh;
        end;
      end;
    '<': begin
        if (PlayObject.m_WAbil.MP < nMIN) then begin
          Result := CheckHigh;
        end;
      end;
  else begin
      if (PlayObject.m_WAbil.MP >= nMIN) then begin
        Result := CheckHigh;
      end;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckMP',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckDC(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethodMin, cMethodMax: Char;
  nMIN, nMax: Integer;
  function CheckHigh(): Boolean;
  begin
    Result := False;
    case cMethodMax of
      '=': begin
          if HiWord(PlayObject.m_WAbil.DC) = nMax then begin
            Result := True;
          end;
        end;
      '>': begin
          if HiWord(PlayObject.m_WAbil.DC) > nMax then begin
            Result := True;
          end;
        end;
      '<': begin
          if HiWord(PlayObject.m_WAbil.DC) < nMax then begin
            Result := True;
          end;
        end;
    else begin
        if HiWord(PlayObject.m_WAbil.DC) >= nMax then begin
          Result := True;
        end;
      end;
    end;
  end;
begin
try
  Result := False;
  cMethodMin := QuestConditionInfo.sParam1[1];
  cMethodMax := QuestConditionInfo.sParam1[3];
  nMIN := Str_ToInt(QuestConditionInfo.sParam2, -1);
  nMax := Str_ToInt(QuestConditionInfo.sParam4, -1);
  if (nMIN < 0) or (nMax < 0) then begin
    ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKDC);
    Exit;
  end;
  case cMethodMin of
    '=': begin
        if (LoWord(PlayObject.m_WAbil.DC) = nMIN) then begin
          Result := CheckHigh;
        end;
      end;
    '>': begin
        if (LoWord(PlayObject.m_WAbil.DC) > nMIN) then begin
          Result := CheckHigh;
        end;
      end;
    '<': begin
        if (LoWord(PlayObject.m_WAbil.DC) < nMIN) then begin
          Result := CheckHigh;
        end;
      end;
  else begin
      if (LoWord(PlayObject.m_WAbil.DC) >= nMIN) then begin
        Result := CheckHigh;
      end;
    end;
  end;
  Result := False;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckDC',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckMC(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethodMin, cMethodMax: Char;
  nMIN, nMax: Integer;
  function CheckHigh(): Boolean;
  begin
    Result := False;
    case cMethodMax of
      '=': begin
          if HiWord(PlayObject.m_WAbil.MC) = nMax then begin
            Result := True;
          end;
        end;
      '>': begin
          if HiWord(PlayObject.m_WAbil.MC) > nMax then begin
            Result := True;
          end;
        end;
      '<': begin
          if HiWord(PlayObject.m_WAbil.MC) < nMax then begin
            Result := True;
          end;
        end;
    else begin
        if HiWord(PlayObject.m_WAbil.MC) >= nMax then begin
          Result := True;
        end;
      end;
    end;
  end;
begin
try
  Result := False;
  cMethodMin := QuestConditionInfo.sParam1[1];
  cMethodMax := QuestConditionInfo.sParam1[3];
  nMIN := Str_ToInt(QuestConditionInfo.sParam2, -1);
  nMax := Str_ToInt(QuestConditionInfo.sParam4, -1);
  if (nMIN < 0) or (nMax < 0) then begin
    ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKMC);
    Exit;
  end;

  case cMethodMin of
    '=': begin
        if (LoWord(PlayObject.m_WAbil.MC) = nMIN) then begin
          Result := CheckHigh;
        end;
      end;
    '>': begin
        if (LoWord(PlayObject.m_WAbil.MC) > nMIN) then begin
          Result := CheckHigh;
        end;
      end;
    '<': begin
        if (LoWord(PlayObject.m_WAbil.MC) < nMIN) then begin
          Result := CheckHigh;
        end;
      end;
  else begin
      if (LoWord(PlayObject.m_WAbil.MC) >= nMIN) then begin
        Result := CheckHigh;
      end;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckMC',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckSC(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethodMin, cMethodMax: Char;
  nMIN, nMax: Integer;
  function CheckHigh(): Boolean;
  begin
    Result := False;
    case cMethodMax of
      '=': begin
          if HiWord(PlayObject.m_WAbil.SC) = nMax then begin
            Result := True;
          end;
        end;
      '>': begin
          if HiWord(PlayObject.m_WAbil.SC) > nMax then begin
            Result := True;
          end;
        end;
      '<': begin
          if HiWord(PlayObject.m_WAbil.SC) < nMax then begin
            Result := True;
          end;
        end;
    else begin
        if HiWord(PlayObject.m_WAbil.SC) >= nMax then begin
          Result := True;
        end;
      end;
    end;
  end;
begin
try
  Result := False;
  cMethodMin := QuestConditionInfo.sParam1[1];
  cMethodMax := QuestConditionInfo.sParam1[3];
  nMIN := Str_ToInt(QuestConditionInfo.sParam2, -1);
  nMax := Str_ToInt(QuestConditionInfo.sParam4, -1);
  if (nMIN < 0) or (nMax < 0) then begin
    ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKSC);
    Exit;
  end;

  case cMethodMin of
    '=': begin
        if (LoWord(PlayObject.m_WAbil.SC) = nMIN) then begin
          Result := CheckHigh;
        end;
      end;
    '>': begin
        if (LoWord(PlayObject.m_WAbil.SC) > nMIN) then begin
          Result := CheckHigh;
        end;
      end;
    '<': begin
        if (LoWord(PlayObject.m_WAbil.SC) < nMIN) then begin
          Result := CheckHigh;
        end;
      end;
  else begin
      if (LoWord(PlayObject.m_WAbil.SC) >= nMIN) then begin
        Result := CheckHigh;
      end;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckSC',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckExp(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethod: Char;
  dwExp: Int64;
begin
  try
    Result := False;
    //dwExp := Str_ToInt(QuestConditionInfo.sParam2, 0);
    dwExp := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),0);//20090409 支持变量操作
    if dwExp = 0 then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKEXP);
      Exit;
    end;
    cMethod := QuestConditionInfo.sParam1[1];
    case cMethod of
      '=': if PlayObject.m_Abil.nExp = dwExp then Result := True;
      '>': if PlayObject.m_Abil.nExp > dwExp then Result := True;
      '<': if PlayObject.m_Abil.nExp < dwExp then Result := True;
    else if PlayObject.m_Abil.nExp >= dwExp then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckExp',[g_sExceptionVer]));
  end;
end;

function TNormNpc.ConditionOfCheckFlourishPoint(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethod: Char;
  nPoint: Integer;
  Guild: TGUild;
begin
try
  Result := False;
  nPoint := Str_ToInt(QuestConditionInfo.sParam2, -1);
  if nPoint < 0 then begin
    if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nPoint) then begin //增加变量支持
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKFLOURISHPOINT);
      Exit;
    end;
  end;
  if PlayObject.m_MyGuild = nil then begin
    Exit;
  end;
  Guild := TGUild(PlayObject.m_MyGuild);
  cMethod := QuestConditionInfo.sParam1[1];
  case cMethod of
    '=': if Guild.nFlourishing = nPoint then Result := True;
    '>': if Guild.nFlourishing > nPoint then Result := True;
    '<': if Guild.nFlourishing < nPoint then Result := True;
  else if Guild.nFlourishing >= nPoint then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckFlourishPoint',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckChiefItemCount(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethod: Char;
  nCount: Integer;
  Guild: TGUild;
begin
try
  Result := False;
  nCount := Str_ToInt(QuestConditionInfo.sParam2, -1);
  if nCount < 0 then begin
    ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKFLOURISHPOINT);
    Exit;
  end;
  if PlayObject.m_MyGuild = nil then begin
    Exit;
  end;
  Guild := TGUild(PlayObject.m_MyGuild);
  cMethod := QuestConditionInfo.sParam1[1];
  case cMethod of
    '=': if Guild.nChiefItemCount = nCount then Result := True;
    '>': if Guild.nChiefItemCount > nCount then Result := True;
    '<': if Guild.nChiefItemCount < nCount then Result := True;
  else if Guild.nChiefItemCount >= nCount then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckChiefItemCount',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckGuildAuraePoint(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethod: Char;
  nPoint: Integer;
  Guild: TGUild;
begin
try
  Result := False;
  nPoint := Str_ToInt(QuestConditionInfo.sParam2, -1);
  if nPoint < 0 then begin
    if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nPoint) then begin //增加变量支持
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKAURAEPOINT);
      Exit;
    end;
  end;
  if PlayObject.m_MyGuild = nil then begin
    Exit;
  end;
  Guild := TGUild(PlayObject.m_MyGuild);
  cMethod := QuestConditionInfo.sParam1[1];
  case cMethod of
    '=': if Guild.nAurae = nPoint then Result := True;
    '>': if Guild.nAurae > nPoint then Result := True;
    '<': if Guild.nAurae < nPoint then Result := True;
  else if Guild.nAurae >= nPoint then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckGuildAuraePoint',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckGuildBuildPoint(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethod: Char;
  nPoint: Integer;
  Guild: TGUild;
begin
try
  Result := False;
  nPoint := Str_ToInt(QuestConditionInfo.sParam2, -1);
  if nPoint < 0 then begin
    if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nPoint) then begin //增加变量支持
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKBUILDPOINT);
      Exit;
    end;
  end;
  if PlayObject.m_MyGuild = nil then begin
    Exit;
  end;
  Guild := TGUild(PlayObject.m_MyGuild);
  cMethod := QuestConditionInfo.sParam1[1];
  case cMethod of
    '=': if Guild.nBuildPoint = nPoint then Result := True;
    '>': if Guild.nBuildPoint > nPoint then Result := True;
    '<': if Guild.nBuildPoint < nPoint then Result := True;
  else if Guild.nBuildPoint >= nPoint then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckGuildBuildPoint',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckStabilityPoint(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethod: Char;
  nPoint: Integer;
  Guild: TGUild;
begin
  try
    Result := False;
    nPoint := Str_ToInt(QuestConditionInfo.sParam2, -1);
    if nPoint < 0 then begin
      if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nPoint) then begin //增加变量支持
        ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKSTABILITYPOINT);
        Exit;
      end;
    end;
    if PlayObject.m_MyGuild = nil then begin
      Exit;
    end;
    Guild := TGUild(PlayObject.m_MyGuild);
    cMethod := QuestConditionInfo.sParam1[1];
    case cMethod of
      '=': if Guild.nStability = nPoint then Result := True;
      '>': if Guild.nStability > nPoint then Result := True;
      '<': if Guild.nStability < nPoint then Result := True;
    else if Guild.nStability >= nPoint then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckStabilityPoint',[g_sExceptionVer]));
  end;
end;
//检查当前人物身上有多少游戏币
function TNormNpc.ConditionOfCheckGameGold(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethod: Char;
  nGameGold: Integer;
begin
  try
    Result := False;
    nGameGold:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080430
    if nGameGold < 0 then begin
      if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nGameGold) then begin //增加变量支持
        //ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKGAMEGOLD);//20100210 注释
        Exit;
      end;
    end;
    cMethod := QuestConditionInfo.sParam1[1];
    case cMethod of
      '=': if PlayObject.m_nGameGold = nGameGold then Result := True;
      '>': if PlayObject.m_nGameGold > nGameGold then Result := True;
      '<': if PlayObject.m_nGameGold < nGameGold then Result := True;
    else if PlayObject.m_nGameGold >= nGameGold then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckGameGold',[g_sExceptionVer]));
  end;
end;
//功能：检查字符串的长度
//格式：CheckStringlength 字符串 操作符(<,>,=) 位数
function TNormNpc.ConditionOfCheckStringlength(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethod: Char;
  nLength: Integer;
  sMag: String;
begin
  Result := False;
  try
    nLength:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam3),-1);//位数
    if nLength < 0 then begin//20090507 增加
      if not GetValValue(PlayObject, QuestConditionInfo.sParam3, nLength) then begin //增加变量支持
        nLength := QuestConditionInfo.nParam3;
      end;
    end;
    sMag:= GetLineVariableText(PlayObject, QuestConditionInfo.sParam1); //字符串
    if (nLength < 0) {or (sMag = '')} then begin//20090805 修改
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CheckStringlength);
      Exit;
    end;
    cMethod := QuestConditionInfo.sParam2[1];
    case cMethod of
      '=': if Length(sMag) = nLength then Result := True;
      '>': if Length(sMag) > nLength then Result := True;
      '<': if Length(sMag) < nLength then Result := True;
    else if Length(sMag) >= nLength then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckStringlength',[g_sExceptionVer]));
  end;
end;

//查检金刚石条件 20071226
function TNormNpc.ConditionOfCheckGameDiaMond(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethod: Char;
  nGameDiaMond: Integer;
begin
try
  Result := False;
  //nGameDiaMond := Str_ToInt(QuestConditionInfo.sParam2, -1); //20080430
  nGameDiaMond:=Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080430

  if nGameDiaMond < 0 then begin
    if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nGameDiaMond) then begin //增加变量支持
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKGAMEDIAMOND);
      Exit;
    end;
  end;

  cMethod := QuestConditionInfo.sParam1[1];
  case cMethod of
    '=': if PlayObject.m_nGameDiaMond = nGameDiaMond then Result := True;
    '>': if PlayObject.m_nGameDiaMond > nGameDiaMond then Result := True;
    '<': if PlayObject.m_nGameDiaMond < nGameDiaMond then Result := True;
  else if PlayObject.m_nGameDiaMond >= nGameDiaMond then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckGameDiaMond',[g_sExceptionVer]));
end;
end;
//查检灵符条件 20071226
function TNormNpc.ConditionOfCheckGameGird(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethod: Char;
  nGameGird: Integer;
begin
try
  Result := False;
  //nGameGird := Str_ToInt(QuestConditionInfo.sParam2, -1);//20080430
  nGameGird:=Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080430
  if nGameGird < 0 then begin
    if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nGameGird) then begin //增加变量支持
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKGAMEGIRD);
      Exit;
    end;
  end;
  cMethod := QuestConditionInfo.sParam1[1];
  case cMethod of
    '=': if PlayObject.m_nGameGird = nGameGird then Result := True;
    '>': if PlayObject.m_nGameGird > nGameGird then Result := True;
    '<': if PlayObject.m_nGameGird < nGameGird then Result := True;
  else if PlayObject.m_nGameGird >= nGameGird then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckGameGird',[g_sExceptionVer]));
end;
end;
//检查荣誉值 20080511
function TNormNpc.ConditionOfCheckGameGLORY(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethod: Char;
  nGameGlory: Integer;
begin
try
  Result := False;
  nGameGlory:=Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080430
  if nGameGlory < 0 then begin
    if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nGameGlory) then begin //增加变量支持
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKGAMEGLORY);
      Exit;
    end;
  end;
  cMethod := QuestConditionInfo.sParam1[1];
  case cMethod of
    '=': if PlayObject.m_btGameGlory = nGameGlory then Result := True;
    '>': if PlayObject.m_btGameGlory > nGameGlory then Result := True;
    '<': if PlayObject.m_btGameGlory < nGameGlory then Result := True;
  else if PlayObject.m_btGameGlory >= nGameGlory then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckGameGLORY',[g_sExceptionVer]));
end;
end;
//------------------------------------------------------------------------------
//检查技能等级 20080512
//CHECKSKILLLEVEL 技能名 控制符(=,>,<) 等级数(0-99) HERO
function TNormNpc.ConditionOfCHECKSKILLLEVEL(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  UserMagic: pTUserMagic;
  nLevel: Integer;
  cMethod: Char;
  sMagicName: String;
begin
  try
    Result := False;
    nLevel := _MIN( 99{4}, Str_ToInt(QuestConditionInfo.sParam3, 0));//20100922 修改 
    sMagicName:= GetLineVariableText(PlayObject,QuestConditionInfo.sParam1);
    cMethod := QuestConditionInfo.sParam2[1];
    if (nLevel < 0) or (sMagicName = '') and (cMethod = '')  then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKSKILLLEVEL);
      Exit;
    end;
    if CompareText(QuestConditionInfo.sParam4, 'HERO') = 0 then begin
      {$IF HEROVERSION = 1}
      if PlayObject.m_MyHero <> nil then begin
        UserMagic:= TPlayObject(PlayObject.m_MyHero).GetMagicInfo(sMagicName);
        if UserMagic <> nil then begin
          case cMethod of
            '=': if UserMagic.btLevel = nLevel then Result := True;
            '>': if UserMagic.btLevel > nLevel then Result := True;
            '<': if UserMagic.btLevel < nLevel then Result := True;
          else if UserMagic.btLevel >= nLevel then Result := True;
          end;
        end;
      end;
      {$IFEND}
    end else begin
      UserMagic:= PlayObject.GetMagicInfo(sMagicName);
      if UserMagic <> nil then begin
        case cMethod of
          '=': if UserMagic.btLevel = nLevel then Result := True;
          '>': if UserMagic.btLevel > nLevel then Result := True;
          '<': if UserMagic.btLevel < nLevel then Result := True;
        else if UserMagic.btLevel >= nLevel then Result := True;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKSKILLLEVEL',[g_sExceptionVer]));
  end;
end;
//------------------------------------------------------------------------------
//检查地图指定坐标指定名称怪物数量 20081217 修改
//CHECKMAPMOBCOUNT 地图 X Y 怪名 ><= 数量 范围
function TNormNpc.ConditionOfCHECKMAPMOBCOUNT(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethod: Char;
  nCount,MonCount: Integer;
  Envir: TEnvirnoment;
  sMap:String;
begin
  try
    Result := False;
    nCount:= Str_ToInt(QuestConditionInfo.sParam6, -1);//数量
    sMap:=GetLineVariableText(PlayObject, QuestConditionInfo.sParam1); //地图ID 支持变量

    Envir := g_MapManager.FindMap(sMap);
    MonCount:=UserEngine.GetMapMonsterCount(Envir, QuestConditionInfo.nParam2,QuestConditionInfo.nParam3, QuestConditionInfo.nParam7, Trim(QuestConditionInfo.sParam4));

    cMethod := QuestConditionInfo.sParam5[1];
    case cMethod of //比较怪物数量
      '=': if MonCount = nCount then Result := True;
      '>': if MonCount > nCount then Result := True;
      '<': if MonCount < nCount then Result := True;
    else if MonCount >= nCount then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKMAPMOBCOUNT',[g_sExceptionVer]));
  end;
end;
//------------------------------------------------------------------------------
//检查人物周围自己宝宝数量 20080425
//格式：CHECKSIDESLAVENAME 怪物名称(*代表所有) 范围 (>,<,=) 数量
function TNormNpc.ConditionOfCHECKSIDESLAVENAME(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  sMonName: String;
  cMethod: Char;
  nCount,nRange,slavCount,I ,K: Integer;
  MonList: TList;
  MoveMon,Slave: TBaseObject;
  boAllSlave: Boolean;
begin
  try
    Result := False;
    boAllSlave:= False;
    SlavCount:= 0;
    sMonName:= GetLineVariableText(PlayObject, QuestConditionInfo.sParam1); //怪物名称
    nRange:=Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2), -1);//范围 支持变量
    nCount:=Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam4), -1);//数量 支持变量
    cMethod := QuestConditionInfo.sParam3[1];//操作符
    if  sMonName='*' then boAllSlave:= True;

    MonList := TList.Create;
    try
      UserEngine.GetMapRangeMonster(PlayObject.m_PEnvir, PlayObject.m_nCurrX, PlayObject.m_nCurrY, nRange, MonList);//查指定XY范围内的怪
      if MonList.Count > 0 then begin//20080629
        for I := 0 to MonList.Count - 1 do begin
          MoveMon := TBaseObject(MonList.Items[I]);
          if MoveMon <> nil then begin//20090212
            if PlayObject.m_SlaveList.Count > 0 then begin//20080629
              for K:=0 to PlayObject.m_SlaveList.Count - 1 do begin
                Slave:= TBaseObject(PlayObject.m_SlaveList.Items[K]);
                if (Slave <> nil) then begin
                  if not boAllSlave then begin
                    if (CompareText(Slave.m_sCharName,sMonName)= 0) and (Slave = MoveMon) then Inc(SlavCount);
                  end else
                    if (Slave = MoveMon) then Inc(SlavCount);
                end;
              end;//for
            end;
          end;
        end;//for
      end;
    finally
      MonList.Free;
    end;

    case cMethod of //比较怪物数量
      '=': if SlavCount = nCount then Result := True;
      '>': if SlavCount > nCount then Result := True;
      '<': if SlavCount < nCount then Result := True;
    else if SlavCount >= nCount then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKSIDESLAVENAME',[g_sExceptionVer]));
  end;
end;
//------------------------------------------------------------------------------
//检测当前日期是否小于大于等于指定的日期,检测后日期差存放在人物的M0中   20110722 修改
//CHECKCURRENTDATE ><= 日期
function TNormNpc.ConditionOfCHECKCURRENTDATE(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethod: Char;//操作符
  sDate:String;//指定的日期
begin
  try
    Result := False;
    sDate:= QuestConditionInfo.sParam2;//指定的日期
    cMethod := QuestConditionInfo.sParam1[1];

    case cMethod of //比较指定日期写当前日期
      '=': if Trunc(Date) = Trunc(StrToDate(sDate)) then Result := True;
      '>': if Date > StrToDate(sDate) then Result := True;
      '<': if Date < StrToDate(sDate) then Result := True;
    end;

    if Date < StrToDate(sDate) then
       PlayObject.m_nMval[0]:= Trunc(Date - StrToDate(sDate))
    else
    if Date > StrToDate(sDate) then
       PlayObject.m_nMval[0]:= - Trunc(Date - StrToDate(sDate))//负数
    else
    if Trunc(Date) = Trunc(StrToDate(sDate)) then PlayObject.m_nMval[0]:= 0;
  except
    on E: Exception do MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKCURRENTDATE %s',[g_sExceptionVer, E.Message]));
  end;
end;
//------------------------------------------------------------------------------
//检查是否在攻城期间 20080422
//格式:CHECKCASTLEWAR 城堡名称
function TNormNpc.ConditionOfCHECKCASTLEWAR(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  Castle: TUserCastle;
  CastleName: String;
begin
  try
    Result := False;
    CastleName:= GetLineVariableText(PlayObject, QuestConditionInfo.sParam1); //城堡名称 支持变量
    Castle:= g_CastleManager.Find(CastleName);
    if Castle <> nil then begin
      if Castle.m_boUnderWar then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKCASTLEWAR',[g_sExceptionVer]));
  end;
end;
//------------------------------------------------------------------------------
//检测师傅（或徒弟）是否在线 20080416
//格式:CHECKMASTERONLINE
function TNormNpc.ConditionOfCHECKMASTERONLINE(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  m_MasterHuman: TPlayObject;
begin
try
  Result := False;
  if PlayObject.m_boMaster then begin //有徒弟
    //m_MasterHuman := UserEngine.GetPlayObject(PlayObject.m_sMasterName);
    m_MasterHuman := UserEngine.GetMasterObject(PlayObject.m_sCharName);//20080512
    if m_MasterHuman <> nil then Result := True;
  end else
    if PlayObject.m_sMasterName <> '' then begin
      m_MasterHuman := UserEngine.GetPlayObject(PlayObject.m_sMasterName);
      if m_MasterHuman <> nil then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKMASTERONLINE',[g_sExceptionVer]));
end;
end;
//------------------------------------------------------------------------------
//检测夫妻一方是否在线 20080416
//格式:CHECKDEARONLINE
function TNormNpc.ConditionOfCHECKDEARONLINE(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
try
  Result := False;
  if PlayObject.m_DearHuman <> nil then Result := True;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKDEARONLINE',[g_sExceptionVer]));
end;
end;
//------------------------------------------------------------------------------
//检测师傅(或徒弟)是否在XXX地图,支持SELF(是否同一地图) 20080416
//格式:CHECKMASTERONMAP XXX
function TNormNpc.ConditionOfCHECKMASTERONMAP(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  m_MasterHuman: TPlayObject;
  sMapName: string;
begin
try
  Result := False;
  if CompareText(QuestConditionInfo.sParam1, 'Self') = 0 then begin
    sMapName := PlayObject.m_sMapName;
  end else begin
    sMapName := QuestConditionInfo.sParam1;
    GetValValue(PlayObject, QuestConditionInfo.sParam1, sMapName);
  end;

  if PlayObject.m_boMaster then begin //有徒弟
    //m_MasterHuman := UserEngine.GetPlayObject(PlayObject.m_sMasterName);
    m_MasterHuman := UserEngine.GetMasterObject(PlayObject.m_sCharName);//20080512
    if (m_MasterHuman <> nil) and (CompareText(m_MasterHuman.m_sMapName , sMapName)= 0) then Result := True;
  end else
    if PlayObject.m_sMasterName <> '' then begin
      m_MasterHuman := UserEngine.GetPlayObject(PlayObject.m_sMasterName);
      if (m_MasterHuman <> nil) and (CompareText(m_MasterHuman.m_sMapName,sMapName)= 0) then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKMASTERONMAP',[g_sExceptionVer]));
end;
end;
//------------------------------------------------------------------------------
//检测夫妻一方是否在XXX地图,支持SELF(是否同一地图) 20080416
//格式:CHECKDEARONMAP XXX
function TNormNpc.ConditionOfCHECKDEARONMAP(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  sMapName: string;
begin
try
  Result := False;
  if CompareText(QuestConditionInfo.sParam1, 'Self') = 0 then begin
    sMapName := PlayObject.m_sMapName;
  end else begin
    sMapName := QuestConditionInfo.sParam1;
    GetValValue(PlayObject, QuestConditionInfo.sParam1, sMapName);
  end;
  if (PlayObject.m_DearHuman <> nil) and (CompareText(PlayObject.m_DearHuman.m_sMapName,sMapName)=0) then Result := True;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKDEARONMAP',[g_sExceptionVer]));
end;
end;
//------------------------------------------------------------------------------
//检测对面是否为自己的徒弟 20080416
//格式:CHECKPOSEISPRENTICE
function TNormNpc.ConditionOfCHECKPOSEISPRENTICE(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  BaseObject: TBaseObject;
begin
try
  Result := False;
  BaseObject := GetPoseCreate();//判断面对面是否有人物
  if BaseObject <> nil then begin
    if TPlayObject(BaseObject).m_boMaster then begin //有徒弟
      if CompareText(TPlayObject(BaseObject).m_sMasterName , PlayObject.m_sCharName)= 0 then Result := True;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKPOSEISPRENTICE',[g_sExceptionVer]));
end;
end;
//------------------------------------------------------------------------------
//脚本命令 FINDMAPPATH 地图 起步X 起步Y 终点X 终点Y (只要使用一次既可) 20080124
function TNormNpc.ConditionOfFINDMAPPATH(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  sMap: string;
  nX,nY,nXX,nYY: Integer;
  Envir: TEnvirnoment;
begin
try
  Result := False;
  sMap:= GetLineVariableText(PlayObject, QuestConditionInfo.sParam1); //地图支持变量
  nX:=Str_ToInt(QuestConditionInfo.sParam2, -1);//起步X
  nY:=Str_ToInt(QuestConditionInfo.sParam3, -1);//起步Y
  nXX:=Str_ToInt(QuestConditionInfo.sParam4, -1);//终点X
  nYY:=Str_ToInt(QuestConditionInfo.sParam5, -1);//终点Y
  if sMap='' then Exit;

  Envir := g_MapManager.FindMap(sMap);//查找地图
  if Envir <> nil then begin
    //UserEngine.m_sMapName_136:=sMap;//20090204
    UserEngine.m_nCurrX_136:=nX;
    UserEngine.m_nCurrY_136:=nY;
    UserEngine.m_NewCurrX_136:=nXX;
    UserEngine.m_NewCurrY_136:=nYY;
    PlayObject.m_sMapName136:= sMap; //魔王岭地图名称 20090204

    {g_boMission := True; //设置怪物集中点  20090204
    g_sMissionMap := sMap;
    g_nMissionX := nX;
    g_nMissionY := nY;}

    Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfFINDMAPPATH',[g_sExceptionVer]));
end;
end;
//-------------------------------------------------------------------------
//检测英雄的忠诚度 20080109
function TNormNpc.ConditionOfCHECKHEROLOYAL(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethod: Char;
  nLoyal: Integer;
begin
{$IF HEROVERSION = 1}
try
  Result := False;
  if PlayObject.m_MyHero =nil then  Exit;
  nLoyal := Str_ToInt(QuestConditionInfo.sParam2, -1);
  if nLoyal < 0 then begin
    if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nLoyal) then begin //增加变量支持
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKHEROLOYAL);
      Exit;
    end;
  end;
  cMethod := QuestConditionInfo.sParam1[1];
  case cMethod of
    '=': if THeroObject(PlayObject.m_MyHero).m_nLoyal = nLoyal then Result := True;
    '>': if THeroObject(PlayObject.m_MyHero).m_nLoyal > nLoyal then Result := True;
    '<': if THeroObject(PlayObject.m_MyHero).m_nLoyal < nLoyal then Result := True;
  else if THeroObject(PlayObject.m_MyHero).m_nLoyal >= nLoyal then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKHEROLOYAL',[g_sExceptionVer]));
end;
{$IFEND}
end;
//------------------------------------------------------------------------------
//判断是否在酿哪种酒 20080620
//格式:ISONMAKEWINE X(1,2)  X-1普通酒 2-药酒
function TNormNpc.ConditionOfISONMAKEWINE(PlayObject: TPlayObject;QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nMakeWineType:Byte;
begin
try
  Result := False;
  nMakeWineType:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam1), 0);
  if not nMakeWineType in [1,2] then begin
    ScriptConditionError(PlayObject, QuestConditionInfo, sISONMAKEWINE);
    Exit;
  end;
  if PlayObject.m_boMakeWine then begin//在NPC处正在酿酒
     if PlayObject.n_MakeWineType = nMakeWineType then Result := True;//酒的类型一致
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfISONMAKEWINE',[g_sExceptionVer]));
end;
end;
//------------------------------------------------------------------------------
//功能:判断是否开启行会泉水仓库 20080625
//格式:CHECKGUILDFOUNTAIN
function TNormNpc.ConditionOfCHECKGUILDFOUNTAIN(PlayObject: TPlayObject;QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
try
  Result := False;
  if PlayObject.m_MyGuild <> nil then begin
    if TGUild(PlayObject.m_MyGuild).boGuildFountainOpen then Result:=True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKGUILDFOUNTAIN',[g_sExceptionVer]));
end;
end;
//------------------------------------------------------------------------------
//检测能量点
function TNormNpc.ConditionOfCheckGamePoint(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethod: Char;
  nGamePoint: Integer;
begin
try
  Result := False;
  nGamePoint:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2), -1);//20080519
  if nGamePoint < 0 then nGamePoint := QuestConditionInfo.nParam2;
  //nGamePoint := Str_ToInt(QuestConditionInfo.sParam2, -1);
  if nGamePoint < 0 then begin
    if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nGamePoint) then begin //增加变量支持
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKGAMEPOINT);
      Exit;
    end;
  end;
  cMethod := QuestConditionInfo.sParam1[1];
  case cMethod of
    '=': if PlayObject.m_nGamePoint = nGamePoint then Result := True;
    '>': if PlayObject.m_nGamePoint > nGamePoint then Result := True;
    '<': if PlayObject.m_nGamePoint < nGamePoint then Result := True;
  else if PlayObject.m_nGamePoint >= nGamePoint then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckGamePoint',[g_sExceptionVer]));
end;
end;
//功能: 检测人物在指定排行榜中的名次 20110113
//格式：CHECKSELFSORT <>= 榜单(1-等级榜\2-战士榜\3-法师榜\4-道士榜) 名次
//例子:CHECKSELFSORT < 1 100
function TNormNpc.ConditionOfCheckSelfSort(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nType: Byte;
  nIndex, n14: Integer;
  cMethod: Char;
  function GetSelfHumMsg(HumSort: THumSort; sName:string):Integer;
  var
    i: integer;
  begin
    Result:= MAXORDERSCOUNT + 1;
    for I := 0 to HumSort.nMaxIdx - 1 do begin
      if CompareText(HumSort.List[I].sChrName, sName) = 0 then begin
        Result:= HumSort.List[I].nIndex;
        break;
      end;
    end;
  end;
begin
  Result := False;
  n14:= -1;
  try
    nType:= QuestConditionInfo.nParam2;//排行榜类型
    nIndex:= QuestConditionInfo.nParam3;//名次
    if (not nType in [1..4]) or (nIndex <= 0) or (nIndex > MAXORDERSCOUNT) then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKSELFSORT);
      Exit;
    end;
    EnterCriticalSection(HumanSortCriticalSection);
    try
      case nType of
        1: n14:= GetSelfHumMsg(g_TaxisAllList,PlayObject.m_sCharName);
        2: n14:= GetSelfHumMsg(g_TaxisWarrList,PlayObject.m_sCharName);
        3: n14:= GetSelfHumMsg(g_TaxisWaidList,PlayObject.m_sCharName);
        4: n14:= GetSelfHumMsg(g_TaxisTaosList,PlayObject.m_sCharName);
      end;
    finally
      LeaveCriticalSection(HumanSortCriticalSection);
    end;
    if n14 > 0 then begin
      cMethod := QuestConditionInfo.sParam1[1];
      case cMethod of
        '=': if n14 = nIndex then Result := True;
        '>': if n14 > nIndex then Result := True;
        '<': if n14 < nIndex then Result := True;
      else if n14 >= nIndex then Result := True;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckSelfSort',[g_sExceptionVer]));
  end;
end;
//功能：检测人物攻击的目标的名字
//格式：CHECKHITMONNAME 名字
function TNormNpc.ConditionOfCheckHitMonName(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var sName: string;
begin
  Result := False;
  try
    sName:= GetLineVariableText(PlayObject,QuestConditionInfo.sParam1);
    if (sName = '') then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKHITMONNAME);
      Exit;
    end;
    if PlayObject.m_TargetCret <> nil then begin
      if CompareText(PlayObject.m_TargetCret.m_sCharName, sName) = 0 then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckHitMonName',[g_sExceptionVer]));
  end;
end;
//功能:检测组队所有成员的任务标记
//格式:CHECKGROUPFLAG 任务标记 状态(1-真 0-否)
//例子:CHECKGROUPFLAG [001] 1
function TNormNpc.ConditionOfCheckGroupFlag(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  I, n14, n18, n10, n11, nCount: Integer;
  GroupMember: TPlayObject;
  sStr: String;
begin
  Result := False;
  try
    if PlayObject.m_GroupOwner = nil then Exit;
    ArrestStringEx(QuestConditionInfo.sParam1, '[', ']', sStr);
    n14 := Str_ToInt(sStr, 0);
    n18 := Str_ToInt(QuestConditionInfo.sParam2, 0);

    if PlayObject.m_GroupOwner.m_GroupMembers.Count > 0 then begin
      nCount:= PlayObject.m_GroupOwner.m_GroupMembers.Count;
      n11:= 0;
      for I := PlayObject.m_GroupOwner.m_GroupMembers.Count - 1 downto 0  do begin
        GroupMember := TPlayObject(PlayObject.m_GroupOwner.m_GroupMembers.Objects[I]);
        if GroupMember <> nil then begin
          n10 := GroupMember.GetQuestFalgStatus(n14);
          if n10 = 0 then begin
            if n18 = 0 then Inc(n11);
          end else begin
            if n18 <> 0 then Inc(n11);
          end;
        end;
      end;//for
      if nCount = n11 then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckGroupFlag',[g_sExceptionVer]));
  end;
end;
//功能：检测组队成员是否在相同地图内
//格式：CHECKGROUPMAP
function TNormNpc.ConditionOfCheckGroupMap(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  I, nCount, n11: Integer;
  GroupMember: TBaseObject;
  sMap: String;
begin
  try
    Result := False;
    if PlayObject.m_GroupOwner = nil then Exit;
    sMap:= PlayObject.m_GroupOwner.m_PEnvir.sMapName;
    if PlayObject.m_GroupOwner.m_GroupMembers.Count > 0 then begin
      nCount:= PlayObject.m_GroupOwner.m_GroupMembers.Count;
      n11:= 0;
      for I := PlayObject.m_GroupOwner.m_GroupMembers.Count - 1 downto 0  do begin
        GroupMember := TBaseObject(PlayObject.m_GroupOwner.m_GroupMembers.Objects[I]);
        if GroupMember <> nil then begin
          if CompareText(GroupMember.m_PEnvir.sMapName , sMap)= 0 then Inc(n11);
        end;
      end;//for
      if nCount = n11 then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckGroupMap',[g_sExceptionVer]));
  end;
end;

//功能:检测组队中是否有指定职业的成员 20100915
//格式:CHECKGROUPJOB 职业(0-战士/1-法师/2-道士)
function TNormNpc.ConditionOfCheckGroupJob(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nJob, I: Integer;
  GroupMember: TBaseObject;
begin
  try
    Result := False;
    if PlayObject.m_GroupOwner = nil then Exit;
    nJob:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam1),-1);
    if nJob < 0 then begin
      if not GetValValue(PlayObject, QuestConditionInfo.sParam1, nJob) then begin //增加变量支持
        ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKGROUPJOB);
        Exit;
      end;
    end;
    if nJob > 2 then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKGROUPJOB);
      Exit;
    end;

    if PlayObject.m_GroupOwner.m_GroupMembers.Count > 0 then begin
      for I := PlayObject.m_GroupOwner.m_GroupMembers.Count - 1 downto 0  do begin
        GroupMember := TBaseObject(PlayObject.m_GroupOwner.m_GroupMembers.Objects[I]);
        if GroupMember <> nil then begin
          if GroupMember.m_btJob = nJob then begin
            Result := True;
            Break;
          end;
        end;
      end;//for
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckGroupJob',[g_sExceptionVer]));
  end;
end;

function TNormNpc.ConditionOfCheckGroupCount(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethod: Char;
  nCount: Integer;
begin
  try
    Result := False;
    if PlayObject.m_GroupOwner = nil then Exit;
    nCount:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);
    if nCount < 0 then begin
      if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nCount) then begin //增加变量支持
        ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKGROUPCOUNT);
        Exit;
      end;
    end;
    cMethod := QuestConditionInfo.sParam1[1];
    case cMethod of
      '=': if PlayObject.m_GroupOwner.m_GroupMembers.Count = nCount then Result := True;
      '>': if PlayObject.m_GroupOwner.m_GroupMembers.Count > nCount then Result := True;
      '<': if PlayObject.m_GroupOwner.m_GroupMembers.Count < nCount then Result := True;
    else if PlayObject.m_GroupOwner.m_GroupMembers.Count >= nCount then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckGroupCount',[g_sExceptionVer]));
  end;
end;

function TNormNpc.ConditionOfCheckHaveGuild(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
  try
    Result := PlayObject.m_MyGuild <> nil; // 01-16 更正检查结果反了
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckHaveGuild',[g_sExceptionVer]));
  end;
end;

function TNormNpc.ConditionOfCheckInMapRange(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  sMapName: string;
  nX, nY, nRange: Integer;
begin
try
  Result := False;
  {sMapName := QuestConditionInfo.sParam1;
  nX := Str_ToInt(QuestConditionInfo.sParam2, -1);
  nY := Str_ToInt(QuestConditionInfo.sParam3, -1);
  nRange := Str_ToInt(QuestConditionInfo.sParam4, -1);}
  sMapName := GetLineVariableText(PlayObject,QuestConditionInfo.sParam1);//20080501
  nX:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
  nY:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam3),-1);//20080501
  nRange:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam4),-1);//20080501
  if nX < 0 then begin
    GetValValue(PlayObject, QuestConditionInfo.sParam2, nX); //增加变量支持
  end;
  if nY < 0 then begin
    GetValValue(PlayObject, QuestConditionInfo.sParam3, nY); //增加变量支持
  end;
  if nRange < 0 then begin
    GetValValue(PlayObject, QuestConditionInfo.sParam4, nRange); //增加变量支持
  end;
  if (sMapName = '') or (nX < 0) or (nY < 0) or (nRange < 0) then begin
    ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKINMAPRANGE);
    Exit;
  end;
  if CompareText(PlayObject.m_sMapName, sMapName) <> 0 then Exit;
  if (abs(PlayObject.m_nCurrX - nX) <= nRange) and (abs(PlayObject.m_nCurrY - nY) <= nRange) then
    Result := True;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckInMapRange',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckIsAttackGuild(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
  try
    Result := False;
    if m_Castle = nil then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_ISATTACKGUILD);
      Exit;
    end;
    if PlayObject.m_MyGuild = nil then Exit;
    Result := TUserCastle(m_Castle).IsAttackGuild(TGUild(PlayObject.m_MyGuild));
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckIsAttackGuild',[g_sExceptionVer]));
  end;
end;

//检查沙巴克占领天数
function TNormNpc.ConditionOfCheckCastleChageDay(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nDay: Integer;
  cMethod: Char;
  nChangeDay: Integer;
begin
  try
    Result := False;
    nDay:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
    if nDay < 0 then begin
      GetValValue(PlayObject, QuestConditionInfo.sParam2, nDay); //增加变量支持
    end;
    if (nDay < 0) or (m_Castle = nil) then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CASTLECHANGEDAY);
      Exit;
    end;
    nChangeDay := GetDayCount(Now, TUserCastle(m_Castle).m_ChangeDate);
    cMethod := QuestConditionInfo.sParam1[1];
    case cMethod of
      '=': if nChangeDay = nDay then Result := True;
      '>': if nChangeDay > nDay then Result := True;
      '<': if nChangeDay < nDay then Result := True;
    else if nChangeDay >= nDay then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckCastleChageDay',[g_sExceptionVer]));
  end;
end;

function TNormNpc.ConditionOfCheckCastleWarDay(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nDay: Integer;
  cMethod: Char;
  nWarDay: Integer;
begin
try
  Result := False;
  //nDay := Str_ToInt(QuestConditionInfo.sParam2, -1);
  nDay:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
  if nDay < 0 then begin
    GetValValue(PlayObject, QuestConditionInfo.sParam2, nDay); //增加变量支持
  end;
  if (nDay < 0) or (m_Castle = nil) then begin
    ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CASTLEWARDAY);
    Exit;
  end;
  nWarDay := GetDayCount(Now, TUserCastle(m_Castle).m_WarDate);
  cMethod := QuestConditionInfo.sParam1[1];
  case cMethod of
    '=': if nWarDay = nDay then Result := True;
    '>': if nWarDay > nDay then Result := True;
    '<': if nWarDay < nDay then Result := True;
  else if nWarDay >= nDay then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckCastleWarDay',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckCastleDoorStatus(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nDay: Integer;
  nDoorStatus: Integer;
  CastleDoor: TCastleDoor;
begin
  try
    Result := False;
    //nDay := Str_ToInt(QuestConditionInfo.sParam2, -1);
    nDay:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
    if nDay < 0 then begin
      GetValValue(PlayObject, QuestConditionInfo.sParam2, nDay); //增加变量支持
    end;
    nDoorStatus := -1;
    if CompareText(QuestConditionInfo.sParam1, '损坏') = 0 then nDoorStatus := 0;
    if CompareText(QuestConditionInfo.sParam1, '开启') = 0 then nDoorStatus := 1;
    if CompareText(QuestConditionInfo.sParam1, '关闭') = 0 then nDoorStatus := 2;

    if (nDay < 0) or (m_Castle = nil) or (nDoorStatus < 0) then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKCASTLEDOOR);
      Exit;
    end;
    CastleDoor := TCastleDoor(TUserCastle(m_Castle).m_MainDoor.BaseObject);

    case nDoorStatus of
      0: if CastleDoor.m_boDeath then Result := True;
      1: if CastleDoor.m_boOpened then Result := True;
      2: if not CastleDoor.m_boOpened then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckCastleDoorStatus',[g_sExceptionVer]));
  end;
end;

function TNormNpc.ConditionOfCheckIsAttackAllyGuild( PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
try
  Result := False;
  if m_Castle = nil then begin
    ScriptConditionError(PlayObject, QuestConditionInfo, sSC_ISATTACKALLYGUILD);
    Exit;
  end;
  if PlayObject.m_MyGuild = nil then Exit;
  Result := TUserCastle(m_Castle).IsAttackAllyGuild(TGUild(PlayObject.m_MyGuild));
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckIsAttackAllyGuild',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckIsDefenseAllyGuild( PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
try
  Result := False;
  if m_Castle = nil then begin
    ScriptConditionError(PlayObject, QuestConditionInfo, sSC_ISDEFENSEALLYGUILD);
    Exit;
  end;

  if PlayObject.m_MyGuild = nil then Exit;
  Result := TUserCastle(m_Castle).IsDefenseAllyGuild(TGUild(PlayObject.m_MyGuild));
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckIsDefenseAllyGuild',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckIsDefenseGuild(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
try
  Result := False;
  if m_Castle = nil then begin
    ScriptConditionError(PlayObject, QuestConditionInfo, sSC_ISDEFENSEGUILD);
    Exit;
  end;

  if PlayObject.m_MyGuild = nil then Exit;
  Result := TUserCastle(m_Castle).IsDefenseGuild(TGUild(PlayObject.m_MyGuild));
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckIsDefenseGuild',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckIsCastleaGuild(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
try
  Result := False;
  //  if (PlayObject.m_MyGuild <> nil) and (UserCastle.m_MasterGuild = PlayObject.m_MyGuild) then
  if g_CastleManager.IsCastleMember(PlayObject) <> nil then Result := True;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckIsCastleaGuild',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckIsCastleMaster(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
  try
    Result := False;
    //if PlayObject.IsGuildMaster and (UserCastle.m_MasterGuild = PlayObject.m_MyGuild) then
    if PlayObject.IsGuildMaster and (g_CastleManager.IsCastleMember(PlayObject) <> nil) then
      Result := True;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckIsCastleMaster',[g_sExceptionVer]));
  end;
end;

function TNormNpc.ConditionOfCheckIsGuildMaster(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
try
  Result := PlayObject.IsGuildMaster;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckIsGuildMaster',[g_sExceptionVer]));
end;
end;
//检查是不是别人的师傅 20080608
function TNormNpc.ConditionOfCheckIsMaster(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
  try
    Result := False;
    if {(PlayObject.m_sMasterName <> '') and} (PlayObject.m_boMaster) then Result := True;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckIsMaster',[g_sExceptionVer]));
  end;
end;

//检查物品增加的附属属性
function TNormNpc.ConditionOfCheckItemAddValue(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nWhere: Integer;
  nAddAllValue, nAddValue: Integer;
  UserItem: pTUserItem;
  cMethod: Char;
  nValType: Integer;
begin
  try
    Result := False;
    //nWhere := Str_ToInt(QuestConditionInfo.sParam1, -1);
    //nValType := Str_ToInt(QuestConditionInfo.sParam2, -1);
    //nAddValue := Str_ToInt(QuestConditionInfo.sParam4, -1);
    nWhere:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam1),-1);//20080501
    if nWhere < 0 then begin
      GetValValue(PlayObject, QuestConditionInfo.sParam1, nWhere);
    end;
    nValType:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
    if nValType < 0 then begin
      GetValValue(PlayObject, QuestConditionInfo.sParam2, nValType);
    end;
    nAddValue:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam4),-1);//20080501
    if nAddValue < 0 then begin
      GetValValue(PlayObject, QuestConditionInfo.sParam4, nAddValue);
    end;

    cMethod := QuestConditionInfo.sParam3[1];
    if (nValType < 0) or (nValType > 15) or (nWhere < 0) or {$IF M2Version <> 2}(nWhere > High(THumanUseItems)){$ELSE}(nWhere > High(THumItems)){$IFEND} or (nAddValue < 0) then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKITEMADDVALUE);
      Exit;
    end;
    UserItem := @PlayObject.m_UseItems[nWhere];
    if UserItem.wIndex = 0 then Exit;
    //nAddAllValue := 0;
    {for i := Low(UserItem.btValue) to High(UserItem.btValue) do begin
      Inc(nAddAllValue, UserItem.btValue[i]);
    end;}
    if nValType = 15 then nValType := 20;//20081103 15代表吸伤属性
    if nValType = 14 then nAddAllValue := UserItem.DuraMax
    else nAddAllValue := UserItem.btValue[nValType];
    case cMethod of
      '=': if nAddAllValue = nAddValue then Result := True;
      '>': if nAddAllValue > nAddValue then Result := True;
      '<': if nAddAllValue < nAddValue then Result := True;
    else if nAddAllValue >= nAddValue then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckItemAddValue',[g_sExceptionVer]));
  end;
end;
//检查物品的鉴定相关属性 20110724
function TNormNpc.ConditionOfCheckItemAddValueEx(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nWhere, nAddAllValue, nAddValue, nValType: Integer;
  UserItem: pTUserItem;
  cMethod: Char;
begin
  Result := False;
  try
    nWhere:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam1),-1);
    if nWhere < 0 then GetValValue(PlayObject, QuestConditionInfo.sParam1, nWhere);
    nValType:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);
    if nValType < 0 then GetValValue(PlayObject, QuestConditionInfo.sParam2, nValType);
    nAddValue:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam4),-1);
    if nAddValue < 0 then  GetValValue(PlayObject, QuestConditionInfo.sParam4, nAddValue);

    cMethod := QuestConditionInfo.sParam3[1];
    if (nValType < 0) or (nValType > 1) or (nWhere < 0) or
      {$IF M2Version <> 2}(nWhere > High(THumanUseItems)){$ELSE}(nWhere > High(THumItems)){$IFEND}
      or (nAddValue < 0) then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKITEMADDVALUEEX);
      Exit;
    end;
    UserItem := @PlayObject.m_UseItems[nWhere];
    if UserItem.wIndex = 0 then Exit;

    case nValType of
      0: begin//几鉴
        case UserItem.btAppraisalLevel of
          1,11,21,31,41,51: nAddAllValue := 0;
          2,12,22,32,42,52: nAddAllValue := 1;
          3,13,23,33,43,53: nAddAllValue := 2;
          4,14,24,34,44,54: nAddAllValue := 3;
        end;
      end;
      1: nAddAllValue := UserItem.btUnKnowValueCount;
    end;

    case cMethod of
      '=': if nAddAllValue = nAddValue then Result := True;
      '>': if nAddAllValue > nAddValue then Result := True;
      '<': if nAddAllValue < nAddValue then Result := True;
    else if nAddAllValue >= nAddValue then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckItemAddValueEx',[g_sExceptionVer]));
  end;
end;

function TNormNpc.ConditionOfCheckItemType(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nWhere: Integer;
  nType: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
try
  Result := False;
  //nWhere := Str_ToInt(QuestConditionInfo.sParam1, -1);
  //nType := Str_ToInt(QuestConditionInfo.sParam2, -1);
  nWhere:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam1),-1);//20080501
  nType:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
  if nWhere < 0 then begin
    GetValValue(PlayObject, QuestConditionInfo.sParam1, nWhere); //增加变量支持
  end;
  if nType < 0 then begin
    GetValValue(PlayObject, QuestConditionInfo.sParam2, nType); //增加变量支持
  end;
  if not (nWhere in {$IF M2Version <> 2}[Low(THumanUseItems)..High(THumanUseItems)]{$ELSE}[Low(THumItems)..High(THumItems)]{$IFEND}) then begin
    ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKITEMTYPE);
    Exit;
  end;
  UserItem := @PlayObject.m_UseItems[nWhere];
  if UserItem.wIndex = 0 then Exit;
  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
  if (StdItem <> nil) and (StdItem.StdMode = nType) then begin
    Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckItemType',[g_sExceptionVer]));
end;
end;
//检查玩家等级
function TNormNpc.ConditionOfCheckLevelEx(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nLevel: Integer;
  cMethod: Char;
begin
  try
    Result := False;
    nLevel:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
    if nLevel < 0 then begin
      if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nLevel) then begin //增加变量支持
        ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKLEVELEX);
        Exit;
      end;
    end;
    cMethod := QuestConditionInfo.sParam1[1];
    case cMethod of
      '=': if PlayObject.m_Abil.Level = nLevel then Result := True;
      '>': if PlayObject.m_Abil.Level > nLevel then Result := True;
      '<': if PlayObject.m_Abil.Level < nLevel then Result := True;
    else if PlayObject.m_Abil.Level >= nLevel then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckLevelEx',[g_sExceptionVer]));
  end;
end;

function TNormNpc.ConditionOfCheckNameListPostion(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  I: Integer;
  LoadList: TStringList;
  sCharName: string;
  nNamePostion, nPostion: Integer;
  sLine: string;
  cMethod: Char;
begin
  try
    Result := False;
    nNamePostion := -1;
    try
      sCharName := PlayObject.m_sCharName;
      LoadList := TStringList.Create;
      if FileExists(g_Config.sEnvirDir + QuestConditionInfo.sParam1) then begin
        LoadList.LoadFromFile(g_Config.sEnvirDir + QuestConditionInfo.sParam1);
        if LoadList.Count > 0 then begin//20080629
          for I := 0 to LoadList.Count - 1 do begin
            sLine := Trim(LoadList.Strings[I]);
            if (sLine = '') or (sLine[1] = ';') then Continue;
            if CompareText(sLine, sCharName) = 0 then begin
              nNamePostion := I + 1;
              Break;
            end;
          end;
        end;
      end else begin
        ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKNAMELISTPOSITION);
      end;
    finally
      LoadList.Free;
    end;
    cMethod := QuestConditionInfo.sParam2[1];
    //nPostion := Str_ToInt(QuestConditionInfo.sParam3, -1);
    nPostion:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam3),-1);//20080501
    if nPostion < 0 then begin
      GetValValue(PlayObject, QuestConditionInfo.sParam3, nPostion); //增加变量支持
    end;

    SetValValue(PlayObject, QuestConditionInfo.sParam4, nNamePostion);
    if nPostion < 0 then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKNAMELISTPOSITION);
      Exit;
    end;
    case cMethod of
      '=': if nNamePostion = nPostion then Result := True;
      '>': if nNamePostion > nPostion then Result := True;
      '<': if nNamePostion < nPostion then Result := True;
    else if nNamePostion >= nPostion then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckNameListPostion',[g_sExceptionVer]));
  end;
end;

function TNormNpc.ConditionOfCheckMarry(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
try
  Result := False;
  if PlayObject.m_sDearName <> '' then Result := True;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckMarry',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckMarryCount(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nCount: Integer;
  cMethod: Char;
begin
try
  Result := False;
  //nCount := Str_ToInt(QuestConditionInfo.sParam2, -1);
  nCount:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
  if nCount < 0 then begin
    if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nCount) then begin //增加变量支持
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKMARRYCOUNT);
      Exit;
    end;
  end;
  cMethod := QuestConditionInfo.sParam1[1];
  case cMethod of
    '=': if PlayObject.m_btMarryCount = nCount then Result := True;
    '>': if PlayObject.m_btMarryCount > nCount then Result := True;
    '<': if PlayObject.m_btMarryCount < nCount then Result := True;
  else if PlayObject.m_btMarryCount >= nCount then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckMarryCount',[g_sExceptionVer]));
end;
end;
//是否为别人的徒弟
function TNormNpc.ConditionOfCheckMaster(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
  try
    Result := False;
    if (PlayObject.m_sMasterName <> '') and (not PlayObject.m_boMaster) then Result := True;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckMaster',[g_sExceptionVer]));
  end;
end;

function TNormNpc.ConditionOfCheckMemBerLevel(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nLevel: Integer;
  cMethod: Char;
begin
try
  Result := False;
  //nLevel := Str_ToInt(QuestConditionInfo.sParam2, -1);
  nLevel:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
  if nLevel < 0 then begin
    if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nLevel) then begin //增加变量支持
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKMEMBERLEVEL);
      Exit;
    end;
  end;
  cMethod := QuestConditionInfo.sParam1[1];
  case cMethod of
    '=': if PlayObject.m_nMemberLevel = nLevel then Result := True;
    '>': if PlayObject.m_nMemberLevel > nLevel then Result := True;
    '<': if PlayObject.m_nMemberLevel < nLevel then Result := True;
  else if PlayObject.m_nMemberLevel >= nLevel then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckMemBerLevel',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckMemberType(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nType: Integer;
  cMethod: Char;
begin
try
  Result := False;
  //nType := Str_ToInt(QuestConditionInfo.sParam2, -1);
  nType:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
  if nType < 0 then begin
    if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nType) then begin //增加变量支持
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKMEMBERTYPE);
      Exit;
    end;
  end;
  cMethod := QuestConditionInfo.sParam1[1];
  case cMethod of
    '=': if PlayObject.m_nMemberType = nType then Result := True;
    '>': if PlayObject.m_nMemberType > nType then Result := True;
    '<': if PlayObject.m_nMemberType < nType then Result := True;
  else if PlayObject.m_nMemberType >= nType then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckMemberType',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckNameIPList(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  I: Integer;
  LoadList: TStringList;
  sCharName: string;
  sCharAccount: string;
  sCharIPaddr: string;
  sLine: string;
  sName: string;
  sIPaddr: string;
begin
try
  Result := False;
  try
    sCharName := PlayObject.m_sCharName;
    sCharAccount := PlayObject.m_sUserID;
    sCharIPaddr := PlayObject.m_sIPaddr;
    LoadList := TStringList.Create;
    if FileExists(g_Config.sEnvirDir + QuestConditionInfo.sParam1) then begin
      LoadList.LoadFromFile(g_Config.sEnvirDir + QuestConditionInfo.sParam1);
      if LoadList.Count > 0 then begin//20080629
        for I := 0 to LoadList.Count - 1 do begin
          sLine := LoadList.Strings[I];
          if sLine <> '' then begin
            if sLine[1] = ';' then Continue;
            sIPaddr := GetValidStr3(sLine, sName, [' ', '/', #9]);
            sIPaddr := Trim(sIPaddr);
            if (sName = sCharName) and (sIPaddr = sCharIPaddr) then begin
              Result := True;
              Break;
            end;
          end;
        end;
      end;
    end else begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKNAMEIPLIST);
    end;
  finally
    LoadList.Free;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckNameIPList',[g_sExceptionVer]));
end;
end;
//功能：可以检查对面人物站的位置性别（要求面对面）
//格式：CHECKPOSEDIR 控制符(1,2)
function TNormNpc.ConditionOfCheckPoseDir(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  PoseHuman: TBaseObject;
begin
try
  Result := False;
  PoseHuman := PlayObject.GetPoseCreate();
  if (PoseHuman <> nil) and (PoseHuman.GetPoseCreate = PlayObject) and (PoseHuman.m_btRaceServer = RC_PLAYOBJECT) then begin
    case QuestConditionInfo.nParam1 of
      1: if PoseHuman.m_btGender = PlayObject.m_btGender then Result := True; //要求相同性别
      2: if PoseHuman.m_btGender <> PlayObject.m_btGender then Result := True; //要求不同性别
    else Result := True; //无参数时不判别性别
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckPoseDir',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckPoseGender(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  PoseHuman: TBaseObject;
  btSex: Byte;
begin
try
  Result := False;
  btSex := 0;
  if CompareText(QuestConditionInfo.sParam1, 'MAN') = 0 then begin
    btSex := 0;
  end else
    if CompareText(QuestConditionInfo.sParam1, '男') = 0 then begin
    btSex := 0;
  end else
    if CompareText(QuestConditionInfo.sParam1, 'WOMAN') = 0 then begin
    btSex := 1;
  end else
    if CompareText(QuestConditionInfo.sParam1, '女') = 0 then begin
    btSex := 1;
  end;
  PoseHuman := PlayObject.GetPoseCreate();
  if (PoseHuman <> nil) and (PoseHuman.m_btRaceServer = RC_PLAYOBJECT) then begin
    if PoseHuman.m_btGender = btSex then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckPoseGender',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckPoseIsMaster(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  PoseHuman: TBaseObject;
begin
try
  Result := False;
  PoseHuman := PlayObject.GetPoseCreate();
  if (PoseHuman <> nil) and (PoseHuman.m_btRaceServer = RC_PLAYOBJECT) then begin
    if (TPlayObject(PoseHuman).m_sMasterName <> '') and (TPlayObject(PoseHuman).m_boMaster) then
      Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckPoseIsMaster',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckPoseLevel(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nLevel: Integer;
  PoseHuman: TBaseObject;
  cMethod: Char;
begin
try
  Result := False;
  //nLevel := Str_ToInt(QuestConditionInfo.sParam2, -1);
  nLevel := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
  if nLevel < 0 then begin
    if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nLevel) then begin //增加支持变量
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKPOSELEVEL);
      Exit;
    end;
  end;
  cMethod := QuestConditionInfo.sParam1[1];
  PoseHuman := PlayObject.GetPoseCreate();
  if (PoseHuman <> nil) and (PoseHuman.m_btRaceServer = RC_PLAYOBJECT) then begin
    case cMethod of
      '=': if PoseHuman.m_Abil.Level = nLevel then Result := True;
      '>': if PoseHuman.m_Abil.Level > nLevel then Result := True;
      '<': if PoseHuman.m_Abil.Level < nLevel then Result := True;
    else if PoseHuman.m_Abil.Level >= nLevel then Result := True;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckPoseLevel',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckPoseMarry(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  PoseHuman: TBaseObject;
begin
try
  Result := False;
  PoseHuman := PlayObject.GetPoseCreate();
  if (PoseHuman <> nil) and (PoseHuman.m_btRaceServer = RC_PLAYOBJECT) then begin
    if TPlayObject(PoseHuman).m_sDearName <> '' then
      Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckPoseMarry',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckPoseMaster(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  PoseHuman: TBaseObject;
begin
try
  Result := False;
  PoseHuman := PlayObject.GetPoseCreate();
  if (PoseHuman <> nil) and (PoseHuman.m_btRaceServer = RC_PLAYOBJECT) then begin
    if (TPlayObject(PoseHuman).m_sMasterName <> '') and not (TPlayObject(PoseHuman).m_boMaster) then
      Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckPoseMaster',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckServerName(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
try
  Result := False;
  if QuestConditionInfo.sParam1 = g_Config.sServerName then Result := True;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckServerName',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckSlaveCount(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nCount: Integer;
  cMethod: Char;
begin
try
  Result := False;
  //nCount := Str_ToInt(QuestConditionInfo.sParam2, -1);
  nCount := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
  if nCount < 0 then begin
    if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nCount) then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKSLAVECOUNT);
      Exit;
    end;
  end;
  cMethod := QuestConditionInfo.sParam1[1];
  case cMethod of
    '=': if PlayObject.m_SlaveList.Count = nCount then Result := True;
    '>': if PlayObject.m_SlaveList.Count > nCount then Result := True;
    '<': if PlayObject.m_SlaveList.Count < nCount then Result := True;
  else if PlayObject.m_SlaveList.Count >= nCount then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckSlaveCount',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckSafeZone(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
try
  Result := PlayObject.InSafeZone;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckSafeZone',[g_sExceptionVer]));
end;
end;
//检查当前所在地图的名字
//格式:CHECKMAPNAME 人名(self) 地图号
function TNormNpc.ConditionOfCheckMapName(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  sCharName: string;
  sMapName: string;
  OnlinePlayObject: TPlayObject;
begin
try
  Result := False;
  if CompareText(QuestConditionInfo.sParam1, 'Self') = 0 then begin
    sCharName := PlayObject.m_sCharName;
  end else begin
   //sCharName := QuestConditionInfo.sParam1;
   // GetValValue(PlayObject, QuestConditionInfo.sParam1, sCharName);
    sCharName := GetLineVariableText(PlayObject,QuestConditionInfo.sParam1);//20080501
  end;
  //sMapName := QuestConditionInfo.sParam2;
  //GetValValue(PlayObject, QuestConditionInfo.sParam2, sMapName);
  sMapName := GetLineVariableText(PlayObject,QuestConditionInfo.sParam2);//20080501

  if sCharName = PlayObject.m_sCharName then begin
    if sMapName = PlayObject.m_sMapName then Result := True;
  end else begin
    OnlinePlayObject := UserEngine.GetPlayObject(sCharName);
    if OnlinePlayObject <> nil then begin
      if OnlinePlayObject.m_sMapName = sMapName then Result := True;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckMapName',[g_sExceptionVer]));
end;
end;
//功能：检查人物技能等级
//CHECKSKILL 技能名称 控制符(=,>,<)  修炼等级
function TNormNpc.ConditionOfCheckSkill(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nSkillLevel: Integer;
  cMethod: Char;
  UserMagic: pTUserMagic;
  sMagicName: string;
begin
  try
    Result := False;
    sMagicName:= GetLineVariableText(PlayObject, QuestConditionInfo.sParam1);//20090708 支持变量
    //nSkillLevel := Str_ToInt(QuestConditionInfo.sParam3, -1);
    nSkillLevel:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam3),-1);//20080501
    if nSkillLevel < 0 then begin
      if not GetValValue(PlayObject, QuestConditionInfo.sParam3, nSkillLevel) then begin
        ScriptConditionError(PlayObject, QuestConditionInfo, sCHECKSKILL);
        Exit;
      end;
    end;
    UserMagic := nil;
    UserMagic := TPlayObject(PlayObject).GetMagicInfo(sMagicName);
    if UserMagic = nil then Exit;
    cMethod := QuestConditionInfo.sParam2[1];
    case cMethod of
      '=': if UserMagic.btLevel = nSkillLevel then Result := True;
      '>': if UserMagic.btLevel > nSkillLevel then Result := True;
      '<': if UserMagic.btLevel < nSkillLevel then Result := True;
    else if UserMagic.btLevel >= nSkillLevel then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckSkill',[g_sExceptionVer]));
  end;
end;
//功能：检查英雄技能 20080423
//HEROCHECKSKILL 技能名称 控制符(=,>,<)  修炼等级
function TNormNpc.ConditionOfHEROCHECKSKILL(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nSkillLevel: Integer;
  cMethod: Char;
  UserMagic: pTUserMagic;
  sMagicName: string;
begin
  {$IF HEROVERSION = 1}
  try
    Result := False;
    sMagicName:= GetLineVariableText(PlayObject, QuestConditionInfo.sParam1);//20090708 支持变量
    //nSkillLevel := Str_ToInt(QuestConditionInfo.sParam3, -1);
    nSkillLevel:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam3),-1);//20080501
    if nSkillLevel < 0 then begin
      if not GetValValue(PlayObject, QuestConditionInfo.sParam3, nSkillLevel) then begin
        ScriptConditionError(PlayObject, QuestConditionInfo, sHEROCHECKSKILL);
        Exit;
      end;
    end;
    if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then begin //20080519
      ScriptConditionError(PlayObject, QuestConditionInfo, sHEROCHECKSKILL);
      Exit;
    end;
    if PlayObject.m_MyHero <> nil then begin
      UserMagic := nil;
      UserMagic := TPlayObject(PlayObject.m_MyHero).GetMagicInfo(sMagicName);
      if UserMagic = nil then Exit;
      cMethod := QuestConditionInfo.sParam2[1];
      case cMethod of
        '=': if UserMagic.btLevel = nSkillLevel then Result := True;
        '>': if UserMagic.btLevel > nSkillLevel then Result := True;
        '<': if UserMagic.btLevel < nSkillLevel then Result := True;
      else if UserMagic.btLevel >= nSkillLevel then Result := True;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfHEROCHECKSKILL',[g_sExceptionVer]));
  end;
  {$IFEND}
end;


function TNormNpc.ConditionOfAnsiContainsText(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  sValue1: string;
  sValue2: string;
begin
try
  Result := False;
  {sValue1 := QuestConditionInfo.sParam1;
  sValue2 := QuestConditionInfo.sParam2;
  GetValValue(PlayObject, QuestConditionInfo.sParam1, sValue1);
  GetValValue(PlayObject, QuestConditionInfo.sParam2, sValue2);}
  sValue1 := GetLineVariableText(PlayObject,QuestConditionInfo.sParam1);//20080501
  sValue2 := GetLineVariableText(PlayObject,QuestConditionInfo.sParam2);//20080501
  if AnsiContainsText(sValue1, sValue2) then Result := True;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfAnsiContainsText',[g_sExceptionVer]));
end;
end;
//比较字符串是否一样
function TNormNpc.ConditionOfCompareText(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  sValue1: string;
  sValue2: string;
begin
try
  Result := False;
 { sValue1 := QuestConditionInfo.sParam1;
  sValue2 := QuestConditionInfo.sParam2;
  GetValValue(PlayObject, QuestConditionInfo.sParam1, sValue1);
  GetValValue(PlayObject, QuestConditionInfo.sParam2, sValue2);}
  sValue1 := GetLineVariableText(PlayObject,QuestConditionInfo.sParam1);//20080501
  sValue2 := GetLineVariableText(PlayObject,QuestConditionInfo.sParam2);//20080501
  if CompareText(sValue1, sValue2) = 0 then Result := True;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCompareText',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckStationTime(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nCount: Integer;
  cMethod: Char;
begin
  try
    Result := False;
    if not PlayObject.m_boAI then begin//假人不执行命令
      //nCount := Str_ToInt(QuestConditionInfo.sParam2, -1);
      nCount := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
      if nCount < 0 then begin
        if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nCount) then begin
          ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKSTATIONTIME);
          Exit;
        end;
      end;
      nCount := nCount * 60000{60 * 1000};
      cMethod := QuestConditionInfo.sParam1[1];
      case cMethod of
        '=': if GetTickCount - PlayObject.m_dwStationTick = nCount then Result := True;
        '>': if GetTickCount - PlayObject.m_dwStationTick > nCount then Result := True;
        '<': if GetTickCount - PlayObject.m_dwStationTick < nCount then Result := True;
      else if GetTickCount - PlayObject.m_dwStationTick >= nCount then Result := True;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckStationTime',[g_sExceptionVer]));
  end;
end;
//判断身上是否有英雄  20080521
//格式:HAVEHERO TRUE 带TRUE参数代码,判断是否有卧龙英雄,不带表示判断是否有白日门英雄
function TNormNpc.ConditionOfCheckHasHero(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
try
  Result := False;
  {$IF HEROVERSION = 1}
  if CompareText(QuestConditionInfo.sParam1, 'TRUE') = 0 then begin//是否有卧龙英雄
    if PlayObject.m_boHasHeroTwo and (PlayObject.m_sHeroCharName <> '') then Result := True;
  end else begin//是否有白日门英雄
    if PlayObject.m_boHasHero and (PlayObject.m_sHeroCharName <> '') then Result := True;
  end;
  {$IFEND}
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckHasHero',[g_sExceptionVer]));
end;
end;
//功能：检查当前在线英雄是否为副将英雄
//格式：CheckDeputyHero
function TNormNpc.ConditionOfCheckDeputyHero(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
  try
    Result := False;
    {$IF HEROVERSION = 1}
    if (PlayObject.m_MyHero <> nil) and PlayObject.m_boHasHero and PlayObject.m_boHasHeroTwo
       and (PlayObject.m_sDeputyHeroName<>'') and (PlayObject.n_HeroSave = 2) then begin
      if CompareText(PlayObject.m_MyHero.m_sCharName, PlayObject.m_sDeputyHeroName) = 0 then Result := True;
    end;
    {$IFEND}
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckDeputyHero',[g_sExceptionVer]));
  end;
end;
//功能：检查副将英雄是否正在自我修炼
//格式：CheckHeroAutoPractice
function TNormNpc.ConditionOfCheckHeroAutoPractice(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
  Result := False;
  if PlayObject.m_boHeroAutoPractice then Result := True;
end;
//检查英雄是否在线
function TNormNpc.ConditionOfCheckHeroOnline(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
  {$IF HEROVERSION = 1}
  try
    Result := PlayObject.m_MyHero <> nil;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckHeroOnline',[g_sExceptionVer]));
  end;
  {$IFEND}
end;
//检查英雄的等级
function TNormNpc.ConditionOfCheckHeroLevel(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nHeroLevel, nLevel: Integer;
  cMethod: Char;
begin
  try
    Result := False;
    {$IF HEROVERSION = 1}
    if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then begin //20080519
      //ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKHEROLEVEL);
      Exit;
    end;

    //nLevel := Str_ToInt(QuestConditionInfo.sParam2, -1);
    nLevel := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
    if nLevel < 0 then begin
      if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nLevel) then begin //增加变量支持
        ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKHEROLEVEL);
        Exit;
      end;
    end;

    if PlayObject.m_MyHero <> nil then begin
      nHeroLevel := PlayObject.m_MyHero.m_Abil.Level;
      cMethod := QuestConditionInfo.sParam1[1];
      case cMethod of
        '=': if nHeroLevel = nLevel then Result := True;
        '>': if nHeroLevel > nLevel then Result := True;
        '<': if nHeroLevel < nLevel then Result := True;
      else if nHeroLevel >= nLevel then Result := True;
      end;
    end;
    {$IFEND}
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckHeroLevel',[g_sExceptionVer]));
  end;
end;

//功能：检查物品数量以及持久值 20090913
//命令格式:CHECKITMECOUNTDURA 物品名称 数量 操作符(<>=) 持久(MaxDura--物品的持久上限)
function TNormNpc.ConditionOfCheckItmeCountDura(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  sItemName, s1C: String;
  nItemCount, nDura, nCount, I: Integer;
  UserItem: pTUserItem;
  boMaxDura: Boolean;
  cMethod: Char;
begin
  Result := False;
  boMaxDura:= False;
  try
    sItemName:=GetLineVariableText(PlayObject, QuestConditionInfo.sParam1); //物品名称
    nItemCount:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//数量
    if CompareText(QuestConditionInfo.sParam4, 'MaxDura') = 0 then boMaxDura:= True
    else nDura := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam4),-1);//持久
    if (sItemName='') or (nItemCount < 0) or (nDura < 0) then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKITMECOUNTDURA);
      Exit;
    end;
    cMethod := QuestConditionInfo.sParam3[1];
    nCount:= 0;
    if PlayObject.m_ItemList.Count > 0 then begin
      for I:=0 to PlayObject.m_ItemList.Count - 1 do begin
        UserItem := PlayObject.m_ItemList.Items[I];
        if UserItem <> nil then begin
          s1C := UserEngine.GetStdItemName(UserItem.wIndex);
          if CompareText(s1C, sItemName) = 0 then begin
            if boMaxDura then begin
              case cMethod of
                '=': if UserItem.Dura = UserItem.DuraMax then Inc(nCount);
                '>': if UserItem.Dura > UserItem.DuraMax then Inc(nCount);
                '<': if UserItem.Dura < UserItem.DuraMax then Inc(nCount);
              end;
            end else begin
              case cMethod of
                '=': if UserItem.Dura = nDura then Inc(nCount);
                '>': if UserItem.Dura > nDura then Inc(nCount);
                '<': if UserItem.Dura < nDura then Inc(nCount);
              end;
            end;
            if nCount >= nItemCount then begin
              Result := True;
              Break;
            end;
          end;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckItmeCountDura',[g_sExceptionVer]));
  end;
end;

//检测矿纯度 20080324
//命令格式:CHECKMINE 矿名称 数量 操作符(<>=) 纯度
function TNormNpc.ConditionOfCHECKMINE(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  sMineName: String;
  nMineCount, nDura, nCount, I: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  cMethod: Char;
begin
  try
    Result := False;
    nCount:= 0;
    sMineName:=GetLineVariableText(PlayObject, QuestConditionInfo.sParam1); //矿石名
    nMineCount := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//数量 20080501
    nDura := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam4),-1); //纯度20080501
    if nMineCount < 0 then begin
      if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nMineCount) then begin //增加变量支持
        ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKMINE);
        Exit;
      end;
    end;
    if nDura < 0 then begin
      if not GetValValue(PlayObject, QuestConditionInfo.sParam4, nDura) then begin //增加变量支持
        ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKMINE);
        Exit;
      end;
    end;

    if (sMineName='') or (nMineCount < 0) or (nDura < 0) or (nDura > 100) then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKMINE);
      Exit;
    end;
    cMethod := QuestConditionInfo.sParam3[1];
    if PlayObject.m_ItemList.Count > 0 then begin//20080628
      for I:=0 to PlayObject.m_ItemList.Count - 1 do begin
        UserItem := PlayObject.m_ItemList.Items[I];
        if UserItem <> nil then begin//20090203
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) then begin//20090203
            if (StdItem.StdMode = 43) and (CompareText(StdItem.Name, sMineName) = 0) then begin
              case cMethod of
                '=': if UserItem.Dura = nDura * 1000 then Inc(nCount);
                '>': if UserItem.Dura > nDura * 1000 then Inc(nCount);
                '<': if UserItem.Dura < nDura * 1000 then Inc(nCount);
              end;
              //if UserItem.Dura >= nDura * 1000 then Inc(nCount);
              if nCount >= nMineCount then begin
                Result := True;
                Break;
              end;
            end;
          end;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKMINE',[g_sExceptionVer]));
  end;
end;
//功能：检测人物是否正在使用改变颜色功能(玄绿,玄紫,玄褐)
//格式：CHECKHEARMSGCOLOR
function TNormNpc.ConditionOfCHECKHEARMSGCOLOR(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
  Result := False;
  if PlayObject.m_dwUseItmeChangMsgFColorTime > 0 then Result := True;
end;

//功能：检测当前地图中的人物是否属于同一个行会(一人不属于同一个行会即为F)
//格式：MAPHUMISSAMEGUILD 地图名 行会名称(可以不填行会名称，不填则表示检测当前人物的行会)
function TNormNpc.ConditionOfMapHumIsSameGuild(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  I: Integer;
  sMap, sGuildName: String;
  Envir: TEnvirnoment;
  Play: TPlayObject;
begin
  Result := False;
  try
    sMap:= GetLineVariableText(PlayObject, QuestConditionInfo.sParam1); //地图ID
    sGuildName:= GetLineVariableText(PlayObject, QuestConditionInfo.sParam2);//行会名称

    if sGuildName = '' then begin
      if PlayObject.m_MyGuild <> nil then begin
        sGuildName:=TGUild(PlayObject.m_MyGuild).sGuildName;
      end;
    end;

    if (sMap = '') or (sGuildName = '') then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_MAPHUMISSAMEGUILD);
      Exit;
    end;
    Envir := g_MapManager.FindMap(sMap);
    if Envir <> nil then begin
      if UserEngine.m_PlayObjectList.Count > 0 then begin
        for I := 0 to UserEngine.m_PlayObjectList.Count - 1 do begin
          Play := TPlayObject(UserEngine.m_PlayObjectList.Objects[I]);
          if Play <> nil then begin
            if not Play.m_boDeath and not Play.m_boGhost and (Play.m_PEnvir = Envir) then begin
              if Play.m_MyGuild <> nil then begin
                if CompareText(TGUild(Play.m_MyGuild).sGuildName, sGuildName) = 0 then begin
                  Result := True;
                end else begin
                  Result := False;
                  Break;
                end;
              end else begin
                Result := False;
                Break;
              end;
            end;
          end;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfMapHumIsSameGuild',[g_sExceptionVer]));
  end;
end;
//功能:检查在线人数
//格式:CHECKONLINEPLAYCOUNT 操作符(<,>,=) 人数
function TNormNpc.ConditionOfCHECKOnlinePlayCount(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethod: Char;
  nCount: Integer;
begin
  try
    Result := False;
    nCount := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);
    if (nCount < 0) then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKONLINEPLAYCOUNT);
      Exit;
    end;
    cMethod := QuestConditionInfo.sParam1[1];//操作符
    case cMethod of
      '=': if UserEngine.PlayObjectCount = nCount then Result := TRUE;
      '>': if UserEngine.PlayObjectCount > nCount then Result := TRUE;
      '<': if UserEngine.PlayObjectCount < nCount then Result := TRUE;
      else if UserEngine.PlayObjectCount >= nCount then Result := TRUE;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKOnlinePlayCount',[g_sExceptionVer]));
  end;
end;
//功能:检查死的玩家(或杀死玩家)等级
//格式:CHECKPLAYDIELVL 操作符(<,>,=) 等级
//     CHECKKILLPLAYLVL 操作符(<,>,=) 等级
function TNormNpc.ConditionOfCheckPlaylvl(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethod: Char;
  nCount: Integer;
begin
try
  Result := False;
  nCount := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),0);
  if PlayObject.m_LastHiter <> nil then begin
    if PlayObject.m_LastHiter.m_btRaceServer = RC_PLAYOBJECT then begin
      cMethod := QuestConditionInfo.sParam1[1];//操作符
      case cMethod of
        '=': if PlayObject.m_LastHiter.m_WAbil.Level = nCount then Result := TRUE;
        '>': if PlayObject.m_LastHiter.m_WAbil.Level > nCount then Result := TRUE;
        '<': if PlayObject.m_LastHiter.m_WAbil.Level < nCount then Result := TRUE;
        else if PlayObject.m_LastHiter.m_WAbil.Level >= nCount then Result := TRUE;
      end;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckPlaylvl',[g_sExceptionVer]));
end;
end;

//功能:检查死的玩家(或杀死玩家)职业
//格式:CHECKPLAYDIEJOB WARRIOR/WIZARD/TAOIST/ASSASSIN
//     CHECKKILLPLAYJOB WARRIOR/WIZARD/TAOIST/ASSASSIN
function TNormNpc.ConditionOfCheckPlayJob(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  sParam1: string;
begin
try
  Result := False;
  if PlayObject.m_LastHiter <> nil then begin
    if PlayObject.m_LastHiter.m_btRaceServer = RC_PLAYOBJECT then begin
      sParam1 :=GetLineVariableText(PlayObject, QuestConditionInfo.sParam1);
      case PlayObject.m_LastHiter.m_btJob of
        0: if CompareText(sParam1, 'WARRIOR') = 0 then Result := TRUE;
        1: if CompareText(sParam1, 'WIZARD') = 0 then Result := TRUE;
        2: if CompareText(sParam1, 'TAOIST') = 0 then Result := TRUE;
        //3: if CompareText(sParam1, 'ASSASSIN') = 0 then Result := TRUE;//刺客
        else Result := False;
      end;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckPlayJob',[g_sExceptionVer]));
end;
end;

//功能:检查死的玩家(或杀死玩家)性别
//格式:CHECKKILLPLAYSEX MAN/WOMAN
//     CHECKPLAYDIESEX MAN/WOMAN
function TNormNpc.ConditionOfCheckPlaySex(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  sParam1: string;
begin
try
  Result := False;
  if PlayObject.m_LastHiter <> nil then begin
    if PlayObject.m_LastHiter.m_btRaceServer = RC_PLAYOBJECT then begin
      sParam1 := GetLineVariableText(PlayObject, QuestConditionInfo.sParam1);
      case PlayObject.m_LastHiter.m_btGender of
        0: if CompareText(sParam1, 'MAN') = 0 then Result := TRUE;
        1: if CompareText(sParam1, 'WOMAN') = 0 then Result := TRUE;
        else Result := False;
      end;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckPlaySex',[g_sExceptionVer]));
end;
end;
//功能：检查装备升级次数。
//格式：CHECKITEMLEVEL 物品位置(0-13) (符号 < > =) 值
function TNormNpc.ConditionOfCHECKITEMLEVEL(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nWhere, nPoint: Integer;
  UserItem: pTUserItem;
  cMethod: Char;
begin
try
  Result := False;
  nWhere := Str_ToInt(QuestConditionInfo.sParam1, -1);//物品位置
  nPoint := Str_ToInt(QuestConditionInfo.sParam3, -1);//值
  if (nWhere < 0) or {$IF M2Version <> 2}(nWhere > High(THumanUseItems)){$ELSE}(nWhere > High(THumItems)){$IFEND} or (nPoint < 0) or (nPoint > 255) then begin
    ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKITEMLEVEL);
    Exit;
  end;
  UserItem := @PlayObject.m_UseItems[nWhere];
  if UserItem.wIndex <= 0 then Exit;
  cMethod := QuestConditionInfo.sParam2[1];//操作符
  case cMethod of
    '=': if UserItem.btValue[9] = nPoint then Result := True;
    '>': if UserItem.btValue[9] > nPoint then Result := True;
    '<': if UserItem.btValue[9] < nPoint then Result := True;
    else if UserItem.btValue[9] >= nPoint then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKITEMLEVEL',[g_sExceptionVer]));
end;
end;

//功能：检查包裹中装备升级次数
//格式：CHECKBAGITEMLEVEL 物品名 (符号 < > =) 等级
function TNormNpc.ConditionOfCHECKBAGITEMLEVEL(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  sMineName: String;
  nMineCount, nLevel, nCount, I, nValue: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  cMethod: Char;  
begin
  Result := False;
  try
    nCount:= 0;
    sMineName:= GetLineVariableText(PlayObject, QuestConditionInfo.sParam1); //物品名
    nMineCount := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//数量
    nLevel := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam4),-1); //升级等级
    if (sMineName='') or (nMineCount < 0) or (nLevel < 0) then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKBAGITEMLEVEL);
      Exit;
    end;
    cMethod := QuestConditionInfo.sParam3[1];
    if PlayObject.m_ItemList.Count > 0 then begin
      for I:=0 to PlayObject.m_ItemList.Count - 1 do begin
        UserItem := PlayObject.m_ItemList.Items[I];
        if UserItem <> nil then begin
          if UserItem.wIndex <= 0 then Continue;//继续
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) then begin
            if (CompareText(StdItem.Name, sMineName) = 0) then begin
              nValue:= 0;
              if (StdItem.StdMode in [15,16,19..24,26,27,28,29,30,52,54,55,62,64])
                and ((StdItem.Shape = 188) or (StdItem.Shape = 203)) then begin
                nValue:= StdItem.Reserved + UserItem.btValue[9];
              end else nValue:= UserItem.btValue[9];
              if nValue > 5 then nValue:= 5;//吸伤装备等级
              case cMethod of
                '=': if nValue = nLevel then Inc(nCount);
                '>': if nValue > nLevel then Inc(nCount);
                '<': if nValue < nLevel then Inc(nCount);
              end;
              if nCount >= nMineCount then begin
                Result := True;
                Break;
              end;
            end;
          end;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKBAGITEMLEVEL',[g_sExceptionVer]));
  end;
end;
//功能:检查酒的品质 20091117
//格式:CHECKMAKEWINE 酒名称 操作符(<,>,=) 点数(0-10) 模式(0-品质 1-酒精度 2-酒等级)
function TNormNpc.ConditionOfCHECKMAKEWINE(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  sItmeName: String;
  nDura, I: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  cMethod: Char;
  nType: Byte;
begin
  try
    Result := False;
    nType:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam4),0);//检查的模式
    sItmeName:=GetLineVariableText(PlayObject, QuestConditionInfo.sParam1); //酒名称
    nDura := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam3),-1);//点数

    if nDura < 0 then begin
      if not GetValValue(PlayObject, QuestConditionInfo.sParam3, nDura) then begin //增加变量支持
        ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKMAKEWINE);
        Exit;
      end;
    end;

    if (sItmeName='') or (nDura < 0) or (nDura > 10) then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKMAKEWINE);
      Exit;
    end;

    cMethod := QuestConditionInfo.sParam2[1];//操作符
    if PlayObject.m_ItemList.Count > 0 then begin
      for I:=0 to PlayObject.m_ItemList.Count - 1 do begin
        UserItem := PlayObject.m_ItemList.Items[I];
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if (StdItem <> nil) and (StdItem.StdMode = 60) and (StdItem.shape <> 0) and (CompareText(StdItem.Name, sItmeName) = 0) then begin
          case nType of
            0: begin//品质
              case cMethod of
                '=': if UserItem.btValue[0] = nDura then Result := True;
                '>': if UserItem.btValue[0] > nDura then Result := True;
                '<': if UserItem.btValue[0] < nDura then Result := True;
                else if UserItem.btValue[0] >= nDura then Result := True;
              end;
            end;
            1: begin//酒精度
              case cMethod of
                '=': if UserItem.btValue[1] = nDura then Result := True;
                '>': if UserItem.btValue[1] > nDura then Result := True;
                '<': if UserItem.btValue[1] < nDura then Result := True;
                else if UserItem.btValue[1] >= nDura then Result := True;
              end;
            end;
            2: begin//酒等级
              case cMethod of
                '=': if UserItem.btValue[3] = nDura then Result := True;
                '>': if UserItem.btValue[3] > nDura then Result := True;
                '<': if UserItem.btValue[3] < nDura then Result := True;
                else if UserItem.btValue[3] >= nDura then Result := True;
              end;
            end;
          end;
          if Result then Break;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKMAKEWINE',[g_sExceptionVer]));
  end;
end;
//功能: 检测人物是否在指定范围之内 20090808
//格式: CheckHumInRange 名字(self) 地图 坐标X 坐标Y 范围(0-500)
Function TNormNpc.ConditionOfCheckHumInRange(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  sMapName, sPlayName: string;
  nX, nY, nRange: Integer;
  Envir: TEnvirnoment;
  BaseObject: TPlayObject;
begin
  Result := False;
  try
    sMapName:=GetLineVariableText(PlayObject, QuestConditionInfo.sParam2); //地图支持变量
    nX := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam3),-1);
    nY := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam4),-1);
    nRange := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam5),-1);
    if nX < 0 then GetValValue(PlayObject, QuestConditionInfo.sParam3, nX);
    if nY < 0 then GetValValue(PlayObject, QuestConditionInfo.sParam4, nY);
    if nRange < 0 then GetValValue(PlayObject, QuestConditionInfo.sParam5, nRange);
    Envir := g_MapManager.FindMap(sMapName);
    if (Envir = nil) or (nX < 0) or (nY < 0) or (nRange < 0) or (nRange > 500) then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sCHECKHUMINRANGE);
      Exit;
    end;
    if CompareText(QuestConditionInfo.sParam1, 'Self') = 0 then begin//20090904 修改
      if (PlayObject.m_PEnvir = Envir) and(abs(PlayObject.m_nCurrX - nX) <= nRange)
         and (abs(PlayObject.m_nCurrY - nY) <= nRange) then Result := True;
    end else begin
      sPlayName:=GetLineVariableText(PlayObject, QuestConditionInfo.sParam1);
      BaseObject:= UserEngine.GetPlayObject(sPlayName);
      if BaseObject <> nil then begin
        if (BaseObject.m_PEnvir = Envir) and(abs(BaseObject.m_nCurrX - nX) <= nRange)
           and (abs(BaseObject.m_nCurrY - nY) <= nRange) then Result := True;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckHumInRange',[g_sExceptionVer]));
  end
end;

//功能：检查包裹是否有指定叠加物品 20090615
//格式：CHECKKIMNEEDLE 物品名称 数量 hero
Function TNormNpc.ConditionOfCheckKimNeele(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  sItemName: string;
  nItemCount, nCount, I: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
  try
    Result := False;
    sItemName := GetLineVariableText(PlayObject, QuestConditionInfo.sParam1);//物品名称 支持变量
    nItemCount := Str_ToInt(GetLineVariableText(PlayObject, QuestConditionInfo.sParam2),0);//数量
    if (nItemCount < 0) or (sItemName = '') then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sCHECKKIMNEEDLE);
      Exit;
    end;
    if CompareText(QuestConditionInfo.sParam3, 'HERO') = 0 then begin
      {$IF HEROVERSION = 1}
      if PlayObject.m_MyHero <> nil then begin
        if (not PlayObject.m_MyHero.m_boDeath) and (not PlayObject.m_MyHero.m_boGhost) then begin
          if PlayObject.m_MyHero.m_ItemList.Count > 0 then begin
            nCount:= 0;
            for I := 0 to PlayObject.m_MyHero.m_ItemList.Count - 1 do begin
              UserItem := PlayObject.m_MyHero.m_ItemList.Items[I];
              if UserItem <> nil then begin
                if UserItem.MakeIndex > 0 then begin
                  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                  if StdItem <> nil then begin
                    if (CompareText(StdItem.Name, sItemName) = 0) and (StdItem.StdMode = 17) then begin
                      if UserItem.Dura > 0 then begin
                        Inc(nCount, UserItem.Dura);
                        if nCount >= nItemCount then begin
                          Result := True;
                          Break;
                        end;
                      end;
                    end;
                  end;
                end;
              end;
            end;
          end;
        end;
      end;
      {$IFEND}
    end else begin
      if PlayObject.m_ItemList.Count > 0 then begin
        nCount:= 0;
        for I := 0 to PlayObject.m_ItemList.Count - 1 do begin
          UserItem := PlayObject.m_ItemList.Items[I];
          if UserItem <> nil then begin
            if UserItem.MakeIndex > 0 then begin
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem <> nil then begin
                if (CompareText(StdItem.Name, sItemName) = 0) and (StdItem.StdMode = 17) then begin
                  if UserItem.Dura > 0 then begin
                    Inc(nCount, UserItem.Dura);
                    if nCount >= nItemCount then begin
                      Result := True;
                      Break;
                    end;
                  end;
                end;
              end;
            end;
          end;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckKimNeele',[g_sExceptionVer]));
  end
end;
{$IF M2Version = 1}
//检查是否开启第四连击技能
function TNormNpc.ConditionOfCHECK4BATTERSKILL(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
  Result := False;
  try
    if CompareText(QuestConditionInfo.sParam1, 'HERO') = 0 then begin//英雄
      {$IF HEROVERSION = 1}
      if PlayObject.m_MyHero <> nil then begin
        if THeroObject(PlayObject.m_MyHero).m_boTrainingNG and THeroObject(PlayObject.m_MyHero).m_boTrainBatterSkill then begin//学过内功以及学有连击技能
          if THeroObject(PlayObject.m_MyHero).m_boUser4BatterSkill then Result := True;//开启第四格连击
        end;
      end;
      {$IFEND}
    end else begin
      if PlayObject.m_boTrainingNG and PlayObject.m_boTrainBatterSkill then begin//学过内功以及学有连击技能
        if PlayObject.m_boUser4BatterSkill then Result := True;//开启第四格连击
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECK4BATTERSKILL',[g_sExceptionVer]));
  end
end;
//检查英雄是否开通经脉系统(英雄不在线，没学内功都将为F) 不带参数
function TNormNpc.ConditionOfCheckHeroOpenPuls(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
  Result := False;
  {$IF HEROVERSION = 1}
  try
    if PlayObject.m_MyHero <> nil then begin
      if THeroObject(PlayObject.m_MyHero).m_boTrainingNG then begin
        if THeroObject(PlayObject.m_MyHero).m_boOpenHumanPulseArr then Result := True;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckHeroOpenPuls',[g_sExceptionVer]));
  end
  {$IFEND}
end;

//功能：检查英雄经络修炼点
//格式：CHECKHEROPULSEXP 控制符(>,<,=) 经验值
function TNormNpc.ConditionOfCheckHeroPulsExp(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethod: Char;
  dwExp: LongWord;
begin
  Result := False;
{$IF HEROVERSION = 1}
  try
    if PlayObject.m_MyHero <> nil then begin
      if THeroObject(PlayObject.m_MyHero).m_boTrainingNG and THeroObject(PlayObject.m_MyHero).m_boOpenHumanPulseArr then begin
        dwExp := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),0);
        if dwExp = 0 then begin
          ScriptConditionError(PlayObject, QuestConditionInfo, sCHECKHEROPULSEXP);
          Exit;
        end;
        cMethod := QuestConditionInfo.sParam1[1];
        case cMethod of
          '=': if THeroObject(PlayObject.m_MyHero).m_ExpPuls = dwExp then Result := True;
          '>': if THeroObject(PlayObject.m_MyHero).m_ExpPuls > dwExp then Result := True;
          '<': if THeroObject(PlayObject.m_MyHero).m_ExpPuls < dwExp then Result := True;
        else if THeroObject(PlayObject.m_MyHero).m_ExpPuls >= dwExp then Result := True;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckHeroPulsExp',[g_sExceptionVer]));
  end
{$IFEND}
end;
//功能：检查是否跨穴点击
//格式：CHECKHUMANPULSE 经络(0..4) 穴位(1..5) hero
function TNormNpc.ConditionOfCheckHumanPulse(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nPulse, nPoint: Byte;
begin
  try
    Result := False;
    nPulse := Str_ToInt(GetLineVariableText(PlayObject, QuestConditionInfo.sParam1), -1);//经络
    nPoint := Str_ToInt(GetLineVariableText(PlayObject, QuestConditionInfo.sParam2), -1);//穴位
    if (nPulse < 0) or (nPulse > 4) or (nPoint <= 0) or (nPoint > 5)  then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sCHECKHUMANPULSE);
      Exit;
    end;
    if CompareText(QuestConditionInfo.sParam3, 'HERO') = 0 then begin//英雄
      {$IF HEROVERSION = 1}
      if (PlayObject.m_MyHero <> nil) then begin
        if THeroObject(PlayObject.m_MyHero).m_boTrainingNG and THeroObject(PlayObject.m_MyHero).m_boOpenHumanPulseArr and (nPoint < 6)then begin//学过内功
          if nPoint - THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].nPulsePoint = 1 then Result := True;
        end;
      end;
      {$IFEND}
    end else begin
      if PlayObject.m_boTrainingNG and (nPoint < 6)then begin//学过内功
        if nPoint - PlayObject.m_wHumanPulseArr[nPulse].nPulsePoint = 1 then Result := True;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckHumanPulse',[g_sExceptionVer]));
  end
end;
//功能：检查打通穴位所需内功等级
//格式：CHECKOPENPULSELEVEL 经络(0..3) 穴位(1..5) Hero
function TNormNpc.ConditionOfCheckOpenPulseLevel(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nPulse, nPoint: Byte;
begin
  Result := False;
  try
    nPulse := Str_ToInt(GetLineVariableText(PlayObject, QuestConditionInfo.sParam1), -1);//经络
    nPoint := Str_ToInt(GetLineVariableText(PlayObject, QuestConditionInfo.sParam2), -1);//穴位
    if (nPulse < 0) or (nPulse > 3) or (nPoint <= 0) or (nPoint > 5)  then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sCHECKOPENPULSELEVEL);
      Exit;
    end;
    if CompareText(QuestConditionInfo.sParam3, 'HERO') = 0 then begin//英雄
      {$IF HEROVERSION = 1}
      if (PlayObject.m_MyHero <> nil) then begin
        if THeroObject(PlayObject.m_MyHero).m_boTrainingNG and THeroObject(PlayObject.m_MyHero).m_boOpenHumanPulseArr and (nPulse < 4) and (nPoint < 6) and ((nPulse * 5 + nPoint - 1) < 20) then begin//学过内功
          if THeroObject(PlayObject.m_MyHero).m_NGLevel >= g_Config.dwPulsePointNGLevel[nPulse * 5 + nPoint - 1] then Result := True;
        end;
      end;
      {$IFEND}
    end else begin
      if PlayObject.m_boTrainingNG and (nPulse < 4) and (nPoint < 6) and ((nPulse * 5 + nPoint - 1) < 20) then begin//学过内功
        if PlayObject.m_NGLevel >= g_Config.dwPulsePointNGLevel[nPulse * 5 + nPoint - 1] then Result := True;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckOpenPulseLevel',[g_sExceptionVer]));
  end
end;
//功能：检查各经络等级
//格式：CHECKPULSELEVEL 经络(0..3,all) 控制符(>,<,=) 等级(0..5) hero
//经络: all表示四条经验，0..3，表示只检测一条经络
function TNormNpc.ConditionOfCheckPulseLevel(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nLevel, nPulse: Byte;
  cMethod: Char;
  boAllPulse: Boolean;
begin
  Result := False;
  if CompareText(QuestConditionInfo.sParam4, 'HERO') = 0 then begin
    {$IF HEROVERSION = 1}
    if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then Exit;
    if PlayObject.m_MyHero <> nil then begin
      if not THeroObject(PlayObject.m_MyHero).m_boTrainingNG then Exit;
      boAllPulse:= False;
      try
        if CompareText(QuestConditionInfo.sParam1, 'All') = 0 then boAllPulse:= True
        else nPulse:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam1),-1);
        nLevel := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam3),-1);
        if (nLevel < 0) or (nLevel > 5) then begin
          ScriptConditionError(PlayObject, QuestConditionInfo, sCHECKPULSELEVEL);
          Exit;
        end;
        cMethod := QuestConditionInfo.sParam2[1];
        if not boAllPulse then begin
          case cMethod of
            '=': if (THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel = nLevel) and
                   THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].boOpenPulse then Result := True;
            '>': if (THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel > nLevel) and
                   THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].boOpenPulse then Result := True;
            '<': if (THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel < nLevel) and
                   THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].boOpenPulse then Result := True;
            else if (THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel >= nLevel) and
                   THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[nPulse].boOpenPulse then Result := True;
          end;
        end else begin//所有经络
          case cMethod of
            '=': begin
               if (THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[0].nPulseLevel = nLevel) and THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[0].boOpenPulse and
                  (THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[1].nPulseLevel = nLevel) and THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[1].boOpenPulse and
                  (THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[2].nPulseLevel = nLevel) and THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[2].boOpenPulse and
                  (THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[3].nPulseLevel = nLevel) and THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[3].boOpenPulse then Result := True;
             end;
            '>': begin
               if (THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[0].nPulseLevel > nLevel) and THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[0].boOpenPulse and
                  (THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[1].nPulseLevel > nLevel) and THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[1].boOpenPulse and
                  (THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[2].nPulseLevel > nLevel) and THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[2].boOpenPulse and
                  (THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[3].nPulseLevel > nLevel) and THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[3].boOpenPulse then Result := True;
             end;
            '<': begin
               if (THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[0].nPulseLevel < nLevel) and THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[0].boOpenPulse and
                  (THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[1].nPulseLevel < nLevel) and THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[1].boOpenPulse and
                  (THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[2].nPulseLevel < nLevel) and THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[2].boOpenPulse and
                  (THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[3].nPulseLevel < nLevel) and THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[3].boOpenPulse then Result := True;
             end;
            else begin
              if (THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[0].nPulseLevel >= nLevel) and THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[0].boOpenPulse and
                 (THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[1].nPulseLevel >= nLevel) and THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[1].boOpenPulse and
                 (THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[2].nPulseLevel >= nLevel) and THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[2].boOpenPulse and
                 (THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[3].nPulseLevel >= nLevel) and THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[3].boOpenPulse then Result := True;
            end;
          end;
        end;
      except
        MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckPulseLevel1',[g_sExceptionVer]));
      end
    end;
    {$IFEND}
  end else begin
    if not PlayObject.m_boTrainingNG then Exit;//没学内功则退出
    boAllPulse:= False;
    try
      if CompareText(QuestConditionInfo.sParam1, 'All') = 0 then boAllPulse:= True
      else nPulse:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam1),-1);
      nLevel := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam3),-1);
      if (nLevel < 0) or (nLevel > 5) then begin
        ScriptConditionError(PlayObject, QuestConditionInfo, sCHECKPULSELEVEL);
        Exit;
      end;
      cMethod := QuestConditionInfo.sParam2[1];
      if not boAllPulse then begin
        case cMethod of
          '=': if (PlayObject.m_wHumanPulseArr[nPulse].nPulseLevel = nLevel) and
                 PlayObject.m_wHumanPulseArr[nPulse].boOpenPulse then Result := True;
          '>': if (PlayObject.m_wHumanPulseArr[nPulse].nPulseLevel > nLevel) and
                 PlayObject.m_wHumanPulseArr[nPulse].boOpenPulse then Result := True;
          '<': if (PlayObject.m_wHumanPulseArr[nPulse].nPulseLevel < nLevel) and
                 PlayObject.m_wHumanPulseArr[nPulse].boOpenPulse then Result := True;
          else if (PlayObject.m_wHumanPulseArr[nPulse].nPulseLevel >= nLevel) and
                 PlayObject.m_wHumanPulseArr[nPulse].boOpenPulse then Result := True;
        end;
      end else begin//所有经络
        case cMethod of
          '=': begin
             if (PlayObject.m_wHumanPulseArr[0].nPulseLevel = nLevel) and PlayObject.m_wHumanPulseArr[0].boOpenPulse and
                (PlayObject.m_wHumanPulseArr[1].nPulseLevel = nLevel) and PlayObject.m_wHumanPulseArr[1].boOpenPulse and
                (PlayObject.m_wHumanPulseArr[2].nPulseLevel = nLevel) and PlayObject.m_wHumanPulseArr[2].boOpenPulse and
                (PlayObject.m_wHumanPulseArr[3].nPulseLevel = nLevel) and PlayObject.m_wHumanPulseArr[3].boOpenPulse then Result := True;
           end;
          '>': begin
             if (PlayObject.m_wHumanPulseArr[0].nPulseLevel > nLevel) and PlayObject.m_wHumanPulseArr[0].boOpenPulse and
                (PlayObject.m_wHumanPulseArr[1].nPulseLevel > nLevel) and PlayObject.m_wHumanPulseArr[1].boOpenPulse and
                (PlayObject.m_wHumanPulseArr[2].nPulseLevel > nLevel) and PlayObject.m_wHumanPulseArr[2].boOpenPulse and
                (PlayObject.m_wHumanPulseArr[3].nPulseLevel > nLevel) and PlayObject.m_wHumanPulseArr[3].boOpenPulse then Result := True;
           end;
          '<': begin
             if (PlayObject.m_wHumanPulseArr[0].nPulseLevel < nLevel) and PlayObject.m_wHumanPulseArr[0].boOpenPulse and
                (PlayObject.m_wHumanPulseArr[1].nPulseLevel < nLevel) and PlayObject.m_wHumanPulseArr[1].boOpenPulse and
                (PlayObject.m_wHumanPulseArr[2].nPulseLevel < nLevel) and PlayObject.m_wHumanPulseArr[2].boOpenPulse and
                (PlayObject.m_wHumanPulseArr[3].nPulseLevel < nLevel) and PlayObject.m_wHumanPulseArr[3].boOpenPulse then Result := True;
           end;
          else begin
            if (PlayObject.m_wHumanPulseArr[0].nPulseLevel >= nLevel) and PlayObject.m_wHumanPulseArr[0].boOpenPulse and
               (PlayObject.m_wHumanPulseArr[1].nPulseLevel >= nLevel) and PlayObject.m_wHumanPulseArr[1].boOpenPulse and
               (PlayObject.m_wHumanPulseArr[2].nPulseLevel >= nLevel) and PlayObject.m_wHumanPulseArr[2].boOpenPulse and
               (PlayObject.m_wHumanPulseArr[3].nPulseLevel >= nLevel) and PlayObject.m_wHumanPulseArr[3].boOpenPulse then Result := True;
          end;
        end;
      end;
    except
      MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckPulseLevel',[g_sExceptionVer]));
    end
  end;
end;
{$IFEND}
//功能：检查服务器挂机人数  20090719
//格式：CHECKAUTOADDEXPPLAY 控制符(>,<,=) 人数
function TNormNpc.ConditionOfCheckAutoAddExpPlay(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nCount, nServerCount: Integer;
  cMethod: Char;
begin
  try
    Result := False;
    nCount := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);
    if nCount < 0 then begin
      if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nCount) then begin //增加变量支持
        ScriptConditionError(PlayObject, QuestConditionInfo, sCHECKAUTOADDEXPPLAY);
        Exit;
      end;
    end;
    nServerCount:= UserEngine.AutoAddExpPlayCount;
    cMethod := QuestConditionInfo.sParam1[1];
    case cMethod of
      '=': if nServerCount = nCount then Result := True;
      '>': if nServerCount > nCount then Result := True;
      '<': if nServerCount < nCount then Result := True;
      else if nServerCount >= nCount then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckAutoAddExpPlay',[g_sExceptionVer]));
  end
end;
//功能：检查服务器假人数
//格式：CHECKAIPLAY 控制符(>,<,=) 人数
function TNormNpc.ConditionOfCheckAIPlay(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nCount, nServerCount: Integer;
  cMethod: Char;
begin
  try
    Result := False;
    nCount := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);
    if nCount < 0 then begin
      if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nCount) then begin //增加变量支持
        ScriptConditionError(PlayObject, QuestConditionInfo, sCHECKAIPLAY);
        Exit;
      end;
    end;
    nServerCount:= UserEngine.AIPlayCount;
    cMethod := QuestConditionInfo.sParam1[1];
    case cMethod of
      '=': if nServerCount = nCount then Result := True;
      '>': if nServerCount > nCount then Result := True;
      '<': if nServerCount < nCount then Result := True;
      else if nServerCount >= nCount then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckAIPlay',[g_sExceptionVer]));
  end
end;
//功能：检查地图是否存在
//格式：CHECKMAP 地图ID
function TNormNpc.ConditionOfCheckMap(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  sMapA: String;
begin
  Result := False;
  try
    sMapA:= GetLineVariableText(PlayObject, QuestConditionInfo.sParam1); //地图ID 支持变量
    if (sMapA ='') then begin //增加变量支持
      ScriptConditionError(PlayObject, QuestConditionInfo, sCHECKMAP);
      Exit;
    end;
    if g_MapManager.FindMap(sMapA) <> nil then Result := True;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckMap',[g_sExceptionVer]));
  end
end;
//检测PK值 20080520
Function TNormNpc.ConditionOfCHECKPKPOINT(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nPKPOINT: Integer;
  cMethod: Char;
begin
  try
    Result := False;
    nPKPOINT := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
    if nPKPOINT < 0 then begin
      if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nPKPOINT) then begin //增加变量支持
        ScriptConditionError(PlayObject, QuestConditionInfo, sCHECKPKPOINT);
        Exit;
      end;
    end;

    cMethod := QuestConditionInfo.sParam1[1];
    case cMethod of
      '=': if PlayObject.m_nPkPoint = nPKPOINT then Result := True;
      '>': if PlayObject.m_nPkPoint > nPKPOINT then Result := True;
      '<': if PlayObject.m_nPkPoint < nPKPOINT then Result := True;
      else if PlayObject.m_nPkPoint >= nPKPOINT then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKPKPOINT',[g_sExceptionVer]));
  end;
end;
//检测英雄PK值 20080304
function TNormNpc.ConditionOfCHECKHEROPKPOINT(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  n_mHEROPKPOINT, nHEROPKPOINT: Integer;
  cMethod: Char;
begin
try
  Result := False;
  {$IF HEROVERSION = 1}
  if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then begin //20080519
    ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKHEROPKPOINT);
    Exit;
  end;

  //nHEROPKPOINT := Str_ToInt(QuestConditionInfo.sParam2, -1);
  nHEROPKPOINT := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
  if nHEROPKPOINT < 0 then begin
    if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nHEROPKPOINT) then begin //增加变量支持
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKHEROPKPOINT);
      Exit;
    end;
  end;

  if PlayObject.m_MyHero <> nil then begin
    n_mHEROPKPOINT := PlayObject.m_MyHero.m_nPkPoint;
    cMethod := QuestConditionInfo.sParam1[1];
    case cMethod of
      '=': if n_mHEROPKPOINT = nHEROPKPOINT then Result := True;
      '>': if n_mHEROPKPOINT > nHEROPKPOINT then Result := True;
      '<': if n_mHEROPKPOINT < nHEROPKPOINT then Result := True;
    else if n_mHEROPKPOINT >= nHEROPKPOINT then Result := True;
    end;
  end;
  {$IFEND}
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKHEROPKPOINT',[g_sExceptionVer]));
end;
end;
//-----------------------------------------------------------------------------
//功能：检测文本里的编码是否存在 20080410
//格式：CHECKCODELIST 玩家变量 文件路径
//例子: CHECKCODELIST <$STR(S1)> ..\questdiary\冲值\500元卡号.txt
function TNormNpc.ConditionOfCHECKCODELIST(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  I: Integer;
  LoadList: TStringList;
  sPlayID, sLine, sFileName: string;
begin
try
  Result := False;
  try
    sPlayID := GetLineVariableText(PlayObject, QuestConditionInfo.sParam1);//增加变量支持 20080410 用户的变量,即输入的字符
    LoadList := TStringList.Create;
    sFileName:= QuestConditionInfo.sParam2;//文本路径
    if sFileName <> '' then begin
      if sFileName[1] = '\' then sFileName := Copy(sFileName, 2, Length(sFileName) - 1);
      if sFileName[2] = '\' then sFileName := Copy(sFileName, 3, Length(sFileName) - 2);
      if sFileName[3] = '\' then sFileName := Copy(sFileName, 4, Length(sFileName) - 3);
    end;
    sFileName:= g_Config.sEnvirDir + sFileName;

    if FileExists(sFileName) then begin
      LoadList.LoadFromFile(sFileName);
      if LoadList.Count > 0 then begin//20080629
        for I := 0 to LoadList.Count - 1 do begin
          sLine := Trim(LoadList.Strings[I]);
          if (sLine = '') or (sLine[1] = ';') then Continue;
          if CompareText(sLine, sPlayID) = 0 then begin
            Result := True;
            Break;
          end;
        end;
      end;
    end else begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKCODELIST);
    end;
  finally
    LoadList.Free;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKCODELIST',[g_sExceptionVer]));
end;
end;
//-----------------------------------------------------------------------------
//功能：检测行会成员上限
//格式：CHECKGUILDMEMBERCOUNT <,>,= 人数(65535)
function TNormNpc.ConditionOfCHECKGUILDMEMBERCOUNT(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nMemberCount: Word;
  cMethod: Char;
begin
  try
    Result := False;
    if PlayObject.m_MyGuild <> nil then begin
      nMemberCount := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),0);
      cMethod := QuestConditionInfo.sParam1[1];
      case cMethod of
        '=': if TGUild(PlayObject.m_MyGuild).m_nGuildMemberCount = nMemberCount then Result := True;
        '>': if TGUild(PlayObject.m_MyGuild).m_nGuildMemberCount > nMemberCount then Result := True;
        '<': if TGUild(PlayObject.m_MyGuild).m_nGuildMemberCount < nMemberCount then Result := True;
      else if TGUild(PlayObject.m_MyGuild).m_nGuildMemberCount >= nMemberCount then Result := True;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKGUILDMEMBERCOUNT',[g_sExceptionVer]));
  end;
end;
//-----------------------------------------------------------------------------
//功能：检测行会成员人数
//格式：CHECKGUILDCOUNT <,>,= 人数(65535)
function TNormNpc.ConditionOfCHECKGUILDCOUNT(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nCount: Word;
  cMethod: Char;
begin
  try
    Result := False;
    if PlayObject.m_MyGuild <> nil then begin
      nCount := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),0);
      cMethod := QuestConditionInfo.sParam1[1];
      case cMethod of
        '=': if TGUild(PlayObject.m_MyGuild).Count = nCount then Result := True;
        '>': if TGUild(PlayObject.m_MyGuild).Count > nCount then Result := True;
        '<': if TGUild(PlayObject.m_MyGuild).Count < nCount then Result := True;
      else if TGUild(PlayObject.m_MyGuild).Count >= nCount then Result := True;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKGUILDCOUNT',[g_sExceptionVer]));
  end;
end;
//-----------------------------------------------------------------------------
//功能：检测行会酒泉数
//格式：CHECKGUILDFOUNTAINVALUE <,>,= 点数
function TNormNpc.ConditionOfCHECKGUILDFOUNTAINValue(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nPoint: Integer;
  cMethod: Char;
begin
  try
    Result := False;
    if PlayObject.m_MyGuild <> nil then begin
      nPoint := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),0);//20091107 支持变量
      //nPoint := Str_ToInt(QuestConditionInfo.sParam2, 0);
      cMethod := QuestConditionInfo.sParam1[1];
      case cMethod of
        '=': if TGUild(PlayObject.m_MyGuild).m_nGuildFountain = nPoint then Result := True;
        '>': if TGUild(PlayObject.m_MyGuild).m_nGuildFountain > nPoint then Result := True;
        '<': if TGUild(PlayObject.m_MyGuild).m_nGuildFountain < nPoint then Result := True;
      else if TGUild(PlayObject.m_MyGuild).m_nGuildFountain >= nPoint then Result := True;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKGUILDFOUNTAINValue',[g_sExceptionVer]));
  end;
end;

//-----------------------------------------------------------------------------
//功能:检查指定装备位置是否带有指定的物品
//格式:CHECKITEMSNAME 位置(0-13) 物品名称
function TNormNpc.ConditionOfCHECKITEMSNAME(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  n1: Integer;
  sName: String;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
  try
    Result := False;
    n1 := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam1),-1);//位置
    sName:= GetLineVariableText(PlayObject,QuestConditionInfo.sParam2);//物品名字
    if (not (n1 in [0..14])) or (sName = '') then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sCHECKITEMSNAME);
      Exit;
    end;

    UserItem := @PlayObject.m_UseItems[n1];
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if (UserItem.wIndex <= 0) or (StdItem = nil) then begin
      //PlayObject.SysMsg('你身上没有戴指定物品！！！', c_Red, t_Hint);
      Exit;
    end;
    if CompareText(StdItem.Name, sName) = 0 then  Result := True;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKITEMSNAME',[g_sExceptionVer]));
  end;
end;
//-----------------------------------------------------------------------------
//功能：检查装备绑定状态   20080312
//格式：CHECKITEMSTATE 装备位置(0-13) 项目(0-5)
//项目: 0 禁止扔1 禁止交易 2 禁止存 3 禁止修 4 禁止出售 5 禁止爆出
function TNormNpc.ConditionOfCHECKITEMSTATE(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  n1,n2: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
  try
    Result := False;
    n1 := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam1),-1);//20080501
    n2 := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
    if n1 < 0 then GetValValue(PlayObject, QuestConditionInfo.sParam1, n1); //支持变量
    if n2 < 0 then GetValValue(PlayObject, QuestConditionInfo.sParam2, n2); //支持变量

    if (not (n1 in [0..14])) or (not (n2 in [0..5])) then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sCHECKITEMSTATE);
      Exit;
    end;

    UserItem := @PlayObject.m_UseItems[n1];
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if (UserItem.wIndex <= 0) or (StdItem = nil) then begin
      Exit;
    end;

    Result := PlayObject.CheckItemValue(UserItem, n2);
    {case n2 of //项目
      0: if UserItem.btValue[14] = 1 then Result := True;
      1: if UserItem.btValue[15] = 1 then Result := True;
      2: if UserItem.btValue[16] = 1 then Result := True;
      3: if UserItem.btValue[17] = 1 then Result := True;
      4: if UserItem.btValue[18] = 1 then Result := True;
      5: if UserItem.btValue[19] = 1 then Result := True;
    end; }
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKITEMSTATE',[g_sExceptionVer]));
  end;
end;
//-----------------------------------------------------------------------------
//功能：检测服务器最高属性人物命令  20080427 修改
//格式：ISHIGH 项目(L P D M S)
//项目: L--等级  P--PK值  D--攻击力  M--魔法力  S--道术
function TNormNpc.ConditionOfISHIGH(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMode: Char;
begin
  Result := False;
  try
    if QuestConditionInfo.sParam1 = '' then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sISHIGH);
      Exit;
    end;
    cMode := QuestConditionInfo.sParam1[1];
    case cMode of
      'L': Result := g_HighLevelHuman = PlayObject;
      'P': Result := g_HighPKPointHuman = PlayObject;
      'D': Result := g_HighDCHuman = PlayObject;
      'M': Result := g_HighMCHuman = PlayObject;
      'S': Result := g_HighSCHuman = PlayObject;
    else
      ScriptConditionError(PlayObject, QuestConditionInfo, sISHIGH);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfISHIGH',[g_sExceptionVer]));
  end;
end;
//-----------------------------------------------------------------------------
//检查英雄职业 
function TNormNpc.ConditionOfCheckHeroJob(PlayObject: TPlayObject; QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  btJob: Byte;
begin
  try
    Result := False;
    {$IF HEROVERSION = 1}
    if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then begin //20080519
      //ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKHEROJOB);//20090211 注释
      Exit;
    end;
    if PlayObject.m_MyHero <> nil then begin
      btJob := PlayObject.m_MyHero.m_btJob;
      if CompareLStr(QuestConditionInfo.sParam1, 'WARRIOR'{sWARRIOR}, 3) then begin
        Result := True;//20080423
        if btJob <> 0 then Result := False;
      end;
      if CompareLStr(QuestConditionInfo.sParam1, 'WIZARD'{sWIZARD}, 3) then begin
        Result := True;//20080423
        if btJob <> 1 then Result := False;
      end;
      if CompareLStr(QuestConditionInfo.sParam1, 'TAOIST'{sTAOS}, 3) then begin
        Result := True;//20080423
        if btJob <> 2 then Result := False;
      end;
      {if CompareLStr(QuestConditionInfo.sParam1, 'ASSASSIN', 3) then begin
        Result := True;
        if btJob <> 3 then Result := False;//刺客
      end;}
    end;
    {$IFEND}
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckHeroJob',[g_sExceptionVer]));
  end;
end;

function TNormNpc.GetValValue(PlayObject: TPlayObject;
  sMsg: string; var nValue: Integer): Boolean;
var
  n01: Integer;
begin
  try
    Result := False;
    if sMsg = '' then Exit;
    n01 := GetValNameNo(sMsg);
    if n01 >= 0 then begin
      case n01 of
        0..99: begin
            if PlayObject <> nil then begin//20090805 增加
              nValue := PlayObject.m_nVal[n01];
              Result := True;
            end;
          end;
        100..199: begin
            nValue := g_Config.GlobalVal[n01 - 100];
            Result := True;
          end;
        200..299: begin
            if PlayObject <> nil then begin//20090805 增加
              nValue := PlayObject.m_DyVal[n01 - 200];
              Result := True;
            end;
          end;
        300..399: begin
            if PlayObject <> nil then begin//20090805 增加
              nValue := PlayObject.m_nMval[n01 - 300];
              Result := True;
            end;
          end;
        400..499: begin
            nValue := g_Config.GlobaDyMval[n01 - 400];
            Result := True;
          end;
        500..599: begin
            if PlayObject <> nil then begin//20090805 增加
              nValue := PlayObject.m_nInteger[n01 - 500];
              Result := True;
            end;  
          end;
        800..1199:begin//20080903 G变量
            nValue := g_Config.GlobalVal[n01 - 700];
            Result := True;
          end;
        2100..2599: begin//G变量(500-999)
            nValue := g_Config.GlobalVal[n01 - 1600];
            Result := True;
          end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.GetValValue1 n01:%d',[g_sExceptionVer, n01]));
  end;
end;

function TNormNpc.GetValValue(PlayObject: TPlayObject;
  sMsg: string; var sValue: string): Boolean;
var
  n01: Integer;
begin
  try
    Result := False;
    if sMsg = '' then Exit;
    n01 := GetValNameNo(sMsg);
    if n01 >= 0 then begin
      case n01 of
        600..699: begin
            if PlayObject <> nil then begin//20090805 增加
              sValue := PlayObject.m_sString[n01 - 600];
              Result := True;
            end;
          end;
        700..799: begin
            sValue := g_Config.GlobalAVal[n01 - 700];
            Result := True;
          end;
        1200..2099:begin//A变量(100-999)
            sValue := g_Config.GlobalAVal[n01 - 1100];
            Result := True;
          end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.GetValValue2 n01:%d',[g_sExceptionVer, n01]));
  end;
end;

function TNormNpc.SetValValue(PlayObject: TPlayObject;
  sMsg: string; nValue: Integer): Boolean;
var
  n01: Integer;
begin
try
  Result := False;
  if sMsg = '' then Exit;
  n01 := GetValNameNo(sMsg);
  if n01 >= 0 then begin
    case n01 of
      0..99: begin
          PlayObject.m_nVal[n01] := nValue;
          Result := True;
        end;
      100..199: begin
          g_Config.GlobalVal[n01 - 100] := nValue;
          Result := True;
        end;
      200..299: begin
          PlayObject.m_DyVal[n01 - 200] := nValue;
          Result := True;
        end;
      300..399: begin
          PlayObject.m_nMval[n01 - 300] := nValue;
          Result := True;
        end;
      400..499: begin
          g_Config.GlobaDyMval[n01 - 400] := nValue;
          Result := True;
        end;
      500..599: begin
          PlayObject.m_nInteger[n01 - 500] := nValue;
          Result := True;
        end;
      800..1199:begin//20080903 G变量
          g_Config.GlobalVal[n01 - 700] := nValue;
          Result := True;
        end;
      2100..2599: begin//G变量(500-999)
          g_Config.GlobalVal[n01 - 1600] := nValue;
          Result := True;
        end;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.SetValValue1',[g_sExceptionVer]));
end;
end;

function TNormNpc.SetValValue(PlayObject: TPlayObject;
  sMsg: string; sValue: string): Boolean;
var
  n01: Integer;
begin
try
  Result := False;
  if sMsg = '' then Exit;
  n01 := GetValNameNo(sMsg);
  if n01 >= 0 then begin
    case n01 of
      600..699: begin
          PlayObject.m_sString[n01 - 600] := sValue;
          Result := True;
        end;
      700..799: begin
          g_Config.GlobalAVal[n01 - 700] := sValue;
          Result := True;
        end;
      1200..2099:begin//A变量(100-999)
          g_Config.GlobalAVal[n01 - 1100] := sValue;
          Result := True;
        end;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.SetValValue2',[g_sExceptionVer]));
end;
end;

procedure TNormNpc.ActionOfAnsiReplaceText(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  sValue1: string;
  sValue2: string;
  sValue3: string;
  n01: Integer;
begin
  try
    sValue1 := QuestActionInfo.sParam1;
    sValue2:= QuestActionInfo.sParam2;
    if (sValue2 <> '') and (sValue2[1] = '<') and (sValue2[2] = '$') then
       sValue2 := GetLineVariableText(PlayObject, QuestActionInfo.sParam2)
    else GetValValue(PlayObject, QuestActionInfo.sParam2, sValue2);

    sValue3:= QuestActionInfo.sParam3;
    if (sValue3 <> '') and (sValue3[1] = '<') and (sValue3[2] = '$') then
       sValue3 := GetLineVariableText(PlayObject, QuestActionInfo.sParam3)
    else GetValValue(PlayObject, QuestActionInfo.sParam3, sValue3);

    if (sValue1 = '') or (sValue2 = '') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_ANSIREPLACETEXT);
      Exit;
    end;
    //GetValValue(PlayObject, QuestActionInfo.sParam2, sValue2); //20110304 注释
    //GetValValue(PlayObject, QuestActionInfo.sParam3, sValue3); //20110304 注释
    n01 := GetValNameNo(sValue1);
    if n01 >= 0 then begin
      case n01 of
        600..699: begin
            sValue1 := PlayObject.m_sString[n01 - 600];
            if AnsiContainsText(sValue1, sValue2) then
              PlayObject.m_sString[n01 - 600] := AnsiReplaceText(sValue1, sValue2, sValue3);
          end;
        700..799: begin
            sValue1 := g_Config.GlobalAVal[n01 - 700];
            if AnsiContainsText(sValue1, sValue2) then
              g_Config.GlobalAVal[n01 - 700] := AnsiReplaceText(sValue1, sValue2, sValue3);
          end;
        1200..2099:begin//A变量(100-999)
            sValue1 := g_Config.GlobalAVal[n01 - 1100];
            if AnsiContainsText(sValue1, sValue2) then
              g_Config.GlobalAVal[n01 - 1100] := AnsiReplaceText(sValue1, sValue2, sValue3);
          end;
      else begin
          ScriptActionError(PlayObject, '', QuestActionInfo, sSC_ANSIREPLACETEXT);
        end;
      end;
    end else ScriptActionError(PlayObject, '', QuestActionInfo, sSC_ANSIREPLACETEXT);
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfAnsiReplaceText',[g_sExceptionVer]));
  end;
end;

procedure TNormNpc.ActionOfEncodeText(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  sNewValue: string;
  sValue1: string;
  sValue2: string;
  sValue3: string;
  sValue4: string;
  sValue5: string;
  sValue6: string;
  n01: Integer;

  function GetHumanInfoValue(sVariable: string; var sValue: string): Boolean;
  var
    sMsg, s10: string;
  begin
    Result := False;
    if sVariable = '' then Exit;
    sMsg := sVariable;
    ArrestStringEx(sMsg, '<', '>', s10);
    if s10 = '' then Exit;
    sVariable := s10;
    //个人信息
    if sVariable = '$USERNAME' then begin//人物名称
      sValue := PlayObject.m_sCharName;
      Result := True;
      Exit;
    end;
    {$IF M2Version <> 2}
    if sVariable = '$SETFENGHAOHUM' then begin//任命称号人名
      sValue := PlayObject.m_sFenghaoName;
      Result := True;
      Exit;
    end;
    if sVariable = '$DIVISIONNAME' then begin//师门名称
      if PlayObject.m_MyDivision <> nil then begin
        sValue := TDivision(PlayObject.m_MyDivision).sDivisionName;
      end else begin
        sValue := '';
      end;
      Result := True;
      Exit;
    end;
    //Add By TasNat at: 2012-04-23 17:16:11
    if sVariable = '$DIVISIONPOPULARITY' then begin//师门人气值
      if PlayObject.m_MyDivision <> nil then begin
        sValue := InttoStr(TDivision(PlayObject.m_MyDivision).nPopularity);
      end else begin
        sValue := '';
      end;
      Result := True;
      Exit;
    end;
    //Add By TasNat at: 2012-04-23 17:16:11
    if sVariable = '$DIVISIONHEARTLEVEL' then begin//传承心法等级
      if PlayObject.m_MyDivision <> nil then begin
        sValue := InttoStr(TDivision(PlayObject.m_MyDivision).nHeartLevel);
      end else begin
        sValue := '';
      end;
      Result := True;
      Exit;
    end;
    if sVariable = '$HEARTNAME' then begin//心法名称
      if PlayObject.m_sHeartName <> '' then begin
        sValue := PlayObject.m_sHeartName;
      end else begin
        sValue := '';
      end;
      Result := True;
      Exit;
    end;
    {$IFEND}
    if sVariable = '$USERALLNAME' then begin//全名  200080419
      sValue := PlayObject.GetShowName;
      Result := True;
      Exit;
    end;
    {$IF HEROVERSION = 1}
    if sVariable = '$HERONAME' then begin//英雄名称 200990708
      if PlayObject.m_MyHero <> nil then begin
        sValue := PlayObject.m_MyHero.m_sCharName;
      end else begin
        sValue := '';
      end;
      Result := True;
      Exit;
    end;
    if sVariable = '$HERODRESS' then begin
      if PlayObject.m_MyHero <> nil then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_DRESS].wIndex);
      end else sValue := '';
      Result := True;
      Exit;
    end else
    if sVariable = '$HEROWEAPON' then begin
      if PlayObject.m_MyHero <> nil then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_WEAPON].wIndex);
      end else sValue := '';
      Result := True;
      Exit;
    end else
    if sVariable = '$HERORIGHTHAND' then begin
      if PlayObject.m_MyHero <> nil then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_RIGHTHAND].wIndex);
      end else sValue := '';
      Result := True;
      Exit;
    end else
    if sVariable = '$HEROHELMET' then begin
      if PlayObject.m_MyHero <> nil then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_HELMET].wIndex);
      end else sValue := '';
      Result := True;
      Exit;
    end else
    if sVariable = '$HERONECKLACE' then begin
      if PlayObject.m_MyHero <> nil then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_NECKLACE].wIndex);
      end else sValue := '';
      Result := True;
      Exit;
    end else
    if sVariable = '$HERORING_R' then begin
      if PlayObject.m_MyHero <> nil then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_RINGR].wIndex);
      end else sValue := '';
      Result := True;
      Exit;
    end else
    if sVariable = '$HERORING_L' then begin
      if PlayObject.m_MyHero <> nil then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_RINGL].wIndex);
      end else sValue := '';
      Result := True;
      Exit;
    end else
    if sVariable = '$HEROARMRING_R' then begin
      if PlayObject.m_MyHero <> nil then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_ARMRINGR].wIndex);
      end else sValue := '';
      Result := True;
      Exit;
    end else
    if sVariable = '$HEROARMRING_L' then begin
      if PlayObject.m_MyHero <> nil then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_ARMRINGL].wIndex);
      end else sValue := '';
      Result := True;
      Exit;
    end else
    if sVariable = '$HEROBUJUK' then begin
      if PlayObject.m_MyHero <> nil then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_BUJUK].wIndex);
      end else sValue := '';
      Result := True;
      Exit;
    end else
    if sVariable = '$HEROBELT' then begin
      if PlayObject.m_MyHero <> nil then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_BELT].wIndex);
      end else sValue := '';
      Result := True;
      Exit;
    end else
    if sVariable = '$HEROBOOTS' then begin
      if PlayObject.m_MyHero <> nil then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_BOOTS].wIndex);
      end else sValue := '';
      Result := True;
      Exit;
    end else
    if sVariable = '$HERODRUM' then begin
      if PlayObject.m_MyHero <> nil then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_DRUM].wIndex);
      end else sValue := '';
      Result := True;
      Exit;
    end else
    if sVariable = '$HEROCHARM' then begin
      if PlayObject.m_MyHero <> nil then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_CHARM].wIndex);
      end else sValue := '';
      Result := True;
      Exit;
    end else
    if sVariable = '$HEROZHULI' then begin //斗笠
      if PlayObject.m_MyHero <> nil then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_ZHULI].wIndex);
      end else sValue := '';
      Result := True;
      Exit;
    end;
    {$IFEND}
    if sVariable = '$DEARNAME' then begin//配偶名
      sValue := PlayObject.m_sDearName;
      Result := True;
      Exit;
    end;
    if sVariable = '$SFNAME' then begin//师傅名  200080603
      sValue := PlayObject.m_sMasterName;
      Result := True;
      Exit;
    end;
    if sVariable = '$TDNAME1' then begin//大徒弟
      sValue := PlayObject.GetApprenticeName(1);
      Result := True;
      Exit;
    end;
    if sVariable = '$TDNAME2' then begin//二徒弟
      sValue := PlayObject.GetApprenticeName(2);
      Result := True;
      Exit;
    end;
    if sVariable = '$TDNAME3' then begin//三徒弟
      sValue := PlayObject.GetApprenticeName(3);
      Result := True;
      Exit;
    end;
    if sVariable = '$TDNAME4' then begin//四徒弟
      sValue := PlayObject.GetApprenticeName(4);
      Result := True;
      Exit;
    end;
    if sVariable = '$TDNAME5' then begin//五徒弟
      sValue := PlayObject.GetApprenticeName(5);
      Result := True;
      Exit;
    end;
    {if sVariable = '$PETSER' then begin//攻击宠物变量(临时) 20110616
      if (PlayObject.m_btRaceServer = RC_PLAYOBJECT) and (PlayObject.m_TargetCret <> nil) then begin
        if (PlayObject.m_TargetCret.m_btRaceServer = 158) then begin
          sValue := TPetsMon(PlayObject.m_TargetCret).m_sMasterName;
        end;
      end else sValue := '';
      Result := True;
      Exit;
    end; }
    if sVariable = '$KILLER' then begin//杀人者变量
      if PlayObject.m_boDeath and (PlayObject.m_LastHiter <> nil) then begin
        if (PlayObject.m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) then begin
          sValue := PlayObject.m_LastHiter.m_sCharName;
        end else
        if (PlayObject.m_LastHiter.m_btRaceServer = RC_HEROOBJECT) or
          (PlayObject.m_LastHiter.m_btRaceServer = 156) then begin
          if PlayObject.m_LastHiter.m_Master <> nil then
            sValue := PlayObject.m_LastHiter.m_Master.m_sCharName
          else sValue := '未知';
        end;
      end else sValue := '未知';
      Result := True;
      Exit;
    end;
    if sVariable = '$MONKILLER' then begin//杀人的怪物变量
      if PlayObject.m_boDeath and (PlayObject.m_LastHiter <> nil) then begin
        if (PlayObject.m_LastHiter.m_btRaceServer <> RC_PLAYOBJECT) and (PlayObject.m_LastHiter.m_btRaceServer <> RC_HEROOBJECT) then begin
          sValue := PlayObject.m_LastHiter.m_sCharName;
        end;
      end else sValue := '未知';
      Result := True;
      Exit;
    end;
    if sVariable = '$MAP' then begin
      sValue := PlayObject.m_PEnvir.sMapName;
      Result := True;
      Exit;
    end;
    if sVariable = '$GUILDNAME' then begin//行会名称
      if PlayObject.m_MyGuild <> nil then begin
        sValue := TGUild(PlayObject.m_MyGuild).sGuildName;
      end else begin
        sValue := '';
      end;
      Result := True;
      Exit;
    end;
    if sVariable = '$RANKNAME' then begin
      sValue := PlayObject.m_sGuildRankName;
      Result := True;
      Exit;
    end;
    if sVariable = '$DRESS' then begin
      sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_DRESS].wIndex);
      Result := True;
      Exit;
    end else
      if sVariable = '$WEAPON' then begin
      sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_WEAPON].wIndex);
      Result := True;
      Exit;
    end else
      if sVariable = '$RIGHTHAND' then begin
      sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_RIGHTHAND].wIndex);
      Result := True;
      Exit;
    end else
      if sVariable = '$HELMET' then begin
      sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_HELMET].wIndex);
      Result := True;
      Exit;
    end else
      if sVariable = '$NECKLACE' then begin
      sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_NECKLACE].wIndex);
      Result := True;
      Exit;
    end else
      if sVariable = '$RING_R' then begin
      sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_RINGR].wIndex);
      Result := True;
      Exit;
    end else
      if sVariable = '$RING_L' then begin
      sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_RINGL].wIndex);
      Result := True;
      Exit;
    end else
      if sVariable = '$ARMRING_R' then begin
      sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_ARMRINGR].wIndex);
      Result := True;
      Exit;
    end else
      if sVariable = '$ARMRING_L' then begin
      sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_ARMRINGL].wIndex);
      Result := True;
      Exit;
    end else
      if sVariable = '$BUJUK' then begin
      sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_BUJUK].wIndex);
      Result := True;
      Exit;
    end else
      if sVariable = '$BELT' then begin
      sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_BELT].wIndex);
      Result := True;
      Exit;
    end else
      if sVariable = '$BOOTS' then begin
      sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_BOOTS].wIndex);
      Result := True;
      Exit;
    end else
      if sVariable = '$DRUM' then begin
      sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_DRUM].wIndex);
      Result := True;
      Exit;
    end else
      if sVariable = '$CHARM' then begin
      sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_CHARM].wIndex);
      Result := True;
      Exit;
    end else
    if sVariable = '$ZHULI' then begin //斗笠
      sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_ZHULI].wIndex);
      Result := True;
      Exit;
    end else
      if sVariable = '$MACHINEID' then begin
      sValue := '$' + IntToHex(PlayObject.m_dwHCode, 8);;
      Result := True;
      Exit;
    end else
     if sVariable = '$REFINEARMYDRUMITEM' then begin
      sValue := PlayObject.m_sTmpStr;
      Result := True;
      Exit;
    end else
      if sVariable = '$IPADDR' then begin
      sValue := PlayObject.m_sIPaddr;
      Result := True;
      Exit;
    end else
      if sVariable = '$PETSNAME' then begin//宠物名
      sValue := PlayObject.m_sPetsMonName;
      Result := True;
      Exit;
    end else
      if sVariable = '$IPLOCAL' then begin
      sValue := PlayObject.m_sIPLocal; // GetIPLocal(PlayObject.m_sIPaddr);
      Result := True;
      Exit;
    end;
  end;
  procedure SetEncodeText(sValName, sValue: string);
  begin
    n01 := GetValNameNo(sValName);
    if n01 >= 0 then begin
      case n01 of
        600..699: begin
            PlayObject.m_sString[n01 - 600] := sValue;
          end;
        700..799: begin
            g_Config.GlobalAVal[n01 - 700] := sValue;
          end;
        1200..2099:begin//A变量(100-999)
            g_Config.GlobalAVal[n01 - 1100] := sValue;
          end;
      else begin
          ScriptActionError(PlayObject, '', QuestActionInfo, sSC_ENCODETEXT);
        end;
      end;
    end else ScriptActionError(PlayObject, '', QuestActionInfo, sSC_ENCODETEXT);
  end;
begin
  try
    sValue1 := QuestActionInfo.sParam1;
    sValue2 := QuestActionInfo.sParam2;
    sValue3 := QuestActionInfo.sParam3;
    sValue4 := QuestActionInfo.sParam4;
    sValue5 := QuestActionInfo.sParam5;
    sValue6 := QuestActionInfo.sParam6;
    if (sValue2 <> '') and (sValue2[1] = '<') and (sValue2[Length(sValue2)] = '>') then begin
      GetHumanInfoValue(sValue2, sValue2);
    end else begin
      GetValValue(PlayObject, sValue2, sValue2);
    end;
    if (sValue3 <> '') and (sValue3[1] = '<') and (sValue3[Length(sValue3)] = '>') then begin
      GetHumanInfoValue(sValue3, sValue3);
    end else begin
      GetValValue(PlayObject, sValue3, sValue3);
    end;
    if (sValue4 <> '') and (sValue4[1] = '<') and (sValue4[Length(sValue4)] = '>') then begin
      GetHumanInfoValue(sValue4, sValue4);
    end else begin
      GetValValue(PlayObject, sValue4, sValue4);
    end;
    if (sValue5 <> '') and (sValue5[1] = '<') and (sValue5[Length(sValue5)] = '>') then begin
      GetHumanInfoValue(sValue5, sValue5);
    end else begin
      GetValValue(PlayObject, sValue5, sValue5);
    end;
    if (sValue6 <> '') and (sValue6[1] = '<') and (sValue6[Length(sValue6)] = '>') then begin
      GetHumanInfoValue(sValue6, sValue6);
    end else begin
      GetValValue(PlayObject, sValue6, sValue6);
    end;
    sNewValue := sValue2 + sValue3 + sValue4 + sValue5 + sValue6;
    SetEncodeText(sValue1, sNewValue);
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfEncodeText',[g_sExceptionVer]));
  end;
end;

//穿上物品
procedure TNormNpc.ActionOfTakeOnItem(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  I, nItemIdx: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  sItemName, sUserItemName: string;
  nWhere: Integer;
  boFound: Boolean;
begin
  try
    sItemName := GetLineVariableText(PlayObject, QuestActionInfo.sParam1);
    nWhere := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2), -1);
    if (sItemName = '') or (not (nWhere in {$IF M2Version <> 2}[Low(THumanUseItems)..High(THumanUseItems)]{$ELSE}[Low(THumItems)..High(THumItems)]{$IFEND})) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_TAKEONITEM);
      Exit;
    end;
    nItemIdx := -1;
    boFound := False;
    if CompareText(QuestActionInfo.sParam3, 'HERO') = 0 then begin
      {$IF HEROVERSION = 1}
      if PlayObject.m_MyHero <> nil then begin
        if PlayObject.m_MyHero.m_ItemList.Count > 0 then begin 
          for I := 0 to PlayObject.m_MyHero.m_ItemList.Count - 1 do begin
            UserItem := PlayObject.m_MyHero.m_ItemList.Items[I];
            if UserItem <> nil then begin
              //取自定义物品名称
              sUserItemName := '';
              if UserItem.btValue[13] = 1 then
                sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
              if sUserItemName = '' then sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem <> nil then begin
                if CompareText(sUserItemName, sItemName) = 0 then begin
                  boFound := True;
                  nItemIdx := UserItem.MakeIndex;
                  Break;
                end;
              end;
            end;
          end;
        end;
        if (nItemIdx >= 0) and boFound then begin
          PlayObject.ClientHeroTakeOnItems(nWhere, nItemIdx, sItemName);
          THeroObject(PlayObject.m_MyHero).SendUseitems();//发送使用的物品
          //优化By TasNat at: 2012-05-19 18:12:33
          //THeroObject(PlayObject.m_MyHero).ClientQueryBagItems;
        end;
      end;
      {$IFEND}
    end else begin
      if PlayObject.m_ItemList.Count > 0 then begin //20080628
        for I := 0 to PlayObject.m_ItemList.Count - 1 do begin
          UserItem := PlayObject.m_ItemList.Items[I];
          if UserItem <> nil then begin
            //取自定义物品名称
            sUserItemName := '';
            if UserItem.btValue[13] = 1 then
              sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
            if sUserItemName = '' then
              sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if StdItem <> nil then begin
              if CompareText(sUserItemName, sItemName) = 0 then begin
                boFound := True;
                nItemIdx := UserItem.MakeIndex;
                Break;
              end;
            end;
          end;
        end;
      end;
      if (nItemIdx >= 0) and boFound then begin
        PlayObject.ClientTakeOnItems(nWhere, nItemIdx, sItemName);
        PlayObject.SendUseitems();//发送使用的物品
        //优化By TasNat at: 2012-05-19 18:12:33
        //PlayObject.ClientQueryBagItems();//刷新包裹
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfTakeOnItem',[g_sExceptionVer]));
  end;
end;
//脱下装备
procedure TNormNpc.ActionOfTakeOffItem(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  nItemIdx: Integer;
  sItemName, sUserItemName: string;
  nWhere: Integer;
begin
try
  sItemName := QuestActionInfo.sParam1;
  nWhere := Str_ToInt(QuestActionInfo.sParam2, -1);
  if (sItemName = '') or (not (nWhere in {$IF M2Version <> 2}[Low(THumanUseItems)..High(THumanUseItems)]{$ELSE}[Low(THumItems)..High(THumItems)]{$IFEND})) then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_TAKEONITEM);
    Exit;
  end;
  if CompareText(QuestActionInfo.sParam3, 'HERO') = 0 then begin//20080805
    {$IF HEROVERSION = 1}
    if PlayObject.m_MyHero <> nil then begin
      if PlayObject.m_MyHero.m_UseItems[nWhere].wIndex > 0 then begin
        sUserItemName := '';
        if PlayObject.m_MyHero.m_UseItems[nWhere].btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(PlayObject.m_MyHero.m_UseItems[nWhere].MakeIndex, PlayObject.m_MyHero.m_UseItems[nWhere].wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[nWhere].wIndex);
        if CompareText(sUserItemName, sItemName) = 0 then begin
          nItemIdx := PlayObject.m_MyHero.m_UseItems[nWhere].MakeIndex;
          PlayObject.ClientHeroTakeOffItems(nWhere, nItemIdx, sItemName);
          THeroObject(PlayObject.m_MyHero).SendUseitems();//发送使用的物品
        end;
      end;
    end;
    {$IFEND}
  end else begin
    if PlayObject.m_UseItems[nWhere].wIndex > 0 then begin
      sUserItemName := '';
      if PlayObject.m_UseItems[nWhere].btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(PlayObject.m_UseItems[nWhere].MakeIndex, PlayObject.m_UseItems[nWhere].wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(PlayObject.m_UseItems[nWhere].wIndex);
      if CompareText(sUserItemName, sItemName) = 0 then begin
        nItemIdx := PlayObject.m_UseItems[nWhere].MakeIndex;
        PlayObject.ClientTakeOffItems(nWhere, nItemIdx, sItemName);
        PlayObject.SendUseitems();//发送使用的物品
      end;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfTakeOffItem',[g_sExceptionVer]));
end;
end;
{$IF HEROVERSION = 1}
//创建英雄数据
//格式:CREATEHERO 2 1 TRUE 使用方法跟原来的一样，只是后面加个参数TRUE，代表为创建第二个英雄 20080514
procedure TNormNpc.ActionOfCreateHero(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  nJob: Integer;
  nSex: Integer;
  nHair: Integer;
  sMsg, sAccount, sChrName, sHair, sJob, sSex, sLevel, sHeroType: string;
begin
  try
    nJob := Str_ToInt(QuestActionInfo.sParam1, -1);//职业
    nSex := Str_ToInt(QuestActionInfo.sParam2, -1);//性别
    if (nJob < 0) or (nSex < 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CREATEHERO);
      Exit;
    end;

    if CompareText(QuestActionInfo.sParam3, 'TRUE') = 0 then begin//创建卧龙英雄
      if (Trim(PlayObject.m_sTempHeroCharName) <> '') and (not PlayObject.m_boHasHeroTwo) then begin
        case nSex of
          0: nHair := 2;
          1: begin
              case Random(2) of
                0: nHair := 1;
                1: nHair := 3;
              end;
            end;
        end;
        sAccount := PlayObject.m_sUserID;
        PlayObject.m_sHeroCharName:= Trim(PlayObject.m_sTempHeroCharName);
        PlayObject.m_btDeputyHeroJob:= nJob;
        sChrName := PlayObject.m_sHeroCharName;
        PlayObject.m_sTempHeroCharName:='';
        sHair := IntToStr(nHair);
        sJob := IntToStr(nJob);
        sSex := IntToStr(nSex);
        sLevel := IntToStr(g_Config.nDrinkHeroStartLevel);
        sHeroType:= IntToStr(1);//英雄类型
        PlayObject.n_tempHeroTpye:= 1;//20080519
        sMsg := sAccount + '/' + sChrName + '/' + sHair + '/' + sJob + '/' + sSex + '/' + sLevel+'/'+PlayObject.m_sCharName+'/'+ sHeroType;//增加主人的名字 20080408
        FrontEngine.AddToLoadHeroRcdList(sChrName, sMsg, PlayObject, 1, False, 255);
      end else begin
        GotoLable(PlayObject, '@CreateHeroFailEx', False, False);
      end;
    end else begin//白日门英雄
      if (Trim(PlayObject.m_sTempHeroCharName) <> '') and (not PlayObject.m_boHasHero) then begin
        case nSex of
          0: nHair := 2;
          1: begin
              case Random(2) of
                0: nHair := 1;
                1: nHair := 3;
              end;
            end;
        end;
        sAccount := PlayObject.m_sUserID;
        PlayObject.m_sHeroCharName:= Trim(PlayObject.m_sTempHeroCharName);
        sChrName := PlayObject.m_sHeroCharName;
        PlayObject.m_sTempHeroCharName:='';
        sHair := IntToStr(nHair);
        sJob := IntToStr(nJob);
        sSex := IntToStr(nSex);
        sLevel := IntToStr(g_Config.nHeroStartLevel);
        sHeroType:= IntToStr(0);//英雄类型
        PlayObject.n_tempHeroTpye:= 0;//20080519
        sMsg := sAccount + '/' + sChrName + '/' + sHair + '/' + sJob + '/' + sSex + '/' + sLevel+'/'+PlayObject.m_sCharName+'/'+ sHeroType;//增加主人的名字 20080408
        FrontEngine.AddToLoadHeroRcdList(sChrName, sMsg, PlayObject, 1, False, 255);
      end else begin
        GotoLable(PlayObject, '@CreateHeroFailEx', False, False);
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfCreateHero',[g_sExceptionVer]));
  end;
end;
//删除英雄 对应的NPC才能删除对应的英雄
procedure TNormNpc.ActionOfDeleteHero(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
begin
  try
    if PlayObject.n_HeroSave = 2 then begin
      GotoLable(PlayObject, '@NotDelHero', False, False);
      Exit;//评定主副将英雄后则不能操作删除命令
    end;
    if TMerchant(self).m_boBuHero then begin//卧龙英雄NPC
      if (PlayObject.m_boHasHeroTwo) and (PlayObject.n_myHeroTpye = 1) then begin
        if (PlayObject.m_MyHero <> nil) and (not PlayObject.m_MyHero.m_boDeath) then begin
          GotoLable(PlayObject, '@LogOutHeroFirst', False, False);
        end else begin
          FrontEngine.AddToLoadHeroRcdList(PlayObject.m_sHeroCharName, '', PlayObject, 2, False, 255);
        end;
      end else begin
        GotoLable(PlayObject, '@NotHaveHero', False, False);
      end;
    end else begin//白日门英雄NPC
      if (PlayObject.m_boHasHero) and (PlayObject.n_myHeroTpye = 0) then begin
        if (PlayObject.m_MyHero <> nil) and (not PlayObject.m_MyHero.m_boDeath) then begin
          GotoLable(PlayObject, '@LogOutHeroFirst', False, False);
        end else begin
          FrontEngine.AddToLoadHeroRcdList(PlayObject.m_sHeroCharName, '', PlayObject, 2, False, 255);
        end;
      end else begin
        GotoLable(PlayObject, '@NotHaveHero', False, False);
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfDeleteHero',[g_sExceptionVer]));
  end;
end;
//改变英雄等级
procedure TNormNpc.ActionOfChangeHeroLevel(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  boChgOK: Boolean;
  nLevel: Integer;
  nLv: Integer;
  nOldLevel: Integer;
  cMethod: Char;
begin
try
  if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then begin //20080519
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEHEROLEVEL);
    Exit;
  end;
  if PlayObject.m_MyHero <> nil then begin
    boChgOK := False;
    nOldLevel := PlayObject.m_MyHero.m_Abil.Level;
    nLevel := Str_ToInt(QuestActionInfo.sParam2, -1);
    if (nLevel < 0) and (not GetValValue(PlayObject, QuestActionInfo.sParam2, nLevel)) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEHEROLEVEL);
      Exit;
    end;
    cMethod := QuestActionInfo.sParam1[1];
    case cMethod of
      '=': begin
          if (nLevel > 0) and (nLevel <= MAXLEVEL) then begin
            PlayObject.m_MyHero.m_Abil.Level := nLevel;
            boChgOK := True;
          end;
        end;
      '-': begin
          nLv := _MAX(0, PlayObject.m_MyHero.m_Abil.Level - nLevel); //20080321 修改
          nLv := _MIN(MAXLEVEL, nLv);
          PlayObject.m_MyHero.m_Abil.Level := nLv;
          boChgOK := True;
        end;
      '+': begin
          nLv := _MAX(0, PlayObject.m_MyHero.m_Abil.Level + nLevel);//20080321 修改
          nLv := _MIN(MAXLEVEL, nLv);
          PlayObject.m_MyHero.m_Abil.Level := nLv;
          boChgOK := True;
        end;
    end;
    if boChgOK then begin
      PlayObject.m_MyHero.HasLevelUp(nOldLevel);
      AddGameDataLog('17' + #9 + PlayObject.m_MyHero.m_sMapName + #9 + //等级调整记录日志 20080911
        IntToStr(PlayObject.m_MyHero.m_nCurrX) + #9 +
        IntToStr(PlayObject.m_MyHero.m_nCurrY)+ #9 +
        PlayObject.m_MyHero.m_sCharName + #9 +
        IntToStr(PlayObject.m_MyHero.m_Abil.Level) + #9 +
        '1' + #9 +
        cMethod+'('+IntToStr(nLv)+')' + #9 +
        m_sCharName);
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeHeroLevel',[g_sExceptionVer]));
end;
end;

//改变英雄职业(转职)
//格式：CHANGEHEROJOB 职业(Warrior/WIZARD/TAOIST) 是否清连击变量(1-全部初始 2-清空经络修炼等级)
//注：副将英雄不能修改职业
procedure TNormNpc.ActionOfChangeHeroJob(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  nJob, I: Integer;
  nType: Byte;
begin
  try
    if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then begin //20080519
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEHEROJOB);
      Exit;
    end;
    nJob := -1;
    if CompareLStr(QuestActionInfo.sParam1, 'WARRIOR'{sWARRIOR}, 3) then nJob := 0;
    if CompareLStr(QuestActionInfo.sParam1, 'WIZARD'{sWIZARD}, 3) then nJob := 1;
    if CompareLStr(QuestActionInfo.sParam1, 'TAOIST'{sTAOS}, 3) then nJob := 2;
    //if CompareLStr(QuestActionInfo.sParam1, 'ASSASSIN', 3) then nJob := 3;//刺客
    nType:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2),0);//操作类型

    if nJob < 0 then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEHEROJOB);
      Exit;
    end;
    if (PlayObject.m_MyHero <> nil) then begin
      if (PlayObject.m_MyHero.m_btJob <> nJob) and (not PlayObject.m_boCallDeputyHero) then begin//副将英雄不能修改职业
        PlayObject.m_MyHero.m_btJob := nJob;
        PlayObject.m_MyHero.HasLevelUp(0);
      end;
      Case nType of
        1: begin//初始所有连击变量
          {$IF M2Version = 1}
          FillChar(THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr, SizeOf(THeroPulseInfo1), #0);
          THeroObject(PlayObject.m_MyHero).SendUserPulseArr;//更新客户端显示
          {$IFEND}
          with THeroObject(PlayObject.m_MyHero) do begin
            m_PulseAddAC:= 0;//防御上限
            m_PulseAddAC1:= 0;//防御下限
            m_PulseAddMAC:= 0;//魔御上限
            m_PulseAddMAC1:= 0;//魔御下限
            m_nDecDamage:= 0;//吸收伤害
            {$IF M2Version = 1}
            m_boTrainBatterSkill:= False;
            m_boUser4BatterSkill:= False;//使用第四格连击 20100720
            m_boOpenHumanPulseArr:= False;
            {$IFEND}
          end;
        end;
        2: begin//初始经络修练等级
          {$IF M2Version = 1}
          for I := Low(THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr) to High(THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr) do begin
            THeroObject(PlayObject.m_MyHero).m_wHumanPulseArr[I].nPulseLevel := 0;
          end;
          {$IFEND}
          with THeroObject(PlayObject.m_MyHero) do begin
            m_PulseAddAC:= 0;//防御上限
            m_PulseAddAC1:= 0;//防御下限
            m_PulseAddMAC:= 0;//魔御上限
            m_PulseAddMAC1:= 0;//魔御下限
            m_nDecDamage:= 0;//吸收伤害
            {$IF M2Version = 1}
            m_boTrainBatterSkill:= False;
            m_boUser4BatterSkill:= False;//使用第四格连击 20100720
            SendUserPulseArr;//更新客户端显示
            {$IFEND}
          end;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeHeroJob',[g_sExceptionVer]));
  end;
end;

//清除英雄技能 20080107
procedure TNormNpc.ActionOfClearHeroSkill(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  I: Integer;
  UserMagic: pTUserMagic;
begin
try
  if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then begin //20080519
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CLEARHEROSKILL);
    Exit;
  end;
  if PlayObject.m_MyHero <> nil then begin
     if QuestActionInfo.sParam1 <> '' then begin//指定技能名称,则删除指定的技能
       for I := PlayObject.m_MyHero.m_MagicList.Count - 1 downto 0 do begin//20080916 修改
         if PlayObject.m_MyHero.m_MagicList.Count <=0 then Break;//20080916
         UserMagic:= PlayObject.m_MyHero.m_MagicList.Items[i];
          if UserMagic <> nil then begin
            if  CompareText(UserMagic.MagicInfo.sMagicName, QuestActionInfo.sParam1) = 0  then begin
              THeroObject(PlayObject.m_MyHero).SendDelMagic(UserMagic);
              //防止释放内存后的非法访问 By TasNat at: 2012-03-11 
              //PlayObject.m_MyHero.m_MagicOfDelList.Add(UserMagic);
              Dispose(UserMagic);
              PlayObject.m_MyHero.m_MagicList.Delete(I);
              break;
            end;
          end;
        end;//for
     end else begin //没有指定技能名称,则删除全部技能
       for I := PlayObject.m_MyHero.m_MagicList.Count - 1 downto 0 do begin
         if PlayObject.m_MyHero.m_MagicList.Count <=0 then Break;//20080916
         UserMagic := PlayObject.m_MyHero.m_MagicList.Items[I];
         THeroObject(PlayObject.m_MyHero).SendDelMagic(UserMagic);
         //防止释放内存后的非法访问 By TasNat at: 2012-03-11 
         //PlayObject.m_MyHero.m_MagicOfDelList.Add(UserMagic);
         Dispose(UserMagic);
         PlayObject.m_MyHero.m_MagicList.Delete(I);
       end;//for
     end;
    PlayObject.m_MyHero.RecalcAbilitys();//20081213
    PlayObject.m_MyHero.CompareSuitItem(False);//200080729 套装
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfClearHeroSkill',[g_sExceptionVer]));
end;
end;

procedure TNormNpc.ActionOfChangeHeroPKPoint(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  nPKPOINT: Integer;
  nPoint: Integer;
  nOldPKLevel: Integer;
  cMethod: Char;
begin
try
  if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then begin //20080519
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEHEROPKPOINT);
    Exit;
  end;
  if PlayObject.m_MyHero <> nil then begin
    nOldPKLevel := PlayObject.m_MyHero.PKLevel;
    nPKPOINT := Str_ToInt(QuestActionInfo.sParam2, -1);
    if (nPKPOINT < 0) and (not GetValValue(PlayObject, QuestActionInfo.sParam2, nPKPOINT)) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEHEROPKPOINT);
      Exit;
    end;
    cMethod := QuestActionInfo.sParam1[1];
    case cMethod of
      '=': begin
          if (nPKPOINT >= 0) then begin
            PlayObject.m_MyHero.m_nPkPoint := nPKPOINT;
          end;
        end;
      '-': begin
          nPoint := _MAX(0, PlayObject.m_MyHero.m_nPkPoint - nPKPOINT);
          PlayObject.m_MyHero.m_nPkPoint := nPoint;
        end;
      '+': begin
          nPoint := _MAX(0, PlayObject.m_MyHero.m_nPkPoint + nPKPOINT);
          PlayObject.m_MyHero.m_nPkPoint := nPoint;
        end;
    end;
    if nOldPKLevel <> PlayObject.m_MyHero.PKLevel then
      PlayObject.m_MyHero.RefNameColor;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeHeroPKPoint',[g_sExceptionVer]));
end;
end;

//改变英雄的经验
//CHANGEHEROEXP +/-/= 点数 类型(0/1)
//+经验时，0是按等级限制，达到限制等级时则不再增加经验 1是不管等级限制，增加经验
procedure TNormNpc.ActionOfChangeHeroExp(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  boChgOK: Boolean;
  nExp : Int64;
  nExp32 : Integer;
  J: Integer;
  cMethod: Char;
  dwInt: Int64;
begin
  try
    if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then begin //20080519
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEHEROEXP);
      Exit;
    end;
    boChgOK := False;
    //nExp := Str_ToInt(QuestActionInfo.sParam2, -1);
    nExp := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);
    if (nExp < 0) then
      if (not GetValValue(PlayObject, QuestActionInfo.sParam2, nExp32)) then begin
        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEHEROEXP);
        Exit;
      end else nExp := nExp32;
    J:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam3),0);//分配类型
    if PlayObject.m_MyHero <> nil then begin
      cMethod := QuestActionInfo.sParam1[1];
      case cMethod of
        '=': begin
            if nExp >= 0 then begin
              PlayObject.m_MyHero.m_Abil.nExp := Int64(nExp);
            end;
          end;
        '-': begin
            if PlayObject.m_MyHero.m_Abil.nExp > nExp then begin
              Dec(PlayObject.m_MyHero.m_Abil.nExp, nExp);
            end else begin
              PlayObject.m_MyHero.m_Abil.nExp := 0;
            end;
          end;
        '+': begin
            case J of
              0: begin
                if PlayObject.m_MyHero.m_Abil.Level < g_Config.nLimitExpLevelHero then begin//是否超过限制等级 //20090131 修改
                  if PlayObject.m_MyHero.m_Abil.Level >= 1000 then begin//20090323 等级分配经验
                    nExp:= Round(nExp * (g_Config.dwLevelToExpRate[1000] / 100));
                    if nExp <= 0 then nExp:= 1;
                  end else begin
                    nExp:= Round(nExp * (g_Config.dwLevelToExpRate[PlayObject.m_MyHero.m_Abil.Level] / 100));
                    if nExp <= 0 then nExp:= 1;
                  end;
                  dwInt := Int64(nExp);
                  THeroObject(PlayObject.m_MyHero).GetExp(dwInt, 0);
                end;
              end;
              1: begin
                if PlayObject.m_MyHero.m_Abil.Level >= 1000 then begin//等级分配经验
                  nExp:= Round(nExp * (g_Config.dwLevelToExpRate[1000] / 100));
                  if nExp <= 0 then nExp:= 1;
                end else begin
                  nExp:= Round(nExp * (g_Config.dwLevelToExpRate[PlayObject.m_MyHero.m_Abil.Level] / 100));
                  if nExp <= 0 then nExp:= 1;
                end;
                dwInt := Int64(nExp);
                THeroObject(PlayObject.m_MyHero).GetExp(dwInt, 1);
              end;
            end;
          end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeHeroExp',[g_sExceptionVer]));
  end;
end;

{$IFEND}
//假人启动
procedure TNormNpc.ActionOfAIStart(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nT: Integer;
begin
  if PlayObject is TAIPlayObject then begin
    nT := Str_ToInt(QuestActionInfo.sParam1, 0);
    TAIPlayObject(PlayObject).Start(TPathType(nT));
  end;
end;
//假人停止
procedure TNormNpc.ActionOfAIStop(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
begin
  if PlayObject is TAIPlayObject then begin
    TAIPlayObject(PlayObject).Stop;
  end;
end;
//假人登陆(可设置指定的配置路径)
procedure TNormNpc.ActionOfAILogOn(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I, nC, nCount, nX, nY: Integer;
  sCharName, sMapName, sConfigFileName, sHeroConfigFileName: string;
  Envir: TEnvirnoment;
  AI: TAILogon;
begin
  sMapName:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1); //地图ID 支持变量
  Envir := g_MapManager.FindMap(sMapName);
  if Envir = nil then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_AILOGON);
    Exit;
  end;

  nX:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2), -1);//X
  nY:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3), -1);//Y
  nCount:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam4), -1);//count

  if (nX < 0) or (nY < 0) or (nCount < 0) then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_AILOGON);
    Exit;
  end;

  sConfigFileName := GetLineVariableText(PlayObject, QuestActionInfo.sParam5);
  if sConfigFileName <> '' then begin
    if sConfigFileName[1] = '\' then sConfigFileName := Copy(sConfigFileName, 2, Length(sConfigFileName) - 1);
    if sConfigFileName[2] = '\' then sConfigFileName := Copy(sConfigFileName, 3, Length(sConfigFileName) - 2);
    if sConfigFileName[3] = '\' then sConfigFileName := Copy(sConfigFileName, 4, Length(sConfigFileName) - 3);
  end;
  sHeroConfigFileName := GetLineVariableText(PlayObject, QuestActionInfo.sParam6);
  if sHeroConfigFileName <> '' then begin
    if sHeroConfigFileName[1] = '\' then sHeroConfigFileName := Copy(sHeroConfigFileName, 2, Length(sHeroConfigFileName) - 1);
    if sHeroConfigFileName[2] = '\' then sHeroConfigFileName := Copy(sHeroConfigFileName, 3, Length(sHeroConfigFileName) - 2);
    if sHeroConfigFileName[3] = '\' then sHeroConfigFileName := Copy(sHeroConfigFileName, 4, Length(sHeroConfigFileName) - 3);
  end;

  AI.sMapName := sMapName;
  AI.sConfigFileName := g_Config.sEnvirDir + sConfigFileName;
  AI.sHeroConfigFileName := g_Config.sEnvirDir + sHeroConfigFileName;
  AI.sConfigListFileName := '';
  AI.sHeroConfigListFileName := '';
  AI.sFilePath := '';
  AI.nX := nX;
  AI.nY := nY;
  nC := 0;
  g_AICharNameList.Lock;
  try
    for I := 0 to g_AICharNameList.Count - 1 do begin
      sCharName := g_AICharNameList.Strings[I];
      if (UserEngine.GetPlayObject(sCharName) = nil) and (not UserEngine.FindAILogon(sCharName)) then begin
        AI.sCharName := sCharName;
        UserEngine.AddAILogon(@AI);
        nC := nC + 1;
      end;
      if nC >= nCount then break;
    end;
  finally
    g_AICharNameList.UnLock;
  end;
end;
//假人登录(可设置指定的配置路径列表)      
procedure TNormNpc.ActionOfAILogOnEx(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I, nC, nCount, nX, nY: Integer;
  sCharName, sMapName, sConfigListFileName, sHeroConfigListFileName: string;
  Envir: TEnvirnoment;
  AI: TAILogon;
begin
  sMapName:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1); //地图ID 支持变量
  Envir := g_MapManager.FindMap(sMapName);
  if Envir = nil then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_AILOGON);
    Exit;
  end;

  nX:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2), -1);//X
  nY:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3), -1);//Y
  nCount:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam4), -1);//count

  if (nX < 0) or (nY < 0) or (nCount < 0) then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_AILOGON);
    Exit;
  end;

  sConfigListFileName := GetLineVariableText(PlayObject, QuestActionInfo.sParam5);
  if sConfigListFileName <> '' then begin
    if sConfigListFileName[1] = '\' then sConfigListFileName := Copy(sConfigListFileName, 2, Length(sConfigListFileName) - 1);
    if sConfigListFileName[2] = '\' then sConfigListFileName := Copy(sConfigListFileName, 3, Length(sConfigListFileName) - 2);
    if sConfigListFileName[3] = '\' then sConfigListFileName := Copy(sConfigListFileName, 4, Length(sConfigListFileName) - 3);
  end;
  sHeroConfigListFileName := GetLineVariableText(PlayObject, QuestActionInfo.sParam6);
  if sHeroConfigListFileName <> '' then begin
    if sHeroConfigListFileName[1] = '\' then sHeroConfigListFileName := Copy(sHeroConfigListFileName, 2, Length(sHeroConfigListFileName) - 1);
    if sHeroConfigListFileName[2] = '\' then sHeroConfigListFileName := Copy(sHeroConfigListFileName, 3, Length(sHeroConfigListFileName) - 2);
    if sHeroConfigListFileName[3] = '\' then sHeroConfigListFileName := Copy(sHeroConfigListFileName, 4, Length(sHeroConfigListFileName) - 3);
  end;

  AI.sMapName := sMapName;
  AI.sConfigFileName := '';
  AI.sHeroConfigFileName := ''; 
  AI.sFilePath := g_Config.sEnvirDir;
  AI.sConfigListFileName := g_Config.sEnvirDir + sConfigListFileName;
  AI.sHeroConfigListFileName := g_Config.sEnvirDir + sHeroConfigListFileName;
  AI.nX := nX;
  AI.nY := nY;
  nC := 0;
  g_AICharNameList.Lock;
  try
    for I := 0 to g_AICharNameList.Count - 1 do begin
      sCharName := g_AICharNameList.Strings[I];
      if (UserEngine.GetPlayObject(sCharName) = nil) and (not UserEngine.FindAILogon(sCharName)) then begin
        AI.sCharName := sCharName;
        UserEngine.AddAILogon(@AI);
        nC := nC + 1;
      end;
      if nC >= nCount then break;
    end;
  finally
    g_AICharNameList.UnLock;
  end;
end;
(*//读取假人配置
procedure TNormNpc.ActionOfLoadRobotConfig(BaseObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I, nAttatckMode: Integer;
  sFileName, sCopyHumBagItems, sLineText, sMagicName, sItemName, sSayMsg: string;
  ItemIni: TIniFile;
  TempList: TStringList;
  UserItem: pTUserItem;
  Magic: pTMagic;
  MagicInfo: pTMagic;
  UserMagic: pTUserMagic;
  StdItem: pTStdItem;
  PlayObject: TAIPlayObject;
  HeroObject: THeroObject;
  UseItemNames: pTUseItemNames;
begin
  if BaseObject.m_boAI then begin
    PlayObject := nil;
    HeroObject := nil;
    UseItemNames := nil;
    sFileName := GetLineVariableText(BaseObject, QuestActionInfo.sParam1);
    if sFileName <> '' then begin
      if sFileName[1] = '\' then sFileName := Copy(sFileName, 2, Length(sFileName) - 1);
      if sFileName[2] = '\' then sFileName := Copy(sFileName, 3, Length(sFileName) - 2);
      if sFileName[3] = '\' then sFileName := Copy(sFileName, 4, Length(sFileName) - 3);
    end;

    if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
      PlayObject := TAIPlayObject(BaseObject);
      UseItemNames := @PlayObject.m_UseItemNames;
      sFileName := GetLineVariableText(PlayObject, QuestActionInfo.sParam1);
    end else begin
      if BaseObject.m_btRaceServer = RC_HEROOBJECT then begin
        HeroObject := THeroObject(BaseObject);
        UseItemNames := @HeroObject.m_UseItemNames;
        sFileName := GetLineVariableText(TPlayObject(BaseObject.m_Master), sFileName);
      end;
    end;

    sFileName := g_Config.sEnvirDir + m_sPath + sFileName;
    if FileExists(sFileName) then begin
      ItemIni := TIniFile.Create(sFileName);
      if ItemIni <> nil then begin
        BaseObject.m_boNoDropItem := ItemIni.ReadBool('Info', 'NoDropItem', False);//是否掉包裹物品
        BaseObject.m_boNoDropUseItem := ItemIni.ReadBool('Info', 'DropUseItem', False);//是否掉装备
        BaseObject.m_nDropUseItemRate := ItemIni.ReadInteger('Info', 'DropUseItemRate', 100);//掉装备机率
        BaseObject.m_btJob := ItemIni.ReadInteger('Info', 'Job', 0);
        BaseObject.m_btGender := ItemIni.ReadInteger('Info', 'Gender', 0);
        BaseObject.m_btHair := ItemIni.ReadInteger('Info', 'Hair', 0);
        BaseObject.m_Abil.Level := ItemIni.ReadInteger('Info', 'Level', 1);
        BaseObject.m_Abil.MaxExp := GetLevelExp(m_Abil.Level);
        BaseObject.m_boTrainingNG:= ItemIni.ReadBool('Info', 'NG', False);//是否学习过内功
        if BaseObject.m_boTrainingNG then begin
          BaseObject.m_NGLevel:= ItemIni.ReadInteger('Info', 'NGLevel', 1);//内功等级
          BaseObject.GetSkill69Exp(BaseObject.m_NGLevel, BaseObject.m_Skill69MaxNH);//计算内力值上限
          BaseObject.m_Skill69NH:= BaseObject.m_Skill69MaxNH;
        end;
        TAIPlayObject(BaseObject).m_boProtectStatus:= ItemIni.ReadBool('Info','ProtectStatus',False);//是否守护模式
        nAttatckMode:= ItemIni.ReadInteger('Info','AttatckMode', 0);//攻击模式
        if nAttatckMode in [0..6] then BaseObject.m_btAttatckMode:= nAttatckMode;

        sLineText := ItemIni.ReadString('Info', 'UseSkill', '');
        if sLineText <> '' then begin
          TempList := TStringList.Create;
          try
            ExtractStrings(['|', '\', '/', ','], [], PChar(sLineText), TempList);
            for I := 0 to TempList.Count - 1 do begin
              sMagicName := Trim(TempList.Strings[I]);
              if TAIPlayObject(BaseObject).FindMagic(sMagicName) = nil then begin
                Magic := UserEngine.FindMagic(sMagicName);
                if Magic <> nil then begin
                  if (Magic.btJob = 99) or (Magic.btJob = m_btJob) then begin
                    New(UserMagic);
                    UserMagic.MagicInfo := Magic;
                    UserMagic.wMagIdx := Magic.wMagicId;
                    UserMagic.btLevel := 3;
                    UserMagic.btKey := 0;
                    UserMagic.nTranPoint := Magic.MaxTrain[3];
                    BaseObject.m_MagicList.Add(UserMagic);
                    {$IF M2Version = 1}
                    if BaseObject.m_boTrainingNG then begin
                      if (UserMagic.MagicInfo.wMagicId > SKILL_75) and (UserMagic.MagicInfo.wMagicId < SKILL_88) then begin//连击技能才处理
                        TAIPlayObject(BaseObject).m_BatterMagicList.Add(UserMagic);
                      end;
                    end;
                    {$IFEND}
                  end;
                end;
              end;
            end;
          finally
            TempList.Free;
          end;
          {$IF M2Version = 1}
          if TAIPlayObject(BaseObject).m_BatterMagicList.Count > 0 then begin
            BaseObject.m_boTrainBatterSkill:= True;
            BaseObject.m_SetBatterKey:= 1;
            BaseObject.m_SetBatterKey1:= 1;
            BaseObject.m_SetBatterKey2:= 1;
          end;
          {$IFEND}
        end;

        sLineText := ItemIni.ReadString('Info', 'InitItems', '');
        if sLineText <> '' then begin
          TempList := TStringList.Create;
          try
            ExtractStrings(['|', '\', '/', ','], [], PChar(sLineText), TempList);
            for I := 0 to TempList.Count - 1 do begin
              sItemName := Trim(TempList.Strings[I]);
              StdItem := UserEngine.GetStdItem(sItemName);
              if StdItem <> nil then begin
                New(UserItem);
                if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
                  if StdItem.StdMode in [15, 19, 20, 21, 22, 23, 24, 26] then begin
                    if (StdItem.Shape = 130) or (StdItem.Shape = 131) or (StdItem.Shape = 132) then begin
                      UserEngine.GetUnknowItemValue(UserItem);
                    end;
                  end;
                  if not BaseObject.AddItemToBag(UserItem) then begin
                    Dispose(UserItem);
                    break;
                  end;
                  TAIPlayObject(BaseObject).m_BagItemNames.Add(StdItem.Name);
                end else Dispose(UserItem);
              end;
            end;
          finally
            TempList.Free;
          end;
        end;
        for I := 0 to 9 do begin
          sSayMsg:= ItemIni.ReadString('MonSay', IntToStr(I), '');
          if sSayMsg <> '' then TAIPlayObject(BaseObject).m_AISayMsgList.Add(sSayMsg)
          else Break;
        end;
        if UseItemNames <> nil then begin
          UseItemNames[U_DRESS] := ItemIni.ReadString('UseItems', 'UseItems0'{'DRESSNAME'}, ''); // '衣服';
          UseItemNames[U_WEAPON] := ItemIni.ReadString('UseItems', 'UseItems1'{'WEAPONNAME'}, ''); // '武器';
          UseItemNames[U_RIGHTHAND] := ItemIni.ReadString('UseItems', 'UseItems2'{'RIGHTHANDNAME'}, ''); // '照明物';
          UseItemNames[U_NECKLACE] := ItemIni.ReadString('UseItems', 'UseItems3'{'NECKLACENAME'}, ''); // '项链';
          UseItemNames[U_HELMET] := ItemIni.ReadString('UseItems', 'UseItems4'{'HELMETNAME'}, ''); // '头盔';
          UseItemNames[U_ARMRINGL] := ItemIni.ReadString('UseItems', 'UseItems5'{'ARMRINGLNAME'}, ''); // '左手镯';
          UseItemNames[U_ARMRINGR] := ItemIni.ReadString('UseItems', 'UseItems6'{'ARMRINGRNAME'}, ''); // '右手镯';
          UseItemNames[U_RINGL] := ItemIni.ReadString('UseItems', 'UseItems7'{'RINGLNAME'}, ''); // '左戒指';
          UseItemNames[U_RINGR] := ItemIni.ReadString('UseItems', 'UseItems8'{'RINGRNAME'}, ''); // '右戒指';
          {$IF M2Version <> 2}
          UseItemNames[U_BUJUK] := ItemIni.ReadString('UseItems', 'UseItems9'{'BUJUKNAME'}, ''); // '物品';
          UseItemNames[U_BELT] := ItemIni.ReadString('UseItems', 'UseItems10'{'BELTNAME'}, ''); // '腰带';
          UseItemNames[U_BOOTS] := ItemIni.ReadString('UseItems', 'UseItems11'{'BOOTSNAME'}, ''); // '鞋子';
          UseItemNames[U_CHARM] := ItemIni.ReadString('UseItems', 'UseItems12'{'CHARMNAME'}, ''); // '宝石';
          UseItemNames[U_ZHULI] := ItemIni.ReadString('UseItems','UseItems13'{'CHARMNAME'}, ''); // '斗笠';
          {$IFEND}

          for I := {$IF M2Version <> 2}U_DRESS to U_ZHULI{$ELSE}U_DRESS to U_RINGR{$IFEND} do begin
            if UseItemNames[I] <> '' then begin
              StdItem := UserEngine.GetStdItem(UseItemNames[I]);
              if StdItem <> nil then begin
                New(UserItem);
                if UserEngine.CopyToUserItemFromName(UseItemNames[I], UserItem) then begin
                  if StdItem.StdMode in [15, 19, 20, 21, 22, 23, 24, 26] then begin
                    if (StdItem.Shape = 130) or (StdItem.Shape = 131) or (StdItem.Shape = 132) then begin
                      UserEngine.GetUnknowItemValue(UserItem);
                    end;
                  end;
                end;
                BaseObject.m_UseItems[I] := UserItem^;
                Dispose(UserItem);
              end;
            end;
          end;
        end;
        ItemIni.Free;

        BaseObject.m_WAbil.HP := BaseObject.m_WAbil.MaxHP;
        BaseObject.m_WAbil.MP := BaseObject.m_WAbil.MaxMP;

        BaseObject.HasLevelUp(0);
      end;
    end else begin
      ScriptActionError(BaseObject, sFileName +'(不存在)', QuestActionInfo, sSC_LOADROBOTCONFIG);
    end;
  end;
end;  *)

//命令格式:GIVEMINE 矿名称 数量 纯度
//如纯度不填,则随机给纯度
procedure TNormNpc.ActionOfGIVEMINE(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);//给矿石 20080330
var
  sMineName: String;
  nMineCount, nDura, I: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
try
  sMineName := QuestActionInfo.sParam1;//矿名
  nMineCount := Str_ToInt(QuestActionInfo.sParam2, -1);//数量
  nDura:= Str_ToInt(QuestActionInfo.sParam3, -1);//纯度
  if (nMineCount <= 0) and (not GetValValue(PlayObject, QuestActionInfo.sParam2, nMineCount)) then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_GIVEMINE);
    Exit;
  end;
  if nDura < 0 then nDura:=Random(18)+ 3;
  if (sMineName='') or (nMineCount < 0) or (nDura < 0) or (nDura > 100) then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_GIVEMINE);
    Exit;
  end;

  if nMineCount > 0 then begin//20080629
    for I := 0 to nMineCount - 1 do begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sMineName, UserItem) then begin
         StdItem := UserEngine.GetStdItem(UserItem.wIndex);
         if (StdItem <> nil) then begin//20090203
           if (StdItem.StdMode = 43) then begin
             if IsAddWeightAvailable(StdItem.Weight * nMineCount) then begin
               UserItem.Dura:= nDura * 1000;
               if UserItem.Dura > UserItem.DuraMax then UserItem.Dura:= UserItem.DuraMax;
               if StdItem.NeedIdentify = 1 then//记录游戏日志
                 AddGameDataLog('39' + #9 +m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                    IntToStr(m_nCurrY) + #9 + PlayObject.m_sCharName + #9 +StdItem.Name + #9 +
                    IntToStr(UserItem.MakeIndex) + #9 +IntToStr(UserItem.Dura)+'/'+inttostr(Useritem.DuraMax) + #9 + m_sCharName);

               PlayObject.m_ItemList.Add(UserItem);
               PlayObject.SendAddItem(UserItem);
             end;
           end;
         end;
       end else begin
         Dispose(UserItem);
         Break;
       end;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfGIVEMINE',[g_sExceptionVer]));
end;
end;

procedure TNormNpc.ActionOfRepairItem(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  nWhere: Integer;
  StdItem: pTStdItem;
  //sCheckItemName: string;
begin
  try
    if Str_ToInt(QuestActionInfo.sParam1, -1) >= 0 then begin
      nWhere := Str_ToInt(QuestActionInfo.sParam1, -1);
      if (nWhere in {$IF M2Version <> 2}[Low(THumanUseItems)..High(THumanUseItems)]{$ELSE}[Low(THumItems)..High(THumItems)]{$IFEND}) then begin
        if PlayObject.m_UseItems[nWhere].wIndex > 0 then begin
          StdItem := UserEngine.GetStdItem(PlayObject.m_UseItems[nWhere].wIndex);
          if StdItem <> nil then begin
            if (PlayObject.m_UseItems[nWhere].DuraMax > PlayObject.m_UseItems[nWhere].Dura) and (StdItem.StdMode <> 43) then begin
              if CheckItemValue(@PlayObject.m_UseItems[nWhere], 3) then begin
                Exit; //20080314 禁止修
              end else
             { if Assigned(zPlugOfEngine.CheckCanRepairItem) then begin
                sCheckItemName := StdItem.Name;
                if not zPlugOfEngine.CheckCanRepairItem(PlayObject, PChar(sCheckItemName)) then Exit;
              end;}
              if PlayObject.PlugOfCheckCanItem(3, StdItem.Name, False, 0, 0) then Exit;//禁止物品规则(管理插件功能) 20080729

              PlayObject.m_UseItems[nWhere].Dura := PlayObject.m_UseItems[nWhere].DuraMax;
              PlayObject.SendMsg(PlayObject, RM_DURACHANGE, nWhere, PlayObject.m_UseItems[nWhere].Dura, PlayObject.m_UseItems[nWhere].DuraMax, 0, '');
            end;
          end;
        end;
      end else begin
        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_REPAIRITEM);
      end;
    end else
      if Str_ToInt(QuestActionInfo.sParam1, -1) < 0 then begin
      for nWhere := Low(THumanUseItems) to High(THumanUseItems) do begin//9格装备+4格装备
        if PlayObject.m_UseItems[nWhere].wIndex > 0 then begin
          StdItem := UserEngine.GetStdItem(PlayObject.m_UseItems[nWhere].wIndex);
          if StdItem <> nil then begin
            if (PlayObject.m_UseItems[nWhere].DuraMax > PlayObject.m_UseItems[nWhere].Dura) and (StdItem.StdMode <> 43) then begin
              if CheckItemValue(@PlayObject.m_UseItems[nWhere], 3) then Continue //20080314 禁止修
              else
              {if Assigned(zPlugOfEngine.CheckCanRepairItem) then begin
                sCheckItemName := StdItem.Name;
                if not zPlugOfEngine.CheckCanRepairItem(PlayObject, PChar(sCheckItemName)) then Continue;
              end; }
              if PlayObject.PlugOfCheckCanItem(3, StdItem.Name, False, 0, 0) then Continue;//禁止物品规则(管理插件功能) 20080729

              PlayObject.m_UseItems[nWhere].Dura := PlayObject.m_UseItems[nWhere].DuraMax;
              PlayObject.SendMsg(PlayObject, RM_DURACHANGE, nWhere, PlayObject.m_UseItems[nWhere].Dura, PlayObject.m_UseItems[nWhere].DuraMax, 0, '');
            end;
          end;
        end;
      end;
    end else begin
      //ScriptActionError(PlayObject, '', QuestActionInfo, sSC_REPAIRITEM);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfRepairItem',[g_sExceptionVer]));
  end;
end;

constructor TNormNpc.Create;
begin
  inherited;
  m_boSuperMan := True;
  m_btRaceServer := RC_NPC;
  m_nLight := 2;
  m_btAntiPoison := 99;
  m_ScriptList := TList.Create;
  m_boStickMode := True;
  m_sFilePath := '';
  m_boIsHide := False;
  m_boIsQuest := True;
  m_boNpcAutoChangeColor := False;
  m_dwNpcAutoChangeColorTick := GetTickCount;
  m_dwNpcAutoChangeColorTime := 0;
  m_nNpcAutoChangeIdx := 0;
  m_boGotoCount := 0;//执行Goto的次数 20080927
  m_dwSearchTime := Random(1500) + 2500;//20090404 乐都,AFT
  m_sRefresAppr:= '';//G变量外观
  m_WinType:=1;
end;

destructor TNormNpc.Destroy;
//var
//  I: Integer;
begin
  ClearScript();
  { for I := 0 to ScriptList.Count - 1 do begin
    Dispose(pTScript(ScriptList.Items[I]));
  end; }
  m_ScriptList.Free;
  inherited;
end;

procedure TNormNpc.ExeAction(PlayObject: TPlayObject; sParam1, sParam2,
  sParam3: string; nParam1, nParam2, nParam3: Integer);
var
  nInt1: Integer;
  dwInt: LongWord;
begin
try
  //================================================
  //更改人物当前经验值
  //EXEACTION CHANGEEXP 0 经验数  设置为指定经验值
  //EXEACTION CHANGEEXP 1 经验数  增加指定经验
  //EXEACTION CHANGEEXP 2 经验数  减少指定经验
  //================================================
  if CompareText(sParam1, 'CHANGEEXP') = 0 then begin
    nInt1 := Str_ToInt(sParam2, -1);
    case nInt1 of //
      0: begin
          if nParam3 >= 0 then begin
            PlayObject.m_Abil.nExp := LongWord(nParam3);
            PlayObject.HasLevelUp({PlayObject.m_Abil.Level - 1}0);//20091022 修改
          end;
        end;
      1: begin
          if PlayObject.m_Abil.nExp >= LongWord(nParam3) then begin
            if (PlayObject.m_Abil.nExp - LongWord(nParam3)) > (High(uInt64) - PlayObject.m_Abil.nExp) then begin
              dwInt := High(uInt64) - PlayObject.m_Abil.nExp;
            end else begin
              dwInt := LongWord(nParam3);
            end;
          end else begin
            if (LongWord(nParam3) - PlayObject.m_Abil.nExp) > (High(uInt64) - LongWord(nParam3)) then begin
              dwInt := High(uInt64) - LongWord(nParam3);
            end else begin
              dwInt := LongWord(nParam3);
            end;
          end;
          Inc(PlayObject.m_Abil.nExp, dwInt);
          PlayObject.HasLevelUp({PlayObject.m_Abil.Level - 1}0);//20091022 修改
        end;
      2: begin
          if PlayObject.m_Abil.nExp > LongWord(nParam3) then begin
            Dec(PlayObject.m_Abil.nExp, LongWord(nParam3));
          end else begin
            PlayObject.m_Abil.nExp := 0;
          end;
          PlayObject.HasLevelUp({PlayObject.m_Abil.Level - 1}0);//20091022
        end;
    end;
    PlayObject.SysMsg('您当前经验点数为: ' + IntToStr(PlayObject.m_Abil.nExp) + '/' + IntToStr(PlayObject.m_Abil.nMaxExp), c_Green, t_Hint);
    Exit;
  end;

  //================================================
  //更改人物当前等级
  //EXEACTION CHANGELEVEL 0 等级数  设置为指定等级
  //EXEACTION CHANGELEVEL 1 等级数  增加指定等级
  //EXEACTION CHANGELEVEL 2 等级数  减少指定等级
  //================================================
  if CompareText(sParam1, 'CHANGELEVEL') = 0 then begin
    nInt1 := Str_ToInt(sParam2, -1);
    case nInt1 of //
      0: begin
          if nParam3 >= 0 then begin
            PlayObject.m_Abil.Level := LongWord(nParam3);
            PlayObject.HasLevelUp(PlayObject.m_Abil.Level - 1);
            AddGameDataLog('17' + #9 + PlayObject.m_sMapName + #9 + //等级调整记录日志 20080911
              IntToStr(PlayObject.m_nCurrX) + #9 +
              IntToStr(PlayObject.m_nCurrY)+ #9 +
              PlayObject.m_sCharName + #9 +
              IntToStr(PlayObject.m_Abil.Level) + #9 +
              '0' + #9 +
              '=('+IntToStr(LongWord(nParam3))+')' + #9 +
              m_sCharName);
          end;
        end;
      1: begin
          if PlayObject.m_Abil.Level >= LongWord(nParam3) then begin
            if (PlayObject.m_Abil.Level - LongWord(nParam3)) > (High(Word) - PlayObject.m_Abil.Level) then begin
              dwInt := High(Word) - PlayObject.m_Abil.Level;
            end else begin
              dwInt := LongWord(nParam3);
            end;
          end else begin
            if (LongWord(nParam3) - PlayObject.m_Abil.Level) > (High(Word) - LongWord(nParam3)) then begin
              dwInt := High(LongWord) - LongWord(nParam3);
            end else begin
              dwInt := LongWord(nParam3);
            end;
          end;
          Inc(PlayObject.m_Abil.Level, dwInt);
          PlayObject.HasLevelUp(PlayObject.m_Abil.Level - 1);
          AddGameDataLog('17' + #9 + PlayObject.m_sMapName + #9 + //等级调整记录日志 20080911
            IntToStr(PlayObject.m_nCurrX) + #9 +
            IntToStr(PlayObject.m_nCurrY)+ #9 +
            PlayObject.m_sCharName + #9 +
            IntToStr(PlayObject.m_Abil.Level) + #9 +
            '0' + #9 +
            '+('+IntToStr(dwInt)+')' + #9 +
            m_sCharName);
        end;
      2: begin
          if PlayObject.m_Abil.Level > LongWord(nParam3) then begin
            Dec(PlayObject.m_Abil.Level, LongWord(nParam3));
          end else begin
            PlayObject.m_Abil.Level := 0;
          end;
          PlayObject.HasLevelUp(PlayObject.m_Abil.Level - 1);
          AddGameDataLog('17' + #9 + PlayObject.m_sMapName + #9 + //等级调整记录日志 20080911
            IntToStr(PlayObject.m_nCurrX) + #9 +
            IntToStr(PlayObject.m_nCurrY)+ #9 +
            PlayObject.m_sCharName + #9 +
            IntToStr(PlayObject.m_Abil.Level) + #9 +
            '0' + #9 +
            '-('+IntToStr(LongWord(nParam3))+')' + #9 +
            m_sCharName);
        end;
    end;
    PlayObject.SysMsg('您当前等级为: ' + IntToStr(PlayObject.m_Abil.Level), c_Green, t_Hint);
    Exit;
  end;

  //================================================
  //杀死人物
  //EXEACTION KILL 0 人物死亡,不显示凶手信息
  //EXEACTION KILL 1 人物死亡不掉物品,不显示凶手信息
  //EXEACTION KILL 2 人物死亡,显示凶手信息为NPC
  //EXEACTION KILL 3 人物死亡不掉物品,显示凶手信息为NPC
  //================================================
  if CompareText(sParam1, 'KILL') = 0 then begin
    nInt1 := Str_ToInt(sParam2, -1);
    case nInt1 of //
      1: begin
          PlayObject.m_boNoItem := True;
          PlayObject.Die;
        end;
      2: begin
          PlayObject.SetLastHiter(Self);
          PlayObject.Die;
        end;
      3: begin
          PlayObject.m_boNoItem := True;
          PlayObject.SetLastHiter(Self);
          PlayObject.Die;
        end;
    else begin
        PlayObject.Die;
      end;
    end;
    Exit;
  end;

  //================================================
  //踢人物下线
  //EXEACTION KICK
  //================================================
  if CompareText(sParam1, 'KICK') = 0 then begin
    PlayObject.m_boKickFlag := True;
    Exit;
  end;
  //==============================================================================
except
  MainOutMessage(Format('{%s} TNormNpc.ExeAction',[g_sExceptionVer]));
end;
end;

function TNormNpc.GetLineVariableText(PlayObject: TPlayObject; sMsg: string): string;
var
  nC: Integer;
  s10: string;
begin
  try
    nC := 0;
    while (True) do begin
      try//20101126 防止死循环
        if TagCount(sMsg, '>') < 1 then Break;
        ArrestStringEx(sMsg, '<', '>', s10);
        GetVariableText(PlayObject, sMsg, s10);
      except
      end;
      Inc(nC);
      if nC >= 101 then Break;
    end;
    Result := sMsg;
  except
    MainOutMessage(Format('{%s} TNormNpc.GetLineVariableText',[g_sExceptionVer]));
  end;
end;
//取变量文本
procedure TNormNpc.GetVariableText(PlayObject: TPlayObject; var sMsg: string; sVariable: string);
var
  sText, s14: string;
  I{, II}: Integer;
  n18{, n20}: Integer;
  wHour: Word;
  wMinute: Word;
  wSecond: Word;
  nSecond: Integer;
  DynamicVar: pTDynamicVar;
  boFoundVar: Boolean;

//  nSellGold: Integer;
//  nRate: Integer;
  s1C: string;
//  SellOffInfo: pTSellOffInfo;
//  Merchant: TMerchant;
//  List20: TList;
  PoseHuman: TPlayObject;
begin
  try
    //显示人物排行
    if sVariable = '$LEVELORDER' then begin
      s1C := '';
      if PlayObject.m_PlayOrderList.Count > 0 then begin
        for I := 0 to PlayObject.m_PlayOrderList.Count - 1 do begin
          s1C := s1C + PlayObject.m_PlayOrderList.Strings[I];
        end;
      end;
      sMsg := sub_49ADB8(sMsg, '<$LEVELORDER>', s1C);
      Exit;
    end;

   { //显示拍卖款  //20080416 去掉拍卖功能
    if sVariable = '$SELLOUTGOLD' then begin
      s1C := '';
      n18 := 0;
      List20 := TList.Create;
      g_SellOffGoldList.GetUserSellOffGoldListByChrName(PlayObject.m_sCharName, List20);
      for I := 0 to List20.Count - 1 do begin
        if List20.Count <= 0 then Break;
        SellOffInfo := pTSellOffInfo(List20.Items[I]);
        if g_Config.nUserSellOffTax > 0 then begin
          nRate := SellOffInfo.nSellGold * g_Config.nUserSellOffTax div 100;
          nSellGold := SellOffInfo.nSellGold - nRate;
        end else begin
          nSellGold := SellOffInfo.nSellGold;
          nRate := 0;
        end;
        s1C := s1C + '<物品:' + UserEngine.GetStdItemName(SellOffInfo.UseItems.wIndex) + ' 金额:' + IntToStr(nSellGold) + ' 税:' + IntToStr(nRate) + g_Config.sGameGoldName + ' 拍卖日期:' + DateTimeToStr(SellOffInfo.dSellDateTime) + '>\';
        Inc(n18);
        if n18 >= 7 then Break;
      end;
      if s1C = '' then s1C := g_sSellOffGoldInfo;
      sMsg := sub_49ADB8(sMsg, '<$SELLOUTGOLD>', s1C);
      List20.Free;
      Exit;
    end; }
   (*//显示拍卖物品    //20080416 去掉拍卖功能
    if sVariable = '$SELLOFFITEM' then begin
      s1C := '';
      n18 := 0;
      List20 := TList.Create;
      g_SellOffGoodList.GetUserSellOffGoodListByChrName(PlayObject.m_sCharName, List20);
      for I := 0 to List20.Count - 1 do begin
        if List20.Count <= 0 then Break;
        SellOffInfo := pTSellOffInfo(List20.Items[II]);
        s1C := s1C + '<物品:' + UserEngine.GetStdItemName(SellOffInfo.UseItems.wIndex) + ' 金额:' + IntToStr(SellOffInfo.nSellGold) + g_Config.sGameGoldName + ' 拍卖日期:' + DateTimeToStr(SellOffInfo.dSellDateTime) + '>\';
        Inc(n18);
        if n18 >= 7 then Break;
        //n20:=n18 div 7;
        {if n20 >= 1 then begin
          n18:=0;
          s1C := s1C + '<下一页/@SELLOFFITEM'+IntToStr(n20)+'>\[@SELLOFFITEM'+IntToStr(n20)+']';
        end;}
      end;
      if s1C = '' then s1C := g_sSellOffItemInfo;
      sMsg := sub_49ADB8(sMsg, '<$SELLOFFITEM>', s1C);
      List20.Free;
      Exit;
    end; *)
    if sVariable = '$DEALGOLDPLAY' then begin
      PoseHuman := TPlayObject(PlayObject.GetPoseCreate());
      if (PoseHuman <> nil) and (TPlayObject(PoseHuman.GetPoseCreate) = PlayObject) and (PoseHuman.m_btRaceServer = RC_PLAYOBJECT) then begin
        sMsg := sub_49ADB8(sMsg, '<$DEALGOLDPLAY>', PoseHuman.m_sCharName);
      end else begin
        sMsg := sub_49ADB8(sMsg, '<$DEALGOLDPLAY>', '????');
      end;
      Exit;
    end;
    //全局信息
    if sVariable = '$SERVERNAME' then begin
      sMsg := sub_49ADB8(sMsg, '<$SERVERNAME>', g_Config.sServerName);
      Exit;
    end;
    if sVariable = '$SERVERIP' then begin
      sMsg := sub_49ADB8(sMsg, '<$SERVERIP>', g_Config.sServerIPaddr);
      Exit;
    end;
    if sVariable = '$WEBSITE' then begin
      sMsg := sub_49ADB8(sMsg, '<$WEBSITE>', g_Config.sWebSite);
      Exit;
    end;
    if sVariable = '$BBSSITE' then begin
      sMsg := sub_49ADB8(sMsg, '<$BBSSITE>', g_Config.sBbsSite);
      Exit;
    end;
    if sVariable = '$CLIENTDOWNLOAD' then begin
      sMsg := sub_49ADB8(sMsg, '<$CLIENTDOWNLOAD>', g_Config.sClientDownload);
      Exit;
    end;
    if sVariable = '$QQ' then begin
      sMsg := sub_49ADB8(sMsg, '<$QQ>', g_Config.sQQ);
      Exit;
    end;
    if sVariable = '$PHONE' then begin
      sMsg := sub_49ADB8(sMsg, '<$PHONE>', g_Config.sPhone);
      Exit;
    end;
    if sVariable = '$BANKACCOUNT0' then begin
      sMsg := sub_49ADB8(sMsg, '<$BANKACCOUNT0>', g_Config.sBankAccount0);
      Exit;
    end;
    if sVariable = '$BANKACCOUNT1' then begin
      sMsg := sub_49ADB8(sMsg, '<$BANKACCOUNT1>', g_Config.sBankAccount1);
      Exit;
    end;
    if sVariable = '$BANKACCOUNT2' then begin
      sMsg := sub_49ADB8(sMsg, '<$BANKACCOUNT2>', g_Config.sBankAccount2);
      Exit;
    end;
    if sVariable = '$BANKACCOUNT3' then begin
      sMsg := sub_49ADB8(sMsg, '<$BANKACCOUNT3>', g_Config.sBankAccount3);
      Exit;
    end;
    if sVariable = '$BANKACCOUNT4' then begin
      sMsg := sub_49ADB8(sMsg, '<$BANKACCOUNT4>', g_Config.sBankAccount4);
      Exit;
    end;
    if sVariable = '$BANKACCOUNT5' then begin
      sMsg := sub_49ADB8(sMsg, '<$BANKACCOUNT5>', g_Config.sBankAccount5);
      Exit;
    end;
    if sVariable = '$BANKACCOUNT6' then begin
      sMsg := sub_49ADB8(sMsg, '<$BANKACCOUNT6>', g_Config.sBankAccount6);
      Exit;
    end;
    if sVariable = '$BANKACCOUNT7' then begin
      sMsg := sub_49ADB8(sMsg, '<$BANKACCOUNT7>', g_Config.sBankAccount7);
      Exit;
    end;
    if sVariable = '$BANKACCOUNT8' then begin
      sMsg := sub_49ADB8(sMsg, '<$BANKACCOUNT8>', g_Config.sBankAccount8);
      Exit;
    end;
    if sVariable = '$BANKACCOUNT9' then begin
      sMsg := sub_49ADB8(sMsg, '<$BANKACCOUNT9>', g_Config.sBankAccount9);
      Exit;
    end;
    if sVariable = '$GAMEGOLDNAME' then begin
      sMsg := sub_49ADB8(sMsg, '<$GAMEGOLDNAME>', g_Config.sGameGoldName);
      Exit;
    end;
    if sVariable = '$GAMEDIAMONDNAME' then begin  //20071227 金刚石
      sMsg := sub_49ADB8(sMsg, '<$GAMEDIAMONDNAME>', g_Config.sGameDiaMond);
      Exit;
    end;
    if sVariable = '$GAMEGIRDNAME' then begin  //20071227 灵符
      sMsg := sub_49ADB8(sMsg, '<$GAMEGIRDNAME>', g_Config.sGameGird);
      Exit;
    end;
    if sVariable = '$GAMEPOINTNAME' then begin
      sMsg := sub_49ADB8(sMsg, '<$GAMEPOINTNAME>', g_Config.sGamePointName);
      Exit;
    end;
    if sVariable = '$USERCOUNT' then begin
      sText := IntToStr(UserEngine.PlayObjectCount);
      sMsg := sub_49ADB8(sMsg, '<$USERCOUNT>', sText);
      Exit;
    end;
    if sVariable = '$MACRUNTIME' then begin//程序运行时长
      sText := CurrToStr(GetTickCount / 86400000{(24 * 60 * 60 * 1000)});
      sMsg := sub_49ADB8(sMsg, '<$MACRUNTIME>', sText);
      Exit;
    end;
    if sVariable = '$SERVERRUNTIME' then begin
      nSecond := (GetTickCount() - g_dwStartTick) div 1000;
      wHour := nSecond div 3600;
      wMinute := (nSecond div 60) mod 60;
      wSecond := nSecond mod 60;
      sText := Format('%d:%d:%d', [wHour, wMinute, wSecond]);
      sMsg := sub_49ADB8(sMsg, '<$SERVERRUNTIME>', sText);
      Exit;
    end;
    if sVariable = '$DATETIME' then begin
      sText := FormatDateTime('dddddd,ddd,hh:mm:ss', Now);//20090514 修改
      sMsg := sub_49ADB8(sMsg, '<$DATETIME>', sText);
      Exit;
    end;
    if sVariable = '$DATE' then begin//20091126 增加
      sText := FormatDateTime('mm月dd日', Now);
      sMsg := sub_49ADB8(sMsg, '<$DATE>', sText);
      Exit;
    end;
    if sVariable = '$HIGHLEVELINFO' then begin //最高等级人物数据
      if TPlayObject(g_HighLevelHuman) <> nil then begin
        sText := TPlayObject(g_HighLevelHuman).GetMyInfo;
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HIGHLEVELINFO>', sText);
      Exit;
    end;
    if sVariable = '$HIGHPKINFO' then begin //最高PK值人物数据
      if TPlayObject(g_HighPKPointHuman) <> nil then begin
        sText := TPlayObject(g_HighPKPointHuman).GetMyInfo;
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HIGHPKINFO>', sText);
      Exit;
    end;
    if sVariable = '$HIGHDCINFO' then begin //最高攻击力人物数据
      if TPlayObject(g_HighDCHuman) <> nil then begin
        sText := TPlayObject(g_HighDCHuman).GetMyInfo;
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HIGHDCINFO>', sText);
      Exit;
    end;
    if sVariable = '$HIGHMCINFO' then begin //最高魔法力人物数据
      if TPlayObject(g_HighMCHuman) <> nil then begin
        sText := TPlayObject(g_HighMCHuman).GetMyInfo;
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HIGHMCINFO>', sText);
      Exit;
    end;
    if sVariable = '$HIGHSCINFO' then begin  //最高道术人物数据
      if TPlayObject(g_HighSCHuman) <> nil then begin
        sText := TPlayObject(g_HighSCHuman).GetMyInfo;
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HIGHSCINFO>', sText);
      Exit;
    end;
    if sVariable = '$HIGHONLINEINFO' then begin//最高在线时长人物数据
      if TPlayObject(g_HighOnlineHuman) <> nil then begin
        sText := TPlayObject(g_HighOnlineHuman).GetMyInfo;
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HIGHONLINEINFO>', sText);
      Exit;
    end;

    //个人信息
    if sVariable = '$USERNAME' then begin
      sMsg := sub_49ADB8(sMsg, '<$USERNAME>', PlayObject.m_sCharName);
      Exit;
    end;
    {$IF M2Version <> 2}
    if sVariable = '$SETFENGHAOHUM' then begin//任命称号人名
      sMsg := sub_49ADB8(sMsg, '<$SETFENGHAOHUM>', PlayObject.m_sFenghaoName);
      Exit;
    end;
    if sVariable = '$DIVISIONNAME' then begin//师门名称
      if PlayObject.m_MyDivision <> nil then begin
        sMsg := sub_49ADB8(sMsg, '<$DIVISIONNAME>', TDivision(PlayObject.m_MyDivision).sDivisionName);

      end;
      Exit;
    end;

    //Add By TasNat at: 2012-04-23 17:16:11
    if sVariable = '$DIVISIONPOPULARITY' then begin//师门人气值
      if PlayObject.m_MyDivision <> nil then begin
        sMsg := sub_49ADB8(sMsg, '<$DIVISIONPOPULARITY>', InttoStr(TDivision(PlayObject.m_MyDivision).nPopularity));
      end else begin
        sMsg := '';
      end;
      Exit;
    end;
    if sVariable = '$DIVISIONHEARTLEVEL' then begin//师门人气值
      if PlayObject.m_MyDivision <> nil then begin
        sMsg := sub_49ADB8(sMsg, '<$DIVISIONHEARTLEVEL>', InttoStr(TDivision(PlayObject.m_MyDivision).nHeartLevel));
      end else begin
        sMsg := '';
      end;
      Exit;
    end;
    //Add By TasNat at: 2012-04-23 17:16:11

    if sVariable = '$HEARTNAME' then begin//心法名称
      if PlayObject.m_sHeartName <> '' then begin
        sMsg := sub_49ADB8(sMsg, '<$HEARTNAME>', PlayObject.m_sHeartName);
      end else begin
        sMsg := '';
      end;
      Exit;
    end;
    {$IFEND}
    if sVariable = '$USERALLNAME' then begin//全名 20080419
      sMsg := sub_49ADB8(sMsg, '<$USERALLNAME>', PlayObject.GetShowName);
      Exit;
    end;
    if sVariable = '$DEARNAME' then begin//配偶名
      sMsg := sub_49ADB8(sMsg, '<$DEARNAME>', PlayObject.m_sDearName);
      Exit;
    end;
    if sVariable = '$SFNAME' then begin//师傅名 20080603
      sMsg := sub_49ADB8(sMsg, '<$SFNAME>', PlayObject.m_sMasterName);
      Exit;
    end;
    if sVariable = '$TDNAME1' then begin//大徒弟
      sMsg := sub_49ADB8(sMsg, '<$TDNAME1>', PlayObject.GetApprenticeName(1));
      Exit;
    end;
    if sVariable = '$TDNAME2' then begin//二徒弟
      sMsg := sub_49ADB8(sMsg, '<$TDNAME2>', PlayObject.GetApprenticeName(2));
      Exit;
    end;
    if sVariable = '$TDNAME3' then begin//三徒弟
      sMsg := sub_49ADB8(sMsg, '<$TDNAME3>', PlayObject.GetApprenticeName(3));
      Exit;
    end;
    if sVariable = '$TDNAME4' then begin//四徒弟
      sMsg := sub_49ADB8(sMsg, '<$TDNAME4>', PlayObject.GetApprenticeName(4));
      Exit;
    end;
    if sVariable = '$TDNAME5' then begin//五徒弟
      sMsg := sub_49ADB8(sMsg, '<$TDNAME5>', PlayObject.GetApprenticeName(5));
      Exit;
    end;
    if sVariable = '$MAPNAME' then begin//地图名称
      sMsg := sub_49ADB8(sMsg, '<$MAPNAME>', PlayObject.m_PEnvir.sMapDesc);
      Exit;
    end;
    {if sVariable = '$PETSER' then begin//攻击宠物变量(临时) 20110616
      if (PlayObject.m_btRaceServer = RC_PLAYOBJECT) and (PlayObject.m_TargetCret <> nil) then begin
        if (PlayObject.m_TargetCret.m_btRaceServer = 158) then begin
          sMsg := sub_49ADB8(sMsg, '<$PETSER>', TPetsMon(PlayObject.m_TargetCret).m_sMasterName);
        end;
      end else sMsg := sub_49ADB8(sMsg, '<$PETSER>', '');
    end;}
    if sVariable = '$KILLER' then begin//杀人者变量 20080826
      if PlayObject.m_boDeath and (PlayObject.m_LastHiter <> nil) then begin
        if (PlayObject.m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) then begin
          sMsg := sub_49ADB8(sMsg, '<$KILLER>', PlayObject.m_LastHiter.m_sCharName);
        end else
        if (PlayObject.m_LastHiter.m_btRaceServer = RC_HEROOBJECT) or
          (PlayObject.m_LastHiter.m_btRaceServer = 156) then begin
          if PlayObject.m_LastHiter.m_Master <> nil then
            sMsg := sub_49ADB8(sMsg, '<$KILLER>', PlayObject.m_LastHiter.m_Master.m_sCharName)
          else sMsg := sub_49ADB8(sMsg, '<$KILLER>', '未知');
        end;
      end else sMsg := sub_49ADB8(sMsg, '<$KILLER>', '未知');
      Exit;
    end;
    if sVariable = '$MONKILLER' then begin//杀人的怪物变量 20080826
      if PlayObject.m_boDeath and (PlayObject.m_LastHiter <> nil) then begin
        if (PlayObject.m_LastHiter.m_btRaceServer <> RC_PLAYOBJECT) and (PlayObject.m_LastHiter.m_btRaceServer <> RC_HEROOBJECT) then begin
          sMsg := sub_49ADB8(sMsg, '<$MONKILLER>', PlayObject.m_LastHiter.m_sCharName);
        end;
      end else sMsg := sub_49ADB8(sMsg, '<$MONKILLER>', '未知');
      Exit;
    end;
    if sVariable = '$MAP' then begin//20080123 增加地图ID参数
      if PlayObject.m_PEnvir <> nil then begin
        sMsg := sub_49ADB8(sMsg, '<$MAP>', PlayObject.m_PEnvir.sMapName);
      end else sMsg := sub_49ADB8(sMsg, '<$MAP>', '????');
      Exit;
    end;
    if sVariable = '$QUERYYBDEALLOG' then begin//查看元宝交易记录  20080318
      sMsg := sub_49ADB8(sMsg, '<$QUERYYBDEALLOG>', PlayObject.SelectSellDate());
      Exit;
    end;
    if sVariable = '$GUILDNAME' then begin
      if PlayObject.m_MyGuild <> nil then begin
        sMsg := sub_49ADB8(sMsg, '<$GUILDNAME>', TGUild(PlayObject.m_MyGuild).sGuildName);
      end else begin
        sMsg := '';
      end;
      Exit;
    end;

    if sVariable = '$TAGMAPNAME1' then begin//记路标石记录地图名 20081019
      sMsg := sub_49ADB8(sMsg, '<$TAGMAPNAME1>', PlayObject.m_TagMapInfos[1].TagMapName);
      Exit;
    end;
    if sVariable = '$TAGMAPNAME2' then begin
      sMsg := sub_49ADB8(sMsg, '<$TAGMAPNAME2>', PlayObject.m_TagMapInfos[2].TagMapName);
      Exit;
    end;
    if sVariable = '$TAGMAPNAME3' then begin
      sMsg := sub_49ADB8(sMsg, '<$TAGMAPNAME3>', PlayObject.m_TagMapInfos[3].TagMapName);
      Exit;
    end;
    if sVariable = '$TAGMAPNAME4' then begin
      sMsg := sub_49ADB8(sMsg, '<$TAGMAPNAME4>', PlayObject.m_TagMapInfos[4].TagMapName);
      Exit;
    end;
    if sVariable = '$TAGMAPNAME5' then begin
      sMsg := sub_49ADB8(sMsg, '<$TAGMAPNAME5>', PlayObject.m_TagMapInfos[5].TagMapName);
      Exit;
    end;
    if sVariable = '$TAGMAPNAME6' then begin
      sMsg := sub_49ADB8(sMsg, '<$TAGMAPNAME6>', PlayObject.m_TagMapInfos[6].TagMapName);
      Exit;
    end;

    if sVariable = '$TAGX1' then begin//记路标石记录X 20081019
      sText := IntToStr(PlayObject.m_TagMapInfos[1].TagX);
      sMsg := sub_49ADB8(sMsg, '<$TAGX1>',sText);
      Exit;
    end;
    if sVariable = '$TAGX2' then begin
      sText := IntToStr(PlayObject.m_TagMapInfos[2].TagX);
      sMsg := sub_49ADB8(sMsg, '<$TAGX2>',sText);
      Exit;
    end;
    if sVariable = '$TAGX3' then begin
      sText := IntToStr(PlayObject.m_TagMapInfos[3].TagX);
      sMsg := sub_49ADB8(sMsg, '<$TAGX3>',sText);
      Exit;
    end;
    if sVariable = '$TAGX4' then begin
      sText := IntToStr(PlayObject.m_TagMapInfos[4].TagX);
      sMsg := sub_49ADB8(sMsg, '<$TAGX4>',sText);
      Exit;
    end;
    if sVariable = '$TAGX5' then begin
      sText := IntToStr(PlayObject.m_TagMapInfos[5].TagX);
      sMsg := sub_49ADB8(sMsg, '<$TAGX5>',sText);
      Exit;
    end;
    if sVariable = '$TAGX6' then begin
      sText := IntToStr(PlayObject.m_TagMapInfos[6].TagX);
      sMsg := sub_49ADB8(sMsg, '<$TAGX6>',sText);
      Exit;
    end;

    if sVariable = '$TAGY1' then begin//记路标石记录Y 20081019
      sText := IntToStr(PlayObject.m_TagMapInfos[1].TagY);
      sMsg := sub_49ADB8(sMsg, '<$TAGY1>',sText);
      Exit;
    end;
    if sVariable = '$TAGY2' then begin
      sText := IntToStr(PlayObject.m_TagMapInfos[2].TagY);
      sMsg := sub_49ADB8(sMsg, '<$TAGY2>',sText);
      Exit;
    end;
    if sVariable = '$TAGY3' then begin
      sText := IntToStr(PlayObject.m_TagMapInfos[3].TagY);
      sMsg := sub_49ADB8(sMsg, '<$TAGY3>',sText);
      Exit;
    end;
    if sVariable = '$TAGY4' then begin
      sText := IntToStr(PlayObject.m_TagMapInfos[4].TagY);
      sMsg := sub_49ADB8(sMsg, '<$TAGY4>',sText);
      Exit;
    end;
    if sVariable = '$TAGY5' then begin
      sText := IntToStr(PlayObject.m_TagMapInfos[5].TagY);
      sMsg := sub_49ADB8(sMsg, '<$TAGY5>',sText);
      Exit;
    end;
    if sVariable = '$TAGY6' then begin
      sText := IntToStr(PlayObject.m_TagMapInfos[6].TagY);
      sMsg := sub_49ADB8(sMsg, '<$TAGY6>',sText);
      Exit;
    end;

    if sVariable = '$GUILDMEMBERCOUNT' then begin//行会成员上限 20090115
      if PlayObject.m_MyGuild <> nil then begin
        sText := IntToStr(TGUild(PlayObject.m_MyGuild).m_nGuildMemberCount);
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$GUILDMEMBERCOUNT>', sText);
      Exit;
    end;
    if sVariable = '$GUILDFOUNTAIN' then begin//行会泉水仓库 20080625
      if PlayObject.m_MyGuild <> nil then begin
        sText := IntToStr(TGUild(PlayObject.m_MyGuild).m_nGuildFountain);
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$GUILDFOUNTAIN>', sText);
      Exit;
    end;
    if sVariable = '$GUILDSTARDATE' then begin//授给行会之星的操作日期
      if PlayObject.m_MyGuild <> nil then begin
        sText := DateTimeToStr(TGUild(PlayObject.m_MyGuild).m_GuildStarDate);
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$GUILDSTARDATE>', sText);
      Exit;
    end;
    if sVariable = '$ALCOHOL' then begin//酒量 20080627
      sText := IntToStr(PlayObject.m_Abil.MaxAlcohol);
      sMsg := sub_49ADB8(sMsg, '<$ALCOHOL>', sText);
      Exit;
    end;
    if sVariable = '$MEDICINEVALUE' then begin//药力值 20080627
      sText := IntToStr(PlayObject.m_Abil.MedicineValue);
      sMsg := sub_49ADB8(sMsg, '<$MEDICINEVALUE>', sText);
      Exit;
    end;
    if sVariable = '$RANKNAME' then begin//行会职位名称
      sMsg := sub_49ADB8(sMsg, '<$RANKNAME>', PlayObject.m_sGuildRankName);
      Exit;
    end;
    {$IF M2Version <> 2}
    if sVariable = '$NGLEVEL' then begin//人物内功等级
      sText := IntToStr(PlayObject.m_NGLevel);
      sMsg := sub_49ADB8(sMsg, '<$NGLEVEL>', sText);
      Exit;
    end;
    if sVariable = '$HEARTLEVEL' then begin//心法等级
      if PlayObject.m_MagicSkill_105 <> nil then begin
        sText := IntToStr(PlayObject.m_MagicSkill_105.btLevel);
      end else
      if PlayObject.m_MagicSkill_106 <> nil then begin
        sText := IntToStr(PlayObject.m_MagicSkill_106.btLevel);
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HEARTLEVEL>', sText);
      Exit;
    end;
    {$IFEND}
    if sVariable = '$LEVEL' then begin
      sText := IntToStr(PlayObject.m_Abil.Level);
      sMsg := sub_49ADB8(sMsg, '<$LEVEL>', sText);
      Exit;
    end;
    if sVariable = '$USEGAMEGIRD' then begin//每次使用灵符数，$USEGAMEGIRD变量使用 20090108
      sText := IntToStr(PlayObject.m_UseGameGird);
      sMsg := sub_49ADB8(sMsg, '<$USEGAMEGIRD>', sText);
      Exit;
    end;
    if sVariable = '$BUYSHOP' then begin//每次商铺花的元宝数量 20090106
      sText := IntToStr(PlayObject.m_BuyShopPrice);
      sMsg := sub_49ADB8(sMsg, '<$BUYSHOP>', sText);
      Exit;
    end;
    if sVariable = '$GETCRYSTALEXP' then begin//天地结晶可提取的经验 20090202
      sText := IntToStr(PlayObject.m_nGetCrystalExp);
      sMsg := sub_49ADB8(sMsg, '<$GETCRYSTALEXP>', sText);
      Exit;
    end;
    if sVariable = '$GETCRYSTALNGEXP' then begin//天地结晶可提取的内功经验 20090202
      sText := IntToStr(PlayObject.m_nGetCrystalNGExp);
      sMsg := sub_49ADB8(sMsg, '<$GETCRYSTALNGEXP>', sText);
      Exit;
    end;
    if sVariable = '$CRYSTALEXP' then begin//天地结晶当前的经验 20090202
      sText := IntToStr(PlayObject.m_CrystalExp);
      sMsg := sub_49ADB8(sMsg, '<$CRYSTALEXP>', sText);
      Exit;
    end;
    if sVariable = '$CRYSTALNGEXP' then begin//天地结晶当前的内功经验 20090202
      sText := IntToStr(PlayObject.m_CrystalNGExp);
      sMsg := sub_49ADB8(sMsg, '<$CRYSTALNGEXP>', sText);
      Exit;
    end;
    if sVariable = '$CRYSTALLEVEL' then begin//天地结晶等级 20090202
      {$IF M2Version = 1}
      if g_Config.boAssignmentCryst then begin
        case PlayObject.m_CrystalLevel of
          1: sText := IntToStr(g_Config.nCRYSTALLEVEL1);
          2: sText := IntToStr(g_Config.nCRYSTALLEVEL2);
          3: sText := IntToStr(g_Config.nCRYSTALLEVEL3);
          4, 5: sText := IntToStr(g_Config.nCRYSTALLEVEL4);//20110722 修改
        end;
      end else sText := IntToStr(_MIN(5,PlayObject.m_CrystalLevel));
      {$ELSE}
      sText := IntToStr(_MIN( 5,PlayObject.m_CrystalLevel));
      {$IFEND}
      sMsg := sub_49ADB8(sMsg, '<$CRYSTALLEVEL>', sText);
      Exit;
    end;
    if sVariable = '$GETEXP' then begin//人物取得的经验 20081228
      sText := IntToStr(PlayObject.m_GetExp);
      sMsg := sub_49ADB8(sMsg, '<$GETEXP>', sText);
      Exit;
    end;
    {$IF HEROVERSION = 1}
    if sVariable = '$HEROLEVEL' then begin//英雄等级 20090708
      if PlayObject.m_MyHero <> nil then begin
        sText := IntToStr(PlayObject.m_MyHero.m_Abil.Level);
        sMsg := sub_49ADB8(sMsg, '<$HEROLEVEL>', sText);
        Exit;
      end;
    end;
    if sVariable = '$HERONAME' then begin//英雄名称 200990708
      if PlayObject.m_MyHero <> nil then begin
        sMsg := sub_49ADB8(sMsg, '<$HERONAME>', PlayObject.m_MyHero.m_sCharName);
      end else begin
        sMsg := '????';
      end;
      Exit;
    end;
    if sVariable = '$HERONGLEVEL' then begin//英雄内功等级
      if PlayObject.m_MyHero <> nil then begin
        sText := IntToStr(THeroObject(PlayObject.m_MyHero).m_NGLevel);
      end else sText:= '????';
      sMsg := sub_49ADB8(sMsg, '<$HERONGLEVEL>', sText);
      Exit;
    end;
    if sVariable = '$HEROGETEXP' then begin//英雄取得的经验 20081228
      if PlayObject.m_MyHero <> nil then begin
        sText := IntToStr(THeroObject(PlayObject.m_MyHero).m_GetExp);
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HEROGETEXP>', sText);
      Exit;
    end;
    if sVariable = '$HERODRESS' then begin
      if PlayObject.m_MyHero <> nil then begin
        sText := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_DRESS].wIndex);
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HERODRESS>', sText);
      Exit;
    end else
    if sVariable = '$HEROWEAPON' then begin
      if PlayObject.m_MyHero <> nil then begin
        sText := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_WEAPON].wIndex);
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HEROWEAPON>', sText);
      Exit;
    end else
    if sVariable = '$HERORIGHTHAND' then begin
      if PlayObject.m_MyHero <> nil then begin
        sText := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_RIGHTHAND].wIndex);
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HERORIGHTHAND>', sText);
      Exit;
    end else
    if sVariable = '$HEROHELMET' then begin
      if PlayObject.m_MyHero <> nil then begin
        sText := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_HELMET].wIndex);
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HEROHELMET>', sText);
      Exit;
    end else
    if sVariable = '$HEROZHULI' then begin //斗笠
      if PlayObject.m_MyHero <> nil then begin
        sText := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_ZHULI].wIndex);
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HEROZHULI>', sText);
      Exit;
    end else
    if sVariable = '$HERONECKLACE' then begin
      if PlayObject.m_MyHero <> nil then begin
        sText := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_NECKLACE].wIndex);
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HERONECKLACE>', sText);
      Exit;
    end else
    if sVariable = '$HERORING_R' then begin
      if PlayObject.m_MyHero <> nil then begin
        sText := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_RINGR].wIndex);
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HERORING_R>', sText);
      Exit;
    end else
    if sVariable = '$HERORING_L' then begin
      if PlayObject.m_MyHero <> nil then begin
        sText := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_RINGL].wIndex);
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HERORING_L>', sText);
      Exit;
    end else
    if sVariable = '$HEROARMRING_R' then begin
      if PlayObject.m_MyHero <> nil then begin
        sText := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_ARMRINGR].wIndex);
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HEROARMRING_R>', sText);
      Exit;
    end else
    if sVariable = '$HEROARMRING_L' then begin
      if PlayObject.m_MyHero <> nil then begin
        sText := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_ARMRINGL].wIndex);
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HEROARMRING_L>', sText);
      Exit;
    end else
    if sVariable = '$HEROBUJUK' then begin
      if PlayObject.m_MyHero <> nil then begin
        sText := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_BUJUK].wIndex);
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HEROBUJUK>', sText);
      Exit;
    end else
    if sVariable = '$HEROBELT' then begin
      if PlayObject.m_MyHero <> nil then begin
        sText := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_BELT].wIndex);
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HEROBELT>', sText);
      Exit;
    end else
    if sVariable = '$HEROBOOTS' then begin
      if PlayObject.m_MyHero <> nil then begin
        sText := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_BOOTS].wIndex);
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HEROBOOTS>', sText);
      Exit;
    end else
    if sVariable = '$HERODRUM' then begin
      if PlayObject.m_MyHero <> nil then begin
        sText := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_DRUM].wIndex);
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HERODRUM>', sText);
      Exit;
    end else
    if sVariable = '$HEROCHARM' then begin
      if PlayObject.m_MyHero <> nil then begin
        sText := UserEngine.GetStdItemName(PlayObject.m_MyHero.m_UseItems[U_CHARM].wIndex);
      end else sText := '????';
      sMsg := sub_49ADB8(sMsg, '<$HEROCHARM>', sText);
      Exit;
    end;
    {$IFEND}
    if sVariable = '$GLORYPOINT' then begin//人物荣誉值  20080512
      sText := IntToStr(PlayObject.m_btGameGlory);
      sMsg := sub_49ADB8(sMsg, '<$GLORYPOINT>', sText);
      Exit;
    end;
    if sVariable = '$STATSERVERTIME' then begin //显示M2启动时间
      sText := FrmMain.LbRunTime.Caption;
      sMsg := sub_49ADB8(sMsg, '<$STATSERVERTIME>', sText);
      Exit;
    end;
    if sVariable = '$RUNDATETIME' then begin //开区间隔时间
      sText := FrmMain.LbTimeCount.Caption;
      sMsg := sub_49ADB8(sMsg, '<$RUNDATETIME>', sText);
      Exit;
    end;
    if sVariable = '$RANDOMNO' then begin //随机值变量
      sText := IntToStr(Random(High(Integer)));
      sMsg := sub_49ADB8(sMsg, '<$RANDOMNO>', sText);
      Exit;
    end;
    if sVariable = '$USERID' then begin //登录账号
      sText := PlayObject.m_sUserID;
      sMsg := sub_49ADB8(sMsg, '<$USERID>', sText);
      Exit;
    end;
    if sVariable = '$REFINEARMYDRUMITEM' then begin //合成输出物品名
      sText := PlayObject.m_sTmpStr;
      sMsg := sub_49ADB8(sMsg, '<$REFINEARMYDRUMITEM>', sText);
      Exit;
    end;
    if sVariable = '$IPADDR' then begin //登录IP
      sText := PlayObject.m_sIPaddr;
      sMsg := sub_49ADB8(sMsg, '<$IPADDR>', sText);
      Exit;
    end;
    if sVariable = '$MACHINEID' then begin
      sText := '$' + IntToHex(PlayObject.m_dwHCode, 8);
      sMsg := sub_49ADB8(sMsg, '$MACHINEID', sText);
      Exit;
    end;
    if sVariable = '$PETSNAME' then begin //宠物名
      sText := PlayObject.m_sPetsMonName;
      sMsg := sub_49ADB8(sMsg, '<$PETSNAME>', sText);
      Exit;
    end;
    if sVariable = '$HEROAUTOTIME' then begin//副将自我修炼时长
      sText := IntToStr(PlayObject.m_HeroAutoPracticeTime);
      sMsg := sub_49ADB8(sMsg, '<$HEROAUTOTIME>', sText);
      Exit;
    end;
    if sVariable = '$PETSHAPP' then begin//人物宠物快乐度
      sText := IntToStr(PlayObject.m_nPetsMonHappiness);
      sMsg := sub_49ADB8(sMsg, '<$PETSHAPP>', sText);
      Exit;
    end;
    if sVariable = '$X' then begin//人物X坐标
      sText := IntToStr(PlayObject.m_nCurrX);
      sMsg := sub_49ADB8(sMsg, '<$X>', sText);
      Exit;
    end;
    if sVariable = '$Y' then begin//人物Y坐标
      sText := IntToStr(PlayObject.m_nCurrY);
      sMsg := sub_49ADB8(sMsg, '<$Y>', sText);
      Exit;
    end;
    if sVariable = '$HP' then begin
      sText := IntToStr(PlayObject.m_WAbil.HP);
      sMsg := sub_49ADB8(sMsg, '<$HP>', sText);
      Exit;
    end;
    if sVariable = '$MAXHP' then begin
      sText := IntToStr(PlayObject.m_WAbil.MaxHP);
      sMsg := sub_49ADB8(sMsg, '<$MAXHP>', sText);
      Exit;
    end;

    if sVariable = '$MP' then begin
      sText := IntToStr(PlayObject.m_WAbil.MP);
      sMsg := sub_49ADB8(sMsg, '<$MP>', sText);
      Exit;
    end;
    if sVariable = '$MAXMP' then begin
      sText := IntToStr(PlayObject.m_WAbil.MaxMP);
      sMsg := sub_49ADB8(sMsg, '<$MAXMP>', sText);
      Exit;
    end;

    if sVariable = '$AC' then begin
      sText := IntToStr(LoWord(PlayObject.m_WAbil.AC));
      sMsg := sub_49ADB8(sMsg, '<$AC>', sText);
      Exit;
    end;
    if sVariable = '$MAXAC' then begin
      sText := IntToStr(HiWord(PlayObject.m_WAbil.AC));
      sMsg := sub_49ADB8(sMsg, '<$MAXAC>', sText);
      Exit;
    end;
    if sVariable = '$MAC' then begin
      sText := IntToStr(LoWord(PlayObject.m_WAbil.MAC));
      sMsg := sub_49ADB8(sMsg, '<$MAC>', sText);
      Exit;
    end;
    if sVariable = '$MAXMAC' then begin
      sText := IntToStr(HiWord(PlayObject.m_WAbil.MAC));
      sMsg := sub_49ADB8(sMsg, '<$MAXMAC>', sText);
      Exit;
    end;

    if sVariable = '$DC' then begin
      sText := IntToStr(LoWord(PlayObject.m_WAbil.DC));
      sMsg := sub_49ADB8(sMsg, '<$DC>', sText);
      Exit;
    end;
    if sVariable = '$MAXDC' then begin
      sText := IntToStr(HiWord(PlayObject.m_WAbil.DC));
      sMsg := sub_49ADB8(sMsg, '<$MAXDC>', sText);
      Exit;
    end;

    if sVariable = '$MC' then begin
      sText := IntToStr(LoWord(PlayObject.m_WAbil.MC));
      sMsg := sub_49ADB8(sMsg, '<$MC>', sText);
      Exit;
    end;
    if sVariable = '$MAXMC' then begin
      sText := IntToStr(HiWord(PlayObject.m_WAbil.MC));
      sMsg := sub_49ADB8(sMsg, '<$MAXMC>', sText);
      Exit;
    end;

    if sVariable = '$SC' then begin
      sText := IntToStr(LoWord(PlayObject.m_WAbil.SC));
      sMsg := sub_49ADB8(sMsg, '<$SC>', sText);
      Exit;
    end;
    if sVariable = '$MAXSC' then begin
      sText := IntToStr(HiWord(PlayObject.m_WAbil.SC));
      sMsg := sub_49ADB8(sMsg, '<$MAXSC>', sText);
      Exit;
    end;

    if sVariable = '$EXP' then begin
      sText := IntToStr(PlayObject.m_Abil.nExp);
      sMsg := sub_49ADB8(sMsg, '<$EXP>', sText);
      Exit;
    end;
    if sVariable = '$MAXEXP' then begin
      sText := IntToStr(PlayObject.m_Abil.nMaxExp);
      sMsg := sub_49ADB8(sMsg, '<$MAXEXP>', sText);
      Exit;
    end;

    if sVariable = '$PKPOINT' then begin
      sText := IntToStr(PlayObject.m_nPkPoint);
      sMsg := sub_49ADB8(sMsg, '<$PKPOINT>', sText);
      Exit;
    end;
    if sVariable = '$CREDITPOINT' then begin
      sText := IntToStr(PlayObject.m_btCreditPoint);
      sMsg := sub_49ADB8(sMsg, '<$CREDITPOINT>', sText);
      Exit;
    end;

    if sVariable = '$HW' then begin
      sText := IntToStr(PlayObject.m_WAbil.HandWeight);
      sMsg := sub_49ADB8(sMsg, '<$HW>', sText);
      Exit;
    end;
    if sVariable = '$MAXHW' then begin
      sText := IntToStr(PlayObject.m_WAbil.MaxHandWeight);
      sMsg := sub_49ADB8(sMsg, '<$MAXHW>', sText);
      Exit;
    end;

    if sVariable = '$BW' then begin
      sText := IntToStr(PlayObject.m_WAbil.Weight);
      sMsg := sub_49ADB8(sMsg, '<$BW>', sText);
      Exit;
    end;
    if sVariable = '$MAXBW' then begin
      sText := IntToStr(PlayObject.m_WAbil.MaxWeight);
      sMsg := sub_49ADB8(sMsg, '<$MAXBW>', sText);
      Exit;
    end;

    if sVariable = '$WW' then begin
      sText := IntToStr(PlayObject.m_WAbil.WearWeight);
      sMsg := sub_49ADB8(sMsg, '<$WW>', sText);
      Exit;
    end;
    if sVariable = '$MAXWW' then begin
      sText := IntToStr(PlayObject.m_WAbil.MaxWearWeight);
      sMsg := sub_49ADB8(sMsg, '<$MAXWW>', sText);
      Exit;
    end;

    if sVariable = '$GOLDCOUNT' then begin
      sText := IntToStr(PlayObject.m_nGold) + '/' + IntToStr(PlayObject.m_nGoldMax);
      sMsg := sub_49ADB8(sMsg, '<$GOLDCOUNT>', sText);
      Exit;
    end;
    if sVariable = '$GAMEGOLD' then begin
      sText := IntToStr(PlayObject.m_nGameGold);
      sMsg := sub_49ADB8(sMsg, '<$GAMEGOLD>', sText);
      Exit;
    end;
    if sVariable = '$GAMEDIAMOND' then begin//20071227 金刚石 要注意大小写,不然客户端显示不出数据
      sText := IntToStr(PlayObject.m_nGAMEDIAMOND);
      sMsg := sub_49ADB8(sMsg, '<$GAMEDIAMOND>', sText);
      Exit;
    end;
    if sVariable = '$GAMEGIRD' then begin//20071227 灵符
      sText := IntToStr(PlayObject.m_nGameGird);
      sMsg := sub_49ADB8(sMsg, '<$GAMEGIRD>', sText);
      Exit;
    end;
    if sVariable = '$GAMEPOINT' then begin
      sText := IntToStr(PlayObject.m_nGamePoint);
      sMsg := sub_49ADB8(sMsg, '<$GAMEPOINT>', sText);
      Exit;
    end;
    if sVariable = '$HUNGER' then begin//饥饿程度
      sText := IntToStr(PlayObject.GetMyStatus);
      sMsg := sub_49ADB8(sMsg, '<$HUNGER>', sText);
      Exit;
    end;
    if sVariable = '$LOGINTIME' then begin//登录时间
      sText := DateTimeToStr(PlayObject.m_dLogonTime);
      sMsg := sub_49ADB8(sMsg, '<$LOGINTIME>', sText);
      Exit;
    end;
    if sVariable = '$LOGINLONG' then begin//登录时长
      sText := IntToStr((GetTickCount - PlayObject.m_dwLogonTick) div 60000) + '分钟';
      sMsg := sub_49ADB8(sMsg, '<$LOGINLONG>', sText);
      Exit;
    end;
    if sVariable = '$DRESS' then begin
      sText := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_DRESS].wIndex);
      sMsg := sub_49ADB8(sMsg, '<$DRESS>', sText);
      Exit;
    end else
      if sVariable = '$WEAPON' then begin
      sText := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_WEAPON].wIndex);
      sMsg := sub_49ADB8(sMsg, '<$WEAPON>', sText);
      Exit;
    end else
      if sVariable = '$RIGHTHAND' then begin
      sText := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_RIGHTHAND].wIndex);
      sMsg := sub_49ADB8(sMsg, '<$RIGHTHAND>', sText);
      Exit;
    end else
      if sVariable = '$HELMET' then begin
      sText := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_HELMET].wIndex);
      sMsg := sub_49ADB8(sMsg, '<$HELMET>', sText);
      Exit;
    end else
      if sVariable = '$ZHULI' then begin //斗笠
      sText := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_ZHULI].wIndex);
      sMsg := sub_49ADB8(sMsg, '<$ZHULI>', sText);
      Exit;
    end else
      if sVariable = '$NECKLACE' then begin
      sText := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_NECKLACE].wIndex);
      sMsg := sub_49ADB8(sMsg, '<$NECKLACE>', sText);
      Exit;
    end else
      if sVariable = '$RING_R' then begin
      sText := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_RINGR].wIndex);
      sMsg := sub_49ADB8(sMsg, '<$RING_R>', sText);
      Exit;
    end else
      if sVariable = '$RING_L' then begin
      sText := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_RINGL].wIndex);
      sMsg := sub_49ADB8(sMsg, '<$RING_L>', sText);
      Exit;
    end else
      if sVariable = '$ARMRING_R' then begin
      sText := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_ARMRINGR].wIndex);
      sMsg := sub_49ADB8(sMsg, '<$ARMRING_R>', sText);
      Exit;
    end else
      if sVariable = '$ARMRING_L' then begin
      sText := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_ARMRINGL].wIndex);
      sMsg := sub_49ADB8(sMsg, '<$ARMRING_L>', sText);
      Exit;
    end else
      if sVariable = '$BUJUK' then begin
      sText := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_BUJUK].wIndex);
      sMsg := sub_49ADB8(sMsg, '<$BUJUK>', sText);
      Exit;
    end else
      if sVariable = '$BELT' then begin
      sText := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_BELT].wIndex);
      sMsg := sub_49ADB8(sMsg, '<$BELT>', sText);
      Exit;
    end else
      if sVariable = '$BOOTS' then begin
      sText := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_BOOTS].wIndex);
      sMsg := sub_49ADB8(sMsg, '<$BOOTS>', sText);
      Exit;
    end else
      if sVariable = '$DRUM' then begin
      sText := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_DRUM].wIndex);
      sMsg := sub_49ADB8(sMsg, '<$DRUM>', sText);
      Exit;
    end else
      if sVariable = '$CHARM' then begin
      sText := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_CHARM].wIndex);
      sMsg := sub_49ADB8(sMsg, '<$CHARM>', sText);
      Exit;
    end else
      if sVariable = '$REFINEARMYDRUMITEM' then begin
      sText := PlayObject.m_sTmpStr;
      sMsg := sub_49ADB8(sMsg, '<$REFINEARMYDRUMITEM>', sText);
      Exit;
    end else
      if sVariable = '$IPADDR' then begin
      sText := PlayObject.m_sIPaddr;
      sMsg := sub_49ADB8(sMsg, '<$IPADDR>', sText);
      Exit;
    end else
      if sVariable = '$MACHINEID' then begin
      sText:= '$' + IntToHex(PlayObject.m_dwHCode, 8);
      sMsg := sub_49ADB8(sMsg, '$MACHINEID', sText);
      Exit;
    end else
      if sVariable = '$PETSNAME' then begin//宠物名
      sText := PlayObject.m_sPetsMonName;
      sMsg := sub_49ADB8(sMsg, '<$PETSNAME>', sText);
      Exit;
    end else
      if sVariable = '$REFINEOTHERITEM' then begin
      sText := PlayObject.m_sTmpStr;
      sMsg := sub_49ADB8(sMsg, '<$REFINEOTHERITEM>', sText);
      Exit;
    end else
      if sVariable = '$IPLOCAL' then begin
      sText := GetIPLocal(PlayObject.m_sIPaddr);
      sMsg := sub_49ADB8(sMsg, '<$IPLOCAL>', sText);
      Exit;
    end else
      if sVariable = '$GUILDBUILDPOINT' then begin//行会建筑度
      if PlayObject.m_MyGuild = nil then begin
        sText := '';
      end else begin
        sText := IntToStr(TGUild(PlayObject.m_MyGuild).nBuildPoint);
      end;
      sMsg := sub_49ADB8(sMsg, '<$GUILDBUILDPOINT>', sText);
      Exit;
    end else
      if sVariable = '$GUILDAURAEPOINT' then begin//行会人气度
      if PlayObject.m_MyGuild = nil then begin
        sText := '';
      end else begin
        sText := IntToStr(TGUild(PlayObject.m_MyGuild).nAurae);
      end;
      sMsg := sub_49ADB8(sMsg, '<$GUILDAURAEPOINT>', sText);
      Exit;
    end else
      if sVariable = '$GUILDSTABILITYPOINT' then begin
      if PlayObject.m_MyGuild = nil then begin
        sText := '';
      end else begin
        sText := IntToStr(TGUild(PlayObject.m_MyGuild).nStability);
      end;
      sMsg := sub_49ADB8(sMsg, '<$GUILDSTABILITYPOINT>', sText);
      Exit;
    end;
    if sVariable = '$GUILDFLOURISHPOINT' then begin
      if PlayObject.m_MyGuild = nil then begin
        sText := '';
      end else begin
        sText := IntToStr(TGUild(PlayObject.m_MyGuild).nFlourishing);
      end;
      sMsg := sub_49ADB8(sMsg, '<$GUILDFLOURISHPOINT>', sText);
      Exit;
    end;

    //其它信息
    if sVariable = '$REQUESTCASTLEWARITEM' then begin
      sText := g_Config.sZumaPiece;
      sMsg := sub_49ADB8(sMsg, '<$REQUESTCASTLEWARITEM>', sText);
      Exit;
    end;
    if sVariable = '$REQUESTCASTLEWARDAY' then begin
      sText := g_Config.sZumaPiece;
      sMsg := sub_49ADB8(sMsg, '<$REQUESTCASTLEWARDAY>', sText);
      Exit;
    end;
    if sVariable = '$REQUESTBUILDGUILDITEM' then begin
      sText := g_Config.sWomaHorn;
      sMsg := sub_49ADB8(sMsg, '<$REQUESTBUILDGUILDITEM>', sText);
      Exit;
    end;
    if sVariable = '$OWNERGUILD' then begin
      if m_Castle <> nil then begin
        sText := TUserCastle(m_Castle).m_sOwnGuild;
        if sText = '' then sText := '游戏管理';
      end else begin
        if g_CastleManager.GetCastle(0) <> nil then begin//20090304 增加 NPC不属于城堡也能显示沙巴克信息
          sText := TUserCastle(g_CastleManager.GetCastle(0)).m_sOwnGuild;
          if sText = '' then sText := '游戏管理';
        end else sText := '????';
      end;
      sMsg := sub_49ADB8(sMsg, '<$OWNERGUILD>', sText);
      Exit;
    end; //0049AF32

    if sVariable = '$CASTLENAME' then begin
      if m_Castle <> nil then begin
        sText := TUserCastle(m_Castle).m_sName;
      end else begin
        sText := '????';
      end;
      sMsg := sub_49ADB8(sMsg, '<$CASTLENAME>', sText);
      Exit;
    end;
    if sVariable = '$LORD' then begin
      if m_Castle <> nil then begin
        if TUserCastle(m_Castle).m_MasterGuild <> nil then begin
          sText := TUserCastle(m_Castle).m_MasterGuild.GetChiefName();
        end else sText := '管理员';
      end else begin
        if g_CastleManager.GetCastle(0) <> nil then begin//20090304 增加 NPC不属于城堡也能显示沙巴克信息
          if TUserCastle(g_CastleManager.GetCastle(0)).m_MasterGuild <> nil then begin
            sText := TUserCastle(g_CastleManager.GetCastle(0)).m_MasterGuild.GetChiefName();
          end else sText := '管理员';
        end else sText := '????';
      end;
      sMsg := sub_49ADB8(sMsg, '<$LORD>', sText);
      Exit;
    end;

    if sVariable = '$GUILDWARFEE' then begin
      sMsg := sub_49ADB8(sMsg, '<$GUILDWARFEE>', IntToStr(g_Config.nGuildWarPrice));
      Exit;
    end;
    if sVariable = '$BUILDGUILDFEE' then begin
      sMsg := sub_49ADB8(sMsg, '<$BUILDGUILDFEE>', IntToStr(g_Config.nBuildGuildPrice));
      Exit;
    end;

    if sVariable = '$CASTLEWARDATE' then begin
      if m_Castle = nil then begin
        m_Castle := g_CastleManager.GetCastle(0);
      end;
      if m_Castle <> nil then begin
        if not TUserCastle(m_Castle).m_boUnderWar then begin
          sText := TUserCastle(m_Castle).GetWarDate();
          if sText <> '' then begin
            sMsg := sub_49ADB8(sMsg, '<$CASTLEWARDATE>', sText);
          end else sMsg := '暂时没有行会攻城！！！\ \<返回/@main>';
        end else sMsg := '现正在攻城中！！！\ \<返回/@main>';
      end else begin
        sText := '????';
      end;
      Exit;
    end;

    if sVariable = '$LISTOFWAR' then begin
      if m_Castle <> nil then begin
        sText := TUserCastle(m_Castle).GetAttackWarList();
      end else begin
        sText := '????';
      end;
      if sText <> '' then begin
        sMsg := sub_49ADB8(sMsg, '<$LISTOFWAR>', sText);
      end else sMsg := '现在没有行会申请攻城战\ \<返回/@main>';
      Exit;
    end;

    if sVariable = '$CASTLECHANGEDATE' then begin//沙巴克占领的日期
      if m_Castle <> nil then begin
        sText := DateTimeToStr(TUserCastle(m_Castle).m_ChangeDate);
      end else begin
        sText := '????';
      end;
      sMsg := sub_49ADB8(sMsg, '<$CASTLECHANGEDATE>', sText);
      Exit;
    end;

    if sVariable = '$CASTLEWARLASTDATE' then begin
      if m_Castle <> nil then begin
        sText := DateTimeToStr(TUserCastle(m_Castle).m_WarDate);
      end else begin
        sText := '????';
      end;
      sMsg := sub_49ADB8(sMsg, '<$CASTLEWARLASTDATE>', sText);
      Exit;
    end;
    if sVariable = '$CASTLEGETDAYS' then begin//沙巴克占领的天数
      if m_Castle <> nil then begin
        sText := IntToStr(GetDayCount(Now, TUserCastle(m_Castle).m_ChangeDate));
      end else begin
        sText := '????';
      end;
      sMsg := sub_49ADB8(sMsg, '<$CASTLEGETDAYS>', sText);
      Exit;
    end;

    if sVariable = '$CMD_DATE' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_DATE>', g_GameCommand.Data.sCmd);
      Exit;
    end;
    if sVariable = '$CMD_ALLOWMSG' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_ALLOWMSG>', g_GameCommand.ALLOWMSG.sCmd);
      Exit;
    end;
    if sVariable = '$CMD_READMASTERMSG' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_READMASTERMSG>', g_GameCommand.READMASTERMSG.sCmd);
      Exit;
    end;
    if sVariable = '$CMD_MARRYMSG' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_MARRYMSG>', g_GameCommand.MarryMsg.sCmd);
      Exit;
    end;
    if sVariable = '$CMD_LETSHOUT' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_LETSHOUT>', g_GameCommand.LETSHOUT.sCmd);
      Exit;
    end;
    if sVariable = '$CMD_LETTRADE' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_LETTRADE>', g_GameCommand.LETTRADE.sCmd);
      Exit;
    end;

    if sVariable = '$CMD_LETGUILD' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_LETGUILD>', g_GameCommand.LETGUILD.sCmd);
      Exit;
    end;

    if sVariable = '$CMD_ENDGUILD' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_ENDGUILD>', g_GameCommand.ENDGUILD.sCmd);
      Exit;
    end;

    if sVariable = '$CMD_BANGUILDCHAT' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_BANGUILDCHAT>', g_GameCommand.BANGUILDCHAT.sCmd);
      Exit;
    end;

    if sVariable = '$CMD_AUTHALLY' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_AUTHALLY>', g_GameCommand.AUTHALLY.sCmd);
      Exit;
    end;

    if sVariable = '$CMD_AUTH' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_AUTH>', g_GameCommand.AUTH.sCmd);
      Exit;
    end;

    if sVariable = '$CMD_AUTHCANCEL' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_AUTHCANCEL>', g_GameCommand.AUTHCANCEL.sCmd);
      Exit;
    end;

    if sVariable = '$CMD_USERMOVE' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_USERMOVE>', g_GameCommand.USERMOVE.sCmd);
      Exit;
    end;

    if sVariable = '$CMD_SEARCHING' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_SEARCHING>', g_GameCommand.SEARCHING.sCmd);
      Exit;
    end;

    if sVariable = '$CMD_ALLOWGROUPCALL' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_ALLOWGROUPCALL>', g_GameCommand.ALLOWGROUPCALL.sCmd);
      Exit;
    end;

    if sVariable = '$CMD_GROUPRECALLL' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_GROUPRECALLL>', g_GameCommand.GROUPRECALLL.sCmd);
      Exit;
    end;

    if sVariable = '$CMD_ATTACKMODE' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_ATTACKMODE>', g_GameCommand.ATTACKMODE.sCmd);
      Exit;
    end;

    if sVariable = '$CMD_REST' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_REST>', g_GameCommand.REST.sCmd);
      Exit;
    end;

    if sVariable = '$CMD_STORAGESETPASSWORD' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_STORAGESETPASSWORD>', g_GameCommand.SETPASSWORD.sCmd);
      Exit;
    end;
    if sVariable = '$CMD_STORAGECHGPASSWORD' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_STORAGECHGPASSWORD>', g_GameCommand.CHGPASSWORD.sCmd);
      Exit;
    end;
    if sVariable = '$CMD_STORAGELOCK' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_STORAGELOCK>', g_GameCommand.Lock.sCmd);
      Exit;
    end;
    if sVariable = '$CMD_STORAGEUNLOCK' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_STORAGEUNLOCK>', g_GameCommand.UNLOCKSTORAGE.sCmd);
      Exit;
    end;
    if sVariable = '$CMD_UNLOCK' then begin
      sMsg := sub_49ADB8(sMsg, '<$CMD_UNLOCK>', g_GameCommand.UnLock.sCmd);
      Exit;
    end;
    if CompareLStr(sVariable, '$HUMAN(', 7) then begin
      ArrestStringEx(sVariable, '(', ')', s14);
      boFoundVar := False;
      if PlayObject.m_DynamicVarList.Count > 0 then begin//20080629
        for I := 0 to PlayObject.m_DynamicVarList.Count - 1 do begin
          DynamicVar := PlayObject.m_DynamicVarList.Items[I];
          if DynamicVar <> nil then begin//20090303
            if CompareText(DynamicVar.sName, s14) = 0 then begin
              case DynamicVar.VarType of
                vInteger: begin
                    sMsg := sub_49ADB8(sMsg, '<' + sVariable + '>', IntToStr(DynamicVar.nInternet));
                    boFoundVar := True;
                  end;
                vString: begin
                    sMsg := sub_49ADB8(sMsg, '<' + sVariable + '>', DynamicVar.sString);
                    boFoundVar := True;
                  end;
              end;
              Break;
            end;
          end;
        end;//for
      end;
      if not boFoundVar then sMsg := '??';
      Exit;
    end;
    if CompareLStr(sVariable, '$GUILD(', 7{Length('$GUILD(')}) then begin
      if PlayObject.m_MyGuild = nil then Exit;
      ArrestStringEx(sVariable, '(', ')', s14);
      boFoundVar := False;
      if TGUild(PlayObject.m_MyGuild).m_DynamicVarList.Count > 0 then begin//20080629
        for I := 0 to TGUild(PlayObject.m_MyGuild).m_DynamicVarList.Count - 1 do begin
          DynamicVar := TGUild(PlayObject.m_MyGuild).m_DynamicVarList.Items[I];
          if DynamicVar <> nil then begin//20090303
            if CompareText(DynamicVar.sName, s14) = 0 then begin
              case DynamicVar.VarType of
                vInteger: begin
                    sMsg := sub_49ADB8(sMsg, '<' + sVariable + '>', IntToStr(DynamicVar.nInternet));
                    boFoundVar := True;
                  end;
                vString: begin
                    sMsg := sub_49ADB8(sMsg, '<' + sVariable + '>', DynamicVar.sString);
                    boFoundVar := True;
                  end;
              end;
              Break;
            end;
          end;
        end;//for
      end;
      if not boFoundVar then sMsg := '??';
      Exit;
    end;
    if CompareLStr(sVariable, '$GLOBAL(', 8{Length('$GLOBAL(')}) then begin
      ArrestStringEx(sVariable, '(', ')', s14);
      boFoundVar := False;
      if g_DynamicVarList.Count > 0 then begin//20080629
        for I := 0 to g_DynamicVarList.Count - 1 do begin
          DynamicVar := g_DynamicVarList.Items[I];
          if DynamicVar <> nil then begin//20090303
            if CompareText(DynamicVar.sName, s14) = 0 then begin
              case DynamicVar.VarType of
                vInteger: begin
                    sMsg := sub_49ADB8(sMsg, '<' + sVariable + '>', IntToStr(DynamicVar.nInternet));
                    boFoundVar := True;
                  end;
                vString: begin
                    sMsg := sub_49ADB8(sMsg, '<' + sVariable + '>', DynamicVar.sString);
                    boFoundVar := True;
                  end;
              end;
              Break;
            end;
          end;
        end;//for
      end;
      if not boFoundVar then sMsg := '??';
      Exit;
    end;
    if CompareLStr(sVariable, '$STR(', 5{Length('$STR(')}) then begin
      ArrestStringEx(sVariable, '(', ')', s14);
      n18 := GetValNameNo(s14);
      if n18 >= 0 then begin
        case n18 of
          0..99: begin //20080323 原为0..99
              sMsg := sub_49ADB8(sMsg, '<' + sVariable + '>', IntToStr(PlayObject.m_nVal[n18]));
            end;
          100..199: begin
              sMsg := sub_49ADB8(sMsg, '<' + sVariable + '>', IntToStr(g_Config.GlobalVal[n18 - 100]));
            end;
          200..299: begin
              sMsg := sub_49ADB8(sMsg, '<' + sVariable + '>', IntToStr(PlayObject.m_DyVal[n18 - 200]));
            end;
          300..399: begin
              sMsg := sub_49ADB8(sMsg, '<' + sVariable + '>', IntToStr(PlayObject.m_nMval[n18 - 300]));
            end;
          400..499: begin
              sMsg := sub_49ADB8(sMsg, '<' + sVariable + '>', IntToStr(g_Config.GlobaDyMval[n18 - 400]));
            end;
          500..599: begin
              sMsg := sub_49ADB8(sMsg, '<' + sVariable + '>', IntToStr(PlayObject.m_nInteger[n18 - 500]));
            end;
          600..699: begin
              sMsg := sub_49ADB8(sMsg, '<' + sVariable + '>', PlayObject.m_sString[n18 - 600]);
            end;
          700..799: begin
              sMsg := sub_49ADB8(sMsg, '<' + sVariable + '>', g_Config.GlobalAVal[n18 - 700]);
            end;
          800..1199:begin//20080903 G变量(100-499)
              sMsg := sub_49ADB8(sMsg, '<' + sVariable + '>',  IntToStr(g_Config.GlobalVal[n18 - 700]));
            end;
          1200..2099:begin//A变量(100-999)
              sMsg := sub_49ADB8(sMsg, '<' + sVariable + '>', g_Config.GlobalAVal[n18 - 1100]);
            end;
          2100..2599: begin//G变量(500-999)
              sMsg := sub_49ADB8(sMsg, '<' + sVariable + '>',  IntToStr(g_Config.GlobalVal[n18 - 1600]));
            end;
        end;
      end;
    end;
  except
    //MainOutMessage(Format('{%s} TNormNpc.GetVariableText Msg:%s',[g_sExceptionVer, sVariable]));
  end;
end;

procedure TNormNpc.GotoLable(AObject: TPlayObject; sLabel: string; boExtJmp, boMmission: Boolean); //0049E584
var
  I, II, III: Integer;
  List1C: TStringList;
  bo11: Boolean;
  n18: Integer;
  n20: Integer;
  sSENDMSG: string;
  Script: pTScript;
  Script3C: pTScript;
  SayingRecord: pTSayingRecord;
  SayingProcedure: pTSayingProcedure;
  UserItem: pTUserItem;
  SC, sStr: string;
  m_DelayGoto: LongWord;//20081213
  nCode: Byte;//20081005
  BaseObject: TBaseObject;//20090926
  PlayObject: TPlayObject;//20090926

  function IsPlayObject: Boolean;//20090926
  begin
    Result := (BaseObject <> nil) and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and (BaseObject = PlayObject);
  end;
  function IsHeroObject: Boolean;//20090926
  begin
    Result := (BaseObject <> nil) and (BaseObject.m_btRaceServer = RC_HEROOBJECT);
  end;

  function CheckQuestStatus(ScriptInfo: pTScript): Boolean; //0049BA00
  var
    I: Integer;
  begin
    Result := True;
    if not ScriptInfo.boQuest then Exit;
    I := 0;
    while (True) do begin
      try//20101126 防止死循环
        if (ScriptInfo.QuestInfo[I].nRandRage > 0) and (Random(ScriptInfo.QuestInfo[I].nRandRage) <> 0) then begin
          Result := False;
          Break;
        end;
        if PlayObject.GetQuestFalgStatus(ScriptInfo.QuestInfo[I].wFlag) <> ScriptInfo.QuestInfo[I].btValue then begin
          Result := False;
          Break;
        end;
      except
      end;
      Inc(I);
      if I >= 10 then Break;
    end; // while
  end;
  function CheckItemW(Play: TBaseObject;sItemType: string; nParam: Integer): pTUserItem;
  var
    nCount: Integer;
  begin
    Result := nil;
    if CompareLStr(sItemType, '[NECKLACE]', 4) then begin
      if Play.m_UseItems[U_NECKLACE].wIndex > 0 then begin
        Result := @Play.m_UseItems[U_NECKLACE];
      end;
      Exit;
    end;
    if CompareLStr(sItemType, '[RING]', 4) then begin
      if Play.m_UseItems[U_RINGL].wIndex > 0 then begin
        Result := @Play.m_UseItems[U_RINGL];
      end;
      if Play.m_UseItems[U_RINGR].wIndex > 0 then begin
        Result := @Play.m_UseItems[U_RINGR];
      end;
      Exit;
    end;
    if CompareLStr(sItemType, '[ARMRING]', 4) then begin
      if Play.m_UseItems[U_ARMRINGL].wIndex > 0 then begin
        Result := @Play.m_UseItems[U_ARMRINGL];
      end;
      if Play.m_UseItems[U_ARMRINGR].wIndex > 0 then begin
        Result := @Play.m_UseItems[U_ARMRINGR];
      end;
      Exit;
    end;
    if CompareLStr(sItemType, '[WEAPON]', 4) then begin
      if Play.m_UseItems[U_WEAPON].wIndex > 0 then begin
        Result := @Play.m_UseItems[U_WEAPON];
      end;
      Exit;
    end;
    if CompareLStr(sItemType, '[HELMET]', 4) then begin
      if Play.m_UseItems[U_HELMET].wIndex > 0 then begin
        Result := @Play.m_UseItems[U_HELMET];
      end;
      Exit;
    end;
    if CompareLStr(sItemType, '[ZHULI]', 4) then begin //斗笠
      if Play.m_UseItems[U_ZHULI].wIndex > 0 then begin
        Result := @Play.m_UseItems[U_ZHULI];
      end;
      Exit;
    end;
    Result := Play.GetUserItemByName(sItemType, nCount);
    if nCount < nParam then Result := nil;
  end;
  function CheckAnsiContainsTextList(sTest, sListFileName: string): Boolean;
  var
    I: Integer;
    LoadList: TStringList;
  begin
    Result := False;
    sListFileName := g_Config.sEnvirDir + sListFileName;
    if FileExists(sListFileName) then begin
      LoadList := TStringList.Create;
      try
        LoadList.LoadFromFile(sListFileName);
      except
        MainOutMessage('文件读取失败3.... => ' + sListFileName);
      end;
      if LoadList.Count > 0 then begin//20080629
        for I := 0 to LoadList.Count - 1 do begin
          if AnsiContainsText(sTest, Trim(LoadList.Strings[I])) then begin
            Result := True;
            Break;
          end;
        end;
      end;
      LoadList.Free;
    end else begin
      MainOutMessage('文件没有找到 => ' + sListFileName);
    end;
  end;

  function CheckTextInList(sTest, sListFileName: string): Boolean;//检查文本里是否含有指定的字符串 200804028
  var
    I: Integer;
    LoadList: TStringList;
  begin
    Result := False;
    sListFileName := g_Config.sEnvirDir + sListFileName;
    if FileExists(sListFileName) then begin
      LoadList := TStringList.Create;
      try
        LoadList.LoadFromFile(sListFileName);
      except
        MainOutMessage('文件读取失败(CHECKLISTTEXT) => ' + sListFileName);
      end;
      if LoadList.Count > 0 then begin//20080629
        for I := 0 to LoadList.Count - 1 do begin
          if AnsiContainsText(Trim(LoadList.Strings[I]), sTest) then begin
            Result := True;
            Break;
          end;
        end;
      end;
      LoadList.Free;
    end else begin
      MainOutMessage('文件没有找到 => ' + sListFileName);
    end;
  end;

  function CheckStringList(sHumName, sListFileName: string): Boolean;
  var
    I: Integer;
    LoadList: TStringList;
  begin
    Result := False;
    sListFileName := g_Config.sEnvirDir + sListFileName;
    if FileExists(sListFileName) then begin
      LoadList := TStringList.Create;
      try
        try
          LoadList.LoadFromFile(sListFileName);
        except
          MainOutMessage('文件读取失败(CheckStringList) => ' + sListFileName);
        end;
        if LoadList.Count > 0 then begin//20080629
          for I := 0 to LoadList.Count - 1 do begin
            if CompareText(Trim(LoadList.Strings[I]), sHumName) = 0 then begin
              Result := True;
              Break;
            end;
          end;
        end;
      finally
        LoadList.Free;
      end;
    end else begin
      MainOutMessage('文件没有找到 => ' + sListFileName);
    end;
  end;

  function CheckVarNameNo(CheckQuestConditionInfo: pTQuestConditionInfo; var n140, n180: Integer): Boolean;
    function GetValValue(sValName: string; var nValue: Integer): Boolean;
    var
      n100: Integer;
    begin
      Result := False;
      nValue := 0;
      n100 := GetValNameNo(sValName);
      if n100 >= 0 then begin
        case n100 of
          0..99: begin //20080323 原为0..99
              nValue := PlayObject.m_nVal[n100];
              Result := True;
            end;
          100..199: begin
              nValue := g_Config.GlobalVal[n100 - 100];
              Result := True;
            end;
          200..299: begin //20080323 原为200..209
              nValue := PlayObject.m_DyVal[n100 - 200];
              Result := True;
            end;
          300..399: begin
              nValue := PlayObject.m_nMval[n100 - 300];
              Result := True;
            end;
          400..499: begin
              nValue := g_Config.GlobaDyMval[n100 - 400];
              Result := True;
            end;
          500..599: begin
              nValue := PlayObject.m_nInteger[n100 - 500];
              Result := True;
            end;
          600..699: begin//20080602 增加
              if IsStringNumber(PlayObject.m_sString[n100 - 600]) then begin//20081210
                nValue := Str_ToInt(PlayObject.m_sString[n100 - 600],0);
                Result := True;
              end;
            end;
          700..799: begin//20080602 增加
              if IsStringNumber(g_Config.GlobalAVal[n100 - 700]) then begin//20081210
                nValue := Str_ToInt(g_Config.GlobalAVal[n100 - 700],0);
                Result := True;
              end;
            end;
          800..1199:begin//20080903 G变量
              nValue := g_Config.GlobalVal[n100 - 700];
              Result := True;
            end;
          1200..2099:begin//A变量(100-999)
              if IsStringNumber(g_Config.GlobalAVal[n100 - 1100]) then begin//20081210
                nValue := Str_ToInt(g_Config.GlobalAVal[n100 - 1100],0);
                Result := True;
              end;
            end;
          2100..2599: begin//G变量(500-999)
              nValue := g_Config.GlobalVal[n100 - 1600];
              Result := True;
            end;
        end;
      end;
    end;

    function GetDynamicVarValue(sVarType, sValName: string; var nValue: Integer): Boolean;
    var
      III: Integer;
      DynamicVar: pTDynamicVar;
      DynamicVarList: TList;
      sName: string;
    begin
      Result := False;
      DynamicVarList := GetDynamicVarList(PlayObject, sVarType, sName);
      if DynamicVarList = nil then begin
        Exit;
      end else begin
        if DynamicVarList.Count > 0 then begin//20080629
          for III := 0 to DynamicVarList.Count - 1 do begin
            DynamicVar := DynamicVarList.Items[III];
            if DynamicVar <> nil then begin
              if CompareText(DynamicVar.sName, sValName) = 0 then begin
                case DynamicVar.VarType of
                  vInteger: begin
                      nValue := DynamicVar.nInternet;
                      Result := True;
                    end;
                  vString: begin
                    end;
                end;
                Break;
              end;
            end;
          end;//for
        end;
      end;
    end;
    function GetDataType: Integer; //
    var
      sParam1: string;
      sParam2: string;
      sParam3: string;
    begin
      Result := -1;
      if CompareLStr(CheckQuestConditionInfo.sParam1, '<$STR(', 6{Length('<$STR(')}) then //20080228 支持字符串变量
        ArrestStringEx(CheckQuestConditionInfo.sParam1, '(', ')', sParam1)
      else sParam1 := CheckQuestConditionInfo.sParam1;

      if CompareLStr(CheckQuestConditionInfo.sParam2, '<$STR(', 6{Length('<$STR(')}) then //20080228 支持字符串变量
        ArrestStringEx(CheckQuestConditionInfo.sParam2, '(', ')', sParam2)
      else sParam2 := CheckQuestConditionInfo.sParam2;

      if CompareLStr(CheckQuestConditionInfo.sParam3, '<$STR(', 6{Length('<$STR(')}) then  //20080228 支持字符串变量
        ArrestStringEx(CheckQuestConditionInfo.sParam3, '(', ')', sParam3)
      else sParam3 := CheckQuestConditionInfo.sParam3;
      
      {sParam1 := CheckQuestConditionInfo.sParam1;//20080228
      sParam2 := CheckQuestConditionInfo.sParam2;
      sParam3 := CheckQuestConditionInfo.sParam3;}
      if IsVarNumber(sParam1) then begin
        if (sParam3 <> '') and (GetValNameNo(sParam3) >= 0) then begin
          Result := 0;
        end else
          if (sParam3 <> '') and IsStringNumber(sParam3) then begin
          Result := 1;
        end;
        Exit;
      end;
      if GetValNameNo(sParam1) >= 0 then begin
        if (sParam2 <> '') and (GetValNameNo(sParam2) >= 0) then begin
          Result := 2;
        end else
          if (sParam2 <> '') and IsVarNumber(sParam2) and (sParam3 <> '') then begin
          Result := 3;
        end else
          if (sParam2 <> '') and IsStringNumber(sParam2) then begin
          Result := 4;
        end;
      end;
    end;
  var
    sParam1: string;
    sParam2: string;
    sParam3: string;
  begin
    Result := False;
    n140 := -1;
    n180 := -1;

    if CompareLStr(CheckQuestConditionInfo.sParam1, '<$STR(', 6{Length('<$STR(')}) then //20080228 支持字符串变量
      ArrestStringEx(CheckQuestConditionInfo.sParam1, '(', ')', sParam1)
    else sParam1 := CheckQuestConditionInfo.sParam1;

    if CompareLStr(CheckQuestConditionInfo.sParam2, '<$STR(', 6{Length('<$STR(')}) then //20080228 支持字符串变量
      ArrestStringEx(CheckQuestConditionInfo.sParam2, '(', ')', sParam2)
    else sParam2 := CheckQuestConditionInfo.sParam2;

    if CompareLStr(CheckQuestConditionInfo.sParam3, '<$STR(', 6{Length('<$STR(')}) then  //20080228 支持字符串变量
      ArrestStringEx(CheckQuestConditionInfo.sParam3, '(', ')', sParam3)
    else sParam3 := CheckQuestConditionInfo.sParam3;

    case GetDataType of
      0: begin
          if GetDynamicVarValue(sParam1, sParam2, n140) and
            GetValValue(sParam3, n180) then Result := True;
        end;
      1: begin
          n180 := CheckQuestConditionInfo.nParam3;
          if GetDynamicVarValue(sParam1, sParam2, n140) then Result := True;
        end;
      2: begin
          if GetValValue(sParam1, n140) and GetValValue(sParam2, n180) then Result := True;
        end;
      3: begin
          if GetValValue(sParam1, n140) and
            GetDynamicVarValue(sParam2, sParam3, n180) then Result := True;
        end;
      4: begin
          n180 := CheckQuestConditionInfo.nParam2;
          if GetValValue(sParam1, n140) then Result := True;
        end;
      5: begin

       end;
    end;
  end;

  function QuestCheckCondition(ConditionList: TList): Boolean;
  var
    I: Integer;
    QuestConditionInfo: pTQuestConditionInfo;
    n10, n14, n18, n1C, nMaxDura, nDura: Integer;
    Hour, Min, Sec, MSec: Word;
    StdItem: pTStdItem;
    s01, s02: string;
  begin
    Result := True;
    if ConditionList.Count > 0 then begin//20081008
      for I := 0 to ConditionList.Count - 1 do begin
        QuestConditionInfo := ConditionList.Items[I];
        BaseObject := QuestConditionInfo.Script.GetBaseObject(Self, AObject); //转换运行对象,NPC命令扩展 20090926
        if BaseObject = nil then begin
          Result := False;
          Break;
        end else begin
          if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
            PlayObject := TPlayObject(BaseObject) else PlayObject := nil;
        end;
        case QuestConditionInfo.nCMDCode of
          nCHECK: begin//48
              if IsPlayObject then begin
                n14 := Str_ToInt(QuestConditionInfo.sParam1, 0);
                n18 := Str_ToInt(QuestConditionInfo.sParam2, 0);
                n10 := PlayObject.GetQuestFalgStatus(n14);
                if n10 = 0 then begin
                  if n18 <> 0 then Result := False;
                end else begin
                  if n18 = 0 then Result := False;
                end;
              end else Result := False;
            end;
          nRANDOM: begin//49
              s01 := QuestConditionInfo.sParam1;
              if (s01 <> '') and (s01[1] = '<') and (s01[2] = '$') then//增20110728 加支持<$Str()>
                 n14 := Str_ToInt(GetLineVariableText(PlayObject, QuestConditionInfo.sParam1), -1)
              else
              if not GetValValue(PlayObject, QuestConditionInfo.sParam1, n14) then begin //增加变量支持
                n14 := QuestConditionInfo.nParam1;
              end;
              if n14 < 0 then n14:= QuestConditionInfo.nParam1;
              if Random({QuestConditionInfo.nParam1}n14) <> 0 then Result := False;
            end;
          nGENDER: begin//70  检查角色性别
              if CompareText(QuestConditionInfo.sParam2, 'HERO') = 0 then begin//20081211 增加检查英雄性别
                {$IF HEROVERSION = 1}
                if PlayObject.m_MyHero <> nil then begin
                  if CompareText(QuestConditionInfo.sParam1, 'MAN'{sMAN}) = 0 then begin
                    if PlayObject.m_MyHero.m_btGender <> 0 then Result := False;
                  end else
                  if CompareText(QuestConditionInfo.sParam1, 'WOMAN') = 0 then begin
                    if PlayObject.m_MyHero.m_btGender <> 1 then Result := False;
                  end;
                end else Result := False;
                {$IFEND}
              end else begin
                if CompareText(QuestConditionInfo.sParam1, 'MAN'{sMAN}) = 0 then begin
                  if PlayObject.m_btGender <> 0 then Result := False;
                end else begin
                  if PlayObject.m_btGender <> 1 then Result := False;
                end;
              end;
            end;
          nDAYTIME: begin//sunset=日落 sunraise=日出 day=白天 night=夜晚
              if CompareText(QuestConditionInfo.sParam1, 'SUNRAISE'{sSUNRAISE}) = 0 then begin
                if g_nGameTime <> 0 then Result := False;
              end;
              if CompareText(QuestConditionInfo.sParam1, 'DAY'{sDAY}) = 0 then begin
                if g_nGameTime <> 1 then Result := False;
              end;
              if CompareText(QuestConditionInfo.sParam1, 'SUNSET'{sSUNSET}) = 0 then begin
                if g_nGameTime <> 2 then Result := False;
              end;
              if CompareText(QuestConditionInfo.sParam1, 'NIGHT'{sNIGHT}) = 0 then begin
                if g_nGameTime <> 3 then Result := False;
              end;
            end;
          nCHECKLEVEL: if PlayObject.m_Abil.Level < QuestConditionInfo.nParam1 then Result := False;
          nCHECKJOB: begin
              if CompareLStr(QuestConditionInfo.sParam1, 'WARRIOR'{sWARRIOR}, 3) then begin
                if PlayObject.m_btJob <> 0 then Result := False;
              end;
              if CompareLStr(QuestConditionInfo.sParam1, 'WIZARD'{sWIZARD}, 3) then begin
                if PlayObject.m_btJob <> 1 then Result := False;
              end;
              if CompareLStr(QuestConditionInfo.sParam1, 'TAOIST'{sTAOS}, 3) then begin
                if PlayObject.m_btJob <> 2 then Result := False;
              end;
              {if CompareLStr(QuestConditionInfo.sParam1, 'ASSASSIN', 3) then begin//刺客
                if PlayObject.m_btJob <> 3 then Result := False;
              end;}
            end;
          nCHECKBBCOUNT: if PlayObject.m_SlaveList.Count < QuestConditionInfo.nParam1 then Result := False;
          nCHECKITEM: begin
              s01 := GetLineVariableText(PlayObject, QuestConditionInfo.sParam1);//20080601 支持变量
              n14 := Str_ToInt(GetLineVariableText(PlayObject, QuestConditionInfo.sParam2), 0);//20080601 支持变量
              if (n14 = 0) then GetValValue(PlayObject, QuestConditionInfo.sParam2, n14);//20110902 增加
              if CompareText(QuestConditionInfo.sParam3, 'HERO') = 0 then begin//英雄 20090910
                {$IF HEROVERSION = 1}
                if (PlayObject.m_MyHero <> nil) then begin
                  UserItem := THeroObject(PlayObject.m_MyHero).QuestCheckItem(s01, n1C, nMaxDura, nDura);
                end else Result := False;
                {$IFEND}
              end else begin
                UserItem := PlayObject.QuestCheckItem(s01, n1C, nMaxDura, nDura);
              end;
              if n1C < n14 then Result := False;
            end;
          nCHECKHUMINRANGE: if not ConditionOfCheckHumInRange(PlayObject, QuestConditionInfo) then Result := False;//检测人物是否在指定范围之内 20090808
          nCHECKKIMNEEDLE: if not ConditionOfCheckKimNeele(PlayObject, QuestConditionInfo) then Result := False;//检查包裹是否有指定叠加物品 20090615
          nCHECKSKILL75: begin
              if CompareText(QuestConditionInfo.sParam1, 'HERO') = 0 then begin//英雄
                {$IF HEROVERSION = 1}
                if (PlayObject.m_MyHero <> nil) then begin
                  if not PlayObject.m_MyHero.m_boProtectionDefence then Result := False;
                end else Result := False;
                {$IFEND}
              end else begin
                if not PlayObject.m_boProtectionDefence then Result := False;
              end;
            end;
          {$IF M2Version = 1}
          nSC_CHECK4BATTERSKILL: if (not ConditionOfCHECK4BATTERSKILL(PlayObject, QuestConditionInfo)) then Result := False;//检查是否开启第四连击技能
          nCHECKHEROOPENOPULS: if not ConditionOfCheckHeroOpenPuls(PlayObject, QuestConditionInfo) then Result := False;//检查英雄是否开通经脉系统(英雄不在线，没学内功都将为F)
          nCHECKHEROPULSEXP: if not ConditionOfCheckHeroPulsExp(PlayObject, QuestConditionInfo) then Result := False;//检查英雄经络修炼点
          nCHECKHUMANPULSE: if not ConditionOfCheckHumanPulse(PlayObject, QuestConditionInfo) then Result := False;//检查是否跨穴点击 20090623
          nCHECKOPENPULSELEVEL: if not ConditionOfCheckOpenPulseLevel(PlayObject, QuestConditionInfo) then Result := False;//检查打通穴位所需内功等级 20090623
          nCHECKPULSELEVEL: if not ConditionOfCheckPulseLevel(PlayObject, QuestConditionInfo) then Result := False;//检查各经络等级
          {$IFEND}
          nCHECKAUTOADDEXPPLAY: if not ConditionOfCHECKAUTOADDEXPPLAY(PlayObject, QuestConditionInfo) then Result := False;//检查服务器挂机人数 20090719
          nCHECKAIPLAY: if not ConditionOfCHECKAIPLAY(PlayObject, QuestConditionInfo) then Result := False;//检查服务器假人数
          nCHECKMAP: if not ConditionOfCHECKMAP(PlayObject, QuestConditionInfo) then Result := False;
          nCHECKITEMW: begin
              if CompareText(QuestConditionInfo.sParam3, 'HERO') = 0 then begin//英雄
                {$IF HEROVERSION = 1}
                if (PlayObject.m_MyHero <> nil) then begin
                  UserItem := CheckItemW(PlayObject.m_MyHero, QuestConditionInfo.sParam1, QuestConditionInfo.nParam2);
                end;
                {$IFEND}
              end else begin
                UserItem := CheckItemW(PlayObject, QuestConditionInfo.sParam1, QuestConditionInfo.nParam2);
              end;
              if UserItem = nil then Result := False;
            end;
          nCHECKGOLD: begin
              if IsPlayObject then begin
                s01 := QuestConditionInfo.sParam1;
                if (s01 <> '') and (s01[1] = '<') and (s01[2] = '$') then//增加支持<$Str()>  20080506
                   n14 := Str_ToInt(GetLineVariableText(PlayObject, QuestConditionInfo.sParam1),0)
                else
                if not GetValValue(PlayObject, QuestConditionInfo.sParam1, n14) then begin //增加变量支持
                  n14 := QuestConditionInfo.nParam1;
                end;
                if PlayObject.m_nGold < n14 then Result := False;
              end else Result := False;
            end;
          nISTAKEITEM: if SC <> QuestConditionInfo.sParam1 then Result := False;
          nCHECKDURA: begin
              UserItem := PlayObject.QuestCheckItem(QuestConditionInfo.sParam1, n1C, nMaxDura, nDura);
              if Round(nDura / 1000) < QuestConditionInfo.nParam2 then Result := False;
            end;
          nCHECKDURAEVA: begin
              UserItem := PlayObject.QuestCheckItem(QuestConditionInfo.sParam1, n1C, nMaxDura, nDura);
              if n1C > 0 then begin
                if Round(nMaxDura / n1C / 1000) < QuestConditionInfo.nParam2 then Result := False;
              end else Result := False;
            end;
          nDAYOFWEEK: begin
              if CompareLStr(QuestConditionInfo.sParam1, 'SUN'{sSUN}, 3{Length(sSUN)}) then begin
                if DayOfWeek(Now) <> 1 then Result := False;
              end;
              if CompareLStr(QuestConditionInfo.sParam1, 'MON'{sMON}, 3{Length(sMON)}) then begin
                if DayOfWeek(Now) <> 2 then Result := False;
              end;
              if CompareLStr(QuestConditionInfo.sParam1, 'TUE'{sTUE}, 3{Length(sTUE)}) then begin
                if DayOfWeek(Now) <> 3 then Result := False;
              end;
              if CompareLStr(QuestConditionInfo.sParam1, 'WED'{sWED}, 3{Length(sWED)}) then begin
                if DayOfWeek(Now) <> 4 then Result := False;
              end;
              if CompareLStr(QuestConditionInfo.sParam1, 'THU'{sTHU}, 3{Length(sTHU)}) then begin
                if DayOfWeek(Now) <> 5 then Result := False;
              end;
              if CompareLStr(QuestConditionInfo.sParam1, 'FRI'{sFRI}, 3{Length(sFRI)}) then begin
                if DayOfWeek(Now) <> 6 then Result := False;
              end;
              if CompareLStr(QuestConditionInfo.sParam1, 'SAT'{sSAT}, 3{Length(sSAT)}) then begin
                if DayOfWeek(Now) <> 7 then Result := False;
              end;
            end;
          nHOUR: begin
              if (QuestConditionInfo.nParam1 <> 0) and (QuestConditionInfo.nParam2 = 0) then
                QuestConditionInfo.nParam2 := QuestConditionInfo.nParam1;
              DecodeTime(Time, Hour, Min, Sec, MSec);
              if (Hour < QuestConditionInfo.nParam1) or (Hour > QuestConditionInfo.nParam2) then
                Result := False;
            end;
          nMIN: begin
              if (QuestConditionInfo.nParam1 <> 0) and (QuestConditionInfo.nParam2 = 0) then
                QuestConditionInfo.nParam2 := QuestConditionInfo.nParam1;
              DecodeTime(Time, Hour, Min, Sec, MSec);
              if (Min < QuestConditionInfo.nParam1) or (Min > QuestConditionInfo.nParam2) then
                Result := False;
            end;
          nCHECKPKPOINT: if (not IsPlayObject) or (not ConditionOfCHECKPKPOINT(PlayObject, QuestConditionInfo)) then Result := False;//20080506
          nCHECKLUCKYPOINT: if (not IsPlayObject) or (PlayObject.m_nBodyLuckLevel < QuestConditionInfo.nParam1) then Result := False;
          nCHECKMONMAP: if (not IsPlayObject) or (not ConditionOfCheckMonMapCount(PlayObject, QuestConditionInfo)) then Result := False;
          nCHECKHUM: begin
              if IsPlayObject then begin
                if not GetValValue(PlayObject, QuestConditionInfo.sParam2, n14) then begin //增加变量支持
                  n14 := QuestConditionInfo.nParam2;
                end;
                if UserEngine.GetMapHuman(QuestConditionInfo.sParam1) < n14 then Result := False;
              end else Result := False;
            end;

          nCHECKBAGGAGE: begin
              if IsPlayObject then begin
                if PlayObject.IsEnoughBag then begin
                  if QuestConditionInfo.sParam1 <> '' then begin
                    Result := False;
                    if not GetValValue(PlayObject, QuestConditionInfo.sParam1, s01) then begin //增加变量支持
                      s01 := QuestConditionInfo.sParam1;
                    end;
                    StdItem := UserEngine.GetStdItem(s01);
                    if StdItem <> nil then begin
                      if PlayObject.IsAddWeightAvailable(StdItem.Weight) then Result := True;
                    end;
                  end;
                end else Result := False;
              end else begin
                if THeroObject(BaseObject).IsEnoughBag then begin
                  if QuestConditionInfo.sParam1 <> '' then begin
                    Result := False;
                    if BaseObject.m_Master <> nil then begin
                      if not GetValValue(TPlayObject(BaseObject.m_Master), QuestConditionInfo.sParam1, s01) then begin //增加变量支持
                        s01 := QuestConditionInfo.sParam1;
                      end;
                      StdItem := UserEngine.GetStdItem(s01);
                      if StdItem <> nil then begin
                        if BaseObject.IsAddWeightAvailable(StdItem.Weight) then Result := True;
                      end;
                    end;
                  end;
                end else Result := False;
              end;
            end;
          nCHECKNAMELIST: if not CheckStringList(PlayObject.m_sCharName, m_sPath + QuestConditionInfo.sParam1) then Result := False;
          nCHECKACCOUNTLIST: if (not IsPlayObject) or (not CheckStringList(PlayObject.m_sUserID, m_sPath + QuestConditionInfo.sParam1)) then Result := False;
          nCHECKIPLIST: if (not IsPlayObject) or (not CheckStringList(PlayObject.m_sIPaddr, m_sPath + QuestConditionInfo.sParam1)) then Result := False;
          nEQUAL: begin
              if IsPlayObject then begin
                if CheckVarNameNo(QuestConditionInfo, n14, n18) then begin//比较数值
                  if n14 <> n18 then Result := False else Result := True;//20080519
                end else begin//比较字符串
                  if not GetValValue(PlayObject, QuestConditionInfo.sParam1, s01) then
                     s01 := GetLineVariableText(PlayObject, QuestConditionInfo.sParam1);//20080604 支持变量
                  if not GetValValue(PlayObject, QuestConditionInfo.sParam2, s02) then
                     s02 := GetLineVariableText(PlayObject, QuestConditionInfo.sParam2);//20080604 支持变量
                  if CompareText(s01,s02)= 0 then Result := True
                  else Result := False;
                end;
              end else Result := False;  
            end;
          nLARGE: begin
              if IsPlayObject then begin
                if CheckVarNameNo(QuestConditionInfo, n14, n18) then begin
                  if n14 <= n18 then Result := False;
                end else Result := False;
              end else Result := False;
            end;
          nSMALL: begin
              if IsPlayObject then begin
                if CheckVarNameNo(QuestConditionInfo, n14, n18) then begin
                  if n14 >= n18 then Result := False;
                end else Result := False;
              end else Result := False;  
            end;
          nSC_ISSYSOP: if (not IsPlayObject) or (not (PlayObject.m_btPermission >= 4)) then Result := False;
          nSC_ISADMIN: if (not IsPlayObject) or (not (PlayObject.m_btPermission >= 6)) then Result := False;
          nSC_CHECKGROUPMAP: if (not IsPlayObject) or (not ConditionOfCheckGroupMap(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKGROUPJOB: if (not IsPlayObject) or (not ConditionOfCheckGroupJob(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKHITMONNAME: if (not IsPlayObject) or (not ConditionOfCheckHitMonName(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKSELFSORT: if (not IsPlayObject) or (not ConditionOfCheckSelfSort(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKGROUPFLAG: if (not IsPlayObject) or (not ConditionOfCheckGroupFLAG(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKGROUPCOUNT: if (not IsPlayObject) or (not ConditionOfCheckGroupCount(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKPOSEDIR: if (not IsPlayObject) or (not ConditionOfCheckPoseDir(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKPOSELEVEL: if (not IsPlayObject) or (not ConditionOfCheckPoseLevel(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKPOSEGENDER: if (not IsPlayObject) or (not ConditionOfCheckPoseGender(PlayObject, QuestConditionInfo)) then Result := False;
          {$IF M2Version <> 2}
          nSC_ISDIVISIONMASTER: if (not IsPlayObject) or (not ConditionOfISDIVISIONMASTER(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_ISDIVISIONHEART: if (not IsPlayObject) or (not ConditionOfISDIVISIONHEART(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKHEARTEXP: if (not IsPlayObject) or (not ConditionOfCheckHeartExp(PlayObject, QuestConditionInfo)) then Result := False;//检查累积经验是否达到心法吸收值
          nSC_CHECKHEHEARTSKILL: if (not IsPlayObject) or (not ConditionOfCheckHeartSkill(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKDIVISIONPOINT: if (not IsPlayObject) or (not ConditionOfCheckDivisionPoint(PlayObject, QuestConditionInfo)) then Result := False;//检测门派人气值
          nSC_CHECKFENGHAO: if (not IsPlayObject) or (not ConditionOfCHECKFENGHAO(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKFENGHAOCOUNT: if (not IsPlayObject) or (not ConditionOfCHECKFENGHAOCOUNT(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKFENGHAOLISTCOUNT: if (not IsPlayObject) or (not ConditionOfCHECKFENGHAOLISTCOUNT(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKGUILDSTARDAY: if (not IsPlayObject) or (not ConditionOfCheckGuildStarDay(PlayObject, QuestConditionInfo)) then Result := False;
          {$IFEND}
          nSC_CHECKLEVELEX: if not ConditionOfCheckLevelEx(PlayObject, QuestConditionInfo) then Result := False;
          nSC_CHECKBONUSPOINT: if (not IsPlayObject) or (not ConditionOfCheckBonusPoint(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKMARRY: if (not IsPlayObject) or (not ConditionOfCheckMarry(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKPOSEMARRY: if (not IsPlayObject) or (not ConditionOfCheckPoseMarry(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKMARRYCOUNT: if (not IsPlayObject) or (not ConditionOfCheckMarryCount(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKMASTER: if (not IsPlayObject) or (not ConditionOfCheckMaster(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_HAVEMASTER: if (not IsPlayObject) or (not ConditionOfHaveMaster(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKPOSEMASTER: if (not IsPlayObject) or (not ConditionOfCheckPoseMaster(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_POSEHAVEMASTER: if (not IsPlayObject) or (not ConditionOfPoseHaveMaster(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKISMASTER: if (not IsPlayObject) or (not ConditionOfCheckIsMaster(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_HASGUILD: if (not IsPlayObject) or (not ConditionOfCheckHaveGuild(PlayObject, QuestConditionInfo)) then Result := False;

          nSC_ISGUILDMASTER: if (not IsPlayObject) or (not ConditionOfCheckIsGuildMaster(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKCASTLEMASTER: if (not IsPlayObject) or (not ConditionOfCheckIsCastleMaster(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_ISCASTLEGUILD: if (not IsPlayObject) or (not ConditionOfCheckIsCastleaGuild(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_ISATTACKGUILD: if (not IsPlayObject) or (not ConditionOfCheckIsAttackGuild(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_ISDEFENSEGUILD: if (not IsPlayObject) or (not ConditionOfCheckIsDefenseGuild(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKCASTLEDOOR: if (not IsPlayObject) or (not ConditionOfCheckCastleDoorStatus(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_ISATTACKALLYGUILD: if (not IsPlayObject) or (not ConditionOfCheckIsAttackAllyGuild(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_ISDEFENSEALLYGUILD: if (not IsPlayObject) or (not ConditionOfCheckIsDefenseAllyGuild(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKPOSEISMASTER: if (not IsPlayObject) or (not ConditionOfCheckPoseIsMaster(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKNAMEIPLIST: if (not IsPlayObject) or (not ConditionOfCheckNameIPList(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKACCOUNTIPLIST: if (not IsPlayObject) or (not ConditionOfCheckAccountIPList(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKSLAVECOUNT: if (not IsPlayObject) or (not ConditionOfCheckSlaveCount(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_ISNEWHUMAN: begin
              if IsPlayObject then begin
                if not PlayObject.m_boNewHuman then Result := False;
              end else begin
                if not THeroObject(BaseObject).m_boNewHuman then Result := False;
              end;
            end;
          nSC_CHECKMEMBERTYPE: if (not IsPlayObject) or (not ConditionOfCheckMemberType(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKMEMBERLEVEL: if (not IsPlayObject) or (not ConditionOfCheckMemBerLevel(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKGAMEGOLD: if (not IsPlayObject) or (not ConditionOfCheckGameGold(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKSTRINGLENGTH: if (not IsPlayObject) or (not ConditionOfCHECKSTRINGLENGTH(PlayObject, QuestConditionInfo)) then Result := False;//检查字符串的长度 20090105
          nSC_CHECKGAMEDIAMOND: if (not IsPlayObject) or (not ConditionOfCHECKGAMEDIAMOND(PlayObject, QuestConditionInfo)) then Result := False;//检查金刚石 20071226
          nSC_CHECKGAMEGIRD: if (not IsPlayObject) or (not ConditionOfCHECKGAMEGIRD(PlayObject, QuestConditionInfo)) then Result := False;//检查灵符 20071226
          nSC_CHECKGAMEGLORY: if (not IsPlayObject) or (not ConditionOfCheckGameGLORY(PlayObject, QuestConditionInfo)) then Result := False;//检测荣誉值 20080511
          nSC_CHECKSKILLLEVEL: if not ConditionOfCHECKSKILLLEVEL(PlayObject, QuestConditionInfo) then Result := False;//检查技能等级 20080512
          nSC_CHECKMAPMOBCOUNT: if (not IsPlayObject) or (not ConditionOfCHECKMAPMOBCOUNT(PlayObject, QuestConditionInfo)) then Result := False;//检查地图指定坐标指定名称怪物数量 20080123
          nSC_CHECKSIDESLAVENAME: if (not IsPlayObject) or (not ConditionOfCHECKSIDESLAVENAME(PlayObject, QuestConditionInfo)) then Result := False;//检查人物周围自己宝宝数量 20080425
          nSC_CHECKCURRENTDATE: if not ConditionOfCHECKCURRENTDATE(PlayObject, QuestConditionInfo) then Result := False;//检测当前日期是否小于大于等于指定的日期 20080416
          nSC_CHECKMASTERONLINE: if (not IsPlayObject) or (not ConditionOfCHECKMASTERONLINE(PlayObject, QuestConditionInfo)) then Result := False;//检测师傅（或徒弟）是否在线  20080416
          nSC_CHECKDEARONLINE: if (not IsPlayObject) or (not ConditionOfCHECKDEARONLINE(PlayObject, QuestConditionInfo)) then Result := False;//检测夫妻一方是否在线  20080416
          nSC_CHECKMASTERONMAP: if (not IsPlayObject) or (not ConditionOfCHECKMASTERONMAP(PlayObject, QuestConditionInfo)) then Result := False;//检测师傅（或徒弟）是否在XXX地图，支持SELF（是否同一地图）  20080416
          nSC_CHECKDEARONMAP: if (not IsPlayObject) or (not ConditionOfCHECKDEARONMAP(PlayObject, QuestConditionInfo)) then Result := False;//检测夫妻一方是否在XXX地图，支持SELF（是否同一地图）  20080416
          nSC_CHECKPOSEISPRENTICE: if (not IsPlayObject) or (not ConditionOfCHECKPOSEISPRENTICE(PlayObject, QuestConditionInfo)) then Result := False;//检测对面是否为自己的徒弟  20080416
          nSC_CHECKCASTLEWAR: if not ConditionOfCHECKCASTLEWAR(PlayObject, QuestConditionInfo) then Result := False;//检查是否在攻城期间 20080422
          nSC_FINDMAPPATH: if not ConditionOfFINDMAPPATH(PlayObject, QuestConditionInfo) then Result := False;//设置地图的起终XY值 20080124
          //检测英雄的忠诚度 20080109
          nSC_CHECKHEROLOYAL: if not ConditionOfCHECKHEROLOYAL(PlayObject, QuestConditionInfo) then Result := False;
          nISONMAKEWINE: if (not IsPlayObject) or (not ConditionOfISONMAKEWINE(PlayObject, QuestConditionInfo)) then Result := False;//判断是否在酿哪种酒 20080620
          nCHECKGUILDFOUNTAIN: if (not IsPlayObject) or (not ConditionOfCHECKGUILDFOUNTAIN(PlayObject, QuestConditionInfo)) then Result := False;//判断是否开启行会泉水仓库  20080625

          nSC_CHECKGAMEPOINT: if (not IsPlayObject) or (not ConditionOfCheckGamePoint(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKNAMELISTPOSITION: if not ConditionOfCheckNameListPostion(PlayObject, QuestConditionInfo) then Result := False;
          nSC_CHECKGUILDLIST: begin
              if IsPlayObject and (PlayObject.m_MyGuild <> nil) then begin
                if not CheckStringList(TGUild(PlayObject.m_MyGuild).sGuildName, m_sPath + QuestConditionInfo.sParam1) then Result := False;
              end else Result := False;
            end;
          nSC_CHECKRENEWLEVEL: if (not IsPlayObject) or (not ConditionOfCheckReNewLevel(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKSLAVELEVEL: if not ConditionOfCheckSlaveLevel(PlayObject, QuestConditionInfo) then Result := False;
          nSC_CHECKSLAVETOPEST: if not ConditionOfCHECKSLAVETOPEST(PlayObject, QuestConditionInfo) then Result := False;
          nSC_CHECKSLAVENAME: if not ConditionOfCheckSlaveName(PlayObject, QuestConditionInfo) then Result := False;
          nSC_CHECKCREDITPOINT: if (not IsPlayObject) or (not ConditionOfCheckCreditPoint(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKOFGUILD: if (not IsPlayObject) or (not ConditionOfCheckOfGuild(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKPAYMENT: if (not IsPlayObject) or (not ConditionOfCheckPayMent(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKUSEITEM: if not ConditionOfCheckUseItem(PlayObject, QuestConditionInfo) then Result := False;
          nSC_CHECKBAGSIZE: if not ConditionOfCheckBagSize(PlayObject, QuestConditionInfo) then Result := False;
          nSC_CHECKDC: if not ConditionOfCheckDC(PlayObject, QuestConditionInfo) then Result := False;
          nSC_CHECKMC: if not ConditionOfCheckMC(PlayObject, QuestConditionInfo) then Result := False;
          nSC_CHECKSC: if not ConditionOfCheckSC(PlayObject, QuestConditionInfo) then Result := False;
          nSC_CHECKHP: if not ConditionOfCheckHP(PlayObject, QuestConditionInfo) then Result := False;
          nSC_CHECKMP: if not ConditionOfCheckMP(PlayObject, QuestConditionInfo) then Result := False;
          nSC_CHECKITEMTYPE: if not ConditionOfCheckItemType(PlayObject, QuestConditionInfo) then Result := False;
          nSC_CHECKEXP: if not ConditionOfCheckExp(PlayObject, QuestConditionInfo) then Result := False;
          nSC_CHECKCASTLEGOLD: if (not IsPlayObject) or (not ConditionOfCheckCastleGold(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_PASSWORDERRORCOUNT: if (not IsPlayObject) or (not ConditionOfCheckPasswordErrorCount(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_ISLOCKPASSWORD: if (not IsPlayObject) or (not ConditionOfIsLockPassword(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_ISLOCKSTORAGE: if (not IsPlayObject) or (not ConditionOfIsLockStorage(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKBUILDPOINT: if (not IsPlayObject) or (not ConditionOfCheckGuildBuildPoint(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKAURAEPOINT: if (not IsPlayObject) or (not ConditionOfCheckGuildAuraePoint(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKSTABILITYPOINT: if (not IsPlayObject) or (not ConditionOfCheckStabilityPoint(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKFLOURISHPOINT: if (not IsPlayObject) or (not ConditionOfCheckFlourishPoint(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKCONTRIBUTION: if (not IsPlayObject) or (not ConditionOfCheckContribution(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKRANGEMONCOUNT: if (not IsPlayObject) or (not ConditionOfCheckRangeMonCount(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_ISONMAP: if not ConditionOfISONMAP(PlayObject, QuestConditionInfo) then Result := False;//检测地图命令  20080426
          nSC_CHECKITEMADDVALUE: if not ConditionOfCheckItemAddValue(PlayObject, QuestConditionInfo) then Result := False;//检查人物身上物品的附加属性值  20080426
          nSC_CHECKITEMADDVALUEEx: if not ConditionOfCheckItemAddValueEx(PlayObject, QuestConditionInfo) then Result := False;//检查人物身上物品的鉴定相关属性 20110724
          nSC_CHECKINMAPRANGE: if (not IsPlayObject) or (not ConditionOfCheckInMapRange(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CASTLECHANGEDAY: if (not IsPlayObject) or (not ConditionOfCheckCastleChageDay(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CASTLEWARDAY: if (not IsPlayObject) or (not ConditionOfCheckCastleWarDay(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_ONLINELONGMIN: if not ConditionOfCheckOnlineLongMin(PlayObject, QuestConditionInfo) then Result := False;
          nSC_CHECKGUILDCHIEFITEMCOUNT: if (not IsPlayObject) or (not ConditionOfCheckChiefItemCount(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKNAMEDATELIST, nSC_CHECKUSERDATE: if (not IsPlayObject) or (not ConditionOfCheckNameDateList(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKMAPHUMANCOUNT: if (not IsPlayObject) or (not ConditionOfCheckMapHumanCount(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKMAPHUMAICOUNT: if (not IsPlayObject) or (not ConditionOfCheckMapHumAICount(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKMAPMONCOUNT: if (not IsPlayObject) or (not ConditionOfCheckMapMonCount(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKVAR: if (not IsPlayObject) or (not ConditionOfCheckVar(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKSERVERNAME: if (not IsPlayObject) or (not ConditionOfCheckServerName(PlayObject, QuestConditionInfo)) then Result := False;
          nCHECKMAPNAME: if (not IsPlayObject) or (not ConditionOfCheckMapName(PlayObject, QuestConditionInfo)) then Result := False;

          nINSAFEZONE: if not ConditionOfCheckSafeZone(PlayObject, QuestConditionInfo) then Result := False;
          nCHECKSKILL: if not ConditionOfCheckSkill(PlayObject, QuestConditionInfo) then Result := False;
          nHEROCHECKSKILL: if not ConditionOfHEROCHECKSKILL(PlayObject, QuestConditionInfo) then Result := False;//检查英雄技能 20080423
          nSC_CHECKCONTAINSTEXT: if (not IsPlayObject) or (not ConditionOfAnsiContainsText(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_COMPARETEXT: if (not IsPlayObject) or (not ConditionOfCompareText(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKTEXTLIST: begin//20080929 修改
              if IsPlayObject then begin
                s01 := QuestConditionInfo.sParam1;
                if (s01 <> '') and (s01[1] = '<') and (s01[2] = '$') then//增加支持<$Str()>  20081230
                   s01 := GetLineVariableText(PlayObject, QuestConditionInfo.sParam1)
                else GetValValue(PlayObject, QuestConditionInfo.sParam1, s01);
                s02 := GetLineVariableText(PlayObject, QuestConditionInfo.sParam2);//20090102 路径支持变量
                if s02 <> '' then begin
                  if s02[1] = '\' then s02 := Copy(s02, 2, Length(s02) - 1);
                  if s02[2] = '\' then s02 := Copy(s02, 3, Length(s02) - 2);
                  if s02[3] = '\' then s02 := Copy(s02, 4, Length(s02) - 3);
                end;
                if not CheckStringList(s01, {m_sPath +} s02) then Result := False;
              end else Result := False;
            end;
          nSC_ISGROUPMASTER: begin//检查是否是队长
              if (not IsPlayObject) or (PlayObject.m_GroupOwner <> PlayObject) then
                Result := False;
            end;
          nSC_ISOPENBOX: begin//检查是否正在打开箱子
              if (not IsPlayObject) or (not PlayObject.m_boOpenBox) then Result := False;
            end;
          nSC_CHECKCONTAINSTEXTLIST: begin//20080929 修改 判断字符串包含在文件里
              if IsPlayObject then begin
                s01 := QuestConditionInfo.sParam1;
                GetValValue(PlayObject, QuestConditionInfo.sParam1, s01);
                if QuestConditionInfo.sParam2 <> '' then begin
                  if QuestConditionInfo.sParam2[1] = '\' then s02 := Copy(QuestConditionInfo.sParam2, 2, Length(QuestConditionInfo.sParam2) - 1);
                  if QuestConditionInfo.sParam2[2] = '\' then s02 := Copy(QuestConditionInfo.sParam2, 3, Length(QuestConditionInfo.sParam2) - 2);
                  if QuestConditionInfo.sParam2[3] = '\' then s02 := Copy(QuestConditionInfo.sParam2, 4, Length(QuestConditionInfo.sParam2) - 3);
                end;
                s02 := GetLineVariableText(PlayObject, s02);//20090102 路径支持变量
                if not CheckAnsiContainsTextList(s01, {m_sPath +} s02) then Result := False;
              end else Result := False;
            end;
          nSC_CHECKLISTTEXT:begin //检查文件是否包含指定文本 20080428
              if IsPlayObject then begin
                s01 := QuestConditionInfo.sParam2;
                if (s01 <> '') and (s01[1] = '<') and (s01[2] = '$') then//增加支持<$Str()>
                   s01 := GetLineVariableText(PlayObject, QuestConditionInfo.sParam2)
                else GetValValue(PlayObject, QuestConditionInfo.sParam2, s01);
                if QuestConditionInfo.sParam1 <> '' then begin
                  if QuestConditionInfo.sParam1[1] = '\' then s02 := Copy(QuestConditionInfo.sParam1, 2, Length(QuestConditionInfo.sParam1) - 1);
                  if QuestConditionInfo.sParam1[2] = '\' then s02 := Copy(QuestConditionInfo.sParam1, 3, Length(QuestConditionInfo.sParam1) - 2);
                  if QuestConditionInfo.sParam1[3] = '\' then s02 := Copy(QuestConditionInfo.sParam1, 4, Length(QuestConditionInfo.sParam1) - 3);
                end;
                s02 := GetLineVariableText(PlayObject, s02);//20080602 路径支持变量
                if not CheckTextInList(s01, s02) then Result := False;
              end else Result := False;
            end;
          nSC_CHECKONLINE: begin//检查玩家是否在线
              s01 := QuestConditionInfo.sParam1;
              if (s01 <> '') and (s01[1] = '<') and (s01[2] = '$') then//增加支持<$Str()> 20080422
                 s01 := GetLineVariableText(PlayObject, QuestConditionInfo.sParam1)
              else GetValValue(PlayObject, QuestConditionInfo.sParam1, s01);
              if (s01 = '') or (UserEngine.GetPlayObject(s01) = nil) then Result := False;
            end;
          nSC_ISDUPMODE: begin//检测人物是否重叠
              if PlayObject.m_PEnvir <> nil then begin
                if PlayObject.m_PEnvir.GetXYObjCount(PlayObject.m_nCurrX, PlayObject.m_nCurrY) <= 1 then Result := False;
              end else Result := False;
            end;
          nSC_ISOFFLINEMODE: begin //检测是否是离线挂机人物
              if IsPlayObject then begin
                if not PlayObject.m_boNotOnlineAddExp then Result := False;
              end else Result := False;
            end;
          ///Add By TasNat at: 2012-04-23 17:22:37
          nSC_CHECKRANGEMONEx: if (not IsPlayObject) or (not ConditionOfCheckRangeMonEx(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_ISINGROUP: begin//检查队伍中是否有此成员
              if (not IsPlayObject) or (not ConditionOfCheckIsInGroup(PlayObject, QuestConditionInfo)) then Result := False;
            end;
          nSC_CHECKBAGITEMS: //检测背包是否有某些物品
              if (not ConditionOfCheckBagItems(PlayObject, QuestConditionInfo)) then Result := False;

          //AddEnd
          nSC_CHECKSTATIONTIME: if not ConditionOfCheckStationTime(PlayObject, QuestConditionInfo) then Result := False; //检测人物站立时间
          nSC_CHECKSIGNMAP: if PlayObject.m_btLastOutStatus <> 1 then Result := False; //检测最后退出状态
          nSC_CHECKMINE: if not ConditionOfCHECKMINE(PlayObject, QuestConditionInfo) then Result := False;//检测矿纯度  20080324
          nSC_CHECKITMECOUNTDURA: if not ConditionOfCheckItmeCountDura(PlayObject, QuestConditionInfo) then Result := False;//检查物品数量以及持久值 20090913
          nSC_MAPHUMISSAMEGUILD: if (not IsPlayObject) or (not ConditionOfMapHumIsSameGuild(PlayObject, QuestConditionInfo)) then Result := False;//检测当前地图中的人物是否属于同一个行会
          nSC_CHECKHEARMSGCOLOR: if (not IsPlayObject) or (not ConditionOfCHECKHEARMSGCOLOR(PlayObject, QuestConditionInfo)) then Result := False;//检查是否正在使用改变文字颜色功能 20090306
          //=================================英雄相关=====================================
          {$IF HEROVERSION = 1}
          nSC_HAVEHERO: if (not IsPlayObject) or (not ConditionOfCheckHasHero(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKDEPUTYHERO: if (not IsPlayObject) or (not ConditionOfCheckDeputyHero(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKASSESSMENTHERO: if (not IsPlayObject) or (PlayObject.n_HeroSave <> 2) then Result := False;//检查是否评定过英雄
          nSC_CHECKHEROAUTOPRACTICE: if (not IsPlayObject) or (not ConditionOfCheckHeroAutoPractice(PlayObject, QuestConditionInfo)) then Result := False;
          nSC_CHECKHEROONLINE: if not ConditionOfCheckHeroOnline(PlayObject, QuestConditionInfo) then Result := False;
          nSC_CHECKHEROLEVEL: if not ConditionOfCheckHeroLevel(PlayObject, QuestConditionInfo) then Result := False;
          nSC_CHECKHEROJOB: if not ConditionOfCheckHeroJob(PlayObject, QuestConditionInfo) then Result := False;
          {$IFEND}
          //插件命令 20080807
          nSC_CHECKONLINEPLAYCOUNT: if not ConditionOfCHECKONLINEPLAYCOUNT(PlayObject, QuestConditionInfo) then Result := False;
          nSC_CHECKPLAYDIELVL,nSC_CHECKKILLPLAYLVL: if not ConditionOfCheckPlaylvl(PlayObject, QuestConditionInfo) then Result := False;
          nSC_CHECKPLAYDIEJOB,nSC_CHECKKILLPLAYJOB: if not ConditionOfCheckPlayJob(PlayObject, QuestConditionInfo) then Result := False;
          nSC_CHECKPLAYDIESEX,nSC_CHECKKILLPLAYSEX: if not ConditionOfCheckPlaySex(PlayObject, QuestConditionInfo) then Result := False;
          nSC_CHECKBAGITEMLEVEL: if not ConditionOfCHECKBAGITEMLEVEL(PlayObject, QuestConditionInfo) then Result := False;//检查包裹中装备升级次数
          nSC_CHECKITEMLEVEL: if not ConditionOfCHECKITEMLEVEL(PlayObject, QuestConditionInfo) then Result := False;//检查装备升级次数 20080816
          nSC_CHECKMAKEWINE: if not ConditionOfCHECKMAKEWINE(PlayObject, QuestConditionInfo) then Result := False;//检查酒的属性  20080806
          nSC_CHECKHEROPKPOINT: if not ConditionOfCHECKHEROPKPOINT(PlayObject, QuestConditionInfo) then Result := False;//检测英雄PK值  20080304
          nSC_CHECKCODELIST: if (not IsPlayObject) or (not ConditionOfCHECKCODELIST(PlayObject, QuestConditionInfo)) then Result := False;//检测文本里的编码是否存在  20080410
          nCHECKITEMSTATE: if not ConditionOfCHECKITEMSTATE(PlayObject, QuestConditionInfo) then Result := False;//检查装备绑定状态  20080312
          nCHECKITEMSNAME: if not ConditionOfCHECKITEMSNAME(PlayObject, QuestConditionInfo) then Result := False;//检查指定装备位置是否带有指定的物品 20080825
          nCHECKGUILDMEMBERCOUNT: if (not IsPlayObject) or (not ConditionOfCHECKGUILDMEMBERCOUNT(PlayObject, QuestConditionInfo)) then Result := False;//检测行会成员上限 20090115
          nCHECKGUILDCOUNT: if (not IsPlayObject) or (not ConditionOfCHECKGUILDCOUNT(PlayObject, QuestConditionInfo)) then Result := False;//检测行会成员人数 20090607
          nCHECKGUILDFOUNTAINVALUE: if (not IsPlayObject) or (not ConditionOfCHECKGUILDFOUNTAINValue(PlayObject, QuestConditionInfo)) then Result := False;//检测行会酒泉数
          {$IF M2Version <> 2}
          nCHECKNGLEVEL: if not ConditionOfCHECKNGLEVEL(PlayObject, QuestConditionInfo) then Result := False;//检查角色内功等级 20081223
          nSC_CHANGREADNG: if not ConditionOfCHANGREADNG(PlayObject, QuestConditionInfo) then Result := False;//检查是否学过内功 20081002
          {$IFEND}
          nKILLBYHUM: begin//检测是否被人物所杀 20080826
              if PlayObject.m_boDeath and (PlayObject.m_LastHiter <> nil) then begin
                if (PlayObject.m_LastHiter.m_btRaceServer <> RC_PLAYOBJECT) and (PlayObject.m_LastHiter.m_btRaceServer <> RC_HEROOBJECT) then Result := False;
              end else Result := False;
            end;
          nISHIGH: if not ConditionOfISHIGH(PlayObject, QuestConditionInfo) then Result := False;//检测服务器最高属性人物命令 20080313
          nSC_ISAI: if not PlayObject.m_boAI then Result := False;
        end;
        if not Result then Break;
      end;
    end;
  end;
  function JmpToLable(sLabel: string): Boolean;
  begin
    Result := False;
    if (IsPlayObject) then begin
      Inc(PlayObject.m_nScriptGotoCount);
      if PlayObject.m_nScriptGotoCount > g_Config.nScriptGotoCountLimit {10} then Exit;
      GotoLable(PlayObject, sLabel, False, False);
    end else begin
      if BaseObject.m_Master <> nil then begin
        Inc(TPlayObject(BaseObject.m_Master).m_nScriptGotoCount);
        if TPlayObject(BaseObject.m_Master).m_nScriptGotoCount > g_Config.nScriptGotoCountLimit {10} then Exit;
        GotoLable(TPlayObject(BaseObject.m_Master), sLabel, False, False);
      end;
    end;
    Result := True;
  end;
  procedure GoToQuest(nQuest: Integer);
  var
    I: Integer;
    Script: pTScript;
  begin
    if m_ScriptList.Count > 0 then begin//20080629
      for I := 0 to m_ScriptList.Count - 1 do begin
        Script := m_ScriptList.Items[I];
        if Script.nQuest = nQuest then begin
          AObject.m_Script := Script;
          AObject.m_NPC := Self;
          GotoLable(AObject, sMAIN, False, False);
          Break;
        end;
      end;
    end;
  end;

  procedure AddList(sHumName, sListFileName: string; boCheck: Boolean);
  var
    I: Integer;
    sLoadList: TStringList;
    s10: string;
    bo15: Boolean;
  begin
    sListFileName := g_Config.sEnvirDir + sListFileName;
    sLoadList := TStringList.Create;
    try
      try
        if FileExists(sListFileName) then begin
          try
            sLoadList.LoadFromFile(sListFileName);
          except
            MainOutMessage('文件读取失败(AddList) => ' + sListFileName);
          end;
        end;
        bo15 := False;
        if (sLoadList.Count > 0) and boCheck then begin//20090621 修改
          for I := 0 to sLoadList.Count - 1 do begin
            s10 := Trim(sLoadList.Strings[I]);
            if CompareText(sHumName, s10) = 0 then begin
              bo15 := True;
              Break;
            end;
          end;
        end;
        if not bo15 then begin
          sLoadList.Add(sHumName);
          try
            sLoadList.SaveToFile(sListFileName);
          except
            MainOutMessage('文件保存失败 => ' + sListFileName);
          end;
        end;
      except//20090222 FileExists 出异常
        MainOutMessage('文件不能打开 => ' + sListFileName);
      end;
    finally
      sLoadList.Free;
    end;
  end;

  procedure DelList(sHumName, sListFileName: string);
  var
    I: Integer;
    LoadList: TStringList;
    s10: string;
    bo15: Boolean;
  begin
    sListFileName := g_Config.sEnvirDir + sListFileName;
    LoadList := TStringList.Create;
    try
      if FileExists(sListFileName) then begin
        try
          LoadList.LoadFromFile(sListFileName);
        except
          MainOutMessage('文件读取失败4.... => ' + sListFileName);
        end;
      end;
      bo15 := False;
      if LoadList.Count > 0 then begin//20080629
        for I := 0 to LoadList.Count - 1 do begin
          if LoadList.Count <= 0 then Break;
          s10 := Trim(LoadList.Strings[I]);
          if CompareText(sHumName, s10) = 0 then begin
            LoadList.Delete(I);
            bo15 := True;
            Break;
          end;
        end;
      end;
      if bo15 then begin
        try
          LoadList.SaveToFile(sListFileName);
        except
          MainOutMessage('文件保存失败 => ' + sListFileName);
        end;
      end;
    finally
      LoadList.Free;
    end;
  end;

  procedure TakeItem(sItemName: string; nItemCount: Integer; sVarNo, sHero: string);
  var
    I: Integer;
    UserItem: pTUserItem;
    StdItem: pTStdItem;
    nCount: Integer;
    sName: string;
  begin
    PlayObject.m_boCanQueryBag:= True;//NPC操作物品时,不能刷新包裹 20080917
    Try
      sName := GetLineVariableText(PlayObject, sItemName);//20080601 支持变量
      nCount := Str_ToInt(GetLineVariableText(PlayObject, sVarNo), 0);//20080601 支持变量
      if nCount = 0 then GetValValue(PlayObject, sVarNo, nCount);//20110902 增加
      if nCount <= 0 then Exit;
      if CompareText( sHero, 'HERO') = 0 then begin//支持取英雄物品 20090323
        {$IF HEROVERSION = 1}
        if PlayObject.m_MyHero <> nil then begin
          try
            for I := PlayObject.m_MyHero.m_ItemList.Count - 1 downto 0 do begin
              if nCount <= 0 then Break;
              if PlayObject.m_MyHero.m_ItemList.Count <= 0 then Break;
              UserItem := PlayObject.m_MyHero.m_ItemList.Items[I];
              if UserItem = nil then Continue;
              if CompareText(UserEngine.GetStdItemName(UserItem.wIndex), sName) = 0 then begin
                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                if StdItem <> nil then begin
                  if StdItem.NeedIdentify = 1 then
                    AddGameDataLog('10' + #9 + PlayObject.m_MyHero.m_sMapName + #9 +
                      IntToStr(PlayObject.m_MyHero.m_nCurrX) + #9 + IntToStr(PlayObject.m_MyHero.m_nCurrY) + #9 +
                      PlayObject.m_MyHero.m_sCharName + #9 + sName + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                      '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                      '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                      '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                      '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                      '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                      IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                      IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                      IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                      IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                  PlayObject.m_MyHero.m_ItemList.Delete(I);
                  THeroObject(PlayObject.m_MyHero).SendDelItems(UserItem);
                  SC := StdItem.Name;
                  //DisPoseAndNil(UserItem);
                  DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 By TasNat at: 2012-03-17
                  UserItem := nil;
                  Dec(nCount);
                end;//if StdItem <> nil
              end;
            end;
          except
            MainOutMessage(Format('{%s} TakeItem hero',[g_sExceptionVer]));
          end;
        end;
        {$IFEND}
      end else begin
        if CompareText(sName, sSTRING_GOLDNAME) = 0 then begin
          PlayObject.DecGold(nCount);
          PlayObject.GoldChanged();
          if g_boGameLogGold then
            AddGameDataLog('10' + #9 + PlayObject.m_sMapName + #9 +
              IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
              PlayObject.m_sCharName + #9 + sSTRING_GOLDNAME + #9 +
              IntToStr(nCount) + #9 +'1' + #9 + m_sCharName);
          Exit;
        end;
        try
          for I := PlayObject.m_ItemList.Count - 1 downto 0 do begin
            if nCount <= 0 then Break;
            if PlayObject.m_ItemList.Count <= 0 then Break;//20080917
            UserItem := PlayObject.m_ItemList.Items[I];
            if UserItem = nil then Continue;
            if CompareText(UserEngine.GetStdItemName(UserItem.wIndex), sName) = 0 then begin
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem <> nil then begin  //20081006 修改
                if StdItem.NeedIdentify = 1 then
                  AddGameDataLog('10' + #9 + PlayObject.m_sMapName + #9 +
                    IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                    PlayObject.m_sCharName + #9 + sName + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                    '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                    '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                    '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                    '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                    '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                    IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                    IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                    IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                    IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                PlayObject.m_ItemList.Delete(I);
                PlayObject.SendDelItems(UserItem);
                SC := StdItem.Name{UserEngine.GetStdItemName(UserItem.wIndex)};//20081006 修改
                //DisPoseAndNil(UserItem);
                DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 By TasNat at: 2012-03-17
                UserItem := nil;
                Dec(nCount);
              end;//if StdItem <> nil
            end;
          end;
        except
          MainOutMessage(Format('{%s} TakeItem',[g_sExceptionVer]));
        end;
      end;
    finally
      PlayObject.m_boCanQueryBag:= False;//NPC操作物品时,不能刷新包裹 20080917
    end;
  end;

  procedure TakeWItem(sItemName: string; nItemCount: Integer);
  var
    I: Integer;
    sName: string;
    HeroObject: THeroObject;
    boOK: Boolean;
  begin
    HeroObject := nil;
    if IsHeroObject then HeroObject := THeroObject(BaseObject);

    if CompareLStr(sItemName, '[NECKLACE]', 4) then begin
      if BaseObject.m_UseItems[U_NECKLACE].wIndex > 0 then begin
        if IsPlayObject then begin
          PlayObject.SendDelItems(@BaseObject.m_UseItems[U_NECKLACE]);
        end else begin
          HeroObject.SendDelItems(@BaseObject.m_UseItems[U_NECKLACE]);
        end;
        //SC := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_NECKLACE].wIndex);
        BaseObject.m_UseItems[U_NECKLACE].wIndex := 0;
        BaseObject.RecalcAbilitys();//20110216
        BaseObject.CompareSuitItem(False);//20110216
        Exit;
      end;
    end;
    if CompareLStr(sItemName, '[RING]', 4) then begin
      if BaseObject.m_UseItems[U_RINGL].wIndex > 0 then begin
        if IsPlayObject then begin
          PlayObject.SendDelItems(@BaseObject.m_UseItems[U_RINGL]);
        end else begin
          HeroObject.SendDelItems(@BaseObject.m_UseItems[U_RINGL]);
        end;
        //SC := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_RINGL].wIndex);
        BaseObject.m_UseItems[U_RINGL].wIndex := 0;
        BaseObject.RecalcAbilitys();//20110216
        BaseObject.CompareSuitItem(False);//20110216
        Exit;
      end;
      if BaseObject.m_UseItems[U_RINGR].wIndex > 0 then begin
        if IsPlayObject then begin
          PlayObject.SendDelItems(@BaseObject.m_UseItems[U_RINGR]);
        end else begin
          HeroObject.SendDelItems(@BaseObject.m_UseItems[U_RINGR]);
        end;
        //SC := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_RINGR].wIndex);
        BaseObject.m_UseItems[U_RINGR].wIndex := 0;
        BaseObject.RecalcAbilitys();//20110216
        BaseObject.CompareSuitItem(False);//20110216
        Exit;
      end;
    end;
    if CompareLStr(sItemName, '[ARMRING]', 4) then begin
      if BaseObject.m_UseItems[U_ARMRINGL].wIndex > 0 then begin
        if IsPlayObject then begin
          PlayObject.SendDelItems(@BaseObject.m_UseItems[U_ARMRINGL]);
        end else begin
          HeroObject.SendDelItems(@BaseObject.m_UseItems[U_ARMRINGL]);
        end;
        //SC := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_ARMRINGL].wIndex);
        BaseObject.m_UseItems[U_ARMRINGL].wIndex := 0;
        BaseObject.RecalcAbilitys();//20110216
        BaseObject.CompareSuitItem(False);//20110216
        Exit;
      end;
      if BaseObject.m_UseItems[U_ARMRINGR].wIndex > 0 then begin
        if IsPlayObject then begin
          PlayObject.SendDelItems(@BaseObject.m_UseItems[U_ARMRINGR]);
        end else begin
          HeroObject.SendDelItems(@BaseObject.m_UseItems[U_ARMRINGR]);
        end;
        //SC := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_ARMRINGR].wIndex);
        BaseObject.m_UseItems[U_ARMRINGR].wIndex := 0;
        BaseObject.RecalcAbilitys();//20110216
        BaseObject.CompareSuitItem(False);//20110216
        Exit;
      end;
    end;
    if CompareLStr(sItemName, '[WEAPON]', 4) then begin
      if BaseObject.m_UseItems[U_WEAPON].wIndex > 0 then begin
        if IsPlayObject then begin
          PlayObject.SendDelItems(@BaseObject.m_UseItems[U_WEAPON]);
        end else begin
          HeroObject.SendDelItems(@BaseObject.m_UseItems[U_WEAPON]);
        end;
        //SC := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_WEAPON].wIndex);
        BaseObject.m_UseItems[U_WEAPON].wIndex := 0;
        BaseObject.RecalcAbilitys();//20110216
        BaseObject.CompareSuitItem(False);//20110216
        Exit;
      end;
    end;
    if CompareLStr(sItemName, '[HELMET]', 4) then begin
      if BaseObject.m_UseItems[U_HELMET].wIndex > 0 then begin
        if IsPlayObject then begin
          PlayObject.SendDelItems(@BaseObject.m_UseItems[U_HELMET]);
        end else begin
          HeroObject.SendDelItems(@BaseObject.m_UseItems[U_HELMET]);
        end;
        //SC := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_HELMET].wIndex);
        BaseObject.m_UseItems[U_HELMET].wIndex := 0;
        BaseObject.RecalcAbilitys();//20110216
        BaseObject.CompareSuitItem(False);//20110216
        Exit;
      end;
    end;
    if CompareLStr(sItemName, '[ZHULI]', 4) then begin //20080416 斗笠
      if BaseObject.m_UseItems[U_ZHULI].wIndex > 0 then begin
        if IsPlayObject then begin
          PlayObject.SendDelItems(@BaseObject.m_UseItems[U_ZHULI]);
        end else begin
          HeroObject.SendDelItems(@BaseObject.m_UseItems[U_ZHULI]);
        end;
        //SC := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_ZHULI].wIndex);
        BaseObject.m_UseItems[U_ZHULI].wIndex := 0;
        BaseObject.RecalcAbilitys();//20110216
        BaseObject.CompareSuitItem(False);//20110216
        Exit;
      end;
    end;
    if CompareLStr(sItemName, '[DRESS]', 4) then begin
      if BaseObject.m_UseItems[U_DRESS].wIndex > 0 then begin
        if IsPlayObject then begin
          PlayObject.SendDelItems(@BaseObject.m_UseItems[U_DRESS]);
        end else begin
          HeroObject.SendDelItems(@BaseObject.m_UseItems[U_DRESS]);
        end;
        //SC := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_DRESS].wIndex);
        BaseObject.m_UseItems[U_DRESS].wIndex := 0;
        BaseObject.RecalcAbilitys();//20110216
        BaseObject.CompareSuitItem(False);//20110216
        Exit;
      end;
    end;
    if CompareLStr(sItemName, '[U_BUJUK]', 4) then begin
      if BaseObject.m_UseItems[U_BUJUK].wIndex > 0 then begin
        if IsPlayObject then begin
          PlayObject.SendDelItems(@BaseObject.m_UseItems[U_BUJUK]);
        end else begin
          HeroObject.SendDelItems(@BaseObject.m_UseItems[U_BUJUK]);
        end;
        //SC := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_BUJUK].wIndex);
        BaseObject.m_UseItems[U_BUJUK].wIndex := 0;
        BaseObject.RecalcAbilitys();//20110216
        BaseObject.CompareSuitItem(False);//20110216
        Exit;
      end;
    end;
    if CompareLStr(sItemName, '[U_BELT]', 4) then begin
      if BaseObject.m_UseItems[U_BELT].wIndex > 0 then begin
        if IsPlayObject then begin
          PlayObject.SendDelItems(@BaseObject.m_UseItems[U_BELT]);
        end else begin
          HeroObject.SendDelItems(@BaseObject.m_UseItems[U_BELT]);
        end;
        //SC := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_BELT].wIndex);
        BaseObject.m_UseItems[U_BELT].wIndex := 0;
        BaseObject.RecalcAbilitys();//20110216
        BaseObject.CompareSuitItem(False);//20110216
        Exit;
      end;
    end;
    if CompareLStr(sItemName, '[U_BOOTS]', 4) then begin
      if BaseObject.m_UseItems[U_BOOTS].wIndex > 0 then begin
        if IsPlayObject then begin
          PlayObject.SendDelItems(@BaseObject.m_UseItems[U_BOOTS]);
        end else begin
          HeroObject.SendDelItems(@BaseObject.m_UseItems[U_BOOTS]);
        end;
        //SC := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_BOOTS].wIndex);
        BaseObject.m_UseItems[U_BOOTS].wIndex := 0;
        BaseObject.RecalcAbilitys();//20110216
        BaseObject.CompareSuitItem(False);//20110216
        Exit;
      end;
    end;
    if CompareLStr(sItemName, '[U_DRUM]', 4) then begin
      if BaseObject.m_UseItems[U_DRUM].wIndex > 0 then begin
        if IsPlayObject then begin
          PlayObject.SendDelItems(@BaseObject.m_UseItems[U_DRUM]);
        end else begin
          HeroObject.SendDelItems(@BaseObject.m_UseItems[U_DRUM]);
        end;
        //SC := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_BOOTS].wIndex);
        BaseObject.m_UseItems[U_DRUM].wIndex := 0;
        BaseObject.RecalcAbilitys();//20110216
        BaseObject.CompareSuitItem(False);//20110216
        Exit;
      end;
    end;
    if CompareLStr(sItemName, '[U_CHARM]', 4) then begin
      if BaseObject.m_UseItems[U_CHARM].wIndex > 0 then begin
        if IsPlayObject then begin
          PlayObject.SendDelItems(@BaseObject.m_UseItems[U_CHARM]);
        end else begin
          HeroObject.SendDelItems(@BaseObject.m_UseItems[U_CHARM]);
        end;
        //SC := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_CHARM].wIndex);
        BaseObject.m_UseItems[U_CHARM].wIndex := 0;
        BaseObject.RecalcAbilitys();//20110216
        BaseObject.CompareSuitItem(False);//20110216
        Exit;
      end;
    end;
    boOK:= False;
    for I := Low(THumanUseItems) to High(THumanUseItems) do begin//9格装备+4格装备
      if nItemCount <= 0 then Break;
      if BaseObject.m_UseItems[I].wIndex > 0 then begin
        sName := UserEngine.GetStdItemName(BaseObject.m_UseItems[I].wIndex);
        if CompareText(sName, sItemName) = 0 then begin
          if IsPlayObject then begin
            PlayObject.SendDelItems(@BaseObject.m_UseItems[I]);
          end else begin
            HeroObject.SendDelItems(@BaseObject.m_UseItems[I]);
          end;
          BaseObject.m_UseItems[I].wIndex := 0;
          boOK:= True;
          Dec(nItemCount);
        end;
      end;
    end;
    if boOK then begin
      BaseObject.RecalcAbilitys();//20110216
      BaseObject.CompareSuitItem(False);//20110216
    end;
  end;

  procedure MovData(QuestActionInfo: pTQuestActionInfo);
    function GetHumanInfoValue(sVariable: string; var sValue: string; var nValue: Integer; var nDataType: Integer): Boolean;
    var
      sMsg, s10: string;
      sVarValue2: string;
      I, nSecond:Integer;
      DynamicVar: pTDynamicVar;
      wHour,wMinute,wSecond: Word;
    begin
      sValue := '';
      nValue := -1;
      nDataType := -1;
      Result := False;
      if sVariable = '' then Exit;
      sMsg := sVariable;
      ArrestStringEx(sMsg, '<', '>', s10);
      if s10 = '' then Exit;
      sVariable := s10;

      //全局信息
      if sVariable = '$SERVERNAME' then begin
        sValue := g_Config.sServerName;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$SERVERIP' then begin
        sValue :=  g_Config.sServerIPaddr;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$WEBSITE' then begin
        sValue :=  g_Config.sWebSite;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$BBSSITE' then begin
        sValue := g_Config.sBbsSite;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$CLIENTDOWNLOAD' then begin
        sValue := g_Config.sClientDownload;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$QQ' then begin
        sValue := g_Config.sQQ;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$PHONE' then begin
        sValue := g_Config.sPhone;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$BANKACCOUNT0' then begin
        sValue := g_Config.sBankAccount0;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$BANKACCOUNT1' then begin
        sValue := g_Config.sBankAccount1;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$BANKACCOUNT2' then begin
        sValue := g_Config.sBankAccount2;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$BANKACCOUNT3' then begin
        sValue := g_Config.sBankAccount3;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$BANKACCOUNT4' then begin
        sValue := g_Config.sBankAccount4;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$BANKACCOUNT5' then begin
        sValue := g_Config.sBankAccount5;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$BANKACCOUNT6' then begin
        sValue := g_Config.sBankAccount6;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$BANKACCOUNT7' then begin
        sValue := g_Config.sBankAccount7;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$BANKACCOUNT8' then begin
        sValue := g_Config.sBankAccount8;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$BANKACCOUNT9' then begin
        sValue := g_Config.sBankAccount9;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$GAMEGOLDNAME' then begin
        sValue := g_Config.sGameGoldName;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$GAMEDIAMONDNAME' then begin
        sValue := g_Config.sGameDiaMond;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$GAMEGIRDNAME' then begin
        sValue := g_Config.sGameGird;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$GAMEPOINTNAME' then begin
        sValue := g_Config.sGamePointName;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$USERCOUNT' then begin
        sValue := IntToStr(UserEngine.PlayObjectCount);
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$MACRUNTIME' then begin
        sValue := CurrToStr(GetTickCount / 86400000{(24 * 60 * 60 * 1000)});
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$SERVERRUNTIME' then begin
        nSecond := (GetTickCount() - g_dwStartTick) div 1000;
        wHour := nSecond div 3600;
        wMinute := (nSecond div 60) mod 60;
        wSecond := nSecond mod 60;
        sValue := Format('%d:%d:%d', [wHour, wMinute, wSecond]);
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$DATETIME' then begin
        sValue := FormatDateTime('dddddd,dddd,hh:mm:ss', Now);//20090515 修改
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$DATE' then begin//20091126 增加
        sValue := FormatDateTime('mm月dd日', Now);
        nDataType := 0;
        Result := True;
        Exit;
      end;

      if sVariable = '$CASTLEGOLD' then begin
        if m_Castle <> nil then begin
          nValue := TUserCastle(m_Castle).m_nTotalGold;
          nDataType := 1;
          Result := True;
          Exit;
        end;
      end;
      if sVariable = '$TODAYINCOME' then begin
        if m_Castle <> nil then begin
          nValue := TUserCastle(m_Castle).m_nTodayIncome;
          nDataType := 1;
          Result := True;
          Exit;
        end;
      end;
      //个人信息
      if sVariable = '$USERNAME' then begin
        sValue := PlayObject.m_sCharName;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      {$IF M2Version <> 2}
      if sVariable = '$SETFENGHAOHUM' then begin//任命称号人名
        sValue := PlayObject.m_sFenghaoName;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$DIVISIONNAME' then begin//师门名称
        if PlayObject.m_MyDivision <> nil then begin
          sValue := TDivision(PlayObject.m_MyDivision).sDivisionName;
        end else begin
          sValue := '';
        end;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      //Add By TasNat at: 2012-04-23 17:16:11
    if sVariable = '$DIVISIONPOPULARITY' then begin//师门人气值
      if PlayObject.m_MyDivision <> nil then begin
        nValue := TDivision(PlayObject.m_MyDivision).nPopularity;
      end;
      nDataType := 1;
      Result := True;
      Exit;
    end;
    //Add By TasNat at: 2012-04-23 17:16:11
    if sVariable = '$DIVISIONHEARTLEVEL' then begin//传承心法等级
      if PlayObject.m_MyDivision <> nil then begin
        nValue := TDivision(PlayObject.m_MyDivision).nHeartLevel;
      end;
      nDataType := 1;
      Result := True;
      Exit;
    end;
      if sVariable = '$HEARTNAME' then begin//心法名称
        if PlayObject.m_sHeartName <> '' then begin
          sValue := PlayObject.m_sHeartName;
        end else begin
          sValue := '';
        end;
        nDataType := 0;
        Result := True;
        Exit;
      end;      
      {$IFEND}
      {if sVariable = '$PETSER' then begin//攻击宠物变量(临时) 20110616
        if (PlayObject.m_btRaceServer = RC_PLAYOBJECT) and (PlayObject.m_TargetCret <> nil) then begin
          if (PlayObject.m_TargetCret.m_btRaceServer = 158) then begin
            sValue := TPetsMon(PlayObject.m_TargetCret).m_sMasterName;
          end;
        end else sValue := '';
        nDataType := 0;
        Result := True;
        Exit;
      end;}
      if sVariable = '$KILLER' then begin//杀人者变量 20080826
        if PlayObject.m_boDeath and (PlayObject.m_LastHiter <> nil) then begin
          if (PlayObject.m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) then begin
            sValue := PlayObject.m_LastHiter.m_sCharName;
          end else
          if (PlayObject.m_LastHiter.m_btRaceServer = RC_HEROOBJECT) or
            (PlayObject.m_LastHiter.m_btRaceServer = 156) then begin
            if PlayObject.m_LastHiter.m_Master <> nil then
              sValue := PlayObject.m_LastHiter.m_Master.m_sCharName
            else sValue := '未知';
          end;
        end else sValue := '未知';
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$MONKILLER' then begin//杀人的怪物变量 20080826
        if PlayObject.m_boDeath and (PlayObject.m_LastHiter <> nil) then begin
          if (PlayObject.m_LastHiter.m_btRaceServer <> RC_PLAYOBJECT) and (PlayObject.m_LastHiter.m_btRaceServer <> RC_HEROOBJECT) then begin
            sValue := PlayObject.m_LastHiter.m_sCharName;
          end;
        end else sValue := '未知';
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$USERALLNAME' then begin//全名  200080419
        sValue := PlayObject.GetShowName;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$DEARNAME' then begin//配偶名
        sValue := PlayObject.m_sDearName;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$SFNAME' then begin//师傅名  200080603
        sValue := PlayObject.m_sMasterName;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$STATSERVERTIME' then begin //显示M2启动时间
        sValue := FrmMain.LbRunTime.Caption;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$RUNDATETIME' then begin //开区间隔时间
        sValue := FrmMain.LbTimeCount.Caption;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$RANDOMNO' then begin //随机值变量
        nValue := Random(High(Integer));
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$USERID' then begin //登录账号
        sValue := PlayObject.m_sUserID;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$REFINEARMYDRUMITEM' then begin //合成物品名
        sValue := PlayObject.m_sTmpStr;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$IPADDR' then begin //登录IP
        sValue := PlayObject.m_sIPaddr;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$REFINEOTHERITEM' then begin //登录IP
        sValue := PlayObject.m_sTmpStr;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$MACHINEID' then begin
        sValue := '$' + IntToHex(PlayObject.m_dwHCode, 8);
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$PETSNAME' then begin //宠物名
        sValue := PlayObject.m_sPetsMonName;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$HEROAUTOTIME' then begin//副将自我修炼时长
        nValue := PlayObject.m_HeroAutoPracticeTime;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$PETSHAPP' then begin//人物宠物快乐度
        nValue := PlayObject.m_nPetsMonHappiness;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$X' then begin//人物X坐标
        nValue := PlayObject.m_nCurrX;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$Y' then begin//人物Y坐标
        nValue := PlayObject.m_nCurrY;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$MAP' then begin
        sValue := PlayObject.m_PEnvir.sMapName;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$MAPNAME' then begin//地图名称
        sValue := PlayObject.m_PEnvir.sMapDesc;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$GUILDNAME' then begin
        if PlayObject.m_MyGuild <> nil then begin
          sValue := TGUild(PlayObject.m_MyGuild).sGuildName;
        end else begin
          sValue := '';
        end;
        nDataType := 0;
        Result := True;
        Exit;
      end;

      if sVariable = '$GUILDMEMBERCOUNT' then begin//行会成员上限 20090115
        if PlayObject.m_MyGuild <> nil then begin
          nValue := TGUild(PlayObject.m_MyGuild).m_nGuildMemberCount;
          nDataType := 1;
          Result := True;
          Exit;
        end;
      end;
      if sVariable = '$GUILDFOUNTAIN' then begin//行会泉水仓库 20080625
        if PlayObject.m_MyGuild <> nil then begin
          nValue := TGUild(PlayObject.m_MyGuild).m_nGuildFountain;
          nDataType := 1;
          Result := True;
          Exit;
        end;
      end;
      if sVariable = '$GUILDSTARDATE' then begin//授给行会之星的操作日期
        if PlayObject.m_MyGuild <> nil then begin
          sValue := DateTimeToStr(TGUild(PlayObject.m_MyGuild).m_GuildStarDate);
        end;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$ALCOHOL' then begin//酒量 20080627
        nValue := PlayObject.m_Abil.MaxAlcohol;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$MEDICINEVALUE' then begin//药力值 20080627
        nValue := PlayObject.m_Abil.MedicineValue;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$RANKNAME' then begin
        sValue := PlayObject.m_sGuildRankName;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      {$IF M2Version <> 2}
      if sVariable = '$NGLEVEL' then begin//人物内功等级 20090719
        nValue := PlayObject.m_NGLevel;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$HEARTLEVEL' then begin//心法等级
        if PlayObject.m_MagicSkill_105 <> nil then begin
          nValue := PlayObject.m_MagicSkill_105.btLevel;
        end else
        if PlayObject.m_MagicSkill_106 <> nil then begin
          nValue := PlayObject.m_MagicSkill_106.btLevel;
        end else nValue := 0;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      {$IFEND}
      if sVariable = '$LEVEL' then begin
        nValue := PlayObject.m_Abil.Level;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$USEGAMEGIRD' then begin//每次使用灵符数，$USEGAMEGIRD变量使用 20090108
        nValue := PlayObject.m_UseGameGird;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$BUYSHOP' then begin//每次商铺花的元宝数量 20090106
        nValue := PlayObject.m_BuyShopPrice;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$GETCRYSTALEXP' then begin//天地结晶可提取的经验 20090202
        nValue := PlayObject.m_nGetCrystalExp;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$GETCRYSTALNGEXP' then begin//天地结晶可提取的内功经验 20090202
        nValue := PlayObject.m_nGetCrystalNGExp;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$CRYSTALEXP' then begin//天地结晶当前的经验 20090202
        nValue := PlayObject.m_CrystalExp;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$CRYSTALNGEXP' then begin//天地结晶当前的内功经验 20090202
        nValue := PlayObject.m_CrystalNGExp;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$CRYSTALLEVEL' then begin//天地结晶等级 20090202
        {$IF M2Version = 1}
        if g_Config.boAssignmentCryst then begin
          case PlayObject.m_CrystalLevel of
            1: nValue := g_Config.nCRYSTALLEVEL1;
            2: nValue := g_Config.nCRYSTALLEVEL2;
            3: nValue := g_Config.nCRYSTALLEVEL3;
            4, 5: nValue := g_Config.nCRYSTALLEVEL4;//20110722 修改
          end;
        end else nValue := _MIN(5, PlayObject.m_CrystalLevel);
        {$ELSE}
        nValue := _MIN(5, PlayObject.m_CrystalLevel);
        {$IFEND}
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$GETEXP' then begin//人物取得的经验 20081228
        nValue := PlayObject.m_GetExp;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      {$IF HEROVERSION = 1}
      if sVariable = '$HEROLEVEL' then begin//英雄等级 20090708
        if PlayObject.m_MyHero <> nil then begin
          nValue := PlayObject.m_MyHero.m_Abil.Level;
        end else nValue := 0;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$HERONAME' then begin//英雄名称 200990708
        if PlayObject.m_MyHero <> nil then begin
          sValue := PlayObject.m_MyHero.m_sCharName;
        end else begin
          sMsg := '';
        end;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$HERONGLEVEL' then begin//英雄内功等级
        if PlayObject.m_MyHero <> nil then begin
          nValue := THeroObject(PlayObject.m_MyHero).m_NGLevel;
        end else nValue := 0;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$HEROGETEXP' then begin//英雄取得的经验
        if PlayObject.m_MyHero <> nil then begin
          nValue := THeroObject(PlayObject.m_MyHero).m_GetExp;
        end else nValue := 0;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$HERODRESS' then begin
        if PlayObject.m_MyHero <> nil then begin
          sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_DRESS].wIndex);
        end else sValue := '';
        nDataType := 0;
        Result := True;
        Exit;
      end else
      if sVariable = '$HEROWEAPON' then begin
        if PlayObject.m_MyHero <> nil then begin
          sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_WEAPON].wIndex);
        end else sValue := '';
        nDataType := 0;
        Result := True;
        Exit;
      end else
      if sVariable = '$HERORIGHTHAND' then begin
        if PlayObject.m_MyHero <> nil then begin
          sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_RIGHTHAND].wIndex);
        end else sValue := '';
        nDataType := 0;
        Result := True;
        Exit;
      end else
      if sVariable = '$HEROHELMET' then begin
        if PlayObject.m_MyHero <> nil then begin
          sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_HELMET].wIndex);
        end else sValue := '';
        nDataType := 0;
        Result := True;
        Exit;
      end else
      if sVariable = '$HEROZHULI' then begin //斗笠
        if PlayObject.m_MyHero <> nil then begin
          sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_ZHULI].wIndex);
        end else sValue := '';
        nDataType := 0;
        Result := True;
        Exit;
      end else
      if sVariable = '$HERONECKLACE' then begin
        if PlayObject.m_MyHero <> nil then begin
          sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_NECKLACE].wIndex);
        end else sValue := '';
        nDataType := 0;
        Result := True;
        Exit;
      end else
      if sVariable = '$HERORING_R' then begin
        if PlayObject.m_MyHero <> nil then begin
          sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_RINGR].wIndex);
        end else sValue := '';
        nDataType := 0;
        Result := True;
        Exit;
      end else
      if sVariable = '$HERORING_L' then begin
        if PlayObject.m_MyHero <> nil then begin
          sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_RINGL].wIndex);
        end else sValue := '';
        nDataType := 0;
        Result := True;
        Exit;
      end else
      if sVariable = '$HEROARMRING_R' then begin
        if PlayObject.m_MyHero <> nil then begin
          sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_ARMRINGR].wIndex);
        end else sValue := '';
        nDataType := 0;
        Result := True;
        Exit;
      end else
      if sVariable = '$HEROARMRING_L' then begin
        if PlayObject.m_MyHero <> nil then begin
          sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_ARMRINGL].wIndex);
        end else sValue := '';
        nDataType := 0;
        Result := True;
        Exit;
      end else
      if sVariable = '$HEROBUJUK' then begin
        if PlayObject.m_MyHero <> nil then begin
          sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_BUJUK].wIndex);
        end else sValue := '';
        nDataType := 0;
        Result := True;
        Exit;
      end else
      if sVariable = '$HEROBELT' then begin
        if PlayObject.m_MyHero <> nil then begin
          sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_BELT].wIndex);
        end else sValue := '';
        nDataType := 0;
        Result := True;
        Exit;
      end else
      if sVariable = '$HEROBOOTS' then begin
        if PlayObject.m_MyHero <> nil then begin
          sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_BOOTS].wIndex);
        end else sValue := '';
        nDataType := 0;
        Result := True;
        Exit;
      end else
      if sVariable = '$HERODRUM' then begin
        if PlayObject.m_MyHero <> nil then begin
          sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_DRUM].wIndex);
        end else sValue := '';
        nDataType := 0;
        Result := True;
        Exit;
      end else
      if sVariable = '$HEROCHARM' then begin
        if PlayObject.m_MyHero <> nil then begin
          sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_CHARM].wIndex);
        end else sValue := '';
        nDataType := 0;
        Result := True;
        Exit;
      end;
      {$IFEND}
      if sVariable = '$GLORYPOINT' then begin//人物荣誉值 20080512
        nValue := PlayObject.m_btGameGlory;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$HP' then begin
        nValue := PlayObject.m_WAbil.HP;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$MAXHP' then begin
        nValue := PlayObject.m_WAbil.MaxHP;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$MP' then begin
        nValue := PlayObject.m_WAbil.MP;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$MAXMP' then begin
        nValue := PlayObject.m_WAbil.MaxMP;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$AC' then begin
        nValue := LoWord(PlayObject.m_WAbil.AC);
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$MAXAC' then begin
        nValue := HiWord(PlayObject.m_WAbil.AC);
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$MAC' then begin
        nValue := LoWord(PlayObject.m_WAbil.MAC);
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$MAXMAC' then begin
        nValue := HiWord(PlayObject.m_WAbil.MAC);
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$DC' then begin
        nValue := LoWord(PlayObject.m_WAbil.DC);
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$MAXDC' then begin
        nValue := HiWord(PlayObject.m_WAbil.DC);
        nDataType := 1;
        Result := True;
        Exit;
      end;

      if sVariable = '$MC' then begin
        nValue := LoWord(PlayObject.m_WAbil.MC);
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$MAXMC' then begin
        nValue := HiWord(PlayObject.m_WAbil.MC);
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$SC' then begin
        nValue := LoWord(PlayObject.m_WAbil.SC);
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$MAXSC' then begin
        nValue := HiWord(PlayObject.m_WAbil.SC);
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$EXP' then begin
        nValue := PlayObject.m_Abil.nExp;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$MAXEXP' then begin
        nValue := PlayObject.m_Abil.nMaxExp;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$PKPOINT' then begin
        nValue := PlayObject.m_nPkPoint;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$CREDITPOINT' then begin
        nValue := PlayObject.m_btCreditPoint;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$HW' then begin
        nValue := PlayObject.m_WAbil.HandWeight;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$MAXHW' then begin
        nValue := PlayObject.m_WAbil.MaxHandWeight;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$BW' then begin
        nValue := PlayObject.m_WAbil.Weight;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$MAXBW' then begin
        nValue := PlayObject.m_WAbil.MaxWeight;
        nDataType := 1;
        Result := True;
        Exit;
      end;

      if sVariable = '$WW' then begin
        nValue := PlayObject.m_WAbil.WearWeight;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$MAXWW' then begin
        nValue := PlayObject.m_WAbil.MaxWearWeight;
        nDataType := 1;
        Result := True;
        Exit;
      end;

      if sVariable = '$GOLDCOUNT' then begin
        nValue := PlayObject.m_nGold;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$GAMEGOLD' then begin
        nValue := PlayObject.m_nGameGold;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$GAMEDIAMOND' then begin //20071226 金刚石
        nValue := PlayObject.m_nGameDiaMond;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$GAMEGIRD' then begin //20071226 灵符
        nValue := PlayObject.m_nGameGird;
        nDataType := 1;
        Result := True;
        Exit;
      end;

      if CompareLStr(sVariable, '$HUMAN', 6{Length('$HUMAN')}) then begin //20080315 人物变量
        ArrestStringEx(sVariable, '(', ')', sVarValue2);
        if PlayObject.m_DynamicVarList.Count > 0 then begin//20080629
          for I := 0 to PlayObject.m_DynamicVarList.Count - 1 do begin
            DynamicVar := PlayObject.m_DynamicVarList.Items[I];
            if CompareText(DynamicVar.sName, sVarValue2) = 0 then begin
              case DynamicVar.VarType of
                vInteger:begin
                    nValue := DynamicVar.nInternet;
                    nDataType := 1;
                    Result := True;
                    Exit;
                  end;
                vString: begin//20090812 增加
                    sValue := DynamicVar.sString;
                    nDataType := 0;
                    Result := True;
                  end;
              end;
              Break;
            end;
          end;//for
        end;
      end;
      if CompareLStr(sVariable, '$GLOBAL(', 8{Length('$GLOBAL(')}) then begin//20090409 增加
        ArrestStringEx(sVariable, '(', ')', sVarValue2);
        if g_DynamicVarList.Count > 0 then begin
          for I := 0 to g_DynamicVarList.Count - 1 do begin
            DynamicVar := g_DynamicVarList.Items[I];
            if CompareText(DynamicVar.sName, sVarValue2) = 0 then begin
              case DynamicVar.VarType of
                vInteger:begin
                    nValue := DynamicVar.nInternet;
                    nDataType := 1;
                    Result := True;
                    Exit;
                 end;
                vString: begin
                    sValue := DynamicVar.sString;
                    nDataType := 0;
                    Result := True;
                 end;
              end;
              Break;
            end;
          end;//for
        end;
      end;

      if sVariable = '$GAMEPOINT' then begin
        nValue := PlayObject.m_nGamePoint;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$HUNGER' then begin
        nValue := PlayObject.GetMyStatus;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$LOGINTIME' then begin
        sValue := DateTimeToStr(PlayObject.m_dLogonTime);
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$DATETIME' then begin
        sValue := FormatDateTime('dddddd,dddd,hh:mm:ss', Now);//20090515 修改
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$DATE' then begin//20091126 增加
        sValue := FormatDateTime('mm月dd日', Now);
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$LOGINLONG' then begin
        nValue := (GetTickCount - PlayObject.m_dwLogonTick) div 60000;
        nDataType := 1;
        Result := True;
        Exit;
      end;
      if sVariable = '$DRESS' then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_DRESS].wIndex);
        nDataType := 0;
        Result := True;
        Exit;
      end else
        if sVariable = '$WEAPON' then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_WEAPON].wIndex);
        nDataType := 0;
        Result := True;
        Exit;
      end else
        if sVariable = '$RIGHTHAND' then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_RIGHTHAND].wIndex);
        nDataType := 0;
        Result := True;
        Exit;
      end else
        if sVariable = '$HELMET' then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_HELMET].wIndex);
        nDataType := 0;
        Result := True;
        Exit;
      end else
        if sVariable = '$ZHULI' then begin //20080416 斗笠
        sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_ZHULI].wIndex);
        nDataType := 0;
        Result := True;
        Exit;
      end else
        if sVariable = '$NECKLACE' then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_NECKLACE].wIndex);
        nDataType := 0;
        Result := True;
        Exit;
      end else
        if sVariable = '$RING_R' then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_RINGR].wIndex);
        nDataType := 0;
        Result := True;
        Exit;
      end else
        if sVariable = '$RING_L' then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_RINGL].wIndex);
        nDataType := 0;
        Result := True;
        Exit;
      end else
        if sVariable = '$ARMRING_R' then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_ARMRINGR].wIndex);
        nDataType := 0;
        Result := True;
        Exit;
      end else
        if sVariable = '$ARMRING_L' then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_ARMRINGL].wIndex);
        nDataType := 0;
        Result := True;
        Exit;
      end else
        if sVariable = '$BUJUK' then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_BUJUK].wIndex);
        nDataType := 0;
        Result := True;
        Exit;
      end else
        if sVariable = '$BELT' then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_BELT].wIndex);
        nDataType := 0;
        Result := True;
        Exit;
      end else
        if sVariable = '$BOOTS' then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_BOOTS].wIndex);
        nDataType := 0;
        Result := True;
        Exit;
      end else
        if sVariable = '$DRUM' then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_DRUM].wIndex);
        nDataType := 0;
        Result := True;
        Exit;
      end else
        if sVariable = '$CHARM' then begin
        sValue := UserEngine.GetStdItemName(PlayObject.m_UseItems[U_CHARM].wIndex);
        nDataType := 0;
        Result := True;
        Exit;
      end else
        if sVariable = '$REFINEARMYDRUMITEM' then begin
        sValue := PlayObject.m_sTmpStr;
        nDataType := 0;
        Result := True;
        Exit;
      end else
        if sVariable = '$IPADDR' then begin
        sValue := PlayObject.m_sIPaddr;
        nDataType := 0;
        Result := True;
        Exit;
      end else
        if sVariable = '$MACHINEID' then begin
        sValue := '$' + IntToHex(PlayObject.m_dwHCode, 8);
        nDataType := 0;
        Result := True;
        Exit;
      end else
        if sVariable = '$PETSNAME' then begin//宠物名
        sValue := PlayObject.m_sPetsMonName;
        nDataType := 0;
        Result := True;
        Exit;
      end else
        if sVariable = '$IPLOCAL' then begin
        sValue := GetIPLocal(PlayObject.m_sIPaddr);
        nDataType := 0;
        Result := True;
        Exit;
      end else
        if sVariable = '$GUILDBUILDPOINT' then begin
        if PlayObject.m_MyGuild <> nil then begin
          nValue := TGUild(PlayObject.m_MyGuild).nBuildPoint;
        end;
        nDataType := 0;
        Result := True;
        Exit;
      end else
        if sVariable = '$GUILDAURAEPOINT' then begin
        if PlayObject.m_MyGuild <> nil then begin
          nValue := TGUild(PlayObject.m_MyGuild).nAurae;
        end;
        nDataType := 0;
        Result := True;
        Exit;
      end else
        if sVariable = '$GUILDSTABILITYPOINT' then begin
        if PlayObject.m_MyGuild <> nil then begin
          nValue := TGUild(PlayObject.m_MyGuild).nStability;
        end;
        nDataType := 0;
        Result := True;
        Exit;
      end;
      if sVariable = '$GUILDFLOURISHPOINT' then begin
        if PlayObject.m_MyGuild <> nil then begin
          nValue := TGUild(PlayObject.m_MyGuild).nFlourishing;
        end;
        nDataType := 0;
        Result := True;
        Exit;
      end;
    end;

    function SetValNameValue(sVarName: string; sValue: string; nValue: Integer; nDataType: Integer): Boolean;
    var
      n100: Integer;
    begin
      n100 := GetValNameNo(sVarName);
      if n100 >= 0 then begin
        case nDataType of
          1: begin
              case n100 of
                0..99: begin //20080323 原为0..99
                    PlayObject.m_nVal[n100] := nValue;
                    Result := True;
                  end;
                100..199: begin
                    g_Config.GlobalVal[n100 - 100] := nValue;
                    Result := True;
                  end;
                200..299: begin //20080323 原为200..209
                    PlayObject.m_DyVal[n100 - 200] := nValue;
                    Result := True;
                  end;
                300..399: begin
                    PlayObject.m_nMval[n100 - 300] := nValue;
                    Result := True;
                  end;
                400..499: begin
                    g_Config.GlobaDyMval[n100 - 400] := nValue;
                    Result := True;
                  end;
                500..599: begin
                    PlayObject.m_nInteger[n100 - 500] := nValue;
                    Result := True;
                  end;
                600..699: begin //20080506 增加
                    PlayObject.m_sString[n100 - 600] := IntToStr(nValue);
                    Result := True;
                  end;
                700..799: begin //20080506 增加
                    g_Config.GlobalAVal[n100 - 700] := IntToStr(nValue);
                    Result := True;
                  end;
                800..1199:begin//20080903 G变量
                    g_Config.GlobalVal[n100 - 700] := nValue;
                    Result := True;
                  end;
                1200..2099:begin//A变量(100-999)
                    g_Config.GlobalAVal[n100 - 1100] := IntToStr(nValue);
                    Result := True;
                  end;
                2100..2599: begin//G变量(500-999)
                    g_Config.GlobalVal[n100 - 1600] := nValue;
                    Result := True;
                  end;
              else begin
                  Result := False;
                end;
              end;
            end;
          0: begin
              case n100 of
                0..99: begin //20090102 增加
                    PlayObject.m_nVal[n100] := Str_ToInt(sValue, 0);
                    Result := True;
                  end;
                100..199: begin
                    g_Config.GlobalVal[n100 - 100] := Str_ToInt(sValue, 0);
                    Result := True;
                  end;
                200..299: begin
                    PlayObject.m_DyVal[n100 - 200] := Str_ToInt(sValue, 0);
                    Result := True;
                  end;
                300..399: begin
                    PlayObject.m_nMval[n100 - 300] := Str_ToInt(sValue, 0);
                    Result := True;
                  end;
                400..499: begin
                    g_Config.GlobaDyMval[n100 - 400] := Str_ToInt(sValue, 0);
                    Result := True;
                  end;
                500..599: begin
                    PlayObject.m_nInteger[n100 - 500] := Str_ToInt(sValue, 0);
                    Result := True;
                  end;
                600..699: begin
                    PlayObject.m_sString[n100 - 600] := sValue;
                    Result := True;
                  end;
                700..799: begin
                    g_Config.GlobalAVal[n100 - 700] := sValue;
                    Result := True;
                  end;
                800..1199:begin
                    g_Config.GlobalVal[n100 - 700] := Str_ToInt(sValue, 0);
                    Result := True;
                  end;
                1200..2099:begin//A变量(100-999)
                    g_Config.GlobalAVal[n100 - 1100] := sValue;
                    Result := True;
                  end;
                2100..2599: begin//G变量(500-999)
                    g_Config.GlobalVal[n100 - 1600] := Str_ToInt(sValue, 0);
                    Result := True;
                  end;
              else begin
                  Result := False;
                end;
              end;
            end;
          3: begin
              case n100 of
                0..99: begin //20080323 原为0..99
                    PlayObject.m_nVal[n100] := nValue;
                    Result := True;
                  end;
                100..199: begin
                    g_Config.GlobalVal[n100 - 100] := nValue;
                    Result := True;
                  end;
                200..299: begin //20080323 原为200..209
                    PlayObject.m_DyVal[n100 - 200] := nValue;
                    Result := True;
                  end;
                300..399: begin
                    PlayObject.m_nMval[n100 - 300] := nValue;
                    Result := True;
                  end;
                400..499: begin
                    g_Config.GlobaDyMval[n100 - 400] := nValue;
                    Result := True;
                  end;
                500..599: begin
                    PlayObject.m_nInteger[n100 - 500] := nValue;
                    Result := True;
                  end;
                600..699: begin
                    PlayObject.m_sString[n100 - 600] := sValue;
                    Result := True;
                  end;
                700..799: begin
                    g_Config.GlobalAVal[n100 - 700] := sValue;
                    Result := True;
                  end;
                800..1199:begin//20080903 G变量
                    g_Config.GlobalVal[n100 - 700] := nValue;
                    Result := True;
                  end;
                1200..2099:begin//A变量(100-999)
                    g_Config.GlobalAVal[n100 - 1100] := sValue;
                    Result := True;
                  end;
                2100..2599: begin//G变量(500-999)
                    g_Config.GlobalVal[n100 - 1600] := nValue;
                    Result := True;
                  end;
              else begin
                  Result := False;
                end;
              end;
            end;
        end;
      end else Result := False;
    end;
    function GetValNameValue(sVarName: string; var sValue: string; var nValue: Integer; var nDataType: Integer): Boolean;
    var
      n100: Integer;
    begin
      nValue := -1;
      sValue := '';
      nDataType := -1;
      n100 := GetValNameNo(sVarName);
      if n100 >= 0 then begin
        case n100 of
          0..99: begin //20080323 原为0..99
              nValue := PlayObject.m_nVal[n100];
              nDataType := 1;
              Result := True;
            end;
          100..199: begin
              nValue := g_Config.GlobalVal[n100 - 100];
              nDataType := 1;
              Result := True;
            end;
          200..299: begin //20080323 原为200..209
              nValue := PlayObject.m_DyVal[n100 - 200];
              nDataType := 1;
              Result := True;
            end;
          300..399: begin
              nValue := PlayObject.m_nMval[n100 - 300];
              nDataType := 1;
              Result := True;
            end;
          400..499: begin
              nValue := g_Config.GlobaDyMval[n100 - 400];
              nDataType := 1;
              Result := True;
            end;
          500..599: begin
              nValue := PlayObject.m_nInteger[n100 - 500];
              nDataType := 1;
              Result := True;
            end;
          600..699: begin
              sValue := PlayObject.m_sString[n100 - 600];
              nDataType := 0;
              Result := True;
            end;
          700..799: begin
              sValue := g_Config.GlobalAVal[n100 - 700];
              nDataType := 0;
              Result := True;
            end;
          800..1199:begin//20080903 G变量
              nValue := g_Config.GlobalVal[n100 - 700];
              nDataType := 1;
              Result := True;
            end;
          1200..2099:begin//A变量(100-999)
              sValue := g_Config.GlobalAVal[n100 - 1100];
              nDataType := 0;
              Result := True;
            end;
          2100..2599: begin//G变量(500-999)
              nValue := g_Config.GlobalVal[n100 - 1600];
              nDataType := 1;
              Result := True;
            end;
        else begin
            Result := False;
          end;
        end;
      end else Result := False;
    end;

    function GetDynamicVarValue(sVarType, sVarName: string; var sValue: string; var nValue: Integer; var nDataType: Integer): Boolean;
    var
      V: Integer;
      DynamicVar: pTDynamicVar;
      DynamicVarList: TList;
      sName: string;
      boVarFound: Boolean;
    begin
      boVarFound := False;
      sValue := '';
      nValue := -1;
      nDataType := -1;
      DynamicVarList := GetDynamicVarList(PlayObject, sVarType, sName);
      if DynamicVarList = nil then begin
        Result := False;
        Exit;
      end;
      if DynamicVarList.Count > 0 then begin//20080629
        for V := 0 to DynamicVarList.Count - 1 do begin
          DynamicVar := DynamicVarList.Items[V];
          if CompareText(DynamicVar.sName, sVarName) = 0 then begin
            case DynamicVar.VarType of
              vInteger: begin
                  nValue := DynamicVar.nInternet;
                  nDataType := 1;
                end;
              vString: begin
                  sValue := DynamicVar.sString;
                  nDataType := 0;
                end;
            end;
            boVarFound := True;
            Break;
          end;
        end;//for
      end;
      if not boVarFound then Result := False else Result := True;
    end;

    function SetDynamicVarValue(sVarType, sVarName: string; sValue: string; nValue: Integer; nDataType: Integer): Boolean;
    var
      V: Integer;
      DynamicVar: pTDynamicVar;
      DynamicVarList: TList;
      sName: string;
      boVarFound: Boolean;
    begin
      boVarFound := False;
      DynamicVarList := GetDynamicVarList(PlayObject, sVarType, sName);
      if DynamicVarList = nil then begin
        Result := False;
        Exit;
      end;
      if DynamicVarList.Count > 0 then begin//20080629
        for V := 0 to DynamicVarList.Count - 1 do begin
          DynamicVar := DynamicVarList.Items[V];
          if CompareText(DynamicVar.sName, sVarName) = 0 then begin
            if nDataType = 1 then begin
              case DynamicVar.VarType of
                vInteger: begin
                    DynamicVar.nInternet := nValue;
                    boVarFound := True;
                    Break;
                  end;
              end;
            end else begin
              case DynamicVar.VarType of
                vString: begin
                    DynamicVar.sString := sValue;
                    boVarFound := True;
                    Break;
                  end;
              end;
            end;
          end;
        end;//for
      end;
      if not boVarFound then Result := False else Result := True;
    end;

    function GetDataType: Integer; //
    var
      sParam1: string;
      sParam2: string;
      sParam3: string;
      n01: Integer;
    begin
      Result := -1;
      if CompareLStr(QuestActionInfo.sParam1, '<$STR(', 6{Length('<$STR(')}) then //20080228 支持字符串变量
        ArrestStringEx(QuestActionInfo.sParam1, '(', ')', sParam1)
      else sParam1 := QuestActionInfo.sParam1;

      if CompareLStr(QuestActionInfo.sParam2, '<$STR(', 6{Length('<$STR(')}) then //20080228 支持字符串变量
        ArrestStringEx(QuestActionInfo.sParam2, '(', ')', sParam2)
      else sParam2 := QuestActionInfo.sParam2;

      if CompareLStr(QuestActionInfo.sParam3, '<$STR(', 6{Length('<$STR(')}) then  //20080228 支持字符串变量
        ArrestStringEx(QuestActionInfo.sParam3, '(', ')', sParam3)
      else sParam3 := QuestActionInfo.sParam3;

     { sParam1 := QuestActionInfo.sParam1; //20080228
      sParam2 := QuestActionInfo.sParam2;
      sParam3 := QuestActionInfo.sParam3;}
      if IsVarNumber(sParam1) then begin//是否是自定义变量
        if (sParam3 <> '') and (sParam3[1] = '<') and (sParam3[Length(sParam3)] = '>') {TagCount(sParam3, '>') > 0} then begin
          Result := 0;
        end else
          if (sParam3 <> '') and (GetValNameNo(sParam3) >= 0) then begin
          Result := 1;
        end else
          if (sParam3 <> '') and IsStringNumber(sParam3) then begin
          Result := 2;
        end else begin
          Result := 3;
        end;
        Exit;
      end;
      n01 := GetValNameNo(sParam1);
      if n01 >= 0 then begin
        if (sParam2 <> '') and (sParam2[1] = '<') and (sParam2[Length(sParam2)] = '>') then begin
          Result := 4;
        end else
          if (sParam2 <> '') and (GetValNameNo(sParam2) >= 0) then begin
          Result := 5;
        end else
          if (sParam2 <> '') and IsVarNumber(sParam2) then begin
          Result := 6;
        end else begin
          Result := 7;
        end;
        Exit;
      end;
    end;
  var
    sParam1: string;
    sParam2: string;
    sParam3: string;
    sValue: string;
    nValue: Integer;
    nDataType: Integer;
  resourcestring
    sVarFound = '变量%s不存在，变量类型:%s';
    sVarTypeError = '变量类型错误，错误类型:%s 当前支持类型(HUMAN、GUILD、GLOBAL)';
    sDataTypeError = '变量类型不一致，错误类型:%s %s';
  begin
    if CompareLStr(QuestActionInfo.sParam1, '<$STR(', 6{Length('<$STR(')}) then //20080228 支持字符串变量
      ArrestStringEx(QuestActionInfo.sParam1, '(', ')', sParam1)
    else sParam1 := QuestActionInfo.sParam1;

    if CompareLStr(QuestActionInfo.sParam2, '<$STR(', 6{Length('<$STR(')}) then //20080228 支持字符串变量
      ArrestStringEx(QuestActionInfo.sParam2, '(', ')', sParam2)
    else sParam2 := QuestActionInfo.sParam2;

    if CompareLStr(QuestActionInfo.sParam3, '<$STR(', 6{Length('<$STR(')}) then  //20080228 支持字符串变量
      ArrestStringEx(QuestActionInfo.sParam3, '(', ')', sParam3)
    else sParam3 := QuestActionInfo.sParam3;

    {sParam1 := QuestActionInfo.sParam1; //20080228
    sParam2 := QuestActionInfo.sParam2;
    sParam3 := QuestActionInfo.sParam3;}
    if sParam1 = '' then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sMOV);
      Exit;
    end;
    case GetDataType of
      0: begin
          if GetHumanInfoValue(sParam3, sValue, nValue, nDataType) then begin
            if not SetDynamicVarValue(sParam1, sParam2, sValue, nValue, nDataType) then
              ScriptActionError(PlayObject, Format(sVarFound, [sParam1, sParam2]), QuestActionInfo, sMOV);
          end else begin
            ScriptActionError(PlayObject, '', QuestActionInfo, sMOV);
          end;
          Exit;
        end;
      1: begin
          if GetValNameValue(sParam3, sValue, nValue, nDataType) then begin
            if not SetDynamicVarValue(sParam1, sParam2, sValue, nValue, nDataType) then
              ScriptActionError(PlayObject, Format(sVarFound, [sParam1, sParam2]), QuestActionInfo, sMOV);
          end else begin
            ScriptActionError(PlayObject, '', QuestActionInfo, sMOV);
          end;
          Exit;
        end;
      2: begin
          if not SetDynamicVarValue(sParam1, sParam2, QuestActionInfo.sParam3, QuestActionInfo.nParam3, 1) then
            ScriptActionError(PlayObject, Format(sVarFound, [sParam1, sParam2]), QuestActionInfo, sMOV);
        end;
      3: begin
          if not SetDynamicVarValue(sParam1, sParam2, QuestActionInfo.sParam3, QuestActionInfo.nParam3, 0) then
            ScriptActionError(PlayObject, Format(sVarFound, [sParam1, sParam2]), QuestActionInfo, sMOV);
        end;
      //==============================================================================
      4: begin
          if GetHumanInfoValue(sParam2, sValue, nValue, nDataType) then begin
            if not SetValNameValue(sParam1, sValue, nValue, nDataType) then
              ScriptActionError(PlayObject, '', QuestActionInfo, sMOV);
          end else begin
            ScriptActionError(PlayObject, '', QuestActionInfo, sMOV);
          end;
          Exit;
        end;
      5: begin
          if GetValNameValue(sParam2, sValue, nValue, nDataType) then begin
            if not SetValNameValue(sParam1, sValue, nValue, nDataType) then
              ScriptActionError(PlayObject, '', QuestActionInfo, sMOV);
          end else begin
            ScriptActionError(PlayObject, '', QuestActionInfo, sMOV);
          end;
          Exit;
        end;
      6: begin
          if GetDynamicVarValue(sParam2, sParam3, sValue, nValue, nDataType) then begin
            if not SetValNameValue(sParam1, sValue, nValue, nDataType) then
              ScriptActionError(PlayObject, '', QuestActionInfo, sMOV);
          end else begin
            ScriptActionError(PlayObject, Format(sVarFound, [sParam2, sParam3]), QuestActionInfo, sMOV);
          end;
          Exit;
        end;
      7: begin
          if GetValNameValue(sParam1, sValue, nValue, nDataType) then begin
            if (sParam2 <> '') and (sParam2[1]= '<') and (sParam2[2]= '$') then begin //20080407 支持:MOV A14 <$USERALLNAME>\天下第一战士 的传值
              GetHumanInfoValue(sParam2, sValue, nValue, nDataType);//取人物信息
              sValue :=sValue + copy(sParam2,pos('\',sParam2),length(sParam2)-pos('\',sParam2)+1);
              if not SetValNameValue(sParam1, sValue, nValue, nDataType) then begin
                ScriptActionError(PlayObject, '', QuestActionInfo, sMOV);
                Exit;
              end;
            end else begin
              if not SetValNameValue(sParam1, QuestActionInfo.sParam2, QuestActionInfo.nParam2, nDataType) then begin
                ScriptActionError(PlayObject, '', QuestActionInfo, sMOV);
                Exit;
              end;
            end;
          end else begin
            ScriptActionError(PlayObject, '', QuestActionInfo, sMOV);
          end;
        end;
      {8: begin
          if not SetValNameValue(sParam1, QuestActionInfo.sParam2, QuestActionInfo.nParam2, 0) then begin
            ScriptActionError(PlayObject, '', QuestActionInfo, sMOV);
          end else begin
            ScriptActionError(PlayObject, '', QuestActionInfo, sMOV);
          end;
          Exit;
        end;}
    else begin
        ScriptActionError(PlayObject, '', QuestActionInfo, sMOV);
      end;
    end;
  end;
  procedure IncInteger(QuestActionInfo: pTQuestActionInfo);
  var
    I, n14, n3C, n10: Integer;
    s01: string;
    DynamicVar: pTDynamicVar;
    DynamicVarList: TList;
    sName: string;
    boVarFound: Boolean;
    sParam1: string;
    sParam2: string;
    sParam3: string;
  resourcestring
    sVarFound = '变量%s不存在，变量类型:%s';
    sVarTypeError = '变量类型错误，错误类型:%s 当前支持类型(HUMAN、GUILD、GLOBAL)';
  begin
    n10 := 0;
    if CompareLStr(QuestActionInfo.sParam1, '<$STR(', 6{Length('<$STR(')}) then//20080228 支持字符串变量
      ArrestStringEx(QuestActionInfo.sParam1, '(', ')', sParam1)
    else sParam1 := {QuestActionInfo.sParam1}GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//20090716 修改

    if CompareLStr(QuestActionInfo.sParam2, '<$STR(', 6{Length('<$STR(')}) then //20080228 支持字符串变量
      ArrestStringEx(QuestActionInfo.sParam2, '(', ')', sParam2)
    else sParam2 := {QuestActionInfo.sParam2}GetLineVariableText(PlayObject, QuestActionInfo.sParam2);//20090716 修改

    if CompareLStr(QuestActionInfo.sParam3, '<$STR(', 6{Length('<$STR(')}) then  //20080228 支持字符串变量
      ArrestStringEx(QuestActionInfo.sParam3, '(', ')', sParam3)
    else sParam3 := {QuestActionInfo.sParam3}GetLineVariableText(PlayObject, QuestActionInfo.sParam3);//20090716 修改

    if (sParam1 = '') or (sParam2 = '') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sINC);
      Exit;
    end;
    if sParam3 <> '' then begin
      if (not IsVarNumber(sParam1)) and (IsVarNumber(sParam2)) then begin
        n10 := 1;
        boVarFound := False;
        DynamicVarList := GetDynamicVarList(PlayObject, sParam2, sName);
        if DynamicVarList = nil then begin
          ScriptActionError(PlayObject, Format(sVarTypeError, [sParam2]), QuestActionInfo, sINC);
          Exit;
        end;
        if DynamicVarList.Count > 0 then begin//20080629
          for I := 0 to DynamicVarList.Count - 1 do begin
            DynamicVar := DynamicVarList.Items[I];
            if CompareText(DynamicVar.sName, sParam3) = 0 then begin
              case DynamicVar.VarType of
                vInteger: begin
                    n3C := DynamicVar.nInternet;
                  end;
                vString: begin
                    s01 := DynamicVar.sString;
                  end;
              end;
              boVarFound := True;
              Break;
            end;
          end;//for
        end;
        if not boVarFound then begin
          ScriptActionError(PlayObject, Format(sVarFound, [sParam3, sParam2]), QuestActionInfo, sINC);
          Exit;
        end;
        n14 := GetValNameNo(sParam1);
        if n14 >= 0 then begin
          case n14 of
            0..99: begin //20080323 原为0..99
                if n3C > {1}0 then begin
                  Inc(PlayObject.m_nVal[n14], n3C);
                {end else begin
                  Inc(PlayObject.m_nVal[n14]); }
                end;
              end;
            100..199: begin
                if n3C > {1}0 then begin
                  Inc(g_Config.GlobalVal[n14 - 100], n3C);
                {end else begin
                  Inc(g_Config.GlobalVal[n14 - 100]); }
                end;
              end;
            200..299: begin //20080323 原为200..209
                if n3C > {1}0 then begin
                  Inc(PlayObject.m_DyVal[n14 - 200], n3C);
                {end else begin
                  Inc(PlayObject.m_DyVal[n14 - 200]);}
                end;
              end;
            300..399: begin
                if n3C > {1}0 then begin
                  Inc(PlayObject.m_nMval[n14 - 300], n3C);
                {end else begin
                  Inc(PlayObject.m_nMval[n14 - 300]); }
                end;
              end;
            400..499: begin
                if n3C > {1}0 then begin
                  Inc(g_Config.GlobaDyMval[n14 - 400], n3C);
                {end else begin
                  Inc(g_Config.GlobaDyMval[n14 - 400]); }
                end;
              end;
            500..599: begin
                if n3C > {1}0 then begin
                  Inc(PlayObject.m_nInteger[n14 - 500], n3C);
                {end else begin
                  Inc(PlayObject.m_nInteger[n14 - 500]);}
                end;
              end;
            600..699: begin
                PlayObject.m_sString[n14 - 600]:= PlayObject.m_sString[n14 - 600]+ s01;
              end;
            700..799: begin
                g_Config.GlobalAVal[n14 - 700]:= g_Config.GlobalAVal[n14 - 700]+ s01;
              end;
            800..1199:begin//20080903 G变量
                if n3C > {1}0 then begin
                  Inc(g_Config.GlobalVal[n14 - 700], n3C);
                {end else begin
                  Inc(g_Config.GlobalVal[n14 - 700]);}
                end;
              end;
            1200..2099:begin//A变量(100-999)
                g_Config.GlobalAVal[n14 - 1100]:= g_Config.GlobalAVal[n14 - 1100]+ s01;
              end;
            2100..2599: begin//G变量(500-999)
                if n3C > {1}0 then begin
                  Inc(g_Config.GlobalVal[n14 - 1600], n3C);
                {end else begin
                  Inc(g_Config.GlobalVal[n14 - 1600]); }
                end;
              end;
          else begin
              ScriptActionError(PlayObject, '', QuestActionInfo, sINC);
              Exit;
            end;
          end;
        end else begin
          ScriptActionError(PlayObject, '', QuestActionInfo, sINC);
          Exit;
        end;
        Exit;
      end;
      if (IsVarNumber(sParam1)) and (not IsVarNumber(sParam2)) then begin
        if (sParam3 <> '') and (not IsStringNumber(sParam3)) then begin
          n10 := 1;
          n14 := GetValNameNo(sParam3);
          if n14 >= 0 then begin
            case n14 of
              0..99: begin //20080323 原为0..99
                  n3C := PlayObject.m_nVal[n14];
                end;
              100..199: begin
                  n3C := g_Config.GlobalVal[n14 - 100];
                end;
              200..299: begin //20080323 原为200..209
                  n3C := PlayObject.m_DyVal[n14 - 200];
                end;
              300..399: begin
                  n3C := PlayObject.m_nMval[n14 - 300];
                end;
              400..499: begin
                  n3C := g_Config.GlobaDyMval[n14 - 400];
                end;
              500..599: begin
                  n3C := PlayObject.m_nInteger[n14 - 500];
                end;
              600..699: begin
                  s01 := PlayObject.m_sString[n14 - 600];
                end;
              700..799: begin
                  s01 := g_Config.GlobalAVal[n14 - 700];
                end;
              800..1199:begin//20080903 G变量
                  n3C := g_Config.GlobalVal[n14 - 700];
                end;
              1200..2099:begin//A变量(100-999)
                  s01 := g_Config.GlobalAVal[n14 - 1100];
                end;
              2100..2599: begin//G变量(500-999)
                  n3C := g_Config.GlobalVal[n14 - 1600];
                end;
            else begin
                ScriptActionError(PlayObject, '', QuestActionInfo, sINC);
                Exit;
              end;
            end;
          end else begin
            s01 := sParam3;//20080530
          end;
        end else n3C := QuestActionInfo.nParam3;
        boVarFound := False;
        DynamicVarList := GetDynamicVarList(PlayObject, sParam1, sName);
        if DynamicVarList = nil then begin
          ScriptActionError(PlayObject, Format(sVarTypeError, [sParam1]), QuestActionInfo, sINC);
          Exit;
        end;
        if DynamicVarList.Count > 0 then begin//20080629
          for I := 0 to DynamicVarList.Count - 1 do begin
            DynamicVar := DynamicVarList.Items[I];
            if DynamicVar <> nil then begin//20090305
              if CompareText(DynamicVar.sName, sParam2) = 0 then begin
                case DynamicVar.VarType of
                  vInteger: begin
                      if n3C > 1 then begin
                        Inc(DynamicVar.nInternet, n3C);
                      end else begin
                        Inc(DynamicVar.nInternet);
                      end;
                    end;
                  vString: begin
                      DynamicVar.sString:= DynamicVar.sString + s01;//20080530
                    end;
                end;
                boVarFound := True;
                Break;
              end;
            end;
          end;//for
        end;
        if not boVarFound then begin
          ScriptActionError(PlayObject, Format(sVarFound, [sParam2, sParam1]), QuestActionInfo, sINC);
          Exit;
        end;
        Exit;
      end;
      if n10 = 0 then
        ScriptActionError(PlayObject, '', QuestActionInfo, sINC);
    end else begin
      if (sParam2 <> '') and (not IsStringNumber(sParam2)) then begin //获取第2个变量值
        n14 := GetValNameNo(sParam2);
        if n14 >= 0 then begin
          case n14 of
            0..99: begin //20080323 原为0..99
                n3C := PlayObject.m_nVal[n14];
              end;
            100..199: begin
                n3C := g_Config.GlobalVal[n14 - 100];
              end;
            200..299: begin //20080323 原为200..209
                n3C := PlayObject.m_DyVal[n14 - 200];
              end;
            300..399: begin
                n3C := PlayObject.m_nMval[n14 - 300];
              end;
            400..499: begin
                n3C := g_Config.GlobaDyMval[n14 - 400];
              end;
            500..599: begin
                n3C := PlayObject.m_nInteger[n14 - 500];
              end;
            600..699: begin
                s01 := PlayObject.m_sString[n14 - 600];
              end;
            700..799: begin
                s01 := g_Config.GlobalAVal[n14 - 700];
              end;
            800..1199:begin//20080903 G变量
                n3C := g_Config.GlobalVal[n14 - 700];
              end;
            1200..2099:begin//A变量(100-999)
                s01 := g_Config.GlobalAVal[n14 - 1100];
              end;
            2100..2599: begin//G变量(500-999)
                n3C := g_Config.GlobalVal[n14 - 1600];
              end;
          else begin
              ScriptActionError(PlayObject, '', QuestActionInfo, sINC);
              Exit;
            end;
          end;
        end else begin
           n3C := Str_ToInt(GetLineVariableText(PlayObject, sParam2),0);//20090111 对个人变量的支持
           s01 := GetLineVariableText(PlayObject, sParam2){sParam2};//20090725
        end;
      end else n3C := QuestActionInfo.nParam2;
      n14 := GetValNameNo(sParam1);
      if n14 >= 0 then begin
        case n14 of
          0..99: begin //20080323 原为0..99
              if n3C > {1}0 then begin
                Inc(PlayObject.m_nVal[n14], n3C);
              {end else begin
                Inc(PlayObject.m_nVal[n14]); }
              end;
            end;
          100..199: begin
              if n3C > {1}0 then begin
                Inc(g_Config.GlobalVal[n14 - 100], n3C);
              {end else begin
                Inc(g_Config.GlobalVal[n14 - 100]); }
              end;
            end;
          200..299: begin //20080323 原为200..209
              if n3C > {1}0 then begin
                Inc(PlayObject.m_DyVal[n14 - 200], n3C);
              {end else begin
                Inc(PlayObject.m_DyVal[n14 - 200]); }
              end;
            end;
          300..399: begin
              if n3C > {1}0 then begin
                Inc(PlayObject.m_nMval[n14 - 300], n3C);
              {end else begin
                Inc(PlayObject.m_nMval[n14 - 300]); }
              end;
            end;
          400..499: begin
              if n3C > {1}0 then begin
                Inc(g_Config.GlobaDyMval[n14 - 400], n3C);
              {end else begin
                Inc(g_Config.GlobaDyMval[n14 - 400]);   }
              end;
            end;
          500..599: begin
              if n3C > {1}0 then begin
                Inc(PlayObject.m_nInteger[n14 - 500], n3C);
              {end else begin
                Inc(PlayObject.m_nInteger[n14 - 500]);}
              end;
            end;
          600..699: begin
              PlayObject.m_sString[n14 - 600]:= PlayObject.m_sString[n14 - 600]+ s01;
            end;
          700..799: begin
              g_Config.GlobalAVal[n14 - 700]:= g_Config.GlobalAVal[n14 - 700]+ s01;
            end;
          800..1199:begin//20080903 G变量
              if n3C > {1}0 then begin
                Inc(g_Config.GlobalVal[n14 - 700], n3C);
              {end else begin
                Inc(g_Config.GlobalVal[n14 - 700]); }
              end;
            end;
          1200..2099:begin//A变量(100-999)
              g_Config.GlobalAVal[n14 - 1100]:= g_Config.GlobalAVal[n14 - 1100]+ s01;
            end;
          2100..2599: begin//G变量(500-999)
              if n3C > {1}0 then begin
                Inc(g_Config.GlobalVal[n14 - 1600], n3C);
              {end else begin
                Inc(g_Config.GlobalVal[n14 - 1600]);}
              end;
            end;
        else begin
            ScriptActionError(PlayObject, '', QuestActionInfo, sINC);
            Exit;
          end;
        end;
      end else begin
        ScriptActionError(PlayObject, '', QuestActionInfo, sINC);
        Exit;
      end;
    end;
  end;

  procedure DecInteger(QuestActionInfo: pTQuestActionInfo);
  var
    I, n14, n3C, n10: Integer;
    DynamicVar: pTDynamicVar;
    DynamicVarList: TList;
    sName,s01,s02,s03: string;
    boVarFound: Boolean;
    sParam1: string;
    sParam2: string;
    sParam3: string;
  resourcestring
    sVarFound = '变量%s不存在，变量类型:%s';
    sVarTypeError = '变量类型错误，错误类型:%s 当前支持类型(HUMAN、GUILD、GLOBAL)';
  begin
    n10 := 0;
    if CompareLStr(QuestActionInfo.sParam1, '<$STR(', 6{Length('<$STR(')}) then //20080228 支持字符串变量
      ArrestStringEx(QuestActionInfo.sParam1, '(', ')', sParam1)
    else sParam1 := {QuestActionInfo.sParam1}GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//20090716 修改

    if CompareLStr(QuestActionInfo.sParam2, '<$STR(', 6{Length('<$STR(')}) then //20080228 支持字符串变量
      ArrestStringEx(QuestActionInfo.sParam2, '(', ')', sParam2)
    else sParam2 := {QuestActionInfo.sParam2}GetLineVariableText(PlayObject, QuestActionInfo.sParam2);//20090716 修改

    if CompareLStr(QuestActionInfo.sParam3, '<$STR(', 6{Length('<$STR(')}) then  //20080228 支持字符串变量
      ArrestStringEx(QuestActionInfo.sParam3, '(', ')', sParam3)
    else sParam3 := {QuestActionInfo.sParam3}GetLineVariableText(PlayObject, QuestActionInfo.sParam3);//20090716 修改

    if (sParam1 = '') or (sParam2 = '') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sDEC);
      Exit;
    end;
    if sParam3 <> '' then begin
      if (not IsVarNumber(sParam1)) and (IsVarNumber(sParam2)) then begin
        n10 := 1;
        boVarFound := False;
        DynamicVarList := GetDynamicVarList(PlayObject, sParam2, sName);
        if DynamicVarList = nil then begin
          ScriptActionError(PlayObject, Format(sVarTypeError, [sParam2]), QuestActionInfo, sDEC);
          Exit;
        end;
        if DynamicVarList.Count > 0 then begin//20080629
          for I := 0 to DynamicVarList.Count - 1 do begin
            DynamicVar := DynamicVarList.Items[I];
            if CompareText(DynamicVar.sName, sParam3) = 0 then begin
              case DynamicVar.VarType of
                vInteger: begin
                    n3C := DynamicVar.nInternet;
                  end;
                vString: begin
                    s01 := DynamicVar.sString;//20080530
                  end;
              end;
              boVarFound := True;
              Break;
            end;
          end;//for
        end;
        if not boVarFound then begin
          ScriptActionError(PlayObject, Format(sVarFound, [sParam3, sParam2]), QuestActionInfo, sDEC);
          Exit;
        end;
        n14 := GetValNameNo(sParam1);
        if n14 >= 0 then begin
          case n14 of
            0..99: begin //20080323 原为0..99
                if n3C > {1}0 then begin
                  Dec(PlayObject.m_nVal[n14], n3C);
                {end else begin
                  Dec(PlayObject.m_nVal[n14]); }
                end;
              end;
            100..199: begin
                if n3C > {1}0 then begin
                  Dec(g_Config.GlobalVal[n14 - 100], n3C);
                {end else begin
                  Dec(g_Config.GlobalVal[n14 - 100]); }
                end;
              end;
            200..299: begin //20080323 原为200..209
                if n3C > {1}0 then begin
                  Dec(PlayObject.m_DyVal[n14 - 200], n3C);
                {end else begin
                  Dec(PlayObject.m_DyVal[n14 - 200]); }
                end;
              end;
            300..399: begin
                if n3C > {1}0 then begin
                  Dec(PlayObject.m_nMval[n14 - 300], n3C);
                {end else begin
                  Dec(PlayObject.m_nMval[n14 - 300]);  }
                end;
              end;
            400..499: begin
                if n3C > {1}0 then begin
                  Dec(g_Config.GlobaDyMval[n14 - 400], n3C);
                {end else begin
                  Dec(g_Config.GlobaDyMval[n14 - 400]);}
                end;
              end;
            500..599: begin
                if n3C > {1}0 then begin
                  Dec(PlayObject.m_nInteger[n14 - 500], n3C);
                {end else begin
                  Dec(PlayObject.m_nInteger[n14 - 500]); }
                end;
              end;
            600..699: begin //20080530
                n10 := Pos(s01, PlayObject.m_sString[n14 - 600]);
                s02:= Copy(PlayObject.m_sString[n14 - 600], 1, n10 - 1);
                s03:= Copy(PlayObject.m_sString[n14 - 600], Length(s01) + n10, Length(PlayObject.m_sString[n14 - 600]));
                PlayObject.m_sString[n14 - 600] := s02 + s03;
              end;
            700..799: begin //20080530
                n10 := Pos(s01, g_Config.GlobalAVal[n14 - 700]);
                s02:= Copy(g_Config.GlobalAVal[n14 - 700], 1, n10 - 1);
                s03:= Copy(g_Config.GlobalAVal[n14 - 700], Length(s01) + n10, Length(g_Config.GlobalAVal[n14 - 700]));
                g_Config.GlobalAVal[n14 - 700] := s02 + s03;
              end;
            800..1199:begin//20080903 G变量
                if n3C > {1}0 then begin
                  Dec(g_Config.GlobalVal[n14 - 700], n3C);
                {end else begin
                  Dec(g_Config.GlobalVal[n14 - 700]); }
                end;
              end;
            1200..2099:begin//A变量(100-999)
                n10 := Pos(s01, g_Config.GlobalAVal[n14 - 1100]);
                s02:= Copy(g_Config.GlobalAVal[n14 - 1100], 1, n10 - 1);
                s03:= Copy(g_Config.GlobalAVal[n14 - 1100], Length(s01) + n10, Length(g_Config.GlobalAVal[n14 - 1100]));
                g_Config.GlobalAVal[n14 - 1100] := s02 + s03;
              end;
             2100..2599: begin//G变量(500-999)
                if n3C > {1}0 then begin
                  Dec(g_Config.GlobalVal[n14 - 1600], n3C);
                {end else begin
                  Dec(g_Config.GlobalVal[n14 - 1600]); }
                end;
              end;
          else begin
              ScriptActionError(PlayObject, '', QuestActionInfo, sDEC);
              Exit;
            end;
          end;
        end else begin
          ScriptActionError(PlayObject, '', QuestActionInfo, sDEC);
          Exit;
        end;
        Exit;
      end;
      if (IsVarNumber(sParam1)) and (not IsVarNumber(sParam2)) then begin
        if (sParam3 <> '') and (not IsStringNumber(sParam3)) then begin
          n10 := 1;
          n14 := GetValNameNo(sParam3);
          if n14 >= 0 then begin
            case n14 of
              0..99: begin //20080323 原为0..99
                  n3C := PlayObject.m_nVal[n14];
                end;
              100..199: begin
                  n3C := g_Config.GlobalVal[n14 - 100];
                end;
              200..299: begin //20080323 原为200..209
                  n3C := PlayObject.m_DyVal[n14 - 200];
                end;
              300..399: begin
                  n3C := PlayObject.m_nMval[n14 - 300];
                end;
              400..499: begin
                  n3C := g_Config.GlobaDyMval[n14 - 400];
                end;
              500..599: begin
                  n3C := PlayObject.m_nInteger[n14 - 500];
                end;
              600..699: begin
                  s01 := PlayObject.m_sString[n14 - 600];
                end;
              700..799: begin
                  s01 := g_Config.GlobalAVal[n14 - 700];
                end;
              800..1199:begin//20080903 G变量
                  n3C := g_Config.GlobalVal[n14 - 700];
                end;
              1200..2099:begin//A变量(100-999)
                  s01 := g_Config.GlobalAVal[n14 - 1100];
                end;
              2100..2599: begin//G变量(500-999)
                  n3C := g_Config.GlobalVal[n14 - 1600];
                end;
            else begin
                ScriptActionError(PlayObject, '', QuestActionInfo, sDEC);
                Exit;
              end;
            end;
          end else begin
            s01 := sParam3;//20080530
          end;
        end else n3C := QuestActionInfo.nParam3;
        boVarFound := False;
        DynamicVarList := GetDynamicVarList(PlayObject, sParam1, sName);
        if DynamicVarList = nil then begin
          ScriptActionError(PlayObject, Format(sVarTypeError, [sParam1]), QuestActionInfo, sDEC);
          Exit;
        end;
        if DynamicVarList.Count > 0 then begin//20080629
          for I := 0 to DynamicVarList.Count - 1 do begin
            DynamicVar := DynamicVarList.Items[I];
            if CompareText(DynamicVar.sName, sParam2) = 0 then begin
              case DynamicVar.VarType of
                vInteger: begin
                    if n3C > 1 then begin
                      Dec(DynamicVar.nInternet, n3C);
                    end else begin
                      Dec(DynamicVar.nInternet);
                    end;
                  end;
                vString: begin//20080530
                    n10 := Pos(s01, DynamicVar.sString);
                    s02:= Copy(DynamicVar.sString, 1, n10 - 1);
                    s03:= Copy(DynamicVar.sString, Length(s01) + n10, Length(DynamicVar.sString));
                    DynamicVar.sString := s02 + s03;
                  end;
              end;
              boVarFound := True;
              Break;
            end;
          end;//for
        end;
        if not boVarFound then begin
          ScriptActionError(PlayObject, Format(sVarFound, [sParam2, sParam1]), QuestActionInfo, sDEC);
          Exit;
        end;
        Exit;
      end;
      if n10 = 0 then
        ScriptActionError(PlayObject, '', QuestActionInfo, sDEC);
    end else begin//sParam3 = ''
      if (sParam2 <> '') and (not IsStringNumber(sParam2)) then begin //获取第2个变量值
        n14 := GetValNameNo(sParam2);
        if n14 >= 0 then begin
          case n14 of
            0..99: begin //20080323 原为0..99
                n3C := PlayObject.m_nVal[n14];
              end;
            100..199: begin
                n3C := g_Config.GlobalVal[n14 - 100];
              end;
            200..299: begin //20080323 原为200..209
                n3C := PlayObject.m_DyVal[n14 - 200];
              end;
            300..399: begin
                n3C := PlayObject.m_nMval[n14 - 300];
              end;
            400..499: begin
                n3C := g_Config.GlobaDyMval[n14 - 400];
              end;
            500..599: begin
                n3C := PlayObject.m_nInteger[n14 - 500];
              end;
            600..699: begin
                s01 := PlayObject.m_sString[n14 - 600];
              end;
            700..799: begin
                s01 := g_Config.GlobalAVal[n14 - 700];
              end;
            800..1199:begin//20080903 G变量
                n3C := g_Config.GlobalVal[n14 - 700];
              end;
            1200..2099:begin//A变量(100-999)
                s01 := g_Config.GlobalAVal[n14 - 1100];
              end;
            2100..2599: begin//G变量(500-999)
                n3C := g_Config.GlobalVal[n14 - 1600];
              end;
          else begin
              ScriptActionError(PlayObject, '', QuestActionInfo, sDEC);
              Exit;
            end;
          end;
        end else begin
           n3C := Str_ToInt(GetLineVariableText(PlayObject, sParam2),0);//20090111 对个人变量的支持
           s01 := GetLineVariableText(PlayObject, sParam2){sParam2};//20090725
        end;
      end else n3C := QuestActionInfo.nParam2;
      n14 := GetValNameNo(sParam1);
      if n14 >= 0 then begin
        case n14 of
          0..99: begin //20080323 原为0..99
              if n3C > {1}0 then begin
                Dec(PlayObject.m_nVal[n14], n3C);
              {end else begin
                Dec(PlayObject.m_nVal[n14]); }
              end;
            end;
          100..199: begin
              if n3C > {1}0 then begin
                Dec(g_Config.GlobalVal[n14 - 100], n3C);
              {end else begin
                Dec(g_Config.GlobalVal[n14 - 100]); }
              end;
            end;
          200..299: begin //20080323 原为200..209
              if n3C > {1}0 then begin
                Dec(PlayObject.m_DyVal[n14 - 200], n3C);
              {end else begin
                Dec(PlayObject.m_DyVal[n14 - 200]); }
              end;
            end;
          300..399: begin
              if n3C > {1}0 then begin
                Dec(PlayObject.m_nMval[n14 - 300], n3C);
             { end else begin
                Dec(PlayObject.m_nMval[n14 - 300]); }
              end;
            end;
          400..499: begin
              if n3C > {1}0 then begin
                Dec(g_Config.GlobaDyMval[n14 - 400], n3C);
              {end else begin
                Dec(g_Config.GlobaDyMval[n14 - 400]);  }
              end;
            end;
          500..599: begin
              if n3C > {1}0 then begin
                Dec(PlayObject.m_nInteger[n14 - 500], n3C);
              {end else begin
                Dec(PlayObject.m_nInteger[n14 - 500]); }
              end;
            end;
          600..699: begin //20080530
              n10 := Pos(s01, PlayObject.m_sString[n14 - 600]);
              s02:= Copy(PlayObject.m_sString[n14 - 600], 1, n10 - 1);
              s03:= Copy(PlayObject.m_sString[n14 - 600], Length(s01) + n10, Length(PlayObject.m_sString[n14 - 600]));
              PlayObject.m_sString[n14 - 600] := s02 + s03;
            end;
          700..799: begin //20080530
              n10 := Pos(s01, g_Config.GlobalAVal[n14 - 700]);
              s02:= Copy(g_Config.GlobalAVal[n14 - 700], 1, n10 - 1);
              s03:= Copy(g_Config.GlobalAVal[n14 - 700], Length(s01) + n10, Length(g_Config.GlobalAVal[n14 - 700]));
              g_Config.GlobalAVal[n14 - 700] := s02 + s03;
            end;
          800..1199:begin//20080903 G变量
              if n3C > {1}0 then begin
                Dec(g_Config.GlobalVal[n14 - 700], n3C);
              {end else begin
                Dec(g_Config.GlobalVal[n14 - 700]);}
              end;
            end;
          1200..2099:begin//A变量(100-999)
              n10 := Pos(s01, g_Config.GlobalAVal[n14 - 1100]);
              s02:= Copy(g_Config.GlobalAVal[n14 - 1100], 1, n10 - 1);
              s03:= Copy(g_Config.GlobalAVal[n14 - 1100], Length(s01) + n10, Length(g_Config.GlobalAVal[n14 - 1100]));
              g_Config.GlobalAVal[n14 - 1100] := s02 + s03;
            end;
          2100..2599: begin//G变量(500-999)
              if n3C > {1}0 then begin
                Dec(g_Config.GlobalVal[n14 - 1600], n3C);
              {end else begin
                Dec(g_Config.GlobalVal[n14 - 1600]);}
              end;
            end;
        else begin
            ScriptActionError(PlayObject, '', QuestActionInfo, sDEC);
            Exit;
          end;
        end;
      end else begin
        ScriptActionError(PlayObject, '', QuestActionInfo, sDEC);
        Exit;
      end;
    end;
  end;

  function QuestActionProcess(ActionList: TList): Boolean;
  var
    I, II, III: Integer;
    QuestActionInfo: pTQuestActionInfo;
    n14, n18, n1C, n28, n2C: Integer;
    n20X, n24Y, n34, n38, n3C, n40: Integer;
    s4C, s50: string;
    s34, s44, s48: string;
    Envir: TEnvirnoment;
    List58: TList;
    User: TPlayObject;
    DynamicVar: pTDynamicVar;
    DynamicVarList: TList;
    sName: string;
    OnlinePlayObject: TPlayObject;
    GuildRank: pTGuildRank;
    UserObject: TPlayObject;
    fun: string;
    CMDCode: Integer;
    m_boCheck: Boolean;
  begin
    Result := True;

    n18 := 0;
    n34 := 0;
    n38 := 0;
    n3C := 0;
    n40 := 0;
    //try
      if ActionList = nil then Exit;//20090103 
      if ActionList.Count > 0 then begin//20081008
        for I := 0 to ActionList.Count - 1 do begin
          QuestActionInfo := ActionList.Items[I];
          if QuestActionInfo <> nil then begin//20090103
            BaseObject := QuestActionInfo.Script.GetBaseObject(Self, AObject); //转换运行对象,NPC扩展 20090926
            if BaseObject = nil then begin
              Result := False;
              Break;
            end else begin
              if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
                PlayObject := TPlayObject(BaseObject) else PlayObject := nil;
            end;
            CMDCode:= QuestActionInfo.nCMDCode;//20090103
            case QuestActionInfo.nCMDCode of
              nSET: begin
                  if IsPlayObject then begin
                    n28 := Str_ToInt(QuestActionInfo.sParam1, 0);
                    n2C := Str_ToInt(QuestActionInfo.sParam2, 0);
                    PlayObject.SetQuestFlagStatus(n28, n2C);
                  end;
                end;
              nTAKE: TakeItem(QuestActionInfo.sParam1, QuestActionInfo.nParam2, QuestActionInfo.sParam2, QuestActionInfo.sParam3);//20090323
              nSC_GIVE: ActionOfGiveItem(PlayObject, QuestActionInfo);//给物品
              nTAKEW: begin
                  if (QuestActionInfo.sParam1 <> '') and (QuestActionInfo.sParam1[1] = '<') and (QuestActionInfo.sParam1[2] = '$') then
                    s4C:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1)//20081204
                  else
                  if not GetValValue(PlayObject, QuestActionInfo.sParam1, s4C) then begin //增加变量支持
                    s4C := QuestActionInfo.sParam1;
                  end;

                  if (QuestActionInfo.sParam2 <> '') and (QuestActionInfo.sParam2[1] = '<') and (QuestActionInfo.sParam2[2] = '$') then//增加支持<$Str()> 20081204
                    n14 := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2),0)
                  else
                  if not GetValValue(PlayObject, QuestActionInfo.sParam2, n14) then begin //增加变量支持
                    n14 := QuestActionInfo.nParam2;
                  end;
                  TakeWItem(s4C, n14);
                end;
              nCLOSE: PlayObject.SendMsg(Self, RM_MERCHANTDLGCLOSE, 0, Integer(Self), 0, 0, '');
              nRESET: begin//重置任务标签
                  if IsPlayObject then begin
                    if QuestActionInfo.nParam2 <= 0 then QuestActionInfo.nParam2:= 1;
                    for II := 0 to QuestActionInfo.nParam2 - 1 do begin
                      PlayObject.SetQuestFlagStatus(QuestActionInfo.nParam1 + II, 0);
                    end;
                  end;
                end;
              nBREAK: begin
                  if QuestActionInfo.nParam1 <> 0 then begin //20080713
                    if (QuestActionInfo.nParam1= 1) or (QuestActionInfo.nParam1= 2) then Result := False;
                  end else Result := False;
                end;
              nTIMERECALL: begin
                  if IsPlayObject then begin
                    PlayObject.m_boTimeRecall := True;
                    PlayObject.m_sMoveMap := PlayObject.m_sMapName;
                    PlayObject.m_nMoveX := PlayObject.m_nCurrX;
                    PlayObject.m_nMoveY := PlayObject.m_nCurrY;
                    PlayObject.m_dwTimeRecallTick := GetTickCount + LongWord(QuestActionInfo.nParam1 * 60000{60 * 1000});
                  end;
                end;
              nSC_PARAM1: begin //20080602 修改
                  n34:=Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam1),0);
                  s44:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1);
                  (*if CompareLStr(QuestActionInfo.sParam1, '<$MAP>', 6{Length('<$MAP>')}) then begin//20080321 增加支持<$MAP>
                    n34 := Str_ToInt(PlayObject.m_PEnvir.sMapName,-1);
                    s44 := PlayObject.m_PEnvir.sMapName;
                  end else begin
                    n34 := QuestActionInfo.nParam1;
                    s44 := QuestActionInfo.sParam1;
                  end; *)
                end;
              nSC_PARAM2: begin
                  //n38 := QuestActionInfo.nParam1;
                  //s48 := QuestActionInfo.sParam1;
                  n38:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam1),0);//20080923
                  s48:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//20080923
                end;
              nSC_PARAM3: begin
                  //n3C := QuestActionInfo.nParam1;
                  //s4C := QuestActionInfo.sParam1;
                  n3C:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam1),0);//20080923
                  s4C:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//20080923
                end;
              nSC_PARAM4: begin
                  //n40 := QuestActionInfo.nParam1;
                  //s50 := QuestActionInfo.sParam1;
                  n40:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam1),0);//20080923
                  s50:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//20080923
                end;
              nSC_EXEACTION: begin
                  if IsPlayObject then begin
                    n40 := QuestActionInfo.nParam1;
                    s50 := QuestActionInfo.sParam1;
                    ExeAction(PlayObject, QuestActionInfo.sParam1, QuestActionInfo.sParam2, QuestActionInfo.sParam3, QuestActionInfo.nParam1, QuestActionInfo.nParam2, QuestActionInfo.nParam3);
                  end;
                end;
              nMAPMOVE: begin
                  if IsPlayObject then begin
                    if (QuestActionInfo.sParam1 <> '') and (QuestActionInfo.sParam1[1] = '<') and (QuestActionInfo.sParam1[2] = '$') then//增加支持<$Str()> 20080609
                      s4C := GetLineVariableText(PlayObject, QuestActionInfo.sParam1)
                    else s4C := QuestActionInfo.sParam1;//20080915

                    if (QuestActionInfo.sParam2 <> '') and (QuestActionInfo.sParam2[1] = '<') and (QuestActionInfo.sParam2[2] = '$') then//增加支持<$Str()> 20080609
                      n14 := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2),0)
                    else
                    if not GetValValue(PlayObject, QuestActionInfo.sParam2, n14) then begin //增加变量支持
                      n14 := QuestActionInfo.nParam2;
                    end;

                    if (QuestActionInfo.sParam3 <> '') and (QuestActionInfo.sParam3[1] = '<') and (QuestActionInfo.sParam3[2] = '$') then//增加支持<$Str()> 20080609
                      n40 := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3),0)
                    else
                    if not GetValValue(PlayObject, QuestActionInfo.sParam3, n40) then begin //增加变量支持
                      n40 := QuestActionInfo.nParam3;
                    end;
                    PlayObject.SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
                    PlayObject.SpaceMove(s4C, n14, n40, 0);
                    bo11 := True;
                  end;
                end;
              nMAP: begin
                  if IsPlayObject and (not PlayObject.InMag113LockRect(PlayObject.m_nCurrX, PlayObject.m_nCurrY)) then begin
                    if (QuestActionInfo.sParam1 <> '') and (QuestActionInfo.sParam1[1] = '<') and (QuestActionInfo.sParam1[2] = '$') then//增加支持<$Str()>
                       s4C := GetLineVariableText(PlayObject, QuestActionInfo.sParam1)
                    else s4C := QuestActionInfo.sParam1;//20080915
                    {if not GetValValue(PlayObject, QuestActionInfo.sParam1, s4C) then begin //增加变量支持
                      s4C := QuestActionInfo.sParam1;
                    end;}
                    PlayObject.SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
                    PlayObject.MapRandomMove(s4C, 0);
                    bo11 := True;
                  end;
                end;
              nTAKECHECKITEM: begin
                  if IsPlayObject then begin
                    if UserItem <> nil then begin
                      PlayObject.QuestTakeCheckItem(UserItem);
                    end else begin
                      ScriptActionError(PlayObject, '', QuestActionInfo, sTAKECHECKITEM);
                    end;
                  end;
                end;
              nMONGEN: begin//20080602 扩展支持变量
                  s34:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//怪物名
                  n34:=Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3),0);//范围
                  n40:=Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2),1);//数量 20080816 修改
                  if n40 <= 0 then n40:=1;//20091113 增加
                  for II := 0 to n40 - 1 do begin
                    n20X := Random(n34 * 2 + 1) + (n38 - n34);
                    n24Y := Random(n34 * 2 + 1) + (n3C - n34);
                    UserEngine.RegenMonsterByName(s44, n20X, n24Y, s34); //地图,X,Y,名字
                  end;
                end;
              nMONCLEAR: begin
                  List58 := TList.Create;
                  s34:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//20080602 支持变量
                  UserEngine.GetMapMonster(g_MapManager.FindMap(s34{QuestActionInfo.sParam1}), List58);
                  if List58.Count > 0 then begin//20080629
                    for II := 0 to List58.Count - 1 do begin
                      TBaseObject(List58.Items[II]).m_boNoItem := True;
                      TBaseObject(List58.Items[II]).m_WAbil.HP := 0;
                    end;
                  end;
                  List58.Free;
                end;
              nMOV: if IsPlayObject then MovData(QuestActionInfo);
              nINC: if IsPlayObject then IncInteger(QuestActionInfo);
              nDEC: if IsPlayObject then DecInteger(QuestActionInfo);
              nSUM: begin
                  if IsPlayObject then begin
                    n18 := 0;
                    if CompareLStr(QuestActionInfo.sParam1, '<$STR(', 6{Length('<$STR(')}) then begin //20080228 SUM 支持字符串变量
                      ArrestStringEx(QuestActionInfo.sParam1, '(', ')', s34);
                      n14 := GetValNameNo(s34);
                    end else n14 := GetValNameNo(QuestActionInfo.sParam1);

                    if n14 >= 0 then begin
                      case n14 of //
                        0..99: begin //20080323 原为0..99
                            n18 := PlayObject.m_nVal[n14];
                          end;
                        100..199: begin
                            n18 := g_Config.GlobalVal[n14 - 100];
                          end;
                        200..299: begin //20080323 原为200..209
                            n18 := PlayObject.m_DyVal[n14 - 200];
                          end;
                        300..399: begin
                            n18 := PlayObject.m_nMval[n14 - 300];
                          end;
                        400..499: begin
                            n18 := g_Config.GlobaDyMval[n14 - 400];
                          end;
                        500..599: begin
                            n18 := PlayObject.m_nInteger[n14 - 500];
                          end;
                        600..699: begin //20080411
                            s44 := PlayObject.m_sString[n14 - 600];
                          end;
                        700..799: begin //20080411
                            s44 := g_Config.GlobalAVal[n14 - 700];
                          end;
                        800..1199:begin//20080903 G变量
                            n18 := g_Config.GlobalVal[n14 - 700];
                          end;
                        1200..2099:begin//A变量(100-999)
                            s44 := g_Config.GlobalAVal[n14 - 1100];
                          end;
                        2100..2599: begin//G变量(500-999)
                            n18 := g_Config.GlobalVal[n14 - 1600];
                          end;
                      else begin
                          ScriptActionError(PlayObject, '', QuestActionInfo, sSUM);
                        end;
                      end; // case
                    end else begin
                      ScriptActionError(PlayObject, '', QuestActionInfo, sSUM);
                    end;
                    n1C := 0;

                    if CompareLStr(QuestActionInfo.sParam2, '<$STR(', 6{Length('<$STR(')}) then begin //20080228 SUM 支持字符串变量
                      ArrestStringEx(QuestActionInfo.sParam2, '(', ')', s34);
                      n14 := GetValNameNo(s34);
                    end else n14 := GetValNameNo(QuestActionInfo.sParam2);

                    if n14 >= 0 then begin
                      case n14 of //
                        0..99: begin //20080323 原为0..99
                            n1C := PlayObject.m_nVal[n14];
                          end;
                        100..199: begin
                            n1C := g_Config.GlobalVal[n14 - 100];
                          end;
                        200..299: begin //20080323 原为200..209
                            n1C := PlayObject.m_DyVal[n14 - 200];
                          end;
                        300..399: begin
                            n1C := PlayObject.m_nMval[n14 - 300];
                          end;
                        400..499: begin
                            n1C := g_Config.GlobaDyMval[n14 - 400];
                          end;
                        500..599: begin
                            n1C := PlayObject.m_nInteger[n14 - 500];
                          end;
                        600..699: begin //20080411
                            s48 := PlayObject.m_sString[n14 - 600];
                          end;
                        700..799: begin //20080411
                            s48 := g_Config.GlobalAVal[n14 - 700];
                          end;
                        800..1199:begin//20080903 G变量
                            n1C := g_Config.GlobalVal[n14 - 700];
                          end;
                        1200..2099:begin//A变量(100-999)
                            s48 := g_Config.GlobalAVal[n14 - 1100];
                          end;
                        2100..2599: begin//G变量(500-999)
                            n1C := g_Config.GlobalVal[n14 - 1600];
                          end;
                      else begin
                          ScriptActionError(PlayObject, '', QuestActionInfo, sSUM);
                        end;
                      end;
                    end else begin
                      //ScriptActionError(PlayObject,'',QuestActionInfo,sSUM);
                    end;

                    if CompareLStr(QuestActionInfo.sParam1, '<$STR(', 6{Length('<$STR(')}) then begin //20080228 SUM 支持字符串变量
                      ArrestStringEx(QuestActionInfo.sParam1, '(', ')', s34);
                      n14 := GetValNameNo(s34);
                    end else n14 := GetValNameNo(QuestActionInfo.sParam1);
                    if n14 >= 0 then begin
                      case n14 of //
                        0..99: begin //20080323 原为0..99
                            PlayObject.m_nVal[n14] := {PlayObject.m_nVal[n14] +} n18 + n1C; //20080411
                          end;
                        100..199: begin
                            g_Config.GlobalVal[n14 - 100] := {g_Config.GlobalVal[n14 - 100] +} n18 + n1C;
                          end;
                        200..299: begin //20080323 原为200..209
                            PlayObject.m_DyVal[n14 - 200] := {PlayObject.m_DyVal[n14 - 200] +} n18 + n1C;
                          end;
                        300..399: begin
                            PlayObject.m_nMval[n14 - 300] := {PlayObject.m_nMval[n14 - 300] +} n18 + n1C;
                          end;
                        400..499: begin
                            g_Config.GlobaDyMval[n14 - 400] := {g_Config.GlobaDyMval[n14 - 400] +} n18 + n1C;
                          end;
                        500..599: begin
                            PlayObject.m_nInteger[n14 - 500] := {PlayObject.m_nInteger[n14 - 500] +} n18 + n1C;
                          end;
                         600..699: begin //20080411
                            PlayObject.m_sString[n14 - 600] := s44 + s48;
                          end;
                        700..799: begin //20080411
                            g_Config.GlobalAVal[n14 - 700] := s44 + s48;
                          end;
                        800..1199:begin//20080903 G变量
                            g_Config.GlobalVal[n14 - 700] := {g_Config.GlobalVal[n14 - 700] +} n18 + n1C;
                          end;
                        1200..2099:begin//A变量(100-999)
                            g_Config.GlobalAVal[n14 - 1100] := s44 + s48;
                          end;
                        2100..2599: begin//G变量(500-999)
                            g_Config.GlobalVal[n14 - 1600] := {g_Config.GlobalVal[n14 - 1600] +} n18 + n1C;
                          end;
                      end;
                    end;
                  end;
                end;
      //------------------------------------------------------------------------------
             nSC_DIV: begin //20080410 变量运算 除法  格式: DIV N1 N2 N3 即N1=N2/N3
                  if IsPlayObject then begin
                    n18 := 0;
                    n14:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2),-1);//20080410
                    if n14 < 0 then begin
                    {if CompareLStr(QuestActionInfo.sParam1, '<$STR(', Length('<$STR(')) then begin //20080228  支持字符串变量
                      ArrestStringEx(QuestActionInfo.sParam1, '(', ')', s34);         //取第一个变量,并传值给n18
                      n14 := GetValNameNo(s34);
                    end else }n14 := GetValNameNo(QuestActionInfo.sParam2);
                      if n14 >= 0 then begin
                        case n14 of //
                          0..99: begin //20080323 原为0..99
                              n18 := PlayObject.m_nVal[n14];
                            end;
                          100..199: begin
                              n18 := g_Config.GlobalVal[n14 - 100];
                            end;
                          200..299: begin //20080323 原为200..209
                              n18 := PlayObject.m_DyVal[n14 - 200];
                            end;
                          300..399: begin
                              n18 := PlayObject.m_nMval[n14 - 300];
                            end;
                          400..499: begin
                              n18 := g_Config.GlobaDyMval[n14 - 400];
                            end;
                          500..599: begin
                              n18 := PlayObject.m_nInteger[n14 - 500];
                            end;
                          800..1199:begin//20080903 G变量
                              n18 := g_Config.GlobalVal[n14 - 700];
                            end;
                          {1800..2799:begin//20080323 I变量
                              n18 := g_Config.GlobaDyMval[n14 - 1800];
                            end; }
                           2100..2599: begin//G变量(500-999)
                              n18 := g_Config.GlobalVal[n14 - 1600];
                            end;
                        else begin
                            ScriptActionError(PlayObject, '', QuestActionInfo, sSC_DIV);
                          end;
                        end; // case
                      end else begin
                        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_DIV);
                      end;
                    end else n18 := N14;

                    n1C := 0;
                    n14:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3),-1);//20080410
                    if n14 < 0 then begin
                    {if CompareLStr(QuestActionInfo.sParam2, '<$STR(', Length('<$STR(')) then begin //20080228  支持字符串变量
                      ArrestStringEx(QuestActionInfo.sParam2, '(', ')', s34);         //取第一个变量,并传值给n1C
                      n14 := GetValNameNo(s34);
                    end else} n14 := GetValNameNo(QuestActionInfo.sParam3);
                      if n14 >= 0 then begin
                        case n14 of //
                          0..99: begin //20080323 原为0..99
                              n1C := PlayObject.m_nVal[n14];
                            end;
                          100..199: begin
                              n1C := g_Config.GlobalVal[n14 - 100];
                            end;
                          200..299: begin //20080323 原为200..209
                              n1C := PlayObject.m_DyVal[n14 - 200];
                            end;
                          300..399: begin
                              n1C := PlayObject.m_nMval[n14 - 300];
                            end;
                          400..499: begin
                              n1C := g_Config.GlobaDyMval[n14 - 400];
                            end;
                          500..599: begin
                              n1C := PlayObject.m_nInteger[n14 - 500];
                            end;
                          800..1199:begin//20080903 G变量
                              n1C := g_Config.GlobalVal[n14 - 700];
                            end;
                         {1800..2799:begin//20080323 I变量
                              n1C := g_Config.GlobaDyMval[n14 - 1800];
                            end; }
                          2100..2599: begin//G变量(500-999)
                              n1C := g_Config.GlobalVal[n14 - 1600];
                            end;
                        else begin
                            ScriptActionError(PlayObject, '', QuestActionInfo, sSC_DIV);
                          end;
                        end;
                      end else begin
                        //ScriptActionError(PlayObject,'',QuestActionInfo,sSC_DIV);
                      end;
                    end else n1C := n14;

                    if CompareLStr(QuestActionInfo.sParam1, '<$STR(', 6{Length('<$STR(')}) then begin //20080228  支持字符串变量
                      ArrestStringEx(QuestActionInfo.sParam1, '(', ')', s34);
                      n14 := GetValNameNo(s34);
                    end else n14 := GetValNameNo(QuestActionInfo.sParam1);
                    if n14 >= 0 then begin
                      case n14 of //
                        0..99: begin //20080323 原为0..99
                            PlayObject.m_nVal[n14] := n18 div n1C;
                          end;
                        100..199: begin
                            g_Config.GlobalVal[n14 - 100] := n18 div n1C;
                          end;
                        200..299: begin //20080323 原为200..209
                             PlayObject.m_DyVal[n14 - 200] := n18 div n1C;
                          end;
                        300..399: begin
                             PlayObject.m_nMval[n14 - 300] := n18 div n1C;
                          end;
                        400..499: begin
                             g_Config.GlobaDyMval[n14 - 400] := n18 div n1C;
                          end;
                        500..599: begin
                             PlayObject.m_nInteger[n14 - 500] :=  n18 div n1C;
                          end;
                        800..1199:begin//20080903 G变量
                            g_Config.GlobalVal[n14 - 700] := n18 div n1C;
                          end;
                       {1800..2799:begin//20080323 I变量
                            g_Config.GlobaDyMval[999]:=  n18 div n1C;
                          end;}
                        2100..2599: begin//G变量(500-999)
                            g_Config.GlobalVal[n14 - 1600] := n18 div n1C;
                          end;
                      end;
                    end;
                  end;
                end;

             nSC_MUL: begin //20080410 变量运算 乘法  格式: MUL N1 N2 N3 即N1=N2*N3
                  if IsPlayObject then begin
                    n18 := 0;
                    n14:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2),-1);//20080410
                    if n14 < 0 then begin
                       {if CompareLStr(QuestActionInfo.sParam2, '<$STR(', Length('<$STR(')) then begin //20080228  支持字符串变量
                         ArrestStringEx(QuestActionInfo.sParam2, '(', ')', s34);
                         n14 := GetValNameNo(s34);
                       end else} n14 := GetValNameNo(QuestActionInfo.sParam2);//20080410

                      if n14 >= 0 then begin
                        case n14 of //
                          0..99: begin //20080323 原为0..99
                              n18 := PlayObject.m_nVal[n14];
                            end;
                          100..199: begin
                              n18 := g_Config.GlobalVal[n14 - 100];
                            end;
                          200..299: begin //20080323 原为200..209
                              n18 := PlayObject.m_DyVal[n14 - 200];
                            end;
                          300..399: begin
                              n18 := PlayObject.m_nMval[n14 - 300];
                            end;
                          400..499: begin
                              n18 := g_Config.GlobaDyMval[n14 - 400];
                            end;
                          500..599: begin
                              n18 := PlayObject.m_nInteger[n14 - 500];
                            end;
                          600..699: begin//20081226
                              n18 := Str_ToInt(PlayObject.m_sString[n14 - 600], 1);
                            end;
                          700..799: begin//20081226
                              n18 := Str_ToInt(g_Config.GlobalAVal[n14 - 700] , 1);
                            end;
                          800..1199:begin//20080903 G变量
                              n18 := g_Config.GlobalVal[n14 - 700];
                            end;
                          1200..2099:begin//A变量(100-999)
                              n18 := Str_ToInt(g_Config.GlobalAVal[n14 - 1100] , 1);
                            end;
                          2100..2599: begin//G变量(500-999)
                              n18 := g_Config.GlobalVal[n14 - 1600];
                            end;
                        else begin
                            ScriptActionError(PlayObject, '', QuestActionInfo, sSC_MUL);
                          end;
                        end; // case
                      end else begin
                        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_MUL);
                      end;
                    end else n18 := N14;
                    n1C := 0;

                    n14:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3),-1);//20080410
                    if n14 < 0 then begin
                       {if CompareLStr(QuestActionInfo.sParam3, '<$STR(', Length('<$STR(')) then begin //20080228  支持字符串变量
                         ArrestStringEx(QuestActionInfo.sParam3, '(', ')', s34);
                         n14 := GetValNameNo(s34);
                       end else} n14 := GetValNameNo(QuestActionInfo.sParam3);//20080410
                      if n14 >= 0 then begin
                        case n14 of //
                          0..99: begin //20080323 原为0..99
                              n1C := PlayObject.m_nVal[n14];
                            end;
                          100..199: begin
                              n1C := g_Config.GlobalVal[n14 - 100];
                            end;
                          200..299: begin //20080323 原为200..209
                              n1C := PlayObject.m_DyVal[n14 - 200];
                            end;
                          300..399: begin
                              n1C := PlayObject.m_nMval[n14 - 300];
                            end;
                          400..499: begin
                              n1C := g_Config.GlobaDyMval[n14 - 400];
                            end;
                          500..599: begin
                              n1C := PlayObject.m_nInteger[n14 - 500];
                            end;
                          600..699: begin//20081226
                              n1C := Str_ToInt(PlayObject.m_sString[n14 - 600], 1);
                            end;
                          700..799: begin//20081226
                              n1C := Str_ToInt(g_Config.GlobalAVal[n14 - 700] , 1);
                            end;
                          800..1199:begin//20080903 G变量
                              n1C := g_Config.GlobalVal[n14 - 700];
                            end;
                          1200..2099:begin//A变量(100-999)
                              n1C := Str_ToInt(g_Config.GlobalAVal[n14 - 1100] , 1);
                            end;
                          2100..2599: begin//G变量(500-999)
                              n1C := g_Config.GlobalVal[n14 - 1600];
                            end;
                        else begin
                            ScriptActionError(PlayObject, '', QuestActionInfo, sSC_MUL);
                          end;
                        end;
                      end else begin
                        //ScriptActionError(PlayObject,'',QuestActionInfo,sSC_MUL;
                      end;
                    end else n1C := n14;

                    if CompareLStr(QuestActionInfo.sParam1, '<$STR(', 6{Length('<$STR(')}) then begin //20080228  支持字符串变量
                      ArrestStringEx(QuestActionInfo.sParam1, '(', ')', s34);
                      n14 := GetValNameNo(s34);
                    end else n14 := GetValNameNo(QuestActionInfo.sParam1);//取第一个变量,并传值给n18
                    if n14 >= 0 then begin
                      case n14 of //
                        0..99: begin //20080323 原为0..99
                            PlayObject.m_nVal[n14] := n18 * n1C;
                          end;
                        100..199: begin
                            g_Config.GlobalVal[n14 - 100] := n18 * n1C;
                          end;
                        200..299: begin //20080323 原为200..209
                             PlayObject.m_DyVal[n14 - 200] := n18 * n1C;
                          end;
                        300..399: begin
                             PlayObject.m_nMval[n14 - 300] := n18 * n1C;
                          end;
                        400..499: begin
                             g_Config.GlobaDyMval[n14 - 400] := n18 * n1C;
                          end;
                        500..599: begin
                             PlayObject.m_nInteger[n14 - 500] :=  n18 * n1C;
                          end;
                        600..699: begin//20081226
                            PlayObject.m_sString[n14 - 600] := IntToStr(n18 * n1C);
                          end;
                        700..799: begin//20081226
                            g_Config.GlobalAVal[n14 - 700] := IntToStr(n18 * n1C);
                          end;
                        800..1199:begin//20080903 G变量
                            g_Config.GlobalVal[n14 - 700] := n18 * n1C;
                          end;
                        1200..2099:begin//A变量(100-999)
                            g_Config.GlobalAVal[n14 - 1100]:= IntToStr(n18 * n1C);
                          end;
                        2100..2599: begin//G变量(500-999)
                            g_Config.GlobalVal[n14 - 1600] := n18 * n1C;
                          end;
                      end;
                    end;
                  end;
                end;

             nSC_PERCENT: begin //20080410 变量运算 百分比  格式: PERCENT N1 N2 N3 即N1=(N2/N3)*100
                  if IsPlayObject then begin
                    n18 := 0;
                    n14:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2),-1);//20080410
                    if n14 < 0 then begin
                    {if CompareLStr(QuestActionInfo.sParam1, '<$STR(', Length('<$STR(')) then begin //20080228  支持字符串变量
                      ArrestStringEx(QuestActionInfo.sParam1, '(', ')', s34);
                      n14 := GetValNameNo(s34);
                    end else} n14 := GetValNameNo(QuestActionInfo.sParam2);//取第一个变量,并传值给n18
                      if n14 >= 0 then begin
                        case n14 of //
                          0..99: begin //20080323 原为0..99
                              n18 := PlayObject.m_nVal[n14];
                            end;
                          100..199: begin
                              n18 := g_Config.GlobalVal[n14 - 100];
                            end;
                          200..299: begin //20080323 原为200..209
                              n18 := PlayObject.m_DyVal[n14 - 200];
                            end;
                          300..399: begin
                              n18 := PlayObject.m_nMval[n14 - 300];
                            end;
                          400..499: begin
                              n18 := g_Config.GlobaDyMval[n14 - 400];
                            end;
                          500..599: begin
                              n18 := PlayObject.m_nInteger[n14 - 500];
                            end;
                          800..1199:begin//20080903 G变量
                              n18 := g_Config.GlobalVal[n14 - 700];
                            end;
                         {1800..2799:begin//20080323 I变量
                              n18 := g_Config.GlobaDyMval[n14 - 1800];
                            end; }
                          2100..2599: begin//G变量(500-999)
                              n18 := g_Config.GlobalVal[n14 - 1600];
                            end;
                        else begin
                            ScriptActionError(PlayObject, '', QuestActionInfo, sSC_PERCENT);
                          end;
                        end; // case
                      end else begin
                        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_PERCENT);
                      end;
                    end else n18 := n14;

                    n1C := 0;
                    n14:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3),-1);//20080410
                    if n14 < 0 then begin
                    {if CompareLStr(QuestActionInfo.sParam2, '<$STR(', Length('<$STR(')) then begin //20080228  支持字符串变量
                      ArrestStringEx(QuestActionInfo.sParam2, '(', ')', s34);
                      n14 := GetValNameNo(s34);
                    end else} n14 := GetValNameNo(QuestActionInfo.sParam3);//取第一个变量,并传值给n1C
                      if n14 >= 0 then begin
                        case n14 of //
                          0..99: begin //20080323 原为0..99
                              n1C := PlayObject.m_nVal[n14];
                            end;
                          100..199: begin
                              n1C := g_Config.GlobalVal[n14 - 100];
                            end;
                          200..299: begin //20080323 原为200..209
                              n1C := PlayObject.m_DyVal[n14 - 200];
                            end;
                          300..399: begin
                              n1C := PlayObject.m_nMval[n14 - 300];
                            end;
                          400..499: begin
                              n1C := g_Config.GlobaDyMval[n14 - 400];
                            end;
                          500..599: begin
                              n1C := PlayObject.m_nInteger[n14 - 500];
                            end;
                          800..1199:begin//20080903 G变量
                              n1C := g_Config.GlobalVal[n14 - 700];
                            end;
                         {1800..2799:begin//20080323 I变量
                              n1C := g_Config.GlobaDyMval[n14 - 1800];
                            end; }
                          2100..2599: begin//G变量(500-999)
                              n1C := g_Config.GlobalVal[n14 - 1600];
                            end;
                        else begin
                            ScriptActionError(PlayObject, '', QuestActionInfo, sSC_PERCENT);
                          end;
                        end;
                      end else begin
                        //ScriptActionError(PlayObject,'',QuestActionInfo,sSC_PERCENT);
                      end;
                    end else n1C := n14;

                    if CompareLStr(QuestActionInfo.sParam1, '<$STR(', 6{Length('<$STR(')}) then begin //20080228  支持字符串变量
                      ArrestStringEx(QuestActionInfo.sParam1, '(', ')', s34);
                      n14 := GetValNameNo(s34);
                    end else n14 := GetValNameNo(QuestActionInfo.sParam1);

                    if n14 >= 0 then begin
                      case n14 of //
                        0..99: begin //20080323 原为0..99
                            PlayObject.m_nVal[n14] := n18 div n1C * 100;
                          end;
                        100..199: begin
                            g_Config.GlobalVal[n14 - 100] := n18 div n1C * 100;
                          end;
                        200..299: begin //20080323 原为200..209
                             PlayObject.m_DyVal[n14 - 200] := n18 div n1C * 100;
                          end;
                        300..399: begin
                             PlayObject.m_nMval[n14 - 300] := n18 div n1C * 100;
                          end;
                        400..499: begin
                             g_Config.GlobaDyMval[n14 - 400] := n18 div n1C * 100;
                          end;
                        500..599: begin
                             PlayObject.m_nInteger[n14 - 500] :=  n18 div n1C * 100;
                          end;
                        600..699: begin
                            PlayObject.m_sString[n14 - 600] := IntToStr(n18 div n1C * 100)+'%';//20080606
                          end;
                        700..799: begin
                            g_Config.GlobalAVal[n14 - 700] := IntToStr(n18 div n1C * 100)+'%';//20080606
                          end;
                        800..1199:begin//20080903 G变量
                            g_Config.GlobalVal[n14 - 700] := n18 div n1C * 100;
                          end;
                        1200..2099:begin//A变量(100-999)
                            g_Config.GlobalAVal[n14 - 1100] := IntToStr(n18 div n1C * 100)+'%';
                          end;
                        2100..2599: begin//G变量(500-999)
                            g_Config.GlobalVal[n14 - 1600] := n18 div n1C * 100;
                          end;
                      end;
                    end;
                  end;
                end;
      //------------------------------------------------------------------------------
              nBREAKTIMERECALL: if IsPlayObject then PlayObject.m_boTimeRecall := False;
              nPKPOINT: begin
                  if IsPlayObject then begin
                    if not GetValValue(PlayObject, QuestActionInfo.sParam1, n14) then begin
                      n14 := QuestActionInfo.nParam1;
                    end;
                  end else begin
                    if not GetValValue(TPlayObject(BaseObject.m_Master), QuestActionInfo.sParam1, n14) then begin
                      n14 := QuestActionInfo.nParam1;
                    end;
                  end;  

                  if n14 = 0 then begin
                    BaseObject.m_nPkPoint := 0;
                  end else begin
                    if n14 < 0 then begin
                      if (BaseObject.m_nPkPoint + n14) >= 0 then begin
                        Inc(BaseObject.m_nPkPoint, n14);
                      end else BaseObject.m_nPkPoint := 0;
                    end else begin
                      if (BaseObject.m_nPkPoint + n14) > 10000 then begin
                        BaseObject.m_nPkPoint := 10000;
                      end else begin
                        Inc(BaseObject.m_nPkPoint, n14);
                      end;
                    end;
                  end;
                  BaseObject.RefNameColor();
                end;

              nSC_RECALLMOB: if IsPlayObject then ActionOfRecallmob(PlayObject, QuestActionInfo);
              nSC_RECALLMOBEX: if IsPlayObject then ActionOfRECALLMOBEX(PlayObject, QuestActionInfo); //20080122 召唤宝宝
              nSC_MOVEMOBTO: if IsPlayObject then ActionOfMOVEMOBTO(PlayObject, QuestActionInfo); //20080123 将指定坐标的怪物移动到新坐标
              nSC_CLEARITEMMAP: if IsPlayObject then ActionOfCLEARITEMMAP(PlayObject, QuestActionInfo); //20080124 清除地图物品
              nKICK: begin
                  if IsPlayObject then begin
                    PlayObject.m_boReconnection := True;
                    PlayObject.m_boSoftClose := True;
                    PlayObject.m_boPlayOffLine := False;
                    PlayObject.m_boNotOnlineAddExp := False;
                  end;
                end;
              nMOVR: begin//取随机值赋给变量   拓展可以随机参数2到参数3之间的数
                  if IsPlayObject then begin
                    if CompareLStr(QuestActionInfo.sParam1, '<$STR(', 6) then begin //20080228 支持字符串变量
                      ArrestStringEx(QuestActionInfo.sParam1, '(', ')', s34);
                      n14 := GetValNameNo(s34);
                    end else n14 := GetValNameNo(QuestActionInfo.sParam1);

                    if not GetValValue(PlayObject, QuestActionInfo.sParam2, n18) then begin//20110704
                      n18 := QuestActionInfo.nParam2;
                    end;
                    if not GetValValue(PlayObject, QuestActionInfo.sParam3, n1C) then begin//20110704
                      n1C := QuestActionInfo.nParam3;
                    end;

                    if n14 >= 0 then begin
                      case n14 of //
                        0..99: begin //20080323 原为0..99
                            if {QuestActionInfo.nParam3}n1C > {QuestActionInfo.nParam2}n18 then begin
                              PlayObject.m_nVal[n14] := {QuestActionInfo.nParam2}n18 + Random({QuestActionInfo.nParam3}n1C - {QuestActionInfo.nParam2}n18);
                            end else PlayObject.m_nVal[n14] := Random({QuestActionInfo.nParam2}n18);
                          end;
                        100..199: begin
                            if {QuestActionInfo.nParam3}n1C > {QuestActionInfo.nParam2}n18 then begin
                               g_Config.GlobalVal[n14 - 100]:= {QuestActionInfo.nParam2}n18 + Random({QuestActionInfo.nParam3}n1C - {QuestActionInfo.nParam2}n18);
                            end else g_Config.GlobalVal[n14 - 100] := Random({QuestActionInfo.nParam2}n18);
                          end;
                        200..299: begin //20080323 原为200..209
                            if {QuestActionInfo.nParam3}n1C > {QuestActionInfo.nParam2}n18 then begin
                               PlayObject.m_DyVal[n14 - 200]:= {QuestActionInfo.nParam2}n18 + Random({QuestActionInfo.nParam3}n1C - {QuestActionInfo.nParam2}n18);
                            end else PlayObject.m_DyVal[n14 - 200] := Random({QuestActionInfo.nParam2}n18);
                          end;
                        300..399: begin
                            if {QuestActionInfo.nParam3}n1C > {QuestActionInfo.nParam2}n18 then begin
                               PlayObject.m_nMval[n14 - 300]:= {QuestActionInfo.nParam2}n18 + Random({QuestActionInfo.nParam3}n1C - {QuestActionInfo.nParam2}n18);
                            end else PlayObject.m_nMval[n14 - 300] := Random({QuestActionInfo.nParam2}n18);
                          end;
                        400..499: begin
                            if {QuestActionInfo.nParam3}n1C > {QuestActionInfo.nParam2}n18 then begin
                               g_Config.GlobaDyMval[n14 - 400] := {QuestActionInfo.nParam2}n18 + Random({QuestActionInfo.nParam3}n1C - {QuestActionInfo.nParam2}n18);
                            end else g_Config.GlobaDyMval[n14 - 400] := Random({QuestActionInfo.nParam2}n18);
                          end;
                        500..599: begin
                            if {QuestActionInfo.nParam3}n1C > {QuestActionInfo.nParam2}n18 then begin
                              PlayObject.m_nInteger[n14 - 500] :={QuestActionInfo.nParam2}n18 + Random({QuestActionInfo.nParam3}n1C - {QuestActionInfo.nParam2}n18);
                            end else PlayObject.m_nInteger[n14 - 500] := Random({QuestActionInfo.nParam2}n18);
                          end;
                        800..1199:begin//20080903 G变量
                            if {QuestActionInfo.nParam3}n1C > {QuestActionInfo.nParam2}n18 then begin
                               g_Config.GlobalVal[n14 - 700]:= {QuestActionInfo.nParam2}n18 + Random({QuestActionInfo.nParam3}n1C - {QuestActionInfo.nParam2}n18);
                            end else g_Config.GlobalVal[n14 - 700] := Random({QuestActionInfo.nParam2}n18);
                          end;
                       {1800..2799:begin//20080323 I变量
                            g_Config.GlobaDyMval[n14 - 1800]:= Random(QuestActionInfo.nParam2);
                          end; }
                         2100..2599: begin//G变量(500-999)
                            if {QuestActionInfo.nParam3}n1C > {QuestActionInfo.nParam2}n18 then begin
                               g_Config.GlobalVal[n14 - 1600]:= {QuestActionInfo.nParam2}n18 + Random({QuestActionInfo.nParam3}n1C - {QuestActionInfo.nParam2}n18);
                            end else g_Config.GlobalVal[n14 - 1600] := Random({QuestActionInfo.nParam2}n18);
                          end;
                      else begin
                          ScriptActionError(PlayObject, '', QuestActionInfo, sMOVR);
                        end;
                      end;
                    end else begin
                      ScriptActionError(PlayObject, '', QuestActionInfo, sMOVR);
                    end;
                  end;
                end;
              nEXCHANGEMAP: begin//两角色互换地图 增加被禁锢不可用 By TasNat at: 2012-03-08 12:17:32
                  if IsPlayObject and (not PlayObject.InMag113LockRect(PlayObject.m_nCurrX, PlayObject.m_nCurrY)) then begin
                    if not GetValValue(PlayObject, QuestActionInfo.sParam1, s4C) then begin //增加变量支持
                      s4C := QuestActionInfo.sParam1;//地图名称
                    end;
                    if CompareText(s4C, 'APPR') = 0 then begin//师徒地图互换 20080422
                       User :=UserEngine.GetPlayObject(PlayObject.m_sMasterName);
                       if (User <> nil) and (not User.InMag113LockRect(User.m_nCurrX, User.m_nCurrY)) then begin
                         s4C:= User.m_sMapName;
                         User.MapRandomMove(PlayObject.m_sMapName, 0);
                         PlayObject.MapRandomMove(s4C, 0);
                       end;
                    end else
                    if CompareText(s4C, 'DEAR') = 0 then begin//夫妻地图互换 20080422
                       if (PlayObject.m_DearHuman <> nil) and (not PlayObject.m_DearHuman.InMag113LockRect(PlayObject.m_DearHuman.m_nCurrX, PlayObject.m_DearHuman.m_nCurrY)) then begin
                          s4C:= PlayObject.m_DearHuman.m_sMapName;
                          PlayObject.m_DearHuman.MapRandomMove(PlayObject.m_sMapName, 0);
                          PlayObject.MapRandomMove(s4C, 0);
                       end;
                    end else begin
                      Envir := g_MapManager.FindMap(s4C);
                      if Envir <> nil then begin
                        List58 := TList.Create;
                        UserEngine.GetMapRageHuman(Envir, 0, 0, 1000, List58);
                        //修改被禁锢检测  By TasNat at: 2012-03-08 12:18:52
                        for II := 0 to List58.Count - 1 do begin
                          User := TPlayObject(List58.Items[II]);
                          if (not User.InMag113LockRect(User.m_nCurrX, User.m_nCurrY)) then begin
                            User.MapRandomMove(Self.m_sMapName, 0);
                            Break;
                          end;
                        end;
                        List58.Free;
                        PlayObject.MapRandomMove(s4C, 0);
                      end else begin
                        ScriptActionError(PlayObject, '', QuestActionInfo, sEXCHANGEMAP);
                      end;
                    end;
                  end;
                end;
              nRECALLMAP: begin
                  if IsPlayObject then begin
                    if not GetValValue(PlayObject, QuestActionInfo.sParam1, s4C) then begin //增加变量支持
                      s4C := QuestActionInfo.sParam1;
                    end;
                    Envir := g_MapManager.FindMap(s4C);
                    if Envir <> nil then begin
                      List58 := TList.Create;
                      UserEngine.GetMapRageHuman(Envir, 0, 0, 1000, List58);
                      if List58.Count > 0 then begin//20080629
                        for II := 0 to _Min(20, List58.Count) - 1 do begin
                          User := TPlayObject(List58.Items[II]);
                          //增加禁锢检测 By TasNat at: 2012-03-08 12:22:41
                          if (not User.InMag113LockRect(User.m_nCurrX, User.m_nCurrY)) then
                            User.MapRandomMove(Self.m_sMapName, 0);
                        end;
                      end;
                      List58.Free;
                    end else begin
                      ScriptActionError(PlayObject, '', QuestActionInfo, sRECALLMAP);
                    end;
                  end;
                end;
              nADDBATCH: if IsPlayObject then List1C.AddObject(QuestActionInfo.sParam1, TObject(n18));
              nBATCHDELAY: n18 := QuestActionInfo.nParam1 * 1000;
              nBATCHMOVE: begin
                  if IsPlayObject and (List1C.Count > 0) then begin
                    for II := 0 to List1C.Count - 1 do begin
                      PlayObject.SendDelayMsg(Self, RM_10155, 0, 0, 0, 0, List1C.Strings[II], Integer(List1C.Objects[II]) + n20);
                      Inc(n20, Integer(List1C.Objects[II]));
                    end;
                  end;
                end;
              nPLAYDICE: begin//转骰子
                  if IsPlayObject then begin
                    PlayObject.m_sPlayDiceLabel := QuestActionInfo.sParam2;//跳转标签
                    PlayObject.m_boNPCCanGoto := QuestActionInfo.sParam2 <> '';//跳转标签
                    PlayObject.SendMsg(Self,
                      RM_PLAYDICE,
                      QuestActionInfo.nParam1,
                      MakeLong(MakeWord(PlayObject.m_DyVal[0], PlayObject.m_DyVal[1]), MakeWord(PlayObject.m_DyVal[2], PlayObject.m_DyVal[3])),
                      MakeLong(MakeWord(PlayObject.m_DyVal[4], PlayObject.m_DyVal[5]), MakeWord(PlayObject.m_DyVal[6], PlayObject.m_DyVal[7])),
                      MakeLong(MakeWord(PlayObject.m_DyVal[8], PlayObject.m_DyVal[9]), 0),
                      QuestActionInfo.sParam2);
                    bo11 := True;
                  end;
                end;

              nSetOnTimer:Begin //个人定时器(开启) 20080510
                 if IsPlayObject then begin
                   if PlayObject <> nil then begin
                     ActionOfSetOnTimer(PlayObject, QuestActionInfo);
                   end;
                 end;
              end;
              nSetOffTimer:Begin //停止定时器 20080510
                if IsPlayObject then begin
                  if PlayObject <> nil then begin
                    ActionOfSetOffTimer(PlayObject, QuestActionInfo);
                  end;
                end;
              end;
              nADDNAMELIST: AddList(PlayObject.m_sCharName, m_sPath + QuestActionInfo.sParam1, True);
              nDELNAMELIST: DelList(PlayObject.m_sCharName, m_sPath + QuestActionInfo.sParam1);
              nADDGUILDLIST: if IsPlayObject and (PlayObject.m_MyGuild <> nil) then AddList(TGUild(PlayObject.m_MyGuild).sGuildName, m_sPath + QuestActionInfo.sParam1, True);
              nDELGUILDLIST: if IsPlayObject and (PlayObject.m_MyGuild <> nil) then DelList(TGUild(PlayObject.m_MyGuild).sGuildName, m_sPath + QuestActionInfo.sParam1);
              nSENDMSG: if IsPlayObject then ActionOfLineMsg(PlayObject, QuestActionInfo);//发送文字信息
              nCREATEFILE: ActionOfCreateFile(PlayObject, QuestActionInfo);//创建文本文件 20081226
              nDELETEFILE: ActionOfDeleteFile(PlayObject, QuestActionInfo);//删除指定文件
      //------------------------------------------------------------------------------------------------------------------
              nSENDTOPMSG: if IsPlayObject then ActionOfSendTopMsg(PlayObject, QuestActionInfo);//顶端滚动公告
              nSENDCENTERMSG: if IsPlayObject then ActionOfSendCenterMsg(PlayObject, QuestActionInfo);//屏幕居中显示公告
              nSENDEDITTOPMSG:if IsPlayObject then ActionOfSendEditTopMsg(PlayObject, QuestActionInfo);//聊天框顶端公告
              nCHANGEPETSMONHAPP:if IsPlayObject then ActionOfCHANGEPETSMONHAPP(PlayObject, QuestActionInfo);//调整人物宠物的快乐度
              nPETSMONHAPPLOG:if IsPlayObject then ActionOfPetsMonHappLog(PlayObject, QuestActionInfo);//打开宠物喂养日志
      //------------------------酿酒系统----------------------------------------------
              nOPENMAKEWINE: if IsPlayObject then ActionOfOPENMAKEWINE(PlayObject, QuestActionInfo);//打开酿酒窗口 20080619
              nGETGOODMAKEWINE: if IsPlayObject then ActionOfGETGOODMAKEWINE(PlayObject, QuestActionInfo);//取回酿好的酒 20080620
              nDECMAKEWINETIME: if IsPlayObject then ActionOfDECMAKEWINETIME(PlayObject, QuestActionInfo);//减少酿酒的时间 20080620
              nMAKEWINENPCMOVE: if IsPlayObject then ActionOfMAKEWINENPCMOVE(PlayObject, QuestActionInfo);//酿酒NPC的走动 20080621
              nFOUNTAIN: if IsPlayObject then ActionOfFOUNTAIN(PlayObject, QuestActionInfo);//设置泉水喷发 20080621
              nSETGUILDFOUNTAIN: if IsPlayObject then ActionOfSETGUILDFOUNTAIN(PlayObject, QuestActionInfo);//开启/关闭行会泉水仓库 20080625
              nGIVEGUILDFOUNTAIN: if IsPlayObject then ActionOfGIVEGUILDFOUNTAIN(PlayObject, QuestActionInfo);//领取行会酒水 20080625
      //------------------------------------------------------------------------------
              nCHALLENGMAPMOVE: if IsPlayObject then ActionOfCHALLENGMAPMOVE(PlayObject, QuestActionInfo);//挑战地图移动 20080705
              nGETCHALLENGEBAKITEM: if IsPlayObject then ActionOfGETCHALLENGEBAKITEM(PlayObject, QuestActionInfo);//没有挑战地图可移动,则退回抵押的物品 20080705
      //------------------------------------------------------------------------------
              nHEROLOGOUT: if IsPlayObject then ActionOfHEROLOGOUT(PlayObject, QuestActionInfo);//人物在线英雄下线 20080716
              {$IF HEROVERSION = 1}
              nSC_RECALLHERO: if IsPlayObject then begin
                  if QuestActionInfo.sParam1 <> '' then PlayObject.ClientHeroLogOut(0)//收回英雄
                  else PlayObject.ClientRecallHero();//召唤英雄
                end;
              {$IFEND}
              nGETSORTNAME:ActionOfGETSORTNAME(PlayObject, QuestActionInfo);//取指定排行榜指定排名的玩家名字 20080531
              nWEBBROWSER:ActionOfWEBBROWSER(PlayObject, QuestActionInfo);//连接指定网站网址 20080602
              nPALYVIDEO:ActionOfPALYVIDEO(PlayObject, QuestActionInfo);//播放指定的视频文件 20100929
              nKICKALLPLAY: if IsPlayObject then ActionOfKICKALLPLAY(PlayObject, QuestActionInfo);//踢除服务器所有人物 20080609
              nREPAIRALL:ActionOfREPAIRALL(PlayObject, QuestActionInfo);//修理全身装备 20080613
              nCHANGESKILL:ActionOfCHANGESKILL(PlayObject, QuestActionInfo);//修改魔法ID 20080624
              nCHANGESKILLEX:ActionOfCHANGESKILLEX(PlayObject, QuestActionInfo);//转换魔法ID
              nAUTOGOTOXY:if IsPlayObject then ActionOfAUTOGOTOXY(PlayObject, QuestActionInfo);//自动寻路 20080617
              nADDATTACKSABUKALL: if IsPlayObject then ActionOfADDATTACKSABUKALL(PlayObject, QuestActionInfo);//设置所有行会攻城 20080609
              nOPENBOOKS: if IsPlayObject then ActionOfOPENBOOKS(PlayObject, QuestActionInfo);//卧龙 20080119
              nOPENYBDEAL: if IsPlayObject then ActionOfOPENYBDEAL(PlayObject, QuestActionInfo);//开通元宝交易 20080316
              nQUERYYBSELL: if IsPlayObject then ActionOfQUERYYBSELL(PlayObject, QuestActionInfo);//查询正在出售的物品 20080317
              nQUERYYBDEAL: if IsPlayObject then ActionOfQUERYYBDEAL(PlayObject, QuestActionInfo);//查询可以的购买物品 20080317
              nTHROUGHHUM: if IsPlayObject then ActionOfTHROUGHHUM(PlayObject, QuestActionInfo);//改变穿人模式 20080221
              nSETITEMSLIGHT:ActionOfSetItemsLight(PlayObject, QuestActionInfo);//装备发光设置 20080223
              nOPENDRAGONBOX: if IsPlayObject then ActionOfOpenDragonBox(PlayObject, QuestActionInfo);//打开卧龙宝藏 20080306
              nOPENHEROAUTOPRACTICE: if IsPlayObject then ActionOfOpenHeroAutoPractice(PlayObject, QuestActionInfo);//打开英雄自我修炼窗口
              nSTOPHEROAUTOPRACTICE: if IsPlayObject then ActionOfStopHeroAutoPractice(PlayObject, QuestActionInfo);//停止英雄自我修炼

              nGOHOME:if IsPlayObject then ActionOfGOHOME(PlayObject, QuestActionInfo);//移动到回城点 20080503
              nTHROWITEM: if IsPlayObject then ActionOfTHROWITEM(PlayObject, QuestActionInfo);//将指定物品刷新到指定地图坐标范围内 20080508
              nNPCGIVEITEM:ActionOfNPCGIVEITEM(PlayObject, QuestActionInfo);//在NPC范围内爆出物品 20090425
              nCLEARCODELIST:ActionOfCLEARCODELIST(PlayObject, QuestActionInfo);//删除指定文本里的编码 20080410
              nGETRANDOMNAME:ActionOfGetRandomName(PlayObject, QuestActionInfo);//从文件中随机取文本 20080126
              nHCall: if IsPlayObject then ActionOfHCall(PlayObject, QuestActionInfo);//通过脚本命令让别人执行QManage.txt中的脚本 20080422
              nINCASTLEWARAY:ActionOfINCASTLEWARAY(PlayObject, QuestActionInfo);//检测人物是否在攻城期间的范围内，在则BB叛变 20080422
              nGIVESTATEITEM:ActionOfGIVESTATEITEM(PlayObject, QuestActionInfo);//给予带绑定状态装备 20080312
              nSETITEMSTATE:ActionOfSETITEMSTATE(PlayObject, QuestActionInfo);//设置装备绑定状态 20080312
              nADDACCOUNTLIST: if IsPlayObject then AddList(PlayObject.m_sUserID, m_sPath + QuestActionInfo.sParam1, True);
              nDELACCOUNTLIST: if IsPlayObject then DelList(PlayObject.m_sUserID, m_sPath + QuestActionInfo.sParam1);
              nADDIPLIST: if IsPlayObject then AddList(PlayObject.m_sIPaddr, m_sPath + QuestActionInfo.sParam1, True);
              nDELIPLIST: if IsPlayObject then DelList(PlayObject.m_sIPaddr, m_sPath + QuestActionInfo.sParam1);
              nGOQUEST: GoToQuest(QuestActionInfo.nParam1);
              nENDQUEST: if IsPlayObject then PlayObject.m_Script := nil;
              nGOTO: begin
                  sStr := GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//20090514 增加,支持变量
                  if not JmpToLable(sStr) then begin//20090515 修改
                    MainOutMessage('[脚本死循环] NPC:' + m_sCharName +
                      ' 位置:' + m_sMapName + '(' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) + ')' +
                      ' 命令:' + sGOTO + ' ' + QuestActionInfo.sParam1);
                    Result := False;
                    Exit;
                  end;
                end;

              nSC_HAIRSTYLE: ActionOfChangeHairStyle(PlayObject, QuestActionInfo);
              nSC_CLEARNAMELIST: if IsPlayObject then ActionOfClearNameList(PlayObject, QuestActionInfo);
              nSC_CHANGELEVEL: ActionOfChangeLevel(PlayObject, QuestActionInfo);
              nSC_MARRY: if IsPlayObject then ActionOfMarry(PlayObject, QuestActionInfo);
              nSC_MASTER: if IsPlayObject then ActionOfMaster(PlayObject, QuestActionInfo);//拜师
              nSC_UNMASTER: if IsPlayObject then ActionOfUnMaster(PlayObject, QuestActionInfo);//出师
              nSC_UNMARRY: if IsPlayObject then ActionOfUnMarry(PlayObject, QuestActionInfo);
              nSC_GETMARRY: if IsPlayObject then ActionOfGetMarry(PlayObject, QuestActionInfo);
              nSC_GETMASTER: if IsPlayObject then ActionOfGetMaster(PlayObject, QuestActionInfo);
              nSC_CLEARSKILL: ActionOfClearSkill(PlayObject, QuestActionInfo);
              nSC_ADDRANDOMMAPGATE: ActionOfAddRandomMapGate(PlayObject, QuestActionInfo);//增加地图连接 20090503
              nSC_DELRANDOMMAPGATE: ActionOfDelRandomMapGate(PlayObject, QuestActionInfo);//删除地图连接 20090503
              nSC_MIRRORMAP: ActionOfMirrorMap(PlayObject, QuestActionInfo);//增加地图镜像
              //Add By TasNat at: 2012-03-17 11:44:06
              nSC_UNMIRRORMAP: ActionOfUnMirrorMap(PlayObject, QuestActionInfo);//删除地图镜像
              nSC_CLEARMAPITEM: ActionOfClearMapItem(PlayObject, QuestActionInfo);//删除地图物品
              nSC_CLEARBAGITEMS: ActionOfClearBagItems(PlayObject, QuestActionInfo);//清理背包物品
              nSC_Status: begin

                if QuestActionInfo.nParam3 <> 1 then BaseObject := PlayObject else
                    if PlayObject.m_MyHero <> nil then
                     BaseObject := PlayObject.m_MyHero;
                case QuestActionInfo.nParam1 of
                  1:BaseObject.MakePosion(65535, QuestActionInfo.nParam2, QuestActionInfo.nParam3);
                  2:BaseObject.MakeFreezeMag(QuestActionInfo.nParam2);
                  3:BaseObject.MakeSpiderMag(7);
                end;
              end;
              nSC_BIGMAIN:m_WinType := 1 + QuestActionInfo.nParam1;
              nSC_IncreaseSkillLevel:ActionOfIncreaseSkillLevel(PlayObject, QuestActionInfo);//调整强化等级
              //Add End
              nSC_RELOADCASTLE: ActionOfReLoadCastle(PlayObject, QuestActionInfo);//初始化沙城配置
              nSC_DELNOJOBSKILL: ActionOfDelNoJobSkill(PlayObject, QuestActionInfo);
              nSC_DELSKILL: ActionOfDelSkill(PlayObject, QuestActionInfo);
              nSC_ADDSKILL: ActionOfAddSkill(PlayObject, QuestActionInfo);
              nSC_ADDGUILDMEMBER: if IsPlayObject then ActionOfADDGUILDMEMBER(PlayObject, QuestActionInfo);//添加行会成员//20080427
              nSC_DELGUILDMEMBER: if IsPlayObject then ActionOfDELGUILDMEMBER(PlayObject, QuestActionInfo);//删除行会成员（删除掌门无效）//20080427
              nSC_CHANGESKILLLEVELEX: ActionOfChangeSkillLevelEx(PlayObject, QuestActionInfo);//调整人物技能的强化等级
              nSC_SKILLLEVEL: ActionOfSkillLevel(PlayObject, QuestActionInfo);//调整人物技能等级
              nSC_HEROSKILLLEVEL: if IsPlayObject then ActionOfHeroSkillLevel(PlayObject, QuestActionInfo);//调整英雄技能等级 20080415
              nSC_CHANGEPKPOINT: ActionOfChangePkPoint(PlayObject, QuestActionInfo);
              nSC_CHANGEEXP: ActionOfChangeExp(PlayObject, QuestActionInfo);
              nSC_CHANGECATTLEGASEXP: if IsPlayObject then ActionOfChangeCattleGasExp(PlayObject, QuestActionInfo);//调整人物牛气值 20090519
              nSC_CHANGEITEMDURA: if IsPlayObject then ActionOfChangeItemDura(PlayObject, QuestActionInfo);//调整装备持久 20110219
              nSORTHUMVARTOFILE: if IsPlayObject then ActionOfSortHumVarToFile(PlayObject, QuestActionInfo);//人物自定义变量排序
              {$IF M2Version <> 2}
              nSC_ADDDIVISIONMEMBER: if IsPlayObject then ActionOfADDDIVISIONMEMBER(PlayObject, QuestActionInfo);//添加师门成员
              nSC_DELDIVISIONMEMBER: if IsPlayObject then ActionOfDELDIVISIONMEMBER(PlayObject, QuestActionInfo);//删除师门成员（删除掌门无效）
              nSC_OPENSAVVYHEART: if IsPlayObject then ActionOfOpenSavvyHeart(PlayObject, QuestActionInfo);//打开领悟心法窗口(学习龙卫心法-999级)
              nSC_OPENAPPLYDIVISION: if IsPlayObject then ActionOfOpenApplyDivision(PlayObject, QuestActionInfo);//打开申请加入门派窗口
              nSC_SAVVYHEART: if IsPlayObject then ActionOfSavvyHeart(PlayObject, QuestActionInfo);//弟子领悟师门心法
              nSC_CHANGEDIVISIONPOINT: if IsPlayObject then ActionOfChangeDivisionPoint(PlayObject, QuestActionInfo);
              nSC_CHANGEHEARTPOINT: if IsPlayObject then ActionOfChangeHeartPoint(PlayObject, QuestActionInfo);//调整弟子传承心法经验
              nSC_INCHEARTPOINT: if IsPlayObject then ActionOfIncHeartPoint(PlayObject, QuestActionInfo);

              nGIVEFENGHAO: if IsPlayObject then ActionOfGIVEFENGHAO(PlayObject, QuestActionInfo);//给予称名
              nRECYCFENGHAO: if IsPlayObject then ActionOfRecycFengHao(PlayObject, QuestActionInfo);//回收称名
              nCHANGEFENGHAOTIME: if IsPlayObject then ActionOfChangeFengHaoTime(PlayObject, QuestActionInfo);//调整称号时长
              nGIVEFENGHAOAGREE: if IsPlayObject then ActionOfGiveFengHaoAgree(PlayObject, QuestActionInfo);//设置称号发送确认信息
              nREADSKILLNG:ActionOfREADSKILLNG(PlayObject, QuestActionInfo);//学习内功 20081001
              nSC_CLEARNGSKILL: ActionOfClearNGSkill(PlayObject, QuestActionInfo);//清除人物的所有内功技能  20090428
              nSC_CHANGENGEXP: ActionOfChangeNGExp(PlayObject, QuestActionInfo);//调整内功经验 20081001
              nSC_CHANGENGLEVEL: ActionOfCHANGENGLEVEL(PlayObject, QuestActionInfo);//调整内功等级 20081004
              nSC_OPENEXPCRYSTAL: if IsPlayObject then ActionOfOPENEXPCRYSTAL(PlayObject, QuestActionInfo);//客户端显示天地结晶 20090131
              nSC_CLOSEEXPCRYSTAL: if IsPlayObject then ActionOfCLOSEEXPCRYSTAL(PlayObject, QuestActionInfo);//客户端关闭天地结晶 20090131
              nSC_GETEXPTOCRYSTAL: if IsPlayObject then ActionOfGETEXPTOCRYSTAL(PlayObject, QuestActionInfo);//取提天地结晶中的经验(只提取可提取的经验) 20090202
              nQUERYREFINEITEM: if IsPlayObject then ActionOfQUERYREFINEITEM(PlayObject, QuestActionInfo);//打开淬炼窗口 20080502
              {$IFEND}
              nOpenRefineArmyDrum: if IsPlayObject then ActionOfOpenRefineArmyDrum(PlayObject, QuestActionInfo); // 淬炼军鼓
              {$IF M2Version = 1}
              nOPENLIANQI: if IsPlayObject then ActionOfOPENLIANQI(PlayObject, QuestActionInfo);//打开炼气窗口
              nCHANGEJINGYUAN: if IsPlayObject then ActionOfCHANGEJINGYUAN(PlayObject, QuestActionInfo);//调整人物精元值
              nOPEN4BATTERSKILL: ActionOfOpen4BatterSkill(PlayObject, QuestActionInfo);//开启第四个连击技能 20100720
              nSC_OPENHEROPULS: ActionOfOpenHeroPuls(PlayObject, QuestActionInfo);//开通英雄经脉
              nSC_OPENPULSE: ActionOfOpenPulse(PlayObject, QuestActionInfo);//打通指定脉穴 20090623
              nSC_CHANGEPULSELEVEL: ActionOfChangePulseLevel(PlayObject, QuestActionInfo);//改变络经等级 20090624
              nSC_CHANGEHEROPULSEXP: if IsPlayObject then ActionOfChangeHeroPulsExp(PlayObject, QuestActionInfo);//改变英雄经络修炼点
              {$IFEND}
              nSC_OPENMAKEKIMNEEDLE: if IsPlayObject then ActionOfOpenMakeKimNeedle(PlayObject, QuestActionInfo);//客户端显示锻练金针窗口 20090615
              nSC_TAKEKIMNEEDLE: ActionOfTakeKimNeedle(PlayObject, QuestActionInfo);//收回包裹指定叠加物品 20090615
              nSC_GIVEKIMNEEDLE: ActionOfGiveKimNeedle(PlayObject, QuestActionInfo);//给指定的叠加物品 20090615
              nSC_CHANGEATTATCKMODE: if IsPlayObject then ActionOfChangeAttatckMode(PlayObject, QuestActionInfo);
              nSC_OPENCATTLEGAS: if IsPlayObject then ActionOfOPENCATTLEGAS(PlayObject, QuestActionInfo);//客户端显示牛气管图标 20090518
              nSC_CLOSECATTLEGAS: if IsPlayObject then ActionOfCLOSECATTLEGAS(PlayObject, QuestActionInfo);//客户端关闭牛气管图标 20090518

              nSC_SENDTIMEMSG: if IsPlayObject then ActionOfSENDTIMEMSG(PlayObject, QuestActionInfo);//时间到解发脚本段(客户端显示时间) 20090124
              nSC_SENDMSGWINDOWS: ActionOfSENDMSGWINDOWS(PlayObject, QuestActionInfo);//时间到解发脚本段 20090124
              nSC_CLOSEMSGWINDOWS: if IsPlayObject then ActionOfCLOSEMSGWINDOWS(PlayObject, QuestActionInfo);//关闭客户端'!'图标的显示 20090126
              nSC_GETMONTHSDAY: if IsPlayObject then ActionOfGETMONTHSDAY(PlayObject, QuestActionInfo);//取当前月份天数 20110304
              nSC_GETGROUPCOUNT: if IsPlayObject then ActionOfGETGROUPCOUNT(PlayObject, QuestActionInfo);//取组队成员数 20090125
              nSC_CHANGEJOB: ActionOfChangeJob(PlayObject, QuestActionInfo);
              nSC_MISSION: if IsPlayObject then ActionOfMission(PlayObject, QuestActionInfo);
              nSC_MOBPLACE: if IsPlayObject then ActionOfMobPlace(PlayObject, QuestActionInfo, n34, n38, n3C, n40);
              nSC_SETMEMBERTYPE: if IsPlayObject then ActionOfSetMemberType(PlayObject, QuestActionInfo);
              nSC_SETMEMBERLEVEL: if IsPlayObject then ActionOfSetMemberLevel(PlayObject, QuestActionInfo);
              nSC_GAMEGOLD: if IsPlayObject then ActionOfGameGold(PlayObject, QuestActionInfo);
              nSC_GAMEDIAMOND: if IsPlayObject then ActionOfGameDiaMond(PlayObject, QuestActionInfo);//金刚石 20071226
              nSC_GAMEGIRD: if IsPlayObject then ActionOfGameGird(PlayObject, QuestActionInfo); //灵符 20071226
              nSC_CHANGEHUMABILITY: ActionOfCHANGEHUMABILITY(PlayObject, QuestActionInfo);//调整人物属性 20080609
              nSC_CHANGEHEROLOYAL: ActionOfHEROLOYAL(PlayObject, QuestActionInfo); //调整英雄的忠诚度 20080109
              nSC_CHANGEHEROTRANPOINT: ActionOfCHANGEHEROTRANPOINT(PlayObject, QuestActionInfo); //调整英雄技能升级点数 20080512
              nSC_CHANGETRANPOINT: ActionOfCHANGETRANPOINT(PlayObject, QuestActionInfo); //调整技能升级点数
      //----------------------酒馆系统-----------------------------------------------
              nSC_SAVEHERO: if IsPlayObject then ActionOfSAVEHERO(PlayObject, QuestActionInfo);//寄放英雄
              nSC_GETHERO: if IsPlayObject then ActionOfGETHERO(PlayObject, QuestActionInfo);//取回英雄
              nSC_ASSESSMENTHERO: if IsPlayObject then ActionOfAssessmentHero(PlayObject, QuestActionInfo);//评定英雄
              nSC_CLOSEDRINK: if IsPlayObject then ActionOfCLOSEDRINK(PlayObject, QuestActionInfo);//关闭斗酒窗口
              nSC_PLAYDRINKMSG: if IsPlayObject then ActionOfPLAYDRINKMSG(PlayObject, QuestActionInfo);//斗酒窗口说话信息 20080514
              nSC_OPENPLAYDRINK: if IsPlayObject then ActionOfOPENPLAYDRINK(PlayObject, QuestActionInfo);//指定人物喝酒 20080514
      //-----------------------------------------------------------------------------
              nSC_GAMEPOINT: if IsPlayObject then ActionOfGamePoint(PlayObject, QuestActionInfo);
              nSC_AUTOADDGAMEGOLD: if IsPlayObject then ActionOfAutoAddGameGold(PlayObject, QuestActionInfo, n34, n38);
              nSC_AUTOSUBGAMEGOLD: if IsPlayObject then ActionOfAutoSubGameGold(PlayObject, QuestActionInfo, n34, n38);
              nSC_CHANGENAMECOLOR: if IsPlayObject then ActionOfChangeNameColor(PlayObject, QuestActionInfo);
              nSC_CLEARPASSWORD: if IsPlayObject then ActionOfClearPassword(PlayObject, QuestActionInfo);
              nSC_RENEWLEVEL: if IsPlayObject then ActionOfReNewLevel(PlayObject, QuestActionInfo);
              nSC_KILLSLAVE: if IsPlayObject then ActionOfKillSlave(PlayObject, QuestActionInfo);
              nSC_CHANGEGENDER: ActionOfChangeGender(PlayObject, QuestActionInfo);
              nSC_KILLMONEXPRATE: if IsPlayObject then ActionOfKillMonExpRate(PlayObject, QuestActionInfo);
              nSC_POWERRATE: if IsPlayObject then ActionOfPowerRate(PlayObject, QuestActionInfo);//设置攻击力倍数
              nSC_CHANGEMODE: if IsPlayObject then ActionOfChangeMode(PlayObject, QuestActionInfo);//改变管理模式
              nSC_CHANGEMODEEX: ActionOfChangeModeEx(PlayObject, QuestActionInfo);
              nSC_CHANGEPERMISSION: if IsPlayObject then ActionOfChangePerMission(PlayObject, QuestActionInfo);
              nSC_KILL: if IsPlayObject then ActionOfKill(PlayObject, QuestActionInfo);
              nSC_KICK: if IsPlayObject then ActionOfKick(PlayObject, QuestActionInfo);
              nSC_BONUSPOINT: if IsPlayObject then ActionOfBonusPoint(PlayObject, QuestActionInfo);
              nSC_RESTRENEWLEVEL: if IsPlayObject then ActionOfRestReNewLevel(PlayObject, QuestActionInfo);
              nSC_DELMARRY: if IsPlayObject then ActionOfDelMarry(PlayObject, QuestActionInfo);
              nSC_DELMASTER: if IsPlayObject then ActionOfDelMaster(PlayObject, QuestActionInfo);
              nSC_DELAPPRENTICE: if IsPlayObject then ActionOfDELAPPRENTICE(PlayObject, QuestActionInfo);//删除徒弟 20090208
              nSC_HIGHLEVELKILLMONFIXEXP: ActionOfHIGHLEVELKILLMONFIXEXP(PlayObject, QuestActionInfo);//一定时间内高等级杀怪经验不变 20090213
              nSC_CHANGHEARMSGCOLOR: if IsPlayObject then ActionOfChangHearMsgColor(PlayObject, QuestActionInfo);//改变发言时文字颜色 20090221
              nSC_TAKEITMECOUNTDURA: ActionOfTakeItmeCountDura(PlayObject, QuestActionInfo);//收回指定名称物品(按数量，持久) 20090912
              nSC_TAKEMINE: ActionOfTAKEMINE(PlayObject, QuestActionInfo);//收回指定名称的矿名(按数量，纯度) 20090330
              nSC_TAKEBAGITEM:if IsPlayObject then ActionOfTAKEBAGITEM(PlayObject, QuestActionInfo);//收回指定名称的物品(按数量，升级次数)
              nSC_GIVEBAGITEM:if IsPlayObject then ActionOfGiveBAGITEM(PlayObject, QuestActionInfo);
              {$IF M2Version <> 2}
              nSC_SENDSHINYMSG: if IsPlayObject then ActionOfSendShinyMsg(PlayObject, QuestActionInfo);//通知客户端使"成长任务"按键发亮 20100801
              nSC_QMISSIONGOTO: if IsPlayObject then ActionOfQMissionGoto(PlayObject, QuestActionInfo);//触发QMission-0.txt脚本段 20100801
              nSC_OPENJUDGE: if IsPlayObject then ActionOfJudge(PlayObject, QuestActionInfo);//打开品评窗口 20100830
              nSC_CHANGEPROFICIENCY: if IsPlayObject then ActionOfCHANGEPROFICIENCY(PlayObject, QuestActionInfo);//调整人物熟练度 20100914
              {$IFEND}
              nSC_TAKEMAKEWINE: ActionOfTakeMakeWine(PlayObject, QuestActionInfo);//收回指定属性的酒(按品质、酒精度、酒等级)
              nSC_CREDITPOINT: if IsPlayObject then ActionOfChangeCreditPoint(PlayObject, QuestActionInfo);
              nSC_CHANGEGUILDMEMBERCOUNT: if IsPlayObject then ActionOfCHANGEGUILDMEMBERCOUNT(PlayObject, QuestActionInfo);//调整行会成员上限 20090115
              nSC_CHANGEGUILDFOUNTAIN: if IsPlayObject then ActionOfCHANGEGUILDFOUNTAIN(PlayObject, QuestActionInfo);//调整行会酒泉 20081007
              nSC_TAGMAPINFO: if IsPlayObject then ActionOfTAGMAPINFO(PlayObject, QuestActionInfo);//记路标石 20081019
              nSC_CREATEDIR: if IsPlayObject then ActionOfCreateDir(PlayObject, QuestActionInfo);//创建文件夹 20090616
              nSC_COPYFILETXT: if IsPlayObject then ActionOfCopyFileTxt(PlayObject, QuestActionInfo);//复制文本文件 20090823
              nSC_TAGMAPMOVE: if IsPlayObject then ActionOfTAGMAPMOVE(PlayObject, QuestActionInfo);//移动到记路标石记录的地图XY 20081019
              nSC_GAMEGLORY : if IsPlayObject then ActionOfChangeCreditGlory(PlayObject, QuestActionInfo); //调整荣誉值 20080511
              nSC_CLEARNEEDITEMS: if IsPlayObject then ActionOfClearNeedItems(PlayObject, QuestActionInfo);
              nSC_CLEARMAEKITEMS: if IsPlayObject then ActionOfClearMakeItems(PlayObject, QuestActionInfo);
              nSC_SETSENDMSGFLAG: if IsPlayObject then PlayObject.m_boSendMsgFlag := True;
              nSC_UPGRADEITEMS: if IsPlayObject then ActionOfUpgradeItems(PlayObject, QuestActionInfo);
              nSC_UPGRADEITEMSEX: if IsPlayObject then ActionOfUpgradeItemsEx(PlayObject, QuestActionInfo);
              nSC_GIVEMINE: ActionOfGIVEMINE(PlayObject, QuestActionInfo);//20080330 给矿石
              nSC_MONGENEX: if IsPlayObject then ActionOfMonGenEx(PlayObject, QuestActionInfo);
              nSC_CLEARMAPMON: if IsPlayObject then ActionOfClearMapMon(PlayObject, QuestActionInfo);
              nSC_MAPMOVESLAVENAME: if IsPlayObject then ActionOfMapMoveSlaveName(PlayObject, QuestActionInfo);
              nSC_LOADPETSMONSET: if IsPlayObject then ActionOfLoadPetsMonSet(PlayObject, QuestActionInfo);
              nSC_SETMAPMODE: if IsPlayObject then ActionOfSetMapMode(PlayObject, QuestActionInfo);
              nSC_PKZONE: if IsPlayObject then ActionOfPkZone(PlayObject, QuestActionInfo);
              nSC_RESTBONUSPOINT: if IsPlayObject then ActionOfRestBonusPoint(PlayObject, QuestActionInfo);
              nSC_TAKECASTLEGOLD: if IsPlayObject then ActionOfTakeCastleGold(PlayObject, QuestActionInfo);
              nSC_HUMANHP: ActionOfHumanHP(PlayObject, QuestActionInfo);
              nSC_HUMANMP: ActionOfHumanMP(PlayObject, QuestActionInfo);
              nSC_BUILDPOINT: if IsPlayObject then ActionOfGuildBuildPoint(PlayObject, QuestActionInfo);
              nSC_AURAEPOINT: if IsPlayObject then ActionOfGuildAuraePoint(PlayObject, QuestActionInfo);
              nSC_STABILITYPOINT: if IsPlayObject then ActionOfGuildstabilityPoint(PlayObject, QuestActionInfo);
              nSC_FLOURISHPOINT: if IsPlayObject then ActionOfGuildFlourishPoint(PlayObject, QuestActionInfo);
              nSC_OPENMAGICBOX: if IsPlayObject then ActionOfOpenMagicBox(PlayObject, QuestActionInfo);
              nSC_SETRANKLEVELNAME: if IsPlayObject then ActionOfSetRankLevelName(PlayObject, QuestActionInfo);
              nSC_GMEXECUTE: if IsPlayObject then ActionOfGmExecute(PlayObject, QuestActionInfo);
              nSC_GUILDCHIEFITEMCOUNT: if IsPlayObject then ActionOfGuildChiefItemCount(PlayObject, QuestActionInfo);
              nSC_ADDUSERDATE: if IsPlayObject then ActionOfAddNameDateList(PlayObject, QuestActionInfo);
              nSC_DELUSERDATE: if IsPlayObject then ActionOfDelNameDateList(PlayObject, QuestActionInfo);
              nSC_MOBFIREBURN: if IsPlayObject then ActionOfMobFireBurn(PlayObject, QuestActionInfo);
              nSC_MESSAGEBOX: if IsPlayObject then ActionOfMessageBox(PlayObject, QuestActionInfo);
              nSC_SETSCRIPTFLAG: if IsPlayObject then ActionOfSetScriptFlag(PlayObject, QuestActionInfo);
              nSC_SETAUTOGETEXP: if IsPlayObject then ActionOfAutoGetExp(PlayObject, QuestActionInfo);
              nSC_VAR: if IsPlayObject then ActionOfVar(PlayObject, QuestActionInfo);
              nSC_LOADVAR: if IsPlayObject then ActionOfLoadVar(PlayObject, QuestActionInfo);
              nSC_SAVEVAR: if IsPlayObject then ActionOfSaveVar(PlayObject, QuestActionInfo);
              nSC_CALCVAR: if IsPlayObject then ActionOfCalcVar(PlayObject, QuestActionInfo);
              nOFFLINEPLAY: if IsPlayObject then ActionOfNotLineAddPiont(PlayObject, QuestActionInfo);
              nKICKOFFLINE: if IsPlayObject then ActionOfKickNotLineAddPiont(PlayObject, QuestActionInfo);
              nSTARTTAKEGOLD: if IsPlayObject then ActionOfStartTakeGold(PlayObject);
              nSC_AISTART: if IsPlayObject then ActionOfAIStart(PlayObject, QuestActionInfo);
              nSC_AISTOP: if IsPlayObject then ActionOfAIStop(PlayObject, QuestActionInfo);
              nSC_AILOGON: if IsPlayObject then ActionOfAILogOn(PlayObject, QuestActionInfo);
              nSC_AILOGONEX: if IsPlayObject then ActionOfAILogOnEx(PlayObject, QuestActionInfo);
              
              //nSC_LOADROBOTCONFIG: ActionOfLoadRobotConfig(PlayObject, QuestActionInfo);
              nDELAYGOTO: begin //延时跳转 20080402
                  if IsPlayObject then begin
                    PlayObject.m_boTimeGoto := True;
                    m_DelayGoto:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam1), 0);//20081213 增加变量操作
                    if m_DelayGoto = 0 then begin
                      GetValValue(PlayObject, QuestActionInfo.sParam1, n20);
                      m_DelayGoto:= n20;
                    end;
                    if m_DelayGoto > 0 then begin
                      PlayObject.m_dwTimeGotoTick := GetTickCount + LongWord(m_DelayGoto);
                    end else PlayObject.m_dwTimeGotoTick := GetTickCount + LongWord(QuestActionInfo.nParam1{ * 1000});//改成毫秒 20080402
                    PlayObject.m_sTimeGotoLable := QuestActionInfo.sParam2;
                    PlayObject.m_TimeGotoNPC := Self;
                  end;
                end;
              nCLEARDELAYGOTO: begin
                  if IsPlayObject then begin
                    PlayObject.m_boTimeGoto := False;
                    PlayObject.m_sTimeGotoLable := '';
                    PlayObject.m_TimeGotoNPC := nil;
                  end;
                end;
              nSC_ANSIREPLACETEXT: if IsPlayObject then ActionOfAnsiReplaceText(PlayObject, QuestActionInfo);
              nSC_ENCODETEXT: if IsPlayObject then ActionOfEncodeText(PlayObject, QuestActionInfo);
              nSC_ADDTEXTLIST: begin//20080614 修改
                  if IsPlayObject then begin
                    s50 := GetLineVariableText(PlayObject,QuestActionInfo.sParam2);//文件路径支持变量 20080529
                    if s50 <> '' then begin
                      if s50[1] = '\' then s50 := Copy(s50, 2, Length(s50) - 1); //20081228 增加,处理文件路径
                      if s50[2] = '\' then s50 := Copy(s50, 3, Length(s50) - 2);
                      if s50[3] = '\' then s50 := Copy(s50, 4, Length(s50) - 3);
                    end;
                    s4C := GetLineVariableText(PlayObject,QuestActionInfo.sParam1);
                    if s4C ='' then begin
                      if not GetValValue(PlayObject, QuestActionInfo.sParam1, s4C) then begin
                        s4C := QuestActionInfo.sParam1;
                      end;
                    end;
                    if QuestActionInfo.sParam3 <> '' then m_boCheck := False
                    else m_boCheck:= True ;
                    AddList(s4C, {m_sPath +}s50, m_boCheck);//20081228
                  end;
                end;
              nSC_DELTEXTLIST: begin//20080614 修改
                  if IsPlayObject then begin
                    s50 := GetLineVariableText(PlayObject,QuestActionInfo.sParam2);//文件路径支持变量 20080529
                    if s50 <> '' then begin
                      if s50[1] = '\' then s50 := Copy(s50, 2, Length(s50) - 1); //20081228 增加,处理文件路径
                      if s50[2] = '\' then s50 := Copy(s50, 3, Length(s50) - 2);
                      if s50[3] = '\' then s50 := Copy(s50, 4, Length(s50) - 3);
                    end;
                    s4C := GetLineVariableText(PlayObject,QuestActionInfo.sParam1);//变量
                    if s4C ='' then begin
                      if not GetValValue(PlayObject, QuestActionInfo.sParam1, s4C) then begin
                        s4C := QuestActionInfo.sParam1;
                      end;
                    end;
                    DelList(s4C, {m_sPath + }s50);//20081228
                  end;
                end;
              nSC_GROUPMOVE: begin
                  if IsPlayObject then begin
                    s4C:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//20080516 增加
                    if s4C = '' then begin
                      if not GetValValue(PlayObject, QuestActionInfo.sParam1, s4C) then begin //增加变量支持
                        s4C := QuestActionInfo.sParam1;
                      end;
                    end;
                    if (PlayObject.m_GroupOwner <> nil) and (PlayObject = PlayObject.m_GroupOwner) then begin
                      if PlayObject.m_GroupOwner.m_GroupMembers.Count > 0 then begin//20080629
                        for II := 0 to PlayObject.m_GroupOwner.m_GroupMembers.Count - 1 do with TPlayObject(PlayObject.m_GroupOwner.m_GroupMembers.Objects[II]) do begin
                          if (not m_boDeath) and
                            (not m_boGhost) and
                            (not InMag113LockRect(m_nCurrX, m_nCurrY))
                            { and (TPlayObject(PlayObject.m_GroupOwner.m_GroupMembers.Objects[II]).m_boAllowGroupReCall) }then begin
                            MapRandomMove(s4C, 0);
                          end;
                        end;//for
                      end;
                      PlayObject.SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
                      //PlayObject.MapRandomMove(s4C, 0);//20080615 注释,修正队长重复二次传送
                      bo11 := True;
                    end;
                  end;
                end;
              nSC_GROUPMAPMOVE: begin //组编传送,只有队长才能使用  增加触发段，所有成员可触发QF指定触发段 20090126
                  if IsPlayObject then begin
                    if (QuestActionInfo.sParam1 <> '') and (QuestActionInfo.sParam1[1] = '<') and (QuestActionInfo.sParam1[2] = '$') then
                      s4C:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1)//20090113
                    else
                    if not GetValValue(PlayObject, QuestActionInfo.sParam1, s4C) then begin //地图号
                      s4C := QuestActionInfo.sParam1;
                    end;

                    if (QuestActionInfo.sParam2 <> '') and (QuestActionInfo.sParam2[1] = '<') and (QuestActionInfo.sParam2[2] = '$') then
                      n14:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2), 0)//20090113
                    else
                    if not GetValValue(PlayObject, QuestActionInfo.sParam2, n14) then begin //X
                      n14 := QuestActionInfo.nParam2;
                    end;

                    if (QuestActionInfo.sParam3 <> '') and (QuestActionInfo.sParam3[1] = '<') and (QuestActionInfo.sParam3[2] = '$') then
                      n40:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3), 0)//20090113
                    else
                    if not GetValValue(PlayObject, QuestActionInfo.sParam3, n40) then begin //Y
                      n40 := QuestActionInfo.nParam3;
                    end;

                    if (QuestActionInfo.sParam4 <> '') and (QuestActionInfo.sParam4[1] = '<') and (QuestActionInfo.sParam4[2] = '$') then
                      n2C:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam4), 0)
                    else
                    if not GetValValue(PlayObject, QuestActionInfo.sParam4, n2C) then begin //传送所需的等级  20090210
                      n2C := QuestActionInfo.nParam4;
                    end;
                    s50:= QuestActionInfo.sParam5;//是否设置触发段 20090210

                    if (PlayObject.m_GroupOwner <> nil) and (PlayObject = PlayObject.m_GroupOwner) then begin
                      if PlayObject.m_GroupOwner.m_GroupMembers.Count > 0 then begin//20080629
                        for II := 0 to PlayObject.m_GroupOwner.m_GroupMembers.Count - 1 do begin
                          if (not TPlayObject(PlayObject.m_GroupOwner.m_GroupMembers.Objects[II]).m_boDeath) and
                             (not TPlayObject(PlayObject.m_GroupOwner.m_GroupMembers.Objects[II]).m_boGhost){ and (TPlayObject(PlayObject.m_GroupOwner.m_GroupMembers.Objects[II]).m_boAllowGroupReCall) }then begin
                              if TPlayObject(PlayObject.m_GroupOwner.m_GroupMembers.Objects[II]).m_Abil.Level >= n2C then begin//检查等级
                                TPlayObject(PlayObject.m_GroupOwner.m_GroupMembers.Objects[II]).SpaceMove(s4C, n14, n40, 0);
                                if (s50 <> '') then Begin//是否设置触发段 20090126
                                  if (g_FunctionNPC <> nil) then begin
                                    g_FunctionNPC.GotoLable(TPlayObject(PlayObject.m_GroupOwner.m_GroupMembers.Objects[II]), s50, False, False);
                                  end;
                                end;
                              end;
                          end;
                        end;//for
                      end;
                      PlayObject.SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
                      //PlayObject.SpaceMove(s4C, n14, n40, 0);//20080615 注释,修正队长重复二次传送
                      bo11 := True;
                    end;
                  end;
                end;
              nSC_RECALLHUMAN: begin
                  if IsPlayObject then begin
                    s4C := QuestActionInfo.sParam1;
                    GetValValue(PlayObject, QuestActionInfo.sParam1, s4C);
                    if s4C <> '' then PlayObject.RecallHuman(s4C);
                  end;
                end;
              nSC_REGOTO: begin
                  if IsPlayObject then begin
                    s4C := QuestActionInfo.sParam1;
                    GetValValue(PlayObject, QuestActionInfo.sParam1, s4C);
                    if s4C <> '' then begin
                      OnlinePlayObject := UserEngine.GetPlayObject(s4C);
                      if PlayObject <> nil then begin
                        PlayObject.SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
                        PlayObject.SpaceMove(OnlinePlayObject.m_PEnvir.sMapName, OnlinePlayObject.m_nCurrX, OnlinePlayObject.m_nCurrY, 0);
                        bo11 := True;
                      end;
                    end;
                  end;
                end;
              nSC_INTTOSTR: begin
                  if IsPlayObject then begin
                    n40 := 0;
                    GetValValue(PlayObject, QuestActionInfo.sParam2, n40);
                    n14 := GetValNameNo(QuestActionInfo.sParam1);
                    if n14 >= 0 then begin
                      case n14 of
                        600..699: begin
                            PlayObject.m_sString[n14 - 600] := IntToStr(n40);
                          end;
                        700..799: begin
                            g_Config.GlobalAVal[n14 - 700] := IntToStr(n40);
                          end;
                        1200..2099:begin//A变量(100-999)
                            g_Config.GlobalAVal[n14 - 1100] := IntToStr(n40);
                          end;
                      else begin
                          ScriptActionError(PlayObject, '', QuestActionInfo, sSC_INTTOSTR);
                        end;
                      end;
                    end;
                  end;
                end;
              nSC_STRTOINT: begin
                  if IsPlayObject then begin
                    GetValValue(PlayObject, QuestActionInfo.sParam1, s4C);
                    n14 := GetValNameNo(QuestActionInfo.sParam1);
                    if n14 >= 0 then begin
                      case n14 of
                        0..99: begin //20080323 原为0..99
                            PlayObject.m_nVal[n14] := Str_ToInt(s4C, 0);
                          end;
                        100..199: begin
                            g_Config.GlobalVal[n14 - 100] := Str_ToInt(s4C, 0);
                          end;
                        200..299: begin //20080323 原为200..209
                            PlayObject.m_DyVal[n14 - 200] := Str_ToInt(s4C, 0);
                          end;
                        300..399: begin
                            PlayObject.m_nMval[n14 - 300] := Str_ToInt(s4C, 0);
                          end;
                        400..499: begin
                            g_Config.GlobaDyMval[n14 - 400] := Str_ToInt(s4C, 0);
                          end;
                        500..599: begin
                            PlayObject.m_nInteger[n14 - 500] := Str_ToInt(s4C, 0);
                          end;
                        800..1199:begin//20080903 G变量
                            g_Config.GlobalVal[n14 - 700] := Str_ToInt(s4C, 0);
                          end;
                       {1800..2799:begin//20080323 I变量
                            g_Config.GlobaDyMval[n14 - 1800]:= Str_ToInt(s4C, 0);
                          end; }
                         2100..2599: begin//G变量(500-999)
                            g_Config.GlobalVal[n14 - 1600] := Str_ToInt(s4C, 0);
                          end;
                      else begin
                          ScriptActionError(PlayObject, '', QuestActionInfo, sSC_STRTOINT);
                        end;
                      end;
                    end;
                  end;  
                end;
              nSC_GUILDMOVE: begin
                  if IsPlayObject then begin
                    if PlayObject.m_MyGuild = nil then Exit;
                    if not GetValValue(PlayObject, QuestActionInfo.sParam1, s4C) then begin //增加变量支持
                      s4C := QuestActionInfo.sParam1;
                    end;
                    PlayObject.SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
                    PlayObject.MapRandomMove(s4C, 0);
                    if TGUild(PlayObject.m_MyGuild).m_RankList.Count > 0 then begin//20080629
                      for II := 0 to TGUild(PlayObject.m_MyGuild).m_RankList.Count - 1 do begin
                        GuildRank := TGUild(PlayObject.m_MyGuild).m_RankList.Items[II];
                        if GuildRank = nil then Continue;
                        if GuildRank.MemberList.Count > 0 then begin//20080629
                          for III := 0 to GuildRank.MemberList.Count - 1 do begin
                            UserObject := TPlayObject(GuildRank.MemberList.Objects[III]);
                            if UserObject = nil then Continue;
                            if (not UserObject.m_boDeath) and (not UserObject.m_boGhost) and (UserObject.m_boAllowGuildReCall) and
                            (not UserObject.InMag113LockRect(UserObject.m_nCurrX, UserObject.m_nCurrY)) then
                              UserObject.MapRandomMove(s4C, 0);
                          end;
                        end;
                      end;//for
                    end;
                    bo11 := True;
                  end;
                end;
              nSC_GUILDMAPMOVE: begin
                  if IsPlayObject then begin
                    if PlayObject.m_MyGuild = nil then Exit;
                    if not GetValValue(PlayObject, QuestActionInfo.sParam1, s4C) then begin //增加变量支持
                      s4C := QuestActionInfo.sParam1;
                    end;
                    if not GetValValue(PlayObject, QuestActionInfo.sParam2, n14) then begin //增加变量支持
                      n14 := QuestActionInfo.nParam2;
                    end;
                    if not GetValValue(PlayObject, QuestActionInfo.sParam3, n40) then begin //增加变量支持
                      n40 := QuestActionInfo.nParam3;
                    end;
                    PlayObject.SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
                    PlayObject.SpaceMove(s4C, n14, n40, 0);
                    if TGUild(PlayObject.m_MyGuild).m_RankList.Count > 0 then begin//20080629
                      for II := 0 to TGUild(PlayObject.m_MyGuild).m_RankList.Count - 1 do begin
                        GuildRank := TGUild(PlayObject.m_MyGuild).m_RankList.Items[II];
                        if GuildRank = nil then Continue;
                        if GuildRank.MemberList.Count > 0 then begin//20080629
                          for III := 0 to GuildRank.MemberList.Count - 1 do begin
                            UserObject := TPlayObject(GuildRank.MemberList.Objects[III]);
                            if UserObject = nil then Continue;
                            if (not UserObject.m_boDeath) and (not UserObject.m_boGhost) and (UserObject.m_boAllowGuildReCall) then
                              UserObject.SpaceMove(s4C, n14, n40, 0);
                          end;
                        end;
                      end;//for
                    end;
                    bo11 := True;
                  end;  
                end;
              nSC_RANDOMMOVE: begin
                  if IsPlayObject then begin
                    PlayObject.RandomMove();
                    bo11 := True;
                  end;
                end;
              nSC_USEBONUSPOINT: if IsPlayObject then ActionOfUseBonusPoint(PlayObject, QuestActionInfo);
              nSC_REPAIRITEM: if IsPlayObject then ActionOfRepairItem(PlayObject, QuestActionInfo);
              nSC_TAKEONITEM: if IsPlayObject then ActionOfTakeOnItem(PlayObject, QuestActionInfo);//穿上装备
              nSC_TAKEOFFITEM: if IsPlayObject then ActionOfTakeOffItem(PlayObject, QuestActionInfo);//脱下装备

              //=================================英雄相关=====================================
              {$IF HEROVERSION = 1}
              nSC_CREATEHERO: if IsPlayObject then ActionOfCreateHero(PlayObject, QuestActionInfo);
              nSC_DELETEHERO: if IsPlayObject then ActionOfDeleteHero(PlayObject, QuestActionInfo);
              nSC_CHANGEHEROLEVEL: if IsPlayObject then ActionOfChangeHeroLevel(PlayObject, QuestActionInfo);

              nSC_CHANGEHEROJOB: if IsPlayObject then ActionOfChangeHeroJob(PlayObject, QuestActionInfo);
              nSC_CLEARHEROSKILL: if IsPlayObject then ActionOfClearHeroSkill(PlayObject, QuestActionInfo); //清除英雄技能
              nSC_CHANGEHEROPKPOINT: if IsPlayObject then ActionOfChangeHeroPKPoint(PlayObject, QuestActionInfo);
              nSC_CHANGEHEROEXP: if IsPlayObject then ActionOfChangeHeroExp(PlayObject, QuestActionInfo);
              {$IFEND}
            end;//Case
          end;
        end;//For
      end;
    (*except
      Result := False;//20090326
      MainOutMessage('{异常} QuestActionProcess CMDCode:'+inttostr(CMDCode));
    end;*)
  end;

  procedure SendMerChantSayMsg(sMsg, sWinName: string; boFlag: Boolean);
  var
    s10, s14: string;
    nC,TagFlag: Integer;
  begin
    PlayObject := AObject;//20090926
    s14 := sMsg;
    nC := 0;
    
    if IsPlayObject and (not PlayObject.m_boNotOnlineAddExp) and (not PlayObject.m_boAI) then begin//20110316 增加
      while (True) do begin
        try//20101126 防止死循环
          if TagCount(s14, '>') < 1 then Break;
          s14 := ArrestStringEx(s14, '<', '>', s10);
          GetVariableText(PlayObject, sMsg, s10);
        except
        end;
        Inc(nC);
        if nC >= 101 then Break;
      end;
      if not PlayObject.m_boGhost then begin//20090413 增加
        PlayObject.GetScriptLabel(sMsg);
        if (pos('@@InPutString',sMsg) <> 0) or (pos('@@InPutInteger',sMsg) <> 0) or (Self = g_FunctionNPC) then PlayObject.m_boNPCCanGoto:= True//@@InPutString @@InPutInteger 跳转标识 20090818
        else PlayObject.m_boNPCCanGoto:= False;
        {$IF M2Version <> 2}
        if Self <> g_MissionNPC then begin
          if boFlag then begin
            PlayObject.SendFirstMsg(Self, RM_MERCHANTSAY, 0, 0, 0, m_WinType, m_sCharName + '/' + sMsg);
          end else begin
            PlayObject.SendMsg(Self, RM_MERCHANTSAY, 0, 0, 0, m_WinType, m_sCharName + '/' + sMsg);
          end;
        end else begin//是 g_MissionNPC，则使用新消息发送
          if boMmission then begin//任务栏里点击了连接
            PlayObject.SendMsg(Self, RM_CLICKMMISSION, 0, 0, 0, m_WinType, sMsg);//内容显示在上部分框中
          end else begin
            PlayObject.SendMsg(Self, RM_CLICKMMISSION, 0, 1, 0, m_WinType, sMsg);//内容显示在下部分框中
          end;
        end;
        {$ELSE}
        if boFlag then begin
          PlayObject.SendFirstMsg(Self, RM_MERCHANTSAY, 0, 0, 0, m_WinType, m_sCharName + '/' + sMsg);
        end else begin
          PlayObject.SendMsg(Self, RM_MERCHANTSAY, 0, 0, 0, m_WinType, m_sCharName + '/' + sMsg);
        end;
        {$IFEND}
        m_WinType := 1;//恢复小窗口.By TasNat at : 2012-11-09 14:25:19
      end;
    end;
  end;

begin
  Inc(m_boGotoCount);
  if (m_boGotoCount > 850) and (Self <> g_FunctionNPC) then begin//20081004 防止M2不断进入GoTo而关闭,20100126 不限制QF执行
    m_boGotoCount:= 0;
    //MainOutMessage('[脚本异常] NPC:' + m_sCharName +  //20090405 注释
    //  ' 位置:' + m_sMapName + '(' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) + ')');
    Exit;
  end;
  Try
    BaseObject := AObject;//20090926
    PlayObject := AObject;//20090926
    Script := nil;
    List1C := TStringList.Create;
    n20 := 0;
    nCode:= 0;//20081005
    Try
      if PlayObject.m_NPC <> Self then begin
        nCode:= 1;
        PlayObject.m_NPC := nil;
        PlayObject.m_Script := nil;
        FillChar(PlayObject.m_nVal, SizeOf(PlayObject.m_nVal), #0);
      end;
      nCode:= 19;

      if (CompareText(sLabel, '@main') = 0) then begin   // 处理npc 点击的 使用哪个窗口 @main @bigmain
        if m_ScriptList.Count > 0 then begin//20080629
          for I := 0 to m_ScriptList.Count - 1 do begin
            nCode:= 2;
            Script3C := m_ScriptList.Items[I];
            nCode:= 13;
            if Script3C = nil then Continue;
            nCode:= 14;
            if Script3C.RecordList.Count > 0 then begin//20080629
              nCode:= 15;
              for II := 0 to Script3C.RecordList.Count - 1 do begin
                nCode:= 16;
                SayingRecord := Script3C.RecordList.Items[II];
                nCode:= 17;
                if SayingRecord = nil then Continue;
                nCode:= 18;
                if (CompareText(sLabel, SayingRecord.sLabel) = 0) or (sBigMain=LowerCase(SayingRecord.sLabel)) then
                begin // 如果是主窗口就处理
                  nCode:= 3;
                  Script := Script3C;
                  PlayObject.m_Script := Script;
                  PlayObject.m_NPC := Self;
                  if sBigMain=LowerCase(SayingRecord.sLabel) then sLabel:=sBigMain;
                  if sLabel='@bigmain' then m_WinType:=2 else m_WinType:=1;
                  Break;
                end;
                if Script <> nil then Break;
              end;
            end;
          end;//for
        end;
      end;

      nCode:= 4;//20081005
      if (Script = nil) then
      begin
        if (PlayObject.m_Script <> nil) then
        begin
          if m_ScriptList.Count > 0 then begin//20080629
            for I := m_ScriptList.Count - 1 downto 0 do begin
              if m_ScriptList.Count <= 0 then Break;
              if (m_ScriptList.Items[I] <> nil) then begin
                if (m_ScriptList.Items[I] = PlayObject.m_Script) then begin
                  Script := m_ScriptList.Items[I];
                  if Script <> nil then Break;//20081005
                end;
              end;
            end;
          end;
        end;

        nCode:= 5;//20081005
        if (Script = nil) then
        begin
          if  m_ScriptList.Count > 0 then begin//20080629
            for I := m_ScriptList.Count - 1 downto 0 do begin
              if m_ScriptList.Count <= 0 then Break;
              if (pTScript(m_ScriptList.Items[I]) <> nil) then begin
                if CheckQuestStatus(pTScript(m_ScriptList.Items[I])) then begin
                  Script := m_ScriptList.Items[I];
                  PlayObject.m_Script := Script;
                  PlayObject.m_NPC := Self;
                  if Script <> nil then Break;//20081005
                end;
              end;
            end;//for
          end;
        end;
      end;

      nCode:= 6;//20081005
      //跳转到指定示签，执行
      if (Script <> nil) then begin
        if Script.RecordList.Count > 0 then begin//20080629  [@XXXX]--保存此类数据
          for II := 0 to Script.RecordList.Count - 1 do
          begin
            SayingRecord := Script.RecordList.Items[II];
            if SayingRecord = nil then Continue;
            if (CompareText(sLabel, SayingRecord.sLabel) = 0) then  // 如果是主窗口就处理
            begin
              if boExtJmp and not SayingRecord.boExtJmp then Break;
              sSENDMSG := '';
              if SayingRecord.ProcedureList.Count > 0 then begin//20080629
                for III := 0 to SayingRecord.ProcedureList.Count - 1 do begin
                  SayingProcedure := SayingRecord.ProcedureList.Items[III];
                  if SayingProcedure = nil then Continue;
                  bo11 := False;
                  nCode:= 7;
                  if QuestCheckCondition(SayingProcedure.ConditionList) then begin
                    nCode:= 13;
                    sSENDMSG := sSENDMSG + SayingProcedure.sSayMsg;
                    nCode:= 8;
                    if not QuestActionProcess(SayingProcedure.ActionList) then Break;
                    nCode:= 9;
                    if bo11 then SendMerChantSayMsg(sSENDMSG, SayingRecord.sLabel,True);
                    nCode:= 16;
                  end else begin
                    nCode:= 14;
                    sSENDMSG := sSENDMSG + SayingProcedure.sElseSayMsg;
                    nCode:= 10;
                    if not QuestActionProcess(SayingProcedure.ElseActionList) then Break;
                    nCode:= 11;
                    if bo11 then SendMerChantSayMsg(sSENDMSG, SayingRecord.sLabel, True);
                    nCode:= 15;
                  end;
                end;//for
              end;
              nCode:= 12;
              if sSENDMSG <> '' then SendMerChantSayMsg(sSENDMSG, SayingRecord.sLabel, False);
              Break;
            end;
          end;//for
        end;
      end;
    except
      MainOutMessage(Format('{%s} TNormNpc.GotoLable Code:%d Name:%s Label:%s',[g_sExceptionVer, nCode, m_sCharName, sLabel]));
    end;
  finally
    m_boGotoCount:= 0;
    List1C.Free;
  end;
end;

//读取NPC脚本
procedure TNormNpc.LoadNpcScript;
var
  s08: string;
begin
  if m_boIsQuest then begin
    m_sPath := sNpc_def;
    s08 := m_sCharName + '-' + m_sMapName;
    FrmDB.LoadNpcScript(Self, m_sFilePath, s08);
  end else begin
    m_sPath := m_sFilePath;
    FrmDB.LoadNpcScript(Self, m_sFilePath, m_sCharName);
  end;
end;

function TNormNpc.Operate(ProcessMsg: pTProcessMessage): Boolean;
begin
  Result := inherited Operate(ProcessMsg);
end;

procedure TNormNpc.Run;
var
  nInteger: Integer;
  nCode: Byte;
begin
  try
    nCode:= 0;
    if m_Master <> nil then m_Master := nil; //不允许召唤为宝宝
    nCode:= 1;
    //NPC变色
    if (m_boNpcAutoChangeColor) and (m_dwNpcAutoChangeColorTime > 0) and (GetTickCount - m_dwNpcAutoChangeColorTick > m_dwNpcAutoChangeColorTime) then begin
      nCode:= 2;
      m_dwNpcAutoChangeColorTick := GetTickCount();
      case m_nNpcAutoChangeIdx of
        0: nInteger := STATE_TRANSPARENT;//8
        1: nInteger := POISON_STONE;//5
        2: nInteger := POISON_DONTMOVE;//4
        3: nInteger := POISON_68;//68
        4: nInteger := POISON_DECHEALTH;//0
        5: nInteger := POISON_LOCK1;//2
        6: nInteger := POISON_DAMAGEARMOR;//1
      else begin
          m_nNpcAutoChangeIdx := 0;
          nInteger := STATE_TRANSPARENT;
        end;
      end;
      nCode:= 3;
      Inc(m_nNpcAutoChangeIdx);
      m_nCharStatus := (m_nCharStatusEx and $FFFFF) or (($80000000 shr nInteger) or 0);
      nCode:= 4;
      StatusChanged('');
    end;
    nCode:= 5;
    if m_boFixColor and (m_nFixStatus <> m_nCharStatus) then begin
      nCode:= 6;
      case m_nFixColorIdx of
        0: nInteger := STATE_TRANSPARENT;
        1: nInteger := POISON_STONE;
        2: nInteger := POISON_DONTMOVE;
        3: nInteger := POISON_68;
        4: nInteger := POISON_DECHEALTH;
        5: nInteger := POISON_LOCK1;
        6: nInteger := POISON_DAMAGEARMOR;
      else begin
          m_nFixColorIdx := 0;
          nInteger := STATE_TRANSPARENT;
        end;
      end;
      nCode:= 7;
      m_nCharStatus := (m_nCharStatusEx and $FFFFF) or (($80000000 shr nInteger) or 0);
      m_nFixStatus := m_nCharStatus;
      nCode:= 8;
      StatusChanged('');
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.Run Code:%d',[g_sExceptionVer, nCode]));
  end;
  inherited;
end;
//脚本错误提示
procedure TNormNpc.ScriptActionError(PlayObject: TPlayObject; sErrMsg: string;
  QuestActionInfo: pTQuestActionInfo; sCmd: string);
var
  sMsg: string;
resourcestring
  sOutMessage = '[脚本错误] %s 脚本命令:%s NPC名称:%s 地图:%s(%d:%d) 参数1:%s 参数2:%s 参数3:%s 参数4:%s 参数5:%s 参数6:%s';
begin
  sMsg := Format(sOutMessage, [sErrMsg,
      sCmd,
      m_sCharName,
      m_sMapName,
      m_nCurrX,
      m_nCurrY,
      QuestActionInfo.sParam1,
      QuestActionInfo.sParam2,
      QuestActionInfo.sParam3,
      QuestActionInfo.sParam4,
      QuestActionInfo.sParam5,
      QuestActionInfo.sParam6]);
  MainOutMessage(sMsg);
end;

procedure TNormNpc.ScriptConditionError(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo; sCmd: string);
var
  sMsg: string;
begin
  sMsg := 'Cmd:' + sCmd +
    ' NPC名称:' + m_sCharName +
    ' 地图:' + m_sMapName +
    ' 座标:' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) +
    ' 参数1:' + QuestConditionInfo.sParam1 +
    ' 参数2:' + QuestConditionInfo.sParam2 +
    ' 参数3:' + QuestConditionInfo.sParam3 +
    ' 参数4:' + QuestConditionInfo.sParam4 +
    ' 参数5:' + QuestConditionInfo.sParam5;
  MainOutMessage('[脚本参数不正确] ' + sMsg);
end;

procedure TNormNpc.SendMsgToUser(PlayObject: TPlayObject; sMsg: string);
begin
  PlayObject.SendMsg(Self, RM_MERCHANTSAY, 0, 0, 0, 1, m_sCharName + '/' + sMsg);
end;

function TNormNpc.sub_49ADB8(sMsg, sStr, sText: string): string;
var
  n10: Integer;
  s14, s18: string;
begin
  n10 := Pos(sStr, sMsg);
  if sText = '' then sText := '';//修改默认为无 By TasNat at: 2012-03-26 18:19:39
  
  if n10 > 0 then begin
    s14 := Copy(sMsg, 1, n10 - 1);
    s18 := Copy(sMsg, Length(sStr) + n10, Length(sMsg));
    Result := s14 + sText + s18;
  end else Result := sMsg;
end;

procedure TNormNpc.UserSelect(PlayObject: TPlayObject; sData: string);
var
  sMsg, sLabel: string;
begin
  try
    PlayObject.m_nScriptGotoCount := 0;
    //==============================================
    //处理脚本命令 @back 返回上级标签内容
    if (sData <> '') and (sData[1] = '@') then begin
      sMsg := GetValidStr3(sData, sLabel, [#13]);
      if sLabel = '@goHero1' then GotoLable(PlayObject, sLabel, False, False)  //支持卧龙笔记移动 20080119
      else begin
        if (PlayObject.m_sScriptCurrLable <> sLabel) then begin
          if (sLabel <> sBACK) then begin
            PlayObject.m_sScriptGoBackLable := PlayObject.m_sScriptCurrLable;
            PlayObject.m_sScriptCurrLable := sLabel;
          end else begin
            if PlayObject.m_sScriptCurrLable <> '' then begin
              PlayObject.m_sScriptCurrLable := '';
            end else begin
              PlayObject.m_sScriptGoBackLable := '';
            end;
          end;
        end;
      end;
    end;
    //==============================================
  except
    MainOutMessage(Format('{%s} TNormNpc.UserSelect',[g_sExceptionVer]));
  end;
end;


//改变名字颜色
procedure TNormNpc.ActionOfChangeNameColor(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nColor: Integer;
begin
try
  if not GetValValue(PlayObject, QuestActionInfo.sParam1, nColor) then begin //增加变量支持
    nColor := QuestActionInfo.nParam1;
  end;
  if (nColor < 0) or (nColor > 255) then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGENAMECOLOR);
    Exit;
  end;
  PlayObject.m_btNameColor := nColor;
  PlayObject.RefNameColor();
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeNameColor',[g_sExceptionVer]));
end;
end;

procedure TNormNpc.ActionOfClearPassword(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
begin
  try
    PlayObject.m_sStoragePwd := '';
    PlayObject.m_boPasswordLocked := False;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfClearPassword',[g_sExceptionVer]));
  end;
end;

//RECALLMOB 怪物名称 等级 叛变时间 变色(0,1) 固定颜色(1-7) 是否显示主人名字(1--不显示,空或其它值显示)
//变色为0 时固定颜色才起作用
procedure TNormNpc.ActionOfRecallmob(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  mon: TBaseObject;
  I, nParam3: Integer;
begin
  try
    nParam3:= Str_ToInt(QuestActionInfo.sParam3, 0);
    if {QuestActionInfo.nParam3}nParam3 <= 1 then begin
      mon := PlayObject.MakeSlave(QuestActionInfo.sParam1, 3, Str_ToInt(QuestActionInfo.sParam2, 0), 100, 864000{10 * 24 * 60 * 60});
    end else begin
      mon := PlayObject.MakeSlave(QuestActionInfo.sParam1, 3, Str_ToInt(QuestActionInfo.sParam2, 0), 100, {QuestActionInfo.nParam3}nParam3 * 60);
    end;
    if mon <> nil then begin
      if (QuestActionInfo.sParam4 <> '') and (QuestActionInfo.sParam4[1] = '1') then begin
        mon.m_boAutoChangeColor := True;
      end else
        if QuestActionInfo.nParam5 > 0 then begin
          mon.m_boFixColor := True;
          mon.m_nFixColorIdx := QuestActionInfo.nParam5 - 1;
      end;
      if (QuestActionInfo.sParam6 <> '') and (QuestActionInfo.sParam6[1] = '1') then mon.m_nCopyHumanLevel:= 3;//不显示主人名字 20080422
      if mon.m_btRaceServer = RC_PLAYMOSTER then begin //如果是人形怪
        mon.m_nCopyHumanLevel := 1;
        if (QuestActionInfo.sParam6 <> '') and (QuestActionInfo.sParam6[1] = '1') then mon.m_nCopyHumanLevel:= 3;//不显示主人名字 20081029
        if m_ItemList.Count > 0 then begin//20080628
          for I := 0 to m_ItemList.Count - 1 do begin //清除包裹
            Dispose(m_ItemList.Items[I]);
          end;
        end;
        m_ItemList.Clear;
        TPlayMonster(mon).InitializeMonster; //人形怪重新加载怪物设置
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfRecallmob',[g_sExceptionVer]));
  end;
end;
//-----------------------------------------------------------------------------
//RECALLMOBEX 怪物名称 名称颜色 坐标X 坐标Y  20080122
//注，使用该命令召出的宝宝，凡是没有主人或者与主人不在同一地图将自动消失
procedure TNormNpc.ActionOfRECALLMOBEX(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  mon: TBaseObject;
begin
  try
    mon := UserEngine.RegenMonsterByName(m_PEnvir.sMapName, Str_ToInt(QuestActionInfo.sParam3, 0), Str_ToInt(QuestActionInfo.sParam4, 0), QuestActionInfo.sParam1);
    if mon <> nil then begin
      mon.m_Master := PlayObject; //20080127
      if g_Config.boMasterTimeRoyalty then
              mon.m_dwMasterRoyaltyTick := g_Config.dwMasterTimeRoyaltyTime * (60 * 1000)
            else
      mon.m_dwMasterRoyaltyTick := {GetTickCount + }86400000{24 * 60 * 60 * 1000};
      mon.m_dwMasterRoyaltyTime:= GetTickCount();//怪物叛变计时 20080813
      mon.m_btSlaveMakeLevel := 3;
      mon.m_btSlaveExpLevel := 1;
      if mon.m_btRaceServer = 135 then begin
        mon.m_nCopyHumanLevel := 3;//20080419 135怪,不显示主人名字
        mon.m_btSlaveExpLevel := SLAVEMAXLEVEL;//20080726 135怪,不改变名字颜色
      end;
      mon.m_btNameColor:= Str_ToInt(QuestActionInfo.sParam2, 0);

      mon.RecalcAbilitys();
      mon.RefNameColor();
      PlayObject.m_SlaveList.Add(mon);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfRECALLMOBEX',[g_sExceptionVer]));
  end;
end;
//-----------------------------------------------------------------------------
//命令格式:MOVEMOBTO 怪物名称 原地图 原X 原Y 新地图 新X 新Y    20080123
//(将指定坐标的怪物移动到新坐标，名称为ALL则移动该坐标所有怪)
procedure TNormNpc.ActionOfMOVEMOBTO(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  boMoveAll: Boolean;
  sMonName,sMap1,sMap2: String;
  SrcEnvir, DenEnvir: TEnvirnoment;
  MonList: TList;
  nX,nY,OnX,OnY: Integer;
  MoveMon: TBaseObject;
  I: Integer;
begin
try
  boMoveAll:= False;
{  nX:=Str_ToInt(QuestActionInfo.sParam6, -1);//新X
  nY:=Str_ToInt(QuestActionInfo.sParam7, -1);//新Y
  OnX:=Str_ToInt(QuestActionInfo.sParam3, -1);//原X
  OnY:=Str_ToInt(QuestActionInfo.sParam4, -1);//原Y  }
  nX:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam6), -1);//新X 支持变量 20080125
  nY:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam7), -1);//新Y 支持变量 20080125
  OnX:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam3), -1);//原X 支持变量20080125
  OnY:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam4), -1);//原Y 支持变量20080125

  sMonName:=GetLineVariableText(PlayObject,QuestActionInfo.sParam1);//怪物名称 支持变量  20080126
  if sMonName = 'ALL' then boMoveAll:= True;

  sMap1:=GetLineVariableText(PlayObject, QuestActionInfo.sParam2); //地图支持变量
  sMap2:=GetLineVariableText(PlayObject, QuestActionInfo.sParam5); //地图支持变量
  SrcEnvir := g_MapManager.FindMap(sMap1);
  DenEnvir := g_MapManager.FindMap(sMap2);
  if (SrcEnvir = nil) or (DenEnvir = nil) then Exit;

  MonList := TList.Create;
  try
    if not boMoveAll then begin//指定名称的怪移动
      UserEngine.GetMapRangeMonster(SrcEnvir, OnX, OnY, 1 ,MonList);//查指定XY范围内的怪 20080422
      if MonList.Count > 0 then begin//20080629
        for I := 0 to MonList.Count - 1 do begin
          MoveMon := TBaseObject(MonList.Items[I]);
          if MoveMon <> Self then begin
            if CompareText(MoveMon.m_sCharName, sMonName) = 0 then //是否是指定名称的怪
               MoveMon.SpaceMove(sMap2, nX, nY, 0);
          end;
        end;//for
      end;
    end else begin //所有怪移动
      UserEngine.GetMapRangeMonster(SrcEnvir, OnX, OnY, 1000,MonList);//查指定XY范围内的怪
      if MonList.Count > 0 then begin//20080629
        for I := 0 to MonList.Count - 1 do begin
          MoveMon := TBaseObject(MonList.Items[I]);
          if MoveMon <> Self then
            MoveMon.SpaceMove(sMap2, nX, nY, 0);
        end;//for
      end;
    end;
  finally
    MonList.Free;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfMOVEMOBTO',[g_sExceptionVer]));
end;
end;
//-----------------------------------------------------------------------------
//CLEARITEMMAP 地图 X Y 范围 物品名称     20080124
//(清除地图物品，物品名称为ALL则清除所有)
procedure TNormNpc.ActionOfCLEARITEMMAP(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  sItmeName,sMap: string;
  I,nX,nY,nRange,nXX,nYY: Integer;
  boClearAll: Boolean;
  Envir: TEnvirnoment;
  MapItem: PTMapItem;
  ItemList:TList;
begin
  try
    boClearAll:= False;
    sItmeName:= QuestActionInfo.sParam5;//物品名称
    sMap:= QuestActionInfo.sParam1;
    if (sMap <> '') and (sMap[1] = '<') and (sMap[2] = '$') then//增加支持<$Str()> 20080422
      sMap := GetLineVariableText(PlayObject, QuestActionInfo.sParam1)
    else GetValValue(PlayObject, QuestActionInfo.sParam1, sMap);
    //sMap:=GetLineVariableText(PlayObject, QuestActionInfo.sParam1); //地图支持变量
    nX:=Str_ToInt(QuestActionInfo.sParam2, -1);//X
    nY:=Str_ToInt(QuestActionInfo.sParam3, -1);//Y
    nRange:=Str_ToInt(QuestActionInfo.sParam4, -1);//范围

    if nX <= 0 then nX:= 1;//20091113 增加
    if nY <= 0 then nY:= 1;//20091113 增加
    if nRange <= 0 then nRange:= 1;//20091113 增加

    if (sItmeName = 'ALL') or (sItmeName = '') then boClearAll:= True; //20080419
    Envir := g_MapManager.FindMap(sMap);//查找地图
    if Envir <> nil then begin
      ItemList:= TList.Create;
      Envir.GetMapItem(nX, nY, nRange,ItemList);//取地图上指定范围的物品
      if not boClearAll then begin///清除指定物品
        if ItemList.Count > 0 then begin//20080629
          for I := 0 to ItemList.Count - 1 do begin
            MapItem:= pTMapItem(ItemList.Items[I]);
            if (CompareText(MapItem.name, sItmeName) = 0) then begin
              for nXX := nX - nRange to nX + nRange do begin
                for nYY := nY - nRange to nY + nRange do begin
                  Envir.DeleteFromMap(nXX, nYY, OS_ITEMOBJECT, TObject(MapItem));
                  if TObject(MapItem)=nil then break;
                end;
              end;
            end;
          end;//for
        end;
      end else begin //清除全部物品
        if ItemList.Count > 0 then begin//20080629
          for I := 0 to ItemList.Count - 1 do begin
            MapItem:= pTMapItem(ItemList.Items[I]);
            for nXX := nX - nRange to nX + nRange do begin
              for nYY := nY - nRange to nY + nRange do begin
               Envir.DeleteFromMap(nXX, nYY, OS_ITEMOBJECT, TObject(MapItem));
               if TObject(MapItem)=nil then break;
              end;
            end;
          end;//for
        end;
      end;
      ItemList.Free;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfCLEARITEMMAP',[g_sExceptionVer]));
  end;
end;
//-----------------------------------------------------------------------------
//功能：人物转生
//RENEWLEVEL 转次数 转后等级 分配点数 是否显示升级效果(0/1)
//    转次数  代表一次转多少级(数值范围为 1 - 255)
//    转后等级 代表转生后人物的等级，0为不改变人物当前等级。
//    分配点数 代表转生后可以得到的点数，此点数可能按比例换成人物属性点(数值范围 1  - 20000)
procedure TNormNpc.ActionOfReNewLevel(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nReLevel, nLevel, nBounsuPoint, nShowEff: Integer;
begin
  try
    nReLevel := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam1),-1);
    nLevel := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);
    nBounsuPoint := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam3),-1);
    nShowEff:= Str_ToInt(QuestActionInfo.sParam4, 0);
    if nReLevel < 0 then begin
      GetValValue(PlayObject, QuestActionInfo.sParam1, nReLevel); //增加变量支持
    end;
    if nLevel < 0 then begin
      GetValValue(PlayObject, QuestActionInfo.sParam2, nLevel); //增加变量支持
    end;
    if nBounsuPoint < 0 then begin
      GetValValue(PlayObject, QuestActionInfo.sParam3, nBounsuPoint); //增加变量支持
    end;
    if (nReLevel < 0) or (nLevel < 0) or (nBounsuPoint < 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_RENEWLEVEL);
      Exit;
    end;
    if (PlayObject.m_btReLevel + nReLevel) <= 255 then begin
      Inc(PlayObject.m_btReLevel, nReLevel);
      if nLevel > 0 then begin
        PlayObject.m_Abil.Level := nLevel;
        AddGameDataLog('17' + #9 + PlayObject.m_sMapName + #9 + //等级调整记录日志 20081102
          IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY)+ #9 +
          PlayObject.m_sCharName + #9 + IntToStr(PlayObject.m_Abil.Level) + #9 +
          '0' + #9 + '=('+IntToStr(nLevel)+')' + #9 + m_sCharName+'(转生)');
      end;  
      if g_Config.boReNewLevelClearExp then PlayObject.m_Abil.nExp := 0;
      Inc(PlayObject.m_nBonusPoint, nBounsuPoint);
      PlayObject.SendMsg(PlayObject, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
      PlayObject.HasLevelUp(0);
      PlayObject.RefShowName();
      if nShowEff = 1 then PlayObject.SendRefMsg(RM_MYSHOW, ET_OBJECTLEVELUP,0, 0, 0, ''); //人物升级动画
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfReNewLevel',[g_sExceptionVer]));
  end;
end;
//功能：改变角色性别
//格式：CHANGEGENDER 性别(0,1) Hero
procedure TNormNpc.ActionOfChangeGender(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nGENDER: Integer;
begin
  try
    nGENDER := Str_ToInt(QuestActionInfo.sParam1, -1);
    if not (nGENDER in [0, 1]) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEGENDER);
      Exit;
    end;
    if CompareText(QuestActionInfo.sParam2, 'HERO') = 0 then begin
      {$IF HEROVERSION = 1}
      if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then begin //20080519
        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEGENDER);
        Exit;
      end;
      if PlayObject.m_MyHero <> nil then begin
        PlayObject.m_MyHero.m_btGender := nGENDER;
        THeroObject(PlayObject.m_MyHero).SendMsg(PlayObject.m_MyHero, RM_HEROABILITY, 0, 0, 0, 0, ''); //发送英雄属性 20090107
        PlayObject.m_MyHero.FeatureChanged;
      end;
      {$IFEND}
    end else begin
      PlayObject.m_btGender := nGENDER;
      PlayObject.FeatureChanged;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeGender',[g_sExceptionVer]));
  end;
end;

procedure TNormNpc.ActionOfKillSlave(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I: Integer;
  Slave: TBaseObject;
  sNameMon: String;
begin
  try
    sNameMon:= GetLineVariableText(PlayObject,QuestActionInfo.sParam1);
    if PlayObject.m_SlaveList.Count > 0 then begin
      for I := 0 to PlayObject.m_SlaveList.Count - 1 do begin
        Slave := TBaseObject(PlayObject.m_SlaveList.Items[I]);
        if Slave <> nil then begin
          if sNameMon <> '' then begin
            if CompareText(sNameMon, Slave.m_sCharName) = 0 then begin
              Slave.m_WAbil.HP := 0;
              Slave.MakeGhost;
            end;
          end else begin
            Slave.m_WAbil.HP := 0;
            Slave.MakeGhost;
          end;
        end;  
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfKillSlave',[g_sExceptionVer]));
  end;
end;
//功能：设置杀怪经验倍数.
//格式：KILLMONEXPRATE 倍率 有效时间 英雄同时改变倍率(0/1)
//倍率 为杀怪经验倍数，倍数除以100为真正的倍率(200 为 2 倍经验，150 为1.5倍)
//英雄同时改变倍率(0/1)  1-英雄同时改变倍率(如与主人不在同个地图则无效)
procedure TNormNpc.ActionOfKillMonExpRate(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nRate: Integer;
  nTime: Integer;
  nCode: Byte;
  ExpTime: LongWord;
  nType: Integer;
  str: string;
begin
  nCode:=0;
  try
    if PlayObject <> nil then begin//20080612
      nRate := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam1), -1);//20090213 支持变量
      nTime := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);//20090213 支持变量
      nType:= Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3), 0);//英雄同地图可用
      if (nRate < 0) or (nTime < 0) then begin
        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_KILLMONEXPRATE);
        Exit;
      end;
      nCode:=1;
      if PlayObject.m_nKillMonExpRate = nRate then begin//20090407 倍率是否相同，相同则累计时间
        if PlayObject.m_dwKillMonExpRateTime >= LongWord(nTime) then begin//20090408 增加，防止越界
          if (High(PlayObject.m_dwKillMonExpRateTime) - PlayObject.m_dwKillMonExpRateTime) < LongWord(nTime) then begin
            nTime := High(PlayObject.m_dwKillMonExpRateTime) - PlayObject.m_dwKillMonExpRateTime;
          end;
        end else begin
          if (High(PlayObject.m_dwKillMonExpRateTime) - nTime) < PlayObject.m_dwKillMonExpRateTime then begin
            nTime := High(PlayObject.m_dwKillMonExpRateTime) - nTime;
          end;
        end;

        ExpTime:= PlayObject.m_dwKillMonExpRateTime + LongWord(nTime);//20090330 修改
        if ExpTime > 0 then begin
          PlayObject.m_nKillMonExpRate := nRate;
          PlayObject.m_nOldKillMonExpRate := PlayObject.m_nKillMonExpRate;
          PlayObject.m_dwKillMonExpRateTime := ExpTime;
          nCode:=2;
          {$IF HEROVERSION = 1}
          if (PlayObject.m_MyHero <> nil) and (nType = 1) then begin//英雄也同时双倍经验  20080406
            if PlayObject.m_MyHero.m_PEnvir = PlayObject.m_PEnvir then begin//英雄与主人同在个地图才执行 20090506
              nCode:=3;
              THeroObject(PlayObject.m_MyHero).m_nKillMonExpRate:= nRate;
              THeroObject(PlayObject.m_MyHero).m_nOldKillMonExpRate:= THeroObject(PlayObject.m_MyHero).m_nKillMonExpRate;//没使用套装前杀怪经验倍数
            end;
          end;
          {$IFEND}
          nCode:=4;
          if g_Config.boShowScriptActionMsg then begin
            nCode:=5;
            str := AnsiReplaceText(g_sChangeKillMonExpRateMsg, '%g', FloatToStr(PlayObject.m_nKillMonExpRate / 100));
            str := AnsiReplaceText(str, '%n', IntToStr(Round(PlayObject.m_dwKillMonExpRateTime / 3600)));//时
            str := AnsiReplaceText(str, '%u', IntToStr(PlayObject.m_dwKillMonExpRateTime));//秒
            //PlayObject.SysMsg(Format(g_sChangeKillMonExpRateMsg, [PlayObject.m_nKillMonExpRate / 100, PlayObject.m_dwKillMonExpRateTime]), {c_Green}c_Blue, t_Hint);//20101022 修改
            PlayObject.SysMsg(str, c_Blue, t_Hint);//20110113 修改
          end;
        end;
      end else begin
        PlayObject.m_nKillMonExpRate := nRate;
        PlayObject.m_nOldKillMonExpRate := PlayObject.m_nKillMonExpRate;
        PlayObject.m_dwKillMonExpRateTime := LongWord(nTime);
        nCode:=6;
        {$IF HEROVERSION = 1}
        if (PlayObject.m_MyHero <> nil) and (nType = 1) then begin//英雄也同时双倍经验
          if PlayObject.m_MyHero.m_PEnvir = PlayObject.m_PEnvir then begin//英雄与主人同在个地图才执行 20090506
            nCode:=7;
            THeroObject(PlayObject.m_MyHero).m_nKillMonExpRate:= nRate;
            THeroObject(PlayObject.m_MyHero).m_nOldKillMonExpRate:= THeroObject(PlayObject.m_MyHero).m_nKillMonExpRate;//没使用套装前杀怪经验倍数
          end;
        end;
        {$IFEND}
        nCode:=8;
        if g_Config.boShowScriptActionMsg then begin
          nCode:=9;
          str := AnsiReplaceText(g_sChangeKillMonExpRateMsg, '%g', FloatToStr(PlayObject.m_nKillMonExpRate / 100));
          str := AnsiReplaceText(str, '%n', IntToStr(Round(PlayObject.m_dwKillMonExpRateTime / 3600)));//时
          str := AnsiReplaceText(str, '%u', IntToStr(PlayObject.m_dwKillMonExpRateTime));//秒
          //PlayObject.SysMsg(Format(g_sChangeKillMonExpRateMsg, [PlayObject.m_nKillMonExpRate / 100, PlayObject.m_dwKillMonExpRateTime]), {c_Green}c_Blue, t_Hint);//20101022 修改
          PlayObject.SysMsg(str, c_Blue, t_Hint);//20110113 修改
        end;
      end;
    end;
  except
    on E: Exception do begin
      MainOutMessage(Format('{%s} TNormNpc.ActionOfKillMonExpRate Code:%d',[g_sExceptionVer, nCode]));
    end;
  end;
end;
//格式:MONGENEX 地图 X Y 怪名|怪类型(0普通怪/1内功怪/2英雄经络经验怪)|怪物颜色值 范围 数量 行会模式(0/1 1怪属于执行命令玩家的行会)
procedure TNormNpc.ActionOfMonGenEx(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I: Integer;
  sMapName, sMonName ,sNGMon ,sNameColor: string;
  nMapX, nMapY, nRange, nCount: Integer;
  nRandX, nRandY: Integer;
  nNameColor: Byte;
  Monster: TBaseObject;
  sStr:string;
  boGuild: Boolean;
begin
  try
    sNGMon:= '';
    sNameColor:= '';
    boGuild:= False;
    sMapName := GetLineVariableText(PlayObject, QuestActionInfo.sParam1);
    nMapX := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2), -1);
    nMapY := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam3), -1);
    if Pos('|',QuestActionInfo.sParam4) > 0 then begin
      sStr := GetValidStr3(QuestActionInfo.sParam4, sMonName, ['|']);
      sNameColor := GetValidStr3(sStr, sNGMon, ['|']);
      if (sNameColor <> '') then nNameColor:= Str_ToInt(Trim(sNameColor), 255);//名字颜色
    end else sMonName := QuestActionInfo.sParam4;
    sMonName := GetLineVariableText(PlayObject, sMonName);

    nRange := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam5),0);
    nCount := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam6),0);

    boGuild := QuestActionInfo.nParam7 = 1;
    if (sMonName = '') or (nMapX <= 0) or (nMapY <= 0) or (sMapName = '') or (nRange < 0) or (nCount <= 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_MONGENEX);
      Exit;
    end;
    if nCount <= 0 then nCount:=1;//20091113 增加
    for I := 0 to nCount - 1 do begin
      nRandX := Random(nRange * 2 + 1) + (nMapX - nRange);
      nRandY := Random(nRange * 2 + 1) + (nMapY - nRange);
      Monster:= UserEngine.RegenMonsterByName(sMapName, nRandX, nRandY, sMonName);
      if Monster = nil then begin
        //ScriptActionError(PlayObject,'',QuestActionInfo,sSC_MONGENEX);
        Break;
      end else begin
        if boGuild then begin//行会怪
          if PlayObject.m_MyGuild <> nil then Monster.m_MyGuild:= PlayObject.m_MyGuild;
        end;
        case Str_ToInt(sNGMon, 0) of
          1: Monster.m_boIsNGMonster := True;//内功怪
          2: Monster.m_boIsHeroPulsExpMon := True;//英雄经络经验怪
        end;
        if (sNameColor <> '') then begin
          Monster.m_btNameColor:= nNameColor;
          Monster.m_boSetNameColor:= True;//20081220
          Monster.RefNameColor;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfMonGenEx',[g_sExceptionVer]));
  end;
end;

procedure TNormNpc.ActionOfOpenMagicBox(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  Monster: TBaseObject;
  sMonName: string;
  nX, nY: Integer;
begin
  try
    sMonName := QuestActionInfo.sParam1;
    if sMonName = '' then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_OPENMAGICBOX);
      Exit;
    end;
    PlayObject.GetFrontPosition(nX, nY);
    Monster := UserEngine.RegenMonsterByName(PlayObject.m_PEnvir.sMapName, nX, nY, sMonName);
    if Monster = nil then Exit;
    Monster.Die;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfOpenMagicBox',[g_sExceptionVer]));
  end;
end;

procedure TNormNpc.ActionOfPkZone(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nX, nY: Integer;
  FireBurnEvent: TFireBurnEvent;
  nMinX, nMaxX, nMinY, nMaxY: Integer;
  nRange, nType, nTime, nPoint: Integer;
begin
try
  nRange := Str_ToInt(QuestActionInfo.sParam1, -1);
  nType := Str_ToInt(QuestActionInfo.sParam2, -1);
  nTime := Str_ToInt(QuestActionInfo.sParam3, -1);
  nPoint := Str_ToInt(QuestActionInfo.sParam4, -1);
  if (nRange < 0) or (nType < 0) or (nTime < 0) or (nPoint < 0) then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_PKZONE);
    Exit;
  end;
  {
  nMinX:=PlayObject.m_nCurrX - nRange;
  nMaxX:=PlayObject.m_nCurrX + nRange;
  nMinY:=PlayObject.m_nCurrY - nRange;
  nMaxY:=PlayObject.m_nCurrY + nRange;
  }
  nMinX := m_nCurrX - nRange;
  nMaxX := m_nCurrX + nRange;
  nMinY := m_nCurrY - nRange;
  nMaxY := m_nCurrY + nRange;
  for nX := nMinX to nMaxX do begin
    for nY := nMinY to nMaxY do begin
      if ((nX < nMaxX) and (nY = nMinY)) or
        ((nY < nMaxY) and (nX = nMinX)) or
        (nX = nMaxX) or (nY = nMaxY) then begin
        FireBurnEvent := TFireBurnEvent.Create(PlayObject, nX, nY, nType, nTime * 1000, nPoint);
        g_EventManager.AddEvent(FireBurnEvent);
      end;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfPkZone',[g_sExceptionVer]));
end;
end;
//功能:设置攻击力倍数
//格式:POWERRATE 倍率 有效时间
//说明:倍率 为杀攻击力倍数，倍数除以100为真正的倍率(200 为 2 倍经验，150 为1.5倍)
procedure TNormNpc.ActionOfPowerRate(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nRate, nTime: Integer;
begin
  try
    nRate := Str_ToInt(QuestActionInfo.sParam1, -1);
    nTime := Str_ToInt(QuestActionInfo.sParam2, -1);
    if (nRate < 0) or (nTime < 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_POWERRATE);
      Exit;
    end;

    PlayObject.m_nPowerRate := nRate;
    PlayObject.m_dwPowerRateTime := LongWord(nTime);
    if g_Config.boShowScriptActionMsg then begin
      PlayObject.SysMsg(Format(g_sChangePowerRateMsg, [PlayObject.m_nPowerRate / 100, PlayObject.m_dwPowerRateTime]), c_Green, t_Hint);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfPowerRate',[g_sExceptionVer]));
  end;
end;
//改变管理模式
procedure TNormNpc.ActionOfChangeMode(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nMode: Integer;
  boOpen: Boolean;
begin
  try
    nMode := QuestActionInfo.nParam1;
    boOpen := Str_ToInt(QuestActionInfo.sParam2, -1) = 1;
    if nMode in [1..3] then begin
      case nMode of //
        1: begin//管理模式
            PlayObject.m_boAdminMode := boOpen;
            if PlayObject.m_boAdminMode then PlayObject.SysMsg(sGameMasterMode, c_Green, t_Hint)
            else PlayObject.SysMsg(sReleaseGameMasterMode, c_Green, t_Hint);
          end;
        2: begin//无敌模式
            PlayObject.m_boSuperMan := boOpen;
            if PlayObject.m_boSuperMan then PlayObject.SysMsg(sSupermanMode, c_Green, t_Hint)
            else PlayObject.SysMsg(sReleaseSupermanMode, c_Green, t_Hint);
          end;
        3: begin//隐身模式
            PlayObject.m_boObMode := boOpen;
            if PlayObject.m_boObMode then PlayObject.SysMsg(sObserverMode, c_Green, t_Hint)
            else PlayObject.SysMsg(g_sReleaseObserverMode, c_Green, t_Hint);
          end;
      end;
    end else begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEMODE);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeMode',[g_sExceptionVer]));
  end;
end;

//功能：改变人物状态
//格式：ChangeModeEx 状态(1-4) 时间(秒)
//说明：1-定身,不能跑不能走 2-冰冻,不能跑不能走,不能攻击 3-蛛网,不能跑 4-红绿毒
procedure TNormNpc.ActionOfChangeModeEX(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nValue: Byte;
  nTime, nOldCharStatus: Integer;
begin
  try
    nValue := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam1), 0);
    nTime := Str_ToInt(GetLineVariableText(PlayObject, QuestActionInfo.sParam2),-1);
    if (nValue > 4) or (nValue <= 0) or (nTime < 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEMODEEX);
      Exit;
    end;
    if CompareText(QuestActionInfo.sParam3, 'HERO') = 0 then begin
      {$IF HEROVERSION = 1}
      if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then Exit;
      if PlayObject.m_MyHero <> nil then begin
        Case nValue of
          1: begin
            nOldCharStatus := PlayObject.m_MyHero.m_nCharStatus;
            PlayObject.m_MyHero.m_wStatusTimeArr[POISON_DONTMOVE] := nTime; //持继多少久(秒)
            PlayObject.m_MyHero.m_dwStatusArrTick[POISON_DONTMOVE] := GetTickCount();//人物状态持续的开始时间
            PlayObject.m_MyHero.m_nCharStatus := PlayObject.m_MyHero.GetCharStatus();
            if nOldCharStatus <> PlayObject.m_MyHero.m_nCharStatus then PlayObject.m_MyHero.StatusChanged('');
          end;
          2: begin
            nOldCharStatus := PlayObject.m_MyHero.m_nCharStatus;
            PlayObject.m_MyHero.m_wStatusTimeArr[POISON_LOCKSPELL] := nTime; //持继多少久(秒)
            PlayObject.m_MyHero.m_dwStatusArrTick[POISON_LOCKSPELL] := GetTickCount();//人物状态持续的开始时间
            PlayObject.m_MyHero.m_nCharStatus := PlayObject.m_MyHero.GetCharStatus();
            if nOldCharStatus <> PlayObject.m_MyHero.m_nCharStatus then PlayObject.m_MyHero.StatusChanged('');
            if sYouPoisonedFreeze <> '' then PlayObject.SysMsg('(英雄) '+ sYouPoisonedFreeze, c_Red, t_Hint);//被冰冻提示
          end;
          3: begin
            nOldCharStatus := PlayObject.m_MyHero.m_nCharStatus;
            PlayObject.m_MyHero.m_wStatusTimeArr[STATE_LOCKRUN] := nTime; //持继多少久(秒)
            PlayObject.m_MyHero.m_dwStatusArrTick[STATE_LOCKRUN] := GetTickCount();//人物状态持续的开始时间
            PlayObject.m_MyHero.m_nCharStatus := PlayObject.m_MyHero.GetCharStatus();
            if nOldCharStatus <> PlayObject.m_MyHero.m_nCharStatus then PlayObject.m_MyHero.StatusChanged('');
            THeroObject(PlayObject.m_MyHero).m_boCanRun:= False;//是否允许跑
            if (sYouPoisonedSpider <> '') then PlayObject.SysMsg('(英雄) '+ sYouPoisonedSpider, c_Red, t_Hint);//中蛛网提示
          end;
          4: begin//红绿毒
            nOldCharStatus := PlayObject.m_MyHero.m_nCharStatus;
            PlayObject.m_MyHero.m_wStatusTimeArr[POISON_DECHEALTH] := nTime; //持继多少久(秒)
            PlayObject.m_MyHero.m_dwStatusArrTick[POISON_DECHEALTH] := GetTickCount();//人物状态持续的开始时间
            PlayObject.m_MyHero.m_wStatusTimeArr[POISON_DAMAGEARMOR] := nTime; //持继多少久(秒)
            PlayObject.m_MyHero.m_dwStatusArrTick[POISON_DAMAGEARMOR] := GetTickCount();//人物状态持续的开始时间
            PlayObject.m_MyHero.m_nCharStatus := PlayObject.m_MyHero.GetCharStatus();
            if nOldCharStatus <> PlayObject.m_MyHero.m_nCharStatus then PlayObject.m_MyHero.StatusChanged('');
          end;
        End;
      end;
      {$IFEND}
    end else begin
      Case nValue of
        1: begin
          nOldCharStatus := PlayObject.m_nCharStatus;
          PlayObject.m_wStatusTimeArr[POISON_DONTMOVE] := nTime; //持继多少久(秒)
          PlayObject.m_dwStatusArrTick[POISON_DONTMOVE] := GetTickCount();//人物状态持续的开始时间
          PlayObject.m_nCharStatus := PlayObject.GetCharStatus();
          if nOldCharStatus <> PlayObject.m_nCharStatus then PlayObject.StatusChanged('');
        end;
        2: begin
          nOldCharStatus := PlayObject.m_nCharStatus;
          PlayObject.m_wStatusTimeArr[POISON_LOCKSPELL] := nTime; //持继多少久(秒)
          PlayObject.m_dwStatusArrTick[POISON_LOCKSPELL] := GetTickCount();//人物状态持续的开始时间
          PlayObject.m_nCharStatus := PlayObject.GetCharStatus();
          if nOldCharStatus <> PlayObject.m_nCharStatus then PlayObject.StatusChanged('');
          PlayObject.SysMsg(sYouPoisonedFreeze, c_Red, t_Hint);//被冰冻提示
        end;
        3: begin
          nOldCharStatus := PlayObject.m_nCharStatus;
          PlayObject.m_wStatusTimeArr[STATE_LOCKRUN] := nTime; //持继多少久(秒)
          PlayObject.m_dwStatusArrTick[STATE_LOCKRUN] := GetTickCount();//人物状态持续的开始时间
          PlayObject.m_nCharStatus := PlayObject.GetCharStatus();
          if nOldCharStatus <> PlayObject.m_nCharStatus then PlayObject.StatusChanged('');
          PlayObject.m_boCanRun:= False;//是否允许跑
          PlayObject.SysMsg(sYouPoisonedSpider, c_Red, t_Hint);//中蛛网提示
        end;
        4: begin//红绿毒
          nOldCharStatus := PlayObject.m_nCharStatus;
          PlayObject.m_wStatusTimeArr[POISON_DECHEALTH] := nTime; //持继多少久(秒)
          PlayObject.m_dwStatusArrTick[POISON_DECHEALTH] := GetTickCount();//人物状态持续的开始时间
          PlayObject.m_wStatusTimeArr[POISON_DAMAGEARMOR] := nTime; //持继多少久(秒)
          PlayObject.m_dwStatusArrTick[POISON_DAMAGEARMOR] := GetTickCount();//人物状态持续的开始时间
          PlayObject.m_nCharStatus := PlayObject.GetCharStatus();
          if nOldCharStatus <> PlayObject.m_nCharStatus then PlayObject.StatusChanged('');
        end;
      End;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangeModeEX',[g_sExceptionVer]));
  end;
end;

procedure TNormNpc.ActionOfChangePerMission(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nPermission: Integer;
begin
try
  nPermission := Str_ToInt(QuestActionInfo.sParam1, -1);
  if nPermission in [0..10] then begin
    PlayObject.m_btPermission := nPermission;
  end else begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEPERMISSION);
    Exit;
  end;
  if g_Config.boShowScriptActionMsg then begin
    PlayObject.SysMsg(Format(g_sChangePermissionMsg, [PlayObject.m_btPermission]), c_Green, t_Hint);
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfChangePerMission',[g_sExceptionVer]));
end;
end;
//给物品
//格式：GIVE 物品名称 数量 是否英雄(英雄为Hero,主体随意加(如"主体")) 神技代码(1-7) 神秘属性数量(1-4) 几鉴(0-3)|属性1|属性2|属性3 是否发光(0/1)
//例：Give 木剑 1 主体 1|3|5|7 4 3|12|32|34 0
procedure TNormNpc.ActionOfGiveItem(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I, nItemCount, nKamPoMysteryCount, nLight, nKamPoCount: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  sItemName, sUnKnow, sStr: string;
  boHero, boVaKnow: Boolean;
  nKnow1,nKnow2,nKnow3,nKnow4: Byte;//神技
  nVaKnow1,nVaKnow2,nVaKnow3, nVaKnow4, VaKnowCount: Byte;//普通属性
  TempList: TStringList;
begin
  Try
    sItemName := GetLineVariableText(PlayObject, QuestActionInfo.sParam1);//增加变量支持 20080409
    if sItemName ='' then sItemName := QuestActionInfo.sParam1;
    nItemCount:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2), -1);//属性 支持变量
    if nItemCount < 0 then nItemCount := QuestActionInfo.nParam2;

    if (sItemName = '') or (nItemCount <= 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_GIVE);
      Exit;
    end;
    if CompareText(sItemName, sSTRING_GOLDNAME) = 0 then begin
      PlayObject.IncGold(nItemCount);
      PlayObject.GoldChanged();
      if g_boGameLogGold then
        AddGameDataLog('9' + #9 + PlayObject.m_sMapName + #9 +
          IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
          PlayObject.m_sCharName + #9 + sSTRING_GOLDNAME + #9 + IntToStr(nItemCount) + #9 +
          '1' + #9 + m_sCharName);
      Exit;
    end;

    boHero:= False;
    if CompareText(QuestActionInfo.sParam3, 'HERO') = 0 then begin
      if PlayObject.m_MyHero <> nil then boHero:= True;
    end;
    nKamPoMysteryCount:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam5), 0);//神秘属性数量
    sUnKnow:= GetLineVariableText(PlayObject,QuestActionInfo.sParam4);//神性属性属性
    if sUnKnow <> '' then begin
      if Pos('|', sUnKnow) > 0 then begin//处理神技
        TempList := TStringList.Create;
        try
          ExtractStrings(['|'], [], PChar(Trim(sUnKnow)), TempList);
          if TempList.Count > 0 then begin
            for I := 0 to TempList.Count - 1 do begin
              if I > 4 then Break;//不超过四个神技
              sStr:= TempList.Strings[I];
              case I of
                0: nKnow1:= Str_ToInt(sStr, 0);
                1: nKnow2:= Str_ToInt(sStr, 0);
                2: nKnow3:= Str_ToInt(sStr, 0);
                3: nKnow4:= Str_ToInt(sStr, 0);
              end;
            end;
          end;
        finally
          TempList.Free;
        end;
      end else nKnow1:= Str_ToInt(sUnKnow, 0);
    end;

    boVaKnow:= False;
    if QuestActionInfo.sParam6 <> '' then begin
      if Pos('|', QuestActionInfo.sParam6) > 0 then begin//处理普通属性
        boVaKnow:= True;
        TempList := TStringList.Create;
        try
          ExtractStrings(['|'], [], PChar(Trim(QuestActionInfo.sParam6)), TempList);
          if TempList.Count > 0 then begin
            for I := 0 to TempList.Count - 1 do begin
              if I > 4 then Break;//不超过三个普通属性
              sStr:= TempList.Strings[I];
              case I of
                0: begin
                  nKamPoCount:= Str_ToInt(sStr, 0);//几鉴
                  if nKamPoCount > 3 then nKamPoCount:= 3;
                end;
                1: nVaKnow1:= Str_ToInt(sStr, 0);
                2: nVaKnow2:= Str_ToInt(sStr, 0);
                3: nVaKnow3:= Str_ToInt(sStr, 0);
                4: begin
                  if nKamPoMysteryCount = 0 then begin//没有神技时
                    nVaKnow4:= Str_ToInt(sStr, 0);
                  end;
                end;
              end;
            end;
          end;
        finally
          TempList.Free;
        end;
      end else begin
        nKamPoCount:= Str_ToInt(QuestActionInfo.sParam6, 0);//几鉴
        if nKamPoCount > 3 then nKamPoCount:= 3;
      end;
    end;

    nLight:= Str_ToInt(QuestActionInfo.sParam7, 0);//是否发光

    if UserEngine.GetStdItemIdx(sItemName) > 0 then begin
      //if not (nItemCount in [1..50]) then nItemCount := 1; //12.28 改上一条
      if (nItemCount <= 0) or (nItemCount > 50) then nItemCount := 1;//20081006 修改
      for I := 0 to nItemCount - 1 do begin //nItemCount 为0时出死循环
        if boHero then begin
          if THeroObject(PlayObject.m_MyHero).IsEnoughBag then begin
            New(UserItem);
            if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
              VaKnowCount:= 0;
              if UserItem.btAppraisalLevel in [1,11,21,31,41,51] then begin
                if (nKamPoMysteryCount > 0) and (nKamPoMysteryCount < 5) then begin//处理神秘属性
                  UserItem.btUnKnowValueCount := nKamPoMysteryCount;
                  case nKamPoMysteryCount of
                    1: UserItem.btUnKnowValue[6] := 255;
                    2: begin
                      UserItem.btUnKnowValue[6] := 255;
                      UserItem.btUnKnowValue[7] := 255;
                    end;
                    3: begin
                      UserItem.btUnKnowValue[6] := 255;
                      UserItem.btUnKnowValue[7] := 255;
                      UserItem.btUnKnowValue[8] := 255;
                    end;
                    4: begin
                      UserItem.btUnKnowValue[6] := 255;
                      UserItem.btUnKnowValue[7] := 255;
                      UserItem.btUnKnowValue[8] := 255;
                      UserItem.btUnKnowValue[9] := 255;
                    end;
                  end;
                  if (nKamPoMysteryCount > 0) then begin
                    Case nKnow1 of
                      1..7: begin
                        if (UserItem.btUnKnowValue[6] <> nKnow1) and (UserItem.btUnKnowValue[7] <> nKnow1) and
                           (UserItem.btUnKnowValue[8] <> nKnow1) and (UserItem.btUnKnowValue[9] <> nKnow1) then begin//判断属性是否重复
                          UserItem.btUnKnowValue[6] := nKnow1;
                        end;
                      end;
                      11..160: begin//20110713 神秘属性有普通属性
                        UserItem.btUnKnowValue[6] := nKnow1;
                      end;
                    end;
                  end;
                  if (nKamPoMysteryCount > 1) then begin
                    Case nKnow2 of
                      1..7: begin
                        if (UserItem.btUnKnowValue[6] <> nKnow2) and (UserItem.btUnKnowValue[7] <> nKnow2) and
                           (UserItem.btUnKnowValue[8] <> nKnow2) and (UserItem.btUnKnowValue[9] <> nKnow2) then begin//判断属性是否重复
                          UserItem.btUnKnowValue[7] := nKnow2;
                        end;
                      end;
                      11..160: begin//20110713 神秘属性有普通属性
                        UserItem.btUnKnowValue[7] := nKnow2;
                      end;
                    End;
                  end;
                  if (nKamPoMysteryCount > 2) then begin
                    Case nKnow3 of
                      1..7: begin
                        if (UserItem.btUnKnowValue[6] <> nKnow3) and (UserItem.btUnKnowValue[7] <> nKnow3) and
                           (UserItem.btUnKnowValue[8] <> nKnow3) and (UserItem.btUnKnowValue[9] <> nKnow3) then begin//判断属性是否重复
                          UserItem.btUnKnowValue[8] := nKnow3;
                        end;
                      end;
                      11..160: begin//20110713 神秘属性有普通属性
                        UserItem.btUnKnowValue[8] := nKnow3;
                      end;
                    end;
                  end;
                  if (nKamPoMysteryCount > 3) then begin
                    Case nKnow4 of
                      1..7: begin
                        if (UserItem.btUnKnowValue[6] <> nKnow4) and (UserItem.btUnKnowValue[7] <> nKnow4) and
                           (UserItem.btUnKnowValue[8] <> nKnow4) and (UserItem.btUnKnowValue[9] <> nKnow4) then begin//判断属性是否重复
                          UserItem.btUnKnowValue[9] := nKnow4;
                        end;
                      end;
                      11..160: begin//20110713 神秘属性有普通属性
                        UserItem.btUnKnowValue[9] := nKnow4;
                      end;
                    end;
                  end;
                end;
                if nVaKnow1 in [11..160] then begin
                  UserItem.btAppraisalValue[2] := nVaKnow1;
                  Inc(VaKnowCount);
                end;
                if (nVaKnow1 in [11..160]) and (nVaKnow2 in [11..160]) then begin
                  UserItem.btAppraisalValue[3] := nVaKnow2;
                  Inc(VaKnowCount);
                end;
                if (nVaKnow1 in [11..160]) and (nVaKnow2 in [11..160])
                  and (nVaKnow3 in [11..160]) then begin
                  UserItem.btAppraisalValue[4] := nVaKnow3;
                  Inc(VaKnowCount);
                end;
                if (nKamPoMysteryCount = 0) and (nVaKnow4 in [11..160]) then begin//没有神技时
                  if (nVaKnow1 in [11..160]) and (nVaKnow2 in [11..160])
                    and (nVaKnow3 in [11..160]) then begin
                    UserItem.btAppraisalValue[5] := nVaKnow4;
                    Inc(VaKnowCount);
                    if VaKnowCount > 3 then VaKnowCount:= 3;
                  end;
                end;
                if not boVaKnow then Inc(UserItem.btAppraisalLevel, nKamPoCount)
                else Inc(UserItem.btAppraisalLevel, VaKnowCount);
              end;
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem <> nil then begin//20090502 增加
                if (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) and (StdItem.StdMode <> 10) and (StdItem.StdMode <> 11) and  (StdItem.StdMode <> 15) then begin
                  UserItem.btValue[12] := nLight;
                end;
                if StdItem.NeedIdentify = 1 then
                  AddGameDataLog('9' + #9 + PlayObject.m_sMapName + #9 +
                    IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                    PlayObject.m_MyHero.m_sCharName + #9 + sItemName + #9 +
                    IntToStr(UserItem.MakeIndex) + #9 +
                    '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                    '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                    '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                    '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                    '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                    IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                    IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                    IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                    IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
              end;
              PlayObject.m_MyHero.m_ItemList.Add(UserItem);
              THeroObject(PlayObject.m_MyHero).SendAddItem(UserItem);
            end else Dispose(UserItem);
          end else begin//包裹没位则给主人
            boHero:= False;
            if PlayObject.IsEnoughBag then begin
              New(UserItem);
              if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
                if UserItem.btAppraisalLevel in [1,11,21,31,41,51] then begin
                  VaKnowCount:= 0;
                  if (nKamPoMysteryCount > 0) and (nKamPoMysteryCount < 5) then begin//处理神秘属性
                    UserItem.btUnKnowValueCount := nKamPoMysteryCount;
                    case nKamPoMysteryCount of
                      1: UserItem.btUnKnowValue[6] := 255;
                      2: begin
                        UserItem.btUnKnowValue[6] := 255;
                        UserItem.btUnKnowValue[7] := 255;
                      end;
                      3: begin
                        UserItem.btUnKnowValue[6] := 255;
                        UserItem.btUnKnowValue[7] := 255;
                        UserItem.btUnKnowValue[8] := 255;
                      end;
                      4: begin
                        UserItem.btUnKnowValue[6] := 255;
                        UserItem.btUnKnowValue[7] := 255;
                        UserItem.btUnKnowValue[8] := 255;
                        UserItem.btUnKnowValue[9] := 255;
                      end;
                    end;
                    if (nKamPoMysteryCount > 0) then begin
                      Case nKnow1 of
                        1..7: begin
                          if (UserItem.btUnKnowValue[6] <> nKnow1) and (UserItem.btUnKnowValue[7] <> nKnow1) and
                             (UserItem.btUnKnowValue[8] <> nKnow1) and (UserItem.btUnKnowValue[9] <> nKnow1) then begin//判断属性是否重复
                            UserItem.btUnKnowValue[6] := nKnow1;
                          end;
                        end;
                        11..160: begin//20110713 神秘属性有普通属性
                          UserItem.btUnKnowValue[6] := nKnow1;
                        end;
                      End;
                    end;
                    if (nKamPoMysteryCount > 1) then begin
                      Case nKnow2 of
                        1..7: begin
                          if (UserItem.btUnKnowValue[6] <> nKnow2) and (UserItem.btUnKnowValue[7] <> nKnow2) and
                             (UserItem.btUnKnowValue[8] <> nKnow2) and (UserItem.btUnKnowValue[9] <> nKnow2) then begin//判断属性是否重复
                            UserItem.btUnKnowValue[7] := nKnow2;
                          end;
                        end;
                        11..160: begin//20110713 神秘属性有普通属性
                          UserItem.btUnKnowValue[7] := nKnow2;
                        end;
                      End;
                    end;
                    if (nKamPoMysteryCount > 2) then begin
                      Case nKnow3 of
                        1..7: begin
                          if (UserItem.btUnKnowValue[6] <> nKnow3) and (UserItem.btUnKnowValue[7] <> nKnow3) and
                             (UserItem.btUnKnowValue[8] <> nKnow3) and (UserItem.btUnKnowValue[9] <> nKnow3) then begin//判断属性是否重复
                            UserItem.btUnKnowValue[8] := nKnow3;
                          end;
                        end;
                        11..160: begin//20110713 神秘属性有普通属性
                          UserItem.btUnKnowValue[8] := nKnow3;
                        end;
                      End;
                    end;
                    if (nKamPoMysteryCount > 3) then begin
                      Case nKnow4 of
                        1..7: begin
                          if (UserItem.btUnKnowValue[6] <> nKnow4) and (UserItem.btUnKnowValue[7] <> nKnow4) and
                             (UserItem.btUnKnowValue[8] <> nKnow4) and (UserItem.btUnKnowValue[9] <> nKnow4) then begin//判断属性是否重复
                            UserItem.btUnKnowValue[9] := nKnow4;
                          end;
                        end;
                        11..160: begin//20110713 神秘属性有普通属性
                          UserItem.btUnKnowValue[9] := nKnow4;
                        end;
                      End;
                    end;
                  end;
                  if nVaKnow1 in [11..160] then begin
                    UserItem.btAppraisalValue[2] := nVaKnow1;
                    Inc(VaKnowCount);
                  end;
                  if (nVaKnow1 in [11..160]) and (nVaKnow2 in [11..160]) then begin
                    UserItem.btAppraisalValue[3] := nVaKnow2;
                    Inc(VaKnowCount);
                  end;
                  if (nVaKnow1 in [11..160]) and (nVaKnow2 in [11..160])
                    and (nVaKnow3 in [11..160]) then begin
                    UserItem.btAppraisalValue[4] := nVaKnow3;
                    Inc(VaKnowCount);
                  end;
                  if (nKamPoMysteryCount = 0) and (nVaKnow4 in [11..160]) then begin//没有神技时
                    if (nVaKnow1 in [11..160]) and (nVaKnow2 in [11..160])
                      and (nVaKnow3 in [11..160]) then begin
                      UserItem.btAppraisalValue[5] := nVaKnow4;
                      Inc(VaKnowCount);
                      if VaKnowCount > 3 then VaKnowCount:= 3;
                    end;
                  end;
                  if not boVaKnow then Inc(UserItem.btAppraisalLevel, nKamPoCount)
                  else Inc(UserItem.btAppraisalLevel, VaKnowCount);
                end;
                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                if StdItem <> nil then begin//20090502 增加
                  if (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) and (StdItem.StdMode <> 10) and (StdItem.StdMode <> 11) and  (StdItem.StdMode <> 15) then begin
                    UserItem.btValue[12] := nLight;
                  end;
                  if StdItem.NeedIdentify = 1 then
                    AddGameDataLog('9' + #9 + PlayObject.m_sMapName + #9 +
                      IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                      PlayObject.m_sCharName + #9 + sItemName + #9 +
                      IntToStr(UserItem.MakeIndex) + #9 +
                      '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                      '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                      '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                      '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                      '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                      IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                      IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                      IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                      IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                end;
                PlayObject.m_ItemList.Add(UserItem);
                PlayObject.SendAddItem(UserItem);
              end else Dispose(UserItem);
            end else begin
              New(UserItem);
              if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
                if UserItem.btAppraisalLevel in [1,11,21,31,41,51] then begin
                  VaKnowCount:= 0;
                  if (nKamPoMysteryCount > 0) and (nKamPoMysteryCount < 5) then begin//20101021 增加
                    UserItem.btUnKnowValueCount := nKamPoMysteryCount;
                    case nKamPoMysteryCount of
                      1: UserItem.btUnKnowValue[6] := 255;
                      2: begin
                        UserItem.btUnKnowValue[6] := 255;
                        UserItem.btUnKnowValue[7] := 255;
                      end;
                      3: begin
                        UserItem.btUnKnowValue[6] := 255;
                        UserItem.btUnKnowValue[7] := 255;
                        UserItem.btUnKnowValue[8] := 255;
                      end;
                      4: begin
                        UserItem.btUnKnowValue[6] := 255;
                        UserItem.btUnKnowValue[7] := 255;
                        UserItem.btUnKnowValue[8] := 255;
                        UserItem.btUnKnowValue[9] := 255;
                      end;
                    end;
                    if (nKamPoMysteryCount > 0) then begin
                      Case nKnow1 of
                        1..7: begin
                          if (UserItem.btUnKnowValue[6] <> nKnow1) and (UserItem.btUnKnowValue[7] <> nKnow1) and
                             (UserItem.btUnKnowValue[8] <> nKnow1) and (UserItem.btUnKnowValue[9] <> nKnow1) then begin//判断属性是否重复
                            UserItem.btUnKnowValue[6] := nKnow1;
                          end;
                        end;
                        11..160: begin//20110713 神秘属性有普通属性
                          UserItem.btUnKnowValue[6] := nKnow1;
                        end;
                      End;
                    end;
                    if (nKamPoMysteryCount > 1) then begin
                      Case nKnow2 of
                        1..7: begin
                          if (UserItem.btUnKnowValue[6] <> nKnow2) and (UserItem.btUnKnowValue[7] <> nKnow2) and
                             (UserItem.btUnKnowValue[8] <> nKnow2) and (UserItem.btUnKnowValue[9] <> nKnow2) then begin//判断属性是否重复
                            UserItem.btUnKnowValue[7] := nKnow2;
                          end;
                        end;
                        11..160: begin//20110713 神秘属性有普通属性
                          UserItem.btUnKnowValue[7] := nKnow2;
                        end;
                      End;
                    end;
                    if (nKamPoMysteryCount > 2) then begin
                      Case nKnow3 of
                        1..7: begin
                          if (UserItem.btUnKnowValue[6] <> nKnow3) and (UserItem.btUnKnowValue[7] <> nKnow3) and
                             (UserItem.btUnKnowValue[8] <> nKnow3) and (UserItem.btUnKnowValue[9] <> nKnow3) then begin//判断属性是否重复
                            UserItem.btUnKnowValue[8] := nKnow3;
                          end;
                        end;
                        11..160: begin//20110713 神秘属性有普通属性
                          UserItem.btUnKnowValue[8] := nKnow3;
                        end;
                      End;
                    end;
                    if (nKamPoMysteryCount > 3) then begin
                      Case nKnow4 of
                        1..7: begin
                          if (UserItem.btUnKnowValue[6] <> nKnow4) and (UserItem.btUnKnowValue[7] <> nKnow4) and
                             (UserItem.btUnKnowValue[8] <> nKnow4) and (UserItem.btUnKnowValue[9] <> nKnow4) then begin//判断属性是否重复
                            UserItem.btUnKnowValue[9] := nKnow4;
                          end;
                        end;
                        11..160: begin//20110713 神秘属性有普通属性
                          UserItem.btUnKnowValue[9] := nKnow4;
                        end;
                      End;
                    end;
                  end;
                  if nVaKnow1 in [11..160] then begin
                    UserItem.btAppraisalValue[2] := nVaKnow1;
                    Inc(VaKnowCount);
                  end;
                  if (nVaKnow1 in [11..160]) and (nVaKnow2 in [11..160]) then begin
                    UserItem.btAppraisalValue[3] := nVaKnow2;
                    Inc(VaKnowCount);
                  end;
                  if (nVaKnow1 in [11..160]) and (nVaKnow2 in [11..160])
                    and (nVaKnow3 in [11..160]) then begin
                    UserItem.btAppraisalValue[4] := nVaKnow3;
                    Inc(VaKnowCount);
                  end;
                  if (nKamPoMysteryCount = 0) and (nVaKnow4 in [11..160]) then begin//没有神技时
                    if (nVaKnow1 in [11..160]) and (nVaKnow2 in [11..160])
                      and (nVaKnow3 in [11..160]) then begin
                      UserItem.btAppraisalValue[5] := nVaKnow4;
                      Inc(VaKnowCount);
                      if VaKnowCount > 3 then VaKnowCount:= 3;
                    end;
                  end;
                  if not boVaKnow then Inc(UserItem.btAppraisalLevel, nKamPoCount)
                  else Inc(UserItem.btAppraisalLevel, VaKnowCount);
                end;
                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                if StdItem <> nil then begin//20090502 增加
                  if (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) and (StdItem.StdMode <> 10) and (StdItem.StdMode <> 11) and  (StdItem.StdMode <> 15) then begin
                    UserItem.btValue[12] := nLight;
                  end;
                  if StdItem.NeedIdentify = 1 then
                    AddGameDataLog('9' + #9 + PlayObject.m_sMapName + #9 +
                      IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                      PlayObject.m_sCharName + #9 + sItemName + #9 +
                      IntToStr(UserItem.MakeIndex) + #9 +
                      '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                      '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                      '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                      '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                      '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                      IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                      IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                      IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                      IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                end;
                PlayObject.DropItemDown(UserItem, 3, False, False, PlayObject, PlayObject{nil}); //20080519 修正M2报错:{异常} TMerchant::UserSelect... Data: @XXXX Code:0
                Dispose(UserItem);//修复内存泄露By TasNat at: 2012-06-01 12:10:51
              end else Dispose(UserItem);//20081006 修改
            end;
          end;
        end else begin
          if PlayObject.IsEnoughBag then begin
            New(UserItem);
            if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem <> nil then begin//20090502 增加
                if UserItem.btAppraisalLevel in [1,11,21,31,41,51] then begin
                  VaKnowCount:= 0;
                  if (nKamPoMysteryCount > 0) and (nKamPoMysteryCount < 5) then begin//20101021 增加
                    UserItem.btUnKnowValueCount := nKamPoMysteryCount;
                    case nKamPoMysteryCount of
                      1: UserItem.btUnKnowValue[6] := 255;
                      2: begin
                        UserItem.btUnKnowValue[6] := 255;
                        UserItem.btUnKnowValue[7] := 255;
                      end;
                      3: begin
                        UserItem.btUnKnowValue[6] := 255;
                        UserItem.btUnKnowValue[7] := 255;
                        UserItem.btUnKnowValue[8] := 255;
                      end;
                      4: begin
                        UserItem.btUnKnowValue[6] := 255;
                        UserItem.btUnKnowValue[7] := 255;
                        UserItem.btUnKnowValue[8] := 255;
                        UserItem.btUnKnowValue[9] := 255;
                      end;
                    end;
                    if (nKamPoMysteryCount > 0) then begin
                      Case nKnow1 of
                        1..7: begin
                          if (UserItem.btUnKnowValue[6] <> nKnow1) and (UserItem.btUnKnowValue[7] <> nKnow1) and
                             (UserItem.btUnKnowValue[8] <> nKnow1) and (UserItem.btUnKnowValue[9] <> nKnow1) then begin//判断属性是否重复
                            UserItem.btUnKnowValue[6] := nKnow1;
                          end;
                        end;
                        11..160: begin//20110713 神秘属性有普通属性
                          UserItem.btUnKnowValue[6] := nKnow1;
                        end;
                      End;
                    end;
                    if (nKamPoMysteryCount > 1) then begin
                      Case nKnow2 of
                        1..7: begin
                          if (UserItem.btUnKnowValue[6] <> nKnow2) and (UserItem.btUnKnowValue[7] <> nKnow2) and
                             (UserItem.btUnKnowValue[8] <> nKnow2) and (UserItem.btUnKnowValue[9] <> nKnow2) then begin//判断属性是否重复
                            UserItem.btUnKnowValue[7] := nKnow2;
                          end;
                        end;
                        11..160: begin//20110713 神秘属性有普通属性
                          UserItem.btUnKnowValue[7] := nKnow2;
                        end;
                      End;
                    end;
                    if (nKamPoMysteryCount > 2) then begin
                      Case nKnow3 of
                        1..7: begin
                          if (UserItem.btUnKnowValue[6] <> nKnow3) and (UserItem.btUnKnowValue[7] <> nKnow3) and
                             (UserItem.btUnKnowValue[8] <> nKnow3) and (UserItem.btUnKnowValue[9] <> nKnow3) then begin//判断属性是否重复
                            UserItem.btUnKnowValue[8] := nKnow3;
                          end;
                        end;
                        11..160: begin//20110713 神秘属性有普通属性
                          UserItem.btUnKnowValue[8] := nKnow3;
                        end;
                      End;
                    end;
                    if (nKamPoMysteryCount > 3) then begin
                      Case nKnow4 of
                        1..7: begin
                          if (UserItem.btUnKnowValue[6] <> nKnow4) and (UserItem.btUnKnowValue[7] <> nKnow4) and
                             (UserItem.btUnKnowValue[8] <> nKnow4) and (UserItem.btUnKnowValue[9] <> nKnow4) then begin//判断属性是否重复
                            UserItem.btUnKnowValue[9] := nKnow4;
                          end;
                        end;
                        11..160: begin//20110713 神秘属性有普通属性
                          UserItem.btUnKnowValue[9] := nKnow4;
                        end;
                      End;
                    end;
                  end;
                  if nVaKnow1 in [11..160] then begin
                    UserItem.btAppraisalValue[2] := nVaKnow1;
                    Inc(VaKnowCount);
                  end;
                  if (nVaKnow1 in [11..160]) and (nVaKnow2 in [11..160]) then begin
                    UserItem.btAppraisalValue[3] := nVaKnow2;
                    Inc(VaKnowCount);
                  end;
                  if (nVaKnow1 in [11..160]) and (nVaKnow2 in [11..160])
                    and (nVaKnow3 in [11..160]) then begin
                    UserItem.btAppraisalValue[4] := nVaKnow3;
                    Inc(VaKnowCount);
                  end;
                  if (nKamPoMysteryCount = 0) and (nVaKnow4 in [11..160]) then begin//没有神技时
                    if (nVaKnow1 in [11..160]) and (nVaKnow2 in [11..160])
                      and (nVaKnow3 in [11..160]) then begin
                      UserItem.btAppraisalValue[5] := nVaKnow4;
                      Inc(VaKnowCount);
                      if VaKnowCount > 3 then VaKnowCount:= 3;
                    end;
                  end;
                  if not boVaKnow then Inc(UserItem.btAppraisalLevel, nKamPoCount)
                  else Inc(UserItem.btAppraisalLevel, VaKnowCount);
                end;
                if (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) and (StdItem.StdMode <> 10) and (StdItem.StdMode <> 11) and  (StdItem.StdMode <> 15) then begin
                  UserItem.btValue[12] := nLight;
                end;
                PlayObject.m_ItemList.Add(UserItem);
                PlayObject.SendAddItem(UserItem);
                if StdItem.NeedIdentify = 1 then
                  AddGameDataLog('9' + #9 + PlayObject.m_sMapName + #9 +
                    IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                    PlayObject.m_sCharName + #9 + sItemName + #9 +
                    IntToStr(UserItem.MakeIndex) + #9 +
                    '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                    '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                    '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                    '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                    '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                    IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                    IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                    IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                    IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
              end;
            end else Dispose(UserItem);
          end else begin//包裹满则扔到地上
            New(UserItem);
            if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if UserItem.btAppraisalLevel in [1,11,21,31,41,51] then begin
                VaKnowCount:= 0;
                if (nKamPoMysteryCount > 0) and (nKamPoMysteryCount < 5) then begin//20101021 增加
                  UserItem.btUnKnowValueCount := nKamPoMysteryCount;
                  case nKamPoMysteryCount of
                    1: UserItem.btUnKnowValue[6] := 255;
                    2: begin
                      UserItem.btUnKnowValue[6] := 255;
                      UserItem.btUnKnowValue[7] := 255;
                    end;
                    3: begin
                      UserItem.btUnKnowValue[6] := 255;
                      UserItem.btUnKnowValue[7] := 255;
                      UserItem.btUnKnowValue[8] := 255;
                    end;
                    4: begin
                      UserItem.btUnKnowValue[6] := 255;
                      UserItem.btUnKnowValue[7] := 255;
                      UserItem.btUnKnowValue[8] := 255;
                      UserItem.btUnKnowValue[9] := 255;
                    end;
                  end;
                  if (nKamPoMysteryCount > 0) then begin
                    Case nKnow1 of
                      1..7: begin
                        if (UserItem.btUnKnowValue[6] <> nKnow1) and (UserItem.btUnKnowValue[7] <> nKnow1) and
                           (UserItem.btUnKnowValue[8] <> nKnow1) and (UserItem.btUnKnowValue[9] <> nKnow1) then begin//判断属性是否重复
                          UserItem.btUnKnowValue[6] := nKnow1;
                        end;
                      end;
                      11..160: begin//20110713 神秘属性有普通属性
                        UserItem.btUnKnowValue[6] := nKnow1;
                      end;
                    End;
                  end;
                  if (nKamPoMysteryCount > 1) then begin
                    Case nKnow2 of
                      1..7: begin
                        if (UserItem.btUnKnowValue[6] <> nKnow2) and (UserItem.btUnKnowValue[7] <> nKnow2) and
                           (UserItem.btUnKnowValue[8] <> nKnow2) and (UserItem.btUnKnowValue[9] <> nKnow2) then begin//判断属性是否重复
                          UserItem.btUnKnowValue[7] := nKnow2;
                        end;
                      end;
                      11..160: begin//20110713 神秘属性有普通属性
                        UserItem.btUnKnowValue[7] := nKnow2;
                      end;
                    End;
                  end;
                  if (nKamPoMysteryCount > 2) then begin
                    Case nKnow3 of
                      1..7: begin
                        if (UserItem.btUnKnowValue[6] <> nKnow3) and (UserItem.btUnKnowValue[7] <> nKnow3) and
                           (UserItem.btUnKnowValue[8] <> nKnow3) and (UserItem.btUnKnowValue[9] <> nKnow3) then begin//判断属性是否重复
                          UserItem.btUnKnowValue[8] := nKnow3;
                        end;
                      end;
                      11..160: begin//20110713 神秘属性有普通属性
                        UserItem.btUnKnowValue[8] := nKnow3;
                      end;
                    End;
                  end;
                  if (nKamPoMysteryCount > 3) then begin
                    Case nKnow4 of
                      1..7: begin
                        if (UserItem.btUnKnowValue[6] <> nKnow4) and (UserItem.btUnKnowValue[7] <> nKnow4) and
                           (UserItem.btUnKnowValue[8] <> nKnow4) and (UserItem.btUnKnowValue[9] <> nKnow4) then begin//判断属性是否重复
                          UserItem.btUnKnowValue[9] := nKnow4;
                        end;
                      end;
                      11..160: begin//20110713 神秘属性有普通属性
                        UserItem.btUnKnowValue[9] := nKnow4;
                      end;
                    End;
                  end;
                end;
                if nVaKnow1 in [11..160] then begin
                  UserItem.btAppraisalValue[2] := nVaKnow1;
                  Inc(VaKnowCount);
                end;
                if (nVaKnow1 in [11..160]) and (nVaKnow2 in [11..160]) then begin
                  UserItem.btAppraisalValue[3] := nVaKnow2;
                  Inc(VaKnowCount);
                end;
                if (nVaKnow1 in [11..160]) and (nVaKnow2 in [11..160])
                  and (nVaKnow3 in [11..160]) then begin
                  UserItem.btAppraisalValue[4] := nVaKnow3;
                  Inc(VaKnowCount);
                end;
                if (nKamPoMysteryCount = 0) and (nVaKnow4 in [11..160]) then begin//没有神技时
                  if (nVaKnow1 in [11..160]) and (nVaKnow2 in [11..160])
                    and (nVaKnow3 in [11..160]) then begin
                    UserItem.btAppraisalValue[5] := nVaKnow4;
                    Inc(VaKnowCount);
                    if VaKnowCount > 3 then VaKnowCount:= 3;
                  end;
                end;
                if not boVaKnow then Inc(UserItem.btAppraisalLevel, nKamPoCount)
                else Inc(UserItem.btAppraisalLevel, VaKnowCount);
              end;
              if StdItem <> nil then begin//20090502 增加
                if StdItem.NeedIdentify = 1 then
                  AddGameDataLog('9' + #9 + PlayObject.m_sMapName + #9 +
                    IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                    PlayObject.m_sCharName + #9 + sItemName + #9 +
                    IntToStr(UserItem.MakeIndex) + #9 +
                    '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                    '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                    '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                    '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                    '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                    IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                    IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                    IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                    IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
              end;
              if (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) and (StdItem.StdMode <> 10) and (StdItem.StdMode <> 11) and  (StdItem.StdMode <> 15) then begin
                UserItem.btValue[12] := nLight;
              end;
              PlayObject.DropItemDown(UserItem, 3, False, False, PlayObject, PlayObject{nil}); //20080519 修正M2报错:{异常} TMerchant::UserSelect... Data: @XXXX Code:0
              Dispose(UserItem);//修复内存泄露By TasNat at: 2012-06-01 12:10:51
            end else Dispose(UserItem);//20081006 修改
          end;
        end;
      end;//for
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfGiveItem %p',[g_sExceptionVer, ExceptAddr]));
  end;
end;

procedure TNormNpc.ActionOfGmExecute(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  sData: string;
  btOldPermission: Byte;
  sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7, sParam8: string;
  nParam2, nParam3, nParam4, nParam5, nParam6, nParam7, nParam8: Integer;
begin
  try
    sParam1 := QuestActionInfo.sParam1;
    sParam2 := QuestActionInfo.sParam2;
    sParam3 := QuestActionInfo.sParam3;
    sParam4 := QuestActionInfo.sParam4;
    sParam5 := QuestActionInfo.sParam5;
    sParam6 := QuestActionInfo.sParam6;
    sParam7 := QuestActionInfo.sParam7;
    sParam8 := QuestActionInfo.sParam8;

    if (sParam2 <> '') and (sParam2[1] = '<') and (sParam2[2] = '$') then//增加支持<$Str()>
      sParam2 := GetLineVariableText(PlayObject, sParam2)
    else begin
      if (CompareText(sParam1, g_GameCommand.MOBNPC.sCmd) <> 0) and (CompareText(sParam1, g_GameCommand.DELNPC.sCmd) <> 0) then //除MOBNPC,DELNPC命令外，其它转换 20101225
        GetValValue(PlayObject, sParam2, sParam2);
    end;
    if (sParam3 <> '') and (sParam3[1] = '<') and (sParam3[2] = '$') then//增加支持<$Str()>
      sParam3 := GetLineVariableText(PlayObject, sParam3)
    else GetValValue(PlayObject, sParam3, sParam3);

    if (sParam4 <> '') and (sParam4[1] = '<') and (sParam4[2] = '$') then//增加支持<$Str()>
       sParam4 := GetLineVariableText(PlayObject, sParam4)
    else GetValValue(PlayObject, sParam4, sParam4);

    if (sParam5 <> '') and (sParam5[1] = '<') and (sParam5[2] = '$') then//增加支持<$Str()>
       sParam5 := GetLineVariableText(PlayObject, sParam5)
    else GetValValue(PlayObject, sParam5, sParam5);

    if (sParam6 <> '') and (sParam6[1] = '<') and (sParam6[2] = '$') then//增加支持<$Str()>
       sParam6 := GetLineVariableText(PlayObject, sParam6)
    else GetValValue(PlayObject, sParam6, sParam6);

    if (sParam7 <> '') and (sParam7[1] = '<') and (sParam7[2] = '$') then//增加支持<$Str()>
       sParam7 := GetLineVariableText(PlayObject, sParam7)
    else GetValValue(PlayObject, sParam7, sParam7);

    if (sParam8 <> '') and (sParam8[1] = '<') and (sParam8[2] = '$') then//增加支持<$Str()>
       sParam8 := GetLineVariableText(PlayObject, sParam8)
    else GetValValue(PlayObject, sParam8, sParam8);

    if GetValValue(PlayObject, sParam2, nParam2) then sParam2 := IntToStr(nParam2);
    if CompareText(sParam1, g_GameCommand.DELNPC.sCmd) <> 0 then//除DELNPC命令外，其它转换 20110508
      if GetValValue(PlayObject, sParam3, nParam3) then sParam3 := IntToStr(nParam3);
    if GetValValue(PlayObject, sParam4, nParam4) then sParam4 := IntToStr(nParam4);
    if GetValValue(PlayObject, sParam5, nParam5) then sParam5 := IntToStr(nParam5);
    if CompareText(sParam1, g_GameCommand.MOBNPC.sCmd) <> 0 then//除MOBNPC命令外，其它转换 20101018
      if GetValValue(PlayObject, sParam6, nParam6) then sParam6 := IntToStr(nParam6);
    if GetValValue(PlayObject, sParam7, nParam7) then sParam7 := IntToStr(nParam7);
    if GetValValue(PlayObject, sParam8, nParam8) then sParam8 := IntToStr(nParam8);
    if CompareText(sParam2, 'Self') = 0 then sParam2 := PlayObject.m_sCharName;
    sData := Format('@%s %s %s %s %s %s %s %s', [sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7, sParam8]);
    btOldPermission := PlayObject.m_btPermission;
    try
      PlayObject.m_btPermission := 10;
      PlayObject.ProcessUserLineMsg(sData);
    finally
      PlayObject.m_btPermission := btOldPermission;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfGmExecute',[g_sExceptionVer]));
  end;
end;

procedure TNormNpc.ActionOfGuildAuraePoint(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nAuraePoint: Integer;
  cMethod: Char;
  Guild: TGUild;
begin
try
  //nAuraePoint := Str_ToInt(QuestActionInfo.sParam2, -1);
  nAuraePoint := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);//20080501
  if nAuraePoint < 0 then begin
    if not GetValValue(PlayObject, QuestActionInfo.sParam2, nAuraePoint) then begin //增加变量支持
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_AURAEPOINT);
      Exit;
    end;
  end;
  if PlayObject.m_MyGuild = nil then begin
    PlayObject.SysMsg(g_sScriptGuildAuraePointNoGuild, c_Red, t_Hint);
    Exit;
  end;
  Guild := TGUild(PlayObject.m_MyGuild);

  cMethod := QuestActionInfo.sParam1[1];
  case cMethod of
    '=': begin
        Guild.nAurae := nAuraePoint;
      end;
    '-': begin
        if Guild.nAurae >= nAuraePoint then begin
          Guild.nAurae := Guild.nAurae - nAuraePoint;
        end else begin
          Guild.nAurae := 0;
        end;
      end;
    '+': begin
        if (High(Integer) - Guild.nAurae) >= nAuraePoint then begin
          Guild.nAurae := Guild.nAurae + nAuraePoint;
        end else begin
          Guild.nAurae := High(Integer);
        end;
      end;
  end;
  if g_Config.boShowScriptActionMsg then begin
    PlayObject.SysMsg(Format(g_sScriptGuildAuraePointMsg, [Guild.nAurae]), c_Green, t_Hint);
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfGuildAuraePoint',[g_sExceptionVer]));
end;
end;

procedure TNormNpc.ActionOfGuildBuildPoint(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nBuildPoint: Integer;
  cMethod: Char;
  Guild: TGUild;
begin
try
  //nBuildPoint := Str_ToInt(QuestActionInfo.sParam2, -1);
  nBuildPoint := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);//20080501
  if nBuildPoint < 0 then begin
    if not GetValValue(PlayObject, QuestActionInfo.sParam2, nBuildPoint) then begin //增加变量支持
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_BUILDPOINT);
      Exit;
    end;
  end;
  if PlayObject.m_MyGuild = nil then begin
    PlayObject.SysMsg(g_sScriptGuildBuildPointNoGuild, c_Red, t_Hint);
    Exit;
  end;
  Guild := TGUild(PlayObject.m_MyGuild);

  cMethod := QuestActionInfo.sParam1[1];
  case cMethod of
    '=': begin
        Guild.nBuildPoint := nBuildPoint;
      end;
    '-': begin
        if Guild.nBuildPoint >= nBuildPoint then begin
          Guild.nBuildPoint := Guild.nBuildPoint - nBuildPoint;
        end else begin
          Guild.nBuildPoint := 0;
        end;
      end;
    '+': begin
        if (High(Integer) - Guild.nBuildPoint) >= nBuildPoint then begin
          Guild.nBuildPoint := Guild.nBuildPoint + nBuildPoint;
        end else begin
          Guild.nBuildPoint := High(Integer);
        end;
      end;
  end;
  if g_Config.boShowScriptActionMsg then begin
    PlayObject.SysMsg(Format(g_sScriptGuildBuildPointMsg, [Guild.nBuildPoint]), c_Green, t_Hint);
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfGuildBuildPoint',[g_sExceptionVer]));
end;
end;

procedure TNormNpc.ActionOfGuildChiefItemCount(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nItemCount: Integer;
  cMethod: Char;
  Guild: TGUild;
begin
try
  //nItemCount := Str_ToInt(QuestActionInfo.sParam2, -1);
  nItemCount := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);//20080501
  if nItemCount < 0 then begin
    if not GetValValue(PlayObject, QuestActionInfo.sParam2, nItemCount) then begin //增加变量支持
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_GUILDCHIEFITEMCOUNT);
      Exit;
    end;
  end;
  if PlayObject.m_MyGuild = nil then begin
    PlayObject.SysMsg(g_sScriptGuildFlourishPointNoGuild, c_Red, t_Hint);
    Exit;
  end;
  Guild := TGUild(PlayObject.m_MyGuild);

  cMethod := QuestActionInfo.sParam1[1];
  case cMethod of
    '=': begin
        Guild.nChiefItemCount := nItemCount;
      end;
    '-': begin
        if Guild.nChiefItemCount >= nItemCount then begin
          Guild.nChiefItemCount := Guild.nChiefItemCount - nItemCount;
        end else begin
          Guild.nChiefItemCount := 0;
        end;
      end;
    '+': begin
        if (High(Integer) - Guild.nChiefItemCount) >= nItemCount then begin
          Guild.nChiefItemCount := Guild.nChiefItemCount + nItemCount;
        end else begin
          Guild.nChiefItemCount := High(Integer);
        end;
      end;
  end;
  if g_Config.boShowScriptActionMsg then begin
    PlayObject.SysMsg(Format(g_sScriptChiefItemCountMsg, [Guild.nChiefItemCount]), c_Green, t_Hint);
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfGuildChiefItemCount',[g_sExceptionVer]));
end;
end;

procedure TNormNpc.ActionOfGuildFlourishPoint(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nFlourishPoint: Integer;
  cMethod: Char;
  Guild: TGUild;
begin
try
  //nFlourishPoint := Str_ToInt(QuestActionInfo.sParam2, -1);
  nFlourishPoint := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);//20080501
  if nFlourishPoint < 0 then begin
    if not GetValValue(PlayObject, QuestActionInfo.sParam2, nFlourishPoint) then begin //增加变量支持
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_FLOURISHPOINT);
      Exit;
    end;
  end;
  if PlayObject.m_MyGuild = nil then begin
    PlayObject.SysMsg(g_sScriptGuildFlourishPointNoGuild, c_Red, t_Hint);
    Exit;
  end;
  Guild := TGUild(PlayObject.m_MyGuild);

  cMethod := QuestActionInfo.sParam1[1];
  case cMethod of
    '=': begin
        Guild.nFlourishing := nFlourishPoint;
      end;
    '-': begin
        if Guild.nFlourishing >= nFlourishPoint then begin
          Guild.nFlourishing := Guild.nFlourishing - nFlourishPoint;
        end else begin
          Guild.nFlourishing := 0;
        end;
      end;
    '+': begin
        if (High(Integer) - Guild.nFlourishing) >= nFlourishPoint then begin
          Guild.nFlourishing := Guild.nFlourishing + nFlourishPoint;
        end else begin
          Guild.nFlourishing := High(Integer);
        end;
      end;
  end;
  if g_Config.boShowScriptActionMsg then begin
    PlayObject.SysMsg(Format(g_sScriptGuildFlourishPointMsg, [Guild.nFlourishing]), c_Green, t_Hint);
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfGuildFlourishPoint',[g_sExceptionVer]));
end;
end;

procedure TNormNpc.ActionOfGuildstabilityPoint(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nStabilityPoint: Integer;
  cMethod: Char;
  Guild: TGUild;
begin
try
  //nStabilityPoint := Str_ToInt(QuestActionInfo.sParam2, -1);
  nStabilityPoint := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);//20080501
  if nStabilityPoint < 0 then begin
    if not GetValValue(PlayObject, QuestActionInfo.sParam2, nStabilityPoint) then begin //增加变量支持
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_STABILITYPOINT);
      Exit;
    end;
  end;
  if PlayObject.m_MyGuild = nil then begin
    PlayObject.SysMsg(g_sScriptGuildStabilityPointNoGuild, c_Red, t_Hint);
    Exit;
  end;
  Guild := TGUild(PlayObject.m_MyGuild);

  cMethod := QuestActionInfo.sParam1[1];
  case cMethod of
    '=': begin
        Guild.nStability := nStabilityPoint;
      end;
    '-': begin
        if Guild.nStability >= nStabilityPoint then begin
          Guild.nStability := Guild.nStability - nStabilityPoint;
        end else begin
          Guild.nStability := 0;
        end;
      end;
    '+': begin
        if (High(Integer) - Guild.nStability) >= nStabilityPoint then begin
          Guild.nStability := Guild.nStability + nStabilityPoint;
        end else begin
          Guild.nStability := High(Integer);
        end;
      end;
  end;
  if g_Config.boShowScriptActionMsg then begin
    PlayObject.SysMsg(Format(g_sScriptGuildStabilityPointMsg, [Guild.nStability]), c_Green, t_Hint);
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfGuildstabilityPoint',[g_sExceptionVer]));
end;
end;
//功能：恢复人物的生命点数
//格式: HumanHP 操作符(+ = -) 数值(0-65535) Hero 是否提示(0/1)
procedure TNormNpc.ActionOfHumanHP(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nHP: Integer;
  cMethod: Char;
  nType: Byte;
begin
  try
    nHP := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);
    if nHP < 0 then begin
      if not GetValValue(PlayObject, QuestActionInfo.sParam2, nHP) then begin //增加变量支持
        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_HUMANHP);
        Exit;
      end;
    end;
    nType:= Str_ToInt(QuestActionInfo.sParam4, 0);
    cMethod := QuestActionInfo.sParam1[1];
    if CompareText(QuestActionInfo.sParam3, 'HERO') = 0 then begin
      {$IF HEROVERSION = 1}
      if PlayObject.m_MyHero <> nil then begin
        case cMethod of
          '=': begin
              PlayObject.m_MyHero.m_WAbil.HP := nHP;
            end;
          '-': begin
              if PlayObject.m_MyHero.m_WAbil.HP >= nHP then begin
                Dec(PlayObject.m_MyHero.m_WAbil.HP, nHP);
              end else begin
                PlayObject.m_MyHero.m_WAbil.HP := 0;
              end;
            end;
          '+': begin
              if PlayObject.m_MyHero.m_WAbil.HP >= nHP then begin//防止越界
                if (High(Integer) - PlayObject.m_MyHero.m_WAbil.HP) < nHP then begin
                  nHP := High(Integer) - PlayObject.m_MyHero.m_WAbil.HP;
                end;
              end else begin
                if (High(Integer) - nHP) < PlayObject.m_MyHero.m_WAbil.HP then begin
                  nHP := High(Integer) - nHP;
                end;
              end;
              Inc(PlayObject.m_MyHero.m_WAbil.HP, nHP);
              if PlayObject.m_MyHero.m_WAbil.HP > PlayObject.m_MyHero.m_WAbil.MaxHP then PlayObject.m_MyHero.m_WAbil.HP := PlayObject.m_MyHero.m_WAbil.MaxHP;
            end;
        end;
        if (not THeroObject(PlayObject.m_MyHero).m_boAI) then begin
          PlayObject.m_MyHero.HealthSpellChanged();
          if g_Config.boShowScriptActionMsg and (nType=0) then begin
            THeroObject(PlayObject.m_MyHero).SysMsg(Format('(英雄)' +g_sScriptChangeHumanHPMsg, [PlayObject.m_MyHero.m_WAbil.HP]), c_Green, t_Hint);
          end;
        end;
      end;
      {$IFEND}
    end else begin
      case cMethod of
        '=': begin
            PlayObject.m_WAbil.HP := nHP;
          end;
        '-': begin
            if PlayObject.m_WAbil.HP >= nHP then begin
              Dec(PlayObject.m_WAbil.HP, nHP);
            end else begin
              PlayObject.m_WAbil.HP := 0;
            end;
          end;
        '+': begin
            if PlayObject.m_WAbil.HP >= nHP then begin//防止越界
              if (High(Integer) - PlayObject.m_WAbil.HP) < nHP then begin
                nHP := High(Integer) - PlayObject.m_WAbil.HP;
              end;
            end else begin
              if (High(Integer) - nHP) < PlayObject.m_WAbil.HP then begin
                nHP := High(Integer) - nHP;
              end;
            end;
            Inc(PlayObject.m_WAbil.HP, nHP);
            if PlayObject.m_WAbil.HP > PlayObject.m_WAbil.MaxHP then PlayObject.m_WAbil.HP := PlayObject.m_WAbil.MaxHP;
          end;
      end;
      if (not PlayObject.m_boAI) then begin
        PlayObject.HealthSpellChanged();
        if g_Config.boShowScriptActionMsg and (nType=0) then begin
          PlayObject.SysMsg(Format(g_sScriptChangeHumanHPMsg, [PlayObject.m_WAbil.HP]), c_Green, t_Hint);
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfHumanHP',[g_sExceptionVer]));
  end;
end;
//功能：恢复人物的魔法点数
//格式：HumanMP 操作符(+ = -) 数值(0-65535) hero 是否提示(0/1)
procedure TNormNpc.ActionOfHumanMP(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nMP: Integer;
  cMethod: Char;
  nType: Byte;
begin
  try
    nMP := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);//20080501
    if nMP < 0 then begin
      if not GetValValue(PlayObject, QuestActionInfo.sParam2, nMP) then begin //增加变量支持
        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_HUMANMP);
        Exit;
      end;
    end;
    nType:= Str_ToInt(QuestActionInfo.sParam4, 0);
    cMethod := QuestActionInfo.sParam1[1];
    if CompareText(QuestActionInfo.sParam3, 'HERO') = 0 then begin
      {$IF HEROVERSION = 1}
      if PlayObject.m_MyHero <> nil then begin
        case cMethod of
          '=': begin
              PlayObject.m_MyHero.m_WAbil.MP := nMP;
            end;
          '-': begin
              if PlayObject.m_MyHero.m_WAbil.MP >= nMP then begin
                Dec(PlayObject.m_MyHero.m_WAbil.MP, nMP);
              end else begin
                PlayObject.m_MyHero.m_WAbil.MP := 0;
              end;
            end;
          '+': begin
              Inc(PlayObject.m_MyHero.m_WAbil.MP, nMP);
              if PlayObject.m_MyHero.m_WAbil.MP > PlayObject.m_MyHero.m_WAbil.MaxMP then PlayObject.m_MyHero.m_WAbil.MP := PlayObject.m_WAbil.MaxMP;
            end;
        end;
        if (not THeroObject(PlayObject.m_MyHero).m_boAI) then begin
          PlayObject.m_MyHero.HealthSpellChanged();//20090426 增加，
          if g_Config.boShowScriptActionMsg and (nType=0) then begin
            THeroObject(PlayObject.m_MyHero).SysMsg(Format('(英雄)' +g_sScriptChangeHumanMPMsg, [PlayObject.m_MyHero.m_WAbil.MP]), c_Green, t_Hint);
          end;
        end;
      end;
      {$IFEND}
    end else begin
      case cMethod of
        '=': begin
            PlayObject.m_WAbil.MP := nMP;
          end;
        '-': begin
            if PlayObject.m_WAbil.MP >= nMP then begin
              Dec(PlayObject.m_WAbil.MP, nMP);
            end else begin
              PlayObject.m_WAbil.MP := 0;
            end;
          end;
        '+': begin
            Inc(PlayObject.m_WAbil.MP, nMP);
            if PlayObject.m_WAbil.MP > PlayObject.m_WAbil.MaxMP then PlayObject.m_WAbil.MP := PlayObject.m_WAbil.MaxMP;
          end;
      end;
      if (not PlayObject.m_boAI) then begin
        PlayObject.HealthSpellChanged();//20090426 增加，
        if g_Config.boShowScriptActionMsg and (nType=0) then begin
          PlayObject.SysMsg(Format(g_sScriptChangeHumanMPMsg, [PlayObject.m_WAbil.MP]), c_Green, t_Hint);
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfHumanMP',[g_sExceptionVer]));
  end;
end;
//功能:永久增加人物属性点。
//格式:USEBONUSPOINT 属性位置（1-9） 控制符（+,-,=） 点数 Hero
//扩展属性位置10-14 :10-防御上限 11-防御下限 12-魔御上限 13-魔御上限 14-吸收伤害
procedure TNormNpc.ActionOfUseBonusPoint(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nPosition, nCount: Integer;
  cMethod: Char;
begin
  try
    nPosition := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam1),-1);//20080501
    cMethod := QuestActionInfo.sParam2[1];
    nCount := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam3),-1);//20080501
    if (nPosition < 0) or (nCount < 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_USEBONUSPOINT);
      Exit;
    end;

    if CompareText(QuestActionInfo.sParam4, 'HERO') = 0 then begin
      if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then begin
        //ScriptActionError(PlayObject, '', QuestActionInfo, sSC_USEBONUSPOINT);
        Exit;
      end;
      if PlayObject.m_MyHero <> nil then begin
        case cMethod of
          '+': begin
              case nPosition of
                1: Inc(PlayObject.m_MyHero.m_BonusAbil.DC, nCount);
                2: Inc(PlayObject.m_MyHero.m_BonusAbil.MC, nCount);
                3: Inc(PlayObject.m_MyHero.m_BonusAbil.SC, nCount);
                4: Inc(PlayObject.m_MyHero.m_BonusAbil.AC, nCount);
                5: Inc(PlayObject.m_MyHero.m_BonusAbil.MAC, nCount);
                6: Inc(PlayObject.m_MyHero.m_BonusAbil.HP, nCount);
                7: Inc(PlayObject.m_MyHero.m_BonusAbil.MP, nCount);
                8: Inc(PlayObject.m_MyHero.m_BonusAbil.Hit, nCount);
                9: Inc(PlayObject.m_MyHero.m_BonusAbil.Speed, nCount);
                10: Inc(THeroObject(PlayObject.m_MyHero).m_PulseAddAC, nCount);//防御上限
                11: Inc(THeroObject(PlayObject.m_MyHero).m_PulseAddAC1, nCount);//防御下限
                12: Inc(THeroObject(PlayObject.m_MyHero).m_PulseAddMAC, nCount);//魔御上限
                13: Inc(THeroObject(PlayObject.m_MyHero).m_PulseAddMAC1, nCount);//魔御下限
                14: Inc(PlayObject.m_MyHero.m_nDecDamage, nCount);//吸收伤害
              end;
            end;
          '-': begin
              case nPosition of
                1: begin
                  if PlayObject.m_MyHero.m_BonusAbil.DC >= nCount then begin//20090424 修改
                    Dec(PlayObject.m_MyHero.m_BonusAbil.DC, nCount);
                  end else PlayObject.m_MyHero.m_BonusAbil.DC:= 0;
                end;
                2: begin
                  if PlayObject.m_MyHero.m_BonusAbil.MC >= nCount then begin//20090424 修改
                    Dec(PlayObject.m_MyHero.m_BonusAbil.MC, nCount);
                  end else PlayObject.m_MyHero.m_BonusAbil.MC:= 0;
                end;
                3: begin
                  if PlayObject.m_MyHero.m_BonusAbil.SC >= nCount then begin//20090424 修改
                    Dec(PlayObject.m_MyHero.m_BonusAbil.SC, nCount);
                  end else PlayObject.m_MyHero.m_BonusAbil.SC:= 0;
                end;
                4: begin
                  if PlayObject.m_MyHero.m_BonusAbil.AC >= nCount then begin//20090424 修改
                    Dec(PlayObject.m_MyHero.m_BonusAbil.AC, nCount);
                  end else PlayObject.m_MyHero.m_BonusAbil.AC:= 0;
                end;
                5: begin
                  if PlayObject.m_MyHero.m_BonusAbil.MAC >= nCount then begin//20090424 修改
                    Dec(PlayObject.m_MyHero.m_BonusAbil.MAC, nCount);
                  end else PlayObject.m_MyHero.m_BonusAbil.MAC:= 0;
                end;
                6: begin
                  if PlayObject.m_MyHero.m_BonusAbil.HP >= nCount then begin//20090424 修改
                    Dec(PlayObject.m_MyHero.m_BonusAbil.HP, nCount);
                  end else PlayObject.m_MyHero.m_BonusAbil.HP:= 0;
                end;
                7: begin
                  if PlayObject.m_MyHero.m_BonusAbil.MP >= nCount then begin//20090424 修改
                    Dec(PlayObject.m_MyHero.m_BonusAbil.MP, nCount);
                  end else PlayObject.m_MyHero.m_BonusAbil.MP:= 0;
                end;
                8: begin
                  if PlayObject.m_MyHero.m_BonusAbil.Hit >= nCount then begin//20090424 修改
                    Dec(PlayObject.m_MyHero.m_BonusAbil.Hit, nCount);
                  end else PlayObject.m_MyHero.m_BonusAbil.Hit:= 0;
                end;
                9: begin
                  if PlayObject.m_MyHero.m_BonusAbil.Speed >= nCount then begin//20090424 修改
                    Dec(PlayObject.m_MyHero.m_BonusAbil.Speed, nCount);
                  end else PlayObject.m_MyHero.m_BonusAbil.Speed:= 0;
                end;
                10: begin
                  if THeroObject(PlayObject.m_MyHero).m_PulseAddAC >= nCount then begin
                    Dec(THeroObject(PlayObject.m_MyHero).m_PulseAddAC, nCount);//防御上限
                  end else THeroObject(PlayObject.m_MyHero).m_PulseAddAC:= 0;
                end;
                11: begin
                  if THeroObject(PlayObject.m_MyHero).m_PulseAddAC1 >= nCount then begin
                    Dec(THeroObject(PlayObject.m_MyHero).m_PulseAddAC1, nCount);//防御下限
                  end else THeroObject(PlayObject.m_MyHero).m_PulseAddAC1:= 0;
                end;
                12: begin
                  if THeroObject(PlayObject.m_MyHero).m_PulseAddMAC >= nCount then begin
                    Dec(THeroObject(PlayObject.m_MyHero).m_PulseAddMAC, nCount);//魔御上限
                  end else THeroObject(PlayObject.m_MyHero).m_PulseAddMAC:= 0;
                end;
                13: begin
                  if THeroObject(PlayObject.m_MyHero).m_PulseAddMAC1 >= nCount then begin
                    Dec(THeroObject(PlayObject.m_MyHero).m_PulseAddMAC1, nCount);//魔御下限
                  end else THeroObject(PlayObject.m_MyHero).m_PulseAddMAC1:= 0;
                end;
                14: begin
                  if PlayObject.m_MyHero.m_nDecDamage >= nCount then begin
                    Dec(PlayObject.m_MyHero.m_nDecDamage, nCount);//吸收伤害
                  end else PlayObject.m_MyHero.m_nDecDamage:= 0;
                end;
              end;
            end;
          '=': begin
              case nPosition of
                1: PlayObject.m_MyHero.m_BonusAbil.DC := nCount;
                2: PlayObject.m_MyHero.m_BonusAbil.MC := nCount;
                3: PlayObject.m_MyHero.m_BonusAbil.SC := nCount;
                4: PlayObject.m_MyHero.m_BonusAbil.AC := nCount;
                5: PlayObject.m_MyHero.m_BonusAbil.MAC := nCount;
                6: PlayObject.m_MyHero.m_BonusAbil.HP := nCount;
                7: PlayObject.m_MyHero.m_BonusAbil.MP := nCount;
                8: PlayObject.m_MyHero.m_BonusAbil.Hit := nCount;
                9: PlayObject.m_MyHero.m_BonusAbil.Speed := nCount;
                10: THeroObject(PlayObject.m_MyHero).m_PulseAddAC := nCount;//防御上限
                11: THeroObject(PlayObject.m_MyHero).m_PulseAddAC1 := nCount;//防御下限
                12: THeroObject(PlayObject.m_MyHero).m_PulseAddMAC := nCount;//魔御上限
                13: THeroObject(PlayObject.m_MyHero).m_PulseAddMAC1 := nCount;//魔御下限
                14: PlayObject.m_MyHero.m_nDecDamage := nCount;//吸收伤害
              end;
            end;
        end;//case
        THeroObject(PlayObject.m_MyHero).RecalcAbilitys();//20081213
        PlayObject.m_MyHero.CompareSuitItem(False);//套装
        THeroObject(PlayObject.m_MyHero).SendMsg({PlayObject}PlayObject.m_MyHero, RM_HEROABILITY, 0, 0, 0, 0, ''); //发送英雄属性  20090107修改
        THeroObject(PlayObject.m_MyHero).SendMsg({PlayObject}PlayObject.m_MyHero, RM_SUBABILITY, 0, 0, 0, 0, '');//20090107修改
      end;   
    end else begin
      case cMethod of
        '+': begin
            case nPosition of
              1: Inc(PlayObject.m_BonusAbil.DC, nCount);
              2: Inc(PlayObject.m_BonusAbil.MC, nCount);
              3: Inc(PlayObject.m_BonusAbil.SC, nCount);
              4: Inc(PlayObject.m_BonusAbil.AC, nCount);
              5: Inc(PlayObject.m_BonusAbil.MAC, nCount);
              6: Inc(PlayObject.m_BonusAbil.HP, nCount);
              7: Inc(PlayObject.m_BonusAbil.MP, nCount);
              8: Inc(PlayObject.m_BonusAbil.Hit, nCount);
              9: Inc(PlayObject.m_BonusAbil.Speed, nCount);
              10: Inc(PlayObject.m_PulseAddAC, nCount);
              11: Inc(PlayObject.m_PulseAddAC1, nCount);
              12: Inc(PlayObject.m_PulseAddMAC, nCount);
              13: Inc(PlayObject.m_PulseAddMAC1, nCount);
              14: Inc(PlayObject.m_nDecDamage, nCount);//吸收伤害
            end;
          end;
        '-': begin
            case nPosition of
              1: begin
                if PlayObject.m_BonusAbil.DC >= nCount then begin//20090424 修改
                  Dec(PlayObject.m_BonusAbil.DC, nCount);
                end else PlayObject.m_BonusAbil.DC:= 0;
              end;
              2: begin
                if PlayObject.m_BonusAbil.MC >= nCount then begin//20090424 修改
                  Dec(PlayObject.m_BonusAbil.MC, nCount);
                end else PlayObject.m_BonusAbil.MC:= 0;
              end;
              3: begin
                if PlayObject.m_BonusAbil.SC >= nCount then begin//20090424 修改
                  Dec(PlayObject.m_BonusAbil.SC, nCount);
                end else PlayObject.m_BonusAbil.SC:= 0;
              end;
              4: begin
                if PlayObject.m_BonusAbil.AC >= nCount then begin//20090424 修改
                  Dec(PlayObject.m_BonusAbil.AC, nCount);
                end else PlayObject.m_BonusAbil.AC:= 0;
              end;
              5: begin
                if PlayObject.m_BonusAbil.MAC >= nCount then begin//20090424 修改
                  Dec(PlayObject.m_BonusAbil.MAC, nCount);
                end else PlayObject.m_BonusAbil.MAC:= 0;
              end;
              6: begin
                if PlayObject.m_BonusAbil.HP >= nCount then begin//20090424 修改
                  Dec(PlayObject.m_BonusAbil.HP, nCount);
                end else PlayObject.m_BonusAbil.HP:= 0;
              end;
              7: begin
                if PlayObject.m_BonusAbil.MP >= nCount then begin//20090424 修改
                  Dec(PlayObject.m_BonusAbil.MP, nCount);
                end else PlayObject.m_BonusAbil.MP:= 0;
              end;
              8: begin
                if PlayObject.m_BonusAbil.Hit >= nCount then begin//20090424 修改
                  Dec(PlayObject.m_BonusAbil.Hit, nCount);
                end else PlayObject.m_BonusAbil.Hit:= 0;
              end;
              9: begin
                if PlayObject.m_BonusAbil.Speed >= nCount then begin//20090424 修改
                  Dec(PlayObject.m_BonusAbil.Speed, nCount);
                end else PlayObject.m_BonusAbil.Speed:= 0;
              end;
              10: begin
                if PlayObject.m_PulseAddAC >= nCount then begin
                  Dec(PlayObject.m_PulseAddAC, nCount);//防御上限
                end else PlayObject.m_PulseAddAC:= 0;
              end;
              11: begin
                if PlayObject.m_PulseAddAC1 >= nCount then begin
                  Dec(PlayObject.m_PulseAddAC1, nCount);//防御下限
                end else PlayObject.m_PulseAddAC1:= 0;
              end;
              12: begin
                if PlayObject.m_PulseAddMAC >= nCount then begin
                  Dec(PlayObject.m_PulseAddMAC, nCount);//魔御上限
                end else PlayObject.m_PulseAddMAC:= 0;
              end;
              13: begin
                if PlayObject.m_PulseAddMAC1 >= nCount then begin
                  Dec(PlayObject.m_PulseAddMAC1, nCount);//魔御下限
                end else PlayObject.m_PulseAddMAC1:= 0;
              end;
              14: begin
                if PlayObject.m_nDecDamage >= nCount then begin
                  Dec(PlayObject.m_nDecDamage, nCount);//吸收伤害
                end else PlayObject.m_nDecDamage:= 0;
              end;
            end;
          end;
        '=': begin
            case nPosition of
              1: PlayObject.m_BonusAbil.DC := nCount;
              2: PlayObject.m_BonusAbil.MC := nCount;
              3: PlayObject.m_BonusAbil.SC := nCount;
              4: PlayObject.m_BonusAbil.AC := nCount;
              5: PlayObject.m_BonusAbil.MAC := nCount;
              6: PlayObject.m_BonusAbil.HP := nCount;
              7: PlayObject.m_BonusAbil.MP := nCount;
              8: PlayObject.m_BonusAbil.Hit := nCount;
              9: PlayObject.m_BonusAbil.Speed := nCount;
              10: PlayObject.m_PulseAddAC := nCount;
              11: PlayObject.m_PulseAddAC1 := nCount;
              12: PlayObject.m_PulseAddMAC := nCount;
              13: PlayObject.m_PulseAddMAC1 := nCount;
              14: PlayObject.m_nDecDamage := nCount;//吸收伤害
            end;
          end;
      end;
      PlayObject.RecalcAbilitys();
      PlayObject.CompareSuitItem(False);//200080729 套装
      PlayObject.SendMsg(PlayObject, RM_ABILITY, 0, 0, 0, 0, '');
      PlayObject.SendMsg(PlayObject, RM_SUBABILITY, 0, 0, 0, 0, '');
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfUseBonusPoint',[g_sExceptionVer]));
  end;
end;

procedure TNormNpc.ActionOfKick(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
begin
try
  PlayObject.m_boKickFlag := True;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfKick',[g_sExceptionVer]));
end;
end;

procedure TNormNpc.ActionOfKill(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nMode: Integer;
begin
try
  nMode := Str_ToInt(QuestActionInfo.sParam1, -1);
  if nMode in [0..3] then begin
    case nMode of //
      1: begin
          PlayObject.m_boNoItem := True;
          PlayObject.Die;
        end;
      2: begin
          PlayObject.SetLastHiter(Self);
          PlayObject.Die;
        end;
      3: begin
          PlayObject.m_boNoItem := True;
          PlayObject.SetLastHiter(Self);
          PlayObject.Die;
        end;
    else begin
        PlayObject.Die;
      end;
    end;
  end else begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_KILL);
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfKill',[g_sExceptionVer]));
end;
end;

procedure TNormNpc.ActionOfBonusPoint(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nBonusPoint: Integer;
  cMethod: Char;
begin
  try
    nBonusPoint := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);
    if nBonusPoint < 0 then begin
      GetValValue(PlayObject, QuestActionInfo.sParam2, nBonusPoint); //增加变量支持
    end;
    if (nBonusPoint < 0) or (nBonusPoint > 10000) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_BONUSPOINT);
      Exit;
    end;

    cMethod := QuestActionInfo.sParam1[1];
    case cMethod of
      '=': begin
          FillChar(PlayObject.m_BonusAbil, SizeOf(TNakedAbility), #0);
          PlayObject.HasLevelUp(0);
          PlayObject.m_nBonusPoint := nBonusPoint;
          PlayObject.SendMsg(PlayObject, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
        end;
      '-': begin
          if PlayObject.m_nBonusPoint >= nBonusPoint then begin
            Dec(PlayObject.m_nBonusPoint, nBonusPoint);
          end else begin
            PlayObject.m_nBonusPoint := 0;
          end;
          PlayObject.SendMsg(PlayObject, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
        end;
      '+': begin
          Inc(PlayObject.m_nBonusPoint, nBonusPoint);
          PlayObject.SendMsg(PlayObject, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
        end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfBonusPoint',[g_sExceptionVer]));
  end;
end;

procedure TNormNpc.ActionOfDelMarry(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
begin
  try
    PlayObject.m_sDearName := '';
    PlayObject.RefShowName;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfDelMarry',[g_sExceptionVer]));
  end;
end;

procedure TNormNpc.ActionOfDelMaster(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
begin
  try
    PlayObject.m_sMasterName := '';
    PlayObject.RefShowName;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfDelMaster',[g_sExceptionVer]));
  end;
end;
//功能：删除徒弟 20090208
//格式：DELAPPRENTICE 徒弟名
procedure TNormNpc.ActionOfDELAPPRENTICE(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  PoseHuman: TPlayObject;
  sMsg, sName: string;  
begin
  try
    if not PlayObject.m_boMaster then begin//检查是否有徒弟
      GotoLable(PlayObject, '@NoApprentice', False, False);//没有徒弟
      Exit;
    end;
    if (QuestActionInfo.sParam1 <> '') then begin//徒弟名
      sName:= GetLineVariableText(PlayObject,QuestActionInfo.sParam1);
      if PlayObject.IsMyApprentice(sName) then begin//检查输入的名字是否为自己的徒弟
        PoseHuman := UserEngine.GetPlayObject(sName);//检查徒弟是否在线
        if PoseHuman <> nil then begin
          PoseHuman.m_sMasterName := '';
          PlayObject.DelMaster(sName);//出师
          //if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(PoseHuman, '@UnMasterEnd', False);
          sMsg := AnsiReplaceText(g_sNPCSayForceUnMasterMsg, '%n', m_sCharName);
          sMsg := AnsiReplaceText(sMsg, '%s', PlayObject.m_sCharName);
          sMsg := AnsiReplaceText(sMsg, '%d', sName);
          UserEngine.SendBroadCastMsg(sMsg, t_Say);
          //if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(PoseHuman, '@UnMasterEnd1', False);//徒弟触发 20080530
          PoseHuman.RefShowName;
        end else begin
          PlayObject.DelMaster(sName);//出师
          g_UnForceMasterList.Lock;
          try
            g_UnForceMasterList.Add(sName+' '+PlayObject.m_sCharName);
            SaveUnForceMasterList();
          finally
            g_UnForceMasterList.UnLock;
          end;
        end;
        GotoLable(PlayObject, '@DelApprenticeEnd', False, False);//删除徒弟结束
      end else begin
        GotoLable(PlayObject, '@DelApprenticeFail', False, False);//不是自己的徒弟
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfDELAPPRENTICE',[g_sExceptionVer]));
  end;
end;
//功能：一定时间内高等级杀怪经验不变
//格式：HIGHLEVELKILLMONFIXEXP 时间(秒)
procedure TNormNpc.ActionOfHIGHLEVELKILLMONFIXEXP(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nTime: Integer;
  dwInt: LongWord;
begin
  try
    nTime:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam1), -1);//时间(秒)
    if (nTime < 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_HIGHLEVELKILLMONFIXEXP);
      Exit;
    end;
    if PlayObject.m_dwHighLevelKillMonFixExpTime >= LongWord(nTime) then begin//20090408 增加，防止越界
      if (High(PlayObject.m_dwHighLevelKillMonFixExpTime) - PlayObject.m_dwHighLevelKillMonFixExpTime) < LongWord(nTime) then begin
        nTime := High(PlayObject.m_dwHighLevelKillMonFixExpTime) - PlayObject.m_dwHighLevelKillMonFixExpTime;
      end;
    end else begin
      if (High(PlayObject.m_dwHighLevelKillMonFixExpTime) - nTime) < PlayObject.m_dwHighLevelKillMonFixExpTime then begin
        nTime := High(PlayObject.m_dwHighLevelKillMonFixExpTime) - nTime;
      end;
    end;

    dwInt:= PlayObject.m_dwHighLevelKillMonFixExpTime + LongWord(nTime);//20090330
    if dwInt > 0 then begin
      PlayObject.m_dwHighLevelKillMonFixExpTime := dwInt;
      if PlayObject.m_dwHighLevelKillMonFixExpTime > 0 then begin
        PlayObject.m_boHighLevelKillMonFixExp:= True;//高等级杀怪经验不变 20090213
        if g_Config.boShowScriptActionMsg then begin
          PlayObject.SysMsg(Format_ToStr(g_sHighLevelKillMonFixExpMsg, [PlayObject.m_dwHighLevelKillMonFixExpTime]), c_Green, t_Hint);
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfHIGHLEVELKILLMONFIXEXP',[g_sExceptionVer]));
  end;
end;
//功能：改变发言时文字颜色 20090221
//格式：CHANGHEARMSGCOLOR 时间(秒) 类型(1-3)
//参数: 1-玄绿 2-玄紫 3-玄褐
procedure TNormNpc.ActionOfChangHearMsgColor(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nTime: Integer;
  nType: Byte;
begin
  Try
    nTime:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam1), -1);//时间(秒)
    nType:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2), 0);//类型
    if (nTime < 0) or (nType > 3) or (nType <= 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_ChangHearMsgColor);
      Exit;
    end;
    PlayObject.m_dwUseItmeChangMsgFColorTime := nTime;//使用物品改变说话颜色的使用时间(秒) 玄绿,玄紫,玄褐 20090221
    if PlayObject.m_dwUseItmeChangMsgFColorTime > 0 then begin
      PlayObject.m_dwUseItmeChangMsgFColorType:= nType;//颜色类型
      PlayObject.SysMsg(Format_ToStr(g_sChangHearMsgColorMsg, [PlayObject.m_dwUseItmeChangMsgFColorTime]), c_Green, t_Hint);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfChangHearMsgColor',[g_sExceptionVer]));
  end;
end;

//格式: SETOFFTIMER 定时器索引(0-24)
//说明: 停止指定的定时器
//增加: 索引为负数则停止所有定时器
procedure TNormNpc.ActionOfSetOffTimer(PlayObject: TPlayObject; QuestActionInfo:
  pTQuestActionInfo);
var
  nIdx: Integer;
  I: Integer;
  OnTimer: pTOnTimer;
begin
  try
    nIdx := Str_ToInt(QuestActionInfo.sParam1, -2);
    if (nIdx < -1) or (nIdx > 24) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSETOFFTIMER);
      exit;
    end;
    for I := PlayObject.m_OnTimerList.Count - 1 downto 0 do begin
      if PlayObject.m_OnTimerList.Count <= 0 then Break;
      OnTimer := PlayObject.m_OnTimerList.Items[I];
      if (nIdx = -1) or (OnTimer.nIdx = nIdx) then begin
        Dispose(OnTimer);
        PlayObject.m_OnTimerList.Delete(I);
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfSetOffTimer',[g_sExceptionVer]));
  end;
end;
//格式: SETONTIMER 定时器索引(0-24) 定时间隔（单位为秒） 循环次数(可为空，当不为空时，循环指定次数后退出)
//说明: 定时器脚本位于QManage.txt里,定时器对应的为[@OnTimer0] [@OnTimer1] [@OnTimer2] ... [@OnTimer19]
procedure TNormNpc.ActionOfSetOnTimer(PlayObject: TPlayObject; QuestActionInfo:
  pTQuestActionInfo);
var
  nTimer: LongWord;
  nIdx, nCount: Integer;
  I: integer;
  OnTimer: pTOnTimer;
begin
  try
    nIdx := Str_ToInt(QuestActionInfo.sParam1, -1);
    nTimer := Str_ToInt(QuestActionInfo.sParam2, -1);
    nCount := Str_ToInt(QuestActionInfo.sParam3, 0);
    if (nIdx < 0) or (nIdx > 24) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSetOnTimer);
      Exit;
    end;
    for I := PlayObject.m_OnTimerList.Count - 1 downto 0 do begin
      OnTimer := PlayObject.m_OnTimerList.Items[I];
      if OnTimer.nIdx = nIdx then begin
        OnTimer.RunCount := nCount;
        OnTimer.Interval := nTimer * 1000;
        OnTimer.NextTimer := GetTickCount + OnTimer.Interval;
        Exit;
      end;
    end;
    New(OnTimer);
    OnTimer.nIdx := nIdx;
    OnTimer.RunCount := nCount;
    OnTimer.Interval := nTimer * 1000;
    OnTimer.NextTimer := GetTickCount + OnTimer.Interval;
    PlayObject.m_OnTimerList.Add(OnTimer);
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfSetOnTimer',[g_sExceptionVer]));
  end;
end;

//功能：收回指定名称物品(按数量，持久) 20090912
//格式：TAKEITMECOUNTDURA 物品名称 数量 操作符(<>=) 持久(MaxDura--物品的持久上限)
procedure TNormNpc.ActionOfTakeItmeCountDura(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  sItemName: String;
  nDura, nCount, I: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  boMaxDura, boIsOKItme: Boolean;
  cMethod: Char;
begin
  boMaxDura:= False;
  boIsOKItme:= False;
  try
    sItemName:=GetLineVariableText(PlayObject, QuestActionInfo.sParam1); //物品名称
    nCount:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);//数量
    if CompareText(QuestActionInfo.sParam4, 'MaxDura') = 0 then boMaxDura:= True
    else nDura := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam4),-1);//持久
    if (sItemName='') or (nCount < 0) or (nDura < 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_TAKEITMECOUNTDURA);
      Exit;
    end;
    cMethod := QuestActionInfo.sParam3[1];
    PlayObject.m_boCanQueryBag:= True;//NPC操作物品时,不能刷新包裹
    try
      for I := PlayObject.m_ItemList.Count - 1 downto 0 do begin
        if (nCount <= 0) or (PlayObject.m_ItemList.Count <= 0) then Break;
        UserItem := PlayObject.m_ItemList.Items[I];
        if UserItem = nil then Continue;
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        boIsOKItme:= False;
        if StdItem <> nil then begin
          if CompareText(StdItem.Name, sItemName) = 0 then begin
            if boMaxDura then begin
              case cMethod of
                '=': if UserItem.Dura = UserItem.DuraMax then boIsOKItme:= True;
                '>': if UserItem.Dura > UserItem.DuraMax then boIsOKItme:= True;
                '<': if UserItem.Dura < UserItem.DuraMax then boIsOKItme:= True;
              end;
            end else begin
              case cMethod of
                '=': if UserItem.Dura = nDura then boIsOKItme:= True;
                '>': if UserItem.Dura > nDura then boIsOKItme:= True;
                '<': if UserItem.Dura < nDura then boIsOKItme:= True;
              end;
            end;
            if boIsOKItme then begin
              if StdItem.NeedIdentify = 1 then
                AddGameDataLog('10' + #9 + PlayObject.m_sMapName + #9 +
                  IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                  PlayObject.m_sCharName + #9 + sItemName + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                  '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                  '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                  '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                  '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                  '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                  IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                  IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                  IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                  IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
              PlayObject.m_ItemList.Delete(I);
              PlayObject.SendDelItems(UserItem);
              //DisPoseAndNil(UserItem);
              DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 By TasNat at: 2012-03-17
              UserItem := nil;
              Dec(nCount);
            end;
          end;
        end;//if StdItem <> nil
      end;
    finally
      PlayObject.m_boCanQueryBag:= False;//NPC操作物品时,不能刷新包裹
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfTakeItmeCountDura',[g_sExceptionVer]));
  end;
end;

//功能：收回指定名称的矿名(按数量，纯度) 20090330
//格式：TAKEMINE 矿名称 数量 操作符(<>=) 纯度
procedure TNormNpc.ActionOfTAKEMINE(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  sMineName: String;
  nMineCount, nDura, nCount, I: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  cMethod: Char;
begin
  try
    nCount:= 0;
    sMineName:=GetLineVariableText(PlayObject, QuestActionInfo.sParam1); //矿石名
    nMineCount := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);//数量 20080501
    nDura := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam4),-1); //纯度20080501
    if nMineCount < 0 then begin
      if not GetValValue(PlayObject, QuestActionInfo.sParam2, nMineCount) then begin //增加变量支持
        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_TAKEMINE);
        Exit;
      end;
    end;
    if nDura < 0 then begin
      if not GetValValue(PlayObject, QuestActionInfo.sParam4, nDura) then begin //增加变量支持
        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_TAKEMINE);
        Exit;
      end;
    end;

    if (sMineName='') or (nMineCount < 0) or (nDura < 0) or (nDura > 100) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_TAKEMINE);
      Exit;
    end;
    cMethod := QuestActionInfo.sParam3[1];
    PlayObject.m_boCanQueryBag:= True;//NPC操作物品时,不能刷新包裹 20080917
    Try
      for I := PlayObject.m_ItemList.Count - 1 downto 0 do begin
        if nMineCount <= 0 then Break;
        if PlayObject.m_ItemList.Count <= 0 then Break;
        UserItem := PlayObject.m_ItemList.Items[I];
        if UserItem = nil then Continue;
        if CompareText(UserEngine.GetStdItemName(UserItem.wIndex), sMineName) = 0 then begin
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem <> nil then begin
            if (StdItem.StdMode = 43) then begin
              case cMethod of
                '=': if UserItem.Dura = nDura * 1000 then begin
                        if StdItem.NeedIdentify = 1 then
                          AddGameDataLog('10' + #9 + PlayObject.m_sMapName + #9 +
                            IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                            PlayObject.m_sCharName + #9 + sMineName + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                            '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                            '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                            '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                            '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                            '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                            IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                            IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                            IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                            IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                        PlayObject.m_ItemList.Delete(I);
                        PlayObject.SendDelItems(UserItem);
                        //DisPoseAndNil(UserItem);
                        DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 By TasNat at: 2012-03-17
                        UserItem := nil;
                        Dec(nMineCount);
                     end;
                '>': if UserItem.Dura > nDura * 1000 then begin
                        if StdItem.NeedIdentify = 1 then
                          AddGameDataLog('10' + #9 + PlayObject.m_sMapName + #9 +
                            IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                            PlayObject.m_sCharName + #9 + sMineName + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                            '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                            '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                            '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                            '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                            '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                            IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                            IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                            IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                            IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                        PlayObject.m_ItemList.Delete(I);
                        PlayObject.SendDelItems(UserItem);
                        //DisPoseAndNil(UserItem);
                        DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 By TasNat at: 2012-03-17
                        UserItem := nil;
                        Dec(nMineCount);
                     end;
                '<': if UserItem.Dura < nDura * 1000 then begin
                        if StdItem.NeedIdentify = 1 then
                          AddGameDataLog('10' + #9 + PlayObject.m_sMapName + #9 +
                            IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                            PlayObject.m_sCharName + #9 + sMineName + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                            '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                            '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                            '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                            '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                            '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                            IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                            IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                            IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                            IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                        PlayObject.m_ItemList.Delete(I);
                        PlayObject.SendDelItems(UserItem);
                        //DisPoseAndNil(UserItem);
                          DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                          UserItem:= nil;

                        Dec(nMineCount);
                     end;
              end;
            end;
          end;//if StdItem <> nil
        end;
      end;
    finally
      PlayObject.m_boCanQueryBag:= False;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfTAKEMINE',[g_sExceptionVer]));
  end;
end;
//功能：收回指定名称的物品(按数量，升级次数)
//格式：TAKEBAGITEM 物品名 数量 操作符(<>=) 升级次数
procedure TNormNpc.ActionOfTAKEBAGITEM(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  sMineName: String;
  nMineCount, nLevel, nCount, I, nValue: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  cMethod: Char;
begin
  try
    nCount:= 0;
    sMineName:=GetLineVariableText(PlayObject, QuestActionInfo.sParam1); //物品名
    nMineCount := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);//数量
    nLevel := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam4),-1); //升级次数
    if (sMineName='') or (nMineCount < 0) or (nLevel < 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_TAKEBAGITEM);
      Exit;
    end;
    cMethod := QuestActionInfo.sParam3[1];
    PlayObject.m_boCanQueryBag:= True;//NPC操作物品时,不能刷新包裹
    Try
      for I := PlayObject.m_ItemList.Count - 1 downto 0 do begin
        if nMineCount <= 0 then Break;
        if PlayObject.m_ItemList.Count <= 0 then Break;
        UserItem := PlayObject.m_ItemList.Items[I];
        if UserItem = nil then Continue;
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem <> nil then begin
          if CompareText(StdItem.Name, sMineName) = 0 then begin
            nValue:= 0;
            if (StdItem.StdMode in [15,16,19..24,26,27,28,29,30,52,54,55,62,64]) and
              ((StdItem.Shape = 188) or (StdItem.Shape = 203)) then begin
              nValue:= StdItem.Reserved + UserItem.btValue[9];
            end else nValue:= UserItem.btValue[9];
            if nValue > 5 then nValue:= 5;//吸伤装备等级
            case cMethod of
              '=': if nValue = nLevel then begin
                      if StdItem.NeedIdentify = 1 then
                        AddGameDataLog('10' + #9 + PlayObject.m_sMapName + #9 +
                          IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                          PlayObject.m_sCharName + #9 + sMineName + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                          '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                          '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                          '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                          '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                          '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                          IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                          IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                          IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                          IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                      PlayObject.m_ItemList.Delete(I);
                      PlayObject.SendDelItems(UserItem);
                      //DisPoseAndNil(UserItem);
                      DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                      UserItem:= nil;

                      Dec(nMineCount);
                   end;
              '>': if nValue > nLevel then begin
                      if StdItem.NeedIdentify = 1 then
                        AddGameDataLog('10' + #9 + PlayObject.m_sMapName + #9 +
                          IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                          PlayObject.m_sCharName + #9 + sMineName + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                          '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                          '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                          '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                          '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                          '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                          IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                          IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                          IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                          IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                      PlayObject.m_ItemList.Delete(I);
                      PlayObject.SendDelItems(UserItem);
                      //DisPoseAndNil(UserItem);
                      DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                      UserItem:= nil;
                      Dec(nMineCount);
                   end;
              '<': if nValue < nLevel then begin
                      if StdItem.NeedIdentify = 1 then
                        AddGameDataLog('10' + #9 + PlayObject.m_sMapName + #9 +
                          IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                          PlayObject.m_sCharName + #9 + sMineName + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                          '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                          '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                          '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                          '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                          '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                          IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                          IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                          IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                          IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                      PlayObject.m_ItemList.Delete(I);
                      PlayObject.SendDelItems(UserItem);
                      //DisPoseAndNil(UserItem);
                      DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                      UserItem:= nil;
                      Dec(nMineCount);
                   end;
            end;
          end;
        end;//if StdItem <> nil
      end;
    finally
      PlayObject.m_boCanQueryBag:= False;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfTAKEBAGITEM',[g_sExceptionVer]));
  end;
end;
//功能：给指定名称的物品(按数量，等级，且可以增加指定属性点)
//命令格式:GIVEBAGITEM 物品名称 数量 等级 属性值(攻1/魔2/道3) 点数(1-100)
//如属性值不填,则不增加属性点
//分类为15,16,19..24,26,27,28,29,30,52,54,62,64且shape=188,203物品才有效
procedure TNormNpc.ActionOfGIVEBAGITEM(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  sMineName: String;
  nMineCount, nLevel, I, nTpye, nPoint: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
  try
    sMineName:= GetLineVariableText(PlayObject, QuestActionInfo.sParam1); //物品名
    nMineCount:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);//数量
    nLevel:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam3),-1); //升级次数
    nTpye:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam4),0);//属性值
    nPoint:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam5),0);//点数
    if (sMineName='') or (nMineCount < 0) or (nLevel < 0) or (nTpye > 3) or (nPoint > 100) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_GIVEBAGITEM);
      Exit;
    end;
    if nMineCount > 0 then begin
      StdItem := UserEngine.GetStdItem(sMineName);
      if (StdItem <> nil) then begin
        if (StdItem.StdMode in [15,16,19..24,26,27,28,29,30,52,54,62,64]) and
          ((StdItem.Shape = 188) or (StdItem.Shape = 203)) then begin
          for I := 0 to nMineCount - 1 do begin
            New(UserItem);
            if UserEngine.CopyToUserItemFromName(sMineName, UserItem) then begin
              UserItem.btValue[9] := _MIN(255, nLevel);//升级次数
              if (nTpye in [1..3]) and (nPoint > 0) then begin
                case nTpye of
                  1: UserItem.btValue[2] := _MIN(255, nPoint);//攻
                  2: UserItem.btValue[3] := _MIN(255, nPoint);//魔
                  3: UserItem.btValue[4] := _MIN(255, nPoint);//道
                end;
              end;
              if PlayObject.IsEnoughBag then begin
                PlayObject.m_ItemList.Add(UserItem);
                PlayObject.SendAddItem(UserItem);
                if StdItem.NeedIdentify = 1 then
                  AddGameDataLog('9' + #9 + PlayObject.m_sMapName + #9 +
                    IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                    PlayObject.m_sCharName + #9 + sMineName + #9 +
                    IntToStr(UserItem.MakeIndex) + #9 +
                    IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                    IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                    IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                    IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
              end else begin//包裹满则扔到地上
                
                if StdItem.NeedIdentify = 1 then
                  AddGameDataLog('9' + #9 + PlayObject.m_sMapName + #9 +
                    IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                    PlayObject.m_sCharName + #9 + sMineName + #9 +
                    IntToStr(UserItem.MakeIndex) + #9 +
                    IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                    IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                    IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                    IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                PlayObject.DropItemDown(UserItem, 3, False, False, PlayObject, PlayObject);
                Dispose(UserItem);//修复内存泄露By TasNat at: 2012-06-01 12:10:51
              end;
            end else begin
              Dispose(UserItem);
              Break;
            end;
          end;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfGiveBagItem',[g_sExceptionVer]));
  end;
end;

{$IF M2Version <> 2}
//功能：在客户端让“成长任务”按键发亮 20100801
//格式：SENDSHINYMSG
procedure TNormNpc.ActionOfSendShinyMsg(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
begin
  PlayObject.SendMsg(PlayObject, RM_SHOWSHINY, 0, 0, 0, 0, '');
end;

//功能：触发QMission-0.txt脚本段
//格式：QMISSIONGOTO TAB页(0-2) 下面脚本段
//0-@主线任务 1-@支线任务 2-@操作指南
procedure TNormNpc.ActionOfQMissionGoto(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  sQFStr, sQFStr1: string;
  nTAB: Integer;
begin
  try
    nTAB := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam1), -1);//TAB页
    sQFStr1:= GetLineVariableText(PlayObject,QuestActionInfo.sParam2);//触发QMission-0.txt段 下面显示
    if (nTAB < 0) or (nTAB > 2) or (sQFStr1 = '') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_QMISSIONGOTO);
      Exit;
    end;
    if (g_MissionNPC <> nil) and (sQFStr1 <> '') then begin
      sQFStr := '';
      case nTAB of//根据TAB值取对应的脚本段
        0: sQFStr := '@主线任务';
        1: sQFStr := '@支线任务';
        2: sQFStr := '@操作指南';
      end;
      if (sQFStr <> '') then begin
        g_MissionNPC.GotoLable(PlayObject, sQFStr, False, True{任务栏上面显示内容});
        PlayObject.SendMsg(PlayObject, RM_OPENSHINY, 0, nTAB, 0, 0, sQFStr1);
        g_MissionNPC.GotoLable(PlayObject, sQFStr1, False, False{任务栏下面显示内容});
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfQMissionGoto',[g_sExceptionVer]));
  end;
end;
//打开品评窗口 20100830
procedure TNormNpc.ActionOfJudge(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
begin
  PlayObject.SendMsg(Self, RM_OPENDJUDGE, 0, g_Config.nJudgePrice, BoolToInt(g_Config.boJudgeUseGold), 0, '');
end;
//功能:调整人物熟练度
//格式:CHANGEPROFICIENCY 控制符(=,+,-) 点数
procedure TNormNpc.ActionOfCHANGEPROFICIENCY(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  nExp: LongWord;
  cMethod: Char;
  //dwInt: LongWord;
begin
  try
    nExp:=Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);
    if (nExp < 0) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CHANGEPROFICIENCY);
      Exit;
    end;
    cMethod := QuestActionInfo.sParam1[1];
    if PlayObject.m_Magic100Skill = nil then Exit;//没学会神秘解读技能则不进行操作
    case cMethod of
      '=': begin
          if nExp >= 0 then PlayObject.m_nProficiency := _MIN(999, nExp);//熟练度
        end;
      '-': begin
          if PlayObject.m_nProficiency > LongWord(nExp) then begin
            Dec(PlayObject.m_nProficiency, LongWord(nExp));
          end else begin
            PlayObject.m_nProficiency := 0;
          end;
        end;
      '+': begin
          //dwInt := LongWord(nExp);
          PlayObject.m_nProficiency := _MIN(999, PlayObject.m_nProficiency + nExp);//熟练度
        end;
    end;//case
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfCHANGEPROFICIENCY',[g_sExceptionVer]));
  end;
end;
//功能：检查玩家是否为门派掌门
//格式：ISDIVISIONMASTER
function TNormNpc.ConditionOfIsDivisionMaster(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
  Result := False;
  try
    if (PlayObject.m_MyDivision <> nil) then begin
      if CompareText(TDivision(PlayObject.m_MyDivision).GetChiefName, PlayObject.m_sCharName) = 0 then
      Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfIsDivisionMaster',[g_sExceptionVer]));
  end;
end;
//功能：检查玩家是否为门派弟子
//格式：ISDIVISIONHEART (0/1)
//0－公共门派 1-999门派
function TNormNpc.ConditionOfIsDivisionHeart(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nTyep: Integer;
begin
  Result := False;
  try
    nTyep:= Str_ToInt(QuestConditionInfo.sParam1, -1);
    if (PlayObject.m_MyDivision <> nil) then begin
      case nTyep of
        0: begin
          if CompareText(TDivision(PlayObject.m_MyDivision).GetChiefName, PlayObject.m_sCharName) <> 0 then begin
            if TDivision(PlayObject.m_MyDivision).nDivisonType = 1 then Result := True;
          end;
        end;
        1: begin
          if CompareText(TDivision(PlayObject.m_MyDivision).GetChiefName, PlayObject.m_sCharName) <> 0 then begin
            if TDivision(PlayObject.m_MyDivision).nDivisonType <> 1 then Result := True;
          end;
        end;
        else Result := True;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfIsDivisionHeart',[g_sExceptionVer]));
  end;
end;
//功能：检查累积经验是否达到心法吸收值
//格式：CHECKHEARTEXP
function TNormNpc.ConditionOfCheckHeartExp(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
  Result := False;
  try
    if PlayObject.m_Abil.nExp < (g_Config.nIncHeartPointNeedExp * 10000) then begin
      PlayObject.SysMsg(Format('已累积经验%u，相差%u经验，无法使用！',[PlayObject.m_Abil.nExp, (g_Config.nIncHeartPointNeedExp * 10000 - PlayObject.m_Abil.nExp)]), c_Green, t_Hint);
    end else Result := True;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckHeartExp',[g_sExceptionVer]));
  end;
end;
//功能：检查是否学过心法
//格式：CHECKHEHEARTSKILL (0/1/2)
//注:0－检查是否有龙卫心法或传承心法 1－检查是否有龙卫心法 2－检查是否有传承心法
function TNormNpc.ConditionOfCheckHeartSKill(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var nType: Integer;
begin
  Result := False;
  try
    nType := Str_ToInt(QuestConditionInfo.sParam1, -1);
    if nType < 0 then begin
      if not GetValValue(PlayObject, QuestConditionInfo.sParam1, nType) then begin //增加变量支持
        ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKHEHEARTSKILL);
        Exit;
      end;
    end;
    case nType of
      0: if (PlayObject.m_MagicSkill_105 <> nil) or (PlayObject.m_MagicSkill_106 <> nil) then Result := True;
      1: if (PlayObject.m_MagicSkill_105 <> nil) then Result := True;
      2: if (PlayObject.m_MagicSkill_106 <> nil) then Result := True;
      else if (PlayObject.m_MagicSkill_105 <> nil) or (PlayObject.m_MagicSkill_106 <> nil) then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckHeartSKill',[g_sExceptionVer]));
  end;
end;
//功能:检测门派人气值
//格式:CHECKDIVISIONPOINT 控制符(<,>,=)数字
function TNormNpc.ConditionOfCheckDivisionPoint(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethod: Char;
  nPoint: Integer;
  Division: TDivision;
begin
  try
    Result := False;
    nPoint := Str_ToInt(QuestConditionInfo.sParam2, -1);
    if nPoint < 0 then begin
      if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nPoint) then begin //增加变量支持
        ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKDIVISIONPOINT);
        Exit;
      end;
    end;
    if PlayObject.m_MyDivision = nil then Exit;
    Division := TDivision(PlayObject.m_MyDivision);
    cMethod := QuestConditionInfo.sParam1[1];
    case cMethod of
      '=': if Division.nPopularity = nPoint then Result := True;
      '>': if Division.nPopularity > nPoint then Result := True;
      '<': if Division.nPopularity < nPoint then Result := True;
    else if Division.nPopularity >= nPoint then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckDivisionPoint',[g_sExceptionVer]));
  end;
end;

//功能：检查玩家是否有指定称号
//格式：CHECKFENGHAO 称号名
function TNormNpc.ConditionOfCheckFengHao(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  I: Integer;
  HumTitleDB, HumTitleDB1: pTHumTitleDB;
  sFengHaoName: string;
begin
  try
    Result := False;
    sFengHaoName := GetLineVariableText(PlayObject, QuestConditionInfo.sParam1);//称号名
    if (sFengHaoName = '') then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKFENGHAO);
      Exit;
    end;
    HumTitleDB:= UserEngine.GetHumTitle(sFengHaoName);
    if HumTitleDB <> nil then begin
      for I := Low(THumTitles) to High(THumTitles) do begin//判断人物是否有同样的称号
        if (PlayObject.m_wHumTitles[I].wIndex > 0) and (PlayObject.m_wHumTitles[I].MakeIndex > 0) then begin
          HumTitleDB1:= UserEngine.GetHumTitle(PlayObject.m_wHumTitles[I].wIndex);
          if HumTitleDB1 <> nil then begin
            if (HumTitleDB1.sTitleName = sFengHaoName) and
               (HumTitleDB1.StdMode = HumTitleDB.StdMode) then begin
              Result := True;
              Break;
            end;
          end;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckFengHao',[g_sExceptionVer]));
  end;
end;
//功能：检查玩家所有称号的数量
//格式：CHECKFENGHAOCOUNT 角色名 操作符(<,>,=) 数量(0-8)
function TNormNpc.ConditionOfCheckFengHaoCount(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nCount, nFengHaoCount: Integer;
  I: Integer;
  HumTitleDB: pTHumTitleDB;
  cMethod: Char;
  sName: string;
  PoseHuman: TPlayObject;
begin
  try
    Result := False;
    sName:= GetLineVariableText(PlayObject,QuestConditionInfo.sParam1);
    nCount:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam3), -1);
    if (nCount <= 0) or (nCount > 8) or (sName = '') then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKFENGHAOCOUNT);
      Exit;
    end;
    PoseHuman := UserEngine.GetPlayObject(sName);//检查是否在线
    if PoseHuman = nil then Exit;
    nFengHaoCount:= 0;
    for I := Low(THumTitles) to High(THumTitles) do begin//判断人物是否有同样的称号
      if (PoseHuman.m_wHumTitles[I].wIndex > 0) and (PoseHuman.m_wHumTitles[I].MakeIndex > 0) then begin
        HumTitleDB:= UserEngine.GetHumTitle(PoseHuman.m_wHumTitles[I].wIndex);
        if HumTitleDB <> nil then Inc(nFengHaoCount);
      end;
    end;
    cMethod := QuestConditionInfo.sParam2[1];
    case cMethod of
      '=': if nFengHaoCount = nCount then Result := True;
      '>': if nFengHaoCount > nCount then Result := True;
      '<': if nFengHaoCount < nCount then Result := True;
    else if nFengHaoCount >= nCount then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckFengHaoCount',[g_sExceptionVer]));
  end;
end;
//功能：检查玩家护花使者或主宰龙卫的数量
//格式：CHECKFENGHAOLISTCOUNT 类型(0-护花使者 1-主宰龙卫) 操作符(<,>,=) 数量(0-10)
function TNormNpc.ConditionOfCheckFengHaoListCount(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nCount, nFengHaoCount, nType: Integer;
  cMethod: Char;
begin
  try
    Result := False;
    nType:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam1), -1);
    nCount:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam3), -1);
    if (nType < 0) or (nType > 1) or (nCount < 0) or (nCount > 10) then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKFENGHAOLISTCOUNT);
      Exit;
    end;
    case nType of
      0: begin
        if not PlayObject.m_boFengHaoMagicEffect then Exit;
        nFengHaoCount:= PlayObject.m_HuhuaList.Count;
      end;
      1: begin
        if not PlayObject.m_boFengHaoDominate then Exit;
        nFengHaoCount:= PlayObject.m_ComradeList.Count;
      end;
    end;
    cMethod := QuestConditionInfo.sParam2[1];
    case cMethod of
      '=': if nFengHaoCount = nCount then Result := True;
      '>': if nFengHaoCount > nCount then Result := True;
      '<': if nFengHaoCount < nCount then Result := True;
    else if nFengHaoCount >= nCount then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckFengHaoListCount',[g_sExceptionVer]));
  end;
end;

//检查行会之星授于日期
//格式：CheckGuildStarDay 操作符(<,>,=) 小时数
function TNormNpc.ConditionOfCheckGuildStarDay(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nHours: Integer;
  cMethod: Char;
  nChangeHours: Integer;
begin
  try
    Result := False;
    nHours:= Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2), -1);
    if (nHours < 0) then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKGUILDSTARDAY);
      Exit;
    end;
    if PlayObject.m_MyGuild <> nil then begin
      nChangeHours := GetHoursCount(Now(), TGUild(PlayObject.m_MyGuild).m_GuildStarDate);
      cMethod := QuestConditionInfo.sParam1[1];
      //MainOutMessage(Format('{%s} 计算相差小时数:%d  对比小时:%d',[DateTimeToStr(TGUild(PlayObject.m_MyGuild).m_GuildStarDate),nChangeHours, nHours]));
      case cMethod of
        '=': if nChangeHours = nHours then Result := True;
        '>': if nChangeHours > nHours then Result := True;
        '<': if nChangeHours < nHours then Result := True;
        else if nChangeHours >= nHours then Result := True;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckGuildStarDay',[g_sExceptionVer]));
  end;
end; 
{$IFEND}
//功能：收回指定属性的酒(按品质、酒精度、酒等级)
//格式：TAKEMAKEWINE 酒名称 数量 操作符(<>=) 点数 模式(0-品质 1-酒精度 2-酒等级)
//说明：酒等级只有0-3级
procedure TNormNpc.ActionOfTakeMakeWine(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  sWineName: String;
  nMineCount, nDura, nCount, I: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  cMethod: Char;
  nType: Byte;
begin
  try
    nCount:= 0;
    nType:= Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam5), 0);//模式
    sWineName:=GetLineVariableText(PlayObject, QuestActionInfo.sParam1); //酒名
    nMineCount := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);//数量
    nDura := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam4),-1); //点数
    if nMineCount < 0 then begin
      if not GetValValue(PlayObject, QuestActionInfo.sParam2, nMineCount) then begin //增加变量支持
        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_TAKEMAKEWINE);
        Exit;
      end;
    end;
    if nDura < 0 then begin
      if not GetValValue(PlayObject, QuestActionInfo.sParam4, nDura) then begin //增加变量支持
        ScriptActionError(PlayObject, '', QuestActionInfo, sSC_TAKEMAKEWINE);
        Exit;
      end;
    end;

    if (sWineName='') or (nMineCount < 0) or (nDura < 0) or (nDura > 100) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_TAKEMAKEWINE);
      Exit;
    end;
    cMethod := QuestActionInfo.sParam3[1];//操作符
    PlayObject.m_boCanQueryBag:= True;//NPC操作物品时,不能刷新包裹
    Try
      for I := PlayObject.m_ItemList.Count - 1 downto 0 do begin
        if nMineCount <= 0 then Break;
        if PlayObject.m_ItemList.Count <= 0 then Break;
        UserItem := PlayObject.m_ItemList.Items[I];
        if UserItem = nil then Continue;
        if CompareText(UserEngine.GetStdItemName(UserItem.wIndex), sWineName) = 0 then begin
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem <> nil then begin
            if (StdItem.StdMode = 60) and (StdItem.shape <> 0) then begin
              case nType of
                0: begin//品质
                  case cMethod of
                    '=': if UserItem.btValue[0] = nDura then begin
                            if StdItem.NeedIdentify = 1 then
                              AddGameDataLog('10' + #9 + PlayObject.m_sMapName + #9 +
                                IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                                PlayObject.m_sCharName + #9 + sWineName + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                                '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                                '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                                '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                                '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                                '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                                IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                                IntToStr(UserItem.btValue[3])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                            PlayObject.m_ItemList.Delete(I);
                            PlayObject.SendDelItems(UserItem);
                            //DisPoseAndNil(UserItem);
                            DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                            UserItem:= nil;
                            Dec(nMineCount);
                         end;
                    '>': if UserItem.btValue[0] > nDura then begin
                            if StdItem.NeedIdentify = 1 then
                              AddGameDataLog('10' + #9 + PlayObject.m_sMapName + #9 +
                                IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                                PlayObject.m_sCharName + #9 + sWineName + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                                '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                                '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                                '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                                '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                                '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                                IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                                IntToStr(UserItem.btValue[3])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                            PlayObject.m_ItemList.Delete(I);
                            PlayObject.SendDelItems(UserItem);
                            //DisPoseAndNil(UserItem);
                            DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                            UserItem:= nil;
                            Dec(nMineCount);
                         end;
                    '<': if UserItem.btValue[0] < nDura then begin
                            if StdItem.NeedIdentify = 1 then
                              AddGameDataLog('10' + #9 + PlayObject.m_sMapName + #9 +
                                IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                                PlayObject.m_sCharName + #9 + sWineName + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                                '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                                '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                                '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                                '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                                '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                                IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                                IntToStr(UserItem.btValue[3])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                            PlayObject.m_ItemList.Delete(I);
                            PlayObject.SendDelItems(UserItem);
                            //DisPoseAndNil(UserItem);
                            DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                            UserItem:= nil;
                            Dec(nMineCount);
                         end;
                  end;
                end;//0
                1: begin//酒精度
                  case cMethod of
                    '=': if UserItem.btValue[1] = nDura then begin
                            if StdItem.NeedIdentify = 1 then
                              AddGameDataLog('10' + #9 + PlayObject.m_sMapName + #9 +
                                IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                                PlayObject.m_sCharName + #9 + sWineName + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                                '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                                '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                                '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                                '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                                '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                                IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                                IntToStr(UserItem.btValue[3])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                            PlayObject.m_ItemList.Delete(I);
                            PlayObject.SendDelItems(UserItem);
                            //DisPoseAndNil(UserItem);
                            DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                            UserItem:= nil;
                            Dec(nMineCount);
                         end;
                    '>': if UserItem.btValue[1] > nDura then begin
                            if StdItem.NeedIdentify = 1 then
                              AddGameDataLog('10' + #9 + PlayObject.m_sMapName + #9 +
                                IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                                PlayObject.m_sCharName + #9 + sWineName + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                                '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                                '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                                '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                                '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                                '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                                IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                                IntToStr(UserItem.btValue[3])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                            PlayObject.m_ItemList.Delete(I);
                            PlayObject.SendDelItems(UserItem);
                            //DisPoseAndNil(UserItem);
                            DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                            UserItem:= nil;
                            Dec(nMineCount);
                         end;
                    '<': if UserItem.btValue[1] < nDura then begin
                            if StdItem.NeedIdentify = 1 then
                              AddGameDataLog('10' + #9 + PlayObject.m_sMapName + #9 +
                                IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                                PlayObject.m_sCharName + #9 + sWineName + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                                '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                                '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                                '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                                '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                                '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                                IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                                IntToStr(UserItem.btValue[3])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                            PlayObject.m_ItemList.Delete(I);
                            PlayObject.SendDelItems(UserItem);
                            //DisPoseAndNil(UserItem);
                            DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                            UserItem:= nil;
                            Dec(nMineCount);
                         end;
                  end;
                end;//1
                2: begin//酒等级
                  case cMethod of
                    '=': if UserItem.btValue[3] = nDura then begin
                            if StdItem.NeedIdentify = 1 then
                              AddGameDataLog('10' + #9 + PlayObject.m_sMapName + #9 +
                                IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                                PlayObject.m_sCharName + #9 + sWineName + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                                '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                                '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                                '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                                '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                                '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                                IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                                IntToStr(UserItem.btValue[3])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                            PlayObject.m_ItemList.Delete(I);
                            PlayObject.SendDelItems(UserItem);
                            //DisPoseAndNil(UserItem);
                            DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                            UserItem:= nil;

                            Dec(nMineCount);
                         end;
                    '>': if UserItem.btValue[3] > nDura then begin
                            if StdItem.NeedIdentify = 1 then
                              AddGameDataLog('10' + #9 + PlayObject.m_sMapName + #9 +
                                IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                                PlayObject.m_sCharName + #9 + sWineName + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                                '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                                '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                                '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                                '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                                '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                                IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                                IntToStr(UserItem.btValue[3])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                            PlayObject.m_ItemList.Delete(I);
                            PlayObject.SendDelItems(UserItem);
                            //DisPoseAndNil(UserItem);
                            DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                            UserItem:= nil;
                            Dec(nMineCount);
                         end;
                    '<': if UserItem.btValue[3] < nDura then begin
                            if StdItem.NeedIdentify = 1 then
                              AddGameDataLog('10' + #9 + PlayObject.m_sMapName + #9 +
                                IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
                                PlayObject.m_sCharName + #9 + sWineName + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                                '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                                '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                                '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                                '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                                '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                                IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                                IntToStr(UserItem.btValue[3])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + m_sCharName);
                            PlayObject.m_ItemList.Delete(I);
                            PlayObject.SendDelItems(UserItem);
                            //DisPoseAndNil(UserItem);
                            DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                            UserItem:= nil;
                            Dec(nMineCount);
                         end;
                  end;                
                end;//2
              end;
            end;
          end;//if StdItem <> nil
        end;
      end;
    finally
      PlayObject.m_boCanQueryBag:= False;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfTakeMakeWine',[g_sExceptionVer]));
  end;
end;

procedure TNormNpc.ActionOfRestBonusPoint(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nTotleUsePoint: Integer;
begin
  try
    nTotleUsePoint := PlayObject.m_BonusAbil.DC +
      PlayObject.m_BonusAbil.MC +
      PlayObject.m_BonusAbil.SC +
      PlayObject.m_BonusAbil.AC +
      PlayObject.m_BonusAbil.MAC +
      PlayObject.m_BonusAbil.HP +
      PlayObject.m_BonusAbil.MP +
      PlayObject.m_BonusAbil.Hit +
      PlayObject.m_BonusAbil.Speed +
      PlayObject.m_BonusAbil.X2;
    FillChar(PlayObject.m_BonusAbil, SizeOf(TNakedAbility), #0);
    Inc(PlayObject.m_nBonusPoint, nTotleUsePoint);
    PlayObject.SendMsg(PlayObject, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    PlayObject.HasLevelUp(0);
    PlayObject.SysMsg('分配点数已复位！！！', c_Red, t_Hint);
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfRestBonusPoint',[g_sExceptionVer]));
  end;
end;

procedure TNormNpc.ActionOfRestReNewLevel(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
begin
  try
    PlayObject.m_btReLevel := 0;
    PlayObject.HasLevelUp(0);
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfRestReNewLevel',[g_sExceptionVer]));
  end;
end;

procedure TNormNpc.ActionOfSetMapMode(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  Envir: TEnvirnoment;
  sMapName: string;
  sMapMode, sParam1, sParam2 {,sParam3,sParam4}: string;
begin
try
  sMapName := QuestActionInfo.sParam1;
  sMapMode := QuestActionInfo.sParam2;
  sParam1 := QuestActionInfo.sParam3;
  sParam2 := QuestActionInfo.sParam4;
  //  sParam3:=QuestActionInfo.sParam5;
  //  sParam4:=QuestActionInfo.sParam6;

  Envir := g_MapManager.FindMap(sMapName);
  if (Envir = nil) or (sMapMode = '') then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_SETMAPMODE);
    Exit;
  end;
  if CompareText(sMapMode, 'SAFE') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boSAFE := True;
    end else begin
      Envir.m_boSAFE := False;
    end;
  end else
  if CompareText(sMapMode, 'SAFENORUN') = 0 then begin//安全区人物不能穿
    if (sParam1 <> '') then begin
      Envir.m_boSAFENORUN := True;
    end else begin
      Envir.m_boSAFENORUN := False;
    end;
  end else
  if CompareText(sMapMode, 'SAFEHERONORUN') = 0 then begin//英雄安全区不能穿 20090525
    if (sParam1 <> '') then begin
      Envir.m_boSAFEHERONORUN := True;
    end else begin
      Envir.m_boSAFEHERONORUN := False;
    end;
  end else
    if CompareText(sMapMode, 'DARK') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boDARK := True;
    end else begin
      Envir.m_boDARK := False;
    end;
  end else
    if CompareText(sMapMode, 'DARK') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boDARK := True;
    end else begin
      Envir.m_boDARK := False;
    end;
  end else
    if CompareText(sMapMode, 'FIGHT') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boFightZone := True;
    end else begin
      Envir.m_boFightZone := False;
    end;
  end else
    if CompareText(sMapMode, 'FIGHT2') = 0 then begin//PK掉装备地图 20080525
    if (sParam1 <> '') then begin
      Envir.m_boFight2Zone := True;
    end else begin
      Envir.m_boFight2Zone := False;
    end;
  end else
    if CompareText(sMapMode, 'FIGHT3') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boFight3Zone := True;
    end else begin
      Envir.m_boFight3Zone := False;
    end;
  end else
    if CompareText(sMapMode, 'FIGHT4') = 0 then begin//挑战地图 20080706
    if (sParam1 <> '') then begin
      Envir.m_boFight4Zone := True;
    end else begin
      Envir.m_boFight4Zone := False;
    end;
  end else
    if CompareText(sMapMode, 'FIGHT5') = 0 then begin//不同行会名字变不同颜色 20090318
    if (sParam1 <> '') then begin
      Envir.m_boFight5Zone := True;
    end else begin
      Envir.m_boFight5Zone := False;
    end;
  end else
    if CompareText(sMapMode, 'NOFIGHT4') = 0 then begin//禁止挑战地图
    if (sParam1 <> '') then begin
      Envir.m_boNoFight4Zone := True;
    end else begin
      Envir.m_boNoFight4Zone := False;
    end;
  end else
    if CompareText(sMapMode, 'DAY') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boDAY := True;
    end else begin
      Envir.m_boDAY := False;
    end;
  end else
    if CompareText(sMapMode, 'QUIZ') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boQUIZ := True;
    end else begin
      Envir.m_boQUIZ := False;
    end;
  end else
    if CompareText(sMapMode, 'NORECONNECT') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boNORECONNECT := True;
      Envir.sNoReconnectMap := sParam1;
    end else begin
      Envir.m_boNORECONNECT := False;
    end;
  end else
    if CompareText(sMapMode, 'MUSIC') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boMUSIC := True;
      Envir.m_nMUSICID := Str_ToInt(sParam1, -1);
    end else begin
      Envir.m_boMUSIC := False;
    end;
  end else
    if CompareText(sMapMode, 'EXPRATE') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boEXPRATE := True;
      Envir.m_nEXPRATE := Str_ToInt(sParam1, -1);
    end else begin
      Envir.m_boEXPRATE := False;
    end;
  end else
    if CompareText(sMapMode, 'CRIT') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boCRIT := True;
      Envir.m_nCRIT := Str_ToInt(sParam1, 0);
    end else begin
      Envir.m_boCRIT := False;
    end;
  end else
    if CompareText(sMapMode, 'PEAK') = 0 then begin
    if (sParam1 <> '') and (sParam2 <> '') then begin
      Envir.m_boPeak := True;
      Envir.m_nPeakMinRate := Str_ToInt(sParam1, 0);
      Envir.m_nPeakMaxRate := Str_ToInt(sParam2, 0);
      if Envir.m_nPeakMinRate > Envir.m_nPeakMaxRate then Envir.m_nPeakMaxRate:= Envir.m_nPeakMinRate;
    end else begin
      Envir.m_boPeak := False;
    end;
  end else
    if CompareText(sMapMode, 'PULSEXPRATE') = 0 then begin//地图杀怪英雄经验倍数 20091029
    if (sParam1 <> '') then begin
      Envir.m_boPULSEXPRATE := True;
      Envir.m_nPULSEXPRATE := Str_ToInt(sParam1, -1);
    end else begin
      Envir.m_boPULSEXPRATE := False;
    end;
  end else
    if CompareText(sMapMode, 'NGEXPRATE') = 0 then begin//地图杀怪内功经验倍数 20091029
    if (sParam1 <> '') then begin
      Envir.m_boNGEXPRATE := True;
      Envir.m_nNGEXPRATE := Str_ToInt(sParam1, -1);
    end else begin
      Envir.m_boNGEXPRATE := False;
    end;
  end else
    if CompareText(sMapMode, 'DECEXPRATETIME') = 0 then begin//减双倍经验时间 20090206
    if (sParam1 <> '') then begin
      Envir.m_boDECEXPRATETIME := True;
      Envir.m_nDECEXPRATETIME := Str_ToInt(sParam1, 1);
    end else begin
      Envir.m_boDECEXPRATETIME := False;
    end;
  end else
    if CompareText(sMapMode, 'PKWINLEVEL') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boPKWINLEVEL := True;
      Envir.m_nPKWINLEVEL := Str_ToInt(sParam1, -1);
    end else begin
      Envir.m_boPKWINLEVEL := False;
    end;
  end else
    if CompareText(sMapMode, 'PKWINEXP') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boPKWINEXP := True;
      Envir.m_nPKWINEXP := Str_ToInt(sParam1, -1);
    end else begin
      Envir.m_boPKWINEXP := False;
    end;
  end else
    if CompareText(sMapMode, 'PKLOSTLEVEL') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boPKLOSTLEVEL := True;
      Envir.m_nPKLOSTLEVEL := Str_ToInt(sParam1, -1);
    end else begin
      Envir.m_boPKLOSTLEVEL := False;
    end;
  end else
    if CompareText(sMapMode, 'PKLOSTEXP') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boPKLOSTEXP := True;
      Envir.m_nPKLOSTEXP := Str_ToInt(sParam1, -1);
    end else begin
      Envir.m_boPKLOSTEXP := False;
    end;
  end else
    if CompareText(sMapMode, 'NOSKILL') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boNOSKILL := True;
    end else begin
      Envir.m_boNOSKILL := False;
    end;
  end else
    if CompareText(sMapMode, 'DECHP') = 0 then begin
    if (sParam1 <> '') and (sParam2 <> '') then begin
      Envir.m_boDECHP := True;
      Envir.m_nDECHPTIME := Str_ToInt(sParam1, -1);
      Envir.m_nDECHPPOINT := Str_ToInt(sParam2, -1);
    end else begin
      Envir.m_boDECHP := False;
    end;
  end else
    if CompareText(sMapMode, 'DECGAMEGOLD') = 0 then begin
    if (sParam1 <> '') and (sParam2 <> '') then begin
      Envir.m_boDecGameGold := True;
      Envir.m_nDECGAMEGOLDTIME := Str_ToInt(sParam1, -1);
      Envir.m_nDecGameGold := Str_ToInt(sParam2, -1);
    end else begin
      Envir.m_boDecGameGold := False;
    end;
  end else
    if CompareText(sMapMode, 'RUNHUMAN') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boRUNHUMAN := True;
    end else begin
      Envir.m_boRUNHUMAN := False;
    end;
  end else
    if CompareText(sMapMode, 'RUNMON') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boRUNMON := True;
    end else begin
      Envir.m_boRUNMON := False;
    end;
  end else
    if CompareText(sMapMode, 'NEEDHOLE') = 0 then begin//进入需要洞
    if (sParam1 <> '') then begin
      Envir.m_boNEEDHOLE := True;
    end else begin
      Envir.m_boNEEDHOLE := False;
    end;
  end else
    if CompareText(sMapMode, 'NORECALL') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boNORECALL := True;
    end else begin
      Envir.m_boNORECALL := False;
    end;
  end else
    if CompareText(sMapMode, 'NOGUILDRECALL') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boNOGUILDRECALL := True;
    end else begin
      Envir.m_boNOGUILDRECALL := False;
    end;
  end else
    if CompareText(sMapMode, 'NODEARRECALL') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boNODEARRECALL := True;
    end else begin
      Envir.m_boNODEARRECALL := False;
    end;
  end else
    if CompareText(sMapMode, 'NOMASTERRECALL') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boNOMASTERRECALL := True;
    end else begin
      Envir.m_boNOMASTERRECALL := False;
    end;
  end else
    if CompareText(sMapMode, 'NORANDOMMOVE') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boNORANDOMMOVE := True;
    end else begin
      Envir.m_boNORANDOMMOVE := False;
    end;
  end else
    if CompareText(sMapMode, 'NODRUG') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boNODRUG := True;
    end else begin
      Envir.m_boNODRUG := False;
    end;
  end else
    if CompareText(sMapMode, 'MINE') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boMINE := True;
    end else begin
      Envir.m_boMINE := False;
    end;
  end else
    if CompareText(sMapMode, 'JEWEL') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boDigJewel := True;
    end else begin
      Envir.m_boDigJewel := False;
    end;
  end else
    if CompareText(sMapMode, 'SHOP') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boSHOP := True;
    end else begin
      Envir.m_boSHOP := False;
    end;
  end else
    if CompareText(sMapMode, 'NOPOSITIONMOVE') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boNOPOSITIONMOVE := True;
    end else begin
      Envir.m_boNOPOSITIONMOVE := False;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfSetMapMode',[g_sExceptionVer]));
end;
end;

procedure TNormNpc.ActionOfSetMemberLevel(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nLevel: Integer;
  cMethod: Char;
begin
try
  //nLevel := Str_ToInt(QuestActionInfo.sParam2, -1);
  nLevel := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);//20080501
  if nLevel < 0 then begin
    if not GetValValue(PlayObject, QuestActionInfo.sParam2, nLevel) then begin //增加变量支持
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_SETMEMBERLEVEL);
      Exit;
    end;
  end;
  cMethod := QuestActionInfo.sParam1[1];
  case cMethod of
    '=': begin
        PlayObject.m_nMemberLevel := nLevel;
      end;
    '-': begin
        Dec(PlayObject.m_nMemberLevel, nLevel);
        if PlayObject.m_nMemberLevel < 0 then PlayObject.m_nMemberLevel := 0;
      end;
    '+': begin
        Inc(PlayObject.m_nMemberLevel, nLevel);
        if PlayObject.m_nMemberLevel > 65535 then PlayObject.m_nMemberLevel := 65535;
      end;
  end;
  if g_Config.boShowScriptActionMsg then begin
    PlayObject.SysMsg(Format(g_sChangeMemberLevelMsg, [PlayObject.m_nMemberLevel]), c_Green, t_Hint);
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfSetMemberLevel',[g_sExceptionVer]));
end;
end;

procedure TNormNpc.ActionOfSetMemberType(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nType: Integer;
  cMethod: Char;
begin
try
  //nType := Str_ToInt(QuestActionInfo.sParam2, -1);
  nType := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam2),-1);//20080501
  if nType < 0 then begin
    if not GetValValue(PlayObject, QuestActionInfo.sParam2, nType) then begin //增加变量支持
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_SETMEMBERTYPE);
      Exit;
    end;
  end;
  cMethod := QuestActionInfo.sParam1[1];
  case cMethod of
    '=': begin
        PlayObject.m_nMemberType := nType;
      end;
    '-': begin
        Dec(PlayObject.m_nMemberType, nType);
        if PlayObject.m_nMemberType < 0 then PlayObject.m_nMemberType := 0;
      end;
    '+': begin
        Inc(PlayObject.m_nMemberType, nType);
        if PlayObject.m_nMemberType > 65535 then PlayObject.m_nMemberType := 65535;
      end;
  end;
  if g_Config.boShowScriptActionMsg then begin
    PlayObject.SysMsg(Format(g_sChangeMemberTypeMsg, [PlayObject.m_nMemberType]), c_Green, t_Hint);
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfSetMemberType',[g_sExceptionVer]));
end;
end;
//检查一个地图内的怪物数量
function TNormNpc.ConditionOfCheckMonMapCount(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  I: Integer;
  sMapName: string;
  nCount: Integer;
  nMapRangeCount: Integer;
  Envir: TEnvirnoment;
  MonList: TList;
  BaseObject: TBaseObject;
  nCode: Byte;
begin
  nCode:= 0;
  try
    Result := False;
    sMapName := QuestConditionInfo.sParam1;
    nCode:= 1;
    //nCount := Str_ToInt(QuestConditionInfo.sParam2, -1);
    nCount := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
    if nCount < 0 then GetValValue(PlayObject, QuestConditionInfo.sParam2, nCount);
    nCode:= 2;
    Envir := g_MapManager.FindMap(sMapName);
    if (Envir = nil) or (nCount < 0) then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sCHECKMONMAP);
      Exit;
    end;
    nCode:= 3;
    MonList := TList.Create;
    try
      nCode:= 4;
      nMapRangeCount := UserEngine.GetMapMonster(Envir, MonList);
      nCode:= 5;
      for I := MonList.Count - 1 downto 0 do begin
        if MonList.Count <= 0 then Break;
        nCode:= 6;
        BaseObject := TBaseObject(MonList.Items[I]);
        if BaseObject <> nil then begin
          nCode:= 7;
          if (BaseObject.m_btRaceServer < RC_ANIMAL) or (BaseObject.m_btRaceServer = RC_ARCHERGUARD) or (BaseObject.m_Master <> nil) or (BaseObject.m_btRaceServer = RC_NPC) or (BaseObject.m_btRaceServer = RC_PEACENPC) then
            MonList.Delete(I);
        end;
      end;
      nCode:= 8;
      nMapRangeCount := MonList.Count;
      if nMapRangeCount >= nCount then Result := True;
    finally
      MonList.Free;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckMonMapCount Code:%d',[g_sExceptionVer, nCode]));
  end;
end;
//-----------------------------------------------------------------------------
//检测地图命令  20080426
//格式:ISONMAP 地图
function TNormNpc.ConditionOfISONMAP(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  sMapName: string;
  Envir: TEnvirnoment;
begin
  try
    Result := False;
    sMapName:=GetLineVariableText(PlayObject, QuestConditionInfo.sParam1); //地图支持变量
    Envir := g_MapManager.FindMap(sMapName);
    if Envir = nil then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_ISONMAP);
      Exit;
    end;
    if PlayObject.m_PEnvir = Envir then Result := True;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfISONMAP',[g_sExceptionVer]));
  end;
end;
//-----------------------------------------------------------------------------
//可以检查一个坐标范围内怪物数量
//格式：CheckRangeMonCount 地图号 X坐标 Y坐标 范围 控制符(=,>,<) 数量
function TNormNpc.ConditionOfCheckRangeMonCount(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  sMapName: string;
  I, nX, nY, nRange, nCount, nMapRangeCount: Integer;
  cMethod: Char;
  Envir: TEnvirnoment;
  MonList: TList;
  BaseObject: TBaseObject;
  nCode: byte;
begin
  nCode:= 0;
  try
    Result := False;
    sMapName:=GetLineVariableText(PlayObject, QuestConditionInfo.sParam1); //地图支持变量 20080125
    nCode:= 1;
    nX := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
    nY := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam3),-1);//20080501
    nCode:= 2;
    nRange := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam4),-1);//20080501
    nCount := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam6),-1);//20080501
    nCode:= 3;
    cMethod := QuestConditionInfo.sParam5[1];
    if nX < 0 then GetValValue(PlayObject, QuestConditionInfo.sParam2, nX);
    if nY < 0 then GetValValue(PlayObject, QuestConditionInfo.sParam3, nY);
    if nRange < 0 then GetValValue(PlayObject, QuestConditionInfo.sParam4, nRange);
    if nCount < 0 then GetValValue(PlayObject, QuestConditionInfo.sParam6, nCount);
    nCode:= 4;
    Envir := g_MapManager.FindMap(sMapName);
    if (Envir = nil) or (nX < 0) or (nY < 0) or (nRange < 0) or (nCount < 0) then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKRANGEMONCOUNT);
      Exit;
    end;
    nCode:= 5;
    MonList := TList.Create;
    try
      nCode:= 6;
      nMapRangeCount := Envir.GetRangeBaseObject(nX, nY, nRange, True, MonList);
      nCode:= 7;
      for I := MonList.Count - 1 downto 0 do begin
        if MonList.Count <= 0 then Break;
        try//20090802 增加
          BaseObject := TBaseObject(MonList.Items[I]);
          if BaseObject <> nil then begin//20090116
            if (BaseObject.m_btRaceServer < RC_ANIMAL) or (BaseObject.m_btRaceServer = RC_ARCHERGUARD) or (BaseObject.m_Master <> nil) or (BaseObject.m_btRaceServer = RC_NPC) or (BaseObject.m_btRaceServer = RC_PEACENPC) then
              Dec(nMapRangeCount);//20090705
              //MonList.Delete(I);
          end;
        except
        end;
      end;
      nCode:= 8;
      if nMapRangeCount < 0 then nMapRangeCount:= 0;//20090705
      case cMethod of
        '=': if nMapRangeCount = nCount then Result := True;
        '>': if nMapRangeCount > nCount then Result := True;
        '<': if nMapRangeCount < nCount then Result := True;
      else if nMapRangeCount >= nCount then Result := True;
      end;
    finally
      MonList.Free;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckRangeMonCount Code:%d',[g_sExceptionVer, nCode]));
  end;
end;

function TNormNpc.ConditionOfCheckReNewLevel(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nLevel: Integer;
  cMethod: Char;
begin
try
  Result := False;
  //nLevel := Str_ToInt(QuestConditionInfo.sParam2, -1);
  nLevel := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
  if nLevel < 0 then begin
    if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nLevel) then begin //增加变量支持
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKRENEWLEVEL);
      Exit;
    end;
  end;
  cMethod := QuestConditionInfo.sParam1[1];
  case cMethod of
    '=': if PlayObject.m_btReLevel = nLevel then Result := True;
    '>': if PlayObject.m_btReLevel > nLevel then Result := True;
    '<': if PlayObject.m_btReLevel < nLevel then Result := True;
  else if PlayObject.m_btReLevel >= nLevel then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckReNewLevel',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckSlaveLevel(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  I: Integer;
  nLevel: Integer;
  cMethod: Char;
  BaseObject: TBaseObject;
  nSlaveLevel: Integer;
begin
try
  Result := False;
  //nLevel := Str_ToInt(QuestConditionInfo.sParam2, -1);
  nLevel := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
  if nLevel < 0 then begin
    if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nLevel) then begin //增加变量支持
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKSLAVELEVEL);
      Exit;
    end;
  end;
  nSlaveLevel := -1;
  if PlayObject.m_SlaveList.Count > 0 then begin//20080629
    for I := 0 to PlayObject.m_SlaveList.Count - 1 do begin
      BaseObject := TBaseObject(PlayObject.m_SlaveList.Items[I]);
      if BaseObject.m_Abil.Level > nSlaveLevel then nSlaveLevel := BaseObject.m_Abil.Level;
    end;
  end;
  if nSlaveLevel < 0 then Exit;
  cMethod := QuestConditionInfo.sParam1[1];
  case cMethod of
    '=': if nSlaveLevel = nLevel then Result := True;
    '>': if nSlaveLevel > nLevel then Result := True;
    '<': if nSlaveLevel < nLevel then Result := True;
  else if nSlaveLevel >= nLevel then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckSlaveLevel',[g_sExceptionVer]));
end;
end;
//检查人物身上指定物品位置是否佩带指定物品名称（为空则检查人物身上指定位置是否佩带物品）
//格式:CHECKUSEITEM 物品位置(0-13) 物品名称 hero
function TNormNpc.ConditionOfCheckUseItem(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nWhere: Integer;
  sItmeName: String;
  StdItem: pTStdItem;
begin
  try
    Result := False;
    //nWhere := Str_ToInt(QuestConditionInfo.sParam1, -1);
    nWhere := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam1),-1);//20080501
    sItmeName := GetLineVariableText(PlayObject,QuestConditionInfo.sParam2);//20080605 物品名称
    if nWhere < 0 then GetValValue(PlayObject, QuestConditionInfo.sParam1, nWhere);
    if (nWhere < 0) or {$IF M2Version <> 2}(nWhere > High(THumanUseItems)){$ELSE}(nWhere > High(THumItems)){$IFEND} then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKUSEITEM);
      Exit;
    end;
    if (CompareText(QuestConditionInfo.sParam3, 'HERO') = 0) then begin//支持英雄 20100627
      {$IF HEROVERSION = 1}
      if ((not PlayObject.m_boHasHero) or (not PlayObject.m_boHasHeroTwo)) and (PlayObject.m_sHeroCharName ='') then Exit;
      if PlayObject.m_MyHero <> nil then begin
        if sItmeName <> '' then begin
          StdItem := UserEngine.GetStdItem(PlayObject.m_MyHero.m_UseItems[nWhere].wIndex);
          if (StdItem <> nil) then begin
            if CompareText(StdItem.Name, sItmeName) = 0 then  Result := True;
          end;
        end else
        if PlayObject.m_MyHero.m_UseItems[nWhere].wIndex > 0 then Result := True;
      end;
      {$IFEND}
    end else begin
      if sItmeName <> '' then begin
        StdItem := UserEngine.GetStdItem(PlayObject.m_UseItems[nWhere].wIndex);
        if (StdItem <> nil) then begin
          if CompareText(StdItem.Name, sItmeName) = 0 then  Result := True;
        end;
      end else
      if PlayObject.m_UseItems[nWhere].wIndex > 0 then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckUseItem',[g_sExceptionVer]));
  end;
end;

function TNormNpc.ConditionOfCheckVar(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  I: Integer;
  sType: string;
  sVarName: string;
  sVarValue: string;
  nVarValue: {Integer}LongWord;//20101114
  sName: string;
  sMethod: string;
  cMethod: Char;
  DynamicVar: pTDynamicVar;
  boFoundVar: Boolean;
  DynamicVarList: TList;
resourcestring
  sVarFound = '变量%s已存在，变量类型:%s';
  sVarTypeError = '变量类型错误，错误类型:%s 当前支持类型(HUMAN、GUILD、GLOBAL)';
begin
  try
    Result := False;
    sType := QuestConditionInfo.sParam1;
    sVarName := QuestConditionInfo.sParam2;
    sMethod := QuestConditionInfo.sParam3;
    //nVarValue := Str_ToInt(QuestConditionInfo.sParam4, 0);
    //sVarValue := QuestConditionInfo.sParam4;  
    nVarValue := Str_ToInt(GetLineVariableText(PlayObject, QuestConditionInfo.sParam4),0);//20080601 支持变量
    sVarValue := GetLineVariableText(PlayObject, QuestConditionInfo.sParam4);//20080601 支持变量

    if (sType = '') or (sVarName = '') or (sMethod = '') then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKVAR+'-1');
      Exit;
    end;
    cMethod := sMethod[1];
    DynamicVarList := GetDynamicVarList(PlayObject, sType, sName);
    if DynamicVarList = nil then begin
      ScriptConditionError(PlayObject {,format(sVarTypeError,[sType])}, QuestConditionInfo, sSC_CHECKVAR+'-2');
      Exit;
    end else begin
      if DynamicVarList.Count > 0 then begin//20080629
        for I := 0 to DynamicVarList.Count - 1 do begin
          DynamicVar := DynamicVarList.Items[I];
          if DynamicVar <> nil then begin
            if CompareText(DynamicVar.sName, sVarName) = 0 then begin
              case DynamicVar.VarType of
                vInteger: begin
                    case cMethod of
                      '=': if DynamicVar.nInternet = nVarValue then Result := True;
                      '>': if DynamicVar.nInternet > nVarValue then Result := True;
                      '<': if DynamicVar.nInternet < nVarValue then Result := True;
                    else if DynamicVar.nInternet >= nVarValue then Result := True;
                    end;
                  end;
                vString: begin
                    case cMethod of//20080603 增加字符串对比
                     '=':if CompareText(DynamicVar.sString, sVarValue) = 0 then Result := True;
                    end;
                  end;
              end;
              boFoundVar := True;
              Break;
            end;
          end;
        end;//for
      end;
      if not boFoundVar then
        ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKVAR+'-3');
    end;
  except
    //MainOutMessage('{异常} TNormNpc.ConditionOfCheckVar');
  end;
end;

function TNormNpc.ConditionOfHaveMaster(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
  try
    Result := False;
    if PlayObject.m_sMasterName <> '' then Result := True;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfHaveMaster',[g_sExceptionVer]));
  end;
end;

function TNormNpc.ConditionOfPoseHaveMaster(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  PoseHuman: TBaseObject;
begin
  try
    Result := False;
    PoseHuman := PlayObject.GetPoseCreate();
    if (PoseHuman <> nil) then begin
      if (PoseHuman.m_btRaceServer = RC_PLAYOBJECT) then begin
        if (TPlayObject(PoseHuman).m_sMasterName <> '') then Result := True;
      end;  
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfPoseHaveMaster',[g_sExceptionVer]));
  end;
end;
//出师
procedure TNormNpc.ActionOfUnMaster(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  PoseHuman: TPlayObject;
  sMsg: string;
  I: Integer;
begin
  try
    if QuestActionInfo.sParam1 = '' then begin
      if PlayObject.m_sMasterName = '' then begin
        GotoLable(PlayObject, '@ExeMasterFail', False, False);
        Exit;
      end;
      PoseHuman := UserEngine.GetPlayObject(PlayObject.m_sMasterName);//检查师傅是否在线
      if PoseHuman <> nil then begin//师傅在线
        if PoseHuman.m_btRaceServer <> RC_PLAYOBJECT then begin//角色类型不对
          GotoLable(PlayObject, '@UnMasterTypeErr', False, False);
          Exit;
        end;
        if PoseHuman.IsMyApprentice(PlayObject.m_sCharName) then begin//检查是否为自己的徒弟
          if (PlayObject.m_sMasterName = PoseHuman.m_sCharName) then begin
            if PlayObject.m_boMaster then begin
              GotoLable(PlayObject, '@UnIsMaster', False, False);//必须由徒弟发起
              Exit;
            end;
            if PlayObject.m_sMasterName <> PoseHuman.m_sCharName then begin
              GotoLable(PlayObject, '@UnMasterError', False, False);//名字对应不上
              Exit;
            end;

            GotoLable(PlayObject, '@StartUnMaster', False, False);//出师开始提示
            GotoLable(PoseHuman, '@WateUnMaster', False, False);//出师开始提示
            Exit;
          end;
        end;
      end else begin//师傅不在线
        GotoLable(PlayObject, '@UnMasterCheckDir', False, False);//师傅不在线，是否强行出师
        Exit;
      end; 
    end;

    if (CompareText(QuestActionInfo.sParam1, 'REQUESTUNMASTER') = 0) then begin//正常出师
      if (QuestActionInfo.sParam2 = '') then begin
        PoseHuman := UserEngine.GetPlayObject(PlayObject.m_sMasterName);//检查师傅是否在线
        if PoseHuman <> nil then begin //PoseHuman-师傅 PlayObject-徒弟    师傅在线
          if PoseHuman.IsMyApprentice(PlayObject.m_sCharName) then begin//检查是否为自己的徒弟
            PlayObject.m_boStartUnMaster := True;
            PlayObject.m_PoseBaseObject := PoseHuman;
            PoseHuman.m_PoseBaseObject := PlayObject;
            if PlayObject.m_boStartUnMaster and PoseHuman.m_boStartUnMaster then begin
              sMsg := AnsiReplaceText(g_sNPCSayUnMasterOKMsg, '%n', m_sCharName);
              sMsg := AnsiReplaceText(sMsg, '%s', PlayObject.m_sCharName);
              sMsg := AnsiReplaceText(sMsg, '%d', PoseHuman.m_sCharName);
              UserEngine.SendBroadCastMsg(sMsg, t_Say);
              PlayObject.m_sMasterName := '';
              PoseHuman.m_sMasterName := '';
              PlayObject.m_boStartUnMaster := False;
              PoseHuman.m_boStartUnMaster := False;
              PoseHuman.DelMaster(PlayObject.m_sCharName);//出师 20080530
              for I := PoseHuman.m_MasterList.Count - 1 downto 0 do begin
                if PoseHuman.m_MasterList.Count <= 0 then Break;
                if TPlayObject(PoseHuman.m_MasterList.Items[I]) <> nil then begin
                  if (TPlayObject(PoseHuman.m_MasterList.Items[I]) = PlayObject) then begin
                    PoseHuman.m_MasterList.Delete(I);
                    Break;
                  end;
                end;
              end;//for

              if g_FunctionNPC <> nil then begin
                g_FunctionNPC.GotoLable(PoseHuman, '@UnMasterEnd', False, False);//师傅触发 20080530
                g_FunctionNPC.GotoLable(PlayObject, '@UnMasterEnd1', False, False);//徒弟触发 20080530
              end;
              PlayObject.RefShowName;
              PoseHuman.RefShowName;
              GotoLable(PlayObject, '@RequestUnMasterEnd', False, False);
              if g_FunctionNPC <> nil then begin
                g_FunctionNPC.GotoLable(PoseHuman, '@PoseUnMasterEnd', False, False);
              end;
            end else begin
              GotoLable(PlayObject, '@WateUnMaster', False, False);
              if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(PoseHuman, '@RevUnMaster', False, False);
            end;
          end;
        end else begin//师傅不在线，直接强出师
          GotoLable(PlayObject, '@UnMasterCheckDir', False, False);//师傅不在线，是否强行出师
        end;
        Exit;
      end else
      if (CompareText(QuestActionInfo.sParam2, 'MASTER') = 0) then begin//师傅点确定
        PlayObject.m_boStartUnMaster := True;
        if PlayObject.m_PoseBaseObject <> nil then begin
          if PlayObject.m_PoseBaseObject.m_btRaceServer = RC_PLAYOBJECT then begin//是人物
            if PlayObject.IsMyApprentice(PlayObject.m_PoseBaseObject.m_sCharName) then begin//检查是否为自己的徒弟
              if PlayObject.m_boStartUnMaster and TPlayObject(PlayObject.m_PoseBaseObject).m_boStartUnMaster then begin
                sMsg := AnsiReplaceText(g_sNPCSayUnMasterOKMsg, '%n', m_sCharName);
                sMsg := AnsiReplaceText(sMsg, '%s', PlayObject.m_sCharName);
                sMsg := AnsiReplaceText(sMsg, '%d', PlayObject.m_PoseBaseObject.m_sCharName);
                UserEngine.SendBroadCastMsg(sMsg, t_Say);
                PlayObject.m_sMasterName := '';
                TPlayObject(PlayObject.m_PoseBaseObject).m_sMasterName := '';
                PlayObject.m_boStartUnMaster := False;
                TPlayObject(PlayObject.m_PoseBaseObject).m_boStartUnMaster := False;

                PlayObject.DelMaster(TPlayObject(PlayObject.m_PoseBaseObject).m_sCharName);//出师
                for I := PlayObject.m_MasterList.Count - 1 downto 0 do begin
                  if PlayObject.m_MasterList.Count <= 0 then Break;
                  if TPlayObject(PlayObject.m_MasterList.Items[I]) <> nil then begin
                    if (TPlayObject(PlayObject.m_MasterList.Items[I]) = PlayObject.m_PoseBaseObject) then begin
                      PlayObject.m_MasterList.Delete(I);
                      Break;
                    end;
                  end;
                end;//for

                if g_FunctionNPC <> nil then begin
                  g_FunctionNPC.GotoLable(PlayObject, '@UnMasterEnd', False, False);//师傅触发 20080530
                  g_FunctionNPC.GotoLable(TPlayObject(PlayObject.m_PoseBaseObject), '@UnMasterEnd1', False, False);//徒弟触发 20080530
                end;
                PlayObject.RefShowName;
                TPlayObject(PlayObject.m_PoseBaseObject).RefShowName;
                GotoLable(PlayObject, '@PoseUnMasterEnd', False, False);//师傅 QF
                GotoLable(TPlayObject(PlayObject.m_PoseBaseObject), '@RequestUnMasterEnd', False, False);//徒弟 QF

                if PlayObject.m_PoseBaseObject <> nil then begin
                  TPlayObject(PlayObject.m_PoseBaseObject).m_PoseBaseObject:= nil;
                end;
                PlayObject.m_PoseBaseObject:= nil;
                Exit;
              end;
            end;
          end;
          if PlayObject.m_PoseBaseObject <> nil then begin
            TPlayObject(PlayObject.m_PoseBaseObject).m_boStartUnMaster := False;
            TPlayObject(PlayObject.m_PoseBaseObject).m_PoseBaseObject:= nil;
          end;
          PlayObject.m_boStartUnMaster := False;
          PlayObject.m_PoseBaseObject:= nil;
        end;
      end else
      if (CompareText(QuestActionInfo.sParam2, 'FORCE') = 0) then begin //强行出师
        sMsg := AnsiReplaceText(g_sNPCSayForceUnMasterMsg, '%n', m_sCharName);
        sMsg := AnsiReplaceText(sMsg, '%s', PlayObject.m_sCharName);
        sMsg := AnsiReplaceText(sMsg, '%d', PlayObject.m_sMasterName);
        UserEngine.SendBroadCastMsg(sMsg, t_Say);
        if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(PlayObject, '@UnMasterEnd1', False, False);//徒弟触发 20080530

        PoseHuman := UserEngine.GetPlayObject(PlayObject.m_sMasterName);
        if PoseHuman <> nil then begin
          PoseHuman.m_sMasterName := '';
          PoseHuman.DelMaster(PlayObject.m_sCharName);//出师 20080530
          for I := PoseHuman.m_MasterList.Count - 1 downto 0 do begin
            if PoseHuman.m_MasterList.Count <= 0 then Break;
            if TPlayObject(PoseHuman.m_MasterList.Items[I]) <> nil then begin
              if (TPlayObject(PoseHuman.m_MasterList.Items[I]) = PlayObject) then begin
                PoseHuman.m_MasterList.Delete(I);
                Break;
              end;
            end;
          end;//for

          if g_FunctionNPC <> nil then begin
            g_FunctionNPC.GotoLable(PoseHuman, '@UnMasterEnd', False, False);//师傅触发 20080530
          end;
          PoseHuman.RefShowName;
        end else begin
          g_UnForceMasterList.Lock;
          try
            g_UnForceMasterList.Add(PlayObject.m_sMasterName+' '+PlayObject.m_sCharName);// 20080530
            SaveUnForceMasterList();
          finally
            g_UnForceMasterList.UnLock;
          end;
        end;
        PlayObject.m_sMasterName := '';
        GotoLable(PlayObject, '@RequestUnMasterEnd', False, False);
        PlayObject.RefShowName;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfUnMaster',[g_sExceptionVer]));
  end;
end;


function TNormNpc.ConditionOfCheckCastleGold(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethod: Char;
  nGold: Integer;
begin
try
  Result := False;
  //nGold := Str_ToInt(QuestConditionInfo.sParam2, -1);
  nGold := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
  if nGold < 0 then GetValValue(PlayObject, QuestConditionInfo.sParam2, nGold);
  if (nGold < 0) or (m_Castle = nil) then begin
    ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKCASTLEGOLD);
    Exit;
  end;
  cMethod := QuestConditionInfo.sParam1[1];
  case cMethod of
    '=': if TUserCastle(m_Castle).m_nTotalGold = nGold then Result := True;
    '>': if TUserCastle(m_Castle).m_nTotalGold > nGold then Result := True;
    '<': if TUserCastle(m_Castle).m_nTotalGold < nGold then Result := True;
  else if TUserCastle(m_Castle).m_nTotalGold >= nGold then Result := True;
  end;
  {
  Result:=False;
  nGold:=Str_ToInt(QuestConditionInfo.sParam2, -1);
  if nGold < 0 then begin
    ScriptConditionError(PlayObject,QuestConditionInfo,sSC_CHECKCASTLEGOLD);
    exit;
  end;
  cMethod:=QuestConditionInfo.sParam1[1];
  case cMethod of
    '=': if UserCastle.m_nTotalGold = nGold then Result:=True;
    '>': if UserCastle.m_nTotalGold > nGold then Result:=True;
    '<': if UserCastle.m_nTotalGold < nGold then Result:=True;
    else if UserCastle.m_nTotalGold >= nGold then Result:=True;
  end;
  }
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckCastleGold',[g_sExceptionVer]));
end;
end;


function TNormNpc.ConditionOfCheckContribution(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nContribution: Integer;
  cMethod: Char;
begin
try
  Result := False;
  //nContribution := Str_ToInt(QuestConditionInfo.sParam2, -1);
  nContribution := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
  if nContribution < 0 then begin
    if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nContribution) then begin //增加变量支持
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKCONTRIBUTION);
      Exit;
    end;
  end;
  cMethod := QuestConditionInfo.sParam1[1];
  case cMethod of
    '=': if PlayObject.m_wContribution = nContribution then Result := True;
    '>': if PlayObject.m_wContribution > nContribution then Result := True;
    '<': if PlayObject.m_wContribution < nContribution then Result := True;
  else if PlayObject.m_wContribution >= nContribution then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckContribution',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckCreditPoint(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nCreditPoint: Integer;
  cMethod: Char;
begin
try
  Result := False;
  //nCreditPoint := Str_ToInt(QuestConditionInfo.sParam2, -1);
  nCreditPoint := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
  if nCreditPoint < 0 then begin
    if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nCreditPoint) then begin //增加变量支持
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKCREDITPOINT);
      Exit;
    end;
  end;
  cMethod := QuestConditionInfo.sParam1[1];
  case cMethod of
    '=': if PlayObject.m_btCreditPoint = nCreditPoint then Result := True;
    '>': if PlayObject.m_btCreditPoint > nCreditPoint then Result := True;
    '<': if PlayObject.m_btCreditPoint < nCreditPoint then Result := True;
  else if PlayObject.m_btCreditPoint >= nCreditPoint then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckCreditPoint',[g_sExceptionVer]));
end;
end;

procedure TNormNpc.ActionOfClearNeedItems(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I: Integer;
  nNeed: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
try
  //nNeed := Str_ToInt(QuestActionInfo.sParam1, -1);
  nNeed := Str_ToInt(GetLineVariableText(PlayObject,QuestActionInfo.sParam1),-1);//20080501
  if (nNeed < 0) then begin
    if not GetValValue(PlayObject, QuestActionInfo.sParam1, nNeed) then begin //增加变量支持
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CLEARNEEDITEMS);
      Exit;
    end;
  end;
  for I := PlayObject.m_ItemList.Count - 1 downto 0 do begin
    if PlayObject.m_ItemList.Count <= 0 then Break;
    UserItem := PlayObject.m_ItemList.Items[I];
    if UserItem = nil then Continue;
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if (StdItem <> nil) and (StdItem.Need = nNeed) then begin
      PlayObject.SendDelItems(UserItem);
      PlayObject.m_ItemList.Delete(I);
      Dispose(UserItem);
    end;
  end;

  for I := PlayObject.m_StorageItemList.Count - 1 downto 0 do begin
    if PlayObject.m_StorageItemList.Count <= 0 then Break;
    UserItem := PlayObject.m_StorageItemList.Items[I];
    if UserItem = nil then Continue;
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if (StdItem <> nil) and (StdItem.Need = nNeed) then begin
      Dispose(UserItem);
      PlayObject.m_StorageItemList.Delete(I);
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfClearNeedItems',[g_sExceptionVer]));
end;
end;

procedure TNormNpc.ActionOfClearMakeItems(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I: Integer;
  nMakeIndex: Integer;
  sItemName: string;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  boMatchName: Boolean;
begin
try
  sItemName := QuestActionInfo.sParam1;
  nMakeIndex := QuestActionInfo.nParam2;
  boMatchName := QuestActionInfo.sParam3 = '1';
  if (sItemName = '') or (nMakeIndex <= 0) then begin
    ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CLEARMAKEITEMS);
    Exit;
  end;

  for I := PlayObject.m_ItemList.Count - 1 downto 0 do begin
    if PlayObject.m_ItemList.Count <= 0 then Break;
    UserItem := PlayObject.m_ItemList.Items[I];
    if UserItem = nil then Continue;
    if UserItem.MakeIndex <> nMakeIndex then Continue;
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if not boMatchName or ((StdItem <> nil) and (CompareText(StdItem.Name, sItemName) = 0)) then begin
      PlayObject.SendDelItems(UserItem);
      Dispose(UserItem);
      PlayObject.m_ItemList.Delete(I);
    end;
  end;

  for I := PlayObject.m_StorageItemList.Count - 1 downto 0 do begin
    if PlayObject.m_StorageItemList.Count <= 0 then Break;
    //UserItem := PlayObject.m_ItemList.Items[I];
    UserItem := PlayObject.m_StorageItemList.Items[I]; //20100913 修改
    if UserItem = nil then Continue;
    if UserItem.MakeIndex <> nMakeIndex then Continue;
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if not boMatchName or ((StdItem <> nil) and (CompareText(StdItem.Name, sItemName) = 0)) then begin
      Dispose(UserItem);
      PlayObject.m_StorageItemList.Delete(I);
    end;
  end;

  for I := Low(PlayObject.m_UseItems) to High(PlayObject.m_UseItems) do begin
    UserItem := @PlayObject.m_UseItems[I];
    if UserItem.MakeIndex <> nMakeIndex then Continue;
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if not boMatchName or ((StdItem <> nil) and (CompareText(StdItem.Name, sItemName) = 0)) then begin
      UserItem.wIndex := 0;
    end;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ActionOfClearMakeItems',[g_sExceptionVer]));
end;
end;
//发送祝福语
procedure TNormNpc.SendCustemMsg(PlayObject: TPlayObject; sMsg: string);
begin
  try
    if not g_Config.boSendCustemMsg then begin
      PlayObject.SysMsg(g_sSendCustMsgCanNotUseNowMsg, c_Red, t_Hint);
      Exit;
    end;
    if PlayObject.m_boSendMsgFlag then begin
      PlayObject.m_boSendMsgFlag := False;
      UserEngine.SendBroadCastMsg(PlayObject.m_sCharName + ': ' + sMsg, t_Cust);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.SendCustemMsg',[g_sExceptionVer]));
  end;
end;

function TNormNpc.ConditionOfCheckOfGuild(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  sGuildName: string;
begin
  try
    Result := False;
    if QuestConditionInfo.sParam1 = '' then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKOFGUILD);
      Exit;
    end;
    if (PlayObject.m_MyGuild <> nil) then begin
      if (QuestConditionInfo.sParam1 <> '') and (QuestConditionInfo.sParam1[1] = '<') and (QuestConditionInfo.sParam1[2] = '$') then//增加支持<$Str()>  20080506
        sGuildName := GetLineVariableText(PlayObject,QuestConditionInfo.sParam1)//20100804 增加
      else
      if not GetValValue(PlayObject, QuestConditionInfo.sParam1, sGuildName) then begin //增加变量支持
        sGuildName := QuestConditionInfo.sParam1;
      end;
      if CompareText(TGUild(PlayObject.m_MyGuild).sGuildName, sGuildName) = 0 then begin
        Result := True;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckOfGuild',[g_sExceptionVer]));
  end;
end;

function TNormNpc.ConditionOfCheckOnlineLongMin(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  cMethod: Char;
  nOnlineMin: Integer;
  nOnlineTime: Integer;
begin
try
  Result := False;
  //nOnlineMin := Str_ToInt(QuestConditionInfo.sParam2, -1);
  nOnlineMin := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
  if nOnlineMin < 0 then begin
    if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nOnlineMin) then begin //增加变量支持
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_ONLINELONGMIN);
      Exit;
    end;
  end;
  nOnlineTime := (GetTickCount - PlayObject.m_dwLogonTick) div 60000;
  cMethod := QuestConditionInfo.sParam1[1];
  case cMethod of
    '=': if nOnlineTime = nOnlineMin then Result := True;
    '>': if nOnlineTime > nOnlineMin then Result := True;
    '<': if nOnlineTime < nOnlineMin then Result := True;
  else if nOnlineTime >= nOnlineMin then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckOnlineLongMin',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckPasswordErrorCount(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nErrorCount: Integer;
  cMethod: Char;
begin
try
  Result := False;
  //nErrorCount := Str_ToInt(QuestConditionInfo.sParam2, -1);
  nErrorCount := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam2),-1);//20080501
  if nErrorCount < 0 then begin
    if not GetValValue(PlayObject, QuestConditionInfo.sParam2, nErrorCount) then begin //增加变量支持
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_PASSWORDERRORCOUNT);
      Exit;
    end;
  end;
  cMethod := QuestConditionInfo.sParam1[1];
  case cMethod of
    '=': if PlayObject.m_btPwdFailCount = nErrorCount then Result := True;
    '>': if PlayObject.m_btPwdFailCount > nErrorCount then Result := True;
    '<': if PlayObject.m_btPwdFailCount < nErrorCount then Result := True;
  else if PlayObject.m_btPwdFailCount >= nErrorCount then Result := True;
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckPasswordErrorCount',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfIsLockPassword(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
try
  Result := PlayObject.m_boPasswordLocked;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfIsLockPassword',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfIsLockStorage(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
begin
try
  Result := not PlayObject.m_boCanGetBackItem;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfIsLockStorage',[g_sExceptionVer]));
end;
end;
//检查角色的充值模式
function TNormNpc.ConditionOfCheckPayMent(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nPayMent: Integer;
begin
try
  Result := False;
  nPayMent := Str_ToInt(QuestConditionInfo.sParam1, -1);
  if nPayMent < 1 then begin
    if not GetValValue(PlayObject, QuestConditionInfo.sParam1, nPayMent) then begin //增加变量支持
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKPAYMENT);
      Exit;
    end;
  end;
  if PlayObject.m_nPayMent = nPayMent then Result := True;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckPayMent',[g_sExceptionVer]));
end;
end;
//功能：检测人物宝宝中是否有宠物类宝宝
//格式：CHECKSLAVETOPEST
function TNormNpc.ConditionOfCHECKSLAVETOPEST(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  I: Integer;
  BaseObject: TBaseObject;
begin
  try
    Result := False;
    if PlayObject.m_SlaveList.Count > 0 then begin//20080629
      for I := 0 to PlayObject.m_SlaveList.Count - 1 do begin
        BaseObject := TBaseObject(PlayObject.m_SlaveList.Items[I]);
        if BaseObject.m_btRaceServer = 158 then begin
          Result := True;
          Break;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCHECKSLAVETOPEST',[g_sExceptionVer]));
  end;
end;  
//功能：检测人物宝宝中是否含有指定名字的宝宝
//格式：CHECKSLAVENAME 下属名字
function TNormNpc.ConditionOfCheckSlaveName(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  I: Integer;
  sSlaveName: string;
  BaseObject: TBaseObject;
begin
  try
    Result := False;
    sSlaveName:= GetLineVariableText(PlayObject, QuestConditionInfo.sParam1);
    if sSlaveName = '' then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKSLAVENAME);
      Exit;
    end;
    if PlayObject.m_SlaveList.Count > 0 then begin//20080629
      for I := 0 to PlayObject.m_SlaveList.Count - 1 do begin
        BaseObject := TBaseObject(PlayObject.m_SlaveList.Items[I]);
        if CompareText(sSlaveName, BaseObject.m_sCharName) = 0 then begin
          Result := True;
          Break;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckSlaveName',[g_sExceptionVer]));
  end;
end;
//升级物品
procedure TNormNpc.ActionOfUpgradeItems(PlayObject: TPlayObject; QuestActionInfo: pTQuestActionInfo);
var
  nRate, nWhere, nValType, nPoint, nAddPoint: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
  try
    nWhere := Str_ToInt(QuestActionInfo.sParam1, -1);
    nRate := Str_ToInt(QuestActionInfo.sParam2, -1);
    nPoint := Str_ToInt(QuestActionInfo.sParam3, -1);
    if nWhere < 0 then GetValValue(PlayObject, QuestActionInfo.sParam1, nWhere); //增加变量支持
    if nRate < 0 then GetValValue(PlayObject, QuestActionInfo.sParam2, nRate); //增加变量支持
    if nPoint < 0 then GetValValue(PlayObject, QuestActionInfo.sParam3, nPoint); //增加变量支持
    if (nWhere < 0) or {$IF M2Version <> 2}(nWhere > High(THumanUseItems)){$ELSE}(nWhere > High(THumItems)){$IFEND} or (nRate < 0) or (nPoint < 0) or (nPoint > 255) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_UPGRADEITEMS);
      Exit;
    end;
    UserItem := @PlayObject.m_UseItems[nWhere];
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if (UserItem.wIndex <= 0) or (StdItem = nil) then begin
      PlayObject.SysMsg('您身上没有戴指定物品！！！', c_Red, t_Hint);
      Exit;
    end;
    nRate := Random(nRate);
    nPoint := Random(nPoint);
    nValType := Random(16);//20080324
    if nRate <> 0 then begin
      PlayObject.SysMsg('装备升级失败！！！', c_Red, t_Hint);
      Exit;
    end;

    UserItem.btValue[9] := _MIN(255, UserItem.btValue[9] + 1);//累积升级次数 20080816
    {$IF M2Version <> 2}
    if (nValType = 11) and (StdItem.StdMode in [5, 6]) then begin//武器时，11位置为暴击等级 20100708
      UserItem.btValue[nValType] := nPoint;
    end else
    {$IFEND}
    if (nValType = 15) and ((StdItem.Shape = 188) or (StdItem.Shape = 203)) then begin//吸伤属性 20080324
      if nWhere <> U_WEAPON then begin//武器位不能有吸伤属性 20101007
        UserItem.btValue[20] := UserItem.btValue[20] + nPoint;
        if UserItem.btValue[20] > 100 then UserItem.btValue[20] := 100;
      end;
    end else
    if nValType = 14 then begin
      nAddPoint := (nPoint * 1000);
      if UserItem.DuraMax + nAddPoint > High(Word) then begin
        nAddPoint := High(Word) - UserItem.DuraMax;
      end;
      UserItem.DuraMax := UserItem.DuraMax + nAddPoint;
    end else begin
      nAddPoint := nPoint;
      if UserItem.btValue[nValType] + nAddPoint > High(Byte) then begin
        nAddPoint := High(Byte) - UserItem.btValue[nValType];
      end;
      UserItem.btValue[nValType] := UserItem.btValue[nValType] + nAddPoint;
     if StdItem.NeedIdentify = 1 then//20080613 装备升级日志
        AddGameDataLog('31' + #9 +
          PlayObject.m_sMapName + #9 +
          IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
          PlayObject.m_sCharName + #9 + StdItem.Name + #9 +
          IntToStr(UserItem.MakeIndex) + #9 +
          '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
          '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
          '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
          '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
          '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
          IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
          IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
          IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
          IntToStr(UserItem.btValue[14])+ #9 + IntToStr(UserItem.Dura)+'/'+IntToStr(UserItem.DuraMax));
    end;
    PlayObject.SendUpdateItem(UserItem);
    PlayObject.SysMsg('装备升级成功', c_Green, t_Hint);
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfUpgradeItems',[g_sExceptionVer]));
  end;
end;
//升级物品
//UPGRADEITEMEX(UPGRADEITEM) 位置 项目 机率(0即100%) 增加点数 点数是否固定(0-随机 1-固定)
//UPGRADEITEMEX 3 15 0 10 (15--吸伤)
procedure TNormNpc.ActionOfUpgradeItemsEx(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  nRate, nWhere, nValType, nPoint, nAddPoint: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  nUpgradeItemStatus: Integer;
  nRatePoint: Integer;
  boNoPointRandom: Boolean;
begin
  try
    nWhere := Str_ToInt(QuestActionInfo.sParam1, -1);//位置
    nValType := Str_ToInt(QuestActionInfo.sParam2, -1);//项目
    nRate := Str_ToInt(QuestActionInfo.sParam3, -1);//机率
    nPoint := Str_ToInt(QuestActionInfo.sParam4, -1);//增加点数
    boNoPointRandom := Str_ToInt(QuestActionInfo.sParam5, 0) <> 0;//是否点数随机
    if nWhere < 0 then GetValValue(PlayObject, QuestActionInfo.sParam1, nWhere); //增加变量支持
    if nValType < 0 then GetValValue(PlayObject, QuestActionInfo.sParam2, nValType); //增加变量支持
    if nRate < 0 then GetValValue(PlayObject, QuestActionInfo.sParam3, nRate); //增加变量支持
    if nPoint < 0 then GetValValue(PlayObject, QuestActionInfo.sParam4, nPoint); //增加变量支持
    nUpgradeItemStatus := Str_ToInt(QuestActionInfo.sParam5, -1);
    if (nValType < 0) or (nValType > 15) or (nWhere < 0) or {$IF M2Version <> 2}(nWhere > High(THumanUseItems)){$ELSE}(nWhere > High(THumItems)){$IFEND} or (nRate < 0) or (nPoint < 0) or (nPoint > 255) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_UPGRADEITEMSEX);
      Exit;
    end;
    UserItem := @PlayObject.m_UseItems[nWhere];
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if (UserItem.wIndex <= 0) or (StdItem = nil) then begin
      PlayObject.SysMsg('您身上没有戴指定物品！！！', c_Red, t_Hint);
      Exit;
    end;
    nRatePoint := Random(nRate * 10);
    if not boNoPointRandom then nPoint := _MAX(1, Random(nPoint));

    if not (nRatePoint in [0..10]) then begin
      case nUpgradeItemStatus of //
        0: begin
            PlayObject.SysMsg('装备升级未成功！！！', c_Red, t_Hint);
          end;
        1: begin
            PlayObject.SendDelItems(UserItem);
            UserItem.wIndex := 0;
            PlayObject.SysMsg('装备破碎！！！', c_Red, t_Hint);
          end;
        2: begin
            PlayObject.SysMsg('装备升级失败，装备属性恢复默认！！！', c_Red, t_Hint);
            if nValType <> 14 then UserItem.btValue[nValType] := 0;
            if (nValType = 15) and ((StdItem.Shape = 188) or (StdItem.Shape = 203)) then begin
              UserItem.btValue[20] := 0;
            end;
          end;
      end;
      Exit;
    end;
    UserItem.btValue[9] := _MIN(255, UserItem.btValue[9] + 1);//累积升级次数 20080816
    {$IF M2Version <> 2}
    if (nValType = 11) and (StdItem.StdMode in [5, 6]) then begin//武器时，11位置为暴击等级 20100708
      UserItem.btValue[nValType] := nPoint;
    end else
    {$IFEND}
    if (nValType = 15) and ((StdItem.Shape = 188) or (StdItem.Shape = 203)) then begin//吸伤属性 20080324
      if nWhere <> U_WEAPON then begin//武器位不能有吸伤属性 20101007
        UserItem.btValue[20] := UserItem.btValue[20] + nPoint;
        if UserItem.btValue[20] > 100 then UserItem.btValue[20] := 100;
      end;
    end else
    if nValType = 14 then begin
      nAddPoint := (nPoint * 1000);
      if UserItem.DuraMax + nAddPoint > High(Word) then begin
        nAddPoint := High(Word) - UserItem.DuraMax;
      end;
      UserItem.DuraMax := UserItem.DuraMax + nAddPoint;
    end else begin
      nAddPoint := nPoint;
      if UserItem.btValue[nValType] + nAddPoint > High(Byte) then begin
        nAddPoint := High(Byte) - UserItem.btValue[nValType];
      end;
      UserItem.btValue[nValType] := UserItem.btValue[nValType] + nAddPoint;
    end;
    PlayObject.SendUpdateItem(UserItem);
    PlayObject.SysMsg('装备升级成功', c_Green, t_Hint);
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfUpgradeItemsEx',[g_sExceptionVer]));
  end;
end;
//声明变量
//VAR 数据类型(Integer String) 类型(HUMAN GUILD GLOBAL) 变量值
procedure TNormNpc.ActionOfVar(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I: Integer;
  sType: string;
  VarType: TVarType;
  sVarName: string;
  sVarValue: string;
  nVarValue: {Integer}LongWord;//20101114
  sName: string;
  DynamicVar: pTDynamicVar;
  boFoundVar: Boolean;
  DynamicVarList: TList;
resourcestring
  sVarFound = '变量%s已存在，变量类型:%s';
  sVarTypeError = '变量类型错误，错误类型:%s 当前支持类型(HUMAN、GUILD、GLOBAL)';
begin
  try
    sType := QuestActionInfo.sParam2;
    sVarName := QuestActionInfo.sParam3;
    sVarValue := QuestActionInfo.sParam4;
    nVarValue := Str_ToInt(QuestActionInfo.sParam4, 0);
    VarType := vNone;
    if CompareText(QuestActionInfo.sParam1, 'Integer') = 0 then VarType := vInteger;
    if CompareText(QuestActionInfo.sParam1, 'String') = 0 then VarType := vString;

    if (sType = '') or (sVarName = '') or (VarType = vNone) then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_VAR);
      Exit;
    end;
    New(DynamicVar);
    DynamicVar.sName := sVarName;
    DynamicVar.VarType := VarType;
    DynamicVar.nInternet := nVarValue;
    DynamicVar.sString := sVarValue;
    boFoundVar := False;
    DynamicVarList := GetDynamicVarList(PlayObject, sType, sName);
    if DynamicVarList = nil then begin
      Dispose(DynamicVar);
      ScriptActionError(PlayObject, Format(sVarTypeError, [sType]), QuestActionInfo, sSC_VAR);
      Exit;
    end;
    if DynamicVarList.Count > 0 then begin//20080629
      for I := 0 to DynamicVarList.Count - 1 do begin
        if CompareText(pTDynamicVar(DynamicVarList.Items[I]).sName, sVarName) = 0 then begin
          boFoundVar := True;
          Break;
        end;
      end;
    end;
    if not boFoundVar then begin
      DynamicVarList.Add(DynamicVar);
    end else begin
      Dispose(DynamicVar); //2006-12-10 叶随风飘增加防止内存泄露
      ScriptActionError(PlayObject, Format(sVarFound, [sVarName, sType]), QuestActionInfo, sSC_VAR);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfVar',[g_sExceptionVer]));
  end;
end;
//读取变量值
//LOADVAR 变量类型 变量名 文件名
procedure TNormNpc.ActionOfLoadVar(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I: Integer;
  sType, sVarName, sFileName, sName: string;
  DynamicVar: pTDynamicVar;
  boFoundVar: Boolean;
  DynamicVarList: TList;
  IniFile: TIniFile;
  //SaveList: TStringList;
  nCode: Byte;
resourcestring
  sVarFound = '变量%s不存在，变量类型:%s';
  sVarTypeError = '变量类型错误，错误类型:%s 当前支持类型(HUMAN、GUILD、GLOBAL)';
begin
  nCode:= 0;
  try
    sType := QuestActionInfo.sParam1;
    nCode:= 13;
    sVarName := QuestActionInfo.sParam2;
    //sFileName := g_Config.sEnvirDir + m_sPath + QuestActionInfo.sParam3;
    nCode:= 14;
    sFileName := GetLineVariableText(PlayObject, QuestActionInfo.sParam3);//文件名支持变量 20110225
    nCode:= 15;
    if sFileName <> '' then begin
      if sFileName[1] = '\' then sFileName := Copy(sFileName, 2, Length(sFileName) - 1); //20080430 增加,处理文件路径
      nCode:= 16;
      if sFileName[2] = '\' then sFileName := Copy(sFileName, 3, Length(sFileName) - 2);
      nCode:= 17;
      if sFileName[3] = '\' then sFileName := Copy(sFileName, 4, Length(sFileName) - 3);
    end;
    nCode:= 18;
    sFileName:= g_Config.sEnvirDir + sFileName;
    {nCode:= 1; //20110508 注释
    if not FileExists(sFileName) then begin//20090719 文件不存在则创建文件
      nCode:= 20;
      ForceDirectories(ExtractFilePath(sFileName));//创建路径
      nCode:= 21;
      SaveList := TStringList.Create;
      try
        nCode:= 22;
        SaveList.SaveToFile(sFileName);
      finally
        SaveList.Free;
      end;
    end;
    nCode:= 3;  }
    if (sType = '') or (sVarName = '') {or (not FileExists(sFileName))} then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_LOADVAR);
      Exit;
    end;
    boFoundVar := False;
    nCode:= 4;
    DynamicVarList := GetDynamicVarList(PlayObject, sType, sName);
    if DynamicVarList = nil then begin
      nCode:= 5;
      ScriptActionError(PlayObject, Format(sVarTypeError, [sType]), QuestActionInfo, sSC_VAR);
      Exit;
    end else begin
      nCode:= 6;
      IniFile := TIniFile.Create(sFileName);
      //try
        if DynamicVarList.Count > 0 then begin//20080629
          nCode:= 7;
          for I := 0 to DynamicVarList.Count - 1 do begin
            DynamicVar := DynamicVarList.Items[I];
            nCode:= 8;
            if DynamicVar <> nil then begin
              if CompareText(DynamicVar.sName, sVarName) = 0 then begin
                nCode:= 9;
                case DynamicVar.VarType of
                  vInteger: begin
                    nCode:= 91;
                    DynamicVar.nInternet := IniFile.ReadInteger(sName, DynamicVar.sName, 0);
                  end;
                  vString: begin
                    nCode:= 92;
                    DynamicVar.sString := IniFile.ReadString(sName, DynamicVar.sName, '');
                  end;
                end;
                nCode:= 10;
                boFoundVar := True;
                Break;
              end;
            end;
          end;//for
        end;
        nCode:= 11;
        if not boFoundVar then
          ScriptActionError(PlayObject, Format(sVarFound, [sVarName, sType]), QuestActionInfo, sSC_LOADVAR);
        nCode:= 12;
      //finally
        IniFile.Free;
      //end;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfLoadVar Code:%d 参数1:%s 参数2:%s 参数3:%s',
        [g_sExceptionVer, nCode, QuestActionInfo.sParam1, QuestActionInfo.sParam2, QuestActionInfo.sParam3]));
  end;
end;

//保存变量值
//SAVEVAR 变量类型 变量名 文件名
procedure TNormNpc.ActionOfSaveVar(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I: Integer;
  sType: string;
  sVarName: string;
  sFileName: string;
  sName: string;
  DynamicVar: pTDynamicVar;
  boFoundVar: Boolean;
  DynamicVarList: TList;
  IniFile: TIniFile;
  nCode: Byte;//20090502
  //SaveList: TStringList;
resourcestring
  sVarFound = '变量%s不存在，变量类型:%s';
  sVarTypeError = '变量类型错误，错误类型:%s 当前支持类型(HUMAN、GUILD、GLOBAL)';
begin
  nCode:= 0;
  try
    sType := QuestActionInfo.sParam1;
    sVarName := QuestActionInfo.sParam2;
    sFileName := GetLineVariableText(PlayObject, QuestActionInfo.sParam3);//文件名支持变量 20110225
    nCode:= 11;
    if sFileName <> '' then begin
      if sFileName[1] = '\' then sFileName := Copy(sFileName, 2, Length(sFileName) - 1); //20080430 增加,处理文件路径
      nCode:= 16;
      if sFileName[2] = '\' then sFileName := Copy(sFileName, 3, Length(sFileName) - 2);
      nCode:= 17;
      if sFileName[3] = '\' then sFileName := Copy(sFileName, 4, Length(sFileName) - 3);

    end;
    nCode:= 18;
    sFileName:= g_Config.sEnvirDir + sFileName;
    {nCode:= 12;//20110508 注释
    if not FileExists(sFileName) then begin//20090719 文件不存在则创建文件
      nCode:= 13;
      ForceDirectories(ExtractFilePath(sFileName));//创建路径
      nCode:= 14;
      SaveList := TStringList.Create;
      try
        nCode:= 15;
        SaveList.SaveToFile(sFileName);
      finally
        SaveList.Free;
      end;
    end; }
    nCode:= 10;
    if (sType = '') or (sVarName = '') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_SAVEVAR);
      Exit;
    end;
    boFoundVar := False;
    nCode:= 1;
    DynamicVarList := GetDynamicVarList(PlayObject, sType, sName);
    nCode:= 2;
    if DynamicVarList = nil then begin
      ScriptActionError(PlayObject, Format(sVarTypeError, [sType]), QuestActionInfo, sSC_VAR);
      Exit;
    end else begin
      nCode:= 3;
      IniFile := TIniFile.Create(sFileName);
      try
        nCode:= 4;
        if DynamicVarList.Count > 0 then begin//20080629
          nCode:= 5;
          for I := 0 to DynamicVarList.Count - 1 do begin
            nCode:= 6;
            DynamicVar := DynamicVarList.Items[I];
            nCode:= 7;
            if DynamicVar <> nil then begin
              nCode:= 80;
              if CompareText(DynamicVar.sName, sVarName) = 0 then begin
                nCode:= 81;
                case DynamicVar.VarType of
                  vInteger: begin
                    nCode:= 82;
                    IniFile.WriteInteger(sName, DynamicVar.sName, DynamicVar.nInternet);
                  end;
                  vString: begin
                    nCode:= 83;
                    IniFile.WriteString(sName, DynamicVar.sName, DynamicVar.sString);
                  end;
                end;
                boFoundVar := True;
                Break;
              end;
            end;
          end;//for
        end;
        nCode:= 84;
        if not boFoundVar then ScriptActionError(PlayObject, Format(sVarFound, [sVarName, sType]), QuestActionInfo, sSC_SAVEVAR);
      finally
        nCode:= 91;
        IniFile.Free;
      end;
    end;
  except
    on E: Exception do begin
      MainOutMessage(Format('{%s} TNormNpc.ActionOfSaveVar Code:%d 参数1:%s 参数2:%s 参数3:%s %s',
        [g_sExceptionVer, nCode, QuestActionInfo.sParam1, QuestActionInfo.sParam2, QuestActionInfo.sParam3, E.Message]));
    end;
  end;
end;
//对自定义变量进行运算(+、-、*、/、=)
procedure TNormNpc.ActionOfCalcVar(PlayObject: TPlayObject;
  QuestActionInfo: pTQuestActionInfo);
var
  I: Integer;
  sType: string;
  sVarName: string;
  sName: string;
  sVarValue: string;
  sVarValue2: string;
  nVarValue: {Integer}LongWord;//20091122 修改
  sMethod: string;
  cMethod: Char;
  DynamicVar: pTDynamicVar;
  boFoundVar: Boolean;
  DynamicVarList: TList;
resourcestring
  sVarFound = '变量%s不存在，变量类型:%s';
  sVarTypeError = '变量类型错误，错误类型:%s 当前支持类型(HUMAN、GUILD、GLOBAL)';
begin
  try
    sType := QuestActionInfo.sParam1;//类型
    sVarName := QuestActionInfo.sParam2;//自定义变量
    sMethod := QuestActionInfo.sParam3;//操作符 +-*/=
    sVarValue := QuestActionInfo.sParam4;//变量

    if (sType = '') or (sVarName = '') or (sMethod = '') then begin
      ScriptActionError(PlayObject, '', QuestActionInfo, sSC_CALCVAR);
      Exit;
    end;
    boFoundVar := False;
    if (sVarValue <> '') {and (sVarValue2 <> '')} and (not IsStringNumber(sVarValue)){ and (not IsStringNumber(sVarValue2))} then begin
      if CompareLStr(sVarValue, '<$HUMAN(', 8{Length('<$HUMAN(')}) then begin //20080314 增加
        ArrestStringEx(sVarValue, '(', ')', sVarValue2);
        sVarValue := sVarValue2;
     { DynamicVarList := GetDynamicVarList(PlayObject, sVarValue, sName);
      if DynamicVarList = nil then begin
        ScriptActionError(PlayObject, Format(sVarTypeError, [sVarValue]), QuestActionInfo, sSC_CALCVAR);
        Exit;
      end;   }
        if PlayObject.m_DynamicVarList.Count > 0 then begin//20080629
          for I := 0 to PlayObject.m_DynamicVarList.Count{DynamicVarList.Count} - 1 do begin
            DynamicVar := PlayObject.m_DynamicVarList.Items[I]{DynamicVarList.Items[I]};
            if CompareText(DynamicVar.sName, sVarValue{2}) = 0 then begin
              case DynamicVar.VarType of
                vInteger: nVarValue := DynamicVar.nInternet;
                vString:  sVarValue := DynamicVar.sString;
              end;
              boFoundVar := True;
              Break;
            end;
          end;//for
        end;
        if not boFoundVar then begin
          ScriptActionError(PlayObject, Format(sVarFound, [sVarValue{2}, sType{sVarValue}]), QuestActionInfo, sSC_CALCVAR);
          Exit;
        end;
      end else begin
        nVarValue:= Str_ToInt(GetLineVariableText(PlayObject,sVarValue),0);//20080314 增加
        sVarValue:=GetLineVariableText(PlayObject,sVarValue);//20080430
      end;
    end else nVarValue := Str_ToInt(QuestActionInfo.sParam4, 0);

    boFoundVar := False;
    cMethod := sMethod[1];
    DynamicVarList:= nil;
    DynamicVarList := GetDynamicVarList(PlayObject, sType, sName);
    if DynamicVarList = nil then begin
      ScriptActionError(PlayObject, Format(sVarTypeError, [sType]), QuestActionInfo, sSC_CALCVAR);
      Exit;
    end else begin
      if DynamicVarList.Count > 0 then begin//20080629
        for I := 0 to DynamicVarList.Count - 1 do begin
          DynamicVar := DynamicVarList.Items[I];
          if DynamicVar <> nil then begin
            if CompareText(DynamicVar.sName, sVarName) = 0 then begin
              case DynamicVar.VarType of
                vInteger: begin
                    case cMethod of
                      '=': DynamicVar.nInternet := nVarValue;
                      '+': begin
                        //DynamicVar.nInternet := DynamicVar.nInternet + nVarValue;
                        if DynamicVar.nInternet > High(LongWord) - nVarValue then begin//20101114 替换
                          DynamicVar.nInternet := High(LongWord);
                        end else DynamicVar.nInternet := DynamicVar.nInternet + nVarValue;
                      end;
                      '-': begin
                        //DynamicVar.nInternet := DynamicVar.nInternet - nVarValue;
                        if DynamicVar.nInternet > nVarValue then begin//20101114 替换
                          DynamicVar.nInternet := DynamicVar.nInternet - nVarValue;
                        end else DynamicVar.nInternet := 0;
                      end;
                      '*': DynamicVar.nInternet := DynamicVar.nInternet * nVarValue;
                      '/': DynamicVar.nInternet := DynamicVar.nInternet div nVarValue;
                    end;
                  end;
                vString: begin
                    case cMethod of
                      '=': DynamicVar.sString := sVarValue;
                      '+': DynamicVar.sString := DynamicVar.sString + sVarValue;
                      '-':;
                    end;
                  end;
              end;
              boFoundVar := True;
              Break;
            end;
          end;
        end;//for
      end;
      if not boFoundVar then ScriptActionError(PlayObject, Format(sVarFound, [sVarName, sType]), QuestActionInfo, sSC_CALCVAR);
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ActionOfCalcVar',[g_sExceptionVer]));
  end;
end;

procedure TNormNpc.Initialize;
begin
  inherited;
  m_Castle := g_CastleManager.InCastleWarArea(Self);
end;

function TNormNpc.ConditionOfCheckNameDateList(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  I: Integer;
  LoadList: TStringList;
  sListFileName, sLineText, sHumName, sDate: string;
  boDeleteExprie, boNoCompareHumanName: Boolean;
  dOldDate: TDateTime;
  cMethod: Char;
  nValNo, nValNoDay, nDayCount, nDay: Integer;
begin
try
  Result := False;
  nDayCount := Str_ToInt(QuestConditionInfo.sParam3, -1);
  nValNo := GetValNameNo(QuestConditionInfo.sParam4);
  nValNoDay := GetValNameNo(QuestConditionInfo.sParam5);
  boDeleteExprie := CompareText(QuestConditionInfo.sParam6, '清理') = 0;
  boNoCompareHumanName := CompareText(QuestConditionInfo.sParam6, '1') = 0;
  cMethod := QuestConditionInfo.sParam2[1];
  if nDayCount < 0 then begin
    ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKNAMEDATELIST);
    Exit;
  end;
  sListFileName := g_Config.sEnvirDir + m_sPath + QuestConditionInfo.sParam1;
  if FileExists(sListFileName) then begin
    LoadList := TStringList.Create;
    try
      LoadList.LoadFromFile(sListFileName);
    except
      MainOutMessage('加载失败.... => ' + sListFileName);
    end;
    if  LoadList.Count > 0 then begin//20080629
      for I := 0 to LoadList.Count - 1 do begin
        sLineText := Trim(LoadList.Strings[I]);
        sLineText := GetValidStr3(sLineText, sHumName, [' ', #9]);
        sLineText := GetValidStr3(sLineText, sDate, [' ', #9]);
        if (CompareText(sHumName, PlayObject.m_sCharName) = 0) or boNoCompareHumanName then begin
          nDay := High(Integer);
          if TryStrToDateTime(sDate, dOldDate) then
            nDay := GetDayCount(Now, dOldDate);
          case cMethod of
            '=': if nDay = nDayCount then Result := True;
            '>': if nDay > nDayCount then Result := True;
            '<': if nDay < nDayCount then Result := True;
          else if nDay >= nDayCount then Result := True;
          end;
          if nValNo >= 0 then begin
            case nValNo of
              0..99: begin
                  PlayObject.m_nVal[nValNo] := nDay;
                end;
              100..199: begin
                  g_Config.GlobalVal[nValNo - 100] := nDay;
                end;
              200..299: begin
                  PlayObject.m_DyVal[nValNo - 200] := nDay;
                end;
              300..399: begin
                  PlayObject.m_nMval[nValNo - 300] := nDay;
                end;
              400..499: begin
                  g_Config.GlobaDyMval[nValNo - 400] := nDay;
                end;
              500..599: begin
                  PlayObject.m_nInteger[nValNo - 500] := nDay;
                end;
              800..1199:begin//20080903 G变量
                  g_Config.GlobalVal[nValNo - 700] := nDay;
                end;
              2100..2599: begin//G变量(500-999)
                  g_Config.GlobalVal[nValNo - 1600] := nDay;
                end;
            end;
          end;

          if nValNoDay >= 0 then begin
            case nValNoDay of
              0..99: begin
                  PlayObject.m_nVal[nValNoDay] := nDayCount - nDay;
                end;
              100..199: begin
                  g_Config.GlobalVal[nValNoDay - 100] := nDayCount - nDay;
                end;
              200..299: begin
                  PlayObject.m_DyVal[nValNoDay - 200] := nDayCount - nDay;
                end;
              300..399: begin
                  PlayObject.m_nMval[nValNoDay - 300] := nDayCount - nDay;
                end;
              400..499: begin
                  g_Config.GlobaDyMval[nValNo - 400] := nDayCount - nDay;
                end;
              500..599: begin
                  PlayObject.m_nInteger[nValNo - 500] := nDayCount - nDay;
                end;
              800..1199:begin//20080903 G变量
                  g_Config.GlobalVal[nValNoDay - 700] := nDayCount - nDay;
                end;
              2100..2599: begin//G变量(500-999)
                  g_Config.GlobalVal[nValNoDay - 1600] := nDayCount - nDay;
                end;
            end;
          end;
          if not Result then begin
            if boDeleteExprie then begin
              LoadList.Delete(I);
              try
                LoadList.SaveToFile(sListFileName);
              except
                MainOutMessage('保存失败.... => ' + sListFileName);
              end;
            end;
          end;
          Break;
        end;
      end;//for
    end;
    LoadList.Free;
  end else begin
    MainOutMessage('文件没有找到 => ' + sListFileName);
  end;
except
  MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckNameDateList',[g_sExceptionVer]));
end;
end;

function TNormNpc.ConditionOfCheckMapHumanCount(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nCount, nHumanCount: Integer;
  cMethod: Char;
  sMapName: string;
begin
  try
    Result := False;
    nCount := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam3),-1);//20080501
    {if nCount < 0 then begin//20091029 注释
      if not GetValValue(PlayObject, QuestConditionInfo.sParam3, nCount) then begin //增加变量支持
        ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKMAPHUMANCOUNT);
        Exit;
      end;
    end;}
    sMapName := GetLineVariableText(PlayObject,QuestConditionInfo.sParam1);//20110811 修改
    {if not GetValValue(PlayObject, QuestConditionInfo.sParam1, sMapName) then begin //增加变量支持
      sMapName := QuestConditionInfo.sParam1;
    end;}
    nHumanCount := UserEngine.GetMapHuman(sMapName);
    cMethod := QuestConditionInfo.sParam2[1];
    case cMethod of
      '=': if nHumanCount = nCount then Result := True;
      '>': if nHumanCount > nCount then Result := True;
      '<': if nHumanCount < nCount then Result := True;
    else if nHumanCount >= nCount then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckMapHumanCount',[g_sExceptionVer]));
  end;
end;
//功能：检查一个地图内的假人数量
//格式：CheckMapHumAICount 地图号 操作符('<' '>' '=') 数量
function TNormNpc.ConditionOfCheckMapHumAICount(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nCount, nHumanCount: Integer;
  cMethod: Char;
  sMapName: string;
  Envir: TEnvirnoment;
begin
  try
    Result := False;
    nCount := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam3),-1);
    sMapName := GetLineVariableText(PlayObject,QuestConditionInfo.sParam1);
    Envir := g_MapManager.FindMap(sMapName);
    if Envir = nil then Exit;
    nHumanCount := Envir.HumAICount;
    cMethod := QuestConditionInfo.sParam2[1];
    case cMethod of
      '=': if nHumanCount = nCount then Result := True;
      '>': if nHumanCount > nCount then Result := True;
      '<': if nHumanCount < nCount then Result := True;
    else if nHumanCount >= nCount then Result := True;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckMapHumAICount',[g_sExceptionVer]));
  end;
end;

function TNormNpc.ConditionOfCheckMapMonCount(PlayObject: TPlayObject;
  QuestConditionInfo: pTQuestConditionInfo): Boolean;
var
  nCount, nMonCount, I: Integer;
  cMethod: Char;
  Envir: TEnvirnoment;
  sMap:string;
  MonList: TList;
  BaseObject: TBaseObject;
begin
  try
    Result := False;
    nCount := Str_ToInt(GetLineVariableText(PlayObject,QuestConditionInfo.sParam3),-1);//20080501

    if CompareText(QuestConditionInfo.sParam1, 'Self') = 0 then begin//20081222
      sMap:=  PlayObject.m_sMapName;
    end else begin
      sMap:= QuestConditionInfo.sParam1;
      if (sMap <> '') and (sMap[1] = '<') and (sMap[2] = '$') then//增加支持<$Str()> 20081221
         sMap := GetLineVariableText(PlayObject, QuestConditionInfo.sParam1)
      else GetValValue(PlayObject, QuestConditionInfo.sParam1, sMap);
    end;
    Envir := g_MapManager.FindMap(sMap);
    
    //Envir := g_MapManager.FindMap(QuestConditionInfo.sParam1);
    if nCount < 0 then GetValValue(PlayObject, QuestConditionInfo.sParam3, nCount);
    if (nCount < 0) or (Envir = nil) then begin
      ScriptConditionError(PlayObject, QuestConditionInfo, sSC_CHECKMAPMONCOUNT);
      Exit;
    end;
    MonList := TList.Create;
    try
      UserEngine.GetMapMonster(Envir, MonList);
      for I := MonList.Count - 1 downto 0 do begin//20090113 增加
        if MonList.Count <= 0 then Break;
        BaseObject := TBaseObject(MonList.Items[I]);
        if (BaseObject.m_btRaceServer < RC_ANIMAL) or (BaseObject.m_btRaceServer = RC_ARCHERGUARD) or (BaseObject.m_Master <> nil) or (BaseObject.m_btRaceServer = RC_NPC) or (BaseObject.m_btRaceServer = RC_PEACENPC) then
          MonList.Delete(I);
      end;
      nMonCount := MonList.Count;
      cMethod := QuestConditionInfo.sParam2[1];
      case cMethod of
        '=': if nMonCount = nCount then Result := True;
        '>': if nMonCount > nCount then Result := True;
        '<': if nMonCount < nCount then Result := True;
      else if nMonCount >= nCount then Result := True;
      end;
    finally
      MonList.Free;
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.ConditionOfCheckMapMonCount',[g_sExceptionVer]));
  end;
end;

function TNormNpc.GetDynamicVarList(PlayObject: TPlayObject;
  sType: string; var sName: string): TList;
begin
  try
    Result := nil;
    if CompareLStr(sType, 'HUMAN', 5) then begin
      Result := PlayObject.m_DynamicVarList;
      sName := PlayObject.m_sCharName;
    end else
      if CompareLStr(sType, 'GUILD', 5) then begin
      if PlayObject.m_MyGuild = nil then Exit;
      Result := TGUild(PlayObject.m_MyGuild).m_DynamicVarList;
      sName := TGUild(PlayObject.m_MyGuild).sGuildName;
    end else
      if CompareLStr(sType, 'GLOBAL', 6) then begin
      Result := g_DynamicVarList;
      sName := 'GLOBAL';
    end;
  except
    MainOutMessage(Format('{%s} TNormNpc.GetDynamicVarList',[g_sExceptionVer]));
  end;
end;

{ TGuildOfficial }

procedure TGuildOfficial.Click(PlayObject: TPlayObject);
begin
  inherited;
end;

procedure TGuildOfficial.GetVariableText(PlayObject: TPlayObject;
  var sMsg: string; sVariable: string);
var
  I, II: Integer;
  sText: string;
  List: TStringList;
  sStr: string;
begin
  inherited;
  try
    if sVariable = '$REQUESTCASTLELIST' then begin
      sText := '';
      List := TStringList.Create;
      g_CastleManager.GetCastleNameList(List);
      if List.Count > 0 then begin//20080629
        for I := 0 to List.Count - 1 do begin
          II := I + 1;
          if ((II div 2) * 2 = II) then sStr := '\'
          else sStr := '';
          sText := sText + Format('<%s/@requestcastlewarnow%d> %s', [List.Strings[I], I, sStr]);
        end;
      end;
      sText := sText + '\ \';
      List.Free;
      sMsg := sub_49ADB8(sMsg, '<$REQUESTCASTLELIST>', sText);
    end;
  except
    MainOutMessage(Format('{%s} TGuildOfficial.GetVariableText',[g_sExceptionVer]));
  end;
end;

procedure TGuildOfficial.Run;
begin
  if Random(40) = 0 then begin
    TurnTo(Random(8));
  end else begin
    if Random(30) = 0 then
      SendRefMsg(RM_HIT, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
  end;
  inherited;
end;

procedure TGuildOfficial.UserSelect(PlayObject: TPlayObject; sData: string);
var
  sMsg, sLabel: string;
  boCanJmp: Boolean;
  nCode: Byte;
resourcestring
  sExceptionMsg = '{%s} TGuildOfficial:UserSelect %s Code:%d';
begin
  inherited;
  nCode:= 0;
  try
    //    PlayObject.m_nScriptGotoCount:=0;
    if (sData <> '') and (sData[1] = '@') then begin
      nCode:= 1;
      sMsg := GetValidStr3(sData, sLabel, [#13]);
      nCode:= 2;
      boCanJmp := PlayObject.LableIsCanJmp(sLabel);
      nCode:= 3;
      GotoLable(PlayObject, sLabel, not boCanJmp, False);

      //GotoLable(PlayObject,sLabel,not PlayObject.LableIsCanJmp(sLabel));
      if not boCanJmp then Exit;
      if CompareText(sLabel, sBUILDGUILDNOW) = 0 then begin
        nCode:= 4;
        ReQuestBuildGuild(PlayObject, sMsg);//创建行会
      end else
        if CompareText(sLabel, sSCL_GUILDWAR) = 0 then begin//申请行会战
        nCode:= 5;
        ReQuestGuildWar(PlayObject, sMsg);
      end else
        if CompareText(sLabel, sDONATE) = 0 then begin
        nCode:= 6;
        DoNate(PlayObject);
      end else
        {if CompareText(sLabel,sREQUESTCASTLEWAR) = 0 then begin
          ReQuestCastleWar(PlayObject,sMsg);
        end else }
        if CompareLStr(sLabel, sREQUESTCASTLEWAR, 20{Length(sREQUESTCASTLEWAR)}) then begin
        nCode:= 7;
        ReQuestCastleWar(PlayObject, Copy(sLabel, 21{Length(sREQUESTCASTLEWAR) + 1}, Length(sLabel) - 20{Length(sREQUESTCASTLEWAR)}));
      end else
        if CompareText(sLabel, sEXIT) = 0 then begin
        nCode:= 8;
        PlayObject.SendMsg(Self, RM_MERCHANTDLGCLOSE, 0, Integer(Self), 0, 0, '');
      end else
        if CompareText(sLabel, sBACK) = 0 then begin
        nCode:= 9;
        if PlayObject.m_sScriptGoBackLable = '' then PlayObject.m_sScriptGoBackLable := sMAIN;
        GotoLable(PlayObject, PlayObject.m_sScriptGoBackLable, False, False);
      end;
    end;
  except
    MainOutMessage(Format(sExceptionMsg,[g_sExceptionVer, sLabel, nCode]));
  end;
  //  inherited;
end;
//创建行会
function TGuildOfficial.ReQuestBuildGuild(PlayObject: TPlayObject; sGuildName: string): Integer;
var
  UserItem: pTUserItem;
begin
  try
    Result := 0;
    sGuildName := Trim(sGuildName);
    UserItem := nil;
    if sGuildName = '' then begin
      Result := -4;
    end;
    if PlayObject.m_MyGuild = nil then begin
      if PlayObject.m_nGold >= g_Config.nBuildGuildPrice then begin
        UserItem := PlayObject.CheckItems(g_Config.sWomaHorn);//是否有沃玛号角
        if UserItem = nil then begin
          Result := -3; //'你没有准备好需要的全部物品。'
        end;
      end else Result := -2; //'缺少创建费用。'
    end else Result := -1; //'您已经加入其它行会。'
    if Result = 0 then begin
      if g_GuildManager.AddGuild(sGuildName, PlayObject.m_sCharName) then begin
        //UserEngine.SendServerGroupMsg(SS_205, nServerIndex, sGuildName + '/' + PlayObject.m_sCharName);//20101022 注释
        PlayObject.SendDelItems(UserItem);
        PlayObject.DelBagItem(UserItem.MakeIndex, g_Config.sWomaHorn);
        PlayObject.DecGold(g_Config.nBuildGuildPrice);
        PlayObject.GoldChanged();
        PlayObject.m_MyGuild := g_GuildManager.MemberOfGuild(PlayObject.m_sCharName);
        if PlayObject.m_MyGuild <> nil then begin
          PlayObject.m_sGuildRankName := TGUild(PlayObject.m_MyGuild).GetRankName(PlayObject, PlayObject.m_nGuildRankNo);
          PlayObject.RefShowName();
          if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(PlayObject, '@CreateGuild', False, False);//创建行会触发 20110225
        end;
      end else Result := -4;
    end;
    if Result >= 0 then begin
      PlayObject.SendMsg(Self, RM_BUILDGUILD_OK, 0, 0, 0, 0, '');
    end else begin
      PlayObject.SendMsg(Self, RM_BUILDGUILD_FAIL, 0, Result, 0, 0, '');
    end;
  except
    MainOutMessage(Format('{%s} TGuildOfficial.ReQuestBuildGuild',[g_sExceptionVer]));
  end;
end;
//申请开启行会战
function TGuildOfficial.ReQuestGuildWar(PlayObject: TPlayObject; sGuildName: string): Integer;
begin
  try
    if g_GuildManager.FindGuild(sGuildName) <> nil then begin
      if PlayObject.m_nGold >= g_Config.nGuildWarPrice then begin
        PlayObject.DecGold(g_Config.nGuildWarPrice);
        PlayObject.GoldChanged();
        PlayObject.ReQuestGuildWar(sGuildName);
      end else begin
        PlayObject.SysMsg('您没有足够的金币！！！', c_Red, t_Hint);
      end;
    end else begin
      PlayObject.SysMsg(sGuildName + ' 无法查找指定行会', c_Red, t_Hint);
    end;
    Result := 1;
  except
    MainOutMessage(Format('{%s} TGuildOfficial.ReQuestGuildWar',[g_sExceptionVer]));
  end;
end;

procedure TGuildOfficial.DoNate(PlayObject: TPlayObject);
begin
  PlayObject.SendMsg(Self, RM_DONATE_OK, 0, 0, 0, 0, '');
end;

procedure TGuildOfficial.ReQuestCastleWar(PlayObject: TPlayObject; sIndex: string);
var
  UserItem: pTUserItem;
  Castle: TUserCastle;
  nIndex: Integer;
begin
try
  //  if PlayObject.IsGuildMaster and
  //     (not UserCastle.IsMasterGuild(TGuild(PlayObject.m_MyGuild))) then begin
  nIndex := Str_ToInt(sIndex, -1);
  if nIndex < 0 then nIndex := 0;

  Castle := g_CastleManager.GetCastle(nIndex);
  if PlayObject.IsGuildMaster and
    not Castle.IsMember(PlayObject) then begin

    UserItem := PlayObject.CheckItems(g_Config.sZumaPiece);
    if UserItem <> nil then begin
      if Castle.AddAttackerInfo(TGUild(PlayObject.m_MyGuild),0) then begin
        PlayObject.SendDelItems(UserItem);
        PlayObject.DelBagItem(UserItem.MakeIndex, g_Config.sZumaPiece);
        GotoLable(PlayObject, '~@request_ok', False, False);
      end else begin
        PlayObject.SysMsg('您现在无法请求攻城！！！', c_Red, t_Hint);
      end;
    end else begin
      PlayObject.SysMsg('您没有' + g_Config.sZumaPiece + '！！！', c_Red, t_Hint);
    end;
  end else begin
    PlayObject.SysMsg('您的请求被取消！！！', c_Red, t_Hint);
  end;
except
  MainOutMessage(Format('{%s} TGuildOfficial.ReQuestCastleWar',[g_sExceptionVer]));
end;
end;

procedure TCastleOfficial.RepairDoor(PlayObject: TPlayObject);
begin
try
  if m_Castle = nil then begin
    PlayObject.SysMsg('NPC不属于城堡！！！', c_Red, t_Hint);
    Exit;
  end;
  if TUserCastle(m_Castle).m_nTotalGold >= g_Config.nRepairDoorPrice then begin
    if TUserCastle(m_Castle).RepairDoor then begin
      Dec(TUserCastle(m_Castle).m_nTotalGold, g_Config.nRepairDoorPrice);
      PlayObject.SysMsg('修理成功。', c_Green, t_Hint);
    end else begin
      PlayObject.SysMsg('城门不需要修理！！！', c_Green, t_Hint);
    end;
  end else begin
    PlayObject.SysMsg('城内资金不足！！！', c_Red, t_Hint);
  end;
  {
  if UserCastle.m_nTotalGold >= g_Config.nRepairDoorPrice then begin
    if UserCastle.RepairDoor then begin
      Dec(UserCastle.m_nTotalGold,g_Config.nRepairDoorPrice);
      PlayObject.SysMsg('修理成功。',c_Green,t_Hint);
    end else begin
      PlayObject.SysMsg('城门不需要修理！！！',c_Green,t_Hint);
    end;
  end else begin
    PlayObject.SysMsg('城内资金不足！！！',c_Red,t_Hint);
  end;
  }
except
  MainOutMessage(Format('{%s} TGuildOfficial.RepairDoor',[g_sExceptionVer]));
end;
end;

procedure TCastleOfficial.RepairWallNow(nWallIndex: Integer;
  PlayObject: TPlayObject);
begin
try
  if m_Castle = nil then begin
    PlayObject.SysMsg('NPC不属于城堡！！！', c_Red, t_Hint);
    Exit;
  end;

  if TUserCastle(m_Castle).m_nTotalGold >= g_Config.nRepairWallPrice then begin
    if TUserCastle(m_Castle).RepairWall(nWallIndex) then begin
      Dec(TUserCastle(m_Castle).m_nTotalGold, g_Config.nRepairWallPrice);
      PlayObject.SysMsg('修理成功。', c_Green, t_Hint);
    end else begin
      PlayObject.SysMsg('城门不需要修理！！！', c_Green, t_Hint);
    end;
  end else begin
    PlayObject.SysMsg('城内资金不足！！！', c_Red, t_Hint);
  end;
  {
  if UserCastle.m_nTotalGold >= g_Config.nRepairWallPrice then begin
    if UserCastle.RepairWall(nWallIndex) then begin
      Dec(UserCastle.m_nTotalGold,g_Config.nRepairWallPrice);
      PlayObject.SysMsg('修理成功。',c_Green,t_Hint);
    end else begin
      PlayObject.SysMsg('城门不需要修理！！！',c_Green,t_Hint);
    end;
  end else begin
    PlayObject.SysMsg('城内资金不足！！！',c_Red,t_Hint);
  end;
  }
except
  MainOutMessage(Format('{%s} TGuildOfficial.RepairWallNow',[g_sExceptionVer]));
end;
end;

constructor TCastleOfficial.Create;
begin
  inherited;
end;

destructor TCastleOfficial.Destroy;
begin
  inherited;
end;

constructor TGuildOfficial.Create;
begin
  inherited;
  m_btRaceImg := RCC_MERCHANT;
  m_wAppr := 8;
end;

destructor TGuildOfficial.Destroy;
begin
  inherited;
end;

procedure TGuildOfficial.SendCustemMsg(PlayObject: TPlayObject;
  sMsg: string);
begin
  inherited;
end;
//发送城主的话
procedure TCastleOfficial.SendCustemMsg(PlayObject: TPlayObject;
  sMsg: string);
begin
  try
    if not g_Config.boSubkMasterSendMsg then begin
      PlayObject.SysMsg(g_sSubkMasterMsgCanNotUseNowMsg, c_Red, t_Hint);
      Exit;
    end;
    if PlayObject.m_boSendMsgFlag then begin
      PlayObject.m_boSendMsgFlag := False;
      UserEngine.SendBroadCastMsg(PlayObject.m_sCharName + ': ' + sMsg, t_Castle);
    end;
  except
    MainOutMessage(Format('{%s} TGuildOfficial.SendCustemMsg',[g_sExceptionVer]));
  end;
end;

end.
