unit ObjBase; // liuzhigang 基本对象，是不是处理图片，场景的一些东西。

interface
uses
  Windows, Classes, SysUtils, Forms, StrUtils, StdCtrls, Grobal2, Envir, Common,
  ObjPlayRobot;
{

G0-G99 全局变量(数字型) 可保存
A0-A999 全局变量(字符型) 可保存
I0-I99 全局变量(数字型) 不可保存

P0-P9 私人变量(数字型) 不可保存
M0-M99 私人变量(数字型) 不可保存
D0-D9 私人变量(数字型) 不可保存
N0-N99 私人变量(数字型) 不可保存
S0-S99 私人变量(字符型) 不可保存

}
type

  TBaseObject = class
    m_sMapName: string[MAPNAMELEN]; //地图名称
    m_sCharName: string[ACTORNAMELEN]; //人物名称
    m_nCurrX: Integer; //人物所在座标X(4字节)
    m_nCurrY: Integer; //人物所在座标Y(4字节)
    m_btDirection: Byte; //人物所在方向(1字节)
    m_btGender: Byte; //人物的性别(1字节)
    m_btHair: Byte; //人物的头发(1字节)
    m_btJob: Byte; //人物的职业 0-战 1-法 2-道 3-刺客
    m_nGold: Integer; //人物金币数(4字节)
    
    m_nCharStatus: Integer; //人物状态
    m_sHomeMap: string[MAPNAMELEN]; //回城地图
    m_nHomeX: Integer; //回城座标X
    m_nHomeY: Integer; //回城座标Y
    m_boOnHorse: Boolean; //骑马
    m_btHorseType: Byte; //马的类型
    m_btDressEffType: Byte; //衣服特效(如天外飞仙衣服效果)

    m_nPkPoint: Integer; //人物的PK值(4字节)
    btB2: Byte; //0xB2
    m_nIncHealth: Integer; //增加HP值
    m_nIncSpell: Integer; //增加MP值
    m_nIncHealing: Integer; //增加治愈值
    m_nFightZoneDieCount: Integer; //在行会战争地图中死亡次数

    m_BonusAbil: TNakedAbility; //人物永久属性
    m_nBonusPoint: Integer; //奖金点，升级增加属性点之类

    m_dBodyLuck: Double; //幸运度
    m_nBodyLuckLevel: Integer; //幸运度等级
    m_boHeartActive: Boolean; //心法激活
    m_QuestFlag: TQuestFlag; //脚本变量
    m_nCharStatusEx: Integer;
    m_dwFightExp: LongWord; //怪物经验值
    m_Abil: TAbility; //
    m_WAbil: TAbility; //角色属性
    m_AddAbil: TAddAbility; //增加的属性
    m_nViewRange: Integer; //可视范围大小
    //人物状态属性值 0-绿毒(减HP) 1-红毒(减MP) 2-防、魔防为0(唯我独尊3级) 3-不能跑动(中蛛网)
    //4-不能移动(中战连击) 5-麻痹(石化) 6-减血，被连击技能万剑归宗击中后掉血
    //7-冰冻(不能跑动，不能魔法) 8-隐身 9-防御力(神圣战甲术) 10-魔御力(幽灵盾) 11-魔法盾
    m_wStatusTimeArr: TStatusTime;
    m_dwStatusArrTick: array[0..MAX_STATUS_ATTRIBUTE - 1] of LongWord; //人物状态持续的开始时间
    //0-攻击力增加 1-魔法增加  2-道术增加(无极真气) 3-攻击速度 4-HP增加(酒气护体)
    //5-增加MP上限 6-减攻击力 7-减魔法 8-减道术 9-减HP 10-减MP 11-敏捷 12-增加防
    //13-增加魔防 14-增加道术上限(虎骨酒) 15-连击伤害增加(醉八打) 16-内力恢复速度增加(何首养气酒)
    //17-内力瞬间恢复增加(何首凝神酒) 18-增加斗转上限(培元酒) 19-不死状态 21-弟子心法激活
    //22-移动减速 23-定身(十步一杀)
    m_wStatusArrValue: array[0..23] of Word;
    m_dwStatusArrTimeOutTick: array[0..23] of LongWord;
    //多少秒 0-攻击力增加 1-魔法增加  2-道术增加(无极真气) 3-攻击速度 4-HP增加(酒气护体)
    //5-增加MP上限 6-减攻击力 7-减魔法 8-减道术 9-减HP 10-减MP 11-敏捷 12-增加防
    //13-增加魔防 14-增加道术上限(虎骨酒) 15-连击伤害增加(醉八打) 16-内力恢复速度增加(何首养气酒)
    //17-内力瞬间恢复增加(何首凝神酒) 18-增加斗转上限(培元酒) 19-不死状态 20-道术+上下限(除魔药剂类) 21-弟子心法激活
    //22-移动减速 23-定身(十步一杀)
    m_boDrinkDrugHotels: Boolean; //是否正在使用药酒

    m_wAppr: Word; //形像代码
    m_btRaceServer: Byte; //角色类型
    m_btRaceImg: Byte; //角色外形
    m_btHitPoint: Byte; //人物攻击准确度(Byte)
    m_btHitPointSkill88: Byte; //四级基本剑术增加攻击值(增加攻击上限)
    m_nHitPlus: ShortInt; //另加攻击伤害(攻杀)
    m_nHitDouble: ShortInt; //双倍攻击伤害(烈火专用)
    m_dwGroupRcallTick: LongWord; //记忆使用间隔(Dword)
    m_boRecallSuite: Boolean; //记忆全套
    //bo245: Boolean; 注释掉 无用 By TasNat at: 2012-04-01 12:59:15
    //m_boTestGa: Boolean; //是否输入Testga 命令(提权,后门) 20081014
    m_nHealthRecover: ShortInt; //体力恢复
    m_nSpellRecover: ShortInt; //魔法恢复
    m_btAntiPoison: Byte; //中毒躲避
    m_nPoisonRecover: ShortInt; //中毒恢复
    m_nAntiMagic: ShortInt; //魔法躲避
    m_nLuck: Integer; //人物的幸运值(幸运9相关)
    m_nBurstRate: Byte; //目标爆率(击杀对手时，对方爆物品机率) 20091129
    m_nUnBurstRate: Byte; //防爆点数
{$IF M2Version <> 2}
    m_nDecTargetNHPoint: Byte; //目标内力值减少点数(内伤装备) 20100513
    m_boCanUerSkill102: Boolean; //唯我独尊可用
{$IFEND}
    m_dwDecUnParalysisTick : DWord;//减少无视麻痹的时间 By TasNat at: 2012-04-23 18:42:10
    m_btUnParalysis : Byte;//麻痹免疫剩余的秒数 > 0 无视麻痹 By TasNat at: 2012-04-23 18:42:15
    m_nUnParalysisRate: Integer; //防麻机率(辉煌衣服) 20100513
    m_nParalysisAddRate: Integer; //麻痹强化 (身上佩戴物品总和) add by liuzhigang on 2011.12.31
    m_nVampirePoint: Byte; //吸血点数(虎威装备)
    m_nVampireRate: Byte; //吸血机率(虎威装备)
    m_nPerHealth: Integer; //
    m_nPerHealing: Integer; //
    m_nPerSpell: Integer; //
    m_dwIncHealthSpellTick: LongWord; //增加攻击的间隔
    m_btGreenPoisoningPoint: Byte; //中绿毒降HP点数
    m_nGoldMax: Integer; //人物身上最多可带金币数(Dword)
    m_btSpeedPoint: Byte; //人物敏捷度
    m_btPermission: Byte; //人物权限等级
    m_nHitSpeed: ShortInt; //攻击速度
    m_nRunSpeed: Smallint; //移动速度
    m_btLifeAttrib: Byte; //不死系,1-为不死系
    m_btCoolEye: Word; //否可以看到隐身人物(视线范围) 20080623

    m_Master: TBaseObject; //是否被召唤(主人)
    m_dwMasterRoyaltyTick: LongWord; //怪物叛变时间
    m_dwMasterRoyaltyTime: LongWord; //怪物叛变计时 20080813
    m_dwMasterTick: LongWord;
    n294: Integer; //宝宝杀怪计数,用于宝宝升级用
    m_btSlaveExpLevel: Byte; //宝宝等级 1-7
    m_btSlaveMakeLevel: Byte; //召唤等级
    

    m_boSlaveRelax: Boolean; //宝宝攻击状态(T休息/F攻击)
    m_btAttatckMode: Byte; //下属攻击状态
    m_btNameColor: Byte; //名字的颜色
    m_nLight: Integer; //亮度
    m_boGuildWarArea: Boolean; //行会占争范围
    m_Castle: TObject; //所属城堡
    bo2B0: Boolean; //城堡成员
    m_dw2B4Tick: LongWord; //0x2B4
    m_boSuperMan: Boolean; //无敌模式
    bo2B9: Boolean; //不可移动,重叠也不会移动
    bo2BA: Boolean; //不进入火墙
    m_boAnimal: Boolean; //是否是动物
    m_boNoItem: Boolean; //死亡是否不掉物品
    m_boFixedHideMode: Boolean; //隐身模式
    m_boStickMode: Boolean; //不能冲撞模式(即敌人不能使用野蛮冲撞技能攻击)
    m_nStickIncLevel: Byte; //称号不动如山增加冲撞技能等级
    bo2BF: Boolean; //被打到是否减慢行走速度,等级小于50的怪 F-减慢 T-不减慢
    m_boNoAttackMode: Boolean; //非攻击模式 F-可攻击 T-不攻击
    m_boButchSkeleton: Boolean; //正在被挖尸体 20090103
    m_boSkeleton: Boolean; //尸体
    m_nMeatQuality: Integer; //挖肉，肉的品质
    m_nBodyLeathery: Integer; //身体坚韧性

    m_boHolySeize: Boolean; //不能走动模式(困魔咒)
    m_dwHolySeizeTick: LongWord; //不能走动间隔(困魔咒)
    m_dwHolySeizeInterval: LongWord; //不能走动时长(困魔咒)
    m_boCrazyMode: Boolean; //狂化模式(红名)
    m_dwCrazyModeTick: LongWord; //狂化模式间隔
    m_dwCrazyModeInterval: LongWord; //狂化模式时长
    m_boShowHP: Boolean; //心灵启示
    m_dwShowHPTick: LongWord; //心灵启示检查时间(Dword)
    m_dwShowHPInterval: LongWord; //心灵启示有效时长(Dword)

    bo2F0: Boolean; //检查重叠人物使用
    m_dwDupObjTick: LongWord; //检查重叠人物间隔
    m_PEnvir: TEnvirnoment; //所在地图场景
    m_boGhost: Boolean; //尸体清除
    m_dwGhostTick: LongWord; //尸体清除间隔
    m_boDeath: Boolean; //死亡
    m_dwDeathTick: LongWord; //死亡间隔
    m_btMonsterWeapon: Byte; //怪物所拿的武器
    m_dwStruckTick: LongWord; //弯腰间隔
    m_boWantRefMsg: Boolean; //刷新消息
    m_boAddtoMapSuccess: Boolean; //增加到地图是否成功
    m_bo316: Boolean; //换地图时，跑走不考虑坐标

    m_MyGuild: TObject; //我的行会
    m_nGuildRankNo: Integer; //行会排名
    m_sGuildRankName: string; //行会封号

    m_btAttackSkillCount: Byte; //攻杀相关
    m_btAttackSkillPointCount: Byte; //攻杀计数

    m_boMission: Boolean; //怪物向集中点集中
    m_nMissionX: Integer; //集中点坐标X
    m_nMissionY: Integer; //集中点坐标Y

    m_boHideMode: Boolean; //隐身戒指
    m_boStoneMode: Boolean; //石像化
    m_boCoolEye: Boolean; //是否可以看到隐身人物(视线范围)
    m_boUserUnLockDurg: Boolean; //是否用了神水
    m_boTransparent: Boolean; //魔法隐身了
    m_boAdminMode: Boolean; //管理模式
    m_boObMode: Boolean; //隐身模式
    m_boTeleport: Boolean; //传送戒指
    m_boParalysis: Boolean; //麻痹戒指
    m_boParalysis1: Boolean; //战意麻痹戒指 时间2秒
    m_boParalysis2: Boolean; //魔道麻痹戒指
    m_boParalysis3: Boolean; //魔意麻痹戒指
    m_boUnParalysis: Boolean; //防麻痹
    m_boRevival: Boolean; //复活戒指
    m_boUnRevival: Boolean; //防复活
    m_boUnPosion: Boolean; //防毒
    m_boHeavenSKill: Boolean; //倚天剑(增加技能)
    m_boDragonSkill: Boolean; //神龙附体
    m_boCallTrollSkill: Boolean; //召唤巨魔
    m_dwDoCallTrollTick: LongWord; //召唤巨魔间隔

    m_dwRevivalTick: LongWord; //复活戒指使用间隔计数
    m_boRebirth: Boolean; //重生戒指
    m_dwRebirthTick: LongWord; //重生戒指使用间隔计数
    m_boFlameRing: Boolean; //火焰戒指
    m_boRecoveryRing: Boolean; //治愈戒指
    m_boMeteorRing: Boolean; //流星火雨戒指 20090918
    m_boAngryRing: Boolean; //不死戒指
    m_boMagicShield: Boolean; //护身戒指(八卦护身戒指)
    m_boMagicShield1: Boolean; //聚魔护身戒指
    m_boMagicShield2: Boolean; //新护身戒指，伤害按1倍转移到魔法值的消耗上
    m_boUnMagicShield: Boolean; //防护身
    m_boMuscleRing: Boolean; //活力戒指(超负载戒指)
    m_boFastTrain: Boolean; //技巧项链
    m_boProbeNecklace: Boolean; //探测项链
    m_boGuildMove: Boolean; //行会传送
    m_boSupermanItem: Boolean; //无敌(未完全)物品
    m_bopirit: Boolean; //触发祈祷

    m_boNoDropItem: Boolean; //掉物品
    m_boNoDropUseItem: Boolean; //死亡是不是掉装备
    m_boExpItem: Boolean; //经验物品
    m_rExpItem: real; //经验物品值
    m_boPowerItem: Boolean; //力量物品(影响力量的物品)
    m_rPowerItem: real; //力量物品值

    m_dwPKDieLostExp: LongWord; //PK 死亡掉经验，不够经验就掉等级
    m_nPKDieLostLevel: Integer; //PK 死亡掉等级

    m_boAbilSeeHealGauge: Boolean; //心灵启示
    m_boAbilMagBubbleDefence: Boolean; //是否使用魔法盾
    m_btMagBubbleDefenceLevel: Byte; //魔法盾等级

    m_boProtectionDefence: Boolean; //是否学过护体神盾

    m_boMagChangXYTick: LongWord; //移行换位使用间隔 20080616
    m_dwSearchTime: LongWord; //搜索时间
    m_dwSearchTick: LongWord; //搜索间隔
    m_dwRunTick: LongWord; //运行间隔
    m_nRunTime: Integer; //运行时间
    m_nHealthTick: Integer; //特别指定为 此类型  加血间隔
    m_nSpellTick: Integer; //0x374
    m_TargetCret: TBaseObject; //目标(攻击或加血,等对像)
    m_dwTargetFocusTick: LongWord; //0x37C
    m_LastHiter: TBaseObject; //人物被对方杀害时对方指针
    m_LastHiterTick: LongWord; //0x384
    m_ExpHitter: TBaseObject; //敌人伤害时对方指针
    m_ExpHitterTick: LongWord; //0x38C
    m_dwTeleportTick: LongWord; //传送戒指使用间隔(Dword)
    m_dwProbeTick: LongWord; //探测项链使用间隔(Dword)
    m_dwMapMoveTick: LongWord; //地图传送使用间隔
    m_boPKFlag: Boolean; //人物攻击变色标志(灰色)
    m_dwPKTick: LongWord; //人物攻击变色时间长度(Dword)
    m_nXieLangSutie: Integer; //魔血2一套(增加HP上限)
    m_nMoXieSuite: Integer; //魔血一套(减蓝增加HP上限)
    m_nHongMoSuite: Integer; //虹魔一套(Dword) 吸血

    m_db3B0: Double; //0x3B0
    m_dwPoisoningTick: LongWord; //中毒处理间隔时间
    m_dwDecPkPointTick: LongWord; //减PK值时间
    m_DecLightItemDrugTick: LongWord; //照明物品使用间隔
    m_dwVerifyTick: LongWord; //0x3C4
    m_dwCheckRoyaltyTick: LongWord; //0x3C8
    m_dwDecHungerPointTick: LongWord; //0x3CC
    m_dwHPMPTick: LongWord; //增加HP MP的间隔
    
    m_SendRefMsgTick: LongWord; //发送刷新消息的间隔
    m_boInFreePKArea: Boolean; //是否在开行会战

    dwTick3F4: LongWord; //跑步,走路,转向间隔 20080217
    m_dwHitTick: LongWord; //攻击间隔
    m_dwWalkTick: LongWord; //走路间隔
    m_dwSearchEnemyTick: LongWord; //0x400
    m_boNameColorChanged: Boolean; //名字颜色改变
    m_boIsVisibleActive: Boolean; //是否在可视范围内有人物,及宝宝
    m_nProcessRunCount: ShortInt; //过程运行数量

    m_UseItems: THumanUseItems; //装备栏物品

    m_nWalkSpeed: Integer; //走路速度
    m_nWalkStep: Integer; //行走步伐
    m_nWalkCount: Integer; //0x504
    m_dwWalkWait: LongWord; //0x508
    m_dwWalkWaitTick: LongWord; //0x50C
    m_boWalkWaitLocked: Boolean; //步行等待锁定
    m_nNextHitTime: Integer; //下个攻击时间
    m_MagicOneSwordSkill: pTUserMagic; //基本剑术,精神力战法
    m_MagicPowerHitSkill: pTUserMagic; //攻杀
    m_MagicErgumSkill: pTUserMagic; //刺杀剑法
    m_Magic89Skill: pTUserMagic; //四级刺杀
    m_MagicBanwolSkill: pTUserMagic; //半月弯刀
    m_Magic90Skill: pTUserMagic; //圆月弯刀
    m_MagicFireSwordSkill: pTUserMagic; //烈火剑法 20080112
    m_MagicCrsSkill: pTUserMagic; //抱月弯刀
    m_Magic41Skill: pTUserMagic; //狮子吼
    m_Magic42Skill: pTUserMagic; //开天斩
    m_Magic43Skill: pTUserMagic; //龙影剑法

    m_Magic67Skill: pTUserMagic; //先天元力
    m_Magic68Skill: pTUserMagic; //酒气护体
    m_Magic71Skill: pTUserMagic; //召唤圣兽
    m_Magic74Skill: pTUserMagic; //逐日剑法
    m_Magic96Skill: pTUserMagic; //血魄一击(战)
    m_Magic104Skill: pTUserMagic; //召唤火灵

    m_boPowerHit: Boolean; //攻杀是否可用
    m_boUseThrusting: Boolean; //刺杀剑法是否可用
    m_boUseHalfMoon: Boolean; //半月弯刀是否可用
    m_boFireHitSkill: Boolean; //烈火剑法是否可用
    m_boDailySkill: Boolean; //逐日剑法是否可用 20080511
    m_boCrsHitkill: Boolean; //抱月弯刀是否可用
    m_bo42kill: Boolean; //开天斩是否可用
    m_n42kill: Byte; //开天斩重轻击 初始为0,1轻,2重
    m_bo43kill: Boolean; //龙影剑法是否可用
    m_boBloodSoulSkill: Boolean; //血魄一击(战)是否可用
    m_dwLatestFireHitTick: LongWord; //烈火的间隔
    m_dwLatestDailyTick: LongWord; //逐日剑法的间隔 20080511
    m_dwSkill55Tick: LongWord; //擒龙手使用间隔
    m_dwLatest42Tick: LongWord; //开天斩的间隔 20080202
    m_dwLatest43Tick: LongWord; //龙影剑法间隔 20080202
    m_dwLatestBloodSoulTick: LongWord; //血魄一击(战)间隔
    m_dwLatest46Tick: LongWord; //分身术的间隔 20080204
    m_boDenyRefStatus: Boolean; //是否刷新在地图上信息
    m_boAddToMaped: Boolean; //是否增加地图计数(人物或怪物数量) T-不需要再计数,F-需要计数
    m_boDelFormMaped: Boolean; //是否从地图中删除计数
    m_boAutoChangeColor: Boolean; //是否自动变色
    m_dwAutoChangeColorTick: LongWord; //自动变色间隔
    m_nAutoChangeIdx: Integer; //自动改变的索引
    m_nChangeColorType: Integer; //变色的类型
    m_boSetNameColor: Boolean; //是否自定义名字颜色 20080913

    m_boFixColor: Boolean; //固定颜色
    m_nFixColorIdx: Integer; //固定颜色的索引
    m_nFixStatus: Integer;
    m_boFastParalysis: Boolean; //快速麻痹，受攻击后麻痹立即消失
    m_nHolyCurtainLockX : Integer;
    m_nHolyCurtainLockY : Integer;
    m_DefMsg: TDefaultMessage;

    m_nCopyHumanLevel: Integer; //复制人辈分等级,显示名字用到
    m_dwStationTick: LongWord; //增加检测人物站立不动时间

    m_btLastOutStatus: Byte; //退出状态 1为死亡
    m_nWinExp: LongWord; //累计经验,达到一定值,增加英雄的忠诚度(20080110)   20080918 聚灵珠使用
    m_boOperationItemList: Boolean; //正在操作背包列表 20080928
    m_boIsNGMonster: Boolean; //内功怪,打死可以增加内力值 20081001
    m_boIsHeroPulsExpMon: boolean; //英雄经络经验怪 20090911

    m_boRobotObject: Boolean; //是否是机器人NPC 20090129
    m_nDecDamage: Word; //吸伤属性 20090618
    m_nDecDamageRate: Byte; //道法连击时的吸伤百分率 20090628
    m_dwDoSuSlaveTick: LongWord; //召唤圣兽间隔
    m_boMakeSlave: boolean; //是否正在召唤下属

    m_boShop: Boolean; //是否开启个人商店
    m_sShopMsg: string[16];
    m_TrueSC: Integer; //无极真气不考虑套装效果
    m_dwHeartAddPower : DWORD;//心法增加攻魔道 By TasNat at: 2012-04-08 12:40:16
    m_dwHeartAddDefence : DWORD;//心法增加防魔 By TasNat at: 2012-04-08 12:40:16
    m_boAI: Boolean; //是否是假人
    m_nDropUseItemRate: Integer; //假人掉装备机率
    //把列表放到高位 防止异常的写入造成未知异常 By TasNat at: 2012-03-14 18:43:15
    m_SlaveList: TList; //下属列表
    m_MsgList: TList; //消息列表
    m_VisibleHumanList: TList; //可见的人物列表
    m_VisibleItems: TList; //可见的物品列表
    m_VisibleEvents: TList; //可见的场景列表
    m_VisibleActors: TList; //可见角色列表
    m_ItemList: TList; //背包列表
    m_MagicList: TList; //技能表
    //m_MagicOfDelList: TList; //被删除的技能表防止删除技能后的非法访问 造成的 M2异常 By TasNat at: 2012-03-11 11:34:20
    m_SayMsgList: TList; //怪物说的信息列表
  private
    function InSafeArea: Boolean; //在安全区
    function Walk(nIdent: Integer): Boolean; //步行
    function AddToMap(): Boolean; //增加到地图
    procedure UseLamp(); //使用灯
    procedure CheckPKStatus(); //检测PK状态
    procedure GetAccessory(Item: TUserItem; StdItem: pTStdItem; var AddAbility: TAddAbility); //获取装备附加属性
{$IF M2Version <> 2}
    procedure GetAddUnKnowAbility(Item: TUserItem; var AddUnKnowAbility: TAddUnKnowAbility); //取鉴定的属性 20100825
{$IFEND}
    procedure RecalcHitSpeed();
    procedure AddItemSkill(nIndex: Integer); //物品增加技能
    procedure DelItemSkill(nIndex: Integer); //删除物品增加的技能
    procedure DecPKPoint(nPoint: Integer); //减少PK点
    procedure HearMsg(sMsg: string); //查询在线人数即 who Total 命令返回
    procedure DoDamageWeapon(nWeaponDamage: Integer); //做损坏的武器
    procedure DieDropItems; //死亡必掉物品 20080614
    function GetMaster(): TBaseObject;
  public
    procedure UpdateVisibleEvent(wX, wY: Integer; MapEvent: TObject);
    procedure UpdateVisibleItem(wX, wY: Integer; MapItem: PTMapItem); //更新可见的物品
    procedure UpdateVisibleGay(BaseObject: TBaseObject; nType: byte); //更新可见的角色
    procedure ChangMapDropItems; //换地图掉指定物品 20110301
    procedure AttackDir(TargeTBaseObject: TBaseObject; wHitMode: Word; nDir: Integer; btLevelEx: Byte); virtual; //攻击目标
    function IsAddWeightAvailable(nWeight: Integer): Boolean; //是可用的增加重量
    procedure DamageSpell(nSpellPoint: Integer); //魔法损害蓝值
    function GetCharColor(BaseObject: TBaseObject): Byte; //取名字颜色值
    function GetNamecolor: Byte; virtual; //取名字颜色
    function RecalcBagWeight(): Integer; //刷新包裹重量
    constructor Create(); virtual;
    destructor Destroy; override;
    function GetLevelExp(nLevel: Integer): LongWord; //取等级经验值
    function GetMedicineExp(nLevel: Integer): Word; //取等级所需药力值 20080624
    function GetSkill68Exp(nLevel: Byte): LongWord; //酒气护体 取等级所需经验值 20080625
    function GetSkill69Exp(nLevel: Word; var nMaxNH: Integer): LongWord; //内功心法 取等级所需经验值,内力值上限 20080930
    procedure SendMsg(BaseObject: TBaseObject; wIdent, wParam: Word; nParam1, nParam2, nParam3: Integer; sMsg: string); //发送消息
    procedure SendFirstMsg(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string); //发送第一次消息
    procedure SendDelayMsg(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string; dwDelay: LongWord); //发送延时消息
    procedure SendRefMsg(wIdent, wParam: Word; nParam1, nParam2, nParam3: Integer; sMsg: string); //发送刷新消息
    procedure SendUpdateMsg(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string); //发送更新消息
    procedure SendUpdateDelayMsg(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string; dwDelay: LongWord); //发送更新延时的消息
    procedure SendUpdateMsgB(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string);
    procedure SendUpdateMsgA(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string);
    //procedure SendActionMsg(BaseObject: TBaseObject; wIdent, wParam: Word;lParam1, lParam2, lParam3: Integer; sMsg: string);//发送行动的消息
    procedure SendAttackMsg(wIdent: Word; btDir, btLevelEx: Byte; nX, nY: Integer); //发送攻击的消息
    procedure SysMsg(sMsg: string; MsgColor: TMsgColor; MsgType: TMsgType);
    procedure SysMsg1(sMsg: string; MsgColor: TMsgColor; MsgType: TMsgType; FColor, BColor: Byte);
    procedure MonsterSayMsg(AttackBaseObject: TBaseObject; MonStatus: TMonStatus);
    procedure RecalcLevelAbilitys; //刷新等级能力
    procedure RecalcLevelAbilitysEx(nLevel: Integer); //按设置等级计算属性 20110921
    function PKLevel(): Integer; //PK等级
    function RunToCheckInSafeZone: Boolean; //跑步专用检查安全区函数 20090811
    function InSafeZone(): Boolean; overload; //在安全区
    function InSafeZone(Envir: TEnvirnoment; nX, nY: Integer): Boolean; overload; //在安全区
    procedure OpenHolySeizeMode(dwInterval: LongWord); //打开不能走动模式
    procedure BreakHolySeizeMode; //打破不能走动模式(困魔咒)
    procedure OpenCrazyMode(nTime: Integer); //开启怪物狂化模式
    procedure BreakCrazyMode(); //关闭怪物狂化模式
    procedure HealthSpellChanged(); //健康点的改变
    procedure PlugHealthSpellChanged; //插件气血改变血量 20080423
    function _Attack(var wHitMode: Word; AttackTarget: TBaseObject): Boolean; //攻击
    function GetHitStruckDamage(Target: TBaseObject; nDamage: Integer): Integer; //取击中的损坏点
    procedure HasLevelUp(nLevel: Integer); //等级提升

    procedure GoldChanged(); //金币改变
    procedure GoldGameGirdChanged(); //更新客户端金币及灵符
    procedure GameGoldChanged; //游戏币改变
    procedure GameGloryChanged(); //荣誉值改变

    function GetFeatureEx: Word;
    function GetPoseCreate(): TBaseObject;
    function GetGuildRelation(cert1: TBaseObject; cert2: TBaseObject): Integer;
    function IsGoodKilling(Cert: TBaseObject): Boolean;
    procedure IncPkPoint(nPoint: Integer); //增加PK值
    procedure AddBodyLuck(dLuck: Double); //增加宝宝幸运
    procedure MakeWeaponUnlock();
    procedure ScatterGolds(GoldOfCreat: TBaseObject);
    function DropGoldDown(nGold: Integer; boFalg: Boolean; GoldOfCreat, DropGoldCreat: TBaseObject): Boolean;
    function DropItemDown(UserItem: pTUserItem; nScatterRange: Integer; boDieDrop, boCanHit: Boolean; ItemOfCreat, DropCreat: TBaseObject): Boolean;
    procedure DamageHealth(nDamage: Integer); //virtual; //增加virtual; 20110704//中毒减血 删除 virtual 这费CPU By TasNat at: 2012-03-13 20:47:01
    function GetAttackPower(nBasePower, nPower: Integer): Integer; //取攻击值
    function CharPushed(nDir, nPushCount: Integer): Integer;
    function InMag113LockRect(nAX,nAY : Integer) : Boolean;
    function GetDropPosition(nOrgX, nOrgY, nRange: Integer; var nDX: Integer; var nDY: Integer): Boolean; //取掉物的位置
    function GetBackDir(nDir: Integer): Integer;
    function GetMapCanShop(tEnvir: TEnvirnoment; nX, nY, nRage: Integer): Boolean; //判断人物所在地图坐标1格范围内是否有位置摆摊
    function GetMapBaseObjects_61(tEnvir: TEnvirnoment; nX, nY, nRage: Integer; rList: TList): Boolean; //取地图坐标对角线的怪(辟星斩使用)
    function GetDirectionBaseObjects_42(btDir, nRage: Integer; rList: TList): Boolean; //取同方向里的目标(龙影)
    function GetDirectionBaseObjects(btDir, nRage: Integer; rList: TList): Boolean; //取同方向里的目标(开天 破魂)
    function GetDirBaseObjectsCount(btDir, nRage: Integer): Integer; //取同方向的怪数 疾光电影使用判断怪的数量 20080421

    function MagPassThroughMagic(sX, sY, tx, ty, nDir, magpwr, nSccPwr: Integer; undeadattack: Boolean; nCode: Byte): Integer;
    procedure KickException; //踢除异常
    function GetMagStruckDamage(BaseObject: TBaseObject; nDamage, nType, nType1: Integer): Integer;
    procedure DamageBubbleDefence(nInt: Integer); //减少打击的损害值
    procedure BreakOpenHealth;
    function GetCharStatus: Integer; //取角色状态
    procedure MakeOpenHealth;
    procedure IncHealthSpell(nHP, nMP: Integer); //增加HP MP值
    procedure ItemDamageRevivalRing; //复活戒指生效，减物品持久
    procedure RebirthItemDecDura(); //重生戒指生效，减物品持久 20100720
    function CalcGetExp(nLevel: Integer; nExp: Integer): Integer;
    function GetUpKill71Count(nLevel: Byte): Integer; //圣兽，火灵升级所需的杀怪数
    procedure GainSlaveExp(nLevel: Integer); //宝宝升级
    procedure MapRandomMove(sMapName: string; nInt: Integer); //地图随机移动
    procedure TurnTo(nDir: Integer); //人物转身
    procedure FeatureChanged(); //着装改变
    function GetFeature(var fResult : TFeatures): Integer;

    procedure AbilCopyToWAbil();
    procedure ChangePKStatus(boWarFlag: Boolean); //改变PK状态
    procedure StruckDamage(nDamage: Integer); virtual; //增加virtual;20080607
    function GetUserItemByName(sItemName: string; var nCount: Integer): pTUserItem;
    procedure StatusChanged(Str: string); //状态改变
    function GeTBaseObjectInfo(): string;
    procedure TrainSkill(UserMagic: pTUserMagic; nTranPoint: Integer);
    function CheckMagicLevelup(UserMagic: pTUserMagic): Boolean; //检查魔法是否升级
    function MagCanHitTarget(nX, nY: Integer; TargeTBaseObject: TBaseObject): Boolean; //魔法能攻的目标
    function sub_4C713C(Magic: pTUserMagic): Boolean;
    function MagBubbleDefenceUp(nLevel, nSec: Integer): Boolean; //魔法盾
    procedure ApplyMeatQuality();
    function TakeBagItems(BaseObject: TBaseObject): Boolean;
    function AddItemToBag(UserItem: pTUserItem): Boolean;
    procedure ClearBagItem;
    function DelBagItem(nIndex: Integer): Boolean; overload; //删除包裹物品
    function DelBagItem(nItemIndex: Integer; sItemName: string): Boolean; overload; //删除包裹物品
    function DelBagItem(UserItem: pTUserItem): Boolean; overload; //删除包裹物品

    procedure WeightChanged(); //重量改变
    function TrainingSkillToLevel(nIndex: Integer; Magic: pTMagic; nLevel, nToLevel: Byte; var Str: string): Boolean; //查找指定技能，并改变等级(四级技能使用) 20091201
    function IsTrainingSkill(nIndex: Integer): Boolean;
    procedure SetQuestFlagStatus(nFlag: Integer; nValue: Integer);
    function GetQuestFalgStatus(nFlag: Integer): Integer;
    function GetAttackDir(BaseObject: TBaseObject; var btDir: Byte): Boolean; overload; //取攻击的方向
    function GetAttackDir(BaseObject: TBaseObject; nRange: Integer; var btDir: Byte): Boolean; overload;
    function TargetInSpitRange(BaseObject: TBaseObject; var btDir: Byte): Boolean;
    procedure MonsterRecalcAbilitys(); //怪物刷新各种能力
    procedure RefNameColor; //刷新名字颜色
    procedure SetPKFlag(BaseObject: TBaseObject);
    procedure SetLastHiter(BaseObject: TBaseObject);
    function EnterAnotherMap(Envir: TEnvirnoment; nDMapX, nDMapY: Integer): Boolean;
    function sub_4DD704(): Boolean;
    function DefenceUp(nSec: Integer): Boolean; //防御力增加
    function MagDefenceUp(nSec: Integer): Boolean; //魔防御力增加
   // function DefenceDown(nSec: Integer): Boolean; //防御力减少 未使用 20080329
   // function MagDefenceDown(nSec: Integer): Boolean; //魔防御力减少 未使用 20080329
    procedure RefShowName;
    function MakeSlave(sMonName: string; nMakeLevel, nExpLevel, nMaxMob: Integer; dwRoyaltySec: LongWord): TBaseObject;
    function MakeSlaveEx(sMonName: string; nMakeLevel, nExpLevel, nMaxMob, nXX, nYY: Integer; dwRoyaltySec: LongWord): TBaseObject; //创建宝宝(强化召唤骨髓使用)
    function MakePosion(nType, nTime, nPoint: Integer): Boolean;
    function MakeSpiderMag(nTime: Integer): Boolean; //中蛛网，不能跑动 20080811
    function MakeSkill102Mag(nTime: Integer): Boolean;
    function MakeFreezeMag(nTime: Integer): Boolean; //被冰冻，不能走，不能跑，不能使用魔法，不能攻击
    function GetFrontPosition(var nX: Integer; var nY: Integer): Boolean;
    function GetBackPosition(var nX: Integer; var nY: Integer): Boolean;
    function WalkTo(btDir: Byte; boFlag: Boolean): Boolean;
    function GetRandXY(Envir: TEnvirnoment; var nX: Integer; var nY: Integer): Boolean;
    procedure SpaceMove(sMAP: string; nX, nY: Integer; nInt: Integer);
    procedure SpaceMove2(nX, nY: Integer; nInt: Integer);
    function sub_4C5370(nX, nY: Integer; nRange: Integer; var nDX, nDY: Integer): Boolean;
    function CheckItems(sItemName: string): pTUserItem;
    function MagMakeDefenceArea(nX, nY, nRange, nSec: Integer; btState: Byte): Integer;
    function MagMakeAbilityArea(nX, nY, nRange, nSec: Integer): Integer;
    procedure MagDownHealth(nType, nTime, nPoint: Integer);

    function sub_4C3538(): Integer;
    function IsGuildMaster(): Boolean; //是行会主人
    procedure LoadSayMsg();
    procedure DisappearA();
    function GetShowName(): string; virtual;
    procedure DropUseItems(BaseObject: TBaseObject; nBurstRate: Byte); virtual; //掉装备
    procedure ScatterBagItems(ItemOfCreat: TBaseObject); virtual; //爆包裹物品
    function GetMessage(Msg: pTProcessMessage): Boolean; virtual; //FFFF
    function MessageCount(): Integer;
    procedure Initialize(); virtual; //FFFE
    procedure Disappear(); virtual; //FFFD
    function Operate(ProcessMsg: pTProcessMessage): Boolean; virtual; //FFFC
    procedure SearchViewRange(); virtual; //dynamic;
    procedure Run(); virtual; //dynamic;//FFFB
    procedure ProcessSayMsg(sMsg: string); virtual;
    procedure ProcessSayMsg1(sMsg: string; FColor, BColor: Byte); //加强版文件信息发送函数(供NPC命令-SendMsg使用) 20081214
    procedure MakeGhost; virtual;
    procedure Die(); virtual;
    procedure ReAlive(); virtual; //FFF8;
    procedure RecalcAbilitys(); virtual; //刷新属性
    function IsProtectTarget(BaseObject: TBaseObject): Boolean; virtual;
    function IsAttackTarget(BaseObject: TBaseObject): Boolean; virtual;
    function IsProperTarget(BaseObject: TBaseObject): Boolean; virtual;
    function IsProperFriend(BaseObject: TBaseObject): Boolean; virtual;
    procedure SetTargetCreat(BaseObject: TBaseObject); virtual; //设置目标
    procedure DelTargetCreat(); virtual; //删除目标

    function IsProperTargetSKILL_54(BaseObject: TBaseObject): Boolean;
    function IsProperTargetSKILL_55(nLevel: Integer; BaseObject: TBaseObject): Boolean;
    function IsProperTargetSKILL_57(BaseObject: TBaseObject): Boolean;
    //function IsProperTargetSKILL_70(PlayObject: TBaseObject): Boolean;//未使用 20080329

    function CanRun(nX, nY: Integer; boFlag: Boolean): Boolean; overload;
    function CanRun(nCurrX, nCurrY, nX, nY: Integer; boFlag: Boolean): Boolean; overload;
    function CanMove(nX, nY: Integer; boFlag: Boolean): Boolean; overload;
    function CanMove(nCurrX, nCurrY, nX, nY: Integer; boFlag: Boolean): Boolean; overload;

    function RunTo(btDir: Byte; boFlag: Boolean; nDestX, nDestY: Integer): Boolean;
    function RunTo1(btDir: Byte; boFlag: Boolean; nDestX, nDestY: Integer): Boolean; //英雄,人形使用 20090525
    procedure ThrustingOnOff(boSwitch: Boolean);
    procedure HalfMoonOnOff(boSwitch: Boolean; nType: Byte);
    procedure SkillCrsOnOff(boSwitch: Boolean);
    function Skill42OnOff(): Boolean; //20080202 开天斩
    function Skill43OnOff(): Boolean; //20080619 替换

    function AllowFireHitSkill(): Boolean;
    function AllowDailySkill(): Boolean; //逐日剑法 20080511
    function AllowBloodSoulSkill(): Boolean; //血魄一击(战) 开启
    function CretInNearXY(TargeTBaseObject: TBaseObject; nX, nY: Integer): Boolean; overload;
    function CretInNearXY(TargeTBaseObject: TBaseObject; nX, nY: Integer; nRange: Integer): Boolean; overload;

    procedure KillSlave; //清除下属 20080124
    function ItemStruckDamage(nDamage: Integer): Integer; //盛大新戒指,减少受伤值  20080223
    procedure CompareSuitItem(boHint: boolean); //套装与身上装备对比 20080226

    function CheckItemValue(UserItem: pTUserItem; nType: Integer): Boolean; //判断绑定物品的属性 20080314

    //设置物品绑定状态(禁止扔、交易、存、修、出售、爆出) 20110528
    procedure SetItemState(Useritem: pTUserItem; nValType: Integer; nRate: Integer);

   // Function IsCastleMaster:Integer;//判断是不是城主或精英团 20080330
    function IsUsesZhuLi: Boolean; //是否使用斗笠 20080424
    function PlugOfCheckCanItem(nCode: Byte; ItemName: string; boCanHit: Boolean; dx, dy: Integer): Boolean; //禁止物品规则(管理插件功能) 20080729
    function CheckIsOKItem(UserItem: pTUserItem): Boolean; //检查物品附加属性是否正常 20081006

    property Master: TBaseObject read GetMaster;
  end;

  TAnimalObject = class(TBaseObject)
    m_nTargetX: Integer;
    m_nTargetY: Integer;
    m_boRunAwayMode: Boolean; //运行远离模式
    m_dwRunAwayStart: LongWord; //运行远离间隔
    m_dwRunAwayTime: LongWord; //运行远离时间
  private

  public
    constructor Create(); override;
    procedure SearchTarget(); virtual; //搜索目标
    procedure sub_4C959C;
    function Operate(ProcessMsg: pTProcessMessage): Boolean; override;
    procedure Run; override;
    procedure DelTargetCreat(); override;
    procedure SetTargetXY(nX, nY: Integer); virtual;
    procedure GotoTargetXY(); virtual;
    procedure Wondering(); virtual;
    procedure Attack(TargeTBaseObject: TBaseObject; nDir: Integer); virtual;
    procedure Struck(hiter: TBaseObject); virtual;
    procedure HitMagAttackTarget(TargeTBaseObject: TBaseObject; nHitPower: Integer; nMagPower: Integer; boFlag: Boolean);
  end;


  //PTPlayObject = ^TPlayObject;
  TPlayObject = class(TAnimalObject)
    m_nItemEffProcessPosition : Integer;
    m_M2AutoCreate: Boolean; //20090318 M2直接挂假人
    m_dwDoMotaeboTick: LongWord; //野蛮冲撞间隔 20080529
    m_sLastMapName: string[MAPNAMELEN]; //人物死亡地图
    m_nLastCurrX: Integer; //人物死亡地图所在座标X(4字节)
    m_nLastCurrY: Integer; //人物死亡地图所在座标Y(4字节)
    m_nSayMsgCount: Integer; //0x560
    m_dwSayMsgTick: LongWord; //0x568
    m_boDisableSayMsg: Boolean; //0x56C
    m_dwDisableSayMsgTick: LongWord; //0x570
    m_dwCheckDupObjTick: LongWord; //0x574
    dwTick578: LongWord; //0x578
    m_boInSafeArea: Boolean; //0x580
    m_sUserID: string[11]; //登录帐号名
    m_sIPaddr: string[15]; //人物IP地址
    m_dwHCode: DWord; //登陆的机器码
    m_sIPLocal: string; //IP所属地区
    m_dLogonTime: TDateTime; //登录时间
    m_dwLogonTick: LongWord; //在线时长
    m_boReadyRun: Boolean; //是否进入游戏完成
    m_nSessionID: Integer; //连接会话ID
    m_nRandomKey: Word; //随机密钥 20091026 TRunSocket.Do ClientCertification 写入
    m_nPayMent: Integer; //人物当前模式(测试/付费模式) 1-试玩模式(达到试玩等级上限时,踢下线) 2-付费用户 3-测试模式或免费模式
    m_nPayMode: Integer; //付费模式
    m_nServerIndex: Integer; //人物当前所在服务器序号
    m_boEmergencyClose: Boolean; //掉线标志
    m_boSoftClose: Boolean; //小退
    m_boKickFlag: Boolean; //踢人下线,断线标志(@kick 命令)
    m_boReconnection: Boolean; //重新连接标志
    m_boRcdSaveding: Boolean; //是否正在保存数据 20090106
    m_boRcdSaved: Boolean; //是否保存数据
    m_boSwitchData: Boolean; //0x5D9
    m_nWriteChgDataErrCount: Integer; //写入数据库错误次数
    m_sSwitchMapName: string; //0x5E0
    m_nSwitchMapX: Integer; //0x5E4
    m_nSwitchMapY: Integer; //0x5E8
    m_boSwitchDataSended: Boolean; //0x5EC
    m_dwChgDataWritedTick: LongWord; //0x5F0

    m_nSocket: Integer; //nSocket
    m_nGSocketIdx: Integer; //人物连接到游戏网关SOCKET ID
    m_nGateIdx: Integer; //人物所在网关号
    m_nSoftVersionDate: Integer; //版本日期

    m_sScriptLable: string; //脚本标签
    m_dwUserTick: array[0..9] of LongWord; //0-倒计时触发QF段(客户端显示时间) 1-商铺购买间隔 2-倒计时触发QF段 3-定时发时间给客户端，保持统一 4-使用药品间隔 5-拆分合并叠加物品间隔  6-人物，英雄连击消息间隔 7-点击NPC链接间隔 8-英雄召唤退出间隔 9-购买箱子钥匙间隔
    m_sMapQFStr: string; //SENDTIMEMSG命令设置的触发段 20090124
    m_sMapQFStr1: string; //SENDMSGWINDOWS命令设置的触发段 20090124
    m_sMessageBoxStr1: string; //MESSAGEBOX命令设置触发段1 20090816
    m_sMessageBoxStr2: string; //MESSAGEBOX命令设置触发段2 20090816
    m_boForMapShowHint: Boolean; //换地图是否还显示倒计时信息 20090128
    m_boShowExpCrystal: Boolean; //是否显示天地结晶图标 20090131
    m_CrystalLevel: Byte; //天地结晶等级 20090131
    m_CrystalExp: LongWord; //天地结晶当前经验 20090131
    m_CrystalMaxExp: LongWord; //天地结晶升级经验 20090131
    m_CrystalNGExp: LongWord; //天地结晶当前内功经验 20090131
    m_CrystalNGMaxExp: LongWord; //天地结晶内功升级经验 20090131
    m_boGetExpCrystalExp: Boolean; //是否可以提取经验 20090201
    m_nGetCrystalExp: LongWord; //可提取天地结晶经验 20090201
    m_nGetCrystalNGExp: LongWord; //天可提取地结晶内功经验 20090201
    m_dwSayMyInfoTick: LongWord; //发广告间隔

    m_boShowCattleGas: Boolean; //是否显示气牛管图标 20090518
    m_CattleGasLevel: Byte; //牛气等级 20090518
    m_CattleGasExp: LongWord; //当前牛气值 20090518
    m_CattleGasMaxExp: LongWord; //牛气值升级经验 20090518
    m_CattleGasHint: Boolean; //提示牛气管将满 20090519
    m_CattleGasOpenBox: Boolean; //是开启牛气箱子 20090524

    m_boBuyShopItem: Boolean; //正在购买商铺物品中 20090114
    m_boDealing: Boolean; //正在交易中
    m_DealLastTick: LongWord; //交易最后操作时间
    m_DealCreat: TPlayObject; //交易的主动方

    m_GroupOwner: TPlayObject; //组队队长
    m_GroupMembers: TStringList; //组成员
    m_boHearWhisper: Boolean; //允许私聊
    m_boBanShout: Boolean; //允许群聊
    m_boBanGmMsg: Boolean; //允许接收所有喊话 20080211
    m_boBanGuildChat: Boolean; //拒绝行会聊天
    m_boAllowDeal: Boolean; //是不允许交易
    m_BlockWhisperList: TStringList; //禁止私聊人员列表

    m_nHungerStatus: Integer; //饥饿状态
    m_boAllowGuildReCall: Boolean; //行会合一
    m_wGroupRcallTime: Word; //队传送时间
    m_boAllowGroupReCall: Boolean; //0x10E

    m_boSellOffOK: Boolean; //确认元宝寄售标志20080316
    m_SellOffItemList: TList; //元宝寄售物品列表 20080316
    m_dwCheckItmeDayTick: LongWord; //处理物品时间的间隔
    m_dwCheckItmeDayTick1: LongWord;
{$IF M2Version <> 2}
    m_MyDivision: TObject; //我的师门
    m_nApplyDivisionPage: Integer; //申请入门派当前页数

    m_HeartArrTick: LongWord; //心法操作时间
    
    m_MagicSkill_105: pTUserMagic; //龙卫心法
    m_MagicSkill_106: pTUserMagic; //传承心法
    m_MagicSkill_107: pTUserMagic; //纵横剑术
    m_MagicSkill_108: pTUserMagic; //冰霜雪雨
    m_MagicSkill_109: pTUserMagic; //裂神符
    m_MagicSkill_113: pTUserMagic; //天雷乱舞
    m_SkillHit_113: Byte; //天雷攻击次数(吟唱状态)
    m_SkillHit_X: Integer;
    m_SkillHit_Y: Integer;
    dw_SkillHitTick: LongWord;
    mHeartSkillTick: LongWord; //主动神技间隔
    m_sHeartName: string[12]; //心法名称(自定义)
    m_nHeartType: Byte; //心法类型
    m_Contribution: LongWord; //贡献值

    m_RefineItemList: TList; //淬练物品列表 20080502
    m_wHumTitles: THumTitles; //人物称号
    m_boCanTitle: Boolean; //是否有称号(取值时，判断，以不必每个人都再次处理)
    m_boUseTitle: Boolean; //当前是否使用称号(用于发群体消息时，判断使用)
    m_boUseIitleIdx: Word; //当前使用称号的图片索引(用于发群体消息时，判断使用)
    m_sUseIitleName: string[ACTORNAMELEN]; //称号名
    m_dwUseTitleTick: LongWord; //处理称号时间的间隔
    m_dwUseTitleTick1: LongWord;

    m_boFengHaoPower: Boolean; //封号增加攻击倍率
    m_nFengHaoMinPowerRate: Integer; //封号最低攻击倍率
    m_nFengHaoMaxPowerRate: Integer; //封号最高攻击倍率
    m_nDieCount: Byte; //一天死亡次数(包括英雄),超过3次则攻击倍率恢复正常

    m_GroupOwnerExp: Boolean; //组队队长,经验翻倍
    m_boShowFengHao: Boolean; //是否显示称号
    m_boFengHaoMagicEffect: Boolean; //魔法粉红效果(传奇之星)
    m_HuhuaList: TStringList; //护花使者列表
    m_boFengHaoHuhua: Boolean; //护花使者称号
    m_sHuhuaName: string[ACTORNAMELEN]; //对应的传奇之星名字
    m_AttackShowMsgTick: LongWord; //受攻击提示间隔
    m_SendNameListMsgTick: LongWord; //发送称号列表间隔
    m_ComradeList: TStringList; //龙卫列表
    m_boFengHaoDominate: Boolean; //主宰称号
    m_boFengHaoComrade: Boolean; //主宰龙卫
    m_sDominateName: string[ACTORNAMELEN]; //对应的主宰名字
    m_CallFengHaoPlayTick: LongWord; //召唤人员间隔
    m_boCallFengHaoPlay: Boolean; //是否正在召唤或传送人员
    m_boSendDominateMapName: Boolean; //是否发送过地图列表
    m_boOpenDominateToken: Boolean; //是否打开主宰令牌
    m_boFengHaoAgree: Boolean; //是否发送过确认信息
    m_nFenghaotype: Byte; //确认后触发类型标识,QF段 @FENGHAOAGREE+类型
    m_sFenghaoName: string[ACTORNAMELEN]; //发送确认人名
{$IFEND}
    m_DealItemList: TList; //交易物品列表
    m_nDealGolds: Integer; //交易的金币数量(Dword)
    m_boDealOK: Boolean; //确认交易标志(Byte)  确认元宝寄售标志20080316

    m_boAllowGroup: Boolean; //允许组队
    m_boAllowGuild: Boolean; //允许加入行会

    m_dwShoutMsgTick: LongWord; //喊消息间隔

    m_dwStorageType: Byte; //打开的仓库类型 1-移动仓库 2-无限仓库 20090901
    m_StorageItemList: TList; //移动仓库

    //m_dwHitIntervalTime: LongWord; //攻击间隔  20080826 未使用
    m_dwMagicHitIntervalTime: LongWord; //魔法间隔
    m_dwRunIntervalTime: LongWord; //跑步间隔
    m_dwWalkIntervalTime: LongWord; //走路间隔
    m_dwTurnIntervalTime: LongWord; //换方向间隔
    m_dwActionIntervalTime: LongWord; //组合操作间隔
    m_dwRunLongHitIntervalTime: LongWord; //移动刺杀间隔
    m_dwRunHitIntervalTime: LongWord; //跑位攻击间隔
    m_dwWalkHitIntervalTime: LongWord; //走位攻击间隔
    m_dwRunMagicIntervalTime: LongWord; //跑位魔法间隔

    m_dwMagicAttackTick: LongWord; //魔法攻击时间(Dword)
    m_dwMagicAttackInterval: LongWord; //魔法攻击间隔时间(Dword)
    m_dwAttackTick: LongWord; //攻击时间(Dword)
    m_dwMoveTick: LongWord; //人物跑动时间(Dword)
    m_dwAttackCount: LongWord; //人物攻击计数(Dword)
    m_dwAttackCountA: LongWord; //人物攻击计数(Dword)
    m_dwMagicAttackCount: LongWord; //魔法攻击计数(Dword)
    m_dwMoveCount: LongWord; //人物跑计数(Dword)
    m_dwMoveCountA: LongWord; //人物跑计数(Dword)
    m_nOverSpeedCount: Integer; //超速计数(Dword)
    m_boDieInFight3Zone: Boolean; //0x628
    m_Script: pTScript; //0x62C
    m_NPC: TBaseObject; //0x630
    m_nVal: array[0..99] of Integer; //玩家的变量
    m_nMval: array[0..99] of Integer; //玩家的变量
    m_DyVal: array[0..99] of Integer; //玩家的变量
    m_sPlayDiceLabel: string;
    m_boTimeRecall: Boolean; //0x684
    m_dwTimeRecallTick: LongWord;
    m_sMoveMap: string; //0x68C
    m_nMoveX: Integer; //0x690
    m_nMoveY: Integer; //0x694
    m_dwSaveRcdTick: LongWord; //保存人物数据时间间隔
    m_nBright: Integer; //0x6A4
    m_boNewHuman: Boolean; //新人物
    m_boSendNotice: Boolean; //0x6A9
    m_dwWaitLoginNoticeOKTick: LongWord;
    m_boLoginNoticeOK: Boolean; //在游戏公告上点了确定
    bo6AB: Boolean; //0x6AB
    m_boExpire: Boolean; //帐号过期
    m_dwShowLineNoticeTick: LongWord; //0x6B0
    m_nShowLineNoticeIdx: Integer; //当前显示公告的ID
    m_nShowHangAutoMsgIdx: Integer; //挂机自动回复信息的ID

    m_nSoftVersionDateEx: Integer; //客户端版本日期
    m_CanJmpScriptLableList: TStringList; //能跳转脚本标签列表
    m_nScriptGotoCount: Integer; //脚本跳转GOTO数
    m_sScriptCurrLable: string; //用于处理 @back 脚本命令
    m_sScriptGoBackLable: string; //用于处理 @back 脚本命令
    m_dwTurnTick: LongWord; //转向间隔
    m_wOldIdent: Word; //旧的动作消息
    m_btOldDir: Byte; //旧的方向

    //m_boFirstAction: Boolean; //第一个操作  未使用 20080329
    m_dwActionTick: LongWord; //二次操作之间间隔时间
    m_sDearName: string[ACTORNAMELEN]; //配偶名称
    m_DearHuman: TPlayObject; //配偶类
    m_boMarryMsg: Boolean; //是否允许求婚
    m_boCanDearRecall: Boolean; //是否允许夫妻传送
    m_boCanMasterRecall: Boolean; //是否允许师徒传送
    m_dwDearRecallTick: LongWord; //夫妻传送间隔
    m_dwMasterRecallTick: LongWord; //师徒传送间隔

    m_boReadMasterMsg: Boolean; //允许收徒弟 20090209
    m_sMasterName: string[ACTORNAMELEN]; //师傅名称
    m_MasterHuman: TPlayObject;
    m_MasterList: TList; //徒弟列表
    m_boMaster: Boolean; //是否是徒弟  T-有徒弟
    m_nMasterNo: Word; //徒弟排名 20080530
    m_MasterNoList: TStringList; //徒弟排名列表 20080530

    m_btCreditPoint: Integer; //声望点 20080118
    m_btMarryCount: Byte; //离婚次数
    m_btReLevel: Byte; //转生等级
    m_btReColorIdx: Byte;
    m_dwReColorTick: LongWord;
    m_dwGetMsgTick: LongWord; //处理消息循环时间控制
    m_dwCheckTakeItemTick: LongWord; //检查身上不合法装备间隔

    m_boSetStoragePwd: Boolean; //设置仓库密码
    m_boReConfigPwd: Boolean;
    m_boCheckOldPwd: Boolean; //是否检查旧密码
    m_boUnLockPwd: Boolean; //解锁定
    m_boUnLockStoragePwd: Boolean; //锁定仓仓库密码
    m_boPasswordLocked: Boolean; //锁密码
    m_btPwdFailCount: Byte;
    m_boLockLogon: Boolean; //是否启用锁登录功能
    m_boLockLogoned: Boolean; //是否打开登录锁(解锁)
    m_sTempPwd: string[7]; //临时密码
    m_sStoragePwd: string[7]; //仓库密码
    m_PoseBaseObject: TBaseObject; //面对面的角色
    m_boStartMarry: Boolean;
    m_boStartMaster: Boolean; //开始收徒或拜师
    m_boStartUnMarry: Boolean;
    m_boStartUnMaster: Boolean; //开始出师
    m_boFilterSendMsg: Boolean; //禁止发方字(发的文字只能自己看到)
    m_nKillMonExpRate: Integer; //杀怪经验倍数(此数除以 100 为真正倍数)
    m_nOldKillMonExpRate: Integer; //没使用套装前杀怪经验倍数 20080522
    m_nItmeIncMonExpRate: Integer; //使用套装增加的经验 20080607

    m_nPowerRate: Integer; //人物攻击力倍数(此数除以 100 为真正倍数)
    m_dwPowerRateTime: LongWord; //人物攻击力倍数改变恢复正常的时间计数(秒)

    m_dwKillMonExpRateTime: LongWord; //调整杀怪经验倍数后的使用时间(秒)
    m_dwRateTick: LongWord;
    m_boHighLevelKillMonFixExp: Boolean; //高等级杀怪经验不变
    m_dwHighLevelKillMonFixExpTime: LongWord; //高等级杀怪经验不变的使用时间(秒) 20090213

    m_dwUseItmeChangMsgFColorTime: LongWord; //使用物品改变说话颜色的使用时间(秒) 玄绿,玄紫,玄褐 20090221
    m_dwUseItmeChangMsgFColorType: Byte; //使用物品改变说话颜色的类型 1-玄绿 2-玄紫 3-玄褐 200902

    m_boCanUseItem: Boolean; //是否允许使用物品
    m_boCanDeal: Boolean; //能交易
    m_boCanDrop: Boolean; //能扔
    m_boCanGetBackItem: Boolean; //取回升级的物品
    m_boCanWalk: Boolean; //是否能走
    m_boCanRun: Boolean; //是否允许跑
    m_boCanHit: Boolean; //是否允许打击
    m_boCanSpell: Boolean; //是否允许魔法
    m_boCanSendMsg: Boolean; //是否允许发送信息

    m_nMemberType: Integer; //会员类型
    m_nMemberLevel: Integer; //会员等级
    m_boSendMsgFlag: Boolean; //发祝福语标志
    m_boChangeItemNameFlag: Boolean;

    m_nGameDiamond: Integer; //金刚石 20071226
    m_nGameGird: Integer; //灵符 20071226
    m_dwDecGameGirdTick: LongWord; //自动修炼强身术减灵符间隔 20100818
    m_nDecGameGird: Byte; //一次减灵符数 20100818
    m_nDecGameGirdCount: Integer; //减灵符次数(强身术) 20100818
    m_nDecGameGirdCount_95: Integer; //主体修炼神冲穴次数
    m_nDecGameGirdCount_Hero95: Integer; //英雄修炼神冲穴次数

    m_btGameGlory: Integer; //荣誉 20080511
    m_nGameGold: Integer; //游戏币(元宝)
    m_boDecGameGold: Boolean; //是否自动减游戏币
    m_dwDecGameGoldTime: LongWord; //自动减游戏币时间
    m_dwDecGameGoldTick: LongWord; //自动减游戏币间隔
    m_nDecGameGold: Integer; //一次减点数

    m_boIncGameGold: Boolean; //是否自动加游戏币
    m_dwIncGameGoldTime: LongWord; //自动加游戏时间
    m_dwIncGameGoldTick: LongWord; //自动加游戏间隔
    m_nIncGameGold: Integer; //一次减点数

    m_nGamePoint: Integer; //游戏点数
    m_dwIncGamePointTick: LongWord; //加游戏点的间隔
    m_dwDecGamePointTick: LongWord; //减游戏点的间隔 20080413

    m_nPayMentPoint: Integer; //秒卡点
    m_dwPayMentPointTick: LongWord; //秒卡点间隔

    m_dwDecHPTick: LongWord; //减HP间隔
    m_dwIncHPTick: LongWord; //加HP间隔

    m_GetWhisperHuman: TPlayObject; //侦听私聊对象
    m_dwClearObjTick: LongWord; //清除对像间隔
    m_wContribution: Word; //贡献度
    m_sRankLevelName: string; //显示名称格式串
    m_boFilterAction: Boolean; //动作过滤
    m_boClientFlag: Boolean; //客户端标志
    //m_nStep: Byte;//20110303注释
    m_nClientFlagMode: Integer;
    m_dwAutoGetExpTick: LongWord; //自动泡点的时间间隔
    m_nAutoGetExpTime: Integer; //自动泡点时间
    m_nAutoGetExpPoint: Integer; //自动泡点数
    m_AutoGetExpEnvir: TEnvirnoment; //自动泡点地图
    m_boAutoGetExpInSafeZone: Boolean;
    m_DynamicVarList: TList; //自定义变量列表
    m_dwClientTick: LongWord; //客户端间隔
    m_boTestSpeedMode: Boolean; //进入速度测试模式

    m_BigStorageItemList: TList; //无限仓库(JS使用 人物名.db分开保存)
    m_boRemoteMsg: Boolean; //是否允许接受消息
    m_boAllowReAlive: Boolean; //是否允许复活

    m_boNotOnlineAddExp: Boolean; //是否是离线挂机人物
    m_dwStartNotOnlineAddExpTime: LongWord; //离线挂机开始时间
    m_dwNotOnlineAddExpTime: LongWord; //离线挂机时长
    m_nNotOnlineAddExpPoint: Integer; //离线挂机每分钟增加经验值
    m_boKickAutoAddExpUser: Boolean; //是否踢出自动挂机人物
    m_dwAutoAddExpPointTick: LongWord;
    m_dwAutoAddExpPointTimeTick: LongWord;
    m_boStartAutoAddExpPoint: Boolean; //是否自动增加经验(挂机)

    m_sAutoSendMsg: string; //自动回复信息
    m_btHearMsgFColor: Byte; //说话字体颜色
    m_btWhisperMsgFColor: Byte; //私聊字体颜色

    m_boTimeGoto: Boolean;
    m_dwTimeGotoTick: LongWord;
    m_sTimeGotoLable: string;
    m_TimeGotoNPC: TObject; //Delaygoto延时跳转

    m_nDealGoldPose: Integer;
    m_nBigStoragePage: Integer; //无限仓库的当前页数
    m_dwDedingUseTick: LongWord; //地钉使用间隔

    m_boRunPlayRobotManage: Boolean; //是否运行个人机器人
    m_PlayRobotManage: TPlayRobotManage; //人物个人机器人

    m_boPlayOffLine: Boolean; //是否下线触发

    m_nInteger: array[0..99] of Integer; //人物变量
    m_sString: array[0..99] of string; //人物变量 S变量
    m_wMasterCount: Word; //徒弟数

    m_PlayOrderList: TStringList; //人物排行(NPC内置)
    m_nSelPlayOrderType: Integer; //选择排行类型 0-等级 1-战士 2-法师 3-道士 4-名师(NPC内置)
    m_nPlayOrderPage: Integer; //选择人物排行页数(NPC内置)
    m_boGetMyLevelOrder: Boolean; //取自己的排名(NPC内置)

    m_nPetsMonHappLogPage: Integer; //宠物快乐度日志当前页数
    m_nPetsMonHappiness: LongWord; //宠物快乐度
    m_sPetsMonName: string[ACTORNAMELEN]; //宠物名称

    m_boWaitHeroDate: Boolean; //是否正在读取英雄数据
    m_TargetTime: LongWord; //锁定目标间隔
    m_boHasHero: Boolean; //是否有英雄(白门英雄)
    m_sHeroCharName: string[ACTORNAMELEN]; //英雄名称
    m_sTempHeroCharName: string[ACTORNAMELEN]; //临时英雄名称,创建英雄时保存用
    m_MyHero: TBaseObject; //我的英雄
    m_boCallHero: Boolean; //是否可以召唤英雄 20080124
    n_HeroSave: Byte; //是否存英雄,1-存英雄 2-已评定主副将英雄
    n_myHeroTpye: Byte; //英雄的类型 0-白日门英雄 1-卧龙英雄 2-主将 3-副将

    m_boPlayDrink: Boolean; //是否请过酒 T-请过酒 20080515
    n_DrinkValue: array[0..1] of Byte; //喝酒的醉酒值 0-NPC 1-玩家 20080517
    n_DrinkCount: Byte; //喝酒的次数(斗酒一次最高6次) 20080517
    m_boHasHeroTwo: Boolean; //是否有卧龙英雄
    n_tempHeroTpye: Byte; //保存临时英雄类型
    m_boMakeWine: Boolean; //是否酿酒 20080620
    n_MakeWineType: Byte; //酿酒的类型 1-普通酒 2-药酒  20080620
    m_MakeWineTime: Integer; //酿酒的时间,即还有多长时间可以取回酒(秒) 20080620
    n_MakeWineItmeType: Byte; //酿酒后,应该可以得到酒的类型 20080620
    n_MakeWineQuality: Byte; //酿酒后,应该可以得到酒的品质 20080620
    n_MakeWineAlcohol: Byte; //酿酒后,应该可以得到酒的酒精度 20080620
    m_dwAddAlcoholTick: LongWord; //增加酒量进度的间隔  20080623
    m_dwDecWineDrinkValueTick: LongWord; //减少醉酒度的间隔  20080623
    n_DrinkWineQuality: Byte; //饮酒时酒的品质 20080623
    n_DrinkWineAlcohol: Byte; //饮酒时酒的度数 20080624
    n_DrinkWineDrunk: Boolean; //喝酒醉了 20080623
    n_InFountainTime: Word; //站在泉水眼的时间 20080624
    dw_UseMedicineTime: Integer; //使用药酒时间,计算长时间没使用药酒 20080623

    m_ClearGamePointDate: Integer; //初始游戏点的日期
{$IF M2Version = 1}
    dw_UseMedicineTime1: Integer; //计算长时间没喝酒
    n_UsesMedicineTime: Integer; //减喝酒时间一分钟计时
    m_MagicSkill_239: pTUserMagic; //怒之施毒术
    m_MagicSkill_240: pTUserMagic; //静之施毒术
    m_MagicSkill_241: pTUserMagic; //怒之月灵
    m_MagicSkill_242: pTUserMagic; //静之月灵

    m_boOpenupSkill95: Boolean; //打通斗转99级
    m_Magic95Skill: pTUserMagic; //斗转星移
    IncSkill95Exping: Boolean; //正在取得斗转星移经验
    m_JingYuanValue: Word; //当前精元值(24时初始)
    m_dwIncJingYuanValueTime: Word; //增加精元值时间(在线30分钟增加100)
    m_InitialJingYuanDate: LongWord; //初始精元值的日期
    m_boLianQiConditions: Boolean; //是否可以炼气
    m_boLianQiing: Boolean; //炼气正在提取

    m_wHumanPulseArr: THumanPulseInfo; //人物脉穴 20090618
    m_nUseBatterTick: LongWord; //使用连击的计时
    m_boUseBatter: Boolean; //使用连击 20090630
    m_nUseBatterTime: LongWord; //发连击消息间隔 20090630
    m_nBatterMagIdx1: Word; //连击技能ID1 20090701
    m_nBatterMagIdx2: Word; //连击技能ID2 20090701
    m_nBatterMagIdx3: Word; //连击技能ID3 20090701
    m_nBatterMagIdx4: Word; //连击技能ID4
    m_boTrainBatterSkill: Boolean; //是否学习过连击技能 20090702
    m_boSendCanBatterMsg: Boolean; //发送可使用连击消息 20090702

    m_boUser4BatterSkill: Boolean; //使用第四格连击 20100720
    m_SetBatterKey: Byte; //第一个连击技能格 20090702
    m_SetBatterKey1: Byte; //第二个连击技能格 20090702
    m_SetBatterKey2: Byte; //第三个连击技能格 20090702
    m_SetBatterKey3: Byte; //第四个连击技能格 20100719

    m_boWarUseBatter: Boolean; //战士连击是否可用
    m_dwLatestWarUseBatterTick: LongWord; //战士连击的间隔
    m_Magic76Skill: pTUserMagic; //三绝杀
    m_Magic79Skill: pTUserMagic; //追心刺
    m_Magic82Skill: pTUserMagic; //断岳斩
    m_Magic85Skill: pTUserMagic; //横扫千军
    m_dwIncTransferTick: LongWord; //斗转值恢复间隔
{$IFEND}
    n_MedicineLevel: Word; //药力值等级 20080623
    m_GiveGuildFountationDate: Integer; //取行会泉水日期
    bo_NPCMove: Boolean; //是否点击,让NPC走动 20080704

    m_boTrainingNG: Boolean; //是否学习过内功 20081002
    m_NGLevel: Word; //内功等级 20081002
    m_ExpSkill69: LongWord; //内功心法当前经验 20080930
    m_MaxExpSkill69: LongWord; //内功心法升级经验 20080930
    m_Skill69NH: Integer; //当前内力值 20080930
    m_Skill69MaxNH: Integer; //最大内力值 20080930
{$IF M2Version <> 2}
    m_dwLatest101Tick: LongWord; //神龙附体间隔
    m_boCanUerSkill101: Boolean; //神龙附体可用
    m_dwUseSkillTime: LongWord; //神龙附体持续时间
    m_dwLatest102Tick: LongWord; //唯我独尊间隔
    m_dwUseSkill102Time: LongWord; //唯我独尊持续时间
    m_dwLatest69Tick: LongWord; //倚天辟地间隔
    m_dwIncNHTick: LongWord; //增加内力值间隔 20081002
    m_nIncNHRecover: Byte; //内力恢复速度%(增加) 20090330
    m_nIncNHPoint: Word; //内力恢复速度(点数) 20090712
    m_boArmsCritPoint: Byte; //武器暴击等级 20100709
    m_nHeapStruckDamage: Integer; //受有武器暴击等级的人物累积攻击点 20100709
    m_SpiritMedia: TUserItem; //灵媒装备位 2010826
    m_nJewelX: Integer; //宝物X坐标
    m_nJewelY: Integer; //宝物Y坐标
    m_boGiveJewelIteming: Boolean; //正在操作给挖宝给物品处理
    m_nSetupMaxLeveltoHPMP: Word; //NPC命令设置人物HP MP上限,按等级计算
    m_dwIncEnergyValueTime: Word; //增加精力值时间(在线1小时增加10点精力值)
    m_nEnergyValue: Byte; //精力值(制造神秘卷轴)
    m_nLuckyValue: Byte; //幸运值(制造神秘卷轴)
    m_nProficiency: Word; //熟练度(制造神秘卷轴)
    m_Magic100Skill: pTUserMagic; //神秘解读
    m_Magic103Skill: pTUserMagic; //召唤巨魔
    m_MagicSkill_200: pTUserMagic; //怒之攻杀
    m_MagicSkill_201: pTUserMagic; //静之攻杀
    m_MagicSkill_202: pTUserMagic; //怒之半月
    m_MagicSkill_203: pTUserMagic; //静之半月
    m_MagicSkill_204: pTUserMagic; //怒之烈火
    m_MagicSkill_205: pTUserMagic; //静之烈火
    m_MagicSkill_206: pTUserMagic; //怒之逐日
    m_MagicSkill_207: pTUserMagic; //静之逐日
    m_MagicSkill_208: pTUserMagic; //怒之火球
    m_MagicSkill_209: pTUserMagic; //静之火球
    m_MagicSkill_210: pTUserMagic; //怒之大火球
    m_MagicSkill_211: pTUserMagic; //静之大火球
    m_MagicSkill_212: pTUserMagic; //怒之火墙
    m_MagicSkill_213: pTUserMagic; //静之火墙
    m_MagicSkill_214: pTUserMagic; //怒之地狱火
    m_MagicSkill_215: pTUserMagic; //静之地狱火
    m_MagicSkill_216: pTUserMagic; //怒之疾光电影
    m_MagicSkill_217: pTUserMagic; //静之疾光电影
    m_MagicSkill_218: pTUserMagic; //怒之爆裂火焰
    m_MagicSkill_219: pTUserMagic; //静之爆裂火焰
    m_MagicSkill_220: pTUserMagic; //怒之冰咆哮
    m_MagicSkill_221: pTUserMagic; //静之冰咆哮
    m_MagicSkill_222: pTUserMagic; //怒之雷电
    m_MagicSkill_223: pTUserMagic; //静之雷电
    m_MagicSkill_224: pTUserMagic; //怒之地狱雷光
    m_MagicSkill_225: pTUserMagic; //静之地狱雷光
    m_MagicSkill_226: pTUserMagic; //怒之寒冰掌
    m_MagicSkill_227: pTUserMagic; //静之寒冰掌
    m_MagicSkill_228: pTUserMagic; //怒之灭天火
    m_MagicSkill_229: pTUserMagic; //静之灭天火

    m_MagicSkill_230: pTUserMagic; //怒之火符
    m_MagicSkill_231: pTUserMagic; //静之火符
    m_MagicSkill_232: pTUserMagic; //怒之噬血
    m_MagicSkill_233: pTUserMagic; //静之噬血
    m_MagicSkill_234: pTUserMagic; //怒之流星火雨
    m_MagicSkill_235: pTUserMagic; //静之流星火雨

    m_MagicSkill_236: pTUserMagic; //怒之内功剑法
    m_MagicSkill_237: pTUserMagic; //静之内功剑法
    m_MagicSkill_238: pTUserMagic; //静之开天斩
{$IFEND}
    m_Boxs: TList; //随机取的宝箱物品 20080116
    n_BoxsItmeID: Integer; //随机给玩家的物品ID
    m_boOpenBox: Boolean; //是否宝箱在打开 20080407
    n_OpenBoxTpye: byte; //打开宝箱的类型 0-不可填充 1-可填充 2-九周年宝箱 3-20格箱子
    m_OpenBoxMakeID: Integer; //打开箱子时，没钥匙时，记录ID
    m_boCanRotation: Boolean; //是否可以转动宝箱
    n_KeyAnicount: Byte; //钥匙标实
    n_OpenBoxCount: Word; //转动宝箱的次数
    n_BoxItmeFilledCount: Byte; //物品填充次数
    m_boGivePlayItme: Boolean; //给玩家物品
    m_boNoCanRotation: Boolean; //用于标识提示用户无同类宝箱
    m_boUpdate9YearsBoxsItem: Boolean; //正在更新九周年物品

    n_9YearBoxsID: Integer; //九周年宝箱{宝箱类型,即Source},没钥匙时，记录ID
    n_9YearUpdateCount: Byte; //更换物品次数
    m_boFree9YearsBox: Boolean; //是否取得免费奖励20格箱子
    m_boOpenNew9YearBox: Boolean; //是否打开新的9周年箱(用于20格箱子后，“开启新天赐”时使用)

    n_LevelOrder: Word; //玩家当前等级排名 20080214
    //dwGetLevelOrderTick: LongWord;//查询玩家等级排名的间隔 20080214

    dwRunHumanModeTick: LongWord; //穿人模式的间隔 20080221
    dwRunHumanModeTime: LongWord; //穿人模式的时间 20080221
    m_boRunHumanMode: Boolean; //是否可以改变穿人模式  20080221

    n_UsesItemTick: Integer; //聚灵珠聚集时间 20080221
    n_UsesItemTime: Integer; //聚灵珠发送剩余时间消息的时间 20080307
    bo_YBDEAL: Boolean; //是否开通元宝寄售 20080316
{$IF HEROVERSION = 1}
    m_nRecallHeroTime: LongWord; //召唤主将英雄间隔时间
    m_nRecallDeputyHeroTime: LongWord; //召唤副将英雄间隔时间
{$IFEND}
    m_OnTimerList: TList; //个人定时器 20100617

    m_boChallengeing: Boolean; //是否在挑战中 20080705
    m_ChallengeCreat: TPlayObject; //挑战的对像 20080705
    m_ChallengeItemList: TList; //挑战物品列表 20080705
    m_nChallengeGolds: Integer; //挑战的金币数量 20080705
    m_nChallengeGAMEDIAMOND: Integer; //挑战的金刚石 20080705
    m_boChallengeOK: Boolean; //确认开始挑战标志 20080705
    m_ChallengeLastTick: LongWord; //挑战放物品最后操作时间  20080705
    m_ChallengeTime: LongWord; //挑战计时 20080705

    dwRockAddHPTick: LongWord; //魔血石类HP 使用间隔 20080728
    dwRockAddMPTick: LongWord; //魔血石类MP 使用间隔 20080728
    m_dwClientQueryBagItemsTick : DWord;//防止刷包过快 By TasNat at: 2012-05-14 10:55:47
    m_boCanQueryBag: Boolean; //是否可以刷新包裹 20080907
    m_boCanQueryShopItme: Boolean; //是否可以刷新商铺 20080907
    m_boHeroLogOut: Boolean; //英雄退出(包裹传递时用于判断) 20080909

    m_TagMapInfos: TagMapInfos; //人物记路标石 20081019
    m_GetExp: LongWord; //人物取得的经验,$GETEXP变量使用  20081228
    m_BuyShopPrice: Integer; //每次商铺花的元宝数量，$BUYSHOP变量使用 20090106
    m_UseGameGird: Integer; //每次使用灵符数，$USEGAMEGIRD变量使用 20090108

    m_sMapName136: string[MAPNAMELEN]; //魔王岭地图名称 20090204
    m_nIncDragonRate: Byte; //合击伤害比例(增加) 20090330
    m_nIncDragon: Word; //增加合击威力点数

    m_ShowThunderAndLavaTick: LongWord; //处理雷电，岩浆的间隔 20090505
    m_boMergerIteming: Boolean; //是否正在合并物品 20090616
    m_boMergerKimNeedle: Boolean; //是否正在锻练金针 20090616

    m_PulseAddAC: Byte; //命令增加 防御上限
    m_PulseAddAC1: Byte; //命令增加 防御下限
    m_PulseAddMAC: Byte; //命令增加 魔御上限
    m_PulseAddMAC1: Byte; //命令增加 魔御上限

    m_boSendCanBatterTick: Boolean; //20090726
    m_nWinNGExp: LongWord; //累计内功经验，内功珠使用 20090814
    m_boNPCCanGoto: Boolean; //@@InPutString @@InPutInteger 跳转标识 20090818
    m_dwSkill50Tick: LongWord; //人物无极真气间隔
    m_nSendMsgCount: Word; //发消息次数

    m_boCallDeputyHero: Boolean; //是否召唤副将英雄
    m_sDeputyHeroName: string[ACTORNAMELEN]; //副将英雄名字(评定时赋值，同时保存到文件里)
    m_btDeputyHeroJob: Byte; //所选副将职业 0-战 1-法 2-道 3-刺客
    m_nHeroLevel1: Word; //主将英雄等级
    m_nHeroLevel2: Word; //副将英雄等级
    m_nHeroNGLevel1: Word; //主将英雄内功等级
    m_nHeroNGLevel2: Word; //副将英雄内功等级
    m_nMainExp: LongWord; //主将累计经验(当副将等级低于主将3级时使用)
    m_nMainNGExp: LongWord; //主将累计内功经验(当副将等级低于主将3级时使用)
    m_boShowHeroLevel: Boolean; //副将英雄等级受限提示(默认开启)

    m_boHeroAutoPractice: Boolean; //副将英雄是否自动修炼
    m_nHeroAutoPracticePlace: Byte; //自动修炼修炼场所 0-封魔谷(经验+内功经验) 1-雷炎洞穴(大量经验) 2-雪域地图(大量内功经验)
    m_nHeroAutoPracticeStrength: Byte; //自动修炼修炼强度(自动修炼收费) 0-低强度 1-中强度 2-高强度
    m_HeroAutoPracticeTime: LongWord; //自动修炼累计时长
    m_HeroAutoPracticeTick: LongWord; //自动修炼间隔
    m_boMainHeroDie: Boolean; //主将死亡
    m_boMainHeroDieTick: LongWord; //主将死亡计时，用于副将复仇模式计时

    m_boHeroDieTreatment: Boolean; //英雄死亡处理中
    m_boButching: Boolean; //正在挖中
    m_sTmpStr  : string;//触发脚本用不同触发意义不同
    m_ShopItemList: TList; //个人商店列表
    ClientSuitAbility: TClientSuitAbility; //套装最高属性
  private
    function ClientDropGold(nGold: Integer): Boolean;
    procedure ClientQueryUserState(BaseObject: TBaseObject; nX, nY: Integer); //查看角色装备
    //procedure ClientQueryUserSet(ProcessMsg: pTProcessMessage); //未使用 20080907
    function ClientDropItem(sItemName: string; nItemIdx: Integer): Boolean;
    function ClientPickUpItem: Boolean;
    procedure ClientOpenDoor(nX, nY: Integer); //客户端打开门
    function UseStdmodeFunItem(StdItem: pTStdItem): Boolean; //使用物品触发脚本段
    function CheckStdmodeFunItem(StdItem: pTStdItem): Boolean; //检查包裹是否有指定物品，是否达到指定数 药绳捆使用 20081217
    procedure ClientUseItems(nItemIdx, nX, nY: Integer; sItemName: string); //客户端使用物品
    function ItemDblClick(sItemName: string; nMakeIndex: Integer; var sMapName: string; var nCurrX, nCurrY: Integer): Boolean;
    function ClientGetButchItem(BaseObject: TBaseObject; nX, nY: Integer; btDir: Byte; var dwDelayTime: LongWord): Boolean;
    procedure ClientChangeMagicKey(nSkillIdx, nKey: Integer; sMsg: string);
    procedure ClientClickNPC(NPC: Integer);
    procedure ClientMerchantDlgSelect(nParam1: Integer; sMsg: string; wMsgLen : Word);
    procedure ClientMerchantDlgSelectPLAYDICELabel(nParam1: Integer);
    procedure ClientMerchantQuerySellPrice(nParam1, nMakeIndex: Integer; sMsg: string);
    procedure ClientUserSellItem(nParam1, nMakeIndex: Integer; sMsg: string);
    procedure ClientUserBuyItem(nIdent, nParam1, nInt, nZz: Integer; sMsg: string);
    procedure ClientQueryRepairCost(nParam1, nInt: Integer; sMsg: string);
    procedure ClientRepairItem(nParam1, nInt: Integer; sMsg: string);
    procedure ClientGetShopItemList(nPage, nType: Integer); //客户端取商铺物品 20080730
    procedure ClientBuyShopItem(sItemName: string; nBuyType {付费类型0-元宝或金币 1-游戏点}: Byte); //客户端购买商铺物品 20080730
    procedure ClientBuyShopItemGive(sMsg: string; nBuyType {付费类型0-元宝或金币 1-游戏点}: Byte); //客户端商铺赠送 20080730
{$IF M2Version <> 2}
    procedure ClientExchangeGameGird(nGameGird: Integer; nBuyType {付费类型0-元宝或金币 1-游戏点}: Byte); //客户端商铺兑换灵符 20080730
    //装备兑换卷轴碎片，把装备放到交易框中，取可兑换的数量 20100812
    procedure ClientMerchantQueryArmsExchangeCount(nParam1, nMakeIndex: Integer; sMsg: string);
    //客户端用装备兑换卷轴碎片  20100812
    procedure ClientUserArmsExhange(nParam1, nMakeIndex: Integer; sMsg: string);
    //自动修炼英雄强身术 20100818
    function ClientGameGirdUpSkill99(nCount: Integer): Boolean;
    //鉴定装备物品 20100822
    procedure ClientUserKamPoItems(nMakeIndex, nMakeIndex1: Integer; nType: Byte);
    //更换鉴定物品 20100822
    procedure ClientChangeKamPoItems(nMakeIndex, nMakeIndex1: Integer);
    //新鉴定 By TasNat at: 2012-04-13 18:01:42
    procedure ClientUserNewKamPoItems(nMakeIndex, nMakeIndex1: Integer; sMsg: string);
    procedure SendUpdateKamPoItem(UserItem: pTUserItem); //更新鉴定物品格物品 20100825
    procedure SendEnergyAndLucky(); //发送精力值和幸运值
    procedure ClientUserMakeScrollItems(nMakeIndex: Integer; nType: Byte); //使用羊皮卷制造神秘卷轴
    procedure ClientUserScrollChangeItem(nMakeIndex, nMakeIndex1: Integer); //解读神秘属性 20100826
    procedure SendUseSpiritItems; //发送灵媒装备物品

    procedure ClientTakeOnSpiritItems(nItemIdx: Integer; sItemName: string); //把物品放到灵媒位上 2010080827
    procedure ClientTakeOffSpiritItems(nItemIdx: Integer; sItemName: string); //从灵媒位脱物品 20100828
    procedure ClientJudgeItems(nItemIdx: Integer; sItemName: string); //客户端品评物品 20100830
    procedure ClientFindJewelItems(nItemIdx: Integer; sItemName: string); //客户端使用灵媒搜索宝物 20100903
    procedure ClientDigJewelItems(nX, nY: Integer); //客户端挖宝 20100904
    function Skill101OnOff(): Boolean; //神龙附体
    function Skill69OnOff(): Boolean; //开启倚天辟地
    function Skill102OnOff(): Boolean; //唯我独尊
    procedure Skill102MagicAttack(nX, nY: Integer; nRage: Integer); //3级唯我独尊处理
    procedure GetFengHaoAbility(var FengHaoAbility: TFengHaoAbility); //取称号的属性
    procedure CheckFangHaoMarry(nType: Byte); //检查称号回收
    procedure ClientArmsTearItem(NPC: TObject; nItemIdx: Integer; sMsg: string); //客户端拆分赤炎石 20100708
    procedure CheckItmeAutoItme(btWhere, btStdMode, btShape: Byte); //检查包裹是否有气血石，有则自动穿上 20090302
    procedure PlaySuperRock; //气血石功能 20080729
    procedure ClientUpNGStrongSkill(wMagIdx {技能ID}: Integer); //客户端强化怒之内功 20110604
    procedure ClientQueryDivision(nPage {0-上一页 1-下一页}: Byte); //查看申请入门派窗口
    procedure ClientNameQueryDivision(sUserName: string); //申请入门派窗口,按宗师名查询门派数据
    procedure ClientApplyDivision(sDivisionName: string); //申请(取消)入门派
    procedure ClientAgreeDivisionApply(sUserName: string); //门派老大同意加入门派
    procedure ClientCancelDivisionApply(sUserName: string); //门派老大取消加入门派申请
    procedure ClientDelDivisionUser(sUserName: string); //门派删除成员
    procedure ClientDivisionUpdateNotice(sNotict: string); //修改门派公告
    procedure ClientOpenDivisionDlg; //客户端打开门派对话框
    procedure ClientDivisionMemberList; //取门派成员列表
    procedure ClientDivisionApplyList; //取申请入门列表
    procedure ClientSavvyHeartSkill(nHeart: byte; sSkillName: string); //领悟龙卫心法
    procedure ClientChangeSavvyHeartSkill(nHeart: byte); //更换龙卫心法类型
    procedure ClientDivisionGetFengHao(); //门派界面点击"领取称号",进入脚本触发段
    procedure ClientIncHeartPoint(); //点击Exp按键，执行QF脚本段(999心法吸收功能)
    procedure SendQueryDivision(nPage: Integer);
    procedure ClearIncreaseSkillLevel(); //清除强化技能等级
    procedure MagGroupLighteningHit(nX, nY: Integer); //天雷攻击
{$IFEND}
   { procedure ClientUserSellOffItem(nParam1, nMakeIndex: Integer; sMsg: string); //拍卖   //20080416 去掉拍卖功能
    procedure ClientUserBuySellOffItem(nIdent, nParam1, nInt, nZz: Integer; sMsg: string); //拍卖 }

    procedure ClientGropuClose();
    procedure ClientCreateGroup(sHumName: string);
    procedure ClientAddGroupMember(sHumName: string);
    procedure ClientDelGroupMember(sHumName: string);
    procedure ClientDealTry(sHumName: string); //开始交易
//----------------挑战(20080704)----------------------
    procedure ClientChallenge; //判断玩家是否面对面,是则弹出抵物品窗口
    procedure OpenChallengeDlg(PlayObject: TPlayObject); //打开挑战抵押物品窗口
    procedure ClientAddChallengeItem(nItemIdx: Integer; sItemName: string); //客户端增加抵押物品到挑战框中
    procedure ClientDelChallengeItem(nItemIdx: Integer; sItemName: string); //客户端删除抵押的挑战物品
    procedure SendAddChallengeItem(UserItem: pTUserItem); //发送抵押的挑战物品
    procedure SendDelChallengeItem(UserItem: pTUserItem); //发送删除挑战框中物品后,给客户端更新
    procedure ChallengeCancel; //取消挑战
    procedure ClientCancelChallenge; //客户端取消挑战
    procedure ClientChangeChallengeGold(nGold: Integer); //客户端把金币放到挑战框中
    procedure ClientChangeChallengeDIAMOND(nDIAMOND: Integer); //客户端把金刚石放到挑战框中
    procedure ClientChallengeEnd; //挑战抵押物品结束
    procedure WinGetChallengeItems; //胜方取得物品
//----------元宝寄售系统( 20080316)-------------------
    procedure ClientAddSellOffItem(nItemIdx: Integer; sItemName: string); //客户端增加寄售物品到出售框中
    procedure ClientDelSellOffItem(nItemIdx: Integer; sItemName: string); //客户端删除寄售出售框中物品
    procedure ClientCancelSellOff(); //客户端取消元宝寄售
    procedure ClientSellOffEnd(sBuyCharName: string; nSellGold, nGAMEDIAMOND, nCode: Integer); //客户端元宝寄售结束(出售物品)

    procedure ClientCancelSellOffIng(); //出售人取消正在出售中的交易 20080316
    procedure ClientBuyCancelSellOff(DealCharName: string); //购买人取消交易 20080316
    procedure ClientBuySellOffItme(DealCharName: string); //购买寄售物品 20080318
    procedure GetSellOffGlod; //人物上线,检查是否有交易结束还没得到元宝 20080318

    procedure UpdateSellOffInfo(code: integer); //交易成功后修改数据标识 20080319
//-----------------------------------------------------
    procedure ClientAddDealItem(nItemIdx: Integer; sItemName: string);
    procedure ClientDelDealItem(nItemIdx: Integer; sItemName: string);
    procedure ClientCancelDeal();
    procedure ClientChangeDealGold(nGold: Integer);
    procedure ClientDealEnd();
    procedure ClientStorageItem(NPC: TObject; nItemIdx: Integer; sMsg: string);
    procedure ClientTakeBackStorageItem(NPC: TObject; nItemIdx: Integer; sMsg: string);
    procedure ClientGetMinMap();
    procedure ClientMakeDrugItem(NPC: TObject; nItemName: string);
    procedure ClientOpenGuildDlg();
    procedure ClientGuildHome();
    procedure ClientGuildMemberList();
    procedure ClientGuildAddMember(sHumName: string);
    procedure ClientGuildDelMember(sHumName: string);
    procedure ClientGuildUpdateNotice(sNotict: string);
    procedure ClientGuildUpdateRankInfo(sRankInfo: string);
    procedure ClientGuildAlly();
    procedure ClientGuildBreakAlly(sGuildName: string);
    procedure ClientAdjustBonus(nPoint: Integer; sMsg: string);
    function ClientChangeDir(wIdent: Word; nX, nY, nDir: Integer; var dwDelayTime: LongWord): Boolean;
    function ClientWalkXY(wIdent: Word; nX, nY: Integer; boLateDelivery: Boolean; var dwDelayTime: LongWord): Boolean;
    function ClientHorseRunXY(wIdent: Word; nX, nY: Integer; boLateDelivery: Boolean; var dwDelayTime: LongWord): Boolean;
    function ClientRunXY(wIdent: Word; nX, nY: Integer; nFlag: Integer; var dwDelayTime: LongWord): Boolean;

    function ClientHitXY(wIdent: Word; nX, nY, nDir: Integer; boLateDelivery: Boolean; var dwDelayTime: LongWord): Boolean;
    function ClientSitDownHit(nX, nY, nDir: Integer; var dwDelayTime: LongWord): Boolean;
    function ClientSpellXY(wIdent: Word; nKey: Integer; nTargetX, nTargetY: Integer; TargeTBaseObject: TBaseObject; boLateDelivery: Boolean; var dwDelayTime: LongWord; sMsg: string): Boolean;

    procedure UserLevelOrder(BaseObject: TObject); //用户等级排行
    function CheckTakeOnItems(nWhere: Integer; var StdItem: TStdItem): Boolean; //检查装备是否可以穿上身
    function GetUserItemWeitht(nWhere: Integer): Integer; //取物品的重量
    procedure SendDelDealItem(UserItem: pTUserItem); //发送删除交易栏里的物品
    procedure SendAddDealItem(UserItem: pTUserItem); //发送放到交易栏里的物品
    procedure OpenDealDlg(PlayObject: TPlayObject); //打开交易对话框
    function EatItems(StdItem: pTStdItem; nType: Byte): Boolean; //吃物品
    function EatUseItems(nShape: Integer): Boolean; //吃使用物品
    function ReadBook(StdItem: pTStdItem): Boolean; //读书
    //function DayBright(): Byte;//一天的光明   (未使用 20080329)
    procedure BaseObjectMove(sMAP, sX, sY: string); //移动到回城点
    function RepairWeapon(): Boolean; //修理武器
    function SuperRepairWeapon(): Boolean; //超级修理武器
    function WinLottery(): Boolean; //赢彩票
    procedure ChangeServerMakeSlave(SalveInfo: pTSlaveInfo);
    function WeaptonMakeLuck(): Boolean; //武器加幸运
    function PileStones(nX, nY: Integer): Boolean; //挖矿
    procedure MakeMine(); //挖矿,给玩家矿石
    function GetRangeHumanCount(): Integer;
    procedure GetStartPoint(); //取复活点
    procedure LogonTimcCost(); //记录角色登陆的日志(通知LoginSrv修改充值玩家的时间)
    procedure SendEffecItems;//发送物品效果数据
    procedure SendNotice(); //发送公告
    procedure SendLogon();
    procedure SendUnBind(); //发送触发数据
    procedure SendServerStatus();

    procedure ClientQueryUserName(Target: TBaseObject; x, y: Integer);
    procedure SendUseMagic(); //发送使用魔法
    procedure SendSaveItemList(nBaseObject: Integer); //发送仓库物品
    procedure SendSaveBigStorageItemList(nBaseObject: Integer; nPage: Integer); //发送无限仓库物品
    procedure SendDelItemList(ItemList: TStringList);
    procedure SendAdjustBonus(); //发送调整的奖金
    procedure SendChangeGuildName();
    procedure SendMapDescription(); //发送地图音乐背景数据
    procedure SendGoldInfo(boSendName: Boolean);
    procedure SendGloryInfo();
    procedure ShowMapInfo(sMAP, sX, sY: string);
    function CancelGroup(): Boolean;

    procedure GetOldAbil(var OAbility: TOAbility);
    //procedure ReadAllBook;//未使用 20080329
    procedure CheckItemsDay(); //定时检测物品是否过期  20110520
    function CheckItemsNeed(StdItem: pTStdItem): Boolean;
    function CheckItemBindUse(UserItem: pTUserItem): Boolean; //检查物品是当前账号的物品
    function CheckActionStatus(wIdent: Word; var dwDelayTime: LongWord): Boolean; //检查动作状态
    procedure RecalcAdjusBonus;
    procedure CheckMarry();
    procedure RefMyStatus;
    procedure ProcessClientPassword(ProcessMsg: pTProcessMessage);
    function CheckDenyLogon: Boolean;
    procedure ProcessSpiritSuite;
    function HorseRunTo(btDir: Byte; boFlag: Boolean): Boolean;
    procedure ClientGetUserOrder(nSortType, nType, nPage: Integer); //用户排行
{$IF HEROVERSION = 1}
    procedure ClientHeroUseItems(nItemIdx: Integer; sItemName: string; nType: Byte);
{$IFEND}
    procedure DelMember(PlayObject: TPlayObject); //删除组队成员
    procedure LeaveGroup();
    procedure PlayGatherFountain; //收集泉水 20080624
    function GetExpCattle(nLevel: Byte; var nMaxCattleExp: LongWord): Boolean; //取牛气管当前等级的牛气值上限值 20090518
    function GetExpCrystal(nLevel: Byte; var nMaxExp, nMaxNGExp: LongWord): Boolean; //取天地结晶当前等级的经验，内功上限值 20090131
    procedure ClientGetExpCrystalData; //客户端点击天地结晶，返回经验等信息 20090201
    function GetItemID(BoxS: TList; ItemType: Integer): Integer; //取开箱子得到的物品ID
{$IF M2Version = 1}
    function ClientBatterHitXY(wIdent: Word; nX, nY, nDir: Integer): Boolean; //战士连击处理 20090706
    procedure ClientUseBatterSpell(TargeTBaseObject: TBaseObject; nTargetX, nTargetY: Integer; sMagicID: string); //使用连击
    procedure UseBatterSpell(nMagicID {技能ID}, StormsHit {暴击率}: Byte);
    procedure BatterAttackDir(TargeTBaseObject: TBaseObject; wHitMode: Word; nDir: Integer; StormsHit {暴击率}: Byte); //战连击处理 20090704

    procedure ClientUserSkillToJingQing(nPage: Byte; nMakeIndex: Integer); //客户端修炼奇经技能
    function GetSkill_95Value(nAC, nAMC: Integer; nLevel: Byte): Word; //计算斗转值上限
    function ClientGameGirdUpSkill95(nType: Byte; nCount: Integer): Boolean; //自动修炼斗转星移
    procedure ClientCheckLianQiConditions(nType: Byte); //检查炼气条件是否达到
    procedure ClientGetLianQiPractice(nType: Byte); //提取炼气所得物品
{$IFEND}
//--------------------------------个人商店--------------------------------------
    function GetBagItemsEx(nItemIdx: Integer): pTUserItem;
    procedure SendDelShopItem(UserItem: pTUserItem); //删除个人商店物品
    procedure SendChangeShop(BaseObject: TBaseObject; boShop: Boolean); //通知客户端，个人商店发生改变
    procedure GetBackShopItems(); //取回摆摊物品
    procedure ClientGetCloseShop(); //收摊
    procedure ClientGetShopItems(Msg: string); //开始摆摊
    procedure ClientClickPlay(BaseObject: TPlayObject; nX, nY: Integer); //别人查看个人商店物品
    procedure ClientBuySelfShopItem(BaseObject: TPlayObject; nX, nY: Integer; sMsg: string); //购买摆摊物品
    procedure ClientGetShopList(); //人物登陆，发送个人商店列表
  public
    constructor Create(); override;
    destructor Destroy; override;
    function GetMagicInfo(sMagicName: string): pTUserMagic; overload;
    function GetMagicInfo(nMagicID: Integer): pTUserMagic; overload;
    function DoMotaebo(nDir: Byte; nMagicLevel: Integer): Boolean;
    procedure ShopCancel(); //取消个人商店
    procedure SendGroupText(sMsg: string); //发送组队文字
    procedure ClearViewRange;
    procedure SendUseitems(); //发送使用物品
    procedure ClientQueryBagItems(); //查询背包物品
    function IsTakeItemForHuShengRing(BaseObject: TBaseObject): Byte;
    procedure SendToAllClientHumProps(bIsHum: Boolean; HumPropPos, Value: Byte);
    procedure ClientTakeOnItems(btWhere: Byte; nItemIdx: Integer; sItemName: string); //人物装配装备到身上的装备位置
    procedure ClientTakeOffItems(btWhere: Byte; nItemIdx: Integer; sItemName: string);
    procedure MoveToHome(); //移动到回城点
    function DoSpell(UserMagic: pTUserMagic; nTargetX, nTargetY: Integer; BaseObject: TBaseObject): Boolean;
    procedure CheckMaster(boAutoUnMaster: Boolean);
{$IF HEROVERSION = 1}
    function MakeHero(PlayObject: TPlayObject; HumanRcd: THumDataInfo; NewHeroDataInfo: TNewHeroDataInfo; nType: Byte): TBaseObject;
    procedure ClientRecallHero(); //召唤英雄
    procedure ClientHeroUseSpell; //使用合击
    procedure ClientRecallDeputyHero(); //召唤副将英雄
    procedure ClientHeroLogOut(nCode: Byte); //英雄退出
    procedure ClientTakeOnItemsFormBag(nIndex: Integer; btWhere: Byte; nItemIdx: Integer; sItemName: string);
    procedure ClientHeroTakeOnItems(btWhere: Byte; nItemIdx: Integer; sItemName: string); //英雄装配装备到身上的装备位置
    procedure ClientHeroTakeOffItems(btWhere: Byte; nItemIdx: Integer; sItemName: string);
    //procedure ClientHeroTakeOffItemsToBag(nIndex: Integer; btWhere: Byte; nItemIdx: Integer; sItemName: string);
    procedure ClientBagToBag(nIndex: Integer; nItemIdx: Integer; sItemName: string);
    procedure ClientChgHeroStatus(); //改变英雄状态
    procedure ClientHeroProtect(nX, nY: Integer); //英雄守护
    procedure ClientHeroAttack(BaseObject: TBaseObject; nX, nY: Integer);
    procedure ClientAssessmentMainHero(sHeroName: string; nHeroLevel1, nHeroLevel2: Word); //评定主将英雄
    procedure ClientHeroAutoPractice(nPlace, nStrength: Byte); //英雄自我修炼
{$IFEND}
    function MakeSelf(PlayObject: TPlayObject; sMonName: string; nMaxMob: Integer; dwRoyaltySec: LongWord): TBaseObject;
    function AbilityUp(UserMagic: pTUserMagic): Boolean;
    procedure SearchViewRange(); override;
    procedure PKDie(PlayObject: TPlayObject); //PK死亡
    procedure GameTimeChanged(); //游戏时间改变
    procedure RunNotice();
    function GetMyStatus(): Integer; //取我的状态
    function IncGold(tGold: Integer): Boolean; //增加金币
    procedure IncGamePoint(nGamePoint: Integer);
    procedure IncGameDiaMond(nGameDiaMond: Integer); //20071226 增加金刚石
    procedure IncGameGird(nGameGird: Integer); //20071226 增加灵符
    procedure SendSocket(DefMsg: pTDefaultMessage; sMsg: string); virtual;
    procedure SendDefMessage(wIdent: Word; nRecog: Integer; nParam, nTag, nSeries: Word; sMsg: string); virtual;
    procedure SendDefMessage1(wIdent: Word; nRecog: Integer; nParam, nTag, nSeries: Word; wSessionID: Integer; sMsg: string); //能发两个intger类型参数 20090524
    function IsEnoughBag(): Boolean; //包裹是否满
    procedure SendAddItem(UserItem: pTUserItem); virtual; //增加物品
    procedure SendDelItems(UserItem: pTUserItem); virtual; //删除物品
    procedure Whisper(whostr, saystr: string); virtual; //私聊
 {---------------------------检查未使用过程到此 20080428-----------------------------}
    function IsBlockWhisper(sName: string): Boolean;
    function QuestCheckItem(sItemName: string; var nCount: Integer; var nParam: Integer; var nDura: Integer): pTUserItem;
    function QuestTakeCheckItem(CheckItem: pTUserItem): Boolean;
    procedure GainExp(dwExp: LongWord; nCode: Byte);
    procedure GetExp(dwExp: Int64; boItmeExp: Boolean; nType: Byte);
    procedure GetCattleGasExp(dwExp: LongWord); //取得牛气值 20090519
{$IF M2Version <> 2}
    procedure DoSendHeartInfo(); //发送心法相关数据
    procedure IncreaseSkillLevel(UserMagic: pTUserMagic); //进行技能强化
    function HeartUpAbility(): Boolean; //心法激活,属性改变
    procedure DiscipleHeartUpAbility(); //弟子心法激活
    function IncHeartPoint(nPoint: Int64): Boolean; //龙卫心法经验吸收
    procedure GetNGExp(dwExp: LongWord; Code: Byte); //取得内力经验 20081001
    procedure NGMAGIC_LVEXP(UserMagic: pTUserMagic); //内功技能升级 20081003
    procedure GetNGExpToItem(dwExp: LongWord); //取得的内功经验,累积到内珠珠上 20090814
    procedure CmdNGLevel(Cmd: pTGameCmd; sHumanName: string; nLevel: Integer); //调整人物内功等级
    procedure ClientGetExpTCrystal; //客户端提取天地结晶经验 20090202
    procedure SendNGData; //发送内功数据 20081005
    procedure SendNGResume(nType: Byte); //发送内功减免，伤害，恢复速度数据 20090812
    procedure GetExpToCrystal(dwExp: LongWord; nType: byte); //取经验到天地结晶中 20090202
//--------------------淬炼系统 20080502--------------
    function ClientAddRefineItem(sItemIdx: string): Boolean; //客户端增加物品到淬炼框中
    procedure GetBackRefineItem(); //取备份淬练列表物品
    procedure GetBackRefineItemName(var sItemName, sItemName1, sItemName2: string); //取备份淬练列表物品的名称
    procedure ClientRefineItem; //淬炼
    function WearRefineItem: Boolean; //是火云石
    procedure RepairRefineItem(nItemIdx: Integer; sItemName: string); //修补火云石

    procedure ClientRefineArmyDrum(MainItem, Count: Integer; sMsg: string); // 淬炼军鼓
//---------------------------------------------------
    function CheckItemSpiritMedia(UserItem: pTUserItem): Boolean; overload; //检查物品是否为灵媒物品
    function CheckItemSpiritMedia(UserItem: TUserItem): Boolean; overload; //检查物品是否为灵媒物品
    function RepairSpiritMediaDura: Integer; //修复灵媒需要的持久值
    procedure RepairSpiritMediaItem(DureCount: Integer); //修复灵媒位灵气值
    function CheckFengHaoNeed(var HumTitleDB: THumTitleDB): Boolean; //检查是否可以得到称号
{$IFEND}
    procedure WinExp(dwExp: LongWord);
    procedure GetExpToItem(dwExp: LongWord); //得到的经验累积到聚灵珠 20080221
    procedure SendItemUseTime(dwTime: Integer); //发送聚灵珠使用剩余时间 20080307
    function IsItem_51(nCode: Integer): Boolean; //是否包裹里有聚龙珠 20080308
    function DecGold(nGold: Integer): Boolean;
    procedure DecGamePoint(nGamePoint: Integer); //减游戏点
    procedure DecGameGold(nGameGold: Integer);
   { procedure DecGameDiaMond(nGameDiaMond: Integer);//20071226 金刚石
    procedure DecGameGird(nGameGird: Integer);//20071226 灵符   }
    procedure Run(); override;
    function Operate(ProcessMsg: pTProcessMessage): Boolean; override;
    procedure RecalcAbilitys(); override; //刷新能力
    procedure MakeSaveRcd(var HumanRcd: THumDataInfo);
    procedure SellOffCancel(); //元宝寄售取消出售 20060316
    procedure DealCancel();
    procedure DealCancelA();
    function GetShowName(): string; override;
    procedure GetBackDealItems();
    procedure GetBackSellOffItems(); //取备份元宝寄信列表物品 20080316
    procedure Disappear(); override;
    procedure GoldChange(sChrName: string; nGold: Integer);
    procedure ProcessUserLineMsg(sData: string);
    procedure ProcessSayMsg(sData: string); override;
    procedure ClearStatusTime();
    procedure UserLogon(); virtual; //人物登陆游戏
    procedure RefRankInfo(nRankNo: Integer; sRankName: string);
    procedure RefUserState;
    procedure SendGroupMembers();
    procedure JoinGroup(PlayObject: TPlayObject);
    function GeTBaseObjectInfo(): string;
    function GetHitMsgCount(): Integer;
    function GetSpellMsgCount(): Integer;
    function GetWalkMsgCount(): Integer;
    function GetRunMsgCount(): Integer;
    function GetTurnMsgCount(): Integer;
    function GetSiteDownMsgCount(): Integer;
    function GetDigUpMsgCount(): Integer;
    procedure SetScriptLabel(sLabel: string);
    procedure GetScriptLabel(sMsg: string);
    function LableIsCanJmp(sLabel: string): Boolean;
    function GetMyInfo(): string;
    procedure MakeGhost; override;
    procedure ScatterBagItems(ItemOfCreat: TBaseObject); override;
    procedure DropUseItems(BaseObject: TBaseObject; nBurstRate: Byte); override;
    procedure RecallHuman(sHumName: string);
    procedure SendAddMagic(UserMagic: pTUserMagic);
    procedure SendDelMagic(UserMagic: pTUserMagic);
    procedure ReQuestGuildWar(sGuildName: string);
    procedure SendUpdateItem(UserItem: pTUserItem); //发送更新物品 20071228
    procedure GetBagUseItems(var btDc: Byte; var btSc: Byte; var btMc: Byte; var btDura: Byte);
    function CallMobeItem(): Boolean; //召唤强化卷,把招出的宝宝变成7级  20080221
    procedure RepairAllItem(DureCount: Integer; boDec: Boolean); //修理所有物品
    function RepairAllItemDura: Integer; //全部修复,需要的持久值 20080325
    procedure RandomMove(); //随机移动
    function IsGroupMember(Target: TBaseObject): Boolean; //是组队会员
    procedure Hear(nIndex: Integer; sMsg: string); virtual;
    procedure SendServerConfig(); //发送服务端配置到客户端  20080221 [移动声明位置]
    procedure ClearCopyItem(nCode: Byte; wIndex, MakeIndex: Integer); //清理包裹和仓库复制物品 20080816
    function CheckItemBindDieNoDrop(UserItem: pTUserItem): Boolean; //检查人物装备死亡物品是否爆 20081127
//Cmd开头函数为GM命令
    procedure CmdClearCopyItem(Cmd: pTGameCmd; sName: string); //清理指定玩家复制品 20080816
    procedure CmdShowEffect(Cmd: pTGameCmd; sEffect {, sTime}: string);
    procedure CmdSignMapMove(Cmd: pTGameCmd);
    procedure CmdGetUserItems(Cmd: pTGameCmd; sHumanName, sItemName, sItemCount, sType: string);
    procedure CmdUserCmd(sLable: string);
    function PlayObjectUserCmd(sLable, sParam: string): Boolean;
    procedure CmdEndGuild(); //退出行会
    procedure CmdMemberFunction(sCmd, sParam: string);
    procedure CmdMemberFunctionEx(sCmd, sParam: string);
    procedure CmdSearchDear(sCmd, sParam: string);
    procedure CmdSearchMaster(sCmd, sParam: string);
    procedure CmdDearRecall(sCmd, sParam: string);
    procedure CmdMasterRecall(sCmd, sParam: string);
    procedure CmdClearBagItem(Cmd: pTGameCmd; sHumanName: string); //清理指定玩家背包物品
    procedure CmdShowUseItemInfo(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdBindUseItem(Cmd: pTGameCmd; sHumanName, sItem, sType: string);
    procedure CmdUnBindUseItem(Cmd: pTGameCmd; sHumanName, sItem, sType: string);
    procedure CmdLockLogin(Cmd: pTGameCmd);
    //procedure CmdViewDiary(sCmd: string; nFlag: Integer);//未使用 20080823
    procedure CmdUserMoveXY(sCmd, sX, sY: string);
    procedure CmdSearchHuman(sCmd, sHumanName: string); //
    procedure CmdGroupRecall(sCmd: string);
    procedure CmdAllowGroupReCall(sCmd, sParam: string);
    procedure CmdGuildRecall(sCmd, sParam: string);
    procedure CmdChangeAttackMode(nMode: Integer; sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7: string);
    procedure CmdChangeSalveStatus();
    procedure CmdTakeOnHorse(sCmd, sParam: string);
    procedure CmdTakeOffHorse(sCmd, sParam: string);
    procedure CmdPrvMsg(sCmd: string; nPermission: Integer; sHumanName: string);
    procedure CmdHumanLocal(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdMapMove(Cmd: pTGameCmd; sMapName: string);
    procedure CmdPositionMove(Cmd: pTGameCmd; sMapName, sX, sY: string);
    procedure CmdHumanInfo(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdReLoadAdmin(sCmd: string);
    procedure CmdReloadNpc(sCmd: string; sParam, sParam2, sParam3, sParam4: string);
    procedure CmdReloadManage(Cmd: pTGameCmd; sParam: string);
    procedure CmdReloadRobotManage;
    procedure CmdReloadRobot;
    procedure CmdReloadMonItems();
    procedure CmdAdjustExp(Human: TPlayObject; nExp: Integer);
    procedure CmdAddGuild(Cmd: pTGameCmd; sGuildName, sGuildChief: string);
    procedure CmdDelGuild(Cmd: pTGameCmd; sGuildName: string);
    //procedure CmdGuildWar(sCmd, sGuildName: string);//20080812 注释
    procedure CmdChangeSabukLord(Cmd: pTGameCmd; sCASTLENAME, sGuildName: string; boFlag: Boolean);
    procedure CmdForcedWallconquestWar(Cmd: pTGameCmd; sCASTLENAME: string);
    //procedure CmdOPTraining(sHumanName, sSkillName: string; nLevel: Integer);//20080812 注释
    //procedure CmdOPDeleteSkill(sHumanName, sSkillName: string);//20080812 注释
    procedure CmdReAlive(Cmd: pTGameCmd; sHumanName: string); //复活
    procedure CmdSysMsg(Cmd: pTGameCmd; Text: string); //千里传音  20071228
{$IF M2Version <> 2}
    procedure CmdClearHumTitle(Cmd: pTGameCmd; sName, sHumTitleName: string); //回收玩家称号
    
    procedure GetUseHumTitles(); //取当前称号名
    procedure SendHumTitles(nType: Byte); //发送称号数据
    procedure ClientSetUserTitles(nTitlesMakeIdx {称号制造ID}: Integer; nType {操作类型}: Byte); //客户设置称号
    procedure GetFengHaoList(sFileName: string; var List: TStringList); //读取称号列表(传奇之星，主宰登录时使用)
    procedure SaveFengHaoList(sFileName: string; var List: TStringList); //保存称号列表
    procedure SendFengHaoList(nType: Byte; boOk: Boolean); //发送称号列表
    procedure SendDominatSendList(); //发送主宰令地图名列表
    procedure ClientDominateFly(sMap: string); //使用主宰令地图传送
    procedure ClientCallFengHaoPlay(nTpye {类型 0-护花令牌 1-主宰令牌}, nOperateTpey {操作类型 0-召唤 1-传送}: Byte; sName: string {名字});
    procedure ClientAgreeCallFengHao(nTpye {类型 0-护花令牌 1-主宰令牌}, nOperateTpey {操作类型 0-召唤 1-传送}: Byte); //同意召唤传送
    procedure ClientCancelCallFengHao(nTpye {类型 0-护花令牌 1-主宰令牌}, nOperateTpey {操作类型 0-召唤 1-传送}: Byte); //取消召唤传送
    procedure ClientRecycFengHao(nTpye {类型 0-护花令牌 1-主宰令牌}: Byte; sName: string {名字}); //客户端回收称号
    procedure ClientFenghaoAgree(nTpye {类型 0-不同意 1-同意}: Byte); //任命回复
{$IFEND}
    procedure CmdHeroLevel(Cmd: pTGameCmd; sHeroName: string; nLevel: Integer); //调整英雄等级  20071227
    procedure CmdAdjuestLevel(Cmd: pTGameCmd; sHumanName: string; nLevel: Integer); //调整人物等级
    procedure CmdAdjuestExp(Cmd: pTGameCmd; sHumanName, sExp: string);
    procedure CmdBackStep(sCmd: string; nType, nCount: Integer);
    procedure CmdFreePenalty(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdPKpoint(Cmd: pTGameCmd; sHumanName: string); //查看人物PK值
    procedure CmdIncPkPoint(Cmd: pTGameCmd; sHumanName: string; nPoint: Integer); //调整人物PK值
    procedure CmdHunger(sCmd, sHumanName: string; nHungerPoint: Integer);
    procedure CmdHair(Cmd: pTGameCmd; sHumanName: string; nHair: Integer);
    procedure CmdTrainingSkill(Cmd: pTGameCmd; sHumanName, sSkillName: string; nLevel: Integer; sHero: string);
    procedure CmdTrainingMagic(Cmd: pTGameCmd; sHumanName, sSkillName: string; nLevel: Integer; sHero: string);
    procedure CmdDelSkill(Cmd: pTGameCmd; sHumanName, sSkillName, sHero: string);
    procedure CmdDeleteItem(Cmd: pTGameCmd; sHumanName, sItemName: string; nCount: Integer);
    procedure CmdClearMission(Cmd: pTGameCmd; sHumanName: string);
    //procedure CmdTraining(sSkillName: string; nLevel: Integer);//20080812 注释
    procedure CmdChangeJob(Cmd: pTGameCmd; sHumanName, sJobName: string);
    procedure CmdChangeGender(Cmd: pTGameCmd; sHumanName, sSex: string);
    procedure CmdMission(Cmd: pTGameCmd; sX, sY: string);
    procedure CmdMobPlace(Cmd: pTGameCmd; sX, sY, sMonName, sCount, sNGMon: string);
    procedure CmdMobLevel(Cmd: pTGameCmd; Param: string);
    procedure CmdMobCount(Cmd: pTGameCmd; sMapName: string);
    procedure CmdHumanCount(Cmd: pTGameCmd; sMapName: string);
    procedure CmdDisableFilter(sCmd, sParam1: string);
    procedure CmdChangeUserFull(sCmd, sUserCount: string);
    procedure CmdChangeZenFastStep(sCmd, sFastStep: string);
    procedure CmdReconnection(sCmd, sIPaddr, sPort: string);
    procedure CmdContestPoint(Cmd: pTGameCmd; sGuildName: string);
    procedure CmdStartContest(Cmd: pTGameCmd; sParam1: string);
    procedure CmdEndContest(Cmd: pTGameCmd; sParam1: string);
    procedure CmdAnnouncement(Cmd: pTGameCmd; sGuildName: string);
    procedure CmdKill(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdMakeItem(Cmd: pTGameCmd; sItemName: string; nCount: Integer; sUnKnow: string; nKamPoCount: Integer; sVaUnKnow: string); //制造物品
    procedure CmdSmakeItem(Cmd: pTGameCmd; nWhere, nValueType, nValue: Integer); //调整身上装备附加属性 @SUPERMAKE
    procedure CmdBonuPoint(Cmd: pTGameCmd; sHumName: string; nCount: Integer);
    procedure CmdDelBonuPoint(Cmd: pTGameCmd; sHumName: string);
    procedure CmdRestBonuPoint(Cmd: pTGameCmd; sHumName: string);
    procedure CmdFireBurn(nInt, nTime, nN: Integer);
    procedure CmdTestFire(sCmd: string; nRange, nType, nTime, nPoint: Integer);
    procedure CmdTestStatus(sCmd: string; nType, nTime: Integer);
    procedure CmdDelGold(Cmd: pTGameCmd; sHumName: string; nCount: Integer);
    procedure CmdAddGold(Cmd: pTGameCmd; sHumName: string; nCount: Integer);
    procedure CmdDelGameGold(sCmd, sHumName: string; nPoint: Integer);
    procedure CmdAddGameGold(sCmd, sHumName: string; nPoint: Integer);
    procedure CmdGameGold(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nGold: Integer);
    procedure CmdGameDiaMond(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nGameDiaMond: Integer); //20071226 金刚石
    procedure CmdGameGird(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nGameGird: Integer); //20071226 灵符
    procedure CmdGameGlory(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nGameGlory: Byte); //20080511 调整荣誉值
    procedure CmdHeroLoyal(Cmd: pTGameCmd; sHumanName: string; nHeroLoyal: Integer); //20080109 英雄的忠诚度
    procedure CmdGamePoint(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nPoint: Integer);
    procedure CmdCreditPoint(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nPoint: Integer);
    procedure CmdMob(Cmd: pTGameCmd; sMonName: string; nCount, nLevel, nMonTpye: Integer);
    procedure CmdRefineWeapon(Cmd: pTGameCmd; nDc, nMc, nSc, nHit: Integer);
    procedure CmdRecallMob(Cmd: pTGameCmd; sMonName: string; nCount, nLevel, nAutoChangeColor, nFixColor, nType: Integer);
    procedure CmdRECALLMOBEX(Cmd: pTGameCmd; sMonName: string; nNameColor, nX, nY: Integer; sMap: string); //20080122 召唤宝宝
    procedure CmdGIVEMINE(Cmd: pTGameCmd; sMINEName: string; nMineCount, nDura: Integer); //20080403 给指定纯度的矿石
    procedure CmdMOVEMOBTO(Cmd: pTGameCmd; sMonName, OleMap, NewMap: string; nX, nY, OnX, OnY: Integer); //20080123 将指定坐标的怪物移动到新坐标
    procedure CmdCLEARITEMMAP(Cmd: pTGameCmd; sMap, sItemName: string; nX, nY, nRange: Integer); //20080124 清除地图物品
    procedure CmdLuckPoint(sCmd: string; nPermission: Integer; sHumanName, sCtr, sPoint: string);
    procedure CmdLotteryTicket(sCmd: string; nPermission: Integer; sParam1: string);
    procedure CmdReloadGuild(sCmd: string; nPermission: Integer; sParam1: string);
    procedure CmdReloadLineNotice(sCmd: string; nPermission: Integer; sParam1: string); //重读公告
    procedure CmdReloadAbuse(sCmd: string; nPermission: Integer; sParam1: string);
    procedure CmdMobNpc(sCmd: string; nPermission: Integer; sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7: string);
    procedure CmdNpcScript(sCmd: string; nPermission: Integer; sParam1, sParam2, sParam3: string);
    procedure CmdDelNpc(sCmd: string; nPermission: Integer; sParam1, sParam2, sParam3, sParam4: string);
    procedure CmdKickHuman(Cmd: pTGameCmd; sHumName: string);
    procedure CmdTing(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdSuperTing(Cmd: pTGameCmd; sHumanName, sRange: string);
    procedure CmdMapMoveHuman(Cmd: pTGameCmd; sSrcMap, sDenMap: string);
    procedure CmdShutup(Cmd: pTGameCmd; sHumanName, sTime: string);
    procedure CmdShowMapInfo(Cmd: pTGameCmd; sParam1: string);
    procedure CmdShutupRelease(Cmd: pTGameCmd; sHumanName: string; boAll: Boolean);
    procedure CmdShutupList(Cmd: pTGameCmd; sParam1: string);
    procedure CmdShowSbkGold(Cmd: pTGameCmd; sCASTLENAME, sCtr, sGold: string);
    procedure CmdRecallHuman(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdReGotoHuman(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdShowHumanFlag(sCmd: string; nPermission: Integer; sHumanName, sFlag: string);
    //procedure CmdShowHumanUnitOpen(sCmd: string; nPermission: Integer; sHumanName, sUnit: string);
    //procedure CmdShowHumanUnit(sCmd: string; nPermission: Integer; sHumanName, sUnit: string);
    procedure CmdChangeAdminMode(sCmd: string; nPermission: Integer; sParam1: string; boFlag: Boolean);
    procedure CmdChangeObMode(sCmd: string; nPermission: Integer; sParam1: string; boFlag: Boolean);
    procedure CmdChangeSuperManMode(sCmd: string; nPermission: Integer; sParam1: string; boFlag: Boolean);
    procedure CmdChangeLevel(Cmd: pTGameCmd; sParam1: string);
    procedure CmdChangeDearName(Cmd: pTGameCmd; sHumanName: string; sDearName: string);
    procedure CmdChangeMasterName(Cmd: pTGameCmd; sHumanName: string; sMasterName, sIsMaster: string);
    procedure CmdStartQuest(Cmd: pTGameCmd; sQuestName: string); //全服触发
    procedure CmdSetPermission(Cmd: pTGameCmd; sHumanName, sPermission: string);
    procedure CmdClearMapMonster(Cmd: pTGameCmd; sMapName, sMonName, sItems: string); //清除地图怪物
    procedure CmdReNewLevel(Cmd: pTGameCmd; sHumanName, sLevel: string);

    procedure CmdDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr, sFixDeny: string);
    procedure CmdDelDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr, sFixDeny: string);
    procedure CmdShowDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr, sFixDeny: string);

    procedure CmdDenyAccountLogon(Cmd: pTGameCmd; sAccount, sFixDeny: string);
    procedure CmdDelDenyAccountLogon(Cmd: pTGameCmd; sAccount, sFixDeny: string);
    procedure CmdShowDenyAccountLogon(Cmd: pTGameCmd; sAccount, sFixDeny: string);

    procedure CmdDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny: string);
    procedure CmdDelDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny: string);
    procedure CmdShowDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny: string);
    procedure CmdViewWhisper(Cmd: pTGameCmd; sCharName, sParam2: string);
    procedure CmdSpirtStart(sCmd: string; sParam1: string);
    procedure CmdSpirtStop(sCmd: string; sParam1: string);
    procedure CmdSetMapMode(sCmd: string; sMapName, sMapMode, sParam1, sParam2: string);
    procedure CmdShowMapMode(sCmd: string; sMapName: string);
    procedure CmdClearHumanPassword(sCmd: string; nPermission: Integer; sHumanName: string);

    procedure CmdChangeItemName(sCmd, sMakeIndex, sItemIndex, sItemName: string);
    procedure CmdDisableSendMsg(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdEnableSendMsg(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdDisableSendMsgList(Cmd: pTGameCmd);
    procedure CmdTestGetBagItems(Cmd: pTGameCmd; sParam: string);
    procedure CmdMobFireBurn(Cmd: pTGameCmd; sMAP, sX, sY, sType, sTime, sPoint: string);
    procedure CmdTestSpeedMode(Cmd: pTGameCmd);

    procedure ProcessUserCmd(sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7: string);

    function DieFunc: Boolean;
    function AddSkillFunc(MagicID: Integer): Boolean; //人物学技能触发 20080324
    function HeroAddSkillFunc(MagicID: Integer): Boolean; //英雄学技能触发 20080324

    function LevelUpFunc: Boolean; //升级触发函数
    function NGLevelUpFunc: Boolean; //人物内级等级升级触发 20090509
    function KillPlayFunc: Boolean; //杀死角色函数
    function KillMonsterFunc(BaseObject: TBaseObject): Boolean; //杀死怪物函数
    function KillMissionMob: Boolean; //宝宝杀死怪触发   20080126
    function HeartLevelUpFunc: Boolean; //宝宝杀死怪触发   20080126

    function DieGotoLable(): Boolean; //死亡触发

    function IsGotoLabel(sMapName: string; nX, nY, nRange, nQuestFalgStatus: Integer; boQuestFalgStatus: Boolean; sItemName1, sItemName2: string; boNeedGroup: Boolean; nRandomCount: Integer): Boolean;
    procedure StartMapEventOfDropItem(sItemName: string); //地图事件触发-掉落物品
    procedure StartMapEventOfPickUpItem(sItemName: string); //地图事件触发-捡起物品
    procedure StartMapEventOfMine(); //地图事件触发-挖矿
    procedure StartMapEventOfWalk(); //地图事件触发-走
    procedure StartMapEventOfRun(); //地图事件触发-跑
//-------------祝福罐.魔令包功能-----------------
    function WearDragon: Boolean;
    procedure RepairDragon(btType: Byte; nItemIdx: Integer; sItemName: string);
    procedure ClientDblRepairDragon(); //双击装备位置的祝福罐,自动把包裹里的祝福油填充完毕) 20100928
    function AutoRepairDragon(StdItem: pTStdItem): Boolean; //自动填充祝福油类物品
//---------------------------------------
    procedure ClientSendBoxItem(BoxsIdx: Integer; str: string; boShowEff: Boolean); //判断宝箱和钥匙是否对应 20080305
    function ClientOpenBoxs(sBoxsID {宝箱类型,即Source}, nBoxTpye {0-不填充 1-填充 即Reserved}: Integer; boShowEff {显示特效}, boSendItem {是否发送中间格物品}: Boolean): Boolean; //打开宝箱 20080115
    procedure ClientRotationBoxs(nType: Boolean); //转动宝箱
    procedure ClientGetBoxsItme(nTpye: Byte); //给玩家物品 20080117
    procedure CheckItemsKey(MakeIndex: Integer; Anicount: Byte; BoxClose: Byte; BoShowEff: Boolean); //检查包裹是否有对应的钥匙 20090225
    procedure BuyKeyAutoBox(nTpye: Integer; nShowEff: Byte); //购买宝箱钥匙,给玩家钥匙，并减元宝，自动打开宝箱 20090225
    function GetPlayBoxItem(Anicount: Byte): Integer; //检查包裹里是否有同类宝箱
    procedure ClientUpdateBoxsItme(); //所有填充物品填充完后，检查是否有同类宝箱，则重新刷物品
    procedure ClientCloseBoxs(); //清空个人箱子列表资源,关闭箱子 20090705

    procedure Check9YearsBoxsKey(MakeIndex: Integer; Anicount: Byte; BoxClose: Byte); //打开9周年箱子，检查是否有所需的钥匙
    procedure ClientSend9YearsBoxItem(BoxsIdx {箱子制造ID}, sBoxsID {宝箱类型,即Source}, nBoxTpye {0-不填充 1-填充 2-九周年宝箱 即Reserved}, KeyAnicount {钥匙标识}, nKeyCount {钥匙数量}: Integer); //判断九周年宝箱和钥匙是否对应,对应是打开箱子，并删除箱子及钥匙物品
    procedure ClientBuy9YearsKeyAutoBox(); //购买九周年宝箱钥匙,给玩家钥匙，并减元宝，自动打开宝箱
    procedure Client9YearsOpenBoxs(nType: Boolean; nKeyCount: byte); //开启宝箱,随机选择开到的物品
    procedure ClientCheck9YearsBoxsKey(); //点击“开始选择”，先判断是否有钥匙，没钥匙，则提示购买
    procedure ClientUpdate9YearsBoxsItem(); //未开启前，更新物品(三次机会)
    procedure ClientGet9YearsBoxsItem(); //给玩家9周年宝箱物品
    procedure ClientOpenFree9YearsBoxs(); //免费奖励(20格箱子,选出20个物品，同时选择得到的物品的ID，发送给客户端)
    procedure ClientGetFree9YearsBoxsItem(); //取20格免费奖励宝箱物品
    procedure ClientOpenNew9YearsBoxs(); //开启新天赐(检查是否在天赐)

    procedure UpdateSendMsgCount(); //更新角色的动态密钥(防WPE)

    function GetUserLevelOrder: Integer; //取玩家的等级排名 20080214
    function SellOffInTime(nCode: Integer): Boolean; //查询玩家是否操作过寄售 20080317
    function SelectSellDate: string; //查询玩家交易记录  20080318
{$IF HEROVERSION = 1}
    procedure ClientGetHero(sHeroName: string; nHeroTpye: Byte); //取回英雄 20080514
{$IFEND}
    procedure ClientPlayDrinkItem(NPC: TObject; nItemIdx: Integer; sMsg: string); //请酒 20080515
    procedure ClientPlayDrinkLable(nParam1: Integer; sMsg: string); //请酒信息跳转 20080515
    procedure ClientPlayDrinkToDrink(nParam1: Integer; nPlayNum: Byte); //比较NPC与玩家出码数,并判断输赢 20080516
    procedure ClientDrinkUpdateValue(nParam1: Integer; nPlayNum, nCode: Byte); //喝酒并增加醉酒值 20080517
    procedure ClientPlayDrink(sMsg: string); //请酒 20080517
    procedure ClientPlayMakeWine(nCode: Byte; sMsg: string); //客户端开始酿酒
//----------------------------------------------------
    function GetMasterNoList: Boolean; //读取师徒文件 20080530
    procedure SaveMasterNoList(); //保存师徒文件 20080530
    procedure AddMaster(MasterName: string); //收徒 20080530
    procedure DelMaster(MasterName: string); //出师 20080530
    function IsMyApprentice(sName: string): Boolean; //检查输入的名字是否为自己的徒弟 20090208
    function GetApprenticeName(nMasterNo: Integer): string; //取徒弟名字 20090208
    procedure MasterNoListQuickSort(sList: TStringList; Order: Boolean); //师徒数据排序 20080530
//----------------------------------------------------
    procedure ClientPetsMonHappLog(nPage: Byte); //查看宠物喂养日志
    procedure ClientMoveToPetsMon(); //传送到宠物身旁
    procedure GetBackChallengeItems; //取回之前抵押物品
    function GetSpellPoint(UserMagic: pTUserMagic): Integer; //取技能消耗的MP值

    function ClientUseItmeToWealthAnimalMon(nItemIdx, nX, nY: Integer; TargeTBaseObject: TBaseObject): Boolean; //客户端攻击富贵兽 20090516
    procedure ClientQMissionGoto(sLabel: string; nType: Byte); //客户端QMission NPC跳转 20100801
    procedure RepairDragonIndia(nItemIdx: Integer; sItemName: string); //使用魔血石填充天龙印 20110116
    procedure ClientReQuestGuildWar(sGuildName: string); //客户端申请行会战 20090510

    procedure ClientItemSplit(nItemMakeIdx {制造ID}: Integer; nDura {拆分数量}: Integer); //客户端拆分物品 20090615
    function AutoItemMerger(UserItem: pTUserItem): Boolean; //自动合并叠加物品 20091126
    procedure ClientItemMerger(nItemMakeIdx {需要合并的物品制造ID}: Integer; sMakeIdx {合并到的物品}: string); //客户端合并物品 20090615
    procedure ClientExerciseKimNeedle(nItemMakeIdx {第一个金针的制造ID}: Integer; sMsg: string); //客户端开始锻练金针 20090616
{$IF M2Version = 1}
    function GetSkill95Exp(nLevel: Byte): LongWord; //斗转星移 取等级升级所需经验
    procedure ClientOpenPulsePoint(nPulse {经络页}, nPoint {穴位}: byte);
    procedure ClientBatterNPCGoto(sLable: string); //messagebox命令发送后，客户端点击“确定”后，跳转到BatterNPC脚本段 20090623
    procedure SendUserPulseArr; //登陆时发送脉穴数据 20090621
    procedure SendUpdataPulseArr(nPulse {经络页}: byte); //发送更新脉穴数据 20090623
    procedure ClientPracticePulse(nPulse {经络页}: byte); //客户端修炼经络 20090623
    procedure SendUserPulsePulsePoint(nPulse {经络页}: byte; boOK: Boolean); //发送脉穴对应穴位发亮以及所需的内功等级 20090624
    procedure ClientHeroPracticePulse(nPulse {经络页}: byte); //客户端英雄修炼经络 20090911
    procedure HeroGetPulsExp(dwExp: LongWord); //英雄取经络经验 20090911
    procedure ClientOpenupSkill95(nMakeIndex: Integer; nType: Byte); //打通斗转99级
{$IFEND}
  end;
var
  g_HighLevelHuman: TPlayObject = nil;
  g_HighPKPointHuman: TPlayObject = nil;
  g_HighDCHuman: TPlayObject = nil;
  g_HighMCHuman: TPlayObject = nil;
  g_HighSCHuman: TPlayObject = nil;
  g_HighOnlineHuman: TPlayObject = nil;

implementation

//{$R+}//检查数组越界 20090811

uses M2Share, Guild, HUtil32, EDcode, ObjNpc, IdSrvClient, ItmUnit, Event, WinlicenseSDK,
  ObjAIPlayObject, ObjMon, ObjMon2, LocalDB, Castle, EDcodeUnit, svMain, PlugIn, ObjPlayMon,
  ObjHero, PlugOfEngine, IniFiles, Division;

{ TBaseObject }

constructor TBaseObject.Create;
begin
  Inc(TBaseObjectCount);//检测内存泄露用 By TasNat at: 2012-10-14 19:59:02
  inherited;
  m_boGhost := False;
  m_dwGhostTick := 0;
  m_boDeath := False;
  m_dwDeathTick := 0;
  m_SendRefMsgTick := GetTickCount();
  m_btDirection := 4;
  m_btRaceServer := RC_ANIMAL;
  m_btRaceImg := 0;
  m_btHair := 0;
  m_btJob := 0;
  m_nGold := 0;
  m_wAppr := 0;
  bo2B9 := True;
  m_nViewRange := 5;
  m_sHomeMap := '0';
  m_btPermission := 0;
  m_nLight := 0;
  m_btNameColor := 255;
  m_nHitPlus := 0;
  m_btHitPointSkill88 := 0;
  m_nHitDouble := 0;
  m_dBodyLuck := 0;

  m_boRecallSuite := False;
  //bo245 := False; 注释掉 无用 By TasNat at: 2012-04-01 12:59:15
  //m_boTestGa := False;//20081014 注释
  bo2BA := False;
  m_boAbilSeeHealGauge := False;
  m_boPowerHit := False;
  m_boUseThrusting := False;
  m_boUseHalfMoon := False;
  m_boFireHitSkill := False;
  m_boDailySkill := False; //逐日剑法是否可用 20080511
  m_bo42kill := False; //开天斩是否可用 20080202
  m_bo43kill := False; //龙影剑法是否可用  20080619
  m_boBloodSoulSkill := False; //血魄一击(战)是否可用
  m_n42kill := 0; //开天斩轻击初始化 20080212 1--为轻 2--为重
  m_btHitPoint := 5;
  m_btSpeedPoint := 15;
  m_nHitSpeed := 0;
  m_nRunSpeed := 0; //移动速度
  m_btLifeAttrib := 0;
  m_btAntiPoison := 0;
  m_nPoisonRecover := 0;
  m_nHealthRecover := 0;
  m_nSpellRecover := 0;
  m_nAntiMagic := 0;
  m_nLuck := 0;
  m_nBurstRate := 0; //爆率(击杀对手时，对方爆物品机率) 20091129
  m_nUnBurstRate := 0; //防爆点数
{$IF M2Version <> 2}
  m_nDecTargetNHPoint := 0; //目标内力值减少点数(内伤装备) 20100513
  m_boCanUerSkill102 := False; //唯我独尊可用
{$IFEND}
  m_nUnParalysisRate := 0; //防麻机率(辉煌衣服) 20100513
  m_nParalysisAddRate := 0;
  m_nVampirePoint := 0; //吸血点数(虎威装备)
  m_nVampireRate := 0; //吸血机率(虎威装备)
  m_nIncSpell := 0;
  m_nIncHealth := 0;
  m_nIncHealing := 0;
  m_nPerHealth := 5;
  m_nPerHealing := 5;
  m_nPerSpell := 5;
  m_dwIncHealthSpellTick := GetTickCount();
  m_btGreenPoisoningPoint := 0;
  m_nFightZoneDieCount := 0;
  //  m_nGoldMax       := 5000000;
  m_nGoldMax := g_Config.nHumanMaxGold;
  m_nCharStatus := 0;
  m_nCharStatusEx := 0;
  FillChar(m_wStatusTimeArr, SizeOf(TStatusTime), #0);
  FillChar(m_BonusAbil, SizeOf(TNakedAbility), #0);

  FillChar(m_wStatusArrValue, SizeOf(m_wStatusArrValue), 0);
  FillChar(m_dwStatusArrTimeOutTick, SizeOf(m_dwStatusArrTimeOutTick), #0);

  btB2 := 0;
  m_btAttatckMode := 0;
  m_boInFreePKArea := False;
  m_boGuildWarArea := False;
  bo2B0 := False;
  m_boSuperMan := False;
  m_boButchSkeleton := False; //正在被挖尸体 20090103
  m_boSkeleton := False;
  bo2BF := False;
  m_boHolySeize := False;
  m_boCrazyMode := False;
  m_boShowHP := False;
  bo2F0 := False;
  m_boAnimal := False;
  m_boNoItem := False;
  m_nBodyLeathery := 50;
  m_boFixedHideMode := False;
  m_boStickMode := False;
  m_nStickIncLevel := 0; //称号不动如山增加冲撞技能等级
  m_boNoAttackMode := False;
  m_boPKFlag := False;
  m_nXieLangSutie := 0; //魔血2一套(增加HP上限)
  m_nMoXieSuite := 0;
  m_nHongMoSuite := 0;
  m_db3B0 := 0;
  FillChar(m_AddAbil, SizeOf(TAddAbility), #0);
  m_MsgList := TList.Create;
  m_VisibleHumanList := TList.Create;

  m_VisibleActors := TList.Create;
  m_VisibleItems := TList.Create;
  m_VisibleEvents := TList.Create;
  m_ItemList := TList.Create;
  m_MagicList := TList.Create;
  //m_MagicOfDelList := TList.Create;//防止内存释放后的非法引用 By TasNat at: 2012-03-11 11:49:38
  m_boIsVisibleActive := False;
  m_nProcessRunCount := 0;

  FillChar(m_UseItems, SizeOf(THumanUseItems), 0); //装备栏物品
  m_MagicOneSwordSkill := nil;
  m_MagicPowerHitSkill := nil;
  m_MagicErgumSkill := nil;
  m_Magic89Skill := nil; //四级刺杀
  m_MagicBanwolSkill := nil;
  m_Magic90Skill := nil; //圆月弯刀
  m_MagicFireSwordSkill := nil;
  m_Magic74Skill := nil; //逐日剑法 20080511
  m_Magic96Skill := nil; //血魄一击(战)
  m_MagicCrsSkill := nil;
  m_Magic41Skill := nil;
  m_Magic42Skill := nil;
  m_Magic43Skill := nil;

  m_Castle := nil;
  m_Master := nil;
  n294 := 0;
  m_btSlaveExpLevel := 0;
  m_boSetNameColor := False; //是否自定义名字颜色 20080913

  m_SlaveList := TList.Create;
  FillChar(m_WAbil, SizeOf(TAbility), #0);
  m_Abil.Level := 1;
  m_Abil.AC := 0;
  m_Abil.MAC := 0;
  m_Abil.DC := MakeLong(1, 4);
  m_Abil.MC := MakeLong(1, 2);
  m_Abil.SC := MakeLong(1, 2);
  m_Abil.HP := 15;
  m_Abil.MP := 15;
  m_Abil.MaxHP := 15;
  m_Abil.MaxMP := 15;
  m_Abil.nExp := 0;
  m_Abil.nMaxExp := 50;
  m_Abil.Weight := 0;
  m_Abil.MaxWeight := 100;
  m_boWantRefMsg := False;

  m_MyGuild := nil;
  m_nGuildRankNo := 0;
  m_sGuildRankName := '';
//m_sScriptLable := '';//20080521 从父类移动人物类中
  m_boMission := False;
  m_boHideMode := False;
  m_boStoneMode := False;
  m_boCoolEye := False;
  m_boUserUnLockDurg := False;
  m_boTransparent := False;
  m_boAdminMode := False;
  m_boObMode := False;
  m_dwRunTick := GetTickCount + LongWord(Random(1500));
  m_nRunTime := 250;
  m_dwSearchTime := Random(2000) + 2000;
  m_dwSearchTick := GetTickCount;
  m_dwDecPkPointTick := GetTickCount;
  m_DecLightItemDrugTick := GetTickCount();
  m_dwPoisoningTick := GetTickCount;
  m_dwVerifyTick := GetTickCount();
  m_dwCheckRoyaltyTick := GetTickCount();
  m_dwDecHungerPointTick := GetTickCount();
  m_dwHPMPTick := GetTickCount();
  //m_dwShoutMsgTick := 0;
  m_dwTeleportTick := 0;
  m_dwProbeTick := 0;
  m_dwMapMoveTick := GetTickCount();
  m_dwMasterTick := 0;
  m_nWalkSpeed := 1400;
  m_nNextHitTime := 2000;
  m_nWalkCount := 0;
  m_dwWalkWaitTick := GetTickCount();
  m_boWalkWaitLocked := False;
  m_nHealthTick := 0;
  m_nSpellTick := 0;
  m_TargetCret := nil;
  m_LastHiter := nil;
  m_ExpHitter := nil;
  m_SayMsgList := nil;
  m_boDenyRefStatus := False;
  m_btHorseType := 0;
  m_btDressEffType := 0;
  m_dwPKDieLostExp := 0;
  m_nPKDieLostLevel := 0;
  m_boAddToMaped := True; //地图是否计数
  m_boAutoChangeColor := False;
  m_dwAutoChangeColorTick := GetTickCount();
  m_nAutoChangeIdx := 0;
  m_nChangeColorType := -1; //是否变色

  m_boFixColor := False;
  m_nFixColorIdx := 0;
  m_nFixStatus := -1;
  m_boFastParalysis := False;

  m_nCopyHumanLevel := 0; //复制人状态
  m_dwStationTick := GetTickCount; //站的时间
  m_btLastOutStatus := 0;
  m_boProtectionDefence := False; //是否学有护体神盾 20080218
  m_btMagBubbleDefenceLevel := 0; //魔法盾等级 20080811
  m_boOperationItemList := False; //正在操作背包列表 20080928
  m_boIsNGMonster := False; //内功怪,打死可以增加内力值 20081001
  m_boIsHeroPulsExpMon := False; //英雄经络经验怪 20090911
  m_boRobotObject := False; //20090129
  m_nDecDamage := 0; //吸伤属性 20090618
  m_nDecDamageRate := 0; //道法连击时的吸伤百分率 20090628
  m_boMakeSlave := False; //是否正在召唤下属
  m_boDrinkDrugHotels := False; //是否正在使用药酒
  if g_Config.boStartRevivalTick then m_dwRevivalTick := GetTickCount(); //复活戒指使用间隔计数 20100704
  if g_Config.boStartRebirthTick then m_dwRebirthTick := GetTickCount(); //重生戒指使用间隔计数
  m_boShop := False; //是否开启个人商店
  m_sShopMsg := ''; //个人商店消息
  m_TrueSC := 0; //无极真气不考虑套装效果
  m_boAI := False; //是否是假人
  m_nDropUseItemRate := 100; //假人掉装备机率
end;

destructor TBaseObject.Destroy;
var
  I: Integer;
  SendMessage: pTSendMessage;
  nCheckCode: Integer;
resourcestring
  sExceptionMsg = '{%s} TBaseObject::Destroy Code: %d CharName: %s:: Msg:%s';
begin
  Dec(TBaseObjectCount);
  nCheckCode := 0;
  try
    nCheckCode := 1;
    if m_MsgList <> nil then begin
      if m_MsgList.Count > 0 then begin
        for I := 0 to m_MsgList.Count - 1 do begin
          nCheckCode := 2;
          SendMessage := m_MsgList.Items[I];
          if SendMessage <> nil then begin //20090115
            if (SendMessage.wIdent = RM_SENDDELITEMLIST) and (SendMessage.nParam1 <> 0) then begin
              nCheckCode := 3;
              if TStringList(SendMessage.nParam1) <> nil then begin
                TStringList(SendMessage.nParam1).Free;
                nCheckCode := 4;
              end;
            end;
            if (SendMessage.wIdent = RM_10401) and (SendMessage.nParam1 <> 0) then begin
              nCheckCode := 5;
              Dispose(pTSlaveInfo(SendMessage.nParam1));
            end;
            nCheckCode := 6;
            try //20091124 增加
              if (SendMessage.Buff <> nil) then begin
                nCheckCode := 7;
                FreeMem(SendMessage.Buff);
              end;
              Dispose(SendMessage);
            except
            end;
            nCheckCode := 8;
          end;
        end;
      end;
      nCheckCode := 9;
      if m_MsgList <> nil then FreeAndNil(m_MsgList); //20090116 修改
    end;

    nCheckCode := 10;
    if m_VisibleHumanList <> nil then FreeAndNil(m_VisibleHumanList);


    nCheckCode := 120;
    if m_VisibleActors <> nil then begin
      nCheckCode := 121;
      if m_VisibleActors.Count > 0 then begin
        nCheckCode := 122;
        for I := 0 to m_VisibleActors.Count - 1 do begin
          try
            if pTVisibleBaseObject(m_VisibleActors.Items[I]) <> nil then //20080724
              Dispose(pTVisibleBaseObject(m_VisibleActors.Items[I]));
          except
          end;
        end;
      end;
      nCheckCode := 13;

      if m_VisibleActors <> nil then FreeAndNil(m_VisibleActors); //20080908

    end;

    nCheckCode := 14;
    try //20090816 增加
      if m_VisibleItems <> nil then begin
        if m_VisibleItems.Count > 0 then begin
          for I := 0 to m_VisibleItems.Count - 1 do begin
            try
              if pTVisibleMapItem(m_VisibleItems.Items[I]) <> nil then //20080724
                Dispose(pTVisibleMapItem(m_VisibleItems.Items[I]));
            except
            end;
          end;
        end;
        nCheckCode := 15;
        FreeAndNil(m_VisibleItems);
      end;
    except
    end;
    nCheckCode := 16;

    if m_VisibleEvents <> nil then begin
      nCheckCode := 17;
      try
        FreeAndNil(m_VisibleEvents); //20090215 修改
      except
      end;
    end;

    nCheckCode := 20;
    try
      if m_MagicList <> nil then begin
        if m_MagicList.Count > 0 then begin
          for I := 0 to m_MagicList.Count - 1 do begin
            try
              if pTUserMagic(m_MagicList.Items[I]) <> nil then
                Dispose(pTUserMagic(m_MagicList.Items[I]));
            except
            end;
          end;
        end;
        FreeAndNil(m_MagicList);
      end;
    except
    end;
    {nCheckCode := 200;
    try
      if m_MagicOfDelList <> nil then begin
        if m_MagicOfDelList.Count > 0 then begin
          for I := 0 to m_MagicOfDelList.Count - 1 do begin
            nCheckCode := 201;
            try
              if pTUserMagic(m_MagicOfDelList[I]) <> nil then
                Dispose(pTUserMagic(m_MagicOfDelList[I]));
            except
            end;
          end;
        end;
        FreeAndNil(m_MagicOfDelList);
      end;
    except
    end;}
    nCheckCode := 21;

    if m_SlaveList <> nil then FreeAndNil(m_SlaveList);


    nCheckCode := 25;
      if m_ItemList <> nil then begin
        m_boOperationItemList := True; //20080928 防止同时操作背包列表时保存
        try //20110816
          for I := m_ItemList.Count - 1 downto 0 do begin
            if m_ItemList.Count <= 0 then Break;
            nCheckCode := 24;
            try
              if pTUserItem(m_ItemList.Items[I]) <> nil then Dispose(pTUserItem(m_ItemList.Items[I]));
            except
            end;
          end;
          nCheckCode := 18;
          FreeAndNil(m_ItemList);
        finally
          m_boOperationItemList := False; //20080928 防止同时操作背包列表时保存
        end;
      end;
  except
    on E: Exception do begin
      MainOutMessage(Format(sExceptionMsg, [g_sExceptionVer, nCheckCode, m_sCharName, E.Message]));
    end;
  end;
  inherited;
end;

procedure TBaseObject.ChangePKStatus(boWarFlag: Boolean);
begin
  if m_boInFreePKArea <> boWarFlag then begin
    m_boInFreePKArea := boWarFlag;
    m_boNameColorChanged := True;
  end;
end;
//取掉物的位置 20080124

function TBaseObject.GetDropPosition(nOrgX, nOrgY, nRange: Integer; var nDX: Integer; var nDY: Integer): Boolean; //004C5238
var
  I, II, III: Integer;
  nItemCount, n24, n28, n2C: Integer;
begin
  n24 := 999;
  Result := False;
  n28 := 0; //09/10
  n2C := 0; //09/10
  if nRange <= 0 then nRange := 1; //20091113 增加
  for I := 1 to nRange do begin
    for II := -I to I do begin
      for III := -I to I do begin
        nDX := nOrgX + III;
        nDY := nOrgY + II;
        if m_PEnvir.GetItemEx(nDX, nDY, nItemCount) = nil then begin
          if m_PEnvir.bo2C then begin
            Result := True;
            Break;
          end;
        end else begin
          if m_PEnvir.bo2C and (n24 > nItemCount) then begin
            n24 := nItemCount;
            n28 := nDX;
            n2C := nDY;
          end;
        end;
      end;
      if Result then Break;
    end;
    if Result then Break;
  end;
  if not Result then begin
    if n24 < 8 then begin
      nDX := n28;
      nDY := n2C;
    end else begin
      nDX := nOrgX;
      nDY := nOrgY;
    end;
  end;
end;
//物品掉落,怪死爆物品 20080126

function TBaseObject.DropItemDown(UserItem: pTUserItem; nScatterRange: Integer; boDieDrop, boCanHit: Boolean; ItemOfCreat, DropCreat: TBaseObject): Boolean;
var
  dx, dy, idura: Integer;
  MapItem, pr: PTMapItem;
  StdItem: pTStdItem;
  logcap: string;
  sUserItemName: string;
  nCode: Byte;
begin
  Result := False;
  nCode := 0;
  try
    MapItem := nil;
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then begin
      if CheckIsOKItem(UserItem) then Exit; //检查物品附加属性是否正常 20081006
      if StdItem.StdMode = 40 then begin
        idura := UserItem.Dura;
        idura := idura - 2000;
        if idura < 0 then idura := 0;
        UserItem.Dura := idura;
      end;
      New(MapItem);
      MapItem.UserItem := UserItem^;
      MapItem.Name := StdItem.Name;
      //取自定义物品名称
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then begin
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then MapItem.Name := sUserItemName;
      end;
      nCode := 7;
      MapItem.Looks := StdItem.Looks;
      if StdItem.StdMode = 45 then begin
        MapItem.Looks := GetRandomLook(MapItem.Looks, StdItem.Shape);
      end;
      nCode := 8;
      MapItem.AniCount := StdItem.AniCount;
      MapItem.Reserved := 0;
      MapItem.Count := 1;
      MapItem.OfBaseObject := ItemOfCreat;
      MapItem.dwCanPickUpTick := GetTickCount();
      MapItem.DropBaseObject := DropCreat;
      if PlugOfCheckCanItem(14, MapItem.Name, False, 0, 0) then begin //隔一定时长才能捡物品 20100530
        if g_FunctionNPC <> nil then begin
          MapItem.OfBaseObject := g_FunctionNPC;
          MapItem.DropBaseObject := g_FunctionNPC;
        end;
      end;
      if DropCreat.m_btRaceServer = 136 then begin //20080127
        nCode := 13;
        GetDropPosition(DropCreat.m_LastHiter.m_nCurrX, DropCreat.m_LastHiter.m_nCurry, nScatterRange, dx, dy); //取掉物的位置
      end else begin
        nCode := 14;
        GetDropPosition(m_nCurrX, m_nCurrY, nScatterRange, dx, dy); //取掉物的位置
      end;
      nCode := 20;
      pr := m_PEnvir.AddToMap(dx, dy, OS_ITEMOBJECT, TObject(MapItem));
      nCode := 16;
      if pr = MapItem then begin
        nCode := 17;
        SendRefMsg(RM_ITEMSHOW, MapItem.Looks, Integer(MapItem), dx, dy, MapItem.Name);
        nCode := 18;
        PlugOfCheckCanItem(4, MapItem.Name, boCanHit, dx, dy); //禁止物品规则(掉落物品提示) 20080729
        nCode := 20;
        if boDieDrop then logcap := '15'
        else logcap := '7';
        nCode := 21;
        if StdItem.NeedIdentify = 1 then begin
          nCode := 22;
          AddGameDataLog(logcap + #9 +
            m_sMapName + '(' + BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + ')' + #9 +
            IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 +
            '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
            '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
            '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
            '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
            '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
            IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
            IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
            IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
            IntToStr(UserItem.btValue[14]) + #9 + IntToStr(UserItem.Dura) + '/' + IntToStr(UserItem.DuraMax));
        end;
        Result := True;
      end else begin
        Dispose(MapItem);
        MapItem := nil;
      end;
    end;
  except
    on E: Exception do begin
      MainOutMessage(Format('{%s} TBaseObject.DropItemDown Code:%d :%s', [g_sExceptionVer, nCode, E.Message]));
      if MapItem <> nil then//防止内存泄露 By TasNat at: 2012-10-14 20:07:16
        Dispose(MapItem);
    end;
  end;
end;
//更新客户端金币及元宝

procedure TBaseObject.GoldChanged();
begin
  if m_btRaceServer = RC_PLAYOBJECT then begin
    SendUpdateMsg(Self, RM_GOLDCHANGED, 0, 0, 0, 0, '');
  end;
end;
//更新客户端金币及灵符

procedure TBaseObject.GoldGameGirdChanged();
begin
  if m_btRaceServer = RC_PLAYOBJECT then begin
    SendUpdateMsg(Self, RM_GOLDGAMEGIRDCHANGED, 0, 0, 0, 0, '');
  end;
end;

procedure TBaseObject.GameGoldChanged();
begin
  if m_btRaceServer = RC_PLAYOBJECT then begin
    SendUpdateMsg(Self, RM_GAMEGOLDCHANGED, 0, 0, 0, 0, '');
  end;
end;
//荣誉值改变 20080511

procedure TBaseObject.GameGloryChanged();
begin
  if m_btRaceServer = RC_PLAYOBJECT then begin
    SendUpdateMsg(Self, RM_GLORY, 0, 0, 0, 0, '');
  end;
end;

//玩家捡起物品

function TPlayObject.ClientPickUpItem: Boolean;
  function IsSelf(BaseObject: TBaseObject): Boolean;
  begin
    if (BaseObject = nil) or (Self = BaseObject) then Result := True
    else Result := False;
    if not Result then begin //检查是否英雄打的
      if m_MyHero <> nil then begin
        if m_MyHero = BaseObject then Result := True;
      end;
    end;
  end;
  function IsOfGroup(BaseObject: TBaseObject): Boolean;
  var
    I: Integer;
    //GroupMember: TBaseObject;
  begin
    Result := False;
    if m_GroupOwner = nil then Exit;
    if m_GroupOwner.m_GroupMembers.Count > 0 then begin //20091113 增加
      I := m_GroupOwner.m_GroupMembers.IndexOf(BaseObject.m_sCharName); //20101104 修改
      if I > -1 then Result := True;
      {for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
        GroupMember := TBaseObject(m_GroupOwner.m_GroupMembers.Objects[I]);
        if GroupMember <> nil then begin//20090308
          if GroupMember = BaseObject then begin
            Result := True;
            Break;
          end;
        end;
      end;//for  }
    end;
  end;
var
  UserItem: pTUserItem;
  MapItem: PTMapItem;
  StdItem: pTStdItem;
begin
  Result := False;
  if m_boDealing or m_boGhost then Exit; //交易中则退出     //尸体清理则退出 20090323
  MapItem := m_PEnvir.GetItem(m_nCurrX, m_nCurrY);
  if MapItem = nil then Exit;

  if (GetTickCount - MapItem.dwCanPickUpTick) > g_Config.dwFloorItemCanPickUpTime {2 * 60 * 1000} then begin
    MapItem.OfBaseObject := nil;
  end;
  if PlugOfCheckCanItem(9, MapItem.Name, False, 0, 0) then begin //禁止物品规则(管理插件功能) 20080729
    SysMsg(g_sPickUpItemHintMsg, c_Red, t_Hint); //提示 禁止捡起
    Exit; //禁止捡起
  end;
  if (MapItem.UserItem.AddValue[0] in [2, 3]) then begin //绑定物品不可捡起 20110528
    SysMsg(g_sCanNotPickBindUpItem, c_Red, t_Hint); //提示 禁止捡起
    Exit; //禁止捡起
  end;
  if not IsSelf(TBaseObject(MapItem.OfBaseObject)) and not IsOfGroup(TBaseObject(MapItem.OfBaseObject)) then begin
    SysMsg(g_sCanotPickUpItem {'在一定时间以内无法捡起此物品！！！'}, c_Red, t_Hint);
    Exit;
  end;
  if CompareText(MapItem.Name, sSTRING_GOLDNAME) = 0 then begin //金币
    if m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_ITEMOBJECT, TObject(MapItem)) = 1 then begin
      if IncGold(MapItem.Count) then begin
        SendRefMsg(RM_ITEMHIDE, 0, Integer(MapItem), m_nCurrX, m_nCurrY, '');
        if g_boGameLogGold then
          AddGameDataLog('4' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            sSTRING_GOLDNAME + #9 +
            IntToStr(MapItem.Count) + #9 +
            '1' + #9 + '0');
        GoldChanged;
        Dispose(MapItem);
      end else
        m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_ITEMOBJECT, TObject(MapItem));
    end;
    Exit;
  end;

  if IsEnoughBag then begin
    if m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_ITEMOBJECT, TObject(MapItem)) = 1 then begin
      if (MapItem.UserItem.wIndex > 0) and (MapItem.UserItem.AddValue[0] = 1) and
        (GetHoursCount(MapItem.UserItem.MaxDate, Now) <= 0) then begin //删除到期装备
        Dispose(MapItem);
        Exit;
      end;
      New(UserItem);
      FillChar(UserItem^, SizeOf(TUserItem), #0); //20080820 增加
      UserItem^ := MapItem.UserItem;
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if (StdItem <> nil) then begin
        if IsAddWeightAvailable(UserEngine.GetStdItemWeight(UserItem.wIndex)) then begin
          SendMsg(Self, RM_ITEMHIDE, 0, Integer(MapItem), m_nCurrX, m_nCurrY, '');
          if not AutoItemMerger(UserItem) then begin //自动合并物品
            if not AutoRepairDragon(StdItem) then begin //戴祝福罐时，自动填充祝福油等物品 20110411
              if GetCheckItemList(18, StdItem.Name) then begin //判断是否为绑定48时物品
                UserItem.AddValue[0] := 2;
                UserItem.MaxDate := IncDayHour(Now(), 48); //解绑时间
              end;
              ClearCopyItem(0, UserItem.wIndex, UserItem.MakeIndex); //清理包裹和仓库复制物品
              AddItemToBag(UserItem);
              if StdItem.NeedIdentify = 1 then
                AddGameDataLog('4' + #9 + m_sMapName + #9 +
                  IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                  m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                  '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                  '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                  '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                  '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                  '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                  IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                  IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                  IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                  IntToStr(UserItem.btValue[14]) + #9 + IntToStr(UserItem.Dura) + '/' + IntToStr(UserItem.DuraMax));
              if m_btRaceServer = RC_PLAYOBJECT then begin
                {PlayObject := TPlayObject(Self); //20100531 注释
                PlayObject.SendAddItem(UserItem);}
                TPlayObject(Self).SendAddItem(UserItem);
              end;
            end else begin
              Dispose(UserItem);
            end;
          end;
          StartMapEventOfPickUpItem(StdItem.Name); //地图捡物品触发 20100531移动位置
          Dispose(MapItem);
          Result := True;
        end else begin
          Dispose(UserItem);
          m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_ITEMOBJECT, TObject(MapItem));
        end;
      end else begin//修复 UserItem内存泄露By TasNat at: 2012-06-01 11:56:03
        Dispose(UserItem);
      end;
    end;
  end;
end;

procedure TPlayObject.RunNotice;
var
  Msg: TProcessMessage;
  nCode: Byte; //20090608
resourcestring
  sExceptionMsg = '{%s} TPlayObject::RunNotice Code:%d.%p';
begin
  if m_boEmergencyClose or m_boKickFlag or m_boSoftClose then begin
    if m_boKickFlag then SendDefMessage(SM_OUTOFCONNECTION, 0, 0, 0, 0, '');
    MakeGhost();
  end else begin
    nCode := 1;
    try
      if not m_boSendNotice then begin
        nCode := 2;
        SendNotice(); //发送公告
        nCode := 3;
        m_boSendNotice := True;
        m_dwWaitLoginNoticeOKTick := GetTickCount();
      end else begin
        nCode := 4;
        if GetTickCount - m_dwWaitLoginNoticeOKTick > 30000 then begin //30秒没有按确定，则断开连接
          m_boEmergencyClose := True;
        end;
        nCode := 5;
        //等待点确定
        while GetMessage(@Msg) do begin
          if Msg.wIdent = CM_LOGINNOTICEOK then begin
            nCode := 6;
            m_boLoginNoticeOK := True;
            m_dwClientTick := Msg.nParam1;
            //SysMsg(IntToStr(m_dwClientTick), c_Red, t_Notice);
          end;
        end;
      end;
    except
      MainOutMessage(Format(sExceptionMsg, [g_sExceptionVer, nCode, ExceptAddr]));
    end;
  end;
end;
//杀怪取得经验

procedure TPlayObject.WinExp(dwExp: LongWord);
begin
  try
    if (not m_boGhost) then begin //20090524 增加
      if m_Abil.Level > g_Config.nLimitExpLevel then begin //超过限制等级,只给指定的限制经验
        dwExp := g_Config.nLimitExpValue;
        GetExp(dwExp, False, 0);
      end else
        if dwExp > 0 then begin
          if m_nKillMonExpRate <= 0 then m_nKillMonExpRate := 100; //20081229 防止倍数为负数
          dwExp := g_Config.dwKillMonExpMultiple * dwExp; //系统指定杀怪经验倍数
          dwExp := Round((m_nKillMonExpRate / 100) * dwExp); //人物指定的杀怪经验倍数
          if m_PEnvir <> nil then begin //20090107
            if m_PEnvir.m_boEXPRATE then dwExp := Round((m_PEnvir.m_nEXPRATE / 100) * dwExp); //地图上指定杀怪经验倍数
          end;
          if m_boExpItem then begin //物品经验倍数
            dwExp := Round(m_rExpItem * dwExp);
          end;
          if m_Abil.Level >= 1000 then begin //20090323 等级分配经验
            dwExp := Round(dwExp * (g_Config.dwLevelToExpRate[1000] / 100));
            if dwExp <= 0 then dwExp := 1;
          end else begin
            dwExp := Round(dwExp * (g_Config.dwLevelToExpRate[m_Abil.Level] / 100));
            if dwExp <= 0 then dwExp := 1;
          end;
          GetExp(dwExp, False, 0);
        end;
    end;
  except
    MainOutMessage(Format('{%s} TPlayObject.WinExp', [g_sExceptionVer]));
  end;
end;

//取得牛气值 20090519

procedure TPlayObject.GetCattleGasExp(dwExp: LongWord);
begin
  if m_boShowCattleGas and (dwExp > 0) and (not m_boGhost) then begin
    if (m_CattleGasMaxExp = 0) and (m_CattleGasLevel < 5) then begin //牛气等级为0时，取升级经验上限值 20090518
      if m_CattleGasLevel <= 0 then m_CattleGasLevel := 1;
      GetExpCattle(m_CattleGasLevel, m_CattleGasMaxExp); //取升级经验上限值
    end;
    if m_CattleGasLevel < 5 then begin
      if m_CattleGasExp >= LongWord(dwExp) then begin //20090101
        if (High(LongWord) - m_CattleGasExp) < LongWord(dwExp) then begin
          dwExp := High(LongWord) - m_CattleGasExp;
        end;
      end else begin
        if (High(LongWord) - LongWord(dwExp)) < m_CattleGasExp then begin
          dwExp := High(LongWord) - LongWord(dwExp);
        end;
      end;
      Inc(m_CattleGasExp, dwExp); //累加当前牛气值
      if m_CattleGasHint and (m_CattleGasMaxExp > 0) and (m_CattleGasLevel < 5) then begin
        if (m_CattleGasExp >= Round(m_CattleGasMaxExp * 0.9)) then begin
          m_CattleGasHint := False;
          SysMsg('恭喜：你的牛气池即将填满，为了避免不必要的损失，请预留6格包裹空位', c_Blue, t_Say);
          if m_boOpenBox then SysMsg('注意：如有箱子正在打开，将无法开启牛气宝箱', c_Blue, t_Say);
        end;
      end;
      if not m_boNotOnlineAddExp then SendDelayMsg(Self, RM_WINCATTLEGASEXP, 0, dwExp, 0, 0, '', 1000); //只发送给非离线挂机人物
    end;
    if (m_CattleGasExp >= m_CattleGasMaxExp) and (m_CattleGasLevel < 5) then begin //牛气管升级
      if not m_boOpenBox then begin //没有箱子正在操作
        Inc(m_CattleGasLevel);
        case m_CattleGasLevel of
          2: begin
              if ClientOpenBoxs(g_Config.nAutoOpenBoxID1, 0, False, False) then begin //自动开启宝箱
                n_OpenBoxCount := 0;
                m_CattleGasOpenBox := True; //是开启牛气箱子 20090524
                SendMsg(Self, RM_OPENDRAGONBOXS, 1 {中间格显示牛头}, 0, 0, 0, '');
              end;
            end;
          3: begin
              if ClientOpenBoxs(g_Config.nAutoOpenBoxID2, 0, False, False) then begin //自动开启宝箱
                n_OpenBoxCount := 0;
                m_CattleGasOpenBox := True; //是开启牛气箱子 20090524
                SendMsg(Self, RM_OPENDRAGONBOXS, 1 {中间格显示牛头}, 0, 0, 0, '');
              end;
            end;
          4: begin
              if ClientOpenBoxs(g_Config.nAutoOpenBoxID3, 0, False, False) then begin //自动开启宝箱
                n_OpenBoxCount := 0;
                m_CattleGasOpenBox := True; //是开启牛气箱子 20090524
                SendMsg(Self, RM_OPENDRAGONBOXS, 1 {中间格显示牛头}, 0, 0, 0, '');
              end;
            end;
          5: begin
              if ClientOpenBoxs(g_Config.nAutoOpenBoxID4, 0, False, False) then begin //自动开启宝箱
                n_OpenBoxCount := 0;
                m_CattleGasOpenBox := True; //是开启牛气箱子 20090524
                SendMsg(Self, RM_OPENDRAGONBOXS, 1 {中间格显示牛头}, 0, 0, 0, '');
              end;
            end;
        end; //case
        m_CattleGasHint := True;
        if m_CattleGasLevel < 5 then begin
          GetExpCattle(m_CattleGasLevel, m_CattleGasMaxExp); //取升级经验上限值
          SendDefMessage(SM_SENDCATTLEGASLEVEL, m_CattleGasLevel, 0, 0, 0, ''); //发送牛气管等级
        end else begin //初始节点,初始变量
          m_CattleGasLevel := 1;
          m_CattleGasExp := 0;
          GetExpCattle(m_CattleGasLevel, m_CattleGasMaxExp); //取升级经验上限值
          SendDefMessage(SM_SENDCATTLEGASLEVEL, m_CattleGasLevel, 0, 0, 0, ''); //发送牛气管等级
        end;
        SysMsg('恭喜：你的牛气宝箱的奖励又提升了一个档次', c_Blue, t_Say);
      end else SysMsg('有箱子正在打开，无法开启牛气宝箱', c_Red, t_Say);
    end;
    if (m_CattleGasLevel < 5) then begin
      SendDefMessage(SM_SENDCATTLEGASEXP, LoWord(m_CattleGasExp), HiWord(m_CattleGasExp), LoWord(m_CattleGasMaxExp), HiWord(m_CattleGasMaxExp), ''); //发送牛气管经验
    end;
  end;
end;

{$IF M2Version <> 2}
//心法激活,属性改变

function TPlayObject.HeartUpAbility(): Boolean;
var
  nOldStatus: Integer;
  nCode: byte;
begin
  try
    Result := False;
    nCode := 1;
    nOldStatus := m_nCharStatus;
    {case m_btJob of//按职业增加属性
      0: m_HeartArrValue := _MIN(HiWord(m_WAbil.DC), Round(HiWord(m_WAbil.DC) * (g_Config.nHeartArrValueRate / 10)));//战
      1: m_HeartArrValue := _MIN(HiWord(m_WAbil.MC), Round(HiWord(m_WAbil.MC) * (g_Config.nHeartArrValueRate / 10)));//法
      2: m_HeartArrValue := _MIN(HiWord(m_WAbil.SC), Round(HiWord(m_WAbil.SC) * (g_Config.nHeartArrValueRate / 10)));//道
    end;  }
    m_boHeartActive := True;
    nCode := 2;
    m_nCharStatus := GetCharStatus();
    nCode := 3;
    if nOldStatus <> m_nCharStatus then StatusChanged('');
    RecalcAbilitys();
    nCode := 4;
    CompareSuitItem(False); //套装与身上装备对比
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
    nCode := 5;
    Result := True;
    if (m_MyDivision <> nil) and (g_Config.nActivMemberHeartRate <> 255) and
      (Random(g_Config.nActivMemberHeartRate) = 0) then begin //激活弟子心法
      nCode := 6;
      TDivision(m_MyDivision).ActivMemberHeart(m_sCharName);
    end;
    nCode := 7;
    DoSendHeartInfo;          
  except
    MainOutMessage(Format('{%s} TPlayObject.HeartUpAbility Code:%d', [g_sExceptionVer, nCode]));
  end;
end;
//弟子心法激活

procedure TPlayObject.DiscipleHeartUpAbility();
var
  nOldStatus: Integer;
  nCode: byte;
begin
  try
    nCode := 0;
    if (m_MagicSkill_106 <> nil) and (m_MagicSkill_105 = nil) and
      (m_wStatusArrValue[21] = 0) and (m_MyDivision <> nil) then begin
      nOldStatus := m_nCharStatus;
      nCode := 1;
      m_dwStatusArrTimeOutTick[21] := GetTickCount + g_Config.nMemberUseHeartTime * 1000; //使用时间
      {case m_btJob of//按职业增加属性
        0: m_wStatusArrValue[21] := _MIN(HiWord(m_WAbil.DC), Round(HiWord(m_WAbil.DC) * (g_Config.nHeartArrValueRate / 10)));//战
        1: m_wStatusArrValue[21] := _MIN(HiWord(m_WAbil.MC), Round(HiWord(m_WAbil.MC) * (g_Config.nHeartArrValueRate / 10)));//法
        2: m_wStatusArrValue[21] := _MIN(HiWord(m_WAbil.SC), Round(HiWord(m_WAbil.SC) * (g_Config.nHeartArrValueRate / 10)));//道
      end; }
      m_wStatusArrValue[21] := 10;
      nCode := 2;
      m_nCharStatus := GetCharStatus();
      RecalcAbilitys();
      nCode := 3;
      CompareSuitItem(False); //套装与身上装备对比
      SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
      nCode := 4;
      SysMsg(sActivMemberHeart, c_Green, t_Hint);
      nCode := 5;
      if nOldStatus <> m_nCharStatus then StatusChanged('');
    end;
  except
    MainOutMessage(Format('{%s} TPlayObject.DiscipleHeartUpAbility Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

//龙卫心法经验吸收(减当前经验)

function TPlayObject.IncHeartPoint(nPoint: Int64): Boolean;
var
  nExp: LongWord;
  MaxTrain: LongWord;
begin
  Result := False;
  nExp := 0;
  if m_MagicSkill_105 <> nil then begin
    if m_MagicSkill_105.btLevel < 100 then begin
      if m_Abil.nExp >= nPoint then begin
        nExp := nPoint div 10000;
        Dec(m_Abil.nExp, nPoint);
      end;
      if nExp > 0 then begin
        //MaxTrain:= m_MagicSkill_105.MagicInfo.MaxTrain[0] + m_MagicSkill_105.btLevel * (m_MagicSkill_105.MagicInfo.MaxTrain[2]- m_MagicSkill_105.MagicInfo.MaxTrain[1]);
        Inc(m_MagicSkill_105.nTranPoint, nExp);
        Result := True;
        if not CheckMagicLevelup(m_MagicSkill_105) then begin //检查技能是否升级

          MaxTrain := m_MagicSkill_105.MagicInfo.MaxTrain[0] + m_MagicSkill_105.btLevel * (m_MagicSkill_105.MagicInfo.MaxTrain[2] - m_MagicSkill_105.MagicInfo.MaxTrain[1]);
          SendDelayMsg(self, RM_MAGIC_LVEXP, m_MagicSkill_105.MagicInfo.wMagicId, MaxTrain, m_MagicSkill_105.btLevel, m_MagicSkill_105.nTranPoint, '', 500);
        end else HeartLevelUpFunc;//增加心法升级触发 By TasNat at: 2012-10-17 10:45:43
        if not m_boNotOnlineAddExp then begin
          SendDelayMsg(Self, RM_WINCATTLEGASEXP, 0, nExp, 1 {0-牛气值 1-心法经验}, 0, '', 1000); //左下角显示心法经验获得
          SendMsg(self, RM_WINEXP, 0, 0, 1 {0-提示 1-不提示}, 0, EncodeExp(m_Abil.nExp, 0));
        end;
      end;
    end;
  end;
end;

//取得内力经验 20081001  Code:0-杀怪分配 1-非杀怪分配 2-饮酒(谁喝分配给谁) 3-提取天地结晶经验 4-使用内功珠

procedure TPlayObject.GetNGExp(dwExp: LongWord; Code: Byte);
begin
  try
    if (not m_boGhost) then begin //20090524 增加
      {if m_Abil.Level > g_Config.nLimitExpLevel then begin //超过限制等级,只给指定的限制经验
        dwExp := g_Config.nLimitExpValue;
      end else }//修复 内功经验增加被普通等级限制的BUG   By TasNat at: 2012-04-25 19:24:37
        if (dwExp > 0) and (Code = 0) then begin
          dwExp := g_Config.dwKillMonExpMultiple * dwExp; //系统指定杀怪经验倍数
          dwExp := Round((m_nKillMonExpRate / 100) * dwExp); //人物指定的杀怪经验倍数
          if m_PEnvir <> nil then begin //20090107
            if m_PEnvir.m_boEXPRATE then dwExp := Round((m_PEnvir.m_nEXPRATE / 100) * dwExp); //地图上指定杀怪经验倍数
            if m_PEnvir.m_boNGEXPRATE then dwExp := Round((m_PEnvir.m_nNGEXPRATE / 100) * dwExp); //地图杀怪内功经验倍数 20091029
          end;
          if m_boExpItem then dwExp := Round(m_rExpItem * dwExp); //物品经验倍数
          if m_Abil.Level >= 1000 then begin //20090323 等级分配经验
            dwExp := Round(dwExp * (g_Config.dwLevelToExpRate[1000] / 100));
            if dwExp <= 0 then dwExp := 1;
          end else begin
            dwExp := Round(dwExp * (g_Config.dwLevelToExpRate[m_Abil.Level] / 100));
            if dwExp <= 0 then dwExp := 1;
          end;
        end;

      if m_MyHero <> nil then begin
        if (not m_MyHero.m_boDeath) and (not m_MyHero.m_boGhost) then begin
          case Code of
            0: begin
                dwExp := Round(dwExp * 1.12); //20100225 英雄存在则乘于系数再进行分配
                THeroObject(m_MyHero).GetNGExp(abs(Round((g_Config.nHeroKillMonExpRate / 100) * dwExp)), 3); //20081018 修改
                dwExp := abs(Round(((100 - g_Config.nHeroKillMonExpRate) / 100) * dwExp)); //20081018 修改
                dwExp := abs(Round(dwExp * g_Config.dwKillMonNGExpMultiple / 100)); //杀怪内功经验倍数 20090104
              end;
            1, 4: begin //非杀怪,英雄与主人一样经验 20081020
                THeroObject(m_MyHero).GetNGExp(dwExp, 1);
              end;
            3: begin //提取天地结晶内功经验，英雄分配比例 20090202
                THeroObject(m_MyHero).GetNGExp(abs(Round((g_Config.nHeroCrystalExpRate / 100) * dwExp)), 2);
                dwExp := abs(Round(((100 - g_Config.nHeroCrystalExpRate) / 100) * dwExp));
              end;
          end;
        end;
      end else begin
        if (dwExp > 0) and (Code = 0) then begin
          dwExp := abs(Round(dwExp * g_Config.dwKillMonNGExpMultiple / 100)); //杀怪内功经验倍数 20090104
        end;
      end;
{$IF M2Version <> 2}
      if m_boTrainingNG and (dwExp > 0) then begin
        if m_ExpSkill69 >= LongWord(dwExp) then begin //20090101
          if (High(LongWord) - m_ExpSkill69) < LongWord(dwExp) then begin
            dwExp := High(LongWord) - m_ExpSkill69;
          end;
        end else begin
          if (High(LongWord) - LongWord(dwExp)) < m_ExpSkill69 then begin
            dwExp := High(LongWord) - LongWord(dwExp);
          end;
        end;
        Inc(m_ExpSkill69, dwExp); //内功心法当前经验
        if not m_boNotOnlineAddExp then SendMsg(Self, RM_WINNHEXP, 0, dwExp, 0, 0, ''); //只发送给非离线挂机人物
        if (m_ExpSkill69 >= m_MaxExpSkill69) and (m_NGLevel < g_Config.nLimitExpNGLevel) then begin //20090504 防止255级后升级内功等级变成0级
          Dec(m_ExpSkill69, m_MaxExpSkill69);
          Inc(m_NGLevel);
          m_MaxExpSkill69 := GetSkill69Exp(m_NGLevel, m_Skill69MaxNH); //取内功心法升级经验
          m_Skill69NH := m_Skill69MaxNH;
          SendRefMsg(RM_MAGIC69SKILLNH, 0, m_Skill69NH, m_Skill69MaxNH, 0, ''); //内力值让别人看到 20081002
          SendRefMsg(RM_MYSHOW, ET_OBJECTLEVELUP, 0, 0, 0, ''); //人物升级动画  20081216
          SendNGResume(0); //发送内功减免，伤害，恢复速度数据 20090812
          NGLevelUpFunc; //人物内级等级升级触发 20090509
        end;
        SendMsg(Self, RM_MAGIC69SKILLEXP, 0, 0, 0, m_NGLevel, EncodeString(Inttostr(m_ExpSkill69) + '/' + Inttostr(m_MaxExpSkill69)));

        if (Code <> 3) then GetExpToCrystal(dwExp, 1); //取经验到天地结晶中 20090202
        if (Code <> 4) then GetNGExpToItem(dwExp); //取得的内功经验,累积到内珠珠上 20090814
      end;
{$IFEND}
    end;
  except
    MainOutMessage(Format('{%s} TPlayObject.GetNGExp', [g_sExceptionVer]));
  end;
end;
//内功技能升级

procedure TPlayObject.NGMAGIC_LVEXP(UserMagic: pTUserMagic);
begin
  if (UserMagic <> nil) then begin
    if (m_btRaceServer = RC_PLAYOBJECT) and (UserMagic.btLevel < 3) and
      (UserMagic.MagicInfo.TrainLevel[UserMagic.btLevel] <= m_NGLevel) then begin
      TrainSkill(UserMagic, Random(3) + 1);
      if not CheckMagicLevelup(UserMagic) then begin
        SendDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 3000);
      end;
    end;
  end;
end;

//取得的内功经验,累积到内珠珠上 20090814

procedure TPlayObject.GetNGExpToItem(dwExp: LongWord);
var
  I: Integer;
  UserItem: pTUserItem;
  AmuletStdItem: pTStdItem;
  boGetExpToItem: Boolean;
  nCode: Byte;
begin
  nCode := 0;
  boGetExpToItem := False;
  try
    if m_boDeath or m_boGhost or (not m_boTrainingNG) then Exit; //死亡不再聚,没学内功
    nCode := 1;
    if m_ItemList.Count > 0 then begin //20080628
      nCode := 11;
      for I := 0 to m_ItemList.Count - 1 do begin //人物包裹不为空
        nCode := 12;
        UserItem := m_ItemList.Items[I];
        if UserItem <> nil then begin
          nCode := 13;
          AmuletStdItem := UserEngine.GetStdItem(UserItem.wIndex);
          nCode := 14;
          if AmuletStdItem <> nil then begin
            nCode := 15;
            if (AmuletStdItem.StdMode = 51) and (AmuletStdItem.Shape = 1) and (UserItem.btValue[12] <> 2) and
              (UserItem.Dura < UserItem.DuraMax) then begin //内功珠
              nCode := 3;
              if m_PEnvir <> nil then
                if not m_PEnvir.AllowStdItems(AmuletStdItem.Name) then Exit; //检查地图是否禁用内功珠
              nCode := 34;
              if UserItem.btValue[20] = 1 then begin
                boGetExpToItem := True;
                Break;
              end;
              if UserItem.btValue[20] = 0 then begin
                boGetExpToItem := True;
                UserItem.btValue[20] := 1;
                Break;
              end;
            end;
          end;
        end;
      end;
    end;

    if m_nWinNGExp >= LongWord(dwExp) then begin
      if (High(LongWord) - m_nWinNGExp) < LongWord(dwExp) then begin
        dwExp := High(LongWord) - m_nWinNGExp;
      end;
    end else begin
      if (High(LongWord) - LongWord(dwExp)) < m_nWinNGExp then begin
        dwExp := High(LongWord) - LongWord(dwExp);
      end;
    end;

    if boGetExpToItem then begin //聚内功经验
      if (UserItem <> nil) then begin
        Inc(m_nWinNGExp, dwExp);
        if m_nWinNGExp >= 1000 then begin
          if (UserItem.Dura + m_nWinNGExp div 1000) > UserItem.DuraMax then begin
            while True do begin
              if m_nWinNGExp < 1000 then break;
              Inc(UserItem.Dura);
              Dec(m_nWinNGExp, 1000);
              if UserItem.Dura >= UserItem.DuraMax then begin
                UserItem.Dura := UserItem.DuraMax;
                break;
              end;
            end;
          end else begin
            Inc(UserItem.Dura, m_nWinNGExp div 1000);
            m_nWinNGExp := m_nWinNGExp mod 1000;
            if UserItem.Dura >= UserItem.DuraMax then begin
              UserItem.Dura := UserItem.DuraMax;
            end;
          end;
          SendMsg(self, RM_DURACHANGE, UserItem.wIndex, UserItem.Dura, UserItem.DuraMax, 0, '');
          SendUpdateItem(UserItem); //更新物品
        end;
        if UserItem.Dura >= UserItem.DuraMax then begin
          UserItem.Dura := UserItem.DuraMax;
          UserItem.btValue[12] := 2; //不能聚集的标识
          UserItem.btValue[20] := 2;
          SysMsg('【内功珠】已聚集足够的内功经验，请双击使用!', c_Green, t_Hint);
        end;
      end;
    end else m_nWinNGExp := 0;
    if m_nWinNGExp < 0 then m_nWinNGExp := 0;
  except
    MainOutMessage(Format('{%s} TPlayObject.GetNGExpToItem Code:%d.%p', [g_sExceptionVer, nCode, ExceptAddr]));
  end;
end;

//调整人物内功等级 20081221

procedure TPlayObject.CmdNGLevel(Cmd: pTGameCmd; sHumanName: string; nLevel: Integer);
var
  PlayObject: TPlayObject;
  HeroObject: TBaseObject;
  nOLevel: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (nLevel < 0) or (nLevel > g_Config.nLimitExpNGLevel) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 内功等级(1-' + IntToStr(g_Config.nLimitExpNGLevel) + ')', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    if PlayObject.m_boTrainingNG then begin
      nOLevel := PlayObject.m_NGLevel;
      PlayObject.m_NGLevel := _MAX(1, _MIN(g_Config.nLimitExpNGLevel, nLevel));
      PlayObject.SendNGData; //发送内功数据
      PlayObject.SendRefMsg(RM_MYSHOW, ET_OBJECTLEVELUP, 0, 0, 0, ''); //人物升级动画  20081221
      AddGameDataLog('17' + #9 + PlayObject.m_sMapName + #9 + //等级调整记录日志
        IntToStr(PlayObject.m_nCurrX) + #9 +
        IntToStr(PlayObject.m_nCurrY) + #9 +
        PlayObject.m_sCharName + #9 +
        IntToStr(PlayObject.m_NGLevel) + #9 +
        '内功' + #9 + '=(' + IntToStr(nLevel) + ')' + #9 +
        m_sCharName + '(GM)');
      SysMsg(sHumanName + ' 内功等级调整完成。', c_Green, t_Hint);
      if g_Config.boShowMakeItemMsg then
        MainOutMessage('[内功等级调整] ' + m_sCharName + '(' + PlayObject.m_sCharName + ' ' + IntToStr(nOLevel) + ' -> ' + IntToStr(PlayObject.m_NGLevel) + ')');
    end else SysMsg(PlayObject.m_sCharName + ' 还未学习内功心法!!!', c_Red, t_Hint);
  end else begin
{$IF HEROVERSION = 1}
    HeroObject := UserEngine.GetHeroObject(sHumanName); //查找英雄
    if HeroObject <> nil then begin
      if THeroObject(HeroObject).m_boTrainingNG then begin
        nOLevel := THeroObject(HeroObject).m_NGLevel;
        THeroObject(HeroObject).m_NGLevel := _MAX(1, _MIN(g_Config.nLimitExpNGLevel, nLevel));
        THeroObject(HeroObject).SendNGData; //发送内功数据
        HeroObject.SendRefMsg(RM_MYSHOW, ET_OBJECTLEVELUP, 0, 0, 0, ''); //人物升级动画  20081221
        AddGameDataLog('17' + #9 + HeroObject.m_sMapName + #9 + //等级调整记录日志
          IntToStr(HeroObject.m_nCurrX) + #9 +
          IntToStr(HeroObject.m_nCurrY) + #9 +
          HeroObject.m_sCharName + #9 +
          IntToStr(THeroObject(HeroObject).m_NGLevel) + #9 +
          '英雄内功' + #9 + '=(' + IntToStr(nLevel) + ')' + #9 + m_sCharName + '(GM)');
        SysMsg(sHumanName + ' 内功等级调整完成。', c_Green, t_Hint);
        if g_Config.boShowMakeItemMsg then
          MainOutMessage('[内功等级调整] ' + m_sCharName + '(' + HeroObject.m_sCharName + ' ' + IntToStr(nOLevel) + ' -> ' + IntToStr(THeroObject(HeroObject).m_NGLevel) + ')');
      end else SysMsg(HeroObject.m_sCharName + ' 还未学习内功心法!!!', c_Red, t_Hint);
    end else begin
      SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    end;
{$IFEND}
  end;
end;

//客户端提取天地结晶经验 20090202

procedure TPlayObject.ClientGetExpTCrystal;
begin
  if (not m_boDeath) and (not m_boGhost) then begin //20090512 增加
    if m_boShowExpCrystal and m_boGetExpCrystalExp then begin //天地结晶图标为显示，并且可以提取经验时
      if (m_nGetCrystalExp > 0) and (m_nGetCrystalNGExp > 0) and
        (m_CrystalLevel < 6) and (m_CrystalLevel > 0) then begin
        //人物获得经验
        GetNGExp(m_nGetCrystalNGExp, 3); //取天地结晶内功经验
        GetExp(m_nGetCrystalExp, False, 3); //取天地结晶经验
        //取得经验后的处理
        m_CrystalNGExp := m_CrystalNGExp - m_nGetCrystalNGExp;
        m_CrystalExp := m_CrystalExp - m_nGetCrystalExp;
        m_CrystalLevel := 1;
        m_nGetCrystalNGExp := 0;
        m_nGetCrystalExp := 0;
        m_boGetExpCrystalExp := False;
        GetExpCrystal(m_CrystalLevel, m_CrystalMaxExp, m_CrystalNGMaxExp); //取天地结晶当前等级经验上限
        SendDefMessage(SM_SENDCRYSTALLEVEL, m_CrystalLevel, 0, 0, 0, '');
        SendDefMessage(SM_SENDCRYSTALNGEXP, 0, 0, 0, 0, Inttostr(m_CrystalNGExp) + '/' + Inttostr(m_CrystalMaxExp) + '/' + Inttostr(m_CrystalNGMaxExp)); //发送天地结晶内功经验
        SendDefMessage(SM_SENDCRYSTALEXP, 0, 0, 0, 0, Inttostr(m_CrystalExp) + '/' + Inttostr(m_CrystalMaxExp) + '/' + Inttostr(m_CrystalNGMaxExp)); //发送天地结晶内功经验
      end;
    end;
  end;
end;

//发送内功数据 20081005

procedure TPlayObject.SendNGData;
begin
  try
    if (not m_boGhost) and (m_NGLevel > 0) and m_boTrainingNG then begin
      m_MaxExpSkill69 := GetSkill69Exp(m_NGLevel, m_Skill69MaxNH); //取内功心法升级经验 20081002
      m_Skill69NH := m_Skill69MaxNH;
      SendRefMsg(RM_MAGIC69SKILLNH, 0, m_Skill69NH, m_Skill69MaxNH, 0, ''); //内力值让别人看到 20081002
      SendMsg(self, RM_MAGIC69SKILLEXP, 0, 0, 0, m_NGLevel, EncodeString(IntToStr(m_ExpSkill69) + '/' + IntToStr(m_MaxExpSkill69)));
      SendNGResume(0); //发送内功减免，伤害，恢复速度数据 20090812
    end;
  except
    MainOutMessage(Format('{%s} TPlayObject.SendNGData :%p', [g_sExceptionVer, ExceptAddr]));
  end;
end;

//发送内功减免，伤害，恢复速度数据 20090812

procedure TPlayObject.SendNGResume(nType: Byte);
var
  nIncDC, nIncAC, nIncNGPoint, n18: Integer;
begin
  if (not m_boGhost) and (m_NGLevel > 0) and m_boTrainingNG then begin
    nIncDC := 0;
    nIncAC := 0;
    nIncNGPoint := 0;
    n18 := 0;
    case m_btJob of //按职业来计算内功攻击力,防御力
      0: begin
          nIncDC := (m_NGLevel div g_Config.nWarrNGLevelIncDC) + 5;
          nIncAC := (m_NGLevel div g_Config.nWarrNGLevelIncAC) + 12;
        end;
      1: begin
          nIncDC := (m_NGLevel div g_Config.nWizardNGLevelIncDC) + 3;
          nIncAC := (m_NGLevel div g_Config.nWizardNGLevelIncAC) + 15;
        end;
      2: begin
          nIncDC := (m_NGLevel div g_Config.nTaosNGLevelIncDC) + 3;
          nIncAC := (m_NGLevel div g_Config.nTaosNGLevelIncAC) + 13;
        end;
    end;
    n18 := (m_Skill69MaxNH div 75) + 1 + m_nIncNHPoint;
    nIncNGPoint := Round(n18 * (1 + m_nIncNHRecover / 100));
    if nType = 1 then SendMsg(self, RM_SENDNGRESUME, LoWord(nIncAC), HiWord(nIncAC), nIncDC {伤害值}, nIncNGPoint {恢复速度}, '')
    else SendDefMessage1(SM_SENDNGRESUME, nIncDC {伤害值}, LoWord(nIncAC), HiWord(nIncAC), 0, nIncNGPoint {恢复速度}, '');
  end;
end;

//取经验到天地结晶中 20090202 nType 0-经验 1-内功经验

procedure TPlayObject.GetExpToCrystal(dwExp: LongWord; nType: byte);
begin
  if m_boShowExpCrystal then begin //天地结晶图标为显示时
    case nType of
      0: begin //经验
          if (m_CrystalMaxExp = 0) and (m_CrystalLevel < 5) then begin //天地结晶等级为0时，取当前经验的上限值 20090201
            GetExpCrystal(m_CrystalLevel, m_CrystalMaxExp, m_CrystalNGMaxExp); //取天地结晶当前等级经验上限
          end;
          if m_CrystalLevel < 5 then Inc(m_CrystalExp, dwExp); //天地结晶当前经验 20090131
          if (m_CrystalExp >= m_CrystalMaxExp) and (m_CrystalNGExp >= m_CrystalNGMaxExp) and (m_CrystalLevel < 5) then begin //超过升级经验,并且内功经验超过升级经验,则天地结晶升级
            if m_CrystalLevel < 5 then begin
              m_boGetExpCrystalExp := True; //是否可以提取经验 20090201
              m_nGetCrystalExp := m_CrystalMaxExp; //可提取天地结晶经验 20090201
              m_nGetCrystalNGExp := m_CrystalNGMaxExp; //天可提取地结晶内功经验 20090201
              Inc(m_CrystalLevel);
            end;
            if m_CrystalLevel < 5 then GetExpCrystal(m_CrystalLevel, m_CrystalMaxExp, m_CrystalNGMaxExp); //取天地结晶当前等级经验上限
            SendDefMessage(SM_SENDCRYSTALLEVEL, m_CrystalLevel, 0, 0, 0, ''); //发送天地结晶的等级 20090202
          end;
          if (Self <> nil) and (m_CrystalLevel < 5) then
            SendDefMessage(SM_SENDCRYSTALEXP, 0, 0, 0, 0, Inttostr(m_CrystalExp) + '/' + Inttostr(m_CrystalMaxExp) + '/' + Inttostr(m_CrystalNGMaxExp)); //发送天地结晶经验
        end;
      1: begin //内功经验
          if (m_CrystalNGMaxExp = 0) and (m_CrystalLevel < 5) then begin //取当前经验的上限值 20090201
            GetExpCrystal(m_CrystalLevel, m_CrystalMaxExp, m_CrystalNGMaxExp); //取天地结晶当前等级经验上限
          end;
          if m_CrystalLevel < 5 then Inc(m_CrystalNGExp, dwExp); //天地结晶当前经验 20090131
          if (m_CrystalExp >= m_CrystalMaxExp) and (m_CrystalNGExp >= m_CrystalNGMaxExp) and (m_CrystalLevel < 5) then begin //超过升级经验,并且内功经验超过升级经验,则天地结晶升级
            if m_CrystalLevel < 5 then begin
              m_boGetExpCrystalExp := True; //是否可以提取经验 20090201
              m_nGetCrystalExp := m_CrystalMaxExp; //可提取天地结晶经验 20090201
              m_nGetCrystalNGExp := m_CrystalNGMaxExp; //天可提取地结晶内功经验 20090201
              Inc(m_CrystalLevel);
            end;
            if m_CrystalLevel < 5 then GetExpCrystal(m_CrystalLevel, m_CrystalMaxExp, m_CrystalNGMaxExp); //取天地结晶当前等级经验上限
            SendDefMessage(SM_SENDCRYSTALLEVEL, m_CrystalLevel, 0, 0, 0, ''); //发送天地结晶的等级 20090202
          end;
          if (Self <> nil) and (m_CrystalLevel < 5) then
            SendDefMessage(SM_SENDCRYSTALNGEXP, 0, 0, 0, 0, Inttostr(m_CrystalNGExp) + '/' + Inttostr(m_CrystalMaxExp) + '/' + Inttostr(m_CrystalNGMaxExp)); //发送天地结晶内功经验
        end;
    end;
  end;
end;

//---------------------------淬炼系统 20080502--------------------------------
//客户端增加物品到淬炼框中

function TPlayObject.ClientAddRefineItem(sItemIdx: string): Boolean;
var
  I: Integer;
  UserItem: pTUserItem;
  nItemIdx, nItemIdx1, nItemIdx2: Integer;
  Str, Str1: string;
begin
  Result := False;
  nItemIdx := 0;
  nItemIdx1 := 0;
  nItemIdx2 := 0;
  if sItemIdx <> '' then begin
    sItemIdx := GetValidStr3(sItemIdx, Str, ['/', #9]);
    sItemIdx := GetValidStr3(sItemIdx, Str1, ['/', #9]);
    nItemIdx := Str_ToInt(Str, 0);
    nItemIdx1 := Str_ToInt(Str1, 0);
    nItemIdx2 := Str_ToInt(sItemIdx, 0);
  end;

  for I := m_ItemList.Count - 1 downto 0 do begin
    if m_ItemList.Count <= 0 then Break;
    UserItem := m_ItemList.Items[I];
    if UserItem = nil then Continue;
    if (UserItem.MakeIndex = nItemIdx) or (UserItem.MakeIndex = nItemIdx1) or (UserItem.MakeIndex = nItemIdx2) then begin
      if (m_RefineItemList.Count < 4) then begin
        m_RefineItemList.Add(UserItem);
        m_ItemList.Delete(I);
        if m_RefineItemList.Count = 3 then begin
          Result := True;
          Break;
        end;
      end;
    end;
  end;
end;

//取淬练列表物品

procedure TPlayObject.GetBackRefineItem();
var
  I: Integer;
  ClientItem: TClientItem;
  StdItem: TStdItem;
  pStdItem: pTStdItem;
  UserItem: pTUserItem;
  sSENDMSG, sUserItemName: string;
begin
  sSENDMSG := '';
  if m_RefineItemList.Count > 0 then begin
    for I := 0 to m_RefineItemList.Count - 1 do begin
      UserItem := m_RefineItemList.Items[I];
      if UserItem.MakeIndex > 0 then begin
        m_ItemList.Add(UserItem);
        pStdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if pStdItem <> nil then begin
          StdItem := pStdItem^;
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('41' + #9 + m_sMapName + #9 +
              IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 + StdItem.Name + #9 +
              IntToStr(UserItem.MakeIndex) + #9 +
              '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
              '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
              '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
              '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
              '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
              IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
              IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
              IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
              IntToStr(UserItem.btValue[14]) + #9 + IntToStr(UserItem.Dura) + '/' + IntToStr(UserItem.DuraMax) + '(取回)');

          ItemUnit.GetItemAddValue(UserItem, StdItem);
          Move(StdItem, ClientItem.s, SizeOf(TStdItem));

          //取自定义物品名称
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if (UserItem.btValue[12] = 1) and (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) then ClientItem.s.Reserved1 := 1 //物品发光 20080223
          else ClientItem.s.Reserved1 := 0;
{$IF M2Version <> 2}
          if (StdItem.StdMode = 5) or (StdItem.StdMode = 6) then begin //武器暴击等级 20100708
            ClientItem.s.NeedIdentify := _MIN(High(Byte), UserItem.btValue[11] + UserItem.btValue[20]);
            if CheckItemSpiritMedia(UserItem) then begin
              ClientItem.Aura := UserItem.btValue[12];
              ClientItem.MaxAura := g_Config.nMaxAuraValue;
            end;
          end else begin
            if CheckItemSpiritMedia(UserItem) or ((StdItem.StdMode = 44) and (StdItem.shape = 253)) then begin
              ClientItem.Aura := UserItem.btValue[11];
              ClientItem.MaxAura := g_Config.nMaxAuraValue;
            end;
          end;
          if (StdItem.StdMode = 44) and (StdItem.shape = 255) then begin //神秘卷轴
            ClientItem.s.NeedIdentify := UserItem.btValue[0];
          end;
{$IFEND}
          if sUserItemName <> '' then ClientItem.s.Name := sUserItemName;

          ClientItem.Dura := UserItem.Dura;
          ClientItem.DuraMax := UserItem.DuraMax;
          ClientItem.MakeIndex := UserItem.MakeIndex;
          //Modified By TasNat at: 2012-04-12 09:28:18
          ClientItem.btAppraisalLevel :=   UserItem.btAppraisalLevel;
          ClientItem.btUnKnowValueCount := UserItem.btUnKnowValueCount;
          Move(UserItem.btAppraisalValue, ClientItem.btAppraisalValue, SizeOf(UserItem.btAppraisalValue));

          Move(UserItem.btUnKnowValue, ClientItem.btUnKnowValue, SizeOf(ClientItem.btUnKnowValue)); //20100822
          ClientItem.BindValue := UserItem.AddValue[0]; //20110622
          ClientItem.MaxDate := UserItem.MaxDate; //20110622
          if ClientItem.BindValue = 0 then begin //禁止交易,扔物品,显示绑定 20110626
            if (CheckItemValue(UserItem, 1) and CheckItemValue(UserItem, 0)) or
              (GetCheckItemList(0, StdItem.Name) and GetCheckItemList(1, StdItem.Name)) then
              ClientItem.BindValue := 3;
          end;
          sSENDMSG := sSENDMSG + EncodeBuffer(@ClientItem, SizeOf(ClientItem)) + '/';
        end;
      end;
    end;
  end;
  //if sSENDMSG <> '' then begin//20080523 注释,修正失败后,三件物品都消失,客户端还有物品显示
  m_DefMsg := MakeDefaultMsg(SM_UPDATERYREFINEITEM, Integer(Self), 0, 0, 0, 0);
  SendSocket(@m_DefMsg, sSENDMSG);
  m_RefineItemList.Clear;
  //end;
end;

//取淬练列表物品的名称

procedure TPlayObject.GetBackRefineItemName(var sItemName, sItemName1, sItemName2: string);
var
  I: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  str: string;
begin
  str := '';
  if m_RefineItemList.Count > 0 then begin
    for I := 0 to m_RefineItemList.Count - 1 do begin
      UserItem := m_RefineItemList.Items[I];
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if str <> '' then str := str + '+';
      if StdItem <> nil then str := Str + StdItem.Name;
    end;
  end;
  if str <> '' then begin
    str := GetValidStr3(str, sItemName, ['+']);
    str := GetValidStr3(str, sItemName1, ['+']);
    str := GetValidStr3(str, sItemName2, ['+']);
  end;
end;

//淬练过程

procedure TPlayObject.ClientRefineItem;
var
  RefineItemList: TList;
  RefineItemInfo: pTRefineItemInfo;
  I, K, T, addValue: Integer;
  UserItem, UserItem1, UserItem2: pTUserItem;
  StdItem, StdItem1: pTStdItem;
  sItemName, sItemName1, sItemName2, str, sMsg: string;
  boOK: Boolean;
begin
  boOK := False;
  try
    if (m_RefineItemList = nil) or (m_RefineItemList.Count = 0) then Exit;
    if (g_RefineItemList = nil) or (g_RefineItemList.Count = 0) then begin //20100226 修正无配置时，不退物品给玩家
      if m_RefineItemList.Count > 0 then begin
        for I := 0 to m_RefineItemList.Count - 1 do begin
          UserItem := m_RefineItemList.Items[I];
          if UserItem.MakeIndex > 0 then m_ItemList.Add(UserItem);
        end;
        m_RefineItemList.Clear;
      end;
      SysMsg(sRefineItemErrorMsg {'这次无法控制火云石的力量，淬炼失败了'}, c_Red, t_Hint); //物品不是配方里的物品,失败提示
      Exit;
    end;
    GetBackRefineItemName(sItemName, sItemName1, sItemName2); //取出淬练框中的物品名称
    RefineItemList := GetRefineItemInfo(sItemName, sItemName1, sItemName2); //取出对应配方的物品配置列表
    if RefineItemList <> nil then begin
      if RefineItemList.Count > 1 then begin //当淬炼原料下列表有多个物品，将随机抽取
        for I := 0 to RefineItemList.Count - 1 do begin
          T := Random(RefineItemList.Count);
          RefineItemInfo := pTRefineItemInfo(RefineItemList.Items[T]);
          if RefineItemInfo <> nil then Break;
        end;
      end else RefineItemInfo := pTRefineItemInfo(RefineItemList.Items[0]);

      //不管成功以否,火云石都要掉持久或消失
      if RefineItemInfo.boDisappear then begin //掉持久
        for I := m_RefineItemList.Count - 1 downto 0 do begin //20080917 修改
          if m_RefineItemList.Count <= 0 then Break; //20080917
          UserItem := pTUserItem(m_RefineItemList.Items[I]);
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) then begin
            if (StdItem.StdMode = 25) and ((StdItem.Shape = 10) or (StdItem.Shape = 11)) then begin
              if UserItem.Dura >= 100 then begin //20080826 修改
                Dec(UserItem.Dura, 100); //掉持久
                if UserItem.Dura <= 0 then begin
                  if StdItem.NeedIdentify = 1 then
                    AddGameDataLog('41' + #9 + m_sMapName + #9 +
                      IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                      m_sCharName + #9 + StdItem.Name + #9 +
                      IntToStr(UserItem.MakeIndex) + #9 +
                      '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' + //攻
                      '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' + //魔法
                      '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' + //道术
                      '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' + //防御
                      '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' + //魔御
                      IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                      IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                      IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                      IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + '消失');
                  m_RefineItemList.Delete(I); //20080917
                  UserItem.MakeIndex:= 0;
                  UserItem.wIndex :=0;
                  //DisPoseAndNil(UserItem); //20080917
                  DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                  UserItem := nil;
                end;
              end else begin
                if StdItem.NeedIdentify = 1 then
                  AddGameDataLog('41' + #9 + m_sMapName + #9 +
                    IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                    m_sCharName + #9 + StdItem.Name + #9 +
                    IntToStr(UserItem.MakeIndex) + #9 +
                    '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' + //攻
                    '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' + //魔法
                    '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' + //道术
                    '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' + //防御
                    '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' + //魔御
                    IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                    IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                    IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                    IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + '消失');
                m_RefineItemList.Delete(I); //20080917
                UserItem.MakeIndex:= 0;
                UserItem.wIndex :=0;
                //DisPoseAndNil(UserItem); //20080917
                DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                UserItem:= nil;
              end;
              Break;
            end;
          end;
        end;
      end else begin //消失
        for I := m_RefineItemList.Count - 1 downto 0 do begin //20080917 修改
          if m_RefineItemList.Count <= 0 then Break; //20080917
          UserItem := m_RefineItemList.Items[I];
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) then begin
            if (StdItem.StdMode = 25) and ((StdItem.Shape = 10) or (StdItem.Shape = 11)) then begin
              if StdItem.NeedIdentify = 1 then
                AddGameDataLog('41' + #9 + m_sMapName + #9 +
                  IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                  m_sCharName + #9 + StdItem.Name + #9 +
                  IntToStr(UserItem.MakeIndex) + #9 +
                  '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' + //攻
                  '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' + //魔法
                  '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' + //道术
                  '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' + //防御
                  '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' + //魔御
                  IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                  IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                  IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                  IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + '消失');
              m_RefineItemList.Delete(I); //20080917
              UserItem.MakeIndex:= 0;
              UserItem.wIndex :=0;
              //DisPoseAndNil(UserItem); //20080917
              DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
              UserItem:= nil;
              boOK := True;
              Break;
            end;
          end;
        end; //for
      end;

      if (Random(100) <= RefineItemInfo.nRefineRate) then begin //淬练成功率
        New(UserItem1);
        if UserEngine.CopyToUserItemFromName(RefineItemInfo.sItemName, UserItem1) then begin
          for K := 0 to 13 do begin
            if (RefineItemInfo.nAttribute[K].nPoints = 0) or (K = 11) then Continue; //最高限制升点数为零时,跳过,暴击等级属性也跳过
            if Random(RefineItemInfo.nAttribute[K].nDifficult) = 0 then begin //淬炼难度
              addValue := RefineItemInfo.nAttribute[K].nPoints - UserItem1.btValue[K];
              UserItem1.btValue[K] := RefineItemInfo.nAttribute[K].nPoints;
            end else begin
              addValue := UserItem1.btValue[K];
              UserItem1.btValue[K] := UserItem1.btValue[K] + Random(RefineItemInfo.nAttribute[K].nPoints - 1) + 1; //随机加点数 20080915 加1,防止随机值为0
              UserItem1.btValue[K] := _MIN(RefineItemInfo.nAttribute[K].nPoints - 1, UserItem1.btValue[K]);
              addValue := UserItem1.btValue[K] - addValue;
            end;
            if addValue > 0 then begin
              StdItem1 := UserEngine.GetStdItem(UserItem1.wIndex);
              if Str <> '' then Str := Str + ' ';
              if StdItem1 <> nil then begin //20090502 增加
                case StdItem1.StdMode of
                  19, 28: begin //20100513
                      case K of
                        0: Str := Str + ' 魔法躲避增加' + inttostr(addValue) + '点';
                        1: Str := Str + ' 幸运增加' + inttostr(addValue) + '点';
                        2: Str := Str + ' 攻击增加' + inttostr(addValue) + '点';
                        3: Str := Str + ' 魔法增加' + inttostr(addValue) + '点';
                        4: Str := Str + ' 道术增加' + inttostr(addValue) + '点';
                        14: Str := Str + ' 持久增加' + inttostr(addValue) + '点';
                      end;
                    end;
                  20, 24, 27: begin //20100513
                      case K of
                        0: Str := Str + ' 准确增加' + inttostr(addValue) + '点';
                        1: Str := Str + ' 敏捷增加' + inttostr(addValue) + '点';
                        2: Str := Str + ' 攻击增加' + inttostr(addValue) + '点';
                        3: Str := Str + ' 魔法增加' + inttostr(addValue) + '点';
                        4: Str := Str + ' 道术增加' + inttostr(addValue) + '点';
                        14: Str := Str + ' 持久增加' + inttostr(addValue) + '点';
                      end;
                    end;
                  21: begin
                      case K of
                        0: Str := Str + ' 体力恢复增加' + inttostr(addValue) + '点';
                        1: Str := Str + ' 魔法恢复增加' + inttostr(addValue) + '点';
                        2: Str := Str + ' 攻击增加' + inttostr(addValue) + '点';
                        3: Str := Str + ' 魔法增加' + inttostr(addValue) + '点';
                        4: Str := Str + ' 道术增加' + inttostr(addValue) + '点';
                        14: Str := Str + ' 持久增加' + inttostr(addValue) + '点';
                      end;
                    end;
                  23: begin
                      case K of
                        0: Str := Str + ' 毒物躲避增加' + inttostr(addValue) + '点';
                        1: Str := Str + ' 中毒恢复增加' + inttostr(addValue) + '点';
                        2: Str := Str + ' 攻击增加' + inttostr(addValue) + '点';
                        3: Str := Str + ' 魔法增加' + inttostr(addValue) + '点';
                        4: Str := Str + ' 道术增加' + inttostr(addValue) + '点';
                        14: Str := Str + ' 持久增加' + inttostr(addValue) + '点';
                      end;
                    end;
                  5, 6: begin
                      case K of
                        0: Str := Str + ' 攻击增加' + inttostr(addValue) + '点';
                        1: Str := Str + ' 魔法增加' + inttostr(addValue) + '点';
                        2: Str := Str + ' 道术增加' + inttostr(addValue) + '点';
                        3: Str := Str + ' 幸运增加' + inttostr(addValue) + '点';
                        4: Str := Str + ' 诅咒增加' + inttostr(addValue) + '点';
                        5: Str := Str + ' 准确增加' + inttostr(addValue) + '点';
                        6: Str := Str + ' 攻击速度增加' + inttostr(addValue) + '点';
                        7: Str := Str + ' 强度增加' + inttostr(addValue) + '点';
                        14: Str := Str + ' 持久增加' + inttostr(addValue) + '点';
                      end;
                    end;
                else begin
                    case K of
                      0: Str := Str + ' 防御增加' + inttostr(addValue) + '点';
                      1: Str := Str + ' 魔御增加' + inttostr(addValue) + '点';
                      2: Str := Str + ' 攻击增加' + inttostr(addValue) + '点';
                      3: Str := Str + ' 魔法增加' + inttostr(addValue) + '点';
                      4: Str := Str + ' 道术增加' + inttostr(addValue) + '点';
                      14: Str := Str + ' 持久增加' + inttostr(addValue) + '点';
                    end;
                  end;
                end; //case StdItem1.StdMode of
              end;
            end;
          end;
          if (Random(100) <= RefineItemInfo.nNeedRate) then UserEngine.RandomUpgradeItem(UserItem1); //极品属性几率,附加极品属性
          if not boOK then begin
            for I := m_RefineItemList.Count - 1 downto 0 do begin //在成功率内,则删除除火云石外的物品 //20080917
              if m_RefineItemList.Count <= 0 then Break; //20080917
              UserItem2 := pTUserItem(m_RefineItemList.Items[I]);
              if (UserItem2 <> nil) then begin
                if (UserItem2.MakeIndex > 0) then begin
                  StdItem1 := UserEngine.GetStdItem(UserItem2.wIndex);
                  if (StdItem1 <> nil) then begin
                    if (StdItem1.StdMode <> 25) and (StdItem1.Name <> '') then begin
                      if StdItem1.NeedIdentify = 1 then
                        AddGameDataLog('41' + #9 + m_sMapName + #9 +
                          IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                          m_sCharName + #9 + StdItem1.Name + #9 +
                          IntToStr(UserItem2.MakeIndex) + #9 +
                          '(' + IntToStr(LoWord(StdItem1.DC)) + '/' + IntToStr(HiWord(StdItem1.DC)) + ')' + //攻
                          '(' + IntToStr(LoWord(StdItem1.MC)) + '/' + IntToStr(HiWord(StdItem1.MC)) + ')' + //魔法
                          '(' + IntToStr(LoWord(StdItem1.SC)) + '/' + IntToStr(HiWord(StdItem1.SC)) + ')' + //道术
                          '(' + IntToStr(LoWord(StdItem1.AC)) + '/' + IntToStr(HiWord(StdItem1.AC)) + ')' + //防御
                          '(' + IntToStr(LoWord(StdItem1.MAC)) + '/' + IntToStr(HiWord(StdItem1.MAC)) + ')' + //魔御
                          IntToStr(UserItem2.btValue[0]) + '/' + IntToStr(UserItem2.btValue[1]) + '/' + IntToStr(UserItem2.btValue[2]) + '/' +
                          IntToStr(UserItem2.btValue[3]) + '/' + IntToStr(UserItem2.btValue[4]) + '/' + IntToStr(UserItem2.btValue[5]) + '/' +
                          IntToStr(UserItem2.btValue[6]) + '/' + IntToStr(UserItem2.btValue[7]) + '/' + IntToStr(UserItem2.btValue[8]) + '/' +
                          IntToStr(UserItem2.btValue[14]) + '[' + IntToStr(UserItem2.Dura) + '/' + inttostr(UserItem2.DuraMax) + ']' + #9 + '消失');
                      m_RefineItemList.Delete(I); //20080917
                      UserItem2.MakeIndex:=0;
                      UserItem2.wIndex :=0;
                      //DisPoseAndNil(UserItem2); //20080917
                      DisPose(UserItem2);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                      UserItem2:= nil;
                    end;
                  end;
                end;
              end;
            end; //for
          end else m_RefineItemList.Clear;
          m_RefineItemList.Add(UserItem1); //物品保存到列表中
          if sRefineItemSuccessMsg <> '' then begin
            sMsg := AnsiReplaceText(sRefineItemSuccessMsg, '%name', m_sCharName);
            sMsg := AnsiReplaceText(sMsg, '%s', RefineItemInfo.sItemName);
            sMsg := AnsiReplaceText(sMsg, '%v', Str);
            if PlugOfCheckCanItem(13, RefineItemInfo.sItemName, False, 0, 0) then begin
              UserEngine.SendBroadCastMsgExt(sMsg, t_Say); //物品规则：淬练提示
            end else SysMsg(sMsg, c_Green, t_Hint); //成功提示
          end;
          if g_FunctionNPC <> nil then begin //20110411 增加淬练成功触发
            g_FunctionNPC.GotoLable(Self, '@RefineOk', False, False);
          end;
        end else Dispose(UserItem1);//修复内存泄露 By TasNat at: 2012-06-01 11:57:32
      end else begin
        if (Random(100) <= RefineItemInfo.nReductionRate) then begin //失败后,在还原成功率内,则删除弩牌或封印装备
          for I := m_RefineItemList.Count - 1 downto 0 do begin //20080917 修改
            if m_RefineItemList.Count <= 0 then Break; //20080917
            UserItem := pTUserItem(m_RefineItemList.Items[I]);
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if (StdItem <> nil) then begin
              if ((StdItem.StdMode = 47) or (Pos(StdItem.Name, '封印') > 0)) then begin
                if StdItem.NeedIdentify = 1 then
                  AddGameDataLog('41' + #9 + m_sMapName + #9 +
                    IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                    m_sCharName + #9 + StdItem.Name + #9 +
                    IntToStr(UserItem.MakeIndex) + #9 +
                    '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' + //攻
                    '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' + //魔法
                    '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' + //道术
                    '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' + //防御
                    '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' + //魔御
                    IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                    IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                    IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                    IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + '消失');
                m_RefineItemList.Delete(I);

                //DisPoseAndNil(UserItem);
                DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                UserItem:= nil;
              end;
            end;
          end;
        end else begin //失败后,不在还原成功率内,1-合成新物品,则删除物品,除火去石外  2-升级物品,则初始属性
          if (CompareText(RefineItemInfo.sItemName, sItemName) = 0) or (CompareText(RefineItemInfo.sItemName, sItemName1) = 0) or (CompareText(RefineItemInfo.sItemName, sItemName2) = 0) then begin
            for I := m_RefineItemList.Count - 1 downto 0 do begin //20080917 修改
              if m_RefineItemList.Count <= 0 then Break; //20080917
              UserItem := m_RefineItemList.Items[I];
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if (StdItem <> nil) then begin
                if (CompareText(StdItem.Name, RefineItemInfo.sItemName) = 0) then begin
                  //m_RefineItemList.Delete(I);
                  for K := 0 to 13 do UserItem.btValue[K] := 0; //初始属性
                  //m_RefineItemList.Add(UserItem);
                end else
                  if (StdItem.StdMode <> 25) then begin
                    if StdItem.NeedIdentify = 1 then
                      AddGameDataLog('41' + #9 + m_sMapName + #9 +
                        IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 + StdItem.Name + #9 +
                        IntToStr(UserItem.MakeIndex) + #9 +
                        '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' + //攻
                        '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' + //魔法
                        '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' + //道术
                        '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' + //防御
                        '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' + //魔御
                        IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                        IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                        IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                        IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + '消失');
                    m_RefineItemList.Delete(I); //20080917
                    //DisPoseAndNil(UserItem);
                    DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                    UserItem:= nil;
                  end;
              end;
            end; //for
          end else begin
            for I := m_RefineItemList.Count - 1 downto 0 do begin //20080917 修改
              if m_RefineItemList.Count <= 0 then Break; //20080917
              UserItem := m_RefineItemList.Items[I];
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if (StdItem <> nil) then begin
                if (StdItem.StdMode <> 25) then begin
                  if StdItem.NeedIdentify = 1 then
                    AddGameDataLog('41' + #9 + m_sMapName + #9 +
                      IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                      m_sCharName + #9 + StdItem.Name + #9 +
                      IntToStr(UserItem.MakeIndex) + #9 +
                      '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' + //攻
                      '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' + //魔法
                      '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' + //道术
                      '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' + //防御
                      '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' + //魔御
                      IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                      IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                      IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                      IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + '消失');
                  m_RefineItemList.Delete(I);
                  //DisPoseAndNil(UserItem);
                  DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                  UserItem:= nil;
                end;
              end;
            end; //for
          end;
        end;
        SysMsg(sRefineItemFailMsg {'淬练装备失败!'}, c_Red, t_Hint); //失败提示 20081224
      end;
      GetBackRefineItem(); //发消息,更新淬练框中的物品
    end else begin //if RefineItemList <> nil then begin
      if m_RefineItemList.Count > 0 then begin
        for I := 0 to m_RefineItemList.Count - 1 do begin
          UserItem := m_RefineItemList.Items[I];
          if UserItem.MakeIndex > 0 then m_ItemList.Add(UserItem);
        end;
      end;
      SysMsg(sRefineItemErrorMsg {'这次无法控制火云石的力量，淬炼失败了'}, c_Red, t_Hint); //物品不是配方里的物品,失败提示 20081224
      m_RefineItemList.Clear;
    end;
  except
    on E: Exception do begin
      MainOutMessage(format('{%s} TPlayObject.ClientRefineItem :%p', [g_sExceptionVer, ExceptAddr]));
    end;
  end;
end;



procedure TPlayObject.ClientRefineArmyDrum(MainItem, Count: Integer; sMsg: string);
var
  m_DefMsg: TDefaultMessage;
  Str, MsgText: string;
  sItemName: string;
  ParamItem: array of pTUserItem; // 放物品
  PassItemsCount : Integer;
  MakeIndexs: array[0..9] of Integer; //放MakeIndex
  S: array[0..1] of string;
  pItemInfo: pTRefineDrumItemInfo;
  I, K, RtnCode: Integer;
  RandValue: Byte;
  UserItem: pTUserItem;
  MainUserItem: pTUserItem;

  function DeleteItemFromBag: Boolean; //  从包裹中删除物品
  var
    UserItem: pTUserItem;
    M, J, MakeId: Integer;
    StdItem : pTStdItem;
    function GetNeedCount(StdItem : pTStdItem) : Integer;
    var
      I : Integer;
      sName1 : string;
      nCount1 : Integer;
      sSubItemName : string;
    begin
      if pItemInfo <> nil then begin
        for I := 0 to pItemInfo.ItemNamesCount - 1 do begin
          sSubItemName := pItemInfo.ItemNames[I];
          sSubItemName := GetValidStr3(sSubItemName, sName1, ['|']);
          nCount1 := Str_ToInt(sSubItemName, -1);
          if CompareText(sName1, StdItem.Name) = 0 then begin
            Result := nCount1;
            Exit;
          end;                  
        end;
      end;
      Result := 0;
    end;
  begin
    Result := False;
    for M := 0 to Count - 1 do
    begin
      MakeId := MakeIndexs[M];
      for J := 0 to m_ItemList.Count - 1 do
      begin
        UserItem := m_ItemList[J];
        if (UserItem^.MakeIndex = MakeId) then
        begin
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) and (StdItem.StdMode = 17) and (UserItem.Dura > GetNeedCount(StdItem)) then begin
            Dec(UserItem.Dura, GetNeedCount(StdItem));
            //客户端默认是删除物品.
            SendAddItem(UserItem);
          end else begin
            SendDelItems(UserItem);
            Dispose(UserItem);
            m_ItemList.Delete(J);
          end;
          Result := True;
          Break;
        end;
      end;
    end;
    for J := 0 to m_ItemList.Count - 1 do
    begin
        UserItem := m_ItemList[J];
        if (UserItem^.MakeIndex = MainItem) then begin
          SendDelItems(UserItem);
          Dispose(UserItem);
          m_ItemList.Delete(J);
          Break;
        end;
    end;
  end;

  function CreateNewItemToBag : pTUserItem; //  创建新的到包裹中
  begin
    New(Result);
    if not UserEngine.CopyToUserItemFromName(pItemInfo^.GiveName, Result) then begin
      Dispose(Result);
      Result := nil;
    end else if not AddItemToBag(Result) then begin
      Dispose(Result);
      Result := nil;
    end;
  end;
  //根据提交的物品自动识别合成什么 By TasNat at: 2012-05-24 11:56:34
  function GetItemInfoByPushItems() : pTRefineDrumItemInfo;
  var
    II: Integer;
    sMainItemName : string;
    sSubItemName : string;
    boFound,boFound2 : Boolean;
    CurInfo : pTRefineDrumItemInfo;
    function FindSubItem: Boolean;
    var
      III, IIII : Integer;
      sName1, sName2 : string;
      nCount1, nCount2 : Integer;
    begin
      Result := False;
        for III := 0 to CurInfo.ItemNamesCount - 1 do begin
          sSubItemName := CurInfo.ItemNames[III];
          sSubItemName := GetValidStr3(sSubItemName, sName1, ['|']);
          nCount1 := Str_ToInt(sSubItemName, -1);
          boFound := False;
          for IIII := 0 to Length(ParamItem) - 1 do begin
            if ParamItem[IIII] = nil then Continue;
            sName2 := UserEngine.GetStdItemName(ParamItem[IIII].wIndex);
            nCount2 := ParamItem[IIII].Dura;
            boFound := CompareText(sName2, sName1) = 0;
            boFound := boFound and (nCount2 >= nCount1);
            if boFound then begin
              ParamItem[IIII] := nil; //下次不查找了
              Break;
            end;
          end;
          if not boFound then Exit;//没找到材料 退出          
        end;
      Result := True;
    end;
  begin
    sMainItemName := UserEngine.GetStdItemName(MainUserItem.wIndex);
    Result := nil;
    for II := 0 to g_RefineDrumItemList.Count - 1 do begin
      CurInfo := pTRefineDrumItemInfo(g_RefineDrumItemList.Objects[II]);
      boFound2 := (CurInfo <> nil) and (Length(ParamItem) = Count) and (CurInfo.ItemNamesCount = Count) and (CompareText(CurInfo.MainItemName, sMainItemName) = 0);
      if boFound2 then begin
        boFound2 := FindSubItem;
      end;
      if boFound2 then begin 
        Result := CurInfo;
        Exit;
      end;
    end;
    
  end;
begin
  RtnCode := 9;
  MainUserItem := nil;
  FillChar(MakeIndexs, SizeOf(MakeIndexs), 0);
  DecodeBuffer(sMsg, @MakeIndexs, Count * 4);
  sMsg := '';
  MainUserItem := GetBagItemsEx(MainItem);
  if (MainUserItem = nil) then Exit;//无主材料退出
  SetLength(ParamItem, Count);
  for I := 0 to _Min(Count - 1, 9) do begin
    if MakeIndexs[I] <= 0 then Break;
    ParamItem[I] := GetBagItemsEx(MakeIndexs[I])
  end;

  pItemInfo := GetItemInfoByPushItems;
  if (pItemInfo <> nil) then begin

  // 检查是否能淬炼新的物品 辅助+...+辅助+主材料

    sMsg := pItemInfo.GiveName;
    RtnCode := 2;
      for I := 0 to pItemInfo.sPriceCount - 1 do
      begin
        case pItemInfo.sPriceType[I] of
          'L': if m_nGameGird < pItemInfo.nPriceCounts[I] then RtnCode := 4; //灵符
          'Y': if m_nGameGold < pItemInfo.nPriceCounts[I] then RtnCode := 5; //元宝
          'G': if m_nGold < pItemInfo.nPriceCounts[I] then RtnCode := 6; //金币
          'S': if m_btCreditPoint < pItemInfo.nPriceCounts[I] then RtnCode := 7; //声望
          'P': if m_nGamePoint < pItemInfo.nPriceCounts[I] then RtnCode := 8; //游戏点
          'R': if m_btGameGlory < pItemInfo.nPriceCounts[I] then RtnCode := 9; //荣誉
        end;
        if RtnCode > 2 then begin
          case pItemInfo.sPriceType[I] of
            'L': sMsg := '灵符';
            'Y': sMsg := '元宝';
            'G': sMsg := '金币';
            'S': sMsg := '声望';
            'P': sMsg := '游戏点';
            'R': sMsg := '荣誉'
          else sMsg := pItemInfo.sPriceType[I];
          end;
          sMsg := '失败.' + sMsg + ' 数量不够!';
          Break;
        end;
      end;
  // 处理淬炼
    if RtnCode <= 2 then
    begin
      {RandValue := 100;
      RandValue := Random(RandValue);
      if RandValue <= pItemInfo^.SuccessRate then }
      for I := 0 to pItemInfo.sPriceCount - 1 do
      begin
        if RtnCode > 2 then Break;
        case pItemInfo.sPriceType[I] of
          'L': Dec(m_nGameGird, pItemInfo.nPriceCounts[I]); //灵符
          'Y': Dec(m_nGameGold, pItemInfo.nPriceCounts[I]); //元宝
          'G': Dec(m_nGold, pItemInfo.nPriceCounts[I]); //金币
          'S': Dec(m_btCreditPoint, pItemInfo.nPriceCounts[I]); //声望
          'P': Dec(m_nGamePoint, pItemInfo.nPriceCounts[I]); //游戏点
          'R': Dec(m_btGameGlory, pItemInfo.nPriceCounts[I]); //荣誉
        end;
      end;
      GameGoldChanged;//修复成功才更新元宝数量的bug By TasNat at: 2012-05-02 15:46:21
      RtnCode := 4;
      if Random(pItemInfo^.SuccessRate) = 0 then // 淬炼成功的话.
      begin
        RtnCode := 5;

        sMsg := pItemInfo^.GiveName;
        UserItem := CreateNewItemToBag;
        if UserItem <> nil then begin
          RtnCode := 2;
          if MainUserItem <> nil then begin//继承主材料属性
            UserItem.btAppraisalLevel := MainUserItem.btAppraisalLevel;//0-是否可鉴定(1-可鉴定 2-一鉴 3-二鉴 4-三鉴)
            UserItem.btUnKnowValueCount := MainUserItem.btUnKnowValueCount;
            UserItem.btAppraisalValue := MainUserItem.btAppraisalValue;
            UserItem.btUnKnowValue := MainUserItem.btUnKnowValue;
          end;
          DeleteItemFromBag;
          SendAddItem(UserItem);
          m_sTmpStr := pItemInfo.GiveName;
          CmdUserCmd('@RefineOtherItemOK');
        end;
      end else
      begin
        sMsg := pItemInfo.GiveName;
        RtnCode := 3;
        if pItemInfo^.FailRate = 1 then DeleteItemFromBag; //消失掉物品
      end;
    end;
  end;
  m_DefMsg := MakeDefaultMsg(SM_OpenRefineArmyDrum, RtnCode, 0, 0, 0, 0);
  SendSocket(@m_DefMsg, EncodeString(sMsg));
end;

//------------------------------------------------------------------------------

function TPlayObject.WearRefineItem: Boolean; //是火云石
var
  StdItem: pTStdItem;
begin
  Result := False;
  if m_UseItems[U_BUJUK].wIndex > 0 then begin
    StdItem := UserEngine.GetStdItem(m_UseItems[U_BUJUK].wIndex);
    if (StdItem <> nil) and (StdItem.StdMode = 25) and (StdItem.Shape = 10) then begin
      Result := True;
    end;
  end;
end;

//修补火云石

procedure TPlayObject.RepairRefineItem(nItemIdx: Integer; sItemName: string);
var
  I, n14: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  sUserItemName: string;
  boRepairOK: Boolean;
  OldDura: Word;
begin
  boRepairOK := False;
  StdItem := nil;
  UserItem := nil;
  OldDura := 0;
  n14 := -1;
  if WearRefineItem then begin
    if (m_UseItems[U_BUJUK].Dura < m_UseItems[U_BUJUK].DuraMax) and (m_UseItems[U_BUJUK].Dura >= 500) then begin
      OldDura := m_UseItems[U_BUJUK].Dura;
      if m_ItemList.Count > 0 then begin
        for I := 0 to m_ItemList.Count - 1 do begin
          UserItem := m_ItemList.Items[I];
          if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then begin
            //取自定义物品名称
            sUserItemName := '';
            if UserItem.btValue[13] = 1 then
              sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
            if sUserItemName = '' then
              sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if StdItem <> nil then begin
              if CompareText(sUserItemName, sItemName) = 0 then begin
                n14 := I;
                Break;
              end;
            end;
          end;
        end;
        if (StdItem <> nil) and (UserItem <> nil) and (StdItem.StdMode = 43) and (StdItem.Shape = 1) then begin
          Inc(m_UseItems[U_BUJUK].Dura, 500);
          if m_UseItems[U_BUJUK].Dura > m_UseItems[U_BUJUK].DuraMax then m_UseItems[U_BUJUK].Dura := m_UseItems[U_BUJUK].DuraMax;
          boRepairOK := True;
          DelBagItem(n14);
        end;
      end;
    end;
  end;
  if boRepairOK then begin
    if OldDura <> m_UseItems[U_BUJUK].Dura then
      SendMsg(Self, RM_DURACHANGE, U_BUJUK, m_UseItems[U_BUJUK].Dura, m_UseItems[U_BUJUK].DuraMax, 0, '');
    SendDefMessage(SM_REPAIRFINEITEM_OK, 0, 0, 0, 0, '');
  end else begin
    SendDefMessage(SM_REPAIRFINEITEM_FAIL, 0, 0, 0, 0, '');
    SysMsg('修补火云石失败!', BB_Fuchsia, t_Hint); //20071231
  end;
end;
//------------------------------------------------------------------------------
{$IFEND}
//取得经验 20080221 参数boItmeExp: False-将经验累积到聚灵珠中 True-不累积经验到聚灵珠中
//nType 3-提取天地结晶经验

procedure TPlayObject.GetExp(dwExp: Int64; boItmeExp: Boolean; nType: Byte);
var
  nCode, K: Byte;
  dwTempExp, nMaxExp: uInt64;
begin
  nCode := 0;
  try
    if (not m_boGhost) then begin //20090512 增加
      if not boItmeExp then GetExpToItem(dwExp); //取得的经验,累积到聚灵珠 20080221
      nCode := 11;
      if m_MyHero <> nil then begin //人取得经验,都给英雄分配经验 20080518
        nCode := 12;
        if (not m_MyHero.m_boDeath) and (not m_MyHero.m_boGhost) and //20080826 增加
          (m_MyHero.m_Abil.Level < g_Config.nLimitExpLevelHero) then begin //20110116 增加
          nCode := 10;
          case nType of
            3: begin //提取天地结晶经验 20090202
                THeroObject(m_MyHero).GetExp(abs(Round((g_Config.nHeroCrystalExpRate / 100) * dwExp)), 0);
                dwExp := abs(Round(((100 - g_Config.nHeroCrystalExpRate) / 100) * dwExp));
              end;
          else begin
              dwExp := Round(dwExp * 1.12); //20100225 英雄存在则乘于系数再进行分配
              THeroObject(m_MyHero).GetExp(abs(Round((g_Config.nHeroKillMonExpRate / 100) * dwExp)) { + 1}, 0); //20081018
              dwExp := abs(Round(((100 - g_Config.nHeroKillMonExpRate) / 100) * dwExp)); //20081018 修改
            end;
          end;
        end;
      end;
      nCode := 3;
      m_GetExp := dwExp; //人物取得的经验,$GetExp变量使用 20081228
      if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(Self, '@GetExp', False, False); //取经验触发 20090101
      nCode := 31;
      if not m_boNotOnlineAddExp then SendMsg(Self, RM_WINEXP, 0, 0, 0, 0, EncodeExp(m_Abil.nExp, dwExp)); //只发送给非离线挂机人物
      nCode := 7;
      try
      if m_Magic68Skill <> nil then begin //学过酒气护体 20080625
        if m_Magic68Skill.btLevel < 100 then Inc(m_Magic68Skill.nTranPoint, dwExp);
        nMaxExp := GetSkill68Exp(m_Magic68Skill.btLevel);
        if m_Magic68Skill.nTranPoint >= nMaxExp then begin //超过升级经验,则升级技能
          Dec(m_Magic68Skill.nTranPoint, nMaxExp);
          if m_Magic68Skill.btLevel < 100 then Inc(m_Magic68Skill.btLevel);
        end;
        nCode := 9;
        if (Self <> nil) and (m_Magic68Skill.btLevel < 101) then begin
          nMaxExp := GetSkill68Exp(m_Magic68Skill.btLevel);
          SendMsg(Self, RM_MAGIC_LVEXP, m_Magic68Skill.MagicInfo.wMagicId, nMaxExp, m_Magic68Skill.btLevel, m_Magic68Skill.nTranPoint, '');
        end;
      end;
      except//屏蔽酒气护体导致的错误By TasNat at: 2012-11-10 12:47:18

      end;
{$IF M2Version <> 2}
      if (nType <> 3) then GetExpToCrystal(dwExp, 0); //取经验到天地结晶中 20090202
{$IFEND}
      dwTempExp := dwExp;
      if m_Abil.nExp >= dwExp then begin
        if (High(uInt64) - m_Abil.nExp) < dwExp then begin
          dwTempExp := High(uInt64) - m_Abil.nExp;
          dwExp := dwExp - dwTempExp;
        end else dwExp := 0;
      end else begin
        if (High(uInt64) - dwExp) < m_Abil.nExp then begin
          dwTempExp := High(uInt64) - dwExp;
          dwExp := dwExp - dwTempExp;
        end else dwExp := 0;
      end;
      nCode := 32;
      Inc(m_Abil.nExp, dwTempExp);
      AddBodyLuck(dwTempExp * 0.002);
      dwTempExp := 0;
      if m_Abil.nMaxExp > m_Abil.nExp then begin
        if dwExp > 0 then begin
          dwTempExp := (m_Abil.nMaxExp - m_Abil.nExp);
          if dwTempExp > 0 then begin
            if dwTempExp > dwExp then begin
              Inc(m_Abil.nExp, dwExp);
              AddBodyLuck(dwExp * 0.002);
              dwExp := 0;
            end else begin
              Inc(m_Abil.nExp, dwTempExp);
              AddBodyLuck(dwTempExp * 0.002);
              dwExp := dwExp - dwTempExp;
            end;
          end;
        end;
      end;
      nCode := 4;
      if (m_Abil.Level < MAXUPLEVEL) and
        (m_Abil.Level < g_Config.nLimitExpLevel) then begin //20110925 达到等级上限时不处理
        if g_Config.boContinuousUpLevel then begin //20100605 连续升8级
          K := 0;
          while (m_Abil.nExp >= m_Abil.nMaxExp) do begin //20100408 循环处理升级
            if K >= 8 then Break;
            Inc(K);
            if m_Abil.nExp <= 0 then begin
              m_Abil.nExp := 0;
              Break;
            end;
          //if m_Abil.Exp >= m_Abil.MaxExp then begin
            Dec(m_Abil.nExp, m_Abil.nMaxExp);
            if dwExp > 0 then begin
              Inc(m_Abil.nExp, dwExp);
              AddBodyLuck(dwExp * 0.002);
              dwExp := 0;
            end;
            if (m_Abil.Level < MAXUPLEVEL) and (m_Abil.Level < g_Config.nLimitExpLevel) then begin //20080715 增加限制等级
              Inc(m_Abil.Level);
              if (m_sMasterName <> '') and not m_boMaster then begin //自动出师 20100408
                if m_Abil.Level >= g_Config.nMasterOKLevel then CheckMaster(True);
              end;
            end;
            if m_Abil.Level < g_Config.nLimitExpLevel then HasLevelUp(m_Abil.Level - 1); //20080715 增加限制等级
            nCode := 5;
            AddBodyLuck(100);
            if not m_boAI then begin
              AddGameDataLog('12' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + //人物升级记录日志
                m_sCharName + #9 + IntToStr(m_Abil.nExp) + '/' + IntToStr(m_Abil.nMaxExp) + #9 + IntToStr(m_Abil.Level) + #9 + '1' + #9 + '0');
            end;
            nCode := 6;
            IncHealthSpell(2000, 2000);
          end;
        end else begin
          if m_Abil.nExp >= m_Abil.nMaxExp then begin
            Dec(m_Abil.nExp, m_Abil.nMaxExp);
            if dwExp > 0 then begin
              Inc(m_Abil.nExp, dwExp);
              AddBodyLuck(dwExp * 0.002);
              dwExp := 0;
            end;
            if (m_Abil.Level < MAXUPLEVEL) and (m_Abil.Level < g_Config.nLimitExpLevel) then begin //20080715 增加限制等级
              Inc(m_Abil.Level);
              if (m_sMasterName <> '') and not m_boMaster then begin //自动出师 20100408
                if m_Abil.Level >= g_Config.nMasterOKLevel then CheckMaster(True);
              end;
            end;
            if m_Abil.Level < g_Config.nLimitExpLevel then HasLevelUp(m_Abil.Level - 1); //20080715 增加限制等级
            nCode := 5;
            AddBodyLuck(100);
            if not m_boAI then begin
              AddGameDataLog('12' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + //人物升级记录日志
                m_sCharName + #9 + IntToStr(m_Abil.nExp) + '/' + IntToStr(m_Abil.nMaxExp) + #9 + IntToStr(m_Abil.Level) + #9 + '1' + #9 + '0');
            end;
            nCode := 6;
            IncHealthSpell(2000, 2000);
          end;
        end;
      end;
    end;
  except
    on E: Exception do
    MainOutMessage(Format('{%s} TPlayObject.GetExp Code:%d.%p', [g_sExceptionVer, nCode, ExceptAddr]));
  end;
end;

//取得的经验,累积到物品上,-----聚灵珠 20080221

procedure TPlayObject.GetExpToItem(dwExp: LongWord);
var
  I: Integer;
  UserItem: pTUserItem;
  AmuletStdItem: pTStdItem;
  boGetExpToItem, boHeroToItem, boHeroTtem: Boolean;
  nCode: Byte; //20080730
begin
  nCode := 0;
  boGetExpToItem := False;
  boHeroToItem := False;
  boHeroTtem := False;
  try
    if m_boDeath or m_boGhost then Exit; //20080730 死亡不再聚
    nCode := 1;
    if m_ItemList.Count > 0 then begin //20080628
      nCode := 11;
      for I := 0 to m_ItemList.Count - 1 do begin //人物包裹不为空
        nCode := 12;
        UserItem := m_ItemList.Items[I];
        if UserItem <> nil then begin //20090103
          nCode := 13;
          AmuletStdItem := UserEngine.GetStdItem(UserItem.wIndex);
          nCode := 14;
          if AmuletStdItem <> nil then begin
            nCode := 15;
            if (AmuletStdItem.StdMode = 51) and (UserItem.btValue[12] <> 2) and (UserItem.Dura < UserItem.DuraMax) then begin //聚灵珠
              case AmuletStdItem.Shape of
                0: begin //聚灵珠
                    nCode := 3;
                    if m_PEnvir <> nil then
                      if not m_PEnvir.AllowStdItems(AmuletStdItem.Name) then Exit; //检查地图是否禁用聚灵珠 20081016
                    nCode := 34;
                    if UserItem.btValue[20] = 1 then boGetExpToItem := True;
                    if n_UsesItemTick = 0 then begin
                      n_UsesItemTick := AmuletStdItem.AniCount * 86400 {24 * 60 * 60}; //使用时间
                      boGetExpToItem := True;
                      UserItem.btValue[20] := 1;
                    end;
                    if boGetExpToItem then Break;
                  end;
                2: begin //英雄聚灵珠
                    nCode := 3;
                    if m_PEnvir <> nil then
                      if not m_PEnvir.AllowStdItems(AmuletStdItem.Name) then Exit; //检查地图是否禁用聚灵珠 20081016
                    nCode := 34;
                    if UserItem.btValue[20] = 1 then begin
                      boGetExpToItem := True;
                      boHeroTtem := True;
                    end;
                    if n_UsesItemTick = 0 then begin
                      boGetExpToItem := True;
                      UserItem.btValue[20] := 1;
                      boHeroTtem := True;
                    end;
                    if boGetExpToItem then Break;
                  end;
              end; //case
            end;
          end;
        end;
      end;
    end;
    nCode := 2;
    if (not boGetExpToItem) and (m_MyHero <> nil) then begin
      nCode := 21;
      if m_MyHero.m_boDeath or m_MyHero.m_boGhost then Exit; //20090102 死亡不再聚
      nCode := 22;
      if m_MyHero.m_ItemList <> nil then begin //20090103
        nCode := 23;
        if m_MyHero.m_ItemList.Count > 0 then begin //20080628
          nCode := 24;
          for I := 0 to m_MyHero.m_ItemList.Count - 1 do begin //人物包里没有珠,英雄包裹不为空时
            nCode := 25;
            if m_MyHero.m_boDeath or m_MyHero.m_boGhost then Exit; //20111006 死亡不再聚
            UserItem := m_MyHero.m_ItemList.Items[I];
            if UserItem <> nil then begin //20090103
              nCode := 26;
              AmuletStdItem := UserEngine.GetStdItem(UserItem.wIndex);
              nCode := 27;
              if AmuletStdItem <> nil then begin
                if (AmuletStdItem.StdMode = 51) and (UserItem.btValue[12] <> 2) and (UserItem.Dura < UserItem.DuraMax) then begin //聚灵珠
                  case AmuletStdItem.Shape of
                    0: begin //聚灵珠
                        nCode := 32;
                        if m_MyHero.m_PEnvir <> nil then
                          if not m_MyHero.m_PEnvir.AllowStdItems(AmuletStdItem.Name) then Exit; //检查地图是否禁用聚灵珠 20081016
                        nCode := 33;
                        if UserItem.btValue[20] = 1 then boHeroToItem := True;
                        if n_UsesItemTick = 0 then begin
                          n_UsesItemTick := AmuletStdItem.AniCount * 86400 {24 * 60 * 60}; //使用时间
                          boHeroToItem := True;
                          UserItem.btValue[20] := 1;
                        end;
                        if boHeroToItem then Break;
                      end;
                    2: begin //英雄聚灵珠
                        nCode := 32;
                        if m_MyHero.m_PEnvir <> nil then
                          if not m_MyHero.m_PEnvir.AllowStdItems(AmuletStdItem.Name) then Exit; //检查地图是否禁用聚灵珠 20081016
                        nCode := 33;
                        if UserItem.btValue[20] = 1 then begin
                          boHeroToItem := True;
                          boHeroTtem := True;
                        end;
                        if n_UsesItemTick = 0 then begin
                          boHeroToItem := True;
                          UserItem.btValue[20] := 1;
                          boHeroTtem := True;
                        end;
                        if boHeroToItem then Break;
                      end;
                  end; //case
                end;
              end;
            end;
          end;
        end;
      end;
    end;
    nCode := 4;

    if m_nWinExp >= LongWord(dwExp) then begin //20090101
      if (High(LongWord) - m_nWinExp) < LongWord(dwExp) then begin
        dwExp := High(LongWord) - m_nWinExp;
      end;
    end else begin
      if (High(LongWord) - LongWord(dwExp)) < m_nWinExp then begin
        dwExp := High(LongWord) - LongWord(dwExp);
      end;
    end;

    if boGetExpToItem then begin //主人包裹里聚经验
      Inc(m_nWinExp, dwExp);
      if m_nWinExp >= 10000 then begin
        if (UserItem.Dura + m_nWinExp div 10000) > UserItem.DuraMax then begin //20090105
          while True do begin
            if m_nWinExp < 10000 then break;
            Inc(UserItem.Dura);
            Dec(m_nWinExp, 10000);
            if UserItem.Dura >= UserItem.DuraMax then begin
              UserItem.Dura := UserItem.DuraMax;
              break;
            end;
          end;
        end else begin
          Inc(UserItem.Dura, m_nWinExp div 10000);
          m_nWinExp := m_nWinExp mod 10000;
          if UserItem.Dura >= UserItem.DuraMax then begin
            UserItem.Dura := UserItem.DuraMax;
          end;
        end;

        SendMsg(self, RM_DURACHANGE, UserItem.wIndex, UserItem.Dura, UserItem.DuraMax, 0, '' {IntToStr(m_nWinExp)});
        SendUpdateItem(UserItem); //更新物品
        if not boHeroTtem then SendItemUseTime(n_UsesItemTick); //20080323
      end;
      if UserItem.Dura >= UserItem.DuraMax then begin
        UserItem.Dura := UserItem.DuraMax;
        UserItem.btValue[12] := 2; //20080404 增加,不能聚集的标识
        if not boHeroTtem then begin
          n_UsesItemTick := 0; //20080311
          SendItemUseTime(n_UsesItemTick); //发送聚灵珠使用剩余时间 20080309
          SysMsg('【聚灵珠】已聚集足够的经验，请双击使用!', c_Green, t_Hint);
        end else begin
          SysMsg('【英雄聚灵珠】已聚集足够的经验，请双击使用!', c_Green, t_Hint);
        end;
      end;
    end else
      if boHeroToItem then begin //英雄包裹里,珠子聚经验 20080427
        nCode := 5;
        Inc(m_nWinExp, dwExp);
        if m_nWinExp >= 10000 then begin
          if (UserItem.Dura + m_nWinExp div 10000) > UserItem.DuraMax then begin //20090105
            while True do begin
              if m_nWinExp < 10000 then break;
              Inc(UserItem.Dura);
              Dec(m_nWinExp, 10000);
              if UserItem.Dura >= UserItem.DuraMax then begin
                UserItem.Dura := UserItem.DuraMax;
                break;
              end;
            end;
          end else begin
            Inc(UserItem.Dura, m_nWinExp div 10000);
            m_nWinExp := m_nWinExp mod 10000;
            if UserItem.Dura >= UserItem.DuraMax then begin
              UserItem.Dura := UserItem.DuraMax;
            end;
          end;

          THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HERODURACHANGE, UserItem.wIndex, UserItem.Dura, UserItem.DuraMax, 0, '' {IntToStr(m_nWinExp)}); //20080610 修改
          THeroObject(m_MyHero).SendUpdateItem(UserItem); //更新物品
          if not boHeroTtem then SendItemUseTime(n_UsesItemTick); //20080323
        end;
        if UserItem.Dura >= UserItem.DuraMax then begin
          UserItem.Dura := UserItem.DuraMax;
          UserItem.btValue[12] := 2; //20080404 增加,不能聚集的标识
          if not boHeroTtem then begin
            n_UsesItemTick := 0; //20080311
            SendItemUseTime(n_UsesItemTick); //发送聚灵珠使用剩余时间 20080309
            SysMsg('【聚灵珠】已聚集足够的经验，请双击使用!', c_Green, t_Hint);
          end else begin
            SysMsg('【英雄聚灵珠】已聚集足够的经验，请双击使用!', c_Green, t_Hint);
          end;
        end;
      end else m_nWinExp := 0; //20090425 增加，人物英雄都没有珠子时清除经验值
    nCode := 6;
    if (not boGetExpToItem) and (not boHeroToItem) and (not boHeroTtem) then n_UsesItemTick := 0; //20080611 主人英雄都没有珠子,则初始
    if m_nWinExp < 0 then m_nWinExp := 0; //20080923
  except
    MainOutMessage(Format('{%s} TPlayObject.GetExpToItem Code:%d.%p', [g_sExceptionVer, nCode, ExceptAddr]));
  end;
end;
//发送聚灵珠使用剩余时间 20080307

procedure TPlayObject.SendItemUseTime(dwTime: Integer);
var
  I: Integer;
  UserItem: pTUserItem;
  AmuletStdItem: pTStdItem;
  boGetExpToItem: Boolean;
begin
  boGetExpToItem := False;
  if m_ItemList.Count > 0 then begin //20080628
    for I := 0 to m_ItemList.Count - 1 do begin //人物包裹不为空
      UserItem := m_ItemList.Items[I];
      AmuletStdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if AmuletStdItem <> nil then begin
        if (AmuletStdItem.StdMode = 51) and (AmuletStdItem.Shape = 0) and (UserItem.btValue[20] = 1) then begin //聚灵珠
          dwTime := dwTime div 3600;
          SendMsg(self, RM_EXPTIMEITEMS, 0, UserItem.MakeIndex, dwTime, 0, ''); //发送聚灵珠剩于时间 20080307
          boGetExpToItem := True;
          Break;
        end;
      end;
    end;
  end;
  if (not boGetExpToItem) and (m_MyHero <> nil) then begin
    if m_MyHero.m_ItemList.Count > 0 then begin //20080628
      for I := 0 to m_MyHero.m_ItemList.Count - 1 do begin //英雄包裹不为空
        UserItem := m_MyHero.m_ItemList.Items[I];
        AmuletStdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if AmuletStdItem <> nil then begin
          if (AmuletStdItem.StdMode = 51) and (AmuletStdItem.Shape = 0) and (UserItem.btValue[20] = 1) then begin //聚灵珠
            dwTime := dwTime div 3600;
            SendMsg(self, RM_EXPTIMEITEMS, 0, UserItem.MakeIndex, dwTime, 0, ''); //发送聚灵珠剩于时间 20080307
            Break;
          end;
        end;
      end;
    end;
  end;
end;
//是否包裹里有聚灵珠 20080308   参数为1时,发送经验值,用于人物上线时发送  2-初始时间

function TPlayObject.IsItem_51(nCode: Integer): Boolean;
var
  I: Integer;
  UserItem: pTUserItem;
  AmuletStdItem: pTStdItem;
  boGetExpToItem: Boolean;
begin
  Result := False;
  try
    boGetExpToItem := False;
    if m_ItemList.Count > 0 then begin //20080628
      for I := 0 to m_ItemList.Count - 1 do begin //人物包裹不为空
        UserItem := m_ItemList.Items[I];
        if UserItem <> nil then begin //20090115
          AmuletStdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if AmuletStdItem <> nil then begin
            if (AmuletStdItem.StdMode = 51) and (AmuletStdItem.Shape = 0) and (UserItem.btValue[12] <> 2) then begin //聚灵珠
              case nCode of
                1: begin
                    if UserItem.btValue[20] <> 1 then Continue;
                    if m_nWinExp >= 10000 then begin
                      Inc(UserItem.Dura);
                      dec(m_nWinExp, 10000);
                      boGetExpToItem := True;
                      if UserItem.Dura > UserItem.DuraMax then UserItem.Dura := UserItem.DuraMax;
                    end;
                    SendMsg(self, RM_DURACHANGE, UserItem.wIndex, UserItem.Dura, UserItem.DuraMax, 0, '' {IntToStr(m_nWinExp)});
                    SendItemUseTime(n_UsesItemTick); //20080412
                  end;
                2: begin
                    n_UsesItemTick := 0; //时间初始 20080911
                    UserItem.btValue[12] := 2; //20080522 增加,不能聚集的标识
                  end;
              end;
              Result := True;
              Break;
            end;
          end;
        end;
      end;
    end;
    if (nCode = 1) and (not boGetExpToItem) and (m_MyHero <> nil) then begin
      if m_MyHero.m_ItemList.Count > 0 then begin //20080628
        for I := 0 to m_MyHero.m_ItemList.Count - 1 do begin //英雄包裹不为空
          UserItem := m_MyHero.m_ItemList.Items[I];
          if UserItem <> nil then begin //20090115
            AmuletStdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if AmuletStdItem <> nil then begin
              if (AmuletStdItem.StdMode = 51) and (AmuletStdItem.Shape = 0) and (UserItem.btValue[12] <> 2) then begin //聚灵珠
                if UserItem.btValue[20] <> 1 then Continue;
                if m_nWinExp >= 10000 then begin
                  Inc(UserItem.Dura);
                  dec(m_nWinExp, 10000);
                  if UserItem.Dura > UserItem.DuraMax then UserItem.Dura := UserItem.DuraMax;
                end;
                THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HERODURACHANGE, UserItem.wIndex, UserItem.Dura, UserItem.DuraMax, 0, '' {IntToStr(m_nWinExp)}); //20080610 修改
                SendItemUseTime(n_UsesItemTick); //20080412
                THeroObject(m_MyHero).SendUpdateItem(UserItem); //更新物品
                Result := True;
                Break;
              end;
            end;
          end;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TPlayObject.IsItem_51.%p', [g_sExceptionVer, ExceptAddr]));
  end;
end;

//重新计算角色的等级各属性

procedure TBaseObject.RecalcLevelAbilitys();
var
  nLevel, n: Integer;
begin
  nLevel := m_Abil.Level;
  case m_btJob of
    2: begin //道
        if 14 + Round(((nLevel / g_Config.nLevelValueOfTaosHP + g_Config.nLevelValueOfTaosHPRate) * nLevel)) > High(Integer) then begin //20091026 修改
          m_Abil.MaxHP := High(Integer);
        end else m_Abil.MaxHP := 14 + Round(((nLevel / g_Config.nLevelValueOfTaosHP + g_Config.nLevelValueOfTaosHPRate) * nLevel));

        if 13 + Round(((nLevel / g_Config.nLevelValueOfTaosMP) * 2.2 * nLevel)) > High(Integer) then begin //20091026 修改
          m_Abil.MaxMP := High(Integer);
        end else m_Abil.MaxMP := 13 + Round(((nLevel / g_Config.nLevelValueOfTaosMP) * 2.2 * nLevel));

        m_Abil.MaxWeight := _MIN(High(Word), 50 + Round((nLevel / 4) * nLevel));
        m_Abil.MaxWearWeight := _MIN(High(Word), 15 + Round((nLevel / 50) * nLevel));
        m_Abil.MaxHandWeight := _MIN(High(Word), 12 + Round((nLevel / 42) * nLevel));

        n := nLevel div 7;
        m_Abil.DC := MakeLong(_MAX(n - 1, 0), _MAX(1, n));
        m_Abil.MC := 0;
        m_Abil.SC := MakeLong(_MAX(n - 1, 0), _MAX(1, n));
        m_Abil.AC := 0;

        n := Round(nLevel / 6);
        m_Abil.MAC := MakeLong(n div 2, n + 1);
        if m_btRaceServer = RC_HEROOBJECT then begin //道英雄HP值按设置倍数计算 20090207
          if Round(m_Abil.MaxHP * (g_Config.nHeroHPRate2 / 1000)) > High(Integer) then begin //20091026 修改
            m_Abil.MaxHP := High(Integer);
          end else m_Abil.MaxHP := Round(m_Abil.MaxHP * (g_Config.nHeroHPRate2 / 1000));
        end;
      end;
    1: begin //法
        if 14 + Round(((nLevel / g_Config.nLevelValueOfWizardHP + g_Config.nLevelValueOfWizardHPRate) * nLevel)) > High(Integer) then begin //20091026 修改
          m_Abil.MaxHP := High(Integer);
        end else m_Abil.MaxHP := 14 + Round(((nLevel / g_Config.nLevelValueOfWizardHP + g_Config.nLevelValueOfWizardHPRate) * nLevel));

        if 13 + Round((nLevel / 5 + 2) * 2.2 * nLevel) > High(Integer) then begin //20091026 修改
          m_Abil.MaxMP := High(Integer);
        end else m_Abil.MaxMP := 13 + Round((nLevel / 5 + 2) * 2.2 * nLevel);

        m_Abil.MaxWeight := _MIN(High(Word), 50 + Round((nLevel / 5) * nLevel));
        m_Abil.MaxWearWeight := _MIN(High(Word), 15 + Round((nLevel / 100) * nLevel));
        m_Abil.MaxHandWeight := _MIN(High(Word), 12 + Round((nLevel / 90) * nLevel));

        n := nLevel div 7;
        m_Abil.DC := MakeLong(_MAX(n - 1, 0), _MAX(1, n));
        m_Abil.MC := MakeLong(_MAX(n - 1, 0), _MAX(1, n));
        m_Abil.SC := 0;
        m_Abil.AC := 0;
        m_Abil.MAC := 0;
        if m_btRaceServer = RC_HEROOBJECT then begin //法英雄HP值按设置倍数计算 20090207
          if Round(m_Abil.MaxHP * (g_Config.nHeroHPRate1 / 1000)) > High(Integer) then begin //20091026 修改
            m_Abil.MaxHP := High(Integer);
          end else m_Abil.MaxHP := Round(m_Abil.MaxHP * (g_Config.nHeroHPRate1 / 1000));
        end;
      end;
    0: begin //战
        if 14 + Round(((nLevel / g_Config.nLevelValueOfWarrHP + g_Config.nLevelValueOfWarrHPRate + nLevel / 20) * nLevel)) > High(Integer) then begin //20091026 修改
          m_Abil.MaxHP := High(Integer);
        end else m_Abil.MaxHP := 14 + Round(((nLevel / g_Config.nLevelValueOfWarrHP + g_Config.nLevelValueOfWarrHPRate + nLevel / 20) * nLevel));

        if 11 + Round(nLevel * 3.5) > High(Integer) then begin //20091026 修改
          m_Abil.MaxMP := High(Integer);
        end else m_Abil.MaxMP := 11 + Round(nLevel * 3.5);

        m_Abil.MaxWeight := _MIN(High(Word), 50 + Round((nLevel / 3) * nLevel));
        m_Abil.MaxWearWeight := _MIN(High(Word), 15 + Round((nLevel / 20) * nLevel));
        m_Abil.MaxHandWeight := _MIN(High(Word), 12 + Round((nLevel / 13) * nLevel));
        m_Abil.DC := MakeLong(_MAX((nLevel div 5) - 1, 1), _MAX(1, (nLevel div 5)));
        m_Abil.SC := 0;
        m_Abil.MC := 0;
        m_Abil.AC := MakeLong(0, (nLevel div 7));
        m_Abil.MAC := 0;
        if m_btRaceServer = RC_HEROOBJECT then begin //战英雄HP值按设置倍数计算 20081219
          if Round(m_Abil.MaxHP * (g_Config.nHeroHPRate / 1000)) > High(Integer) then begin //20091026 修改
            m_Abil.MaxHP := High(Integer);
          end else m_Abil.MaxHP := Round(m_Abil.MaxHP * (g_Config.nHeroHPRate / 1000));
        end;
      end;
   {3: begin//刺客(暂时使用战士参数)
        m_Abil.MaxHP := _MIN(High(Word), 14 + Round(((nLevel / g_Config.nLevelValueOfWarrHP + g_Config.nLevelValueOfWarrHPRate + nLevel / 20) * nLevel)));
        m_Abil.MaxMP := _MIN(High(Word), 11 + Round(nLevel * 3.5));
        m_Abil.MaxWeight := 50 + Round((nLevel / 3) * nLevel);
        m_Abil.MaxWearWeight := 15 + Round((nLevel / 20) * nLevel);
        m_Abil.MaxHandWeight := 12 + Round((nLevel / 13) * nLevel);
        m_Abil.DC := MakeLong(_MAX((nLevel div 5) - 1, 1), _MAX(1, (nLevel div 5)));
        m_Abil.SC := 0;
        m_Abil.MC := 0;
        m_Abil.AC := MakeLong(0, (nLevel div 7));
        m_Abil.MAC := 0;
      end;}
  end;

// if m_Abil.HP > m_Abil.MaxHP then m_Abil.HP := m_Abil.MaxHP; //20100821 注释
  if m_Abil.MP > m_Abil.MaxMP then m_Abil.MP := m_Abil.MaxMP;
end;
//按设置等级计算属性

procedure TBaseObject.RecalcLevelAbilitysEx(nLevel: Integer);
var
  n: Integer;
begin
  if nLevel <= 0 then Exit;
  case m_btJob of
    2: begin //道
        if 14 + Round(((nLevel / g_Config.nLevelValueOfTaosHP + g_Config.nLevelValueOfTaosHPRate) * nLevel)) > High(Integer) then begin //20091026 修改
          m_Abil.MaxHP := High(Integer);
        end else m_Abil.MaxHP := 14 + Round(((nLevel / g_Config.nLevelValueOfTaosHP + g_Config.nLevelValueOfTaosHPRate) * nLevel));

        if 13 + Round(((nLevel / g_Config.nLevelValueOfTaosMP) * 2.2 * nLevel)) > High(Integer) then begin //20091026 修改
          m_Abil.MaxMP := High(Integer);
        end else m_Abil.MaxMP := 13 + Round(((nLevel / g_Config.nLevelValueOfTaosMP) * 2.2 * nLevel));

        m_Abil.MaxWeight := _MIN(High(Word), 50 + Round((nLevel / 4) * nLevel));
        m_Abil.MaxWearWeight := _MIN(High(Word), 15 + Round((nLevel / 50) * nLevel));
        m_Abil.MaxHandWeight := _MIN(High(Word), 12 + Round((nLevel / 42) * nLevel));

        n := nLevel div 7;
        m_Abil.DC := MakeLong(_MAX(n - 1, 0), _MAX(1, n));
        m_Abil.MC := 0;
        m_Abil.SC := MakeLong(_MAX(n - 1, 0), _MAX(1, n));
        m_Abil.AC := 0;

        n := Round(nLevel / 6);
        m_Abil.MAC := MakeLong(n div 2, n + 1);
        if m_btRaceServer = RC_HEROOBJECT then begin //道英雄HP值按设置倍数计算 20090207
          if Round(m_Abil.MaxHP * (g_Config.nHeroHPRate2 / 1000)) > High(Integer) then begin //20091026 修改
            m_Abil.MaxHP := High(Integer);
          end else m_Abil.MaxHP := Round(m_Abil.MaxHP * (g_Config.nHeroHPRate2 / 1000));
        end;
      end;
    1: begin //法
        if 14 + Round(((nLevel / g_Config.nLevelValueOfWizardHP + g_Config.nLevelValueOfWizardHPRate) * nLevel)) > High(Integer) then begin //20091026 修改
          m_Abil.MaxHP := High(Integer);
        end else m_Abil.MaxHP := 14 + Round(((nLevel / g_Config.nLevelValueOfWizardHP + g_Config.nLevelValueOfWizardHPRate) * nLevel));

        if 13 + Round((nLevel / 5 + 2) * 2.2 * nLevel) > High(Integer) then begin //20091026 修改
          m_Abil.MaxMP := High(Integer);
        end else m_Abil.MaxMP := 13 + Round((nLevel / 5 + 2) * 2.2 * nLevel);

        m_Abil.MaxWeight := _MIN(High(Word), 50 + Round((nLevel / 5) * nLevel));
        m_Abil.MaxWearWeight := _MIN(High(Word), 15 + Round((nLevel / 100) * nLevel));
        m_Abil.MaxHandWeight := _MIN(High(Word), 12 + Round((nLevel / 90) * nLevel));

        n := nLevel div 7;
        m_Abil.DC := MakeLong(_MAX(n - 1, 0), _MAX(1, n));
        m_Abil.MC := MakeLong(_MAX(n - 1, 0), _MAX(1, n));
        m_Abil.SC := 0;
        m_Abil.AC := 0;
        m_Abil.MAC := 0;
        if m_btRaceServer = RC_HEROOBJECT then begin //法英雄HP值按设置倍数计算 20090207
          if Round(m_Abil.MaxHP * (g_Config.nHeroHPRate1 / 1000)) > High(Integer) then begin //20091026 修改
            m_Abil.MaxHP := High(Integer);
          end else m_Abil.MaxHP := Round(m_Abil.MaxHP * (g_Config.nHeroHPRate1 / 1000));
        end;
      end;
    0: begin //战
        if 14 + Round(((nLevel / g_Config.nLevelValueOfWarrHP + g_Config.nLevelValueOfWarrHPRate + nLevel / 20) * nLevel)) > High(Integer) then begin //20091026 修改
          m_Abil.MaxHP := High(Integer);
        end else m_Abil.MaxHP := 14 + Round(((nLevel / g_Config.nLevelValueOfWarrHP + g_Config.nLevelValueOfWarrHPRate + nLevel / 20) * nLevel));

        if 11 + Round(nLevel * 3.5) > High(Integer) then begin //20091026 修改
          m_Abil.MaxMP := High(Integer);
        end else m_Abil.MaxMP := 11 + Round(nLevel * 3.5);

        m_Abil.MaxWeight := _MIN(High(Word), 50 + Round((nLevel / 3) * nLevel));
        m_Abil.MaxWearWeight := _MIN(High(Word), 15 + Round((nLevel / 20) * nLevel));
        m_Abil.MaxHandWeight := _MIN(High(Word), 12 + Round((nLevel / 13) * nLevel));
        m_Abil.DC := MakeLong(_MAX((nLevel div 5) - 1, 1), _MAX(1, (nLevel div 5)));
        m_Abil.SC := 0;
        m_Abil.MC := 0;
        m_Abil.AC := MakeLong(0, (nLevel div 7));
        m_Abil.MAC := 0;
        if m_btRaceServer = RC_HEROOBJECT then begin //战英雄HP值按设置倍数计算 20081219
          if Round(m_Abil.MaxHP * (g_Config.nHeroHPRate / 1000)) > High(Integer) then begin //20091026 修改
            m_Abil.MaxHP := High(Integer);
          end else m_Abil.MaxHP := Round(m_Abil.MaxHP * (g_Config.nHeroHPRate / 1000));
        end;
      end;
   {3: begin//刺客(暂时使用战士参数)
        m_Abil.MaxHP := _MIN(High(Word), 14 + Round(((nLevel / g_Config.nLevelValueOfWarrHP + g_Config.nLevelValueOfWarrHPRate + nLevel / 20) * nLevel)));
        m_Abil.MaxMP := _MIN(High(Word), 11 + Round(nLevel * 3.5));
        m_Abil.MaxWeight := 50 + Round((nLevel / 3) * nLevel);
        m_Abil.MaxWearWeight := 15 + Round((nLevel / 20) * nLevel);
        m_Abil.MaxHandWeight := 12 + Round((nLevel / 13) * nLevel);
        m_Abil.DC := MakeLong(_MAX((nLevel div 5) - 1, 1), _MAX(1, (nLevel div 5)));
        m_Abil.SC := 0;
        m_Abil.MC := 0;
        m_Abil.AC := MakeLong(0, (nLevel div 7));
        m_Abil.MAC := 0;
      end;}
  end;
// if m_Abil.HP > m_Abil.MaxHP then m_Abil.HP := m_Abil.MaxHP; //20100821 注释
  if m_Abil.MP > m_Abil.MaxMP then m_Abil.MP := m_Abil.MaxMP;
end;

procedure TBaseObject.HasLevelUp(nLevel: Integer);
var
  nCode: Byte; //20100117
begin
  nCode := 0;
  try
    if (not m_boGhost) then begin //20090526 修改
      nCode := 1;
      m_Abil.nMaxExp := GetLevelExp(m_Abil.Level);
      nCode := 2;
      RecalcLevelAbilitys(); //刷新等级各种属性
      nCode := 3;
      RecalcAbilitys();
      nCode := 4;
      CompareSuitItem(False); //200080808 套装
      nCode := 5;
      if nLevel <> 0 then begin //20080305 根据参数来发消息,参数为0不发消息
        case m_btRaceServer of
          RC_PLAYOBJECT: begin
              nCode := 6;
              if not TPlayObject(Self).m_boNotOnlineAddExp then begin //非挂机人物
                nCode := 61;
                SendMsg(Self, RM_LEVELUP, 0, 0, 0, 0, '');
                SendRefMsg(RM_MYSHOW, ET_OBJECTLEVELUP, 0, 0, 0, ''); //人物升级动画  20080222
              end;
              nCode := 62;
              TPlayObject(Self).LevelUpFunc(); //人物升级触发 20090311 挂机也触发
            end;
          RC_HEROOBJECT: begin
              nCode := 7;
              if (m_Master <> nil) then begin //20090413 修改
                nCode := 71;
                if TPlayObject(m_Master).m_sDeputyHeroName <> '' then begin //评定过主副将英雄则记录对应英雄等级
                  nCode := 72;
                  if TPlayObject(m_Master).m_boCallDeputyHero then TPlayObject(m_Master).m_nHeroLevel2 := m_Abil.Level //副将英雄等级
                  else TPlayObject(m_Master).m_nHeroLevel1 := m_Abil.Level; //主将英雄等级
                end;
                nCode := 73;
                if (not TPlayObject(m_Master).m_boNotOnlineAddExp) and (not m_Master.m_boGhost) then begin //20090512 增加 m_boGhost
                  nCode := 74;
                  THeroObject(Self).SendMsg(m_Master, RM_HEROLEVELUP, 0, 0, 0, 0, '');
                  SendRefMsg(RM_MYSHOW, ET_OBJECTLEVELUP, 0, 0, 0, ''); //人物升级动画  20080222
                  nCode := 75;
                  THeroObject(Self).GetBagItemCount; //刷新英雄包裹容量
                end;
              end;
              nCode := 76;
              THeroObject(Self).LevelUpFunc(); //英雄升级触发 20080423  20090311 挂机也触发
            end;
        end; //case
      end;
      nCode := 8;
{$IFDEF FOR_ABIL_POINT}
      if prevlevel + 1 = Abil.Level then begin
        BonusPoint := BonusPoint + GetBonusPoint(Job, Abil.Level);
        SendMsg(Self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
      end else begin
        if prevlevel <> Abil.Level then begin
          BonusPoint := GetLevelBonusSum(Job, Abil.Level);
          FillChar(BonusAbil, SizeOf(TNakedAbility), #0);
          FillChar(CurBonusAbil, SizeOf(TNakedAbility), #0);
          RecalcLevelAbilitys; //刷新等级各种属性
          SendMsg(Self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
        end;
      end;
{$ENDIF}
    end;
  except
    MainOutMessage(Format('{%s} TBaseObject.HasLevelUp Code:%d.%p', [g_sExceptionVer, nCode, ExceptAddr]));
  end;
end;
//增加金币

function TPlayObject.IncGold(tGold: Integer): Boolean;
begin
  Result := False;
  if m_nGold + tGold <= g_Config.nHumanMaxGold then begin
    Inc(m_nGold, tGold);
    Result := True;
  end;
end;

procedure TPlayObject.IncGameDiaMond(nGameDiaMond: Integer); //20071226 金刚石
begin
  Inc(m_nGameDiaMond, nGameDiaMond);
end;

procedure TPlayObject.IncGameGird(nGameGird: Integer); //20071226 灵符
begin
  Inc(m_nGameGird, nGameGird);
end;

procedure TPlayObject.IncGamePoint(nGamePoint: Integer);
begin
  Inc(m_nGamePoint, nGamePoint);
end;

function TBaseObject.WalkTo(btDir: Byte; boFlag: Boolean): Boolean;
var
  nOX, nOY, nNX, nNY, n20, n24: Integer;
  bo29: Boolean;
  nCode: Byte;
resourcestring
  sExceptionMsg = '{%s} TBaseObject::WalkTo Code:%d.%p';
begin
  Result := False;
  nCode := 0;
  if m_boHolySeize or (m_wStatusTimeArr[POISON_DONTMOVE] <> 0) then Exit;
  try
    nOX := m_nCurrX;
    nOY := m_nCurrY;
    m_btDirection := btDir;
    nNX := 0;
    nNY := 0;
    nCode := 1;
    case btDir of
      DR_UP: begin
          nNX := m_nCurrX; nNY := m_nCurrY - 1; end;
      DR_UPRIGHT: begin
          nNX := m_nCurrX + 1; nNY := m_nCurrY - 1; end;
      DR_RIGHT: begin
          nNX := m_nCurrX + 1; nNY := m_nCurrY; end;
      DR_DOWNRIGHT: begin
          nNX := m_nCurrX + 1; nNY := m_nCurrY + 1; end;
      DR_DOWN: begin
          nNX := m_nCurrX; nNY := m_nCurrY + 1; end;
      DR_DOWNLEFT: begin
          nNX := m_nCurrX - 1; nNY := m_nCurrY + 1; end;
      DR_LEFT: begin
          nNX := m_nCurrX - 1; nNY := m_nCurrY; end;
      DR_UPLEFT: begin
          nNX := m_nCurrX - 1; nNY := m_nCurrY - 1; end;
    end;
    nCode := 2;
    if (nNX >= 0) and ((m_PEnvir.m_nWidth - 1) >= nNX) and
      (nNY >= 0) and ((m_PEnvir.m_nHeight - 1) >= nNY) then begin
      bo29 := True;
      nCode := 3;
      if bo2BA and not m_PEnvir.CanSafeWalk(nNX, nNY) then bo29 := False; //精灵为不进入火墙时，检查是否能安全的走过
      nCode := 4;
      if m_Master <> nil then begin
        if not m_Master.m_boGhost then begin //20081216
          nCode := 5;
          m_Master.m_PEnvir.GetNextPosition(m_Master.m_nCurrX, m_Master.m_nCurrY, m_Master.m_btDirection, 1, n20, n24);
          nCode := 6;
          if (nNX = n20) and (nNY = n24) then bo29 := False;
        end;
      end;
      if bo29 then begin
        nCode := 7;
        if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nNX, nNY, boFlag) > 0 then begin
          m_nCurrX := nNX;
          m_nCurrY := nNY;
        end;
      end;
    end;
    if (m_nCurrX <> nOX) or (m_nCurrY <> nOY) then begin
      nCode := 8;
      if Walk(RM_WALK) then begin
        if m_boTransparent and m_boHideMode then m_wStatusTimeArr[STATE_TRANSPARENT {8}] := 1; //走动隐身状态消失
        Result := True;
      end else begin
        nCode := 9;
        m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
        m_nCurrX := nOX;
        m_nCurrY := nOY;
        nCode := 10;
        m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
      end;
    end;
  except
    MainOutMessage(Format(sExceptionMsg, [g_sExceptionVer, nCode, ExceptAddr]));
  end;
end;
//包裹是否满了

function TPlayObject.IsEnoughBag: Boolean;
begin
  Result := False;
  if m_ItemList.Count < MAXBAGITEM then Result := True;
end;
//是否超过负重

function TBaseObject.IsAddWeightAvailable(nWeight: Integer): Boolean;
begin
  Result := False;
  if (m_WAbil.Weight + nWeight) <= m_WAbil.MaxWeight then
    Result := True;
end;

procedure TPlayObject.SendAddItem(UserItem: pTUserItem);
var
  pStdItem: pTStdItem;
  StdItem: TStdItem;
  ClientItem: TClientItem;
  EffecItem: pTEffecItem;
  OClientItem: TOClientItem;
  sUserItemName: string;
begin
  if m_boNotOnlineAddExp or m_boAI then Exit; //离线挂机不发送 20110316
  if m_nSoftVersionDateEx = 0 then begin
    pStdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if pStdItem = nil then Exit;
    StdItem := pStdItem^;
    ItemUnit.GetItemAddValue(UserItem, StdItem);
    //Move(StdItem,ClientItem.S,SizeOf(TStdItem));
    CopyStdItemToOStdItem(@StdItem, @OClientItem.s);
    //取自定义物品名称
    sUserItemName := '';
    if UserItem.btValue[13] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if sUserItemName <> '' then
      OClientItem.s.Name := sUserItemName;

    OClientItem.MakeIndex := UserItem.MakeIndex;
    OClientItem.Dura := UserItem.Dura;
    OClientItem.DuraMax := UserItem.DuraMax;
    {if StdItem.StdMode = 50 then begin//20080808 注释
      OClientItem.s.Name := OClientItem.s.Name + ' #' + IntToStr(UserItem.Dura);
    end;}

    if StdItem.StdMode in [15, 19, 20, 21, 22, 23, 24, 26, 27, 28, 29] then begin //20100513 修改 20100628 增加29分类(敏捷幸运型项链)
      if UserItem.btValue[8] = 0 then OClientItem.s.Shape := 0
      else OClientItem.s.Shape := 130;
    end;

    m_DefMsg := MakeDefaultMsg(SM_ADDITEM, Integer(Self), 0, 0, 1, 0);
    SendSocket(@m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
  end else begin
    pStdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if pStdItem = nil then Exit;
    FillChar(ClientItem, SizeOf(ClientItem), #0);
    StdItem := pStdItem^;
    ItemUnit.GetItemAddValue(UserItem, StdItem);
    Move(StdItem, ClientItem.s, SizeOf(TStdItem));
    //取特效配置
    {By TasNat at: 2012-11-22 11:08:57
    EffecItem := GetEffecItemList(StdItem.Name); //取物品特效
    if EffecItem <> nil then begin
      Move(EffecItem^, ClientItem.ClientEffec, SizeOf(TEffecItem));
    end;   }
    //取自定义物品名称
    sUserItemName := '';
    if UserItem.btValue[13] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if (UserItem.btValue[12] = 1) and (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) then ClientItem.s.Reserved1 := 1 //物品发光 20080223
    else ClientItem.s.Reserved1 := 0;
{$IF M2Version <> 2}
    if (StdItem.StdMode = 5) or (StdItem.StdMode = 6) then begin //武器暴击等级 20100708
      ClientItem.s.NeedIdentify := _MIN(High(Byte), UserItem.btValue[11] + UserItem.btValue[20]);
      if CheckItemSpiritMedia(UserItem) then begin
        ClientItem.Aura := UserItem.btValue[12];
        ClientItem.MaxAura := g_Config.nMaxAuraValue;
      end;
    end else begin
      if CheckItemSpiritMedia(UserItem) or ((StdItem.StdMode = 44) and (StdItem.shape = 253)) then begin
        ClientItem.Aura := UserItem.btValue[11];
        ClientItem.MaxAura := g_Config.nMaxAuraValue;
      end;
    end;
    if (StdItem.StdMode = 44) and (StdItem.shape = 255) then begin //神秘卷轴
      ClientItem.s.NeedIdentify := UserItem.btValue[0];
    end;
{$IFEND}
    if sUserItemName <> '' then ClientItem.s.Name := sUserItemName;

    ClientItem.MakeIndex := UserItem.MakeIndex;
    ClientItem.Dura := UserItem.Dura;
    ClientItem.DuraMax := UserItem.DuraMax;
    Move(UserItem.btValue, ClientItem.btValue, SizeOf(ClientItem.btValue)); //20100822
    //Modified By TasNat at: 2012-04-12 09:28:18
    ClientItem.btAppraisalLevel :=   UserItem.btAppraisalLevel;
    ClientItem.btUnKnowValueCount := UserItem.btUnKnowValueCount;
    Move(UserItem.btAppraisalValue, ClientItem.btAppraisalValue, SizeOf(UserItem.btAppraisalValue));

    Move(UserItem.btUnKnowValue, ClientItem.btUnKnowValue, SizeOf(ClientItem.btUnKnowValue)); //20100822
    ClientItem.BindValue := UserItem.AddValue[0]; //20110622
    ClientItem.MaxDate := UserItem.MaxDate; //20110622
    if ClientItem.BindValue = 0 then begin //禁止交易,扔物品,显示绑定 20110626
      if (CheckItemValue(UserItem, 1) and CheckItemValue(UserItem, 0)) or
        (GetCheckItemList(0, StdItem.Name) and GetCheckItemList(1, StdItem.Name)) then
        ClientItem.BindValue := 3;
    end;
    case StdItem.StdMode of //20081009 修改
      8: if UserItem.btValue[0] <> 0 then ClientItem.s.AC := UserItem.btValue[0]; //材料的品质
      15, 19..24, 26, 27, 28, 29: if UserItem.btValue[8] <> 0 then ClientItem.s.Shape := 130; //20100513 修改 20100628 增加29分类(敏捷幸运型项链)
      51: if (StdItem.Shape = 0) then ClientItem.s.Need := StdItem.AniCount * 24; //如果是聚灵珠,则换成小时数 20080323
      60: begin
          if (StdItem.shape <> 0) then begin //酒类,除烧酒外 20080622
            if UserItem.btValue[0] <> 0 then ClientItem.s.AC := UserItem.btValue[0]; //酒的品质
            if UserItem.btValue[1] <> 0 then ClientItem.s.MAC := UserItem.btValue[1]; //酒的酒精度
            if UserItem.btValue[3] > 0 then ClientItem.s.NeedLevel := UserItem.btValue[3] //酒的等级 20091117
            else ClientItem.s.NeedLevel := 0;
          end;
        end;
      17: if StdItem.Weight > 0 then ClientItem.s.Weight := UserItem.Dura; //拆加物品的重量 20090816
    end;
    m_DefMsg := MakeDefaultMsg(SM_ADDITEM, Integer(Self), 0, 0, 1, 0);
    SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(ClientItem)));
  end;
end;

//是否是组队的成员

function TPlayObject.IsGroupMember(Target: TBaseObject): Boolean;
var
  I: Integer;
  nCode: Byte;
begin
  Result := False;
  nCode := 0;
  try
    if (m_GroupOwner = nil) or (Target = nil) or (Self = nil) then Exit; //20080812 增加
    nCode := 6;
    if m_boDeath or m_boGhost or (m_btRaceServer <> RC_PLAYOBJECT) or (Target.m_btRaceServer <> RC_PLAYOBJECT) then Exit; //20090818 增加
    nCode := 4;
    if m_GroupOwner.m_GroupMembers.Count > 0 then begin //20090818 增加
      I := m_GroupOwner.m_GroupMembers.IndexOf(Target.m_sCharName); //20101104 增加
      if I > -1 then Result := True;
      {nCode:= 5;
      for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
        nCode:= 2;
        if m_GroupOwner.m_GroupMembers.Objects[I] = Target then begin
          nCode:= 3;
          Result := True;
          Break;
        end;
      end; }
    end;
  except
    MainOutMessage(Format('{%s} TPlayObject.IsGroupMember Code:%d.%p', [g_sExceptionVer, nCode, ExceptAddr]));
  end;
end;

procedure TPlayObject.Hear(nIndex: Integer; sMsg: string);
begin

end;

//私聊  whostr-对谁说的

procedure TPlayObject.Whisper(whostr, saystr: string);
var
  PlayObject: TPlayObject;
  //svidx: Integer;
begin
  PlayObject := UserEngine.GetPlayObject(whostr);
  if PlayObject <> nil then begin
    if not PlayObject.m_boReadyRun then begin
      SysMsg(whostr + g_sCanotSendmsg {'无法发送信息.'}, c_Red, t_Hint);
      Exit;
    end;
    if not PlayObject.m_boHearWhisper or PlayObject.IsBlockWhisper(m_sCharName) then begin
      SysMsg(whostr + g_sUserDenyWhisperMsg {' 拒绝私聊！！！'}, c_Red, t_Hint);
      Exit;
    end;
    if g_Config.boRecordClientMsg and (saystr <> '') then begin //记录私聊聊天信息 20090129
      MainOutMessage('[私聊] ' + m_sCharName + '=>' + PlayObject.m_sCharName + ':' + saystr);
    end;
    if (PlayObject.m_boNotOnlineAddExp) then begin //离线挂机人物自动回复
      if m_btPermission >= 10 then begin
        if (PlayObject.m_sAutoSendMsg <> '') then SendMsg(Self, RM_WHISPER, 0, g_Config.btGMWhisperMsgFColor, g_Config.btGMWhisperMsgBColor, 0, PlayObject.m_sCharName + '=>' + ' ' + PlayObject.m_sAutoSendMsg);
      end else begin
        if HangAutoMsgList.Count > 0 then begin
          if HangAutoMsgList.Count > PlayObject.m_nShowHangAutoMsgIdx then begin
            SendMsg(Self, RM_WHISPER, PlayObject.m_Abil.Level, m_btWhisperMsgFColor, g_Config.btWhisperMsgBColor, 0, Format('%s[%d级]=> %s', [PlayObject.m_sCharName, PlayObject.m_Abil.Level, HangAutoMsgList.Strings[PlayObject.m_nShowHangAutoMsgIdx]]));
            Inc(PlayObject.m_nShowHangAutoMsgIdx);
          end;
          if (HangAutoMsgList.Count <= PlayObject.m_nShowHangAutoMsgIdx) then PlayObject.m_nShowHangAutoMsgIdx := 0;
        end else begin
          if (PlayObject.m_sAutoSendMsg <> '') then SendMsg(Self, RM_WHISPER, PlayObject.m_Abil.Level, m_btWhisperMsgFColor, g_Config.btWhisperMsgBColor, 0, Format('%s[%d级]=> %s', [PlayObject.m_sCharName, PlayObject.m_Abil.Level, PlayObject.m_sAutoSendMsg]));
        end;
      end;
      Exit;
    end;
    if m_btPermission > 0 then begin
      PlayObject.SendMsg(PlayObject, RM_WHISPER, m_Abil.Level, g_Config.btGMWhisperMsgFColor, g_Config.btGMWhisperMsgBColor, 0, Format('%s[%d级]=> %s', [m_sCharName, m_Abil.Level, saystr]));
      //取得私聊信息
      //m_GetWhisperHuman 侦听私聊对象
      if (m_GetWhisperHuman <> nil) and (not m_GetWhisperHuman.m_boGhost) then
        m_GetWhisperHuman.SendMsg(m_GetWhisperHuman, RM_WHISPER, m_Abil.Level, g_Config.btGMWhisperMsgFColor, g_Config.btGMWhisperMsgBColor, 0, Format('%s[%d级]=> %s %s', [m_sCharName, m_Abil.Level, PlayObject.m_sCharName, saystr]));
      if (PlayObject.m_GetWhisperHuman <> nil) and (not PlayObject.m_GetWhisperHuman.m_boGhost) then
        PlayObject.m_GetWhisperHuman.SendMsg(PlayObject.m_GetWhisperHuman, RM_WHISPER, m_Abil.Level, g_Config.btGMWhisperMsgFColor, g_Config.btGMWhisperMsgBColor, 0, Format('%s[%d级]=> %s %s', [m_sCharName, m_Abil.Level, PlayObject.m_sCharName, saystr]));
    end else begin
      PlayObject.SendMsg(PlayObject, RM_WHISPER, m_Abil.Level, {g_Config.btWhisperMsgFColor} m_btWhisperMsgFColor, g_Config.btWhisperMsgBColor, 0, Format('%s[%d级]=> %s', [m_sCharName, m_Abil.Level, saystr]));
      if (m_GetWhisperHuman <> nil) and (not m_GetWhisperHuman.m_boGhost) then
        m_GetWhisperHuman.SendMsg(m_GetWhisperHuman, RM_WHISPER, m_Abil.Level, {g_Config.btWhisperMsgFColor} m_btWhisperMsgFColor, g_Config.btWhisperMsgBColor, 0, Format('%s[%d级]=> %s %s', [m_sCharName, m_Abil.Level, PlayObject.m_sCharName, saystr]));

      if (PlayObject.m_GetWhisperHuman <> nil) and (not PlayObject.m_GetWhisperHuman.m_boGhost) then
        PlayObject.m_GetWhisperHuman.SendMsg(PlayObject.m_GetWhisperHuman, RM_WHISPER, m_Abil.Level, {g_Config.btWhisperMsgFColor} m_btWhisperMsgFColor, g_Config.btWhisperMsgBColor, 0, Format('%s[%d级]=> %s %s', [m_sCharName, m_Abil.Level, PlayObject.m_sCharName, saystr]));
    end;
  end else begin
    {if UserEngine.FindOtherServerUser(whostr, svidx) then begin
      UserEngine.SendServerGroupMsg(SS_WHISPER, svidx, whostr + '/' + m_sCharName + '=> ' + saystr);//20101022 注释
    end else begin }
    SysMsg(whostr + g_sUserNotOnLine {'  没有在线！！！'}, c_Green, t_Hint);
    //end;
  end;
end;

function TPlayObject.IsBlockWhisper(sName: string): Boolean;
var
  I: Integer;
begin
  Result := False;
  if m_BlockWhisperList.Count > 0 then begin //20091113 增加
    for I := 0 to m_BlockWhisperList.Count - 1 do begin
      if CompareText(sName, m_BlockWhisperList.Strings[I]) = 0 then begin
        Result := True;
        Break;
      end;
    end;
  end;
end;

function TBaseObject.PKLevel(): Integer;
begin
  Result := m_nPkPoint div 100;
end;

procedure TBaseObject.HealthSpellChanged;
var nCode: byte;

  procedure UpdateToAllClient(Value: Word);
  var I: Integer;
  begin
      {for I := 0 to UserEngine.m_PlayObjectList.Count - 1 do
      begin
        TPlayObject(UserEngine.m_PlayObjectList.Objects[I]).SendUpdateMsg(Self, Value, 0, 0, 0, 0, '');
      end; }
  end;

begin
  nCode := 0;
  try
    if m_btRaceServer = RC_PLAYOBJECT then begin
      nCode := 1;
      if not TPlayObject(Self).m_boNotOnlineAddExp then //只发送给非离线挂机人物
      begin
        SendUpdateMsg(Self, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
        //UpdateToAllClient(RM_HEALTHSPELLCHANGED);
      end;
    end else if (m_btRaceServer = RC_HEROOBJECT) and (m_Master <> nil) then begin //英雄
      nCode := 2;
      if not TPlayObject(m_Master).m_boNotOnlineAddExp then //只发送给非离线挂机人物
      begin
        m_Master.SendUpdateMsg(Self, RM_HEROHEALTHSPELLCHANGED, 0, 0, 0, 0, ''); //20081219 替换，估计是这句导致人物等级乱变  //20090302 换新消息
        //UpdateToAllClient(RM_HEROHEALTHSPELLCHANGED);
      end;
    end else begin
      nCode := 3;
      SendUpdateMsg(Self, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
    end;
    nCode := 4;
    if m_boShowHP then SendRefMsg(RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
  except
    MainOutMessage(Format('{%s} TBaseObject.HealthSpellChanged Code:%d.%p', [g_sExceptionVer, nCode, ExceptAddr]));
  end;
end;
//插件气血改变血量 20080423

procedure TBaseObject.PlugHealthSpellChanged;
begin
  if m_btRaceServer = RC_PLAYOBJECT then begin
    if not TPlayObject(Self).m_boNotOnlineAddExp then //只发送给非离线挂机人物
      SendUpdateMsg(Self, RM_HEALTHSPELLCHANGED1, 0, 0, 0, 0, '');
  end else
    if (m_btRaceServer = RC_HEROOBJECT) then begin //英雄
      if (m_Master <> nil) then begin
        if not TPlayObject(m_Master).m_boNotOnlineAddExp then //只发送给非离线挂机人物
          m_Master.SendUpdateMsg(Self, RM_HEROHEALTHSPELLCHANGED1, 0, 0, 0, 0, '');
      end;
    end else begin
      SendUpdateMsg(Self, RM_HEALTHSPELLCHANGED1, 0, 0, 0, 0, ''); //200080525
    end;
  if m_boShowHP then SendRefMsg(RM_HEALTHSPELLCHANGED1, 0, 0, 0, 0, ''); //20090336 增加 if m_boShowHP then
end;
//计算可取得的经验值

function TBaseObject.CalcGetExp(nLevel: Integer; nExp: Integer): Integer;
begin
  if g_Config.boHighLevelKillMonFixExp or (m_Abil.Level < (nLevel + 10)) then begin
    Result := nExp;
  end else begin
    case m_btRaceServer of
      RC_PLAYOBJECT: begin //20090213 高等级杀怪经验不变
          if TPLAYOBJECT(self).m_boHighLevelKillMonFixExp then Result := nExp
          else Result := nExp - Round((nExp / 15) * (m_Abil.Level - (nLevel + 10)));
        end;
      RC_HEROOBJECT: begin //20090221 英雄真视经验不变增加
          if m_Master <> nil then begin
            if TPLAYOBJECT(m_Master).m_boHighLevelKillMonFixExp then Result := nExp
            else Result := nExp - Round((nExp / 15) * (m_Abil.Level - (nLevel + 10)));
          end else Result := nExp - Round((nExp / 15) * (m_Abil.Level - (nLevel + 10)));
        end;
    else begin
        if m_Master <> nil then begin
          case m_Master.m_btRaceServer of
            RC_PLAYOBJECT: begin
                if TPLAYOBJECT(m_Master).m_boHighLevelKillMonFixExp then Result := nExp
                else Result := nExp - Round((nExp / 15) * (m_Abil.Level - (nLevel + 10)));
              end;
            RC_HEROOBJECT: begin //20110911 增加
                if m_Master.m_Master <> nil then begin
                  if TPLAYOBJECT(m_Master.m_Master).m_boHighLevelKillMonFixExp then Result := nExp
                  else Result := nExp - Round((nExp / 15) * (m_Abil.Level - (nLevel + 10)));
                end else Result := nExp - Round((nExp / 15) * (m_Abil.Level - (nLevel + 10)));
              end;
          else Result := nExp - Round((nExp / 15) * (m_Abil.Level - (nLevel + 10)));
          end;
        end else Result := nExp - Round((nExp / 15) * (m_Abil.Level - (nLevel + 10)));
      end;
    end; //case
  end;
  if Result <= 0 then Result := 1;
end;
//刷新名字颜色

procedure TBaseObject.RefNameColor();
begin
  SendRefMsg(RM_CHANGENAMECOLOR, 0, 0, 0, 0, '');
end;
//圣兽升级所需的杀怪数

function TBaseObject.GetUpKill71Count(nLevel: Byte): Integer;
var
  tCount: Integer;
begin
  if nLevel < SLAVEMAXLEVEL - 2 then begin
    tCount := g_Config.MonUpLvNeedKillCount[nLevel];
    Result := nLevel * g_Config.nMonUpLvRate {16} + g_Config.nMonUpLvNeedKillBase {100} + tCount;
  end else begin
    tCount := g_Config.MonUpLvNeedKillCount[SLAVEMAXLEVEL - 2];
    Result := Round((nLevel * 0.3 + nLevel) * g_Config.nMonUpLvRate {16}) + g_Config.nMonUpLvNeedKillBase {100} + tCount;
  end;
end;

//宝宝升级

procedure TBaseObject.GainSlaveExp(nLevel: Integer);
var
  nMaxExp: LongWord;
  function GetUpKillCount(): Integer; //取升级的杀怪数量
  var
    tCount: Integer;
  begin
    if m_btSlaveExpLevel < SLAVEMAXLEVEL - 2 then begin
      tCount := g_Config.MonUpLvNeedKillCount[m_btSlaveExpLevel];
    end else begin
      tCount := 0;
    end;
    Result := ((m_Abil.Level * g_Config.nMonUpLvRate {16}) - m_Abil.Level) + g_Config.nMonUpLvNeedKillBase {100} + tCount;
  end;
begin
  try
    case m_btRaceServer of
      132, 133: begin //圣兽
          if m_Master <> nil then begin
            if not m_Master.m_boGhost then begin
              if m_Master.m_Magic71Skill <> nil then begin
                if m_Master.m_Magic71Skill.btLevel < 99 then begin
                  Inc(n294, nLevel); //20110205 移动位置
                  m_Master.m_Magic71Skill.nTranPoint := n294;
                  nMaxExp := GetUpKill71Count(m_Master.m_Magic71Skill.btLevel); //取圣兽升级所需的杀怪数
                  if nMaxExp < n294 then begin
                    Dec(n294, nMaxExp);
                    m_Master.m_Magic71Skill.nTranPoint := n294;
                    if m_Master.m_Magic71Skill.btLevel < 99 then begin
                      Inc(m_Master.m_Magic71Skill.btLevel);
                      m_btSlaveExpLevel := m_Master.m_Magic71Skill.btLevel;
                      RecalcAbilitys();
                      RefNameColor();
                    end;
                  end;
                  if m_Master.m_btRaceServer = RC_PLAYOBJECT then begin //更新技能点
                    nMaxExp := GetUpKill71Count(m_Master.m_Magic71Skill.btLevel); //取圣兽升级所需的杀怪数
                    m_Master.SendDelayMsg(m_Master, RM_MAGIC_LVEXP, m_Master.m_Magic71Skill.MagicInfo.wMagicId, nMaxExp, m_Master.m_Magic71Skill.btLevel, m_Master.m_Magic71Skill.nTranPoint, '', 1000);
                  end;
                end;
              end;
            end;
          end;
        end;
      154: begin //火灵
          if m_Master <> nil then begin
            if not m_Master.m_boGhost then begin
              if m_Master.m_Magic104Skill <> nil then begin
                if m_Master.m_Magic104Skill.btLevel < 100 then begin
                  Inc(n294, nLevel);
                  m_Master.m_Magic104Skill.nTranPoint := n294;
                  nMaxExp := GetUpKill71Count(m_Master.m_Magic104Skill.btLevel); //取升级所需的杀怪数
                  if nMaxExp < n294 then begin
                    Dec(n294, nMaxExp);
                    m_Master.m_Magic104Skill.nTranPoint := n294;
                    if m_Master.m_Magic104Skill.btLevel < 100 then begin
                      Inc(m_Master.m_Magic104Skill.btLevel);
                      m_btSlaveExpLevel := m_Master.m_Magic104Skill.btLevel;
                      RecalcAbilitys();
                      RefNameColor();
                    end;
                  end;
                  nMaxExp := GetUpKill71Count(m_Master.m_Magic104Skill.btLevel); //取升级所需的杀怪数
                  case m_Master.m_btRaceServer of
                    RC_PLAYOBJECT: m_Master.SendDelayMsg(m_Master, RM_MAGIC_LVEXP, m_Master.m_Magic104Skill.MagicInfo.wMagicId, nMaxExp, m_Master.m_Magic104Skill.btLevel, m_Master.m_Magic104Skill.nTranPoint, '', 1000);
                    RC_HEROOBJECT: THeroObject(m_Master).SendDelayMsg(m_Master, RM_HEROMAGIC_LVEXP, m_Master.m_Magic104Skill.MagicInfo.wMagicId, nMaxExp, m_Master.m_Magic104Skill.btLevel, m_Master.m_Magic104Skill.nTranPoint, '', 1000);
                  end;
                end;
              end;
            end;
          end;
        end;
    else begin
        Inc(n294, nLevel);
        if GetUpKillCount() < n294 then begin
          Dec(n294, GetUpKillCount);
          if m_btSlaveExpLevel < (m_btSlaveMakeLevel * 2 + 1) then begin
            Inc(m_btSlaveExpLevel);
            RecalcAbilitys();
            if m_btRaceServer = RC_HEROOBJECT then CompareSuitItem(False); //套装
            RefNameColor();
          end;
        end;
      end;
    end; //case
  except
    MainOutMessage(Format('{%s} TBaseObject.GainSlaveExp %p', [g_sExceptionVer, ExceptAddr]));
  end;
end;
//金币掉落

function TBaseObject.DropGoldDown(nGold: Integer; boFalg: Boolean; GoldOfCreat, DropGoldCreat: TBaseObject): Boolean; //004C5794
var
  MapItem, MapItemA: PTMapItem;
  nX, nY: Integer;
  s20: string;
begin
  Result := False;
  New(MapItem);
  FillChar(MapItem^, SizeOf(TMapItem), #0);
  MapItem.Name := sSTRING_GOLDNAME;
  MapItem.Count := nGold;
  MapItem.Looks := GetGoldShape(nGold);
  MapItem.OfBaseObject := GoldOfCreat;
  MapItem.dwCanPickUpTick := GetTickCount();
  MapItem.DropBaseObject := DropGoldCreat;
  GetDropPosition(m_nCurrX, m_nCurrY, 3, nX, nY);
  MapItemA := m_PEnvir.AddToMap(nX, nY, OS_ITEMOBJECT, TObject(MapItem));
  if MapItemA <> nil then begin
    if MapItemA <> MapItem then begin
      Dispose(MapItem);
      MapItem := MapItemA;
    end;
    SendRefMsg(RM_ITEMSHOW, MapItem.Looks, Integer(MapItem), nX, nY, MapItem.Name);
    if m_btRaceServer = RC_PLAYOBJECT then begin
      if boFalg then s20 := '15'
      else s20 := '7';
      if g_boGameLogGold then
        AddGameDataLog(s20 + #9 +
          m_sMapName + #9 +
          IntToStr(m_nCurrX) + #9 +
          IntToStr(m_nCurrY) + #9 +
          m_sCharName + #9 +
          sSTRING_GOLDNAME + #9 +
          IntToStr(nGold) + #9 +
          BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
          '0');
    end;
    Result := True;
  end else Dispose(MapItem);
end;
//检查行会关系,盟友或敌对

function TBaseObject.GetGuildRelation(cert1, cert2: TBaseObject): Integer;
begin
  Result := 0;
  m_boGuildWarArea := False;
  if (cert1.m_MyGuild = nil) or (cert2.m_MyGuild = nil) then Exit;
  if cert1.InSafeArea or (cert2.InSafeArea) then Exit; //由于此处,行会战杀英雄,主体提示谋杀 20081006
  if TGUild(cert1.m_MyGuild).GuildWarList.Count <= 0 then Exit;
  m_boGuildWarArea := True;
  if TGUild(cert1.m_MyGuild).IsWarGuild(TGUild(cert2.m_MyGuild)) and
    TGUild(cert2.m_MyGuild).IsWarGuild(TGUild(cert1.m_MyGuild)) then Result := 2; //敌对行会
  if cert1.m_MyGuild = cert2.m_MyGuild then Result := 1; //同个行会
  if TGUild(cert1.m_MyGuild).IsAllyGuild(TGUild(cert2.m_MyGuild)) and
    TGUild(cert2.m_MyGuild).IsAllyGuild(TGUild(cert1.m_MyGuild)) then Result := 3; //联盟行会
end;
//增加角色PK值 20080721

procedure TBaseObject.IncPkPoint(nPoint: Integer);
var
  nOldPKLevel: Integer;
begin
  if m_btRaceServer = RC_HEROOBJECT then begin //英雄
    if m_Master <> nil then begin
      nOldPKLevel := m_Master.PKLevel;
      Inc(m_Master.m_nPkPoint, nPoint);
      if m_Master.PKLevel <> nOldPKLevel then begin
        if m_Master.PKLevel <= 2 then m_Master.RefNameColor;
      end;
    end;
    THeroObject(self).m_nLoyal := _MAX(0, THeroObject(self).m_nLoyal - g_Config.nPKDecLoyal); //PK值增加减少忠诚度 20080214
  end else begin
    nOldPKLevel := PKLevel;
    Inc(m_nPkPoint, nPoint);
    if PKLevel <> nOldPKLevel then begin
      if PKLevel <= 2 then RefNameColor;
    end;
  end;
end;

procedure TBaseObject.AddBodyLuck(dLuck: Double);
var
  n: Integer;
begin
  if (dLuck > 0) and (m_dBodyLuck < 5 * BODYLUCKUNIT) then begin
    m_dBodyLuck := m_dBodyLuck + dLuck;
  end;
  if (dLuck < 0) and (m_dBodyLuck > -(5 * BODYLUCKUNIT)) then begin
    m_dBodyLuck := m_dBodyLuck + dLuck;
  end;
  n := Trunc(m_dBodyLuck / BODYLUCKUNIT);
  if n > 5 then n := 5;
  if n < -10 then n := -10;
  m_nBodyLuckLevel := n;
end;
//武器被诅咒

procedure TBaseObject.MakeWeaponUnlock;
begin
  if m_UseItems[U_WEAPON].wIndex <= 0 then Exit;
  if m_UseItems[U_WEAPON].btValue[3] > 0 then begin
    Dec(m_UseItems[U_WEAPON].btValue[3]);
    SysMsg(g_sTheWeaponIsCursed, c_Red, t_Hint);
  end else begin
    if m_UseItems[U_WEAPON].btValue[4] < 10 then begin
      Inc(m_UseItems[U_WEAPON].btValue[4]);
      SysMsg(g_sTheWeaponIsCursed, c_Red, t_Hint);
    end;
  end;
  if m_btRaceServer = RC_PLAYOBJECT then begin
    RecalcAbilitys();
    CompareSuitItem(False); //200080729 套装
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
    //修复喝了祝福油不更新属性By TasNat at: 2012-06-24 14:50:56
    TPlayObject(Self).SendUpdateItem(@m_UseItems[U_WEAPON]);
  end;
end;
//取攻击点数

function TBaseObject.GetAttackPower(nBasePower, nPower: Integer): Integer;
var
  PlayObject: TPlayObject;
  HeroObject: THeroObject;
begin
  if nPower < 0 then nPower := 0;
  Result := nBasePower + Random(nPower + 1);
  if m_nLuck > 0 then begin
    if Random(10 - _MIN(9, m_nLuck)) = 0 then
      Result := nBasePower + nPower //幸运9
  end else begin
    if m_nLuck < 0 then begin
      if Random(10 - _MAX(0, -m_nLuck)) = 0 then Result := nBasePower;
    end;
  end;
  case m_btRaceServer of
    RC_PLAYOBJECT: begin
        PlayObject := TPlayObject(Self);
        if (PlayObject.m_dwPowerRateTime <= 0) and (PlayObject.m_nPowerRate > 100) then
          PlayObject.m_nPowerRate := 100; //检查人物攻击力倍数是否正确
        Result := Round(Result * (PlayObject.m_nPowerRate / 100));
        if PlayObject.m_boPowerItem then Result := Round(m_rPowerItem * Result); //力量物品
      end;
    RC_HEROOBJECT: begin
        HeroObject := THeroObject(Self);
        if HeroObject.m_boPowerItem then Result := Round(m_rPowerItem * Result);
      end;
  end;

  if m_boAutoChangeColor then Result := Result * m_nAutoChangeIdx + 1;
  if m_boFixColor then Result := Result * m_nFixColorIdx + 1;
  if Result < 0 then Result := 0; //防止出现负值
end;


//减血, 可能怪物和玩家掉血就这里掉的。

procedure TBaseObject.DamageHealth(nDamage: Integer);
var
  nSpdam: Integer;
  nCode: Byte; //20090330
begin
  nCode := 0;
  try
    if m_LastHiter <> nil then begin
      nCode := 1;
      if (not m_LastHiter.m_boDeath) and (not m_LastHiter.m_boUnMagicShield) then begin //20090504 增加
        nCode := 2;
        if m_boMagicShield and (nDamage > 0) and (m_WAbil.MP > 0) then begin //护身戒指掉1.5倍的蓝
          nSpdam := Round(nDamage * 1.5);
          if Integer(m_WAbil.MP) >= nSpdam then begin
            m_WAbil.MP := m_WAbil.MP - nSpdam;
            nSpdam := 0;
          end else begin
            nSpdam := nSpdam - m_WAbil.MP;
            m_WAbil.MP := 0;
          end;
          nDamage := Round(nSpdam / 1.5);
        end;
        if m_boMagicShield1 and (nDamage > 0) and (m_WAbil.MP > 0) then begin //聚魔护身戒指掉50%蓝,50%红
          nSpdam := Round(nDamage * 0.5); //蓝
          nDamage := Round(nDamage * 0.5); //红
          if Integer(m_WAbil.MP) >= nSpdam then begin
            m_WAbil.MP := m_WAbil.MP - nSpdam;
            nSpdam := 0;
          end else begin
            nSpdam := nSpdam - m_WAbil.MP;
            m_WAbil.MP := 0;
          end;
          if nSpdam > 0 then begin
            nDamage := nDamage + Round(nSpdam * 0.67);
          end;
        end;
        if m_boMagicShield2 and (nDamage > 0) and (m_WAbil.MP > 0) then begin //新护身戒指掉1倍的蓝
          nSpdam := nDamage;
          if Integer(m_WAbil.MP) >= nSpdam then begin
            m_WAbil.MP := m_WAbil.MP - nSpdam;
            nSpdam := 0;
          end else begin
            nSpdam := nSpdam - m_WAbil.MP;
            m_WAbil.MP := 0;
          end;
          nDamage := nSpdam;
        end;
      end;
    end else begin
      nCode := 3;
      if m_boMagicShield and (nDamage > 0) and (m_WAbil.MP > 0) then begin
        nSpdam := Round(nDamage * 1.5);
        if Integer(m_WAbil.MP) >= nSpdam then begin
          m_WAbil.MP := m_WAbil.MP - nSpdam;
          nSpdam := 0;
        end else begin
          nSpdam := nSpdam - m_WAbil.MP;
          m_WAbil.MP := 0;
        end;
        nDamage := Round(nSpdam / 1.5);
      end;
      if m_boMagicShield1 and (nDamage > 0) and (m_WAbil.MP > 0) then begin //聚魔护身戒指掉50%蓝,50%红
        nSpdam := Round(nDamage * 0.5); //蓝
        nDamage := Round(nDamage * 0.5); //红
        if Integer(m_WAbil.MP) >= nSpdam then begin
          m_WAbil.MP := m_WAbil.MP - nSpdam;
          nSpdam := 0;
        end else begin
          nSpdam := nSpdam - m_WAbil.MP;
          m_WAbil.MP := 0;
        end;
        if nSpdam > 0 then begin
          nDamage := nDamage + Round(nSpdam * 0.67);
        end;
      end;
      if m_boMagicShield2 and (nDamage > 0) and (m_WAbil.MP > 0) then begin //新护身戒指掉1倍的蓝
        nSpdam := nDamage;
        if Integer(m_WAbil.MP) >= nSpdam then begin
          m_WAbil.MP := m_WAbil.MP - nSpdam;
          nSpdam := 0;
        end else begin
          nSpdam := nSpdam - m_WAbil.MP;
          m_WAbil.MP := 0;
        end;
        nDamage := nSpdam;
      end;
    end;
    nCode := 5;
    if nDamage > 0 then begin
      if (m_WAbil.HP - nDamage) > 0 then begin
        m_WAbil.HP := m_WAbil.HP - nDamage;
      end else begin
        m_WAbil.HP := 0;
      end;
    end else begin
      if (m_WAbil.HP - nDamage) < m_WAbil.MaxHP then begin
        m_WAbil.HP := m_WAbil.HP - nDamage;
      end else begin
        m_WAbil.HP := m_WAbil.MaxHP;
      end;
    end;
    HealthSpellChanged(); //20090430 增加
  except
    MainOutMessage(Format('{%s} TBaseObject.DamageHealth Code:%d.%p', [g_sExceptionVer, nCode, ExceptAddr]));
  end;
end;

function TBaseObject.GetBackDir(nDir: Integer): Integer;
begin
  Result := 0;
  case nDir of
    DR_UP: Result := DR_DOWN;
    DR_DOWN: Result := DR_UP;
    DR_LEFT: Result := DR_RIGHT;
    DR_RIGHT: Result := DR_LEFT;
    DR_UPLEFT: Result := DR_DOWNRIGHT;
    DR_UPRIGHT: Result := DR_DOWNLEFT;
    DR_DOWNLEFT: Result := DR_UPRIGHT;
    DR_DOWNRIGHT: Result := DR_UPLEFT;
  end;
end;

//m_nHolyCurtainLockX
function TBaseObject.InMag113LockRect(nAX,nAY : Integer) : Boolean;
var
  nCX,nCY,I: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  Event: TEvent;
  LockRect : TRect;
begin
  Result := m_PEnvir <> nil;
  if Result then begin
  Result := False;
  LockRect.Left := -1;
  for nCX := nAX - 3 to nAX + 3 do begin
    for nCY := nAY - 3 to nAY + 3 do begin
      if m_PEnvir.GetMapCellInfo(nCX, nCY, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
        if MapCellInfo.ObjList.Count > 0 then begin //20080629
          for I := 0 to MapCellInfo.ObjList.Count - 1 do begin
            OSObject := pTOSObject(MapCellInfo.ObjList.Items[I]);
            if (OSObject <> nil) and (not OSObject.boObjectDisPose) and (OSObject.CellObj <> nil) and (OSObject.btType = OS_EVENTOBJECT) and (TEvent(OSObject.CellObj).m_nEventType = ET_NOTGOTO) then begin
                Event := TEvent(OSObject.CellObj);
                if (Event.m_OwnBaseObject <> nil) and (Event.m_OwnBaseObject.m_nCharStatus and $00008000 <> 0) then begin
                  with Event.m_OwnBaseObject do
                    LockRect := Rect(m_nHolyCurtainLockX - 3, m_nHolyCurtainLockY - 3, m_nHolyCurtainLockX + 3, m_nHolyCurtainLockY + 3);
                  Result := PtInRect(LockRect,Point(nAX, nAY));
                  Exit;
                end;
              end;
          end; //for
        end;
      end;
    end;
  end;

  end;
end;

//被冲撞
function TBaseObject.CharPushed(nDir, nPushCount: Integer): Integer;
var
  I, nX, nY, olddir, nBackDir: Integer;
  nOldCharStatus : Integer;
begin
  Result := 0;


  if nPushCount > 0 then begin
  olddir := m_btDirection;
  m_btDirection := nDir;
  nBackDir := GetBackDir(nDir);
{$IF M2Version <> 2}
  if InMag113LockRect(m_nCurrX, m_nCurrY) then Exit;//在被天雷乱舞锁定范围 则不考虑 By TasNat at: 2012-03-08 11:53:11

  if (m_btRaceServer = RC_PLAYOBJECT) and (nPushCount > 0) then        
  with TPlayObject(Self) do //修复被野蛮状态不改变 By TasNat at: 2012-03-08 11:09:19        
  begin        
    nOldCharStatus := m_nCharStatus;
    if m_SkillHit_113 > 0 then begin
      m_SkillHit_113 := 0;
      m_SkillHit_X := 0;
      m_SkillHit_Y := 0;
    end;
    m_nCharStatus := GetCharStatus();
    if nOldCharStatus <> m_nCharStatus then        
      StatusChanged('');        
  end;
{$IFEND}
    for I := 0 to nPushCount - 1 do begin
      GetFrontPosition(nX, nY);
      if m_PEnvir.CanWalk(nX, nY, False) then begin
        if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nX, nY, False) > 0 then begin
          m_nCurrX := nX;
          m_nCurrY := nY;
          SendRefMsg(RM_PUSH, nBackDir, m_nCurrX, m_nCurrY, 0, '');
          Inc(Result);
          if m_btRaceServer >= RC_ANIMAL then m_dwWalkTick := m_dwWalkTick + 800;
        end else Break;
      end else Break;
    end; //for
  end;
  m_btDirection := nBackDir;
  if Result = 0 then m_btDirection := olddir;
end;

function TBaseObject.MagPassThroughMagic(sX, sY, tx, ty, nDir, magpwr, nSccPwr: Integer; undeadattack: Boolean; nCode: Byte): Integer;
var
  I, tCount, acpwr, nPwr: Integer;
  BaseObject: TBaseObject;
begin
  tCount := 0;
  for I := 0 to 12 do begin
    BaseObject := TBaseObject(m_PEnvir.GetMovingObject(sX, sY, True));
    if BaseObject <> nil then begin
      if IsProperTarget(BaseObject) then begin
        if Random(10) >= BaseObject.m_nAntiMagic then begin
          if undeadattack then acpwr := Round(magpwr * 1.5)
          else acpwr := magpwr;
          if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then
            TPlayObject(BaseObject).CmdUserCmd('@MagTagFunc'+inttostr(nCode));//人物技能触发 By TasNat at: 2012-07-21 15:13:25
{$IF M2Version <> 2}
          case nCode of
            SKILL_FIRE: begin //地狱火
                if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then begin //20090304修改
                  nPwr := 0;
                  if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
                    nPwr := MagicManager.GetNGPow(BaseObject, TPlayObject(BaseObject).m_MagicSkill_215, nSccPwr); //静之地狱火
                  end else
                    if BaseObject.m_btRaceServer = RC_HEROOBJECT then begin
                      nPwr := MagicManager.GetNGPow(BaseObject, THEROOBJECT(BaseObject).m_MagicSkill_215, nSccPwr); //静之地狱火
                    end;
                  acpwr := _MAX(0, acpwr - nPwr);
                end;
              end;
            SKILL_SHOOTLIGHTEN: begin //疾光电影
                if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then begin //20090304修改
                  nPwr := 0;
                  if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
                    nPwr := MagicManager.GetNGPow(BaseObject, TPlayObject(BaseObject).m_MagicSkill_217, nSccPwr); //静之疾光电影
                  end else
                    if BaseObject.m_btRaceServer = RC_HEROOBJECT then begin
                      nPwr := MagicManager.GetNGPow(BaseObject, THEROOBJECT(BaseObject).m_MagicSkill_217, nSccPwr); //静之疾光电影
                    end;
                  acpwr := _MAX(0, acpwr - nPwr);
                end;
              end;
          end;
{$IFEND}
          BaseObject.SendDelayMsg(Self, RM_MAGSTRUCK, 0, acpwr, 0, 0, '', 600);
          Inc(tCount);
        end;
      end;
    end;
    if not ((abs(sX - tx) <= 0) and (abs(sY - ty) <= 0)) then begin
      nDir := GetNextDirection(sX, sY, tx, ty);
      if not m_PEnvir.GetNextPosition(sX, sY, nDir, 1, sX, sY) then Break;
    end else Break;
  end;
  Result := tCount;
end;

procedure TPlayObject.SendSocket(DefMsg: pTDefaultMessage; sMsg: string);
var
  MsgHdr: TMsgHeader;
  nSendBytes: Integer;
  tBuff: PChar;
  nCode: Byte; //20091124 增加
resourcestring
  sExceptionMsg = '{%s} TPlayObject::SendSocket..%d. %p';
begin
  nCode := 0;
  if m_boAI then Exit;                                                      
  if m_boNotOnlineAddExp and (GetTickCount - m_dwAutoAddExpPointTimeTick > 30 * 1000) then Exit; //如果挂机超过30秒后不在发送数据到客户端 20100131
  tBuff := nil;
  try
    MsgHdr.dwCode := RUNGATECODE;
    nCode := 1;
    MsgHdr.nSocket := m_nSocket;
    MsgHdr.wGSocketIdx := m_nGSocketIdx;
    MsgHdr.wIdent := GM_DATA;
    nCode := 2;
    if DefMsg <> nil then begin
      if sMsg <> '' then begin
        nCode := 3;
        MsgHdr.nLength := Length(sMsg) + SizeOf(TDefaultMessage) + 1;
        nCode := 21;
        nSendBytes := MsgHdr.nLength + SizeOf(TMsgHeader);
        nCode := 4;
        GetMem(tBuff, nSendBytes + SizeOf(Integer));
        nCode := 5;
        Move(nSendBytes, tBuff^, SizeOf(Integer));
        nCode := 6;
        Move(MsgHdr, tBuff[SizeOf(Integer)], SizeOf(TMsgHeader));
        nCode := 7;
        Move(DefMsg^, tBuff[SizeOf(TMsgHeader) + SizeOf(Integer)], SizeOf(TDefaultMessage));
        nCode := 8;
        Move(sMsg[1], tBuff[SizeOf(TDefaultMessage) + SizeOf(TMsgHeader) + SizeOf(Integer)], Length(sMsg) + 1);
      end else begin
        nCode := 9;
        MsgHdr.nLength := SizeOf(TDefaultMessage);
        nCode := 19;
        nSendBytes := MsgHdr.nLength + SizeOf(TMsgHeader);
        nCode := 20;
        GetMem(tBuff, nSendBytes + SizeOf(Integer));
        nCode := 10;
        Move(nSendBytes, tBuff^, SizeOf(Integer));
        nCode := 11;
        Move(MsgHdr, tBuff[SizeOf(Integer)], SizeOf(TMsgHeader));
        nCode := 12;
        Move(DefMsg^, tBuff[SizeOf(TMsgHeader) + SizeOf(Integer)], SizeOf(TDefaultMessage));
      end;
    end else begin
      if sMsg <> '' then begin
        nCode := 13;
        MsgHdr.nLength := -(Length(sMsg) + 1);
        nSendBytes := abs(MsgHdr.nLength) + SizeOf(TMsgHeader);
        GetMem(tBuff, nSendBytes + SizeOf(Integer));
        nCode := 14;
        Move(nSendBytes, tBuff^, SizeOf(Integer));
        nCode := 15;
        Move(MsgHdr, tBuff[SizeOf(Integer)], SizeOf(TMsgHeader));
        nCode := 16;
        Move(sMsg[1], tBuff[SizeOf(TMsgHeader) + SizeOf(Integer)], Length(sMsg) + 1);
      end;
    end;
    nCode := 17;
    if not RunSocket.AddGateBuffer(m_nGateIdx, tBuff) then begin
      nCode := 18;
      FreeMem(tBuff);
{$IF TESTMODE = 1}
      MainOutMessage('消息发送失败');
{$IFEND}
    end;
  except
    MainOutMessage(Format(sExceptionMsg, [g_sExceptionVer, nCode, ExceptAddr]));
  end;
end;
//只能发一个intger类型参数

procedure TPlayObject.SendDefMessage(wIdent: Word; nRecog: Integer; nParam, nTag, nSeries: Word; sMsg: string);
begin
  if m_boAI then Exit;
  m_DefMsg := MakeDefaultMsg(wIdent, nRecog, nParam, nTag, nSeries, 0);
  if sMsg <> '' then SendSocket(@m_DefMsg, EncodeString(sMsg))
  else SendSocket(@m_DefMsg, '');
end;

//只能发两个intger类型参数

procedure TPlayObject.SendDefMessage1(wIdent: Word; nRecog: Integer; nParam, nTag, nSeries: Word; wSessionID: Integer; sMsg: string);
begin
  if m_boAI then Exit;
  m_DefMsg := MakeDefaultMsg(wIdent, nRecog, nParam, nTag, nSeries, wSessionID);
  if sMsg <> '' then SendSocket(@m_DefMsg, EncodeString(sMsg))
  else SendSocket(@m_DefMsg, '');
end;

procedure TPlayObject.ClientQueryUserName(Target: TBaseObject; x, y: Integer);
var
  uname: string;
  TagColor: Integer;
  Def: TDefaultMessage;
begin
  if Target <> nil then begin //20091027 增加
    if CretInNearXY(Target, x, y) then begin
      TagColor := GetCharColor(Target);
      Def := MakeDefaultMsg(SM_USERNAME, Integer(Target), TagColor, 0, 0, 0);
      uname := Target.GetShowName;
      SendSocket(@Def, EncodeString(uname));
    end else SendDefMessage(SM_GHOST, Integer(Target), x, y, 0, '');
  end;
end;

//是否使用斗笠 20080424

function TBaseObject.IsUsesZhuLi: Boolean;
var
  StdItem: pTStdItem;
begin
  Result := False;
  try
    if m_boGhost then Exit; //20091021 清理人物则退出
    if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then begin
      if m_UseItems[U_ZHULI].wIndex > 0 then begin
        StdItem := UserEngine.GetStdItem(m_UseItems[U_ZHULI].wIndex);
        if (StdItem <> nil) then begin
          if (StdItem.StdMode = 16) and ((StdItem.Shape = 0) or (StdItem.Shape = 1)) then Result := True; //是斗笠才显示神秘人，黑巾不显示 20090331
        end;
      end;
    end;
  except
  end;
end;

//显示名字 20080330 (包括所以NPC,怪,人物)

function TBaseObject.GetShowName: string;
var
  sShowName, sTemp: string;
  n10: Integer;
  nCode: Byte;
begin
  nCode := 0;
  try
    if m_boGhost then Exit; //清理人物则退出
    if g_Config.boUnKnowHum and IsUsesZhuLi then begin
      Result := '神秘人'; //带上斗笠即显示神秘人
    end else begin
      sShowName := m_sCharName;
      nCode := 1;
      if (m_btRaceServer = RC_NPC) then begin //只检查NPC 20081223
        n10 := GetValNameNo(sShowName); //20080406 支持NPC变量显示 A T S 变量
        nCode := 11;
        if (n10 >= 0) then begin
          case n10 of
            600..699: begin
                nCode := 12;
                {//非法内存访问 By TasNat at: 2012-04-29 13:28:13
                sTemp := TPlayObject(self).m_sString[n10 - 600];
                if (Length(sTemp) > 1) and (sTemp[1] = '<') and (sTemp[2] = '$') then sTemp := copy(sTemp, pos('\', sTemp), length(sTemp)); //20080421
                if sTemp = '' then
                sTemp := TMerchant(self).m_sScript; //20080421
                TMerchant(self).m_boRefreshName := True; }//刷新NPC名字(使用全局变量命名时) 20101224
              end;
            700..799: begin
                nCode := 13;
                sTemp := g_Config.GlobalAVal[n10 - 700];
                if (Length(sTemp) > 1) and (sTemp[1] = '<') and (sTemp[2] = '$') then sTemp := copy(sTemp, pos('\', sTemp), length(sTemp)); //20080421
                if sTemp = '' then begin
                  if pos('_', TMerchant(self).m_sScript) > 0 then begin //20080509 处理名字为 "比奇/比奇村_第一男战士",客户端只显示"比奇"
                    sTemp := copy(TMerchant(self).m_sScript, pos('_', TMerchant(self).m_sScript) + 1, length(TMerchant(self).m_sScript));
                  end else begin
                    sTemp := TMerchant(self).m_sScript; //20080421
                    sTemp := copy(sTemp, pos('/', sTemp) + 1, length(sTemp)); //20100628 增加，修正：当变量值为空时，"盟重省/天下第一男战"，客户端只显示"盟重省"，且颜色黑色
                  end;
                end;
                TMerchant(self).m_boRefreshName := True; //刷新NPC名字(使用全局变量命名时) 20101224
              end;
            1200..2099: begin //A变量(100-999)
                nCode := 14;
                sTemp := g_Config.GlobalAVal[n10 - 1100];
                if (Length(sTemp) > 1) and (sTemp[1] = '<') and (sTemp[2] = '$') then sTemp := copy(sTemp, pos('\', sTemp), length(sTemp)); //20080421
                if sTemp = '' then begin
                  if pos('_', TMerchant(self).m_sScript) > 0 then begin //处理名字为 "比奇/比奇村_第一男战士",客户端只显示"比奇"
                    sTemp := copy(TMerchant(self).m_sScript, pos('_', TMerchant(self).m_sScript) + 1, length(TMerchant(self).m_sScript));
                  end else begin
                    sTemp := TMerchant(self).m_sScript;
                    sTemp := copy(sTemp, pos('/', sTemp) + 1, length(sTemp)); //20100628 增加，修正：当变量值为空时，"盟重省/天下第一男战"，客户端只显示"盟重省"，且颜色黑色
                  end;
                end;
                TMerchant(self).m_boRefreshName := True; //刷新NPC名字(使用全局变量命名时) 20101224
              end;
          end;
        end;
      end;
      nCode := 15;

      if sTemp <> '' then begin
        Result := sTemp;
      end else Result := FilterShowName(sShowName); //过滤有数字的名称
      nCode := 2;
      case m_nCopyHumanLevel of
        0..1: begin
            if m_btRaceServer <> 158 then begin
              if (m_Master <> nil) then begin
                if (not m_Master.m_boObMode) and (not m_Master.m_boGhost) then begin //非隐身模式
                  if g_Config.boUnKnowHum and (m_Master.IsUsesZhuLi) then Result := Result + '(神秘人)' //主人为神秘人时，宝宝也要显示神秘人
                  else Result := Result + '(' + m_Master.m_sCharName + ')';
                end;
              end;
            end else Result := TPetsMon(self).m_sMasterName + '\' + Result; //宠物显名 20110713
          end; //0..1
        2: begin
            if (m_Master <> nil) then begin
              nCode := 31;
              if (not m_Master.m_boObMode) and (not m_Master.m_boGhost) then begin
                if g_Config.boAddMasterName then begin //使用主人名称做前缀
                  if (m_Master <> nil) then begin
                    if g_Config.boUnKnowHum and (m_Master.IsUsesZhuLi) then
                      Result := '(神秘人)' + g_Config.sCopyHumName
                    else begin
                      if (m_Master.m_btRaceServer = RC_HEROOBJECT) then Result := THeroObject(m_Master).GetShowName //20090323 英雄分身与英雄一样
                      else Result := m_Master.m_sCharName + g_Config.sCopyHumName;
                    end;
{$IF M2Version <> 2}
                    if (m_btRaceServer = RC_PLAYMOSTER) then begin
                      if (m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
                        if (not TPlayObject(m_Master).m_boShowFengHao) and (TPlayObject(m_Master).m_boUseTitle) then Result := Result + '|' + TPlayObject(m_Master).m_sUseIitleName;
                      end;
                    end;
{$IFEND}
                  end;
                end else begin
                  nCode := 4;
                  Result := g_Config.sCopyHumName;
                //人物分身名称支持显示跟人物一样,可以显示行会名 20080421
                  if (m_btRaceServer = RC_PLAYMOSTER) then begin
                    if (m_Master <> nil) then begin
                      case m_Master.m_btRaceServer of
                        RC_PLAYOBJECT: Result := TPlayObject(m_Master).GetShowName;
                        RC_HEROOBJECT: Result := THeroObject(m_Master).GetShowName;
                      end;
                    end;
                  end;
                end;
              end;
            end;
          end; //2
      end; //case
    end;
  except
    MainOutMessage(Format('{%s} TBaseObject.GetShowName Code:%d.%p', [g_sExceptionVer, nCode, ExceptAddr]));
  end;
end;

procedure TAnimalObject.Attack(TargeTBaseObject: TBaseObject; nDir: Integer);
begin
  inherited AttackDir(TargeTBaseObject, 0, nDir, 0);
end;

constructor TAnimalObject.Create;
begin
  inherited;
  m_nTargetX := -1;
  dwTick3F4 := GetTickCount();
  m_btRaceServer := RC_ANIMAL;
  m_dwHitTick := GetTickCount - LongWord(Random(3000));
  m_dwWalkTick := GetTickCount - LongWord(Random(3000));
  m_dwSearchEnemyTick := GetTickCount();
  m_boRunAwayMode := False;
  m_dwRunAwayStart := GetTickCount();
  m_dwRunAwayTime := 0;
  m_nCopyHumanLevel := 0;
end;

procedure TAnimalObject.GotoTargetXY;
var
  I: Integer;
  nDir: Integer;
  n10: Integer;
  n14: Integer;
  n20: Integer;
  nOldX: Integer;
  nOldY: Integer;
begin
  if ((m_nCurrX <> m_nTargetX) or (m_nCurrY <> m_nTargetY)) then begin
    n10 := m_nTargetX;
    n14 := m_nTargetY;
    dwTick3F4 := GetTickCount();
    nDir := DR_DOWN;
    if n10 > m_nCurrX then begin
      nDir := DR_RIGHT;
      if n14 > m_nCurrY then nDir := DR_DOWNRIGHT;
      if n14 < m_nCurrY then nDir := DR_UPRIGHT;
    end else begin
      if n10 < m_nCurrX then begin
        nDir := DR_LEFT;
        if n14 > m_nCurrY then nDir := DR_DOWNLEFT;
        if n14 < m_nCurrY then nDir := DR_UPLEFT;
      end else begin
        if n14 > m_nCurrY then nDir := DR_DOWN
        else if n14 < m_nCurrY then nDir := DR_UP;
      end;
    end;
    nOldX := m_nCurrX;
    nOldY := m_nCurrY;
    WalkTo(nDir, False);
    n20 := Random(3);
    for I := DR_UP to DR_UPLEFT do begin
      if (nOldX = m_nCurrX) and (nOldY = m_nCurrY) then begin
        if n20 <> 0 then Inc(nDir)
        else if nDir > 0 then Dec(nDir)
        else nDir := DR_UPLEFT;
        if (nDir > DR_UPLEFT) then nDir := DR_UP;
        WalkTo(nDir, False);
      end;
    end;
  end;
end;

function TAnimalObject.Operate(ProcessMsg: pTProcessMessage): Boolean;
var nCode: Byte; //20090115
begin
  nCode := 0;
  Result := False; //20090810 增加
  try
    if ProcessMsg.wIdent = RM_STRUCK then begin
      nCode := 1;
      if (ProcessMsg.BaseObject = Self) and (TBaseObject(ProcessMsg.nParam3 {AttackBaseObject}) <> nil) then begin
        nCode := 2;
        SetLastHiter(TBaseObject(ProcessMsg.nParam3 {AttackBaseObject}));
        if (not TBaseObject(ProcessMsg.nParam3).m_boDeath) then begin //20090504 增加
          nCode := 3;
          Struck(TBaseObject(ProcessMsg.nParam3 {AttackBaseObject}));
          nCode := 4;
          BreakHolySeizeMode();
          nCode := 10;
          if (m_Master <> nil) and (TBaseObject(ProcessMsg.nParam3) <> nil) then begin
            nCode := 12;
            if (not TBaseObject(ProcessMsg.nParam3).m_boDeath) then begin //20090116 增加 m_boDeath
              nCode := 9;
              if (TBaseObject(ProcessMsg.nParam3) <> m_Master) and
                ((TBaseObject(ProcessMsg.nParam3).m_btRaceServer = RC_PLAYOBJECT) or
                (TBaseObject(ProcessMsg.nParam3).m_btRaceServer = RC_HEROOBJECT)) then begin //英雄灰名 20080721
                nCode := 6;
                if m_Master.m_Master <> nil then begin //20080823 增加
                  nCode := 7;
                  if m_Master.m_Master <> TBaseObject(ProcessMsg.nParam3) then m_Master.SetPKFlag(TBaseObject(ProcessMsg.nParam3));
                end else m_Master.SetPKFlag(TBaseObject(ProcessMsg.nParam3));
              end;
            end;
          end;
          nCode := 8;
          if g_Config.boMonSayMsg then MonsterSayMsg(TBaseObject(ProcessMsg.nParam3), s_UnderFire);
        end;
      end;
      Result := True;
    end else begin
      Result := inherited Operate(ProcessMsg);
    end;
  except
    MainOutMessage(Format('{%s} TAnimalObject.Operate Code:%d.%p', [g_sExceptionVer, nCode, ExceptAddr]));
  end;
end;

procedure TAnimalObject.Run;
begin
  inherited;
end;
//被击中

procedure TAnimalObject.Struck(hiter: TBaseObject);
var
  btDir: Byte;
begin
  m_dwStruckTick := GetTickCount;
  if hiter <> nil then begin
    if (m_TargetCret = nil) or GetAttackDir(m_TargetCret, btDir) or (Random(6) = 0) then begin
      if IsProperTarget(hiter) then SetTargetCreat(hiter);
    end;
  end;
  if m_boAnimal then begin //是动物
    m_nMeatQuality := m_nMeatQuality - Random(300);
    if m_nMeatQuality < 0 then m_nMeatQuality := 0;
  end;
  //if m_Abil.Level < 50 then
  m_dwHitTick := m_dwHitTick + LongWord(150 - _MIN(130, m_Abil.Level * 4));
  //WalkTime := WalkTime + (300 - _MIN(200, (Abil.Level div 5) * 20));
end;

//刷新属性 重新计算各个人物的属性值，包括怪物吗

procedure TBaseObject.RecalcAbilitys;
var
  Abil: TAbility;
  boOldHideMode: Boolean;
  nOldLight: Integer;
  I, ShangHaiValue, XiXueValue, BingDongKangXing: Integer;
  ShangHaiValue1,ShangHaiValue2 : Integer;
  StdItem: pTStdItem;
  StdItem2: pTStdItem;
  boRecallSuite1, boRecallSuite2, boRecallSuite3, boRecallSuite4: Boolean;
  boXieLangSuite1, boXieLangSuite2, boXieLangSuite3: Boolean;
  boMoXieSuite1, boMoXieSuite2, boMoXieSuite3: Boolean;
  boHongMoSuite1, boHongMoSuite2, boHongMoSuite3: Boolean;
  boSpirit1, boSpirit2, boSpirit3, boSpirit4: Boolean;
  n01, n02, n03, n04: Integer;
  nCode: Byte;
  nIncMaxHP: Word;
{$IF M2Version <> 2}
  AddUnKnowAbility: TAddUnKnowAbility;
  FengHaoAbility: TFengHaoAbility;
{$IFEND}
begin
  nCode := 0;
  try
    FillChar(m_AddAbil, SizeOf(TAddAbility), #0);
{$IF M2Version <> 2}
    FillChar(AddUnKnowAbility, SizeOf(TAddUnKnowAbility), #0);
    FillChar(FengHaoAbility, SizeOf(TFengHaoAbility), #0);
{$IFEND}
    nIncMaxHP := 0;
    m_TrueSC := 0; //无极真气不考虑套装效果
    Abil := m_WAbil;
    if m_PEnvir <> nil then begin
      if m_PEnvir.boLimitLevel then begin
        case m_btRaceServer of
          RC_PLAYOBJECT: if m_Abil.Level > m_PEnvir.nLimitLevel1 then RecalcLevelAbilitysEx(m_PEnvir.nLimitLevel2); //按设置等级计算属性 20110921
          RC_HEROOBJECT: if m_Abil.Level > m_PEnvir.nLimitLevelHero then RecalcLevelAbilitysEx(m_PEnvir.nLimitLevelHero1);
        end;
      end;
    end;
    m_WAbil := m_Abil;
    m_WAbil.HP := Abil.HP;
    m_WAbil.MP := Abil.MP;
{$IF M2Version = 1}
    m_WAbil.TransferValue := Abil.TransferValue;
{$IFEND}
    m_WAbil.Weight := 0;
    m_WAbil.WearWeight := 0;
    m_WAbil.HandWeight := 0;
    case m_btRaceServer of //20091104 修改
      RC_PLAYOBJECT: begin
          TPlayObject(self).m_nIncDragonRate := 0; //合击伤害(增加) 20090330
          TPlayObject(self).m_nIncDragon := 0; //增加合击威力点数
{$IF M2Version <> 2}
          TPlayObject(self).m_boArmsCritPoint := 0; //武器暴击等级 20100709
          TPlayObject(self).m_nIncNHRecover := 0; //内力恢复(增加) 20090330
          TPlayObject(self).m_nIncNHPoint := 0; //内力恢复速度(点数) 20090712
          TPlayObject(self).GetFengHaoAbility(FengHaoAbility); //取称号所带的属性
{$IFEND}
        end;
      RC_HEROOBJECT: begin
          THeroObject(self).m_nIncDragonRate := 0; //合击伤害(增加) 20090330
          THeroObject(self).m_nIncDragon := 0; //增加合击威力点数
{$IF M2Version <> 2}
          THeroObject(self).m_boArmsCritPoint := 0; //武器暴击等级 20100709
          THeroObject(self).m_nIncNHRecover := 0; //内力恢复(增加) 20090330
          THeroObject(self).m_nIncNHPoint := 0; //内力恢复速度(点数) 20090712
{$IFEND}
        end;
    end;
    m_btAntiPoison := 0;
    m_nPoisonRecover := 0;
    m_nHealthRecover := 0;
    m_nSpellRecover := 0;
    
    m_nAntiMagic := 1;
    m_nLuck := 0;
    m_nBurstRate := 0; //爆率(击杀对手时，对方爆物品机率) 20091129
    m_nUnBurstRate := 0; //防爆点数
{$IF M2Version <> 2}
    m_nDecTargetNHPoint := 0; //目标内力值减少点数(内伤装备) 20100513
{$IFEND}
    m_nUnParalysisRate := 0; //防麻机率(辉煌衣服) 20100513
    m_nParalysisAddRate := 0;
    m_nVampirePoint := 0; //20100312
    m_nVampireRate := 0; //20100312
    m_nHitSpeed := 0;
    m_nRunSpeed := 0; //移动速度
    m_boExpItem := False;
    m_rExpItem := 0;
    m_boPowerItem := False;
    m_rPowerItem := 0;
    boOldHideMode := m_boHideMode;
    m_boHideMode := False;
    m_boTeleport := False; //传送
    m_boParalysis := False; //麻痹
    m_boParalysis1 := False; //新麻痹戒指 时间2秒
    m_boParalysis2 := False; //魔道麻痹戒指 20091009
    m_boParalysis3 := False; //魔意麻痹戒指
    m_boRevival := False; //复活
    m_boUnRevival := False;
    m_boRebirth := False; //重生戒指
    m_boUnPosion := False; //防毒
    m_boHeavenSKill := False; //倚天剑(增加技能)
    m_boDragonSkill := False; //神龙附体
    m_boCallTrollSkill := False; //召唤巨魔
    m_boFlameRing := False;
    m_boRecoveryRing := False;
    m_boMeteorRing := False; //流星火雨戒指 20090918
    m_boAngryRing := False;
    m_boMagicShield := False; //护身
    m_boMagicShield1 := False; //聚魔护身戒指
    m_boMagicShield2 := False; //新护身戒指，伤害按1倍转移到魔法值的消耗上
    m_boUnMagicShield := False;
    m_boMuscleRing := False;
    m_boFastTrain := False;
    m_boProbeNecklace := False;
    m_boSupermanItem := False;
    m_boGuildMove := False;
    m_boUnParalysis := False; //防麻痹
    m_boExpItem := False;
    m_boPowerItem := False;
    m_boNoDropItem := False;
    m_boNoDropUseItem := False;
    m_bopirit := False;
    m_btHorseType := 0;
    m_btDressEffType := 0;

    m_nXieLangSutie := 0; //魔血2一套(增加HP上限)
    boXieLangSuite1 := False;
    boXieLangSuite2 := False;
    boXieLangSuite3 := False;
    m_nMoXieSuite := 0;
    boMoXieSuite1 := False;
    boMoXieSuite2 := False;
    boMoXieSuite3 := False;
    m_db3B0 := 0;
    m_nHongMoSuite := 0;
    boHongMoSuite1 := False;
    boHongMoSuite2 := False;
    boHongMoSuite3 := False;

    boSpirit1 := False;
    boSpirit2 := False;
    boSpirit3 := False;
    boSpirit4 := False;

    m_boRecallSuite := False;
    boRecallSuite1 := False;
    boRecallSuite2 := False;
    boRecallSuite3 := False;
    boRecallSuite4 := False;

    m_dwPKDieLostExp := 0;
    m_nPKDieLostLevel := 0;
    nCode := 1;
    try
    if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin //20101025 增加,只有人,英雄,人形才检查装备
{$Region '身上装备'}
      for I := Low(THumanUseItems) to High(THumanUseItems) do begin //9格装备+4格装备
        if (m_UseItems[I].wIndex <= 0) or (m_UseItems[I].Dura <= 0) then Continue;
        StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
        if StdItem = nil then Continue;
        GetAccessory(m_UseItems[I], StdItem, m_AddAbil); //取物品的附加属性 20101025 修改
{$IF M2Version <> 2}
        if g_Config.boUseCanKamPo then GetAddUnKnowAbility(m_UseItems[I], AddUnKnowAbility); //取鉴定的属性 20100825
{$IFEND}
        if (I = U_WEAPON) or (I = U_RIGHTHAND) or (I = U_DRESS) then begin
          if I = U_DRESS then begin
            m_WAbil.WearWeight := _MIN(High(Word), m_WAbil.WearWeight + StdItem.Weight);
          end else begin
            Inc(m_WAbil.HandWeight, StdItem.Weight);
          end;
          case StdItem.AniCount of //20091104 修改
            111: begin
                m_wStatusTimeArr[STATE_TRANSPARENT] := MaxWord {6 * 10 * 1000};
                m_boHideMode := True;
                m_boTransparent := False; //20090907 修正，先魔法隐身后，再带隐身装备，跑动隐身消失BUG
              end;
            112: m_boTeleport := True;
            113: begin
                if m_btRaceServer = RC_PLAYMOSTER then begin
                  if m_Master = nil then m_boParalysis := True;
                end else m_boParalysis := True;
              end;
            114: m_boRevival := True;
            115: m_boFlameRing := True;
            116: m_boRecoveryRing := True;
            117: m_boAngryRing := True;
            118: m_boMagicShield := True;
            119: m_boMuscleRing := True;
            120: m_boFastTrain := True;
            121: m_boProbeNecklace := True;
            135: begin
                boMoXieSuite1 := True;
                Inc(m_nMoXieSuite, StdItem.Weight div 10);
              end;
            138: Inc(m_nHongMoSuite, StdItem.Weight);
            139: m_boUnParalysis := True; //防麻
            140: m_boSupermanItem := True;
            141: begin
                m_boExpItem := True;
                m_rExpItem := m_rExpItem + (m_UseItems[I].Dura / g_Config.nItemExpRate);
              end;
            142: begin
                m_boPowerItem := True;
                m_rPowerItem := m_rPowerItem + (m_UseItems[I].Dura / g_Config.nItemPowerRate);
              end;
            143: m_boUnMagicShield := True;
            144: m_boUnRevival := True;
            145: m_boGuildMove := True;
            150: begin //麻痹护身
                if m_btRaceServer = RC_PLAYMOSTER then begin
                  if m_Master = nil then m_boParalysis := True;
                end else m_boParalysis := True;
                m_boMagicShield := True;
              end;
            151: begin //麻痹火球
                if m_btRaceServer = RC_PLAYMOSTER then begin
                  if m_Master = nil then m_boParalysis := True;
                end else m_boParalysis := True;
                m_boFlameRing := True;
              end;
            152: begin //麻痹防御
                if m_btRaceServer = RC_PLAYMOSTER then begin
                  if m_Master = nil then m_boParalysis := True;
                end else m_boParalysis := True;
                m_boRecoveryRing := True;
              end;
            153: begin //麻痹负载
                if m_btRaceServer = RC_PLAYMOSTER then begin
                  if m_Master = nil then m_boParalysis := True;
                end else m_boParalysis := True;
                m_boMuscleRing := True;
              end;
            154: begin //护身火球
                m_boMagicShield := True;
                m_boFlameRing := True;
              end;
            155: begin //护身防御
                m_boMagicShield := True;
                m_boRecoveryRing := True;
              end;
            156: begin //护身负载
                m_boMagicShield := True;
                m_boMuscleRing := True;
              end;
            157: begin //传送麻痹
                m_boTeleport := True;
                if m_btRaceServer = RC_PLAYMOSTER then begin
                  if m_Master = nil then m_boParalysis := True;
                end else m_boParalysis := True;
              end;
            158: begin //传送护身
                m_boTeleport := True;
                m_boMagicShield := True;
              end;
            159: begin //传送探测
                m_boTeleport := True;
                m_boProbeNecklace := True;
              end;
            160: begin //传送复活
                m_boTeleport := True;
                m_boRevival := True;
              end;
            161: begin //麻痹复活
                if m_btRaceServer = RC_PLAYMOSTER then begin
                  if m_Master = nil then m_boParalysis := True;
                end else m_boParalysis := True;
                m_boRevival := True;
              end;
            162: begin //护身复活
                m_boMagicShield := True;
                m_boRevival := True;
              end;
            163: begin //防麻+记忆 20090808
                m_boUnParalysis := True; //防麻
                m_boRecallSuite := True; //记忆
              end;
            164: begin //防毒+记忆 20090808
                m_boRecallSuite := True; //记忆
                m_boUnPosion := True; //防毒
              end;
            165: begin //防护身+复活 20090808
                m_boUnMagicShield := True; //防护身
                m_boRevival := True; //复活
              end;
            166: begin //防麻+防复活 20090808
                m_boUnParalysis := True; //防麻痹
                m_boUnRevival := True; //防复活
              end;
            167: begin //防麻+防护身 20090808
                m_boUnParalysis := True; //防麻痹
                m_boUnMagicShield := True; //防护身
              end;
            168: m_boUnPosion := True; //防毒 20090808
            169: m_boMeteorRing := True; //流星火雨戒指 20090918
            170: m_boAngryRing := True;
            171: m_boNoDropItem := True;
            172: m_boNoDropUseItem := True;
            180: m_dwPKDieLostExp := StdItem.DuraMax * g_Config.dwPKDieLostExpRate; //PK 死亡掉经验
            181: m_nPKDieLostLevel := StdItem.DuraMax div g_Config.nPKDieLostLevelRate; //PK 死亡掉等级
            182: begin
                m_boExpItem := True;
                m_rExpItem := m_rExpItem + (m_UseItems[I].DuraMax / g_Config.nItemExpRate);
              end;
            183: begin //人物攻击力倍数(倍数为持久除以 10000)，不受物品持久太小影响
                m_boPowerItem := True;
                m_rPowerItem := m_rPowerItem + (m_UseItems[I].DuraMax / g_Config.nItemPowerRate);
              end;
            189: m_boMagicShield1 := True; //聚魔护身戒指 红扣50% 蓝扣50%
            190: begin //战意麻痹戒指，麻痹时间2秒
                if m_btRaceServer = RC_PLAYMOSTER then begin
                  if m_Master = nil then m_boParalysis1 := True;
                end else m_boParalysis1 := True;
              end;
            191: begin ////魔道麻痹戒指
                if m_btRaceServer = RC_PLAYMOSTER then begin
                  if m_Master = nil then m_boParalysis2 := True;
                end else m_boParalysis2 := True;
              end;
            192: m_boHeavenSKill := True; //倚天剑(增加技能)
            194: begin //魔血2一套(增加HP上限) 装备一
                boXieLangSuite1 := True;
                Inc(m_nXieLangSutie, StdItem.Weight div 10);
              end;
            195: begin //魔血2一套(增加HP上限) 装备二
                boXieLangSuite2 := True;
                Inc(m_nXieLangSutie, StdItem.Weight div 10);
              end;
            196: begin //魔血2一套(增加HP上限) 装备三
                boXieLangSuite3 := True;
                Inc(m_nXieLangSutie, StdItem.Weight div 10);
              end;
            197: m_boRebirth := True; //重生戒指
            198: m_boMagicShield2 := True; //新护身戒指 蓝扣100%
            199: m_boDragonSkill := True; //神龙附体
            200: m_boCallTrollSkill := True; //召唤巨魔
            201: begin //魔意麻痹戒指
                if m_btRaceServer = RC_PLAYMOSTER then begin
                  if m_Master = nil then m_boParalysis3 := True;
                end else m_boParalysis3 := True;
              end;
            202: begin //麻痹、护身、重生属性
                if m_btRaceServer = RC_PLAYMOSTER then begin
                  if m_Master = nil then m_boParalysis := True;
                end else m_boParalysis := True;
                m_boMagicShield := True;
                m_boRebirth := True;
              end;
            204: begin //魔道麻痹和普通护身
                if m_btRaceServer = RC_PLAYMOSTER then begin
                  if m_Master = nil then m_boParalysis2 := True;
                end else m_boParalysis2 := True;
                m_boMagicShield := True; //八卦护身   1.5倍蓝
              end;
            205: begin //魔道麻痹和聚魔护身
                if m_btRaceServer = RC_PLAYMOSTER then begin
                  if m_Master = nil then m_boParalysis2 := True;
                end else m_boParalysis2 := True;
                m_boMagicShield1 := True; //聚魔护身戒指 红扣50% 蓝扣50%
              end;
            206: begin //至尊麻痹神戒
                if m_btRaceServer = RC_PLAYMOSTER then begin
                  if m_Master = nil then m_boParalysis2 := True;
                end else m_boParalysis2 := True;
                m_boMagicShield2 := True; //新护身戒指 蓝扣100%
              end;
          end; //case
        //新增结束
        end else begin
          m_WAbil.WearWeight := _MIN(High(Word), m_WAbil.WearWeight + StdItem.Weight); //20090628 修改
        end;
        nCode := 5;
        Inc(m_WAbil.Weight, StdItem.Weight);
        if (I = U_WEAPON) then begin //武器
{$IF M2Version <> 2}
          //修复覆盖掉原来属性的Bug By TasNat at: 2012-06-03 15:56:17
          case m_btRaceServer of
            RC_PLAYOBJECT: TPlayObject(self).m_boArmsCritPoint := _MIN(High(Byte), TPlayObject(self).m_boArmsCritPoint + m_UseItems[I].btValue[11] + m_UseItems[I].btValue[20]); //武器暴击等级 20100709
            RC_HEROOBJECT: THeroObject(self).m_boArmsCritPoint := _MIN(High(Byte), THeroObject(self).m_boArmsCritPoint + m_UseItems[I].btValue[11] + m_UseItems[I].btValue[20]); //武器暴击等级 20100709
          end;
{$IFEND}
          if (StdItem.Source - 1 - 10) < 0 then begin
            if StdItem.Source >= 0 then m_AddAbil.btWeaponStrong := StdItem.Source; //强度+ 20090811修改，由于btWeaponStrong为Byte,可能会出现越界
          end;
          if (StdItem.Source <= -1) and (StdItem.Source >= -50) then // -1 至 -50
            m_AddAbil.bt1DF := _MIN(High(Byte), m_AddAbil.bt1DF + -StdItem.Source); //神圣+  //20081204 由于 bt1DF为Byte，所以需判断
          if (StdItem.Source <= -51) and (StdItem.Source >= -100) then // -51 至 - 100
            m_AddAbil.bt1DF := _MIN(High(Byte), m_AddAbil.bt1DF + (StdItem.Source + 50)); //神圣- //20081204 由于 bt1DF为Byte，所以需判断
          Continue;
        end;
        if (I = U_RIGHTHAND) then begin //勋章,腊,火把
          if StdItem.Shape in [1..50] then m_btDressEffType := StdItem.Shape;
          if StdItem.Shape in [51..100] then m_btHorseType := StdItem.Shape - 50;
          Continue;
        end;
        if (I = U_DRESS) then begin //衣服特效值
          if m_UseItems[I].btValue[5] > 0 then m_btDressEffType := m_UseItems[I].btValue[5];
          if StdItem.AniCount > 0 then m_btDressEffType := StdItem.AniCount;
          Continue;
        end;
        case StdItem.Shape of //20091104 修改
          111: begin
              m_wStatusTimeArr[STATE_TRANSPARENT] := MaxWord {6 * 10 * 1000};
              m_boHideMode := True;
              m_boTransparent := False; //20090907 修正，先魔法隐身后，再带隐身装备，跑动隐身消失BUG
            end;
          112: m_boTeleport := True;
          113: begin
              if m_btRaceServer = RC_PLAYMOSTER then begin
                if m_Master = nil then m_boParalysis := True;
              end else m_boParalysis := True;
            end;
          114: m_boRevival := True;
          115: m_boFlameRing := True;
          116: m_boRecoveryRing := True;
          117: m_boAngryRing := True;
          118: m_boMagicShield := True;
          119: m_boMuscleRing := True;
          120: m_boFastTrain := True;
          121: m_boProbeNecklace := True;
          122: boRecallSuite2 := True;
          123: boRecallSuite1 := True; //记忆
          124: boRecallSuite3 := True;
          125: boRecallSuite4 := True;
          126: boSpirit3 := True;
          127: boSpirit1 := True;
          128: boSpirit2 := True;
          129: boSpirit4 := True;
          133: begin //魔血2
              boMoXieSuite2 := True;
              Inc(m_nMoXieSuite, StdItem.AniCount);
            end;
          134: begin //魔血3
              boMoXieSuite3 := True;
              Inc(m_nMoXieSuite, StdItem.AniCount);
            end;
          135: begin //魔血1
              boMoXieSuite1 := True;
              Inc(m_nMoXieSuite, StdItem.AniCount);
            end;
          136: begin
              boHongMoSuite2 := True;
              Inc(m_nHongMoSuite, StdItem.AniCount);
            end;
          137: begin
              boHongMoSuite3 := True;
              Inc(m_nHongMoSuite, StdItem.AniCount);
            end;
          138: begin
              boHongMoSuite1 := True;
              Inc(m_nHongMoSuite, StdItem.AniCount);
            end;
          139: m_boUnParalysis := True;
          140: m_boSupermanItem := True;
          141: begin
              m_boExpItem := True;
              m_rExpItem := m_rExpItem + (m_UseItems[I].Dura / g_Config.nItemExpRate);
            end;
          142: begin
              m_boPowerItem := True;
              m_rPowerItem := m_rPowerItem + (m_UseItems[I].Dura / g_Config.nItemPowerRate);
            end;
          143: m_boUnMagicShield := True;
          144: m_boUnRevival := True;
          145: m_boGuildMove := True;
          150: begin //麻痹护身
              if m_btRaceServer = RC_PLAYMOSTER then begin
                if m_Master = nil then m_boParalysis := True;
              end else m_boParalysis := True;
              m_boMagicShield := True;
            end;
          151: begin //麻痹火球
              if m_btRaceServer = RC_PLAYMOSTER then begin
                if m_Master = nil then m_boParalysis := True;
              end else m_boParalysis := True;
              m_boFlameRing := True;
            end;
          152: begin //麻痹防御
              if m_btRaceServer = RC_PLAYMOSTER then begin
                if m_Master = nil then m_boParalysis := True;
              end else m_boParalysis := True;
              m_boRecoveryRing := True;
            end;
          153: begin //麻痹负载
              if m_btRaceServer = RC_PLAYMOSTER then begin
                if m_Master = nil then m_boParalysis := True;
              end else m_boParalysis := True;
              m_boMuscleRing := True;
            end;
          154: begin //护身火球
              m_boMagicShield := True;
              m_boFlameRing := True;
            end;
          155: begin //护身防御
              m_boMagicShield := True;
              m_boRecoveryRing := True;
            end;
          156: begin //护身负载
              m_boMagicShield := True;
              m_boMuscleRing := True;
            end;
          157: begin //传送麻痹
              m_boTeleport := True;
              if m_btRaceServer = RC_PLAYMOSTER then begin
                if m_Master = nil then m_boParalysis := True;
              end else m_boParalysis := True;
            end;
          158: begin //传送护身
              m_boTeleport := True;
              m_boMagicShield := True;
            end;
          159: begin //传送探测
              m_boTeleport := True;
              m_boProbeNecklace := True;
            end;
          160: begin //传送复活
              m_boTeleport := True;
              m_boRevival := True;
            end;
          161: begin //麻痹复活
              if m_btRaceServer = RC_PLAYMOSTER then begin
                if m_Master = nil then m_boParalysis := True;
              end else m_boParalysis := True;
              m_boRevival := True;
            end;
          162: begin //护身+复活
              m_boMagicShield := True;
              m_boRevival := True;
            end;
          163: begin //防麻+记忆 20090808
              m_boUnParalysis := True; //防麻
              m_boRecallSuite := True; //记忆
            end;
          164: begin //防毒+记忆 20090808
              m_boRecallSuite := True; //记忆
              m_boUnPosion := True; //防毒
            end;
          165: begin //防护身+复活 20090808
              m_boUnMagicShield := True; //防护身
              m_boRevival := True; //复活
            end;
          166: begin //防麻+防复活 20090808
              m_boUnParalysis := True; //防麻痹
              m_boUnRevival := True; //防复活
            end;
          167: begin //防麻+防护身 20090808
              m_boUnParalysis := True; //防麻痹
              m_boUnMagicShield := True; //防护身
            end;
          168: m_boUnPosion := True; //防毒 20090808
          169: m_boMeteorRing := True; //流星火雨戒指 20090918
          170: m_boAngryRing := True;
          171: m_boNoDropItem := True;
          172: m_boNoDropUseItem := True;
          180: m_dwPKDieLostExp := StdItem.DuraMax * g_Config.dwPKDieLostExpRate; //PK 死亡掉经验
          181: m_nPKDieLostLevel := StdItem.DuraMax div g_Config.nPKDieLostLevelRate; //PK 死亡掉等级
          182: begin
              m_boExpItem := True;
              m_rExpItem := m_rExpItem + (m_UseItems[I].DuraMax / g_Config.nItemExpRate);
            end;
          183: begin
              m_boPowerItem := True;
              m_rPowerItem := m_rPowerItem + (m_UseItems[I].DuraMax / g_Config.nItemPowerRate);
            end;
          189: m_boMagicShield1 := True; //聚魔护身戒指 红扣50% 蓝扣50%
          190: begin //战意麻痹戒指，麻痹时间2秒
              if m_btRaceServer = RC_PLAYMOSTER then begin
                if m_Master = nil then m_boParalysis1 := True;
              end else m_boParalysis1 := True;
            end;
          191: begin //魔道麻痹戒指
              if m_btRaceServer = RC_PLAYMOSTER then begin
                if m_Master = nil then m_boParalysis2 := True;
              end else m_boParalysis2 := True;
            end;
          192: m_boHeavenSKill := True; //倚天剑(增加技能)
          194: begin //魔血2一套(增加HP上限) 装备一
              boXieLangSuite1 := True;
              Inc(m_nXieLangSutie, StdItem.AniCount);
            end;
          195: begin //魔血2一套(增加HP上限) 装备二
              boXieLangSuite2 := True;
              Inc(m_nXieLangSutie, StdItem.AniCount);
            end;
          196: begin //魔血2一套(增加HP上限) 装备三
              boXieLangSuite3 := True;
              Inc(m_nXieLangSutie, StdItem.AniCount);
            end;
          197: m_boRebirth := True; //重生戒指
          198: m_boMagicShield2 := True; //新护身戒指 蓝扣100%
          199: m_boDragonSkill := True; //神龙附体
          200: m_boCallTrollSkill := True; //召唤巨魔
          201: begin //魔意麻痹戒指
              if m_btRaceServer = RC_PLAYMOSTER then begin
                if m_Master = nil then m_boParalysis3 := True;
              end else m_boParalysis3 := True;
            end;
          202: begin //麻痹、护身、重生属性
              if m_btRaceServer = RC_PLAYMOSTER then begin
                if m_Master = nil then m_boParalysis := True;
              end else m_boParalysis := True;
              m_boMagicShield := True;
              m_boRebirth := True;
            end;
          203: begin //麻痹、吸伤(武器无效)
              if m_btRaceServer = RC_PLAYMOSTER then begin
                if m_Master = nil then m_boParalysis := True;
              end else m_boParalysis := True;
            end;
          204: begin //魔道麻痹和普通护身
              if m_btRaceServer = RC_PLAYMOSTER then begin
                if m_Master = nil then m_boParalysis2 := True;
              end else m_boParalysis2 := True;
              m_boMagicShield := True; //八卦护身  1.5倍蓝
            end;
          205: begin //魔道麻痹和聚魔护身
              if m_btRaceServer = RC_PLAYMOSTER then begin
                if m_Master = nil then m_boParalysis2 := True;
              end else m_boParalysis2 := True;
              m_boMagicShield1 := True; //聚魔护身戒指 红扣50% 蓝扣50%
            end;
          206: begin //至尊麻痹神戒
              if m_btRaceServer = RC_PLAYMOSTER then begin
                if m_Master = nil then m_boParalysis2 := True;
              end else m_boParalysis2 := True;
              m_boMagicShield2 := True; //新护身戒指 蓝扣100%
            end;
        end; //case
        if I = U_BUJUK then begin
          if (StdItem.StdMode = 25) and (StdItem.Shape = 6) then m_boTeleport := True; //传送符
        end;
      //新增结束
      end;
{$EndRegion}//身上装备
    end;
    nCode := 10;
    if boRecallSuite1 and boRecallSuite2 and boRecallSuite3 and boRecallSuite4 then m_boRecallSuite := True;
    if boXieLangSuite1 and boXieLangSuite2 and boXieLangSuite3 then Inc(m_nXieLangSutie, 50); //魔血2一套(增加HP上限) 穿全三件套，增加50HP上限
    if boMoXieSuite1 and boMoXieSuite2 and boMoXieSuite3 then Inc(m_nMoXieSuite, 50);
    if boHongMoSuite1 and boHongMoSuite2 and boHongMoSuite3 then Inc(m_AddAbil.wHitPoint, 2);

    if boSpirit1 and boSpirit2 and boSpirit3 and boSpirit4 then m_bopirit := True;
    nCode := 11;
    m_WAbil.Weight := RecalcBagWeight(); //刷包裹重量

    if m_boTransparent and (m_wStatusTimeArr[STATE_TRANSPARENT {8}] > 0) then m_boHideMode := True;
    nCode := 120;
    if m_boHideMode then begin
      if not boOldHideMode then begin
        nCode := 121;
        m_nCharStatus := GetCharStatus();
        nCode := 122;
        StatusChanged('');
      end;
    end else begin
      if boOldHideMode then begin
        nCode := 123;
        m_wStatusTimeArr[STATE_TRANSPARENT {8}] := 0;
        m_nCharStatus := GetCharStatus();
        nCode := 124;
        StatusChanged('');
      end;
    end;
    nCode := 132;

    if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) then begin
      nCode := 128;
      if m_boFlameRing then AddItemSkill(1) else DelItemSkill(1);
      if m_boRecoveryRing then AddItemSkill(2) else DelItemSkill(2);
      nCode := 130;
      if m_boMeteorRing then AddItemSkill(3) else DelItemSkill(3); //流星火雨戒指 20090918
      nCode := 131;
      if m_boHeavenSKill then AddItemSkill(4) else DelItemSkill(4); //倚天剑(增加技能)
      if m_boDragonSkill then AddItemSkill(5) else DelItemSkill(5); //神龙附体
      if m_boCallTrollSkill then AddItemSkill(6) else DelItemSkill(6); //召唤巨魔(传奇神剑)
    end;
    except
      //防止异常不调用  RecalcHitSpeed 导致 技能指针无效 By TasNat at: 2012-07-25 17:27:49 
    end;

    if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then //01-20 增加此行，只有类型为人物的角色才重新计算攻击敏捷，刷新技能
      RecalcHitSpeed();
    nCode := 126;
    nOldLight := m_nLight;
    if (m_UseItems[U_RIGHTHAND].wIndex > 0) and (m_UseItems[U_RIGHTHAND].Dura > 0) then
      m_nLight := 3
    else m_nLight := 0;
    nCode := 127; //20090710 增加
    if (nOldLight <> m_nLight) and (not m_boDeath) then SendRefMsg(RM_CHANGELIGHT, 0, 0, 0, 0, '');
    nCode := 13;
    m_btSpeedPoint := _MIN(High(Byte), m_btSpeedPoint + m_AddAbil.wSpeedPoint); //敏捷 20090904
    m_btHitPoint := _MIN(High(m_btHitPoint), m_btHitPoint + m_AddAbil.wHitPoint); //准确  //20101006 修改

    m_btAntiPoison := _MIN(High(Byte), m_btAntiPoison + m_AddAbil.wAntiPoison); //中毒躲避 20090904
    Inc(m_nPoisonRecover, m_AddAbil.wPoisonRecover); //中毒恢复
    Inc(m_nHealthRecover, m_AddAbil.wHealthRecover); //体力恢复
    Inc(m_nSpellRecover, m_AddAbil.wSpellRecover); //魔法恢复

    m_nAntiMagic := _MIN(High(ShortInt), m_nAntiMagic + m_AddAbil.wAntiMagic); //魔法躲避 20090904

    case m_btRaceServer of //20091104 修改
      RC_PLAYOBJECT: begin
{$IF M2Version <> 2}
          TPlayObject(self).m_nIncNHRecover := _MIN(100, TPlayObject(self).m_nIncNHRecover + m_AddAbil.wIncNHRecover); //内力恢复(增加) 20090331
          TPlayObject(self).m_nIncNHPoint := _MIN(High(Word), TPlayObject(self).m_nIncNHPoint + m_AddAbil.wIncNHPoint + m_wStatusArrValue[16] + AddUnKnowAbility.wIncNHPoint); //内力恢复速度(点数) 20090712
          m_nDecTargetNHPoint := _MIN(High(Byte), m_nDecTargetNHPoint + m_AddAbil.wDecTargetNHPoint + AddUnKnowAbility.wDecTargetNHLevel + FengHaoAbility.wDecTargetNHPoint); //目标内力值减少点数(内伤装备) 20100513
          if AddUnKnowAbility.wCritLevel > 0 then //暴击等级
            TPlayObject(self).m_boArmsCritPoint := _MIN(High(Byte), TPlayObject(self).m_boArmsCritPoint + AddUnKnowAbility.wCritLevel); //武器暴击等级
          if FengHaoAbility.wCritLevel > 0 then //暴击等级
            TPlayObject(self).m_boArmsCritPoint := _MIN(High(Byte), TPlayObject(self).m_boArmsCritPoint + FengHaoAbility.wCritLevel); //武器暴击等级
          if AddUnKnowAbility.wIncDragonRate > 0 then //合击威力
            TPlayObject(self).m_nIncDragonRate := _MIN(High(Byte), TPlayObject(self).m_nIncDragonRate + AddUnKnowAbility.wIncDragonRate);
          if FengHaoAbility.wIncDragonRate > 0 then //合击威力
            TPlayObject(self).m_nIncDragonRate := _MIN(High(Byte), TPlayObject(self).m_nIncDragonRate + FengHaoAbility.wIncDragonRate);
{$IFEND}
          m_nBurstRate := _MIN(High(Byte), m_nBurstRate + m_AddAbil.btBurstRate); //爆率
          m_nUnBurstRate := _MIN(High(Byte), m_nUnBurstRate + m_AddAbil.wUnBurstRate); //防爆点数
          m_nUnParalysisRate := _MIN(High(Word), m_nUnParalysisRate + m_AddAbil.wUnParalysisRate); //防麻机率(辉煌衣服) 20100513
          m_nParalysisAddRate := _MIN(High(Word), m_nParalysisAddRate + m_AddAbil.wParalysisAddRate); //麻痹强化(军鼓等等)  add by liuzhigang on 2011.12.31
          TPlayObject(self).m_nIncDragon := _MIN(High(Word), TPlayObject(self).m_nIncDragon + m_AddAbil.wIncDragon); //增加合击威力点数
          //m_nUnParalysisRate := _MAX(0, m_nUnParalysisRate - m_nParalysisAddRate); // 麻痹抗性-麻痹强化
          m_nVampirePoint := _MIN(High(Byte), m_nVampirePoint + m_AddAbil.wVampirePoint); //吸血点数(虎威装备)
          m_nVampireRate := _MIN(100, m_nVampireRate + m_AddAbil.wVampireRate); //吸血机率(虎威装备)
        end;
      RC_HEROOBJECT: begin
{$IF M2Version <> 2}
          THeroObject(self).m_nIncNHRecover := _MIN(100, THeroObject(self).m_nIncNHRecover + m_AddAbil.wIncNHRecover); //内力恢复(增加) 20090331
          THeroObject(self).m_nIncNHPoint := _MIN(High(Word), THeroObject(self).m_nIncNHPoint + m_AddAbil.wIncNHPoint + m_wStatusArrValue[16] + AddUnKnowAbility.wIncNHPoint); //内力恢复速度(点数) 20090712
          m_nDecTargetNHPoint := _MIN(High(Byte), m_nDecTargetNHPoint + m_AddAbil.wDecTargetNHPoint + AddUnKnowAbility.wDecTargetNHLevel); //目标内力值减少点数(内伤装备) 20100513
          if AddUnKnowAbility.wCritLevel > 0 then //暴击等级
            THeroObject(self).m_boArmsCritPoint := _MIN(High(Byte), THeroObject(self).m_boArmsCritPoint + AddUnKnowAbility.wCritLevel); //武器暴击等级
          if AddUnKnowAbility.wIncDragonRate > 0 then //合击威力
            THeroObject(self).m_nIncDragonRate := _MIN(High(Byte), THeroObject(self).m_nIncDragonRate + AddUnKnowAbility.wIncDragonRate);
{$IFEND}
          m_nBurstRate := _MIN(High(Byte), m_nBurstRate + m_AddAbil.btBurstRate); //爆率
          m_nUnBurstRate := _MIN(High(Byte), m_nUnBurstRate + m_AddAbil.wUnBurstRate); //防爆点数
          m_nUnParalysisRate := _MIN(High(Word), m_nUnParalysisRate + m_AddAbil.wUnParalysisRate); //防麻机率(辉煌衣服) 20100513
          m_nParalysisAddRate := _MIN(High(Word), m_nParalysisAddRate + m_AddAbil.wParalysisAddRate); //防麻强化(军鼓等等)  add by liuzhigang on 2011.12.31
          THeroObject(self).m_nIncDragon := _MIN(High(Word), THeroObject(self).m_nIncDragon + m_AddAbil.wIncDragon); //增加合击威力点数
          //m_nUnParalysisRate := _MAX(0, m_nUnParalysisRate - m_nParalysisAddRate);
          m_nVampirePoint := _MIN(High(Byte), m_nVampirePoint + m_AddAbil.wVampirePoint); //吸血点数(虎威装备)
          m_nVampireRate := _MIN(100, m_nVampireRate + m_AddAbil.wVampireRate); //吸血机率(虎威装备)
        end;
    end;

    Inc(m_nLuck, m_AddAbil.btLuck); //人物的幸运值
    if m_nLuck >= m_AddAbil.btUnLuck then begin //20090424 修改
      Dec(m_nLuck, m_AddAbil.btUnLuck);
    end else m_nLuck := 0;

    if m_AddAbil.nHitSpeed > 0 then begin
      m_nHitSpeed := _MIN(High(ShortInt), m_AddAbil.nHitSpeed); //速度 20090904
    end else m_nHitSpeed := m_AddAbil.nHitSpeed; //速度

    nCode := 14;
    if m_Abil.MaxHP > (High(Integer) - m_AddAbil.wHP) then begin //20101008 修改
      m_WAbil.MaxHP := High(Integer);
    end else m_WAbil.MaxHP := m_Abil.MaxHP + m_AddAbil.wHP;

    if m_Abil.MaxMP > (High(Integer) - m_AddAbil.wMP) then begin //20101008 修改
      m_WAbil.MaxMP := High(Integer);
    end else m_WAbil.MaxMP := m_Abil.MaxMP + m_AddAbil.wMP;

    m_WAbil.AC := MakeLong(LoWord(m_AddAbil.wAC) + LoWord(m_Abil.AC), HiWord(m_AddAbil.wAC) + HiWord(m_Abil.AC));
    m_WAbil.MAC := MakeLong(LoWord(m_AddAbil.wMAC) + LoWord(m_Abil.MAC), HiWord(m_AddAbil.wMAC) + HiWord(m_Abil.MAC));
    m_WAbil.DC := MakeLong(LoWord(m_AddAbil.wDC) + LoWord(m_Abil.DC), HiWord(m_AddAbil.wDC) + HiWord(m_Abil.DC) + m_btHitPointSkill88);
    m_WAbil.MC := MakeLong(LoWord(m_AddAbil.wMC) + LoWord(m_Abil.MC), HiWord(m_AddAbil.wMC) + HiWord(m_Abil.MC));
    m_WAbil.SC := MakeLong(LoWord(m_AddAbil.wSC) + LoWord(m_Abil.SC), HiWord(m_AddAbil.wSC) + HiWord(m_Abil.SC));

    if (m_AddAbil.wWearWeight + m_Abil.MaxWearWeight) < High(m_WAbil.MaxWearWeight) then begin //20090719 修改
      m_WAbil.MaxWearWeight := MakeLong(LoWord(m_AddAbil.wWearWeight) + LoWord(m_Abil.MaxWearWeight), HiWord(m_AddAbil.wWearWeight) + HiWord(m_Abil.MaxWearWeight)); //20080325 加负重
    end else m_WAbil.MaxWearWeight := High(m_WAbil.MaxWearWeight);
    nCode := 15;
    case m_btRaceServer of //命令增加的永久属性  20090623
      RC_PLAYOBJECT: begin
          m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC) + TPlayObject(self).m_PulseAddAC1, HiWord(m_WAbil.AC) + TPlayObject(self).m_PulseAddAC);
          m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC) + TPlayObject(self).m_PulseAddMAC1, HiWord(m_WAbil.MAC) + TPlayObject(self).m_PulseAddMAC);
        end;
      RC_HEROOBJECT: begin
          m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC) + THeroObject(self).m_PulseAddAC1, HiWord(m_WAbil.AC) + THeroObject(self).m_PulseAddAC);
          m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC) + THeroObject(self).m_PulseAddMAC1, HiWord(m_WAbil.MAC) + THeroObject(self).m_PulseAddMAC);
        end;
    end;

    if m_wStatusTimeArr[STATE_DEFENCEUP {9}] > 0 then
      m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC), HiWord(m_WAbil.AC) + 2 + (m_Abil.Level div 7));

    if m_wStatusTimeArr[STATE_MAGDEFENCEUP {10}] > 0 then
      m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC), HiWord(m_WAbil.MAC) + 2 + (m_Abil.Level div 7));

{$IF M2Version <> 2}
    if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) or
       (m_btRaceServer = RC_PLAYMOSTER) then begin //20101023 增加人形
      if AddUnKnowAbility.boRebirth then m_boRebirth := True; //重生技能
      if AddUnKnowAbility.boMagicShield then m_boMagicShield1 := True; //八卦护身技能
      if AddUnKnowAbility.boParalysis then begin //麻痹技能
        if m_btRaceServer = RC_PLAYMOSTER then begin
          if m_Master = nil then m_boParalysis := True;
        end else m_boParalysis := True;
      end;
      if AddUnKnowAbility.boParalysis2 then begin //魔道麻痹技能
        if m_btRaceServer = RC_PLAYMOSTER then begin
          if m_Master = nil then m_boParalysis2 := True;
        end else m_boParalysis2 := True;
      end;
      if AddUnKnowAbility.boParalysis1 then begin //战意麻痹技能
        if m_btRaceServer = RC_PLAYMOSTER then begin
          if m_Master = nil then m_boParalysis1 := True;
        end else m_boParalysis1 := True;
      end;
      if AddUnKnowAbility.boProbeNecklace then m_boProbeNecklace := True; //探测技能
      if AddUnKnowAbility.boTeleport then m_boTeleport := True; //传送技能

      if AddUnKnowAbility.wDC > 0 then //攻击力 上限
        m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_WAbil.DC) + AddUnKnowAbility.wDC);
      if AddUnKnowAbility.wMC > 0 then //魔法 上限
        m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC), HiWord(m_WAbil.MC) + AddUnKnowAbility.wMC);
      if AddUnKnowAbility.wSC > 0 then //道术 上限
        m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), HiWord(m_WAbil.SC) + AddUnKnowAbility.wSC);
      if AddUnKnowAbility.wMAC > 0 then //魔御 上限
        m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC), HiWord(m_WAbil.MAC) + AddUnKnowAbility.wMAC);
      if AddUnKnowAbility.wAC > 0 then //防御 上限
        m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC), HiWord(m_WAbil.AC) + AddUnKnowAbility.wAC);
      if AddUnKnowAbility.wVampirePoint > 0 then //吸血上限(虎威)
        m_nVampirePoint := _MIN(High(Byte), m_nVampirePoint + AddUnKnowAbility.wVampirePoint);
      if AddUnKnowAbility.wUnBurstRate > 0 then //防爆
        m_nUnBurstRate := _MIN(High(Byte), m_nUnBurstRate + AddUnKnowAbility.wUnBurstRate); //防爆点数
      if AddUnKnowAbility.wHitPoint > 0 then //准确
        m_btHitPoint := _MIN(High(m_btHitPoint), m_btHitPoint + AddUnKnowAbility.wHitPoint); //准确
      if AddUnKnowAbility.wSpeedPoint > 0 then //敏捷
        m_btSpeedPoint := _MIN(High(Byte), m_btSpeedPoint + AddUnKnowAbility.wSpeedPoint); //敏捷

      if AddUnKnowAbility.wUnParalysisRate > 0 then //麻痹抗性(辉煌衣服)
        m_nUnParalysisRate := _MIN(High(Word), m_nUnParalysisRate + AddUnKnowAbility.wUnParalysisRate); //防麻机率(辉煌衣服)
      if AddUnKnowAbility.wParalysisAddRate > 0 then //麻痹抗性(辉煌衣服)
        m_nParalysisAddRate := _MIN(High(Word), m_nParalysisAddRate + AddUnKnowAbility.wParalysisAddRate); //防麻强化(军鼓等等)  add by liuzhigang on 2011.12.31

      case m_btJob of //按职业增加属性
        0: begin //战
            if AddUnKnowAbility.wMain > 0 then //主属性
              m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_WAbil.DC) + AddUnKnowAbility.wMain);
            if AddUnKnowAbility.wMagicShieldLevel > 0 then begin //聚魔等级(加蓝，职业不同加的魔法上限应该是不同)
              if m_WAbil.MaxMP > (High(Integer) - (AddUnKnowAbility.wMagicShieldLevel * 20)) then begin
                m_WAbil.MaxMP := High(Integer);
              end else m_WAbil.MaxMP := m_WAbil.MaxMP + (AddUnKnowAbility.wMagicShieldLevel * 20);
            end;
            if AddUnKnowAbility.wPhysicalLevel > 0 then begin //强身等级(加血，职业不同加的血量不同 战+50 法+20 道+35)
              if m_WAbil.MaxHP > (High(Integer) - (AddUnKnowAbility.wPhysicalLevel * 50)) then begin
                m_WAbil.MaxHP := High(Integer);
              end else m_WAbil.MaxHP := m_WAbil.MaxHP + (AddUnKnowAbility.wPhysicalLevel * 50);
            end;
          end;
        1: begin //法
            if AddUnKnowAbility.wMain > 0 then //主属性
              m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC), HiWord(m_WAbil.MC) + AddUnKnowAbility.wMain);
            if AddUnKnowAbility.wMagicShieldLevel > 0 then begin //聚魔等级(加蓝，职业不同加的魔法上限应该是不同)
              if m_WAbil.MaxMP > (High(Integer) - (AddUnKnowAbility.wMagicShieldLevel * 50)) then begin
                m_WAbil.MaxMP := High(Integer);
              end else m_WAbil.MaxMP := m_WAbil.MaxMP + (AddUnKnowAbility.wMagicShieldLevel * 50);
            end;
            if AddUnKnowAbility.wPhysicalLevel > 0 then begin //强身等级(加血，职业不同加的血量不同 战+50 法+20 道+35)
              if m_WAbil.MaxHP > (High(Integer) - (AddUnKnowAbility.wPhysicalLevel * 20)) then begin
                m_WAbil.MaxHP := High(Integer);
              end else m_WAbil.MaxHP := m_WAbil.MaxHP + (AddUnKnowAbility.wPhysicalLevel * 20);
            end;
          end;
        2: begin //道
            if AddUnKnowAbility.wMain > 0 then //主属性
              m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), HiWord(m_WAbil.SC) + AddUnKnowAbility.wMain);
            if AddUnKnowAbility.wMagicShieldLevel > 0 then begin //聚魔等级(加蓝，职业不同加的魔法上限应该是不同)
              if m_WAbil.MaxMP > (High(Integer) - (AddUnKnowAbility.wMagicShieldLevel * 35)) then begin
                m_WAbil.MaxMP := High(Integer);
              end else m_WAbil.MaxMP := m_WAbil.MaxMP + (AddUnKnowAbility.wMagicShieldLevel * 35);
            end;
            if AddUnKnowAbility.wPhysicalLevel > 0 then begin //强身等级(加血，职业不同加的血量不同 战+50 法+20 道+35)
              if m_WAbil.MaxHP > (High(Integer) - (AddUnKnowAbility.wPhysicalLevel * 35)) then begin
                m_WAbil.MaxHP := High(Integer);
              end else m_WAbil.MaxHP := m_WAbil.MaxHP + (AddUnKnowAbility.wPhysicalLevel * 35);
            end;
          end;
      end;
    end;
    if (m_btRaceServer = RC_PLAYOBJECT) then begin
      with TPlayObject(self) do begin //弟子无门派则清掉心法,有门派则计算属性
        m_dwHeartAddPower := 0;
        m_dwHeartAddDefence := 0;
        if (m_MagicSkill_106 <> nil) and (m_MyDivision <> nil) then begin //传承心法
          if m_MagicSkill_106.MagicInfo <> nil then begin
            m_dwHeartAddDefence := MakeLong(m_MagicSkill_106.MagicInfo.wPower, m_MagicSkill_106.MagicInfo.wMaxPower);
            if LoWord(m_dwHeartAddDefence) > 0 then //增加防御上下限
              m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC)+LoWord(m_dwHeartAddDefence), HiWord(m_WAbil.AC)+LoWord(m_dwHeartAddDefence));
            if HiWord(m_dwHeartAddDefence) > 0 then//增加魔防御上下限
              m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC)+HiWord(m_dwHeartAddDefence), HiWord(m_WAbil.MAC)+HiWord(m_dwHeartAddDefence));
            if m_MagicSkill_106.MagicInfo.btDefMaxPower > 0 then begin//增加攻魔道(按技能等级计算)
              m_dwHeartAddPower := (m_MagicSkill_106.MagicInfo.btDefMaxPower * m_MagicSkill_106.btLevel);
              m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_WAbil.DC) + m_dwHeartAddPower);//攻
              m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC), HiWord(m_WAbil.MC) + m_dwHeartAddPower);//魔
              m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), HiWord(m_WAbil.SC) + m_dwHeartAddPower);//道
            end;
          end;
          if (m_wStatusArrValue[21] > 0) then begin //心法激活,增加主属性下限
          case m_btJob of//按职业增加属性
            0: Inc(m_dwHeartAddPower, Round(HiWord(m_WAbil.DC) * (g_Config.nHeartArrValueRate / 10)) - HiWord(m_WAbil.DC));//战
            1: Inc(m_dwHeartAddPower, Round(HiWord(m_WAbil.MC) * (g_Config.nHeartArrValueRate / 10)) - HiWord(m_WAbil.MC));//法
            2: Inc(m_dwHeartAddPower, Round(HiWord(m_WAbil.SC) * (g_Config.nHeartArrValueRate / 10)) - HiWord(m_WAbil.SC));//道
          end;
          case m_btJob of//按职业增加属性
            0:m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_WAbil.DC) + m_dwHeartAddPower);//战
            1:m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC), HiWord(m_WAbil.MC) + m_dwHeartAddPower);//法
            2:m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), HiWord(m_WAbil.SC) + m_dwHeartAddPower);//道
          end;
          end;
        end;
        if (m_MagicSkill_105 <> nil) then begin             
          case m_btJob of//按职业增加属性
            0: Inc(m_dwHeartAddPower, Round(HiWord(m_WAbil.DC) * (g_Config.nHeartArrValueRate / 10)) - HiWord(m_WAbil.DC));//战
            1: Inc(m_dwHeartAddPower, Round(HiWord(m_WAbil.MC) * (g_Config.nHeartArrValueRate / 10)) - HiWord(m_WAbil.MC));//法
            2: Inc(m_dwHeartAddPower, Round(HiWord(m_WAbil.SC) * (g_Config.nHeartArrValueRate / 10)) - HiWord(m_WAbil.SC));//道
          end;
        if (m_boHeartActive) and (m_dwHeartAddPower > 0) then begin
          case m_btJob of//按职业增加属性
            0:m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_WAbil.DC) + m_dwHeartAddPower);//战
            1:m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC), HiWord(m_WAbil.MC) + m_dwHeartAddPower);//法
            2:m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), HiWord(m_WAbil.SC) + m_dwHeartAddPower);//道
          end;
        end;
        end;
      end;
    end;
{$IFEND}

    if m_wStatusArrValue[0] > 0 then //增加攻击力,同时增加上限和下限 20091222
      m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC) + m_wStatusArrValue[0], HiWord(m_WAbil.DC) + m_wStatusArrValue[0]);

    if m_wStatusArrValue[1] > 0 then //增加魔法力,同时增加上限和下限 20091222
      m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC) + m_wStatusArrValue[1], HiWord(m_WAbil.MC) + m_wStatusArrValue[1]);

    nCode := 160;
    if m_wStatusArrValue[2] > 0 then begin //增加道术,同时增加上限和下限 20091222  无极真气改变道术值
      if g_Config.boAbilityAddMode then
      begin
        m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC) + m_wStatusArrValue[2], HiWord(m_WAbil.SC) + m_wStatusArrValue[2]);
      end else m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), HiWord(m_WAbil.SC) + m_wStatusArrValue[2]);
    end;

    if m_wStatusArrValue[3] > 0 then begin //攻击速度 20090904 修改
      m_nHitSpeed := _MIN(High(ShortInt), m_nHitSpeed + m_wStatusArrValue[3]);
    end;
    if m_wStatusArrValue[22] > 0 then begin //移动速度
      if m_btRaceServer = RC_PLAYOBJECT then
        m_nRunSpeed := _MAX(Low(Smallint), m_nRunSpeed - m_wStatusArrValue[22])
      else m_dwWalkTick := m_dwWalkTick + m_wStatusArrValue[22];
    end;
    if m_wStatusArrValue[4] > 0 then begin //增加生命上限
      if m_WAbil.MaxHP > (High(Integer) - m_wStatusArrValue[4]) then begin //20101008 修改
        m_WAbil.MaxHP := High(Integer);
      end else m_WAbil.MaxHP := m_WAbil.MaxHP + m_wStatusArrValue[4];
    end;

    if m_wStatusArrValue[5] > 0 then begin //增加魔法值上限
      if m_WAbil.MaxMP > (High(Integer) - m_wStatusArrValue[5]) then begin //20101008 修改
        m_WAbil.MaxMP := High(Integer);
      end else m_WAbil.MaxMP := m_WAbil.MaxMP + m_wStatusArrValue[5];
    end;

    if m_wStatusArrValue[6] > 0 then begin //减攻击力
      if LoWord(m_WAbil.DC) > (HiWord(m_WAbil.DC) - m_wStatusArrValue[6]) then
        m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), LoWord(m_WAbil.DC))
      else
        m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_WAbil.DC) - m_wStatusArrValue[6])
    end;

    if m_wStatusArrValue[7] > 0 then begin //减魔法力
      if LoWord(m_WAbil.MC) > (HiWord(m_WAbil.MC) - m_wStatusArrValue[7]) then
        m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC), LoWord(m_WAbil.MC))
      else
        m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC), HiWord(m_WAbil.MC) - m_wStatusArrValue[7]);
    end;

    if m_wStatusArrValue[8] > 0 then begin //减道术
      if LoWord(m_WAbil.SC) > (HiWord(m_WAbil.SC) - m_wStatusArrValue[8]) then
        m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), LoWord(m_WAbil.SC))
      else
        m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), HiWord(m_WAbil.SC) - m_wStatusArrValue[8]);
    end;

    if m_wStatusArrValue[11] > 0 then //增加敏捷
      Inc(m_btSpeedPoint, m_wStatusArrValue[11]); //敏捷

    if m_wStatusArrValue[12] > 0 then begin //增加防御上下限 20091222
      m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC) + m_wStatusArrValue[12], HiWord(m_WAbil.AC) + m_wStatusArrValue[12]);
    end;

    if m_wStatusArrValue[13] > 0 then begin //增加魔防上下限 20091222
      m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC) + m_wStatusArrValue[13], HiWord(m_WAbil.MAC) + m_wStatusArrValue[13]);
    end;

    if m_wStatusArrValue[14] > 0 then begin //增加道术上限(虎骨酒)
      m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), HiWord(m_WAbil.SC) + m_wStatusArrValue[14]);
    end;
    if m_wStatusArrValue[20] > 0 then begin //增加道术,同时增加上限和下限
      m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC) + m_wStatusArrValue[20], HiWord(m_WAbil.SC) + m_wStatusArrValue[20])
    end;
    nCode := 162;
    if m_boMuscleRing then begin //活力  20090205 修改
      m_WAbil.MaxWeight := _MIN(High(Word), m_WAbil.MaxWeight + m_WAbil.MaxWeight);
      m_WAbil.MaxWearWeight := _MIN(High(Word), m_WAbil.MaxWearWeight + m_WAbil.MaxWearWeight);
      m_WAbil.MaxHandWeight := _MIN(High(Word), m_WAbil.MaxHandWeight + m_WAbil.MaxHandWeight);
    end;
    if m_nMoXieSuite > 0 then begin //魔血(减蓝加HP上限)
      if m_WAbil.MaxMP <= m_nMoXieSuite then m_nMoXieSuite := m_WAbil.MaxMP - 1;
      Dec(m_WAbil.MaxMP, m_nMoXieSuite);
      if m_WAbil.MaxHP > High(Integer) - m_nMoXieSuite then begin
        m_WAbil.MaxHP := High(Integer);
      end else m_WAbil.MaxHP := m_WAbil.MaxHP + m_nMoXieSuite;
    end;
    if m_nXieLangSutie > 0 then begin //魔血2一套(增加HP上限) 20100421
      if m_WAbil.MaxHP > High(Integer) - m_nXieLangSutie then begin
        m_WAbil.MaxHP := High(Integer);
      end else m_WAbil.MaxHP := m_WAbil.MaxHP + m_nXieLangSutie;
    end;

    nCode := 17;
    if m_btRaceServer = RC_PLAYOBJECT then begin
      if not TPlayObject(Self).m_boNotOnlineAddExp then
        SendUpdateMsgB(Self, RM_CHARSTATUSCHANGED, m_nHitSpeed, m_nCharStatus, abs(m_nRunSpeed), 0, ''); //更新人物速度及状态 20110825修改
{$IF M2Version <> 2}
      with TPlayObject(self) do begin
        if m_Magic100Skill <> nil then begin //神秘解读
          if (m_Magic100Skill.btLevel > 0) and (m_Magic100Skill.btLevel < 16) then begin
            nIncMaxHP := 0;
            case m_btJob of //按职业增加HP上限
              0: nIncMaxHP := Round(m_Magic100Skill.btLevel * 200); //战,最高增加3000
              1: nIncMaxHP := Round(m_Magic100Skill.btLevel * 60); //法,最高增加900
              2: nIncMaxHP := Round(m_Magic100Skill.btLevel * 140); //道,最高增加2100
            end;
            if nIncMaxHP > 0 then begin
              if m_WAbil.MaxHP > High(Integer) - nIncMaxHP then begin
                m_WAbil.MaxHP := High(Integer);
              end else m_WAbil.MaxHP := m_WAbil.MaxHP + nIncMaxHP;
            end;
          end;
        end;
        if m_nSetupMaxLeveltoHPMP > 0 then begin //根据设置等级数,设置HP MP上限 20100914
          case m_btJob of
            0: begin
                if 14 + Round(((m_nSetupMaxLeveltoHPMP / g_Config.nLevelValueOfWarrHP + g_Config.nLevelValueOfWarrHPRate + m_nSetupMaxLeveltoHPMP / 20) * m_nSetupMaxLeveltoHPMP)) > High(Integer) then begin //20091026 修改
                  m_WAbil.MaxHP := High(Integer);
                end else m_WAbil.MaxHP := 14 + Round(((m_nSetupMaxLeveltoHPMP / g_Config.nLevelValueOfWarrHP + g_Config.nLevelValueOfWarrHPRate + m_nSetupMaxLeveltoHPMP / 20) * m_nSetupMaxLeveltoHPMP));

                if 11 + Round(m_nSetupMaxLeveltoHPMP * 3.5) > High(Integer) then begin
                  m_WAbil.MaxMP := High(Integer);
                end else m_WAbil.MaxMP := 11 + Round(m_nSetupMaxLeveltoHPMP * 3.5);
              end;
            1: begin
                if 14 + Round(((m_nSetupMaxLeveltoHPMP / g_Config.nLevelValueOfWizardHP + g_Config.nLevelValueOfWizardHPRate) * m_nSetupMaxLeveltoHPMP)) > High(Integer) then begin
                  m_WAbil.MaxHP := High(Integer);
                end else m_WAbil.MaxHP := 14 + Round(((m_nSetupMaxLeveltoHPMP / g_Config.nLevelValueOfWizardHP + g_Config.nLevelValueOfWizardHPRate) * m_nSetupMaxLeveltoHPMP));

                if 13 + Round((m_nSetupMaxLeveltoHPMP / 5 + 2) * 2.2 * m_nSetupMaxLeveltoHPMP) > High(Integer) then begin
                  m_WAbil.MaxMP := High(Integer);
                end else m_WAbil.MaxMP := 13 + Round((m_nSetupMaxLeveltoHPMP / 5 + 2) * 2.2 * m_nSetupMaxLeveltoHPMP);
              end;
            2: begin
                if 14 + Round(((m_nSetupMaxLeveltoHPMP / g_Config.nLevelValueOfTaosHP + g_Config.nLevelValueOfTaosHPRate) * m_nSetupMaxLeveltoHPMP)) > High(Integer) then begin //20091026 修改
                  m_WAbil.MaxHP := High(Integer);
                end else m_WAbil.MaxHP := 14 + Round(((m_nSetupMaxLeveltoHPMP / g_Config.nLevelValueOfTaosHP + g_Config.nLevelValueOfTaosHPRate) * m_nSetupMaxLeveltoHPMP));

                if 13 + Round(((m_nSetupMaxLeveltoHPMP / g_Config.nLevelValueOfTaosMP) * 2.2 * m_nSetupMaxLeveltoHPMP)) > High(Integer) then begin //20091026 修改
                  m_WAbil.MaxMP := High(Integer);
                end else m_WAbil.MaxMP := 13 + Round(((m_nSetupMaxLeveltoHPMP / g_Config.nLevelValueOfTaosMP) * 2.2 * m_nSetupMaxLeveltoHPMP));
              end;
          end;
        end;
      end;
{$IFEND}
    end;
    if (m_btRaceServer >= RC_ANIMAL) and (m_btRaceServer <> RC_PLAYMOSTER) and
      (m_btRaceServer <> RC_HEROOBJECT) and (m_btRaceServer <> 135) then begin //20080726 135怪也不刷新能力
      MonsterRecalcAbilitys(); //怪物刷新HP上限及攻击力
    end;

    if m_Magic67Skill <> nil then begin //先天元力增加防御,魔御上限 20080626
      if m_Abil.WineDrinkValue >= abs(m_Abil.MaxAlcohol * g_Config.nMinDrinkValue67 div 100) then begin //酒量大于或等于酒量上限的5%时才有效
        if m_Magic67Skill.btLevel > 0 then begin
          m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC), HiWord(m_WAbil.AC) + m_Magic67Skill.btLevel * (m_Magic67Skill.btLevel + 1)); //20080829 修改
          m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC), HiWord(m_WAbil.MAC) + m_Magic67Skill.btLevel * (m_Magic67Skill.btLevel + 1)); //20080829 修改
        end;
      end;
    end;
    nCode := 18;
{$IF HEROVERSION = 1}
    if m_btRaceServer = RC_HEROOBJECT then begin
      with THeroObject(self) do begin
{$IF M2Version <> 2}
        if m_Magic99Skill <> nil then begin //强身术增加HP上限 20100817
          nIncMaxHP := 0;
          if m_Magic99Skill.btLevel < 100 then begin
            case m_btJob of //按职业增加HP上限
              0: nIncMaxHP := _MIN(10000, 156 + Round(142 * m_Magic99Skill.btLevel - (((m_Magic99Skill.btLevel - 1) / 2) * m_Magic99Skill.btLevel + 1))); //战,最高增加10000
              1: begin
                  if m_Magic99Skill.btLevel <= 10 then
                    nIncMaxHP := _MIN(2500, 39 + Round(41 * m_Magic99Skill.btLevel - (((m_Magic99Skill.btLevel - 1) / 2) * m_Magic99Skill.btLevel + 1))) //法,最高增加2500
                  else nIncMaxHP := _MIN(2500, 403 + 23 * m_Magic99Skill.btLevel);
                end;
              2: nIncMaxHP := _MIN(6500, 110 + Round(109 * m_Magic99Skill.btLevel - (((m_Magic99Skill.btLevel - 1) / 2) * m_Magic99Skill.btLevel + 1))); //道,最高增加6500
            end;
            if nIncMaxHP > 0 then begin
              if m_WAbil.MaxHP > High(Integer) - nIncMaxHP then begin
                m_WAbil.MaxHP := High(Integer);
              end else m_WAbil.MaxHP := m_WAbil.MaxHP + nIncMaxHP;
            end;
          end;
        end;
{$IFEND}
        if m_boRevengeMode then begin //复仇模式
          if m_wSnapArrValue[0] > 0 then begin //生命
            if m_WAbil.MaxHP > High(Integer) - m_wSnapArrValue[0] then begin
              m_WAbil.MaxHP := High(Integer);
            end else m_WAbil.MaxHP := m_WAbil.MaxHP + m_wSnapArrValue[0];
          end;

          if m_wSnapArrValue[1] > 0 then begin //魔法值
            if m_WAbil.MaxMP + m_wSnapArrValue[1] > High(Integer) then begin
              m_WAbil.MaxMP := High(Integer);
            end else m_WAbil.MaxMP := m_WAbil.MaxMP + m_wSnapArrValue[1];
          end;

          if m_wSnapArrValue[2] > 0 then //防御上下限
            m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC) + m_wSnapArrValue[2], HiWord(m_WAbil.AC) + m_wSnapArrValue[2]);

          if m_wSnapArrValue[3] > 0 then //魔防上下限
            m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC) + m_wSnapArrValue[3], HiWord(m_WAbil.MAC) + m_wSnapArrValue[3]);

          if m_wSnapArrValue[4] > 0 then //攻击力,同时增加上限和下限
            m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC) + m_wSnapArrValue[4], HiWord(m_WAbil.DC) + m_wSnapArrValue[4]);

          if m_wSnapArrValue[5] > 0 then //魔法力,同时增加上限和下限
            m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC) + m_wSnapArrValue[5], HiWord(m_WAbil.MC) + m_wSnapArrValue[5]);

          if m_wSnapArrValue[6] > 0 then //道术,同时增加上限和下限
            m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC) + m_wSnapArrValue[6], HiWord(m_WAbil.SC) + m_wSnapArrValue[6]);
        end;
      end;
    end;
{$IFEND}
{$IF M2Version <> 2}
    case m_btRaceServer of
      RC_PLAYMOSTER: begin
          if (m_Master <> nil) then begin //分身支持强身术，神秘解读增加HP处理 20100928
            with TPlayMonster(self) do begin
              if m_Magic99Skill <> nil then begin //强身术增加HP上限
                nIncMaxHP := 0;
                if m_Magic99Skill.btLevel < 100 then begin
                  case m_btJob of //按职业增加HP上限
                    0: nIncMaxHP := _MIN(10000, 156 + Round(142 * m_Magic99Skill.btLevel - (((m_Magic99Skill.btLevel - 1) / 2) * m_Magic99Skill.btLevel + 1))); //战,最高增加10000
                    1: begin
                        if m_Magic99Skill.btLevel <= 10 then
                          nIncMaxHP := _MIN(2500, 39 + Round(41 * m_Magic99Skill.btLevel - (((m_Magic99Skill.btLevel - 1) / 2) * m_Magic99Skill.btLevel + 1))) //法,最高增加2500
                        else nIncMaxHP := _MIN(2500, 403 + 23 * m_Magic99Skill.btLevel);
                      end;
                    2: nIncMaxHP := _MIN(6500, 110 + Round(109 * m_Magic99Skill.btLevel - (((m_Magic99Skill.btLevel - 1) / 2) * m_Magic99Skill.btLevel + 1))); //道,最高增加6500
                  end;
                  if nIncMaxHP > 0 then begin
                    if m_WAbil.MaxHP > High(Integer) - nIncMaxHP then begin
                      m_WAbil.MaxHP := High(Integer);
                    end else m_WAbil.MaxHP := m_WAbil.MaxHP + nIncMaxHP;
                  end;
                end;
              end;
              if m_Magic100Skill <> nil then begin //神秘解读
                if (m_Magic100Skill.btLevel > 0) and (m_Magic100Skill.btLevel < 16) then begin
                  nIncMaxHP := 0;
                  case m_btJob of //按职业增加HP上限
                    0: nIncMaxHP := Round(m_Magic100Skill.btLevel * 200); //战,最高增加3000
                    1: nIncMaxHP := Round(m_Magic100Skill.btLevel * 60); //法,最高增加900
                    2: nIncMaxHP := Round(m_Magic100Skill.btLevel * 140); //道,最高增加2100
                  end;
                  if nIncMaxHP > 0 then begin
                    if m_WAbil.MaxHP > High(Integer) - nIncMaxHP then begin
                      m_WAbil.MaxHP := High(Integer);
                    end else m_WAbil.MaxHP := m_WAbil.MaxHP + nIncMaxHP;
                  end;
                end;
              end;
            end;
          end;
        end;
      RC_PLAYOBJECT: begin
          if TPLAYOBJECT(Self).m_boCanTitle then begin //称号属性
            if FengHaoAbility.wDC > 0 then //攻击力 上限
              m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_WAbil.DC) + FengHaoAbility.wDC);
            if FengHaoAbility.wMC > 0 then //魔法 上限
              m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC), HiWord(m_WAbil.MC) + FengHaoAbility.wMC);
            if FengHaoAbility.wSC > 0 then //道术 上限
              m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), HiWord(m_WAbil.SC) + FengHaoAbility.wSC);

            if FengHaoAbility.wUnParalysisRate > 0 then //麻痹抗性(辉煌衣服)
              m_nUnParalysisRate := _MIN(High(Word), m_nUnParalysisRate + FengHaoAbility.wUnParalysisRate); //防麻机率(辉煌衣服)
            if FengHaoAbility.wParalysisAddRate > 0 then //麻痹抗性(辉煌衣服)
              m_nParalysisAddRate := _MIN(High(Word), m_nParalysisAddRate + FengHaoAbility.wParalysisAddRate); //防麻强化(军鼓等等)  add by liuzhigang on 2011.12.31

            if FengHaoAbility.wHP > 0 then begin //增加生命上限
              if m_WAbil.MaxHP > (High(Integer) - FengHaoAbility.wHP) then begin
                m_WAbil.MaxHP := High(Integer);
              end else m_WAbil.MaxHP := m_WAbil.MaxHP + FengHaoAbility.wHP;
            end;
            case m_btJob of //按职业增加属性
              0: begin //战
                  if FengHaoAbility.wMagicShieldLevel > 0 then begin //聚魔等级(加蓝，职业不同加的魔法上限应该是不同)
                    if m_WAbil.MaxMP > (High(Integer) - (FengHaoAbility.wMagicShieldLevel * 20)) then begin
                      m_WAbil.MaxMP := High(Integer);
                    end else m_WAbil.MaxMP := m_WAbil.MaxMP + (FengHaoAbility.wMagicShieldLevel * 20);
                  end;
                  if FengHaoAbility.wPhysicalLevel > 0 then begin //强身等级(加血，职业不同加的血量不同 战+50 法+20 道+35)
                    if m_WAbil.MaxHP > (High(Integer) - (FengHaoAbility.wPhysicalLevel * 50)) then begin
                      m_WAbil.MaxHP := High(Integer);
                    end else m_WAbil.MaxHP := m_WAbil.MaxHP + (FengHaoAbility.wPhysicalLevel * 50);
                  end;
                end;
              1: begin //法
                  if FengHaoAbility.wMagicShieldLevel > 0 then begin //聚魔等级(加蓝，职业不同加的魔法上限应该是不同)
                    if m_WAbil.MaxMP > (High(Integer) - (FengHaoAbility.wMagicShieldLevel * 50)) then begin
                      m_WAbil.MaxMP := High(Integer);
                    end else m_WAbil.MaxMP := m_WAbil.MaxMP + (FengHaoAbility.wMagicShieldLevel * 50);
                  end;
                  if FengHaoAbility.wPhysicalLevel > 0 then begin //强身等级(加血，职业不同加的血量不同 战+50 法+20 道+35)
                    if m_WAbil.MaxHP > (High(Integer) - (FengHaoAbility.wPhysicalLevel * 20)) then begin
                      m_WAbil.MaxHP := High(Integer);
                    end else m_WAbil.MaxHP := m_WAbil.MaxHP + (FengHaoAbility.wPhysicalLevel * 20);
                  end;
                end;
              2: begin //道
                  if FengHaoAbility.wMagicShieldLevel > 0 then begin //聚魔等级(加蓝，职业不同加的魔法上限应该是不同)
                    if m_WAbil.MaxMP > (High(Integer) - (FengHaoAbility.wMagicShieldLevel * 35)) then begin
                      m_WAbil.MaxMP := High(Integer);
                    end else m_WAbil.MaxMP := m_WAbil.MaxMP + (FengHaoAbility.wMagicShieldLevel * 35);
                  end;
                  if FengHaoAbility.wPhysicalLevel > 0 then begin //强身等级(加血，职业不同加的血量不同 战+50 法+20 道+35)
                    if m_WAbil.MaxHP > (High(Integer) - (FengHaoAbility.wPhysicalLevel * 35)) then begin
                      m_WAbil.MaxHP := High(Integer);
                    end else m_WAbil.MaxHP := m_WAbil.MaxHP + (FengHaoAbility.wPhysicalLevel * 35);
                  end;
                end;
            end;
          end;
        end;
    end;
{$IFEND}
    if m_wStatusTimeArr[POISON_LOCK1] > 0 then begin //敌对目标的防御和魔防减到0(唯我独尊)
      m_WAbil.AC := 0;
      m_WAbil.MAC := 0;
    end;

  //限制最高属性
    m_WAbil.AC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.AC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.AC)));
    m_WAbil.MAC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.MAC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.MAC)));
    m_WAbil.DC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.DC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.DC)));
    m_WAbil.MC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.MC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.MC)));
    m_WAbil.SC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.SC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.SC)));
    //减去心法增加的道术 By TasNat at: 2012-03-06 16:08:19
    //无极真气不考虑套装效果
{$IF M2Version <> 2}
    //if m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT] then
    if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) then       
    begin

      ShangHaiValue := 0;
      XiXueValue := 0;
      BingDongKangXing := 0;
      I := Low(m_UseItems);
      while I < U_ARMRINGL do
      begin
        StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
        if StdItem <> nil then
        begin
          if (StdItem.Shape in [188, 203]) and (StdItem.Source > 0) then begin
            ShangHaiValue := ShangHaiValue + StdItem.Source;
            {
            if StdItem.Source > ShangHaiValue then//修改伤害吸收不累加 By TasNat at: 2012-04-26 15:09:43
              ShangHaiValue := StdItem.Source;       }
          end;

          if (StdItem.Shape = 193) and (m_Abil.Level >= StdItem.NeedLevel) and (StdItem.Stock > 0) then
            XiXueValue := XiXueValue + StdItem.Stock;
        end;
        Inc(I);
      end;
      ShangHaiValue1 := 0;
      ShangHaiValue2 := 0;
      StdItem := UserEngine.GetStdItem(m_UseItems[U_ARMRINGL].wIndex);
      if StdItem <> nil then begin
        if (StdItem.Shape = 193) and (m_Abil.Level >= StdItem.NeedLevel) and (StdItem.Stock > 0) then
            XiXueValue := XiXueValue + StdItem.Stock;
        if (StdItem.Shape in [188, 203]) and (StdItem.Source > 0) then
          ShangHaiValue1 := StdItem.Source;
      end;

      StdItem := UserEngine.GetStdItem(m_UseItems[U_ARMRINGR].wIndex);
      if StdItem <> nil then begin
        if (StdItem.Shape = 193) and (m_Abil.Level >= StdItem.NeedLevel) and (StdItem.Stock > 0) then
            XiXueValue := XiXueValue + StdItem.Stock;
        if (StdItem.Shape in [188, 203]) and (StdItem.Source > 0) then
          ShangHaiValue2 := StdItem.Source;
      end;
      if g_Config.boOneRingXiXue then
        ShangHaiValue1 := _Max(ShangHaiValue1, ShangHaiValue2)
      else
        ShangHaiValue1 := ShangHaiValue1 + ShangHaiValue2;
      ShangHaiValue := ShangHaiValue + ShangHaiValue1;
      ShangHaiValue1 := 0;
      ShangHaiValue2 := 0;
      StdItem := UserEngine.GetStdItem(m_UseItems[U_RINGL].wIndex);
      if StdItem <> nil then begin
        if (StdItem.Shape = 193) and (m_Abil.Level >= StdItem.NeedLevel) and (StdItem.Stock > 0) then
            XiXueValue := XiXueValue + StdItem.Stock;
        if (StdItem.Shape in [188, 203]) and (StdItem.Source > 0) then
          ShangHaiValue1 := StdItem.Source;
      end;

      StdItem := UserEngine.GetStdItem(m_UseItems[U_RINGR].wIndex);
      if StdItem <> nil then begin
        if (StdItem.Shape = 193) and (m_Abil.Level >= StdItem.NeedLevel) and (StdItem.Stock > 0) then
            XiXueValue := XiXueValue + StdItem.Stock;
        if (StdItem.Shape in [188, 203]) and (StdItem.Source > 0) then
          ShangHaiValue2 := StdItem.Source;
      end;
      if g_Config.boOneRingXiXue then      
        ShangHaiValue1 := _Max(ShangHaiValue1, ShangHaiValue2)
      else
        ShangHaiValue1 := ShangHaiValue1 + ShangHaiValue2;
      ShangHaiValue := ShangHaiValue + ShangHaiValue1;


      I := U_BUJUK;
      while I <= High(m_UseItems) do
      begin
        StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
        if StdItem <> nil then
        begin
          if (StdItem.Shape in [188, 203]) and (StdItem.Source > 0) then begin
            ShangHaiValue := ShangHaiValue + StdItem.Source;
          end;

          if (StdItem.Shape = 193) and (m_Abil.Level >= StdItem.NeedLevel) and (StdItem.Stock > 0) then
            XiXueValue := XiXueValue + StdItem.Stock;
        end;
        Inc(I);
      end;


      //修复异常的写入导致N多错误 By TasNat at: 2012-04-05 17:06:51

      if m_btRaceServer = RC_PLAYOBJECT then
      with TPlayObject(Self) do begin
        ClientSuitAbility.nShangHaiXiShou := ShangHaiValue;
        ClientSuitAbility.nGongJiSuDu := m_nHitSpeed;
        ClientSuitAbility.nGongJiXiXue := XiXueValue;
        ClientSuitAbility.nQiangShenDengJi := AddUnKnowAbility.wPhysicalLevel;
        ClientSuitAbility.nJuMoDengJi := AddUnKnowAbility.wMagicShieldLevel;
        ClientSuitAbility.nBaoJiDengJi := m_boArmsCritPoint;
        ClientSuitAbility.nNeiShangDengJi := AddUnKnowAbility.wDecTargetNHLevel;
        ClientSuitAbility.nHeJiWeiLi := m_nIncDragonRate;
        ClientSuitAbility.nIncDragon := m_nIncDragon;//修复合击威力叠加 By TasNat at: 2012-04-30 13:15:37
        ClientSuitAbility.nBingDongKangXing := BingDongKangXing;
      end else with THeroObject(Self) do begin //这里可以用什么else注意 上面有 检测
        ClientSuitAbility.nShangHaiXiShou := ShangHaiValue;
        ClientSuitAbility.nGongJiSuDu := m_nHitSpeed;
        ClientSuitAbility.nGongJiXiXue := XiXueValue;
        ClientSuitAbility.nQiangShenDengJi := AddUnKnowAbility.wPhysicalLevel;
        ClientSuitAbility.nJuMoDengJi := AddUnKnowAbility.wMagicShieldLevel;
        ClientSuitAbility.nBaoJiDengJi := m_boArmsCritPoint;
        ClientSuitAbility.nNeiShangDengJi := AddUnKnowAbility.wDecTargetNHLevel;
        ClientSuitAbility.nHeJiWeiLi := m_nIncDragonRate;
        ClientSuitAbility.nIncDragon := m_nIncDragon;
        ClientSuitAbility.nBingDongKangXing := BingDongKangXing;
      end;

    end;
{$IFEND}
  except
    MainOutMessage(Format('{%s} TBaseObject.RecalcAbilitys Code:%d.%p', [g_sExceptionVer, nCode, ExceptAddr]));
  end;
end;

procedure TBaseObject.BreakOpenHealth();
begin
  if m_boShowHP then begin
    m_boShowHP := False;
    m_nCharStatusEx := m_nCharStatusEx xor STATE_OPENHEATH;
    m_nCharStatus := GetCharStatus();
    SendRefMsg(RM_CLOSEHEALTH, 0, 0, 0, 0, '');
  end;
end;

procedure TBaseObject.MakeOpenHealth();
begin
  m_boShowHP := True;
  m_nCharStatusEx := m_nCharStatusEx or STATE_OPENHEATH;
  m_nCharStatus := GetCharStatus();
  SendRefMsg(RM_OPENHEALTH, 0, m_WAbil.HP, m_WAbil.MaxHP, 0, '');
end;
//增加HP,MP

procedure TBaseObject.IncHealthSpell(nHP, nMP: Integer);
begin
  if (nHP < 0) or (nMP < 0) then Exit;
  if (m_WAbil.HP + nHP) >= m_WAbil.MaxHP then m_WAbil.HP := m_WAbil.MaxHP
  else Inc(m_WAbil.HP, nHP);
  if (m_WAbil.MP + nMP) >= m_WAbil.MaxMP then m_WAbil.MP := m_WAbil.MaxMP
  else Inc(m_WAbil.MP, nMP);
  HealthSpellChanged();
end;
//复活戒指生效，体力恢复

procedure TBaseObject.ItemDamageRevivalRing();
var
  I: Integer;
  pSItem: pTStdItem;
  nDura, tDura: Integer;
  PlayObject: TPlayObject;
begin
  for I := {$IF M2Version <> 2}High(THumanUseItems) downto Low(THumanUseItems){$ELSE}High(THumItems) downto Low(THumItems){$IFEND} do begin //9格装备+4格装备(倒循环，先优先减戒指，再到手 20110118)
    if (m_UseItems[I].wIndex > 0) and ((m_UseItems[I].Dura > 0) or g_Config.boItmeAutoOver) then begin
      pSItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
      if pSItem <> nil then begin
        if (pSItem.Shape in [114, 160, 161, 162]) or (((I = U_WEAPON) or (I = U_RIGHTHAND)) and (pSItem.AniCount in [114, 160, 161, 162])) then begin
          nDura := m_UseItems[I].Dura;
          tDura := Round(nDura / 1000 {1.03});
          Dec(nDura, 1000);
          if nDura <= 0 then begin
            nDura := 0;
            m_UseItems[I].Dura := nDura;
            if g_Config.boItmeAutoOver then begin //20110117 持久0物品不消失
              if m_btRaceServer = RC_PLAYOBJECT then begin
                PlayObject := TPlayObject(Self);
                PlayObject.SendDelItems(@m_UseItems[I]);
              end;
              if pSItem.NeedIdentify = 1 then //20090502 使用复活，物品消息记录日志
                AddGameDataLog('6' + #9 + m_sMapName + #9 +
                  IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                  m_sCharName + #9 + pSItem.Name + #9 +
                  IntToStr(m_UseItems[I].MakeIndex) + #9 +
                  '(' + IntToStr(LoWord(pSItem.DC)) + '/' + IntToStr(HiWord(pSItem.DC)) + ')' +
                  '(' + IntToStr(LoWord(pSItem.MC)) + '/' + IntToStr(HiWord(pSItem.MC)) + ')' +
                  '(' + IntToStr(LoWord(pSItem.SC)) + '/' + IntToStr(HiWord(pSItem.SC)) + ')' +
                  '(' + IntToStr(LoWord(pSItem.AC)) + '/' + IntToStr(HiWord(pSItem.AC)) + ')' +
                  '(' + IntToStr(LoWord(pSItem.MAC)) + '/' + IntToStr(HiWord(pSItem.MAC)) + ')' +
                  IntToStr(m_UseItems[I].btValue[0]) + '/' + IntToStr(m_UseItems[I].btValue[1]) + '/' + IntToStr(m_UseItems[I].btValue[2]) + '/' +
                  IntToStr(m_UseItems[I].btValue[3]) + '/' + IntToStr(m_UseItems[I].btValue[4]) + '/' + IntToStr(m_UseItems[I].btValue[5]) + '/' +
                  IntToStr(m_UseItems[I].btValue[6]) + '/' + IntToStr(m_UseItems[I].btValue[7]) + '/' + IntToStr(m_UseItems[I].btValue[8]) + '/' +
                  IntToStr(m_UseItems[I].btValue[14]) + #9 + '持久耗尽');
              m_UseItems[I].wIndex := 0;
            end;
            RecalcAbilitys();
            CompareSuitItem(False);
          end else begin
            m_UseItems[I].Dura := nDura;
          end;
          if tDura <> Round(nDura / 1000 {1.03}) then begin
            SendMsg(Self, RM_DURACHANGE, I, nDura, m_UseItems[I].DuraMax, 0, '');
          end;
          break; //20110118 恢复注释(修正当有同种属性的不同位置物品时，全减持久)
        end;
      end; //if pSItem <> nil then begin
    end; //if UseItems[i].wIndex > 0 then begin
  end; // for i:=Low(UseItems) to High(UseItems) do begin
end;
//重生戒指生效，减物品持久 20100720

procedure TBaseObject.RebirthItemDecDura();
var
  I, K: Integer;
  pSItem: pTStdItem;
  nDura, tDura: Integer;
  PlayObject: TPlayObject;
begin
  for I := Low(THumanUseItems) to High(THumanUseItems) do begin //9格装备+4格装备
    if (m_UseItems[I].wIndex > 0) and ((m_UseItems[I].Dura > 0) or g_Config.boItmeAutoOver) then begin
      pSItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
      if pSItem <> nil then begin
        if ((pSItem.Shape = 197) and (pSItem.StdMode in [19..24, 26..29])) or //重生戒指 20110922修改
          ((pSItem.AniCount = 202) and ((I = U_WEAPON) or (I = U_RIGHTHAND))) then begin //球王勋章
          nDura := m_UseItems[I].Dura;
          tDura := Round(nDura / 1000 {1.03});
          Dec(nDura, 1000);
          if nDura <= 0 then begin
            nDura := 0;
            m_UseItems[I].Dura := nDura;
            if g_Config.boItmeAutoOver then begin //20110117 持久0物品不消失
              if m_btRaceServer = RC_PLAYOBJECT then begin
                PlayObject := TPlayObject(Self);
                PlayObject.SendDelItems(@m_UseItems[I]);
              end;
              if pSItem.NeedIdentify = 1 then //物品消失记录日志
                AddGameDataLog('6' + #9 + m_sMapName + #9 +
                  IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                  m_sCharName + #9 + pSItem.Name + #9 +
                  IntToStr(m_UseItems[I].MakeIndex) + #9 +
                  '(' + IntToStr(LoWord(pSItem.DC)) + '/' + IntToStr(HiWord(pSItem.DC)) + ')' +
                  '(' + IntToStr(LoWord(pSItem.MC)) + '/' + IntToStr(HiWord(pSItem.MC)) + ')' +
                  '(' + IntToStr(LoWord(pSItem.SC)) + '/' + IntToStr(HiWord(pSItem.SC)) + ')' +
                  '(' + IntToStr(LoWord(pSItem.AC)) + '/' + IntToStr(HiWord(pSItem.AC)) + ')' +
                  '(' + IntToStr(LoWord(pSItem.MAC)) + '/' + IntToStr(HiWord(pSItem.MAC)) + ')' +
                  IntToStr(m_UseItems[I].btValue[0]) + '/' + IntToStr(m_UseItems[I].btValue[1]) + '/' + IntToStr(m_UseItems[I].btValue[2]) + '/' +
                  IntToStr(m_UseItems[I].btValue[3]) + '/' + IntToStr(m_UseItems[I].btValue[4]) + '/' + IntToStr(m_UseItems[I].btValue[5]) + '/' +
                  IntToStr(m_UseItems[I].btValue[6]) + '/' + IntToStr(m_UseItems[I].btValue[7]) + '/' + IntToStr(m_UseItems[I].btValue[8]) + '/' +
                  IntToStr(m_UseItems[I].btValue[14]) + #9 + '持久耗尽');
              m_UseItems[I].wIndex := 0;
            end;
            RecalcAbilitys();
            CompareSuitItem(False); //200080729 套装
          end else m_UseItems[I].Dura := nDura;
          if tDura <> Round(nDura / 1000 {1.03}) then begin
            SendMsg(Self, RM_DURACHANGE, I, nDura, m_UseItems[I].DuraMax, 0, '');
          end;
          break;
        end;
{$IF M2Version <> 2}
        if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) then begin //人物和英雄才执行
          if (m_UseItems[I].btAppraisalLevel in [2..4, 12..14, 22..24, 32..34, 42..44, 52..54]) or
            ((m_UseItems[I].btUnKnowValueCount > 0) and (m_UseItems[I].btUnKnowValueCount < 5)) then begin //鉴定过的,或有神秘属性的
            if (m_UseItems[I].Dura > 0) or g_Config.boItmeAutoOver then begin
              for K := 6 to 9 do begin
                if m_UseItems[I].btUnKnowValue[K] = 1 then begin //重生技能
                  nDura := m_UseItems[I].Dura;
                  tDura := Round(nDura / 1000 {1.03});
                  Dec(nDura, 1000);
                  if nDura <= 0 then begin
                    nDura := 0;
                    m_UseItems[I].Dura := nDura;
                    if g_Config.boItmeAutoOver then begin //20110117 持久0物品不消失
                      if m_btRaceServer = RC_PLAYOBJECT then begin
                        PlayObject := TPlayObject(Self);
                        PlayObject.SendDelItems(@m_UseItems[I]);
                      end;
                      if pSItem.NeedIdentify = 1 then //物品消失记录日志
                        AddGameDataLog('6' + #9 + m_sMapName + #9 +
                          IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                          m_sCharName + #9 + pSItem.Name + #9 +
                          IntToStr(m_UseItems[I].MakeIndex) + #9 +
                          '(' + IntToStr(LoWord(pSItem.DC)) + '/' + IntToStr(HiWord(pSItem.DC)) + ')' +
                          '(' + IntToStr(LoWord(pSItem.MC)) + '/' + IntToStr(HiWord(pSItem.MC)) + ')' +
                          '(' + IntToStr(LoWord(pSItem.SC)) + '/' + IntToStr(HiWord(pSItem.SC)) + ')' +
                          '(' + IntToStr(LoWord(pSItem.AC)) + '/' + IntToStr(HiWord(pSItem.AC)) + ')' +
                          '(' + IntToStr(LoWord(pSItem.MAC)) + '/' + IntToStr(HiWord(pSItem.MAC)) + ')' +
                          IntToStr(m_UseItems[I].btValue[0]) + '/' + IntToStr(m_UseItems[I].btValue[1]) + '/' + IntToStr(m_UseItems[I].btValue[2]) + '/' +
                          IntToStr(m_UseItems[I].btValue[3]) + '/' + IntToStr(m_UseItems[I].btValue[4]) + '/' + IntToStr(m_UseItems[I].btValue[5]) + '/' +
                          IntToStr(m_UseItems[I].btValue[6]) + '/' + IntToStr(m_UseItems[I].btValue[7]) + '/' + IntToStr(m_UseItems[I].btValue[8]) + '/' +
                          IntToStr(m_UseItems[I].btValue[14]) + #9 + '持久耗尽');
                      m_UseItems[I].wIndex := 0;
                    end;
                    RecalcAbilitys();
                    CompareSuitItem(False); //套装
                  end else m_UseItems[I].Dura := nDura;
                  if tDura <> Round(nDura / 1000) then SendMsg(Self, RM_DURACHANGE, I, nDura, m_UseItems[I].DuraMax, 0, '');
                  Exit;
                end;
              end; //for K:=
            end;
          end;
        end;
{$IFEND}
      end; //if pSItem <> nil then begin
    end; //if UseItems[i].wIndex > 0 then begin
  end; // for i:=Low(UseItems) to High(UseItems) do begin
end;

procedure TBaseObject.Run;
var
  I: Integer;
  boChg: Boolean;
  boNeedRecalc: Boolean;
  nHP, nMP, n18: Integer;
  dwC, dwInChsTime: LongWord;
  ProcessMsg: TProcessMessage;
  BaseObject: TBaseObject;
  nCheckCode, nReviealMode: Byte;
  dwRunTick: LongWord;
  nInteger: Integer;
  boChangeColor: Boolean;
  Castle: TUserCastle;
  FlowerEvent: TFlowerEvent;
resourcestring
  sExceptionMsg0 = '{%s} TBaseObject::Run 0.%p';
  sExceptionMsg1 = '{%s} TBaseObject::Run 1.%p %d %d';
  sExceptionMsg2 = '{%s} TBaseObject::Run 2.%p';
  sExceptionMsg3 = '{%s} TBaseObject::Run 3.%p Code:%d Name:%s';
  sExceptionMsg4 = '{%s} TBaseObject::Run 4.%p Code:%d';
  sExceptionMsg5 = '{%s} TBaseObject::Run 5.%p Code:%d';
  sExceptionMsg6 = '{%s} TBaseObject::Run 6.%p Code:%d';
begin
  nCheckCode := 0;
  dwRunTick := GetTickCount();
  try
    while GetMessage(@ProcessMsg) do begin
      Operate(@ProcessMsg);
    end;
  except                                   
    MainOutMessage(Format(sExceptionMsg0, [g_sExceptionVer, ExceptAddr]));
  end;

  try
    nCheckCode := 200;
    //减少无视麻痹的时间 By TasNat at: 2012-04-23 18:52:52
    if (m_btUnParalysis > 0) and (GetTickCount - m_dwDecUnParalysisTick > 1000) then begin
      Dec(m_btUnParalysis);
      m_dwDecUnParalysisTick := GetTickCount;
    end;
    if m_boSuperMan then begin //无敌模式
      m_WAbil.HP := m_WAbil.MaxHP;
      m_WAbil.MP := m_WAbil.MaxMP;
    end;
    if ((nCrackedLevel <> 0) or (nErrorLevel <> 0)) and (dwStartTime > 36000 {60 * 60 * 10}) then begin //破解后运行10小时后,所有角色无敌
      m_WAbil.HP := m_WAbil.MaxHP;
      m_WAbil.MP := m_WAbil.MaxMP;
    end;
    dwC := (GetTickCount() - m_dwHPMPTick) div 20;
    m_dwHPMPTick := GetTickCount();

    n18 := dwC * (1 + m_nHealthRecover); //20090204 体力恢复
    Inc(m_nHealthTick, n18);
    n18 := dwC * (1 + m_nSpellRecover); //20090204 魔法恢复
    Inc(m_nSpellTick, n18);
    nCheckCode := 201;
    if not m_boDeath then begin
      if (m_WAbil.HP < m_WAbil.MaxHP) and (m_nHealthTick >= g_Config.nHealthFillTime) then begin //不断增加HP值
        n18 := (m_WAbil.MaxHP div 75) + 1;
        if (m_WAbil.HP + n18) < m_WAbil.MaxHP then begin
          Inc(m_WAbil.HP, n18);
        end else begin
          m_WAbil.HP := m_WAbil.MaxHP;
        end;
        nCheckCode := 3;
        HealthSpellChanged;
      end;
      nCheckCode := 202;
      if (m_WAbil.MP < m_WAbil.MaxMP) and (m_nSpellTick >= g_Config.nSpellFillTime) and (m_wStatusTimeArr[POISON_SKILLDECHEALTH] <= 0) then begin //不断增加MP值,中万剑归宗时不回MP值 20110115
        n18 := (m_WAbil.MaxMP div 18) + 1;
        if (m_WAbil.MP + n18) < m_WAbil.MaxMP then begin
          Inc(m_WAbil.MP, n18);
        end else begin
          m_WAbil.MP := m_WAbil.MaxMP;
        end;
        HealthSpellChanged;
      end;
      nCheckCode := 203;
      if m_WAbil.HP = 0 then begin
        nReviealMode := 0;
        if m_LastHiter = nil then begin
          if m_boRevival and (GetTickCount - m_dwRevivalTick > g_Config.dwRevivalTime {60 * 1000}) then begin
            nReviealMode := 1;
            m_dwRevivalTick := GetTickCount();
            nCheckCode := 9;
            m_WAbil.HP := m_WAbil.MaxHP;
            nCheckCode := 10;
            case m_btRaceServer of
              RC_PLAYOBJECT: begin
                  nCheckCode := 5;
                  ItemDamageRevivalRing; //复活戒指生效，体力恢复 20091110 换位置
                  SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
                  SysMsg(g_sRevivalRecoverMsg {'复活戒指生效，体力恢复'}, c_Green, t_Hint);
{$IF M2Version <> 2}
                  TPLAYOBJECT(self).m_nDieCount := _MIN(High(Byte), TPLAYOBJECT(self).m_nDieCount + 1);
{$IFEND}
                end;
              RC_HEROOBJECT: begin
                  nCheckCode := 26;
                  THeroObject(self).ItemDamageRevivalRing; //复活戒指生效，体力恢复 20110118 修改
                  THeroObject(self).SendMsg(self, RM_HEROABILITY, 0, 0, 0, 0, ''); //发送英雄属性  20090210
                  THeroObject(self).SysMsg(g_sRevivalRecoverMsg {'复活戒指生效，体力恢复'}, c_Green, t_Hint);
{$IF M2Version <> 2}
                  if (m_Master <> nil) then begin
                    if not m_Master.m_boGhost then
                      TPlayObject(m_Master).m_nDieCount := _MIN(High(Byte), TPlayObject(m_Master).m_nDieCount + 1);
                  end;
{$IFEND}
                end;
              RC_PLAYMOSTER: begin
                  ItemDamageRevivalRing; //复活戒指生效，体力恢复
                end;
            end;
            if g_Config.boUnderWarMove and (m_btRaceServer = RC_PLAYOBJECT) then begin //攻城期复活传送回攻方复活点
              Castle := g_CastleManager.InCastleWarArea(Self);
              if (Castle <> nil) then begin
                if Castle.m_boUnderWar then begin //攻城中
                  if (m_PEnvir = Castle.m_MapPalace) then begin //皇宫
                    TPLAYOBJECT(self).BaseObjectMove(Castle.m_sWarAreaHomeMap, IntToStr(Castle.m_nWarAreaHomeX), IntToStr(Castle.m_nWarAreaHomeY));
                  end;
                end;
              end;
            end;
          end else
            if m_boRebirth and (GetTickCount - m_dwRebirthTick > g_Config.dwRebirthTime) then begin //重生戒指
              nReviealMode := 2;
              m_dwRebirthTick := GetTickCount();
              nCheckCode := 17;
              m_WAbil.HP := m_WAbil.MaxHP;
              m_WAbil.MP := m_WAbil.MaxMP;
              nCheckCode := 18;
              case m_btRaceServer of
                RC_PLAYOBJECT: begin
                    nCheckCode := 19;
                    RebirthItemDecDura; //重生戒指生效，减物品持久
                    SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
                    SysMsg(g_sRebirthRecoverMsg {'重生戒指生效，体力和魔法恢复.'}, c_Green, t_Hint);
{$IF M2Version <> 2}
                    TPLAYOBJECT(self).m_nDieCount := _MIN(High(Byte), TPLAYOBJECT(self).m_nDieCount + 1);
{$IFEND}
                  end;
                RC_HEROOBJECT: begin
                    nCheckCode := 20;
                    THeroObject(self).RebirthItemDecDura; //重生戒指生效，减物品持久 20110118 修改
                    THeroObject(self).SendMsg(self, RM_HEROABILITY, 0, 0, 0, 0, ''); //发送英雄属性
                    THeroObject(self).SysMsg(g_sRebirthRecoverMsg {'重生戒指生效，体力和魔法恢复.'}, c_Green, t_Hint);
{$IF M2Version <> 2}
                    if (m_Master <> nil) then begin
                      if not m_Master.m_boGhost then
                        TPlayObject(m_Master).m_nDieCount := _MIN(High(Byte), TPlayObject(m_Master).m_nDieCount + 1);
                    end;
{$IFEND}
                  end;
                RC_PLAYMOSTER: begin
                    RebirthItemDecDura; //重生戒指生效，减物品持久
                  end;
              end;
              if g_Config.boUnderWarMove and (m_btRaceServer = RC_PLAYOBJECT) then begin //攻城期复活传送回攻方复活点
                Castle := g_CastleManager.InCastleWarArea(Self);
                if (Castle <> nil) then begin
                  if Castle.m_boUnderWar then begin //攻城中
                    if (m_PEnvir = Castle.m_MapPalace) then begin //皇宫
                      TPLAYOBJECT(self).BaseObjectMove(Castle.m_sWarAreaHomeMap, IntToStr(Castle.m_nWarAreaHomeX), IntToStr(Castle.m_nWarAreaHomeY));
                    end;
                  end;
                end;
              end;
            end;
          if (m_boRevival or m_boRebirth) and (not m_boAI) then begin //20101126 增加复活日志
            case nReviealMode of
              0: begin //时间未到
                  AddGameDataLog('19' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                    m_sCharName + #9 + '未复活或重生' + #9 + '2' + #9 + '1' + #9 + '时间未到');
                end;
              1: begin //复活生效
                  AddGameDataLog('19' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                    m_sCharName + #9 + '复活生效' + #9 + '2' + #9 + '1' + #9 + '');
                end;
              2: begin //重生生效
                  AddGameDataLog('19' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                    m_sCharName + #9 + '重生生效' + #9 + '2' + #9 + '1' + #9 + '');
                end;
            end;
          end;
        end else
          if m_LastHiter <> nil then begin
            if not m_LastHiter.m_boUnRevival {防复活} then begin
              if m_boRevival and (GetTickCount - m_dwRevivalTick > g_Config.dwRevivalTime {60 * 1000}) then begin
                m_dwRevivalTick := GetTickCount();
                nReviealMode := 1;
                nCheckCode := 12;
                m_WAbil.HP := m_WAbil.MaxHP;
                nCheckCode := 13;
                case m_btRaceServer of
                  RC_PLAYOBJECT: begin
                      nCheckCode := 11;
                      ItemDamageRevivalRing; //20091110 换位置
                      SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
                      SysMsg(g_sRevivalRecoverMsg {'复活戒指生效，体力恢复'}, c_Green, t_Hint);
                    end;
                  RC_HEROOBJECT: begin
                      nCheckCode := 25;
                      ItemDamageRevivalRing; //20091110 换位置
                      THeroObject(self).SendMsg(self, RM_HEROABILITY, 0, 0, 0, 0, ''); //发送英雄属性  20090210
                      THeroObject(self).SysMsg(g_sRevivalRecoverMsg {'复活戒指生效，体力恢复'}, c_Green, t_Hint);
                    end;
                  RC_PLAYMOSTER: begin
                      ItemDamageRevivalRing; //复活戒指生效，体力恢复
                    end;
                end;
                if g_Config.boUnderWarMove and (m_btRaceServer = RC_PLAYOBJECT) then begin //攻城期复活传送回攻方复活点
                  Castle := g_CastleManager.InCastleWarArea(Self);
                  if (Castle <> nil) then begin
                    if Castle.m_boUnderWar then begin //攻城中
                      if (m_PEnvir = Castle.m_MapPalace) then begin //皇宫
                        TPLAYOBJECT(self).BaseObjectMove(Castle.m_sWarAreaHomeMap, IntToStr(Castle.m_nWarAreaHomeX), IntToStr(Castle.m_nWarAreaHomeY));
                      end;
                    end;
                  end;
                end;
              end else
                if m_boRebirth and (GetTickCount - m_dwRebirthTick > g_Config.dwRebirthTime) then begin //重生戒指 20100720
                  m_dwRebirthTick := GetTickCount();
                  nReviealMode := 2;
                  nCheckCode := 21;
                  m_WAbil.HP := m_WAbil.MaxHP;
                  m_WAbil.MP := m_WAbil.MaxMP;
                  nCheckCode := 22;
                  case m_btRaceServer of
                    RC_PLAYOBJECT: begin
                        nCheckCode := 23;
                        RebirthItemDecDura; //重生戒指生效，减物品持久
                        SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
                        SysMsg(g_sRebirthRecoverMsg {'重生戒指生效，体力和魔法恢复.'}, c_Green, t_Hint);
                      end;
                    RC_HEROOBJECT: begin
                        nCheckCode := 24;
                        RebirthItemDecDura; //重生戒指生效，减物品持久
                        THeroObject(self).SendMsg(self, RM_HEROABILITY, 0, 0, 0, 0, ''); //发送英雄属性
                        THeroObject(self).SysMsg(g_sRebirthRecoverMsg {'重生戒指生效，体力和魔法恢复.'}, c_Green, t_Hint);
                      end;
                    RC_PLAYMOSTER: begin
                        RebirthItemDecDura; //重生戒指生效，减物品持久
                      end;
                  end;
                  if g_Config.boUnderWarMove and (m_btRaceServer = RC_PLAYOBJECT) then begin //攻城期复活传送回攻方复活点
                    Castle := g_CastleManager.InCastleWarArea(Self);
                    if (Castle <> nil) then begin
                      if Castle.m_boUnderWar then begin //攻城中
                        if (m_PEnvir = Castle.m_MapPalace) then begin //皇宫
                          TPLAYOBJECT(self).BaseObjectMove(Castle.m_sWarAreaHomeMap, IntToStr(Castle.m_nWarAreaHomeX), IntToStr(Castle.m_nWarAreaHomeY));
                        end;
                      end;
                    end;
                  end;
                end;
              if (m_boRevival or m_boRebirth) and (not m_boAI) then begin //20101126 增加复活日志
                case nReviealMode of
                  0: begin //时间未到
                      AddGameDataLog('19' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 + '未复活或重生' + #9 + '3' + #9 + '1' + #9 + '时间未到');
                    end;
                  1: begin //复活生效
                      AddGameDataLog('19' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 + '复活生效' + #9 + '3' + #9 + '1' + #9 + '');
                    end;
                  2: begin //重生生效
                      AddGameDataLog('19' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 + '重生生效' + #9 + '3' + #9 + '1' + #9 + '');
                    end;
                end;
              end;
            end else begin
              if (m_boRevival or m_boRebirth) and (not m_boAI) then begin //20101126 增加复活日志
                AddGameDataLog('19' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                  m_sCharName + #9 + '未复活或重生' + #9 + '3' + #9 + '1' + #9 + '防复活');
              end;
            end;
          end;
        nCheckCode := 14;
        if (m_wStatusArrValue[19] > 0) and (m_WAbil.HP = 0) then begin //不死状态
          m_WAbil.HP := m_WAbil.MaxHP;
          case m_btRaceServer of
            RC_PLAYOBJECT: SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
            RC_HEROOBJECT: THeroObject(self).SendMsg(self, RM_HEROABILITY, 0, 0, 0, 0, ''); //发送英雄属性
          end;
        end;
        if (m_WAbil.HP = 0) and (not m_boGhost) then Die;
      end; //if m_WAbil.HP = 0 then begin
      if m_nHealthTick >= g_Config.nHealthFillTime then m_nHealthTick := 0;
      if m_nSpellTick >= g_Config.nSpellFillTime then m_nSpellTick := 0;
    end else begin
      nCheckCode := 16;
      if (m_btRaceServer = RC_PLAYMOSTER) and (m_Master = nil) then begin //人形怪尸体清理时间 20080418
        if (GetTickCount() - m_dwDeathTick > g_Config.dwMakeGhostPlayMosterTime) then begin
          if TPlayMonster(self).boIsDieEvent then begin
            FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_DIEEVENT, 4000); //人形退出动画显示 20080914
            g_EventManager.AddEvent(FlowerEvent);
          end else begin
            FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, SM_HEROLOGOUT, 4000); //人形退出动画显示 20080914
            g_EventManager.AddEvent(FlowerEvent);
          end;
          MakeGhost();
        end;
      end else
        if (m_btRaceServer = RC_HEROOBJECT) and (m_Master <> nil) then begin //英雄尸体清理时间 20080418
          if (GetTickCount() - m_dwDeathTick > g_Config.nMakeGhostHeroTime) then MakeGhost();
        end else
          if (m_btRaceServer in [78, 121..125]) and (m_Master = nil) then begin //雷炎怪清理时间 20080810
            if (GetTickCount() - m_dwDeathTick > g_Config.dwMakeGhostPlayMosterTime) then MakeGhost();
          end else
            if (GetTickCount() - m_dwDeathTick > g_Config.dwMakeGhostTime) or
              (m_boAI and (GetTickCount() - m_dwDeathTick > 100000)) then begin //假人直接清理尸体 20110512
              MakeGhost();
            end;
    end;
  except
    MainOutMessage(Format(sExceptionMsg1, [g_sExceptionVer, ExceptAddr, nCheckCode, m_btRaceServer]));
  end;

  try
    if not m_boDeath and ((m_nIncSpell > 0) or (m_nIncHealth > 0) or (m_nIncHealing > 0)) then begin
      dwInChsTime := 600 - _MIN(400, m_Abil.Level * 10);
      if ((GetTickCount - m_dwIncHealthSpellTick) >= dwInChsTime) and not m_boDeath then begin
        dwC := _MIN(200, (GetTickCount - m_dwIncHealthSpellTick - dwInChsTime));
        m_dwIncHealthSpellTick := GetTickCount() + dwC;
        if (m_nIncSpell > 0) or (m_nIncHealth > 0) or (m_nPerHealing > 0) then begin
          if (m_nPerHealth <= 0) then m_nPerHealth := 1;
          if (m_nPerSpell <= 0) then m_nPerSpell := 1;
          if (m_nPerHealing <= 0) then m_nPerHealing := 1;
          if m_nIncHealth < m_nPerHealth then begin
            nHP := m_nIncHealth; // 这个地方小于的话，就置血为 零
            m_nIncHealth := 0;
          end else begin
            nHP := m_nPerHealth;
            Dec(m_nIncHealth, m_nPerHealth); // liuzhigang 减血的代码
          end;
          if m_nIncSpell < m_nPerSpell then begin
            nMP := m_nIncSpell;
            m_nIncSpell := 0;
          end else begin
            nMP := m_nPerSpell;
            Dec(m_nIncSpell, m_nPerSpell);
          end;
          if m_nIncHealing < m_nPerHealing then begin
            Inc(nHP, m_nIncHealing);
            m_nIncHealing := 0;
          end else begin
            Inc(nHP, m_nPerHealing);
            Dec(m_nIncHealing, m_nPerHealing);
          end;
          m_nPerHealth := (m_Abil.Level div 10 + 5);
          m_nPerSpell := (m_Abil.Level div 10 + 5);
          m_nPerHealing := 5;
          IncHealthSpell(nHP, nMP);
          if m_WAbil.HP = m_WAbil.MaxHP then begin
            m_nIncHealth := 0;
            m_nIncHealing := 0;
          end;
          if m_WAbil.MP = m_WAbil.MaxMP then begin
            m_nIncSpell := 0;
          end;
        end;
      end;
    end else begin
      m_dwIncHealthSpellTick := GetTickCount();
    end;
    if (m_nHealthTick < -g_Config.nHealthFillTime) and (m_WAbil.HP > 1) then begin //Jacky ????
      Dec(m_WAbil.HP);
      Inc(m_nHealthTick, g_Config.nHealthFillTime);
      HealthSpellChanged();
    end;
    //检查HP/MP值是否大于最大值，大于则降低到正常大小
    boNeedRecalc := False;
    if m_WAbil.HP > m_WAbil.MaxHP then begin
      boNeedRecalc := True;
      m_WAbil.HP := m_WAbil.MaxHP - 1;
    end;
    if m_WAbil.MP > m_WAbil.MaxMP then begin
      boNeedRecalc := True;
      m_WAbil.MP := m_WAbil.MaxMP - 1;
    end;
    if boNeedRecalc then HealthSpellChanged();
  except
    MainOutMessage(Format(sExceptionMsg2, [g_sExceptionVer, ExceptAddr]));
  end;

  try //20080527 增加异常提示
    nCheckCode := 62;
   //TBaseObject.Run 3 清理目标对象
    if (m_TargetCret <> nil) then begin
      if ((GetTickCount() - m_dwTargetFocusTick) > 30000) or
        m_TargetCret.m_boDeath or
        m_TargetCret.m_boGhost or
        (m_TargetCret.m_PEnvir <> m_PEnvir) or // 08/06 增加，弓箭卫士在人物进入房间后再出来，还会攻击人物(人物的攻击目标没清除)
        (abs(m_TargetCret.m_nCurrX - m_nCurrX) > 15) or
        (abs(m_TargetCret.m_nCurrY - m_nCurrY) > 15) then begin
        m_TargetCret := nil;
{$IF M2Version <> 2}
        case m_btRaceServer of
          RC_PLAYOBJECT: TPLAYOBJECT(Self).m_nHeapStruckDamage := 0; //受有武器暴击等级的人物累积攻击点 20100709
          RC_HEROOBJECT: THeroObject(Self).m_nHeapStruckDamage := 0; //受有武器暴击等级的人物累积攻击点 20100709
        end; //case
{$IFEND}
      end;
    end;
    nCheckCode := 63;
    try //20081214
      if (m_LastHiter <> nil) then begin
        nCheckCode := 66;
        if ((GetTickCount() - m_LastHiterTick) > 30000) or m_LastHiter.m_boDeath or m_LastHiter.m_boGhost then begin
          nCheckCode := 67;
          m_LastHiter := nil;
        end;
      end;
    except
    end;
    nCheckCode := 64;
    try //20081214
      if (m_ExpHitter <> nil) then begin
        nCheckCode := 65;
        if ((GetTickCount() - m_ExpHitterTick) > 6000) or m_ExpHitter.m_boDeath or m_ExpHitter.m_boGhost then begin
          nCheckCode := 68;
          m_ExpHitter := nil;
        end;
      end;
    except
    end;
    nCheckCode := 31;
    boChangeColor := True;
    if m_nChangeColorType >= 0 then begin
      //怪物变色
      boChangeColor := False;
      if m_nChangeColorType = 0 then begin
        if not m_boAutoChangeColor then begin
          m_boAutoChangeColor := True;
          m_dwAutoChangeColorTick := GetTickCount();
        end;
        nCheckCode := 35;
        if m_boAutoChangeColor and (GetTickCount - m_dwAutoChangeColorTick > g_Config.dwBBMonAutoChangeColorTime) then begin
          nCheckCode := 36;
          m_dwAutoChangeColorTick := GetTickCount();
          case m_nAutoChangeIdx of
            0: nInteger := STATE_TRANSPARENT;
            1: nInteger := POISON_STONE;
            2: nInteger := POISON_DONTMOVE;
            3: nInteger := POISON_68;
            4: nInteger := POISON_DECHEALTH;
            5: nInteger := POISON_LOCK1;
            6: nInteger := POISON_DAMAGEARMOR;
          else begin
              m_nAutoChangeIdx := 0;
              nInteger := STATE_TRANSPARENT;
            end;
          end;
          nCheckCode := 37;
          Inc(m_nAutoChangeIdx);
          m_nCharStatus := (m_nCharStatusEx and $FFFFF) or (($80000000 shr nInteger) or 0);
          StatusChanged(''); //状态改变
        end;
        if m_boFixColor and (m_nFixStatus <> m_nCharStatus) then begin
          nCheckCode := 39;
          case m_nFixColorIdx of
            0: nInteger := STATE_TRANSPARENT;
            1: nInteger := POISON_STONE;
            2: nInteger := POISON_DONTMOVE;
            3: nInteger := POISON_68;
            4: nInteger := POISON_DECHEALTH;
            5: nInteger := POISON_LOCK1;
            6: nInteger := POISON_DAMAGEARMOR;
          else begin
              m_nFixColorIdx := 0;
              nInteger := STATE_TRANSPARENT;
            end;
          end;
          nCheckCode := 40;
          m_nCharStatus := (m_nCharStatusEx and $FFFFF) or (($80000000 shr nInteger) or 0);
          m_nFixStatus := m_nCharStatus;
          StatusChanged(''); //状态改变
        end;
      end else begin
        nCheckCode := 41;
        m_boAutoChangeColor := False; //固定颜色
        m_boFixColor := True;
        m_nFixColorIdx := m_nChangeColorType - 1;
        if m_boFixColor and (m_nFixStatus <> m_nCharStatus) then begin
          nCheckCode := 42;
          case m_nFixColorIdx of
            0: nInteger := STATE_TRANSPARENT;
            1: nInteger := POISON_STONE;
            2: nInteger := POISON_DONTMOVE;
            3: nInteger := POISON_68;
            4: nInteger := POISON_DECHEALTH;
            5: nInteger := POISON_LOCK1;
            6: nInteger := POISON_DAMAGEARMOR;
          else begin
              m_nFixColorIdx := 0;
              nInteger := STATE_TRANSPARENT;
            end;
          end;
          nCheckCode := 43;
          m_nCharStatus := (m_nCharStatusEx and $FFFFF) or (($80000000 shr nInteger) or 0);
          m_nFixStatus := m_nCharStatus;
          StatusChanged(''); //状态改变
        end;
      end;
    end;
    nCheckCode := 44;
    if m_Master <> nil then begin
      if m_btRaceServer <> RC_HEROOBJECT then m_boNoItem := True; //20080602  英雄除外,所有宝宝不掉物品
      //宝宝变色
      if m_boAutoChangeColor and (GetTickCount - m_dwAutoChangeColorTick > g_Config.dwBBMonAutoChangeColorTime) and boChangeColor then begin
        nCheckCode := 46;
        m_dwAutoChangeColorTick := GetTickCount();
        case m_nAutoChangeIdx of
          0: nInteger := STATE_TRANSPARENT;
          1: nInteger := POISON_STONE;
          2: nInteger := POISON_DONTMOVE;
          3: nInteger := POISON_68;
          4: nInteger := POISON_DECHEALTH;
          5: nInteger := POISON_LOCK1;
          6: nInteger := POISON_DAMAGEARMOR;
        else begin
            m_nAutoChangeIdx := 0;
            nInteger := STATE_TRANSPARENT;
          end;
        end;
        nCheckCode := 47;
        Inc(m_nAutoChangeIdx);
        m_nCharStatus := (m_nCharStatusEx and $FFFFF) or (($80000000 shr nInteger) or 0);
        StatusChanged(''); //状态改变
      end;
      nCheckCode := 48;
      if m_boFixColor and (m_nFixStatus <> m_nCharStatus) and boChangeColor then begin
        nCheckCode := 49;
        case m_nFixColorIdx of
          0: nInteger := STATE_TRANSPARENT;
          1: nInteger := POISON_STONE;
          2: nInteger := POISON_DONTMOVE;
          3: nInteger := POISON_68;
          4: nInteger := POISON_DECHEALTH;
          5: nInteger := POISON_LOCK1;
          6: nInteger := POISON_DAMAGEARMOR;
        else begin
            m_nFixColorIdx := 0;
            nInteger := STATE_TRANSPARENT;
          end;
        end;
        nCheckCode := 50;
        m_nCharStatus := (m_nCharStatusEx and $FFFFF) or (($80000000 shr nInteger) or 0);
        m_nFixStatus := m_nCharStatus;
        StatusChanged('');
      end;
      nCheckCode := 51;
      // 宝宝在主人死亡后死亡处理 (20071216 增加人物死亡后,英雄需要继续战斗)
      if m_Master <> nil then begin //20080730
        nCheckCode := 58;
        try
          if (not m_Master.m_boGhost) then begin
            nCheckCode := 60;
            if (m_Master.m_btRaceServer = RC_HEROOBJECT) or (m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin //20090104
              nCheckCode := 59;
              if m_Master.m_boDeath and (GetTickCount - m_Master.m_dwDeathTick > 1000) then begin
                if (m_btRaceServer <> 158) then begin
                  nCheckCode := 52;
                  if g_Config.boMasterDieMutiny and (m_Master.m_LastHiter <> nil)
                    and (Random(g_Config.nMasterDieMutinyRate) = 0) then begin
                    nCheckCode := 53;
                    if (m_btRaceServer <> RC_HEROOBJECT) and (m_btRaceServer <> RC_PLAYMOSTER) then begin //除英雄,分身外，其它死亡
                      nCheckCode := 54;
                      m_Master := nil;
                      m_btSlaveExpLevel := High(g_Config.SlaveColor);
                      RecalcAbilitys();
                      m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC) * g_Config.nMasterDieMutinyPower, HiWord(m_WAbil.DC) * g_Config.nMasterDieMutinyPower);
                      m_nWalkSpeed := m_nWalkSpeed div g_Config.nMasterDieMutinySpeed;
                      RefNameColor;
                      RefShowName;
                    end else begin
                      if g_Config.boHeroMutinyDie then m_WAbil.HP := 0;
                    end;
                  end else begin
                    nCheckCode := 55;
                    case m_Master.m_btRaceServer of
                      RC_HEROOBJECT: begin //主人(英雄)死亡,英雄下属也一起死亡 20080228
                          if (m_btRaceServer = RC_PLAYMOSTER) then begin //收回英雄，英雄的分身，和英雄一样的消失 20081211
                            MakeGhost;
                          end else m_WAbil.HP := 0;
                        end;
                      RC_PLAYOBJECT: if m_btRaceServer <> RC_HEROOBJECT then m_WAbil.HP := 0;
                    end;
                  end;
                end else begin //宠物类不处理 20110609
                  m_Master := nil;
                end;
              end;
            end;
          end;
        except //20091227 叛变异常时，直接清除怪物
          MakeGhost;
        end;
      end;
      nCheckCode := 56;
      if m_Master <> nil then begin //20080623 增加
        if m_Master.m_boGhost and ((GetTickCount - m_Master.m_dwGhostTick) > 1000) then begin
          nCheckCode := 57;
          if (m_btRaceServer <> 158) then MakeGhost //宠物类不处理 20110609
          else m_Master := nil; //宠物类不处理 20110609
        end;
      end;
    end;

    //清除宝宝列表中已经死亡及叛变的宝宝信息
    nCheckCode := 18; //20090206 人形不进入
    if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) {or (m_btRaceServer = RC_PLAYMOSTER)} then begin //20080712 增加
      nCheckCode := 181;
      for I := m_SlaveList.Count - 1 downto 0 do begin
        nCheckCode := 182;
        if m_SlaveList.Count <= 0 then Break;
        nCheckCode := 183;
        if TBaseObject(m_SlaveList.Items[I]) <> nil then begin //20090116 修改
          if TBaseObject(m_SlaveList.Items[I]).m_boDeath or TBaseObject(m_SlaveList.Items[I]).m_boGhost then begin
            m_SlaveList.Delete(I);
            m_dwLatest46Tick := GetTickCount; //20080204 召唤分身间隔
          end else begin
            nCheckCode := 187;
            if TBaseObject(m_SlaveList.Items[I]).m_Master <> nil then begin
              if (TBaseObject(m_SlaveList.Items[I]).m_Master <> Self) then begin
                m_SlaveList.Delete(I);
                m_dwLatest46Tick := GetTickCount; //召唤分身间隔
              end;
            end;
          end;
        end;
      end;
    end;
    nCheckCode := 184;
    if m_boHolySeize and ((GetTickCount() - m_dwHolySeizeTick) > m_dwHolySeizeInterval) then begin
      BreakHolySeizeMode();
    end;
    if m_boCrazyMode and ((GetTickCount() - m_dwCrazyModeTick) > m_dwCrazyModeInterval) then begin
      BreakCrazyMode();
    end;
    if m_boShowHP and ((GetTickCount() - m_dwShowHPTick) > m_dwShowHPInterval) then begin
      BreakOpenHealth();
    end;
  except
    MainOutMessage(Format(sExceptionMsg3, [g_sExceptionVer, ExceptAddr, nCheckCode, m_sCharName]));
  end;

  try
    if (GetTickCount() - m_dwDecPkPointTick) > g_Config.dwDecPkPointTime {120000} then begin //减少PK值
      m_dwDecPkPointTick := GetTickCount();
      if m_nPkPoint > 0 then DecPKPoint(g_Config.nDecPkPointCount {1});
    end;

    nCheckCode := 24;
    if (GetTickCount - m_DecLightItemDrugTick) > g_Config.dwDecLightItemDrugTime {1000} then begin //检查照明物品及PK状态
      Inc(m_DecLightItemDrugTick, g_Config.dwDecLightItemDrugTime {1000});
      case m_btRaceServer of //20090901 修改
        RC_PLAYOBJECT: begin
            UseLamp(); //使用照明物品
            CheckPKStatus(); //检查PK状态
          end;
        RC_HEROOBJECT: begin //英雄灰名变为正常
            CheckPKStatus(); //检查PK状态
          end;
        RC_PLAYMOSTER: begin //分身灰名变为正常
            if (m_Master <> nil) then CheckPKStatus(); //检查PK状态
          end;
      end; //case
    end;

    nCheckCode := 25;
    if ((GetTickCount - m_dwCheckRoyaltyTick) > 10000) and (m_btRaceServer <> RC_HEROOBJECT) {英雄不叛变}
      and (m_btRaceServer <> 158) then begin //宠物类怪不叛变 20110609
      m_dwCheckRoyaltyTick := GetTickCount();
      if m_Master <> nil then begin
        if (m_btRaceServer <> RC_PLAYMOSTER) then begin //宝宝叛变
          if (g_dwSpiritMutinyTick > GetTickCount) and (m_btSlaveExpLevel < 5) then begin
            m_dwMasterRoyaltyTick := 0;
          end;
          //宝宝叛变  开始
          nCheckCode := 26;
          if (GetTickCount - m_dwMasterRoyaltyTime > m_dwMasterRoyaltyTick) and (m_Master <> nil) then begin //20080813修改
            try //20090615
              if not m_Master.m_boGhost then begin //20081216
                nCheckCode := 29;
                for I := m_Master.m_SlaveList.Count - 1 downto 0 do begin
                  if m_Master.m_SlaveList.Count <= 0 then Break;
                  nCheckCode := 27;
                  if m_Master.m_SlaveList.Items[I] = Self then begin
                    nCheckCode := 28;
                    m_Master.m_SlaveList.Delete(I);
                    m_Master.m_dwLatest46Tick := GetTickCount; //20080204 召唤分身间隔
                    Break;
                  end;
                end; //for
              end;
            except
            end;
            m_Master := nil;
            if m_btRaceServer <> 99 then begin
              m_WAbil.HP := m_WAbil.HP div 10;
              RefShowName();
            end else m_WAbil.HP := 0; //时间到,冰眼巨魔死亡 20101104
          end;
          //宝宝叛变 结束
          nCheckCode := 30;
          if m_dwMasterTick <> 0 then begin //诱惑来的怪
            if (GetTickCount - m_dwMasterTick) > 43200000 {12 * 60 * 60 * 1000} then m_WAbil.HP := 0;
          end;
        end else begin //分身时间到直接消失 20080404
          if (GetTickCount - m_dwMasterRoyaltyTime > m_dwMasterRoyaltyTick) then begin //20080813 修改
            for I := m_Master.m_SlaveList.Count - 1 downto 0 do begin
              if m_Master.m_SlaveList.Count <= 0 then Break;
              nCheckCode := 31;
              if m_Master.m_SlaveList.Items[I] = Self then begin
                nCheckCode := 32;
                m_Master.m_SlaveList.Delete(I);
                m_Master.m_dwLatest46Tick := GetTickCount; //召唤分身间隔
                Break;
              end;
            end; //for
            m_Master := nil;
            FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, SM_HEROLOGOUT, 4000); //人物分身时间到，显示退出动画(与收英雄一样) 20090104
            g_EventManager.AddEvent(FlowerEvent);
            m_WAbil.HP := 0;
            MakeGhost;
            nCheckCode := 33;
          end;
        end;
      end; //if m_Master <> nil then begin
    end;
    if (GetTickCount - m_dwVerifyTick) > 30000 then begin
      m_dwVerifyTick := GetTickCount();
      if (not m_boDenyRefStatus) and (m_PEnvir <> nil) then m_PEnvir.VerifyMapTime(m_nCurrX, m_nCurrY, Self); //刷新在地图上位置的时间
    end;
  except
      MainOutMessage(Format(sExceptionMsg4, [g_sExceptionVer, ExceptAddr, nCheckCode]));
  end;

  try
    nCheckCode := 65;
    boChg := False;
    boNeedRecalc := False;
    for I := Low(m_dwStatusArrTick) to High(m_dwStatusArrTick) do begin //处理各种状态
      if (m_wStatusTimeArr[I] > 0) and ((I = STATE_TRANSPARENT) or (m_wStatusTimeArr[I] <> MaxWord)){隐身戒指不处理 By TasNat at: 2012-05-16 10:02:31} then begin
        nHP := (GetTickCount() - m_dwStatusArrTick[I]);
        if nHP > 1000 then begin
          Dec(m_wStatusTimeArr[I]);
          Inc(m_dwStatusArrTick[I], 1000);
          nCheckCode := 66;
          if (m_wStatusTimeArr[I] = 0) then begin
            boChg := True;
            case I of
              STATE_TRANSPARENT: begin //隐身
                  m_boHideMode := False;
                end;
              STATE_DEFENCEUP: begin
                  boNeedRecalc := True;
                  if m_btRaceServer = RC_HEROOBJECT then //20080602 英雄加提示
                    THeroObject(Self).SysMsg('(英雄) ' + g_sDefenceUpTimeOver, c_Green, t_Hint)
                  else SysMsg(g_sDefenceUpTimeOver {'防御力回复正常'}, c_Green, t_Hint);
                end;
              STATE_MAGDEFENCEUP: begin
                  boNeedRecalc := True;
                  if m_btRaceServer = RC_HEROOBJECT then //20080602 英雄加提示
                    THeroObject(Self).SysMsg('(英雄) ' + g_sMagDefenceUpTimeOver, c_Green, t_Hint)
                  else SysMsg(g_sMagDefenceUpTimeOver {'魔御力回复正常'}, c_Green, t_Hint);
                end;
              STATE_BUBBLEDEFENCEUP: begin //让魔法盾停止
                  m_boAbilMagBubbleDefence := False;
                  if m_btMagBubbleDefenceLevel = 4 then StatusChanged('555'); //20080811 4级盾,发个消息给客户端显示特有的效果
                end;
              STATE_LOCKRUN: begin
                  case m_btRaceServer of //20090901 修改
                    RC_PLAYOBJECT: TPlayObject(self).m_boCanRun := True; //是否允许跑
                    RC_HEROOBJECT: THeroObject(self).m_boCanRun := True; //是否允许跑
                  end;
                end;
              POISON_LOCK1: begin //恢复防，魔防
                  boNeedRecalc := True;
                  if m_btRaceServer = RC_HEROOBJECT then
                    THeroObject(Self).SysMsg('(英雄) ' + g_sSkill102TimeOver, c_Green, t_Hint)
                  else SysMsg(g_sSkill102TimeOver {'防御力、魔防回复正常'}, c_Green, t_Hint);
                end;
            end;
          end;
        end;
      end;
      //20091225 0-11与m_wStatusTimeArr共用同一循环
      if m_wStatusArrValue[I] > 0 then begin
        if GetTickCount() > m_dwStatusArrTimeOutTick[I] then begin
          m_wStatusArrValue[I] := 0;
          boNeedRecalc := True;
          nCheckCode := 68;
          case I of
            0, 6: begin
                if (I = 0) then m_boDrinkDrugHotels := False;
                if m_btRaceServer = RC_HEROOBJECT then //20080602 英雄加提示
                  THeroObject(Self).SysMsg('(英雄) 攻击力回复正常', c_Green, t_Hint)
                else SysMsg('攻击力回复正常', c_Green, t_Hint);
              end;
            1, 7: begin
                if (I = 1) then m_boDrinkDrugHotels := False;
                if m_btRaceServer = RC_HEROOBJECT then //20080602 英雄加提示
                  THeroObject(Self).SysMsg('(英雄) 魔法力回复正常', c_Green, t_Hint)
                else SysMsg('魔法力回复正常', c_Green, t_Hint);
              end;
            2: begin
                if m_btRaceServer = RC_HEROOBJECT then //20080602 英雄加提示
                  THeroObject(Self).SysMsg('(英雄) 无极真气状态结束', c_Green, t_Hint)
                else SysMsg('无极真气状态结束', c_Green, t_Hint);
                m_dwStatusArrTimeOutTick[2] := GetTickCount(); //20100128 无极真气间隔
              end;
            3: begin
                if m_btRaceServer = RC_HEROOBJECT then //20080602 英雄加提示
                  THeroObject(Self).SysMsg('(英雄) 攻击速度回复正常', c_Green, t_Hint)
                else SysMsg('攻击速度回复正常', c_Green, t_Hint);
              end;
            4: begin
                m_boDrinkDrugHotels := False;
                if m_btRaceServer = RC_HEROOBJECT then //20080602 英雄加提示
                  THeroObject(Self).SysMsg('(英雄) 体力回复正常', c_Green, t_Hint)
                else SysMsg('体力回复正常', c_Green, t_Hint);
              end;
            5: begin
                m_boDrinkDrugHotels := False;
                if m_btRaceServer = RC_HEROOBJECT then //20080602 英雄加提示
                  THeroObject(Self).SysMsg('(英雄) 魔法值回复正常', c_Green, t_Hint)
                else SysMsg('魔法值回复正常', c_Green, t_Hint);
              end;
            8: begin
                if m_btRaceServer = RC_HEROOBJECT then
                  THeroObject(Self).SysMsg('(英雄) 道术回复正常', c_Green, t_Hint)
                else SysMsg('道术回复正常', c_Green, t_Hint);
              end;
            11: begin //20080626 增加敏捷度回复正常
                m_boDrinkDrugHotels := False;
                if m_btRaceServer = RC_HEROOBJECT then
                  THeroObject(Self).SysMsg('(英雄) 敏捷回复正常', c_Green, t_Hint)
                else SysMsg('敏捷回复正常', c_Green, t_Hint);
              end;
          end;
        end else begin
          case I of
            9: begin //减HP
                DamageHealth(m_wStatusArrValue[I]);
                HealthSpellChanged();
              end;
            10: begin //减MP
                DamageSpell(m_wStatusArrValue[I]);
                HealthSpellChanged();
              end;
          end;
        end;
      end;
    end;
    nCheckCode := 67;
    if ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and (not m_boAI) then begin //人和英雄才进行新属性循环处理 20100411  20110627假人不处理
      for I := 12 to 23 do begin //新加的属性，独自循环处理 20091225
        if m_wStatusArrValue[I] > 0 then begin
          if GetTickCount() > m_dwStatusArrTimeOutTick[I] then begin
            m_wStatusArrValue[I] := 0;
            boNeedRecalc := True;
            nCheckCode := 68;
            case I of
              12: begin //20091222
                  m_boDrinkDrugHotels := False;
                  if m_btRaceServer = RC_HEROOBJECT then
                    THeroObject(Self).SysMsg('(英雄) 防御力回复正常', c_Green, t_Hint)
                  else SysMsg('防御力回复正常', c_Green, t_Hint);
                end;
              13: begin //20091222
                  m_boDrinkDrugHotels := False;
                  if m_btRaceServer = RC_HEROOBJECT then
                    THeroObject(Self).SysMsg('(英雄) 魔防力回复正常', c_Green, t_Hint)
                  else SysMsg('魔防力回复正常', c_Green, t_Hint);
                end;
              14: begin
                  m_boDrinkDrugHotels := False;
                  if m_btRaceServer = RC_HEROOBJECT then
                    THeroObject(Self).SysMsg('(英雄) 道术回复正常', c_Green, t_Hint)
                  else SysMsg('道术回复正常', c_Green, t_Hint);
                end;
              15: begin
                  m_boDrinkDrugHotels := False;
                  if m_btRaceServer = RC_HEROOBJECT then
                    THeroObject(Self).SysMsg('(英雄) 连击伤害回复正常', c_Green, t_Hint)
                  else SysMsg('连击伤害回复正常', c_Green, t_Hint);
                end;
              16: begin
                  m_boDrinkDrugHotels := False;
                  if m_btRaceServer = RC_HEROOBJECT then
                    THeroObject(Self).SysMsg('(英雄) 内力恢复速度回复正常', c_Green, t_Hint)
                  else SysMsg('内力恢复速度回复正常', c_Green, t_Hint);
                end;
              17: begin
                  m_boDrinkDrugHotels := False;
                  if m_btRaceServer = RC_HEROOBJECT then
                    THeroObject(Self).SysMsg('(英雄) 内力瞬间恢复回复正常', c_Green, t_Hint)
                  else SysMsg('内力瞬间恢复回复正常', c_Green, t_Hint);
                end;
{$IF M2Version = 1}
              18: begin
                  m_boDrinkDrugHotels := False;
                  if m_btRaceServer = RC_HEROOBJECT then
                    THeroObject(Self).SysMsg('(英雄) 斗转星移上限值恢复正常', c_Blue, t_Hint)
                  else SysMsg('斗转星移上限值恢复正常', c_Blue, t_Hint);
                end;
{$IFEND}
              19: begin
                  if m_btRaceServer = RC_HEROOBJECT then
                    THeroObject(Self).SysMsg('(英雄) 不死状态已结束', c_Green, t_Hint)
                  else SysMsg('不死状态已结束', c_Green, t_Hint);
                end;
              20: begin
                  if m_btRaceServer = RC_HEROOBJECT then
                    THeroObject(Self).SysMsg('(英雄) 道术回复正常', c_Green, t_Hint)
                  else SysMsg('道术回复正常', c_Green, t_Hint);
                end;
              21, 22: boChg := True;
              23: begin
                  if m_btRaceServer = RC_HEROOBJECT then
                    THeroObject(Self).SysMsg('(英雄) 定身状态结束！', c_Green, t_Hint)
                  else SysMsg('定身状态结束！', c_Green, t_Hint);
                  boChg := True;
                end;
            end;
          end;
        end;
      end;
    end else begin
      if m_wStatusArrValue[22] > 0 then begin //处理怪的减速状态
        if GetTickCount() > m_dwStatusArrTimeOutTick[22] then begin
          m_wStatusArrValue[22] := 0;
          boChg := True;
        end;
      end;
      if m_wStatusArrValue[23] > 0 then begin //处理怪的定身状态
        if GetTickCount() > m_dwStatusArrTimeOutTick[23] then begin
          m_wStatusArrValue[23] := 0;
          boChg := True;
        end;
      end;
    end;
    nCheckCode := 69;
    if boChg then begin
      m_nCharStatus := GetCharStatus();
      StatusChanged('');
    end;
    if boNeedRecalc then begin
      if m_btRaceServer = RC_HEROOBJECT then begin // 20080430
        nCheckCode := 70;
        THeroObject(self).RecalcAbilitys();
        THeroObject(self).CompareSuitItem(False); //200080729 套装
        THeroObject(self).SendMsg(self, RM_HEROABILITY, 0, 0, 0, 0, ''); //发送英雄属性
      end else begin
        nCheckCode := 71;
        RecalcAbilitys();
        CompareSuitItem(False); //200080729 套装
        if m_btRaceServer = RC_PLAYOBJECT then SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, ''); //20090501 修改
      end;
    end;
  except
    MainOutMessage(Format(sExceptionMsg5, [g_sExceptionVer, ExceptAddr, nCheckCode]));
  end;

  nCheckCode := 72;
  try
    if (GetTickCount - m_dwPoisoningTick) > g_Config.dwPosionDecHealthTime {2500} then begin
      m_dwPoisoningTick := GetTickCount();
      if m_wStatusTimeArr[POISON_DECHEALTH] > 0 then begin //中毒绿毒减血
        nCheckCode := 73;
        if m_boAnimal then Dec(m_nMeatQuality, 1000);
        DamageHealth(m_btGreenPoisoningPoint + 1);
        m_nHealthTick := 0;
        m_nSpellTick := 0;
        HealthSpellChanged();
      end;
      if m_wStatusTimeArr[POISON_SKILLDECHEALTH] > 0 then begin //中万剑归宗击中减血 20090628
        DamageHealth(g_Config.nBatterSkillPoinson_87 + 1);
        m_nHealthTick := 0;
        m_nSpellTick := 0;
        HealthSpellChanged();
      end;
    end;
    nCheckCode := 74;
    g_nBaseObjTimeMin := GetTickCount - dwRunTick;
    if g_nBaseObjTimeMax < g_nBaseObjTimeMin then g_nBaseObjTimeMax := g_nBaseObjTimeMin;
  except
    MainOutMessage(Format(sExceptionMsg6, [g_sExceptionVer, ExceptAddr, nCheckCode]));
  end;
end;
{//未使用 20080329
function TPlayObject.DayBright: Byte;
begin
  Result := 0;
  if m_PEnvir <> nil then begin
    if m_PEnvir.m_boDarkness then
      Result := 1
    else if m_PEnvir.m_boDayLight then Result := 0;
  end;
end; }

function TBaseObject.GetFrontPosition(var nX: Integer; var nY: Integer): Boolean;
var
  Envir: TEnvirnoment;
begin
  Envir := m_PEnvir;
  nX := m_nCurrX;
  nY := m_nCurrY;
  case m_btDirection of
    DR_UP: begin
        if nY > 0 then Dec(nY);
      end;
    DR_UPRIGHT: begin
        if (nX < (Envir.m_nWidth - 1)) and (nY > 0) then begin
          Inc(nX);
          Dec(nY);
        end;
      end;
    DR_RIGHT: begin
        if nX < (Envir.m_nWidth - 1) then Inc(nX);
      end;
    DR_DOWNRIGHT: begin
        if (nX < (Envir.m_nWidth - 1)) and (nY < (Envir.m_nHeight - 1)) then begin
          Inc(nX);
          Inc(nY);
        end;
      end;
    DR_DOWN: begin
        if nY < (Envir.m_nHeight - 1) then Inc(nY);
      end;
    DR_DOWNLEFT: begin
        if (nX > 0) and (nY < (Envir.m_nHeight - 1)) then begin
          Dec(nX);
          Inc(nY);
        end;
      end;
    DR_LEFT: begin
        if nX > 0 then Dec(nX);
      end;
    DR_UPLEFT: begin
        if (nX > 0) and (nY > 0) then begin
          Dec(nX);
          Dec(nY);
        end;
      end;
  end;
  Result := True;
end;

function TBaseObject.GetRandXY(Envir: TEnvirnoment; var nX: Integer; var nY: Integer): Boolean;
var
  n14, n18, n1C: Integer;
begin
  Result := False;
  if Envir.m_nWidth < 80 then n18 := 3
  else n18 := 10;
  if Envir.m_nHeight < 150 then begin
    if Envir.m_nHeight < 50 then n1C := 2
    else n1C := 15;
  end else n1C := 50;
  n14 := 0;
  while (True) do begin
    try //20101126 防止死循环
      if Envir.CanWalk(nX, nY, True) then begin
        Result := True;
        Break;
      end;
      if nX < (Envir.m_nWidth - n1C - 1) then Inc(nX, n18)
      else begin
        nX := Random(Envir.m_nWidth);
        if nY < (Envir.m_nHeight - n1C - 1) then Inc(nY, n18)
        else nY := Random(Envir.m_nHeight);
      end;
    except
    end;
    Inc(n14);
    if n14 >= 201 then Break;
  end;
end;

//地图移动  nInt 0--传送效果1 1--传送效果2

procedure TBaseObject.SpaceMove(sMAP: string; nX, nY: Integer; nInt: Integer);
var
  I, nOldX, nOldY: Integer;
  Envir, OldEnvir: TEnvirnoment;
  bo21, boRef: Boolean;
  PlayObject: TPlayObject;
  nCode: Byte;
begin
  nCode := 0;
  try
    Envir := g_MapManager.FindMap(sMAP);
    nCode := 1;
    if Envir <> nil then begin
      if nServerIndex = Envir.nServerIndex then begin
        OldEnvir := m_PEnvir;
        nOldX := m_nCurrX;
        nOldY := m_nCurrY;
        bo21 := False;
        nCode := 2;
        if (OldEnvir <> Envir) then ChangMapDropItems; //换地图掉指定物品 20110930
        m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
        nCode := 3;
        m_VisibleHumanList.Clear;
        nCode := 4;
        if m_VisibleItems.Count > 0 then begin
          for I := 0 to m_VisibleItems.Count - 1 do begin
            try //20090512 增加
              if pTVisibleMapItem(m_VisibleItems.Items[I]) <> nil then
                Dispose(pTVisibleMapItem(m_VisibleItems.Items[I]));
            except
            end;
          end;
          m_VisibleItems.Clear;
        end;
        nCode := 5;
        if m_VisibleActors.Count > 0 then begin
          for I := 0 to m_VisibleActors.Count - 1 do begin
            try
              if pTVisibleBaseObject(m_VisibleActors.Items[I]) <> nil then
                Dispose(pTVisibleBaseObject(m_VisibleActors.Items[I]));
            except //20090103
            end;
          end;
          m_VisibleActors.Clear;
        end;
        nCode := 6;
        if m_VisibleEvents.Count > 0 then m_VisibleEvents.Clear; //移动时清除列表
        nCode := 7;
        m_PEnvir := Envir;
        m_sMapName := Envir.sMapName;
        m_nCurrX := nX;
        m_nCurrY := nY;
        nCode := 8;
        case m_btRaceServer of
          RC_PLAYOBJECT: begin
              if TPLAYOBJECT(self).m_boForMapShowHint and (TPLAYOBJECT(self).m_dwUserTick[0] > 0) then begin //换地图是否还显示倒计时信息 20090128
                TPLAYOBJECT(self).m_dwUserTick[0] := 0;
                TPLAYOBJECT(self).m_dwUserTick[3] := 0; //20090129
                TPLAYOBJECT(self).m_boForMapShowHint := False;
                SendMsg(self, RM_MOVEMESSAGE, 2 {倒记时消息}, 255, 0, 1, ''); //关闭客户端显示倒计时(快捷键上方显示)
              end;
              if TPLAYOBJECT(self).m_boShowExpCrystal then begin //20090202
                TPLAYOBJECT(self).m_boShowExpCrystal := False;
              //TPLAYOBJECT(self).m_boGetExpCrystalExp := False;//是否可以提取经验 20090205注释
                SendMsg(self, RM_OPENEXPCRYSTAL, 0, 1, 0, 0, ''); //发消息关闭天地结晶图标
              end;
              if TPLAYOBJECT(self).m_boShowCattleGas then begin //关闭牛气管图标 20090518
                TPLAYOBJECT(self).m_boShowCattleGas := False;
                SendMsg(self, RM_OPENCATTLEGAS, 0, 1, 0, 0, ''); //发消息关闭牛气管图标
              end;
{$IF M2Version <> 2}
              TPLAYOBJECT(self).m_nHeapStruckDamage := 0; //受有武器暴击等级的人物累积攻击点 20100709
              if (OldEnvir <> m_PEnvir) then begin
                TPLAYOBJECT(self).ShopCancel; //取消个人商店
                boRef := False;
                if OldEnvir.boLimitLevel then begin
                  RecalcLevelAbilitys();
                  boRef := True;
                end;
                if m_PEnvir.boLimitLevel then boRef := True;
                if (TPLAYOBJECT(self).m_nSetupMaxLeveltoHPMP > 0) then begin
                  TPLAYOBJECT(self).m_nSetupMaxLeveltoHPMP := 0;
                  boRef := True;
                end;
                if boRef then begin
                  RecalcAbilitys();
                  CompareSuitItem(False);
                  SendDelayMsg(Self, RM_ABILITY, 0, 0, 0, 0, '', 1000); //由于换地图时，客户端对像不处理此消息，需要延时
                end;
              end;
              if (TPLAYOBJECT(self).m_nJewelX > -1) or (TPLAYOBJECT(self).m_nJewelY > -1) then begin
                SysMsg('因为您离开了宝物所在地图，灵媒的感应消失', c_Green, t_Hint);
                TPLAYOBJECT(self).m_nJewelX := -1; //宝物X坐标
                TPLAYOBJECT(self).m_nJewelY := -1; //宝物Y坐标
              end;
              if m_PEnvir.m_boCRIT and (sMapIncCritMsg <> '') then SysMsg(Format_ToStr(sMapIncCritMsg, [m_PEnvir.m_nCRIT]), c_Blue, t_Hint); //进入暴击等级地图提示 20110114
              if m_PEnvir.m_boPeak then begin
                if m_PEnvir.m_nPeakMaxRate > 100 then SysMsg(sMapPaekMsg1, c_Blue, t_Hint)
                else SysMsg(sMapPaekMsg, c_Blue, t_Hint);
              end;
{$IFEND}
            end;
          RC_HEROOBJECT: begin
{$IF M2Version <> 2}THeroObject(self).m_nHeapStruckDamage := 0{$IFEND}; //受有武器暴击等级的人物累积攻击点 20100709
              if (OldEnvir <> m_PEnvir) then begin
                if OldEnvir.boLimitLevel or m_PEnvir.boLimitLevel then begin
                  if OldEnvir.boLimitLevel then RecalcLevelAbilitys();
                  RecalcAbilitys();
                  CompareSuitItem(False);
                  THeroObject(self).SendMsg(Self, RM_HEROABILITY, 0, 0, 0, 0, '');
                end;
              end;
            end;
        end; //case
        if GetRandXY(m_PEnvir, m_nCurrX, m_nCurrY) then begin
          nCode := 9;
          m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
          if (m_btRaceServer = RC_PLAYOBJECT) and (not TPLAYOBJECT(self).m_boNotOnlineAddExp) and (not m_boAI) then begin //20110316 增加
            SendMsg(Self, RM_CLEAROBJECTS, 0, 0, 0, 0, '');
            SendMsg(Self, RM_CHANGEMAP, 0, 0, 0, 0, g_MapManager.GetMainMap(Envir)); //获取重复利用地图名称
            if m_btRaceServer = RC_PLAYOBJECT then begin //让人物直接搜索目标  20090811 注释
              m_dwSearchTick := GetTickCount() + 1100; //20090811 修改
            end;
          end;
          nCode := 10;
          if nInt = 1 then begin //传送后显示的效果
            SendRefMsg(RM_SPACEMOVE_SHOW2, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
          end else SendRefMsg(RM_SPACEMOVE_SHOW, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
          m_dwMapMoveTick := GetTickCount();
          m_bo316 := True;
          bo21 := True;
        end;
        if not bo21 then begin
          m_PEnvir := OldEnvir;
          m_nCurrX := nOldX;
          m_nCurrY := nOldY;
          nCode := 11;
          m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
        end;
        if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(Self).ShopCancel; //取消个人商店
      end else begin
        nCode := 12;
        if GetRandXY(Envir, nX, nY) then begin
          nCode := 13;
          if m_btRaceServer = RC_PLAYOBJECT then begin
            nCode := 14;
            DisappearA();
            m_bo316 := True;
            PlayObject := TPlayObject(Self);
            PlayObject.m_sSwitchMapName := Envir.sMapName;
            PlayObject.m_nSwitchMapX := nX;
            PlayObject.m_nSwitchMapY := nY;
            PlayObject.m_boSwitchData := True;
            PlayObject.m_nServerIndex := Envir.nServerIndex;
            PlayObject.m_boEmergencyClose := True;
            PlayObject.m_boReconnection := True;
            PlayObject.m_boPlayOffLine := False;
          end else KickException();
        end;
      end;
    end;                                                                              
  except
    MainOutMessage(Format('{%s} TBaseObject.SpaceMove Code:%d.%p', [g_sExceptionVer, nCode, ExceptAddr]));
  end;
end;

procedure TBaseObject.SpaceMove2(nX, nY: Integer; nInt: Integer);
var
  nOldX, nOldY: Integer;
  bo21: Boolean;
begin
  nOldX := m_nCurrX;
  nOldY := m_nCurrY;
  bo21 := False;
  ChangMapDropItems; //换地图掉指定物品 20110301
  m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
  m_nCurrX := nX;
  m_nCurrY := nY;
  case m_btRaceServer of
    RC_PLAYOBJECT: begin
        if TPLAYOBJECT(self).m_boForMapShowHint and (TPLAYOBJECT(self).m_dwUserTick[0] > 0) then begin //换地图是否还显示倒计时信息 20090128
          TPLAYOBJECT(self).m_dwUserTick[0] := 0;
          TPLAYOBJECT(self).m_dwUserTick[3] := 0; //20090129
          TPLAYOBJECT(self).m_boForMapShowHint := False;
          SendMsg(self, RM_MOVEMESSAGE, 2 {倒记时消息}, 255, 0, 1, ''); //关闭客户端显示倒计时(快捷键上方显示)
        end;
        if TPLAYOBJECT(self).m_boShowExpCrystal then begin //20090202
          TPLAYOBJECT(self).m_boShowExpCrystal := False;
        //TPLAYOBJECT(self).m_boGetExpCrystalExp := False;//是否可以提取经验 20090205注释
          SendMsg(self, RM_OPENEXPCRYSTAL, 0, 1, 0, 0, ''); //发消息关闭天地结晶图标
        end;
        if TPLAYOBJECT(self).m_boShowCattleGas then begin //关闭牛气管图标 20090518
          TPLAYOBJECT(self).m_boShowCattleGas := False;
          SendMsg(self, RM_OPENCATTLEGAS, 0, 1, 0, 0, ''); //发消息关闭牛气管图标
        end;
{$IF M2Version <> 2}
        TPLAYOBJECT(self).m_nHeapStruckDamage := 0; //受有武器暴击等级的人物累积攻击点 20100709
        if (TPLAYOBJECT(self).m_nJewelX > -1) or (TPLAYOBJECT(self).m_nJewelY > -1) then begin
          SysMsg('因为您离开了宝物所在地图，灵媒的感应消失', c_Green, t_Hint);
          TPLAYOBJECT(self).m_nJewelX := -1; //宝物X坐标
          TPLAYOBJECT(self).m_nJewelY := -1; //宝物Y坐标
        end;
        if m_PEnvir.m_boCRIT and (sMapIncCritMsg <> '') then SysMsg(Format_ToStr(sMapIncCritMsg, [m_PEnvir.m_nCRIT]), c_Blue, t_Hint); //进入暴击等级地图提示 20110114
        if m_PEnvir.m_boPeak then begin
          if m_PEnvir.m_nPeakMaxRate > 100 then SysMsg(sMapPaekMsg1, c_Blue, t_Hint)
          else SysMsg(sMapPaekMsg, c_Blue, t_Hint);
        end;
{$IFEND}
      end;
    RC_HEROOBJECT: {$IF M2Version <> 2}THeroObject(self).m_nHeapStruckDamage := 0{$IFEND}; //受有武器暴击等级的人物累积攻击点 20100709
  end; //case
  if GetRandXY(m_PEnvir, m_nCurrX, m_nCurrY) then begin
    m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
    if (m_btRaceServer = RC_PLAYOBJECT) and (not TPLAYOBJECT(self).m_boNotOnlineAddExp) and (not m_boAI) then begin //20110316
      SendMsg(Self, RM_CHANGEMAP, 0, 0, 0, 0, g_MapManager.GetMainMap(m_PEnvir));
    end;
    if nInt = 1 then begin //传送后显示的效果
      SendRefMsg(RM_SPACEMOVE_SHOW2, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
    end else SendRefMsg(RM_SPACEMOVE_SHOW, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
    m_dwMapMoveTick := GetTickCount();
    m_bo316 := True;
    bo21 := True;
  end;
  if not bo21 then begin
    m_nCurrX := nOldX;
    m_nCurrY := nOldY;
    m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
  end;
  if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(Self).ShopCancel; //取消个人商店
end;
//刷新玩家状态

procedure TPlayObject.RefUserState();
var
  n8: Integer;
begin
  n8 := 0;
  if m_PEnvir.m_boFightZone or m_PEnvir.m_boFight2Zone then n8 := n8 or 1;
  if m_PEnvir.m_boSAFE then n8 := n8 or 2;
  if m_boInFreePKArea then n8 := n8 or 4;
  SendDefMessage(SM_AREASTATE, n8, 0, 0, 0, '');
end;
//刷新名字

procedure TBaseObject.RefShowName();
begin
{$IF M2Version <> 2}
  case m_btRaceServer of
    RC_PLAYOBJECT: begin
        if (not TPlayObject(Self).m_boShowFengHao) and (TPlayObject(Self).m_boUseTitle) then SendRefMsg(RM_USERNAME, 0, 0, 0, TPlayObject(Self).m_boUseIitleIdx, GetShowName)
        else SendRefMsg(RM_USERNAME, 0, 0, 0, 0 {IsCastleMaster}, GetShowName);
      end;
    RC_PLAYMOSTER: begin
        if m_Master <> nil then begin
          if (m_Master.m_btRaceServer = RC_PLAYOBJECT) and (not m_Master.m_boGhost) then begin
            if TPlayObject(m_Master).m_boCanTitle then begin
              if (not TPlayObject(m_Master).m_boShowFengHao) and (TPlayObject(m_Master).m_boUseTitle) then
                SendRefMsg(RM_USERNAME, 0, 0, 0, TPlayObject(m_Master).m_boUseIitleIdx, GetShowName)
              else SendRefMsg(RM_USERNAME, 0, 0, 0, 0 {IsCastleMaster}, GetShowName);
            end else SendRefMsg(RM_USERNAME, 0, 0, 0, 0 {IsCastleMaster}, GetShowName);
          end else SendRefMsg(RM_USERNAME, 0, 0, 0, 0 {IsCastleMaster}, GetShowName);
        end else SendRefMsg(RM_USERNAME, 0, 0, 0, 0 {IsCastleMaster}, GetShowName);
      end;
  else SendRefMsg(RM_USERNAME, 0, 0, 0, 0 {IsCastleMaster}, GetShowName);
  end;
{$ELSE}
  SendRefMsg(RM_USERNAME, 0, 0, 0, 0 {IsCastleMaster}, GetShowName);
{$IFEND}
end;

procedure TPlayObject.RefMyStatus();
begin
  RecalcAbilitys();
  CompareSuitItem(False); //200080729 套装
  SendMsg(Self, RM_MYSTATUS, 0, 0, 0, 0, '');
end;

function TBaseObject.Operate(ProcessMsg: pTProcessMessage): Boolean;
  function MINXY(AObject, BObject: TBaseObject): TBaseObject;
  var
    nA, nB: Integer;
  begin
    nA := abs(m_nCurrX - AObject.m_nCurrX) + abs(m_nCurrY - AObject.m_nCurrY);
    nB := abs(m_nCurrX - BObject.m_nCurrX) + abs(m_nCurrY - BObject.m_nCurrY);
    if nA > nB then Result := BObject else Result := AObject;
  end;
var
  nDamage: Integer;
  nTargetX: Integer;
  nTargetY: Integer;
  nPower: Integer;
  nRage: Integer;
  TargeTBaseObject, AttackBaseObject: TBaseObject;
  nCode: Byte;
  boDisableSayMsg: Boolean;
resourcestring
  sExceptionMsg = '{%s} TBaseObject::Operate Code:%d.%p';
begin
  Result := False;
  nCode := 0;
  try
    if (ProcessMsg = nil) or (self = nil) then Exit; //20080812修改
    case ProcessMsg.wIdent of
      RM_MAGSTRUCK,
        RM_MAGSTRUCK_MINE: begin //10025
          nCode := 1;
          if (ProcessMsg.wIdent = RM_MAGSTRUCK) and (m_btRaceServer >= RC_ANIMAL) and
            (not bo2BF) and (m_Abil.Level < 50) then begin
            m_dwWalkTick := m_dwWalkTick + {800} 400 + LongWord(Random({1000}500)); //20090108 被打中，小于50级的怪，减慢行走速度
          end;
          nCode := 11;
          AttackBaseObject := TBaseObject(ProcessMsg.BaseObject);
          if AttackBaseObject <> nil then begin //20081220 修正学了内功后对魔法技能不增加攻击力
            nDamage := GetMagStruckDamage(AttackBaseObject, ProcessMsg.nParam1, ProcessMsg.nParam2, 0);
          end else nDamage := GetMagStruckDamage(nil, ProcessMsg.nParam1, ProcessMsg.nParam2, 0);
          if nDamage > 0 then begin
            if AttackBaseObject <> nil then begin //假人设置目标 20110316
              if (not AttackBaseObject.m_boDeath) and (not AttackBaseObject.m_boGhost) then begin
                if m_boAI {or (m_btRaceServer in [RC_PLAYMOSTER, RC_HEROOBJECT])} then begin
                  if (AttackBaseObject.m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT, RC_PLAYMOSTER]) or
                    ((AttackBaseObject.m_Master <> nil) and (AttackBaseObject.Master.m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT, RC_PLAYMOSTER])) then begin
                    if (m_TargetCret <> nil) and ((m_TargetCret.m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT, RC_PLAYMOSTER]) or
                      ((m_TargetCret.m_Master <> nil) and (m_TargetCret.Master.m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT, RC_PLAYMOSTER]))) then begin
                      if ((MINXY(m_TargetCret, AttackBaseObject) = AttackBaseObject) or (Random(6) = 0)) and (GetTickCount() - m_dwTargetFocusTick > 3000) then begin
                        SetTargetCreat(AttackBaseObject);
                      end;
                    end else begin
                      SetTargetCreat(AttackBaseObject);
                    end;
                    if m_boAI and (m_btRaceServer = RC_PLAYOBJECT) then begin
                      if (Random(15) = 0) and (TAIPlayObject(Self).m_AISayMsgList.Count > 0) then begin
                        if GetTickCount >= TPlayObject(Self).m_dwDisableSayMsgTick then TPlayObject(Self).m_boDisableSayMsg := False;
                        boDisableSayMsg := TPlayObject(Self).m_boDisableSayMsg;
                        g_DenySayMsgList.Lock;
                        try
                          if g_DenySayMsgList.GetIndex(m_sCharName) >= 0 then boDisableSayMsg := True;
                        finally
                          g_DenySayMsgList.UnLock;
                        end;
                        if not boDisableSayMsg then begin
                          SendRefMsg(RM_HEAR, 0, TPlayObject(Self).m_btHearMsgFColor, g_Config.btHearMsgBColor, 0, m_sCharName + ':' + TAIPlayObject(Self).m_AISayMsgList.Strings[Random(TAIPlayObject(Self).m_AISayMsgList.Count)]);
                        end;
                      end;
                    end;
                  end else begin
                    if (m_TargetCret = nil) and IsProperTarget(AttackBaseObject) then begin
                      SetTargetCreat(AttackBaseObject);
                    end else begin
                      if ((m_TargetCret <> nil) and (MINXY(m_TargetCret, AttackBaseObject) = AttackBaseObject)) or (Random(6) = 0) then begin
                        if (m_btJob > 0) or ((m_TargetCret <> nil) and (GetTickCount() - m_dwTargetFocusTick > 1000 * 3)) then
                          if IsProperTarget(AttackBaseObject) then begin
                            SetTargetCreat(AttackBaseObject);
                          end;
                      end;
                    end;
                  end;
                end;
              end;
            end;

            nCode := 12;
            StruckDamage(nDamage); //受攻击,减身上装备的持久
            nCode := 13;
            HealthSpellChanged();
            nCode := 14;
            SendRefMsg(RM_STRUCK_MAG, nDamage, m_WAbil.HP, m_WAbil.MaxHP, Integer(ProcessMsg.BaseObject), '');
            nCode := 15;
            if m_btRaceServer <> RC_PLAYOBJECT then begin
              if m_boAnimal then Dec(m_nMeatQuality, nDamage * 1000);
              nCode := 16;
              SendMsg(Self, RM_STRUCK, nDamage, m_WAbil.HP, m_WAbil.MaxHP, Integer(ProcessMsg.BaseObject) {AttackBaseObject}, '');
            end;
          end;
          if m_boFastParalysis then begin
            m_wStatusTimeArr[POISON_STONE] := 1;
            m_boFastParalysis := False;
          end;
        end;
      RM_MAGHEALING: begin //10026
          nCode := 2;
          if (m_nIncHealing + ProcessMsg.nParam1) < 300 then begin
            if m_btRaceServer = RC_PLAYOBJECT then begin
              Inc(m_nIncHealing, ProcessMsg.nParam1);
              m_nPerHealing := 5;
            end else begin
              Inc(m_nIncHealing, ProcessMsg.nParam1);
              m_nPerHealing := 5;
            end;
          end else m_nIncHealing := 300;
        end;
      RM_10101: begin //10101
          nCode := 3;
          SendRefMsg(Integer(ProcessMsg.BaseObject),
            ProcessMsg.wParam {nPower},
            ProcessMsg.nParam1 {HP},
            ProcessMsg.nParam2 {MaxHP},
            ProcessMsg.nParam3 {AttackSrc},
            ProcessMsg.sMsg);
          if (Integer(ProcessMsg.BaseObject) = RM_STRUCK) and (m_btRaceServer <> RC_PLAYOBJECT) then begin
            SendMsg(Self, Integer(ProcessMsg.BaseObject),
              ProcessMsg.wParam,
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              ProcessMsg.nParam3 {AttackBaseObject},
              ProcessMsg.sMsg);
          end;
          if m_boFastParalysis then begin //快速麻痹，受攻击后麻痹立即消失
            m_wStatusTimeArr[POISON_STONE] := 1;
            m_boFastParalysis := False;
          end;
        end;
      RM_10102: begin
          SendRefMsg(Integer(ProcessMsg.BaseObject),
            ProcessMsg.wParam {nPower},
            ProcessMsg.nParam1 {HP},
            ProcessMsg.nParam2 {MaxHP},
            ProcessMsg.nParam3 {AttackSrc},
            ProcessMsg.sMsg);
          if (Integer(ProcessMsg.BaseObject) = RM_STRUCK) { and (m_btRaceServer <> RC_PLAYOBJECT)} then begin
            SendMsg(Self, Integer(ProcessMsg.BaseObject),
              ProcessMsg.wParam,
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              ProcessMsg.nParam3 {AttackBaseObject},
              ProcessMsg.sMsg);
          end;
          if m_boFastParalysis then begin //快速麻痹，受攻击后麻痹立即消失
            m_wStatusTimeArr[POISON_STONE] := 1;
            m_boFastParalysis := False;
          end;
        end;
      RM_DELAYMAGIC1: begin //延时发送魔法消息
          TargeTBaseObject := TBaseObject(ProcessMsg.BaseObject);
          if TargeTBaseObject <> nil then begin
            TargeTBaseObject.SendRefMsg(RM_10205, ProcessMsg.wParam {类型}, ProcessMsg.nParam1 {X}, ProcessMsg.nParam2 {Y}, ProcessMsg.nParam3 {目标ID}, '');
          end;
        end;
      RM_DELAYMAGIC: begin
          nCode := 4;
          nPower := ProcessMsg.wParam;
          nTargetX := LoWord(ProcessMsg.nParam1);
          nTargetY := HiWord(ProcessMsg.nParam1);
          nRage := ProcessMsg.nParam2;
          nCode := 41;
          TargeTBaseObject := TBaseObject(ProcessMsg.nParam3);
          nCode := 42;
          if (TargeTBaseObject <> nil) then begin
            if (TargeTBaseObject.GetMagStruckDamage(Self, nPower, {0} 1, 1) > 0) then begin //20110102 修改,防止,魔法出现两次暴击
              nCode := 43;
              if m_btRaceServer = RC_HEROOBJECT then begin //20080427 修正英雄锁定后,不打锁定怪
                nCode := 44;
                if not THeroObject(self).m_boTarget then SetTargetCreat(TargeTBaseObject);
              end else SetTargetCreat(TargeTBaseObject);
              nCode := 45;
              if m_boAI {or (m_btRaceServer in [RC_PLAYMOSTER, RC_HEROOBJECT])} then begin
                if (TargeTBaseObject.m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT, RC_PLAYMOSTER]) or ((TargeTBaseObject.m_Master <> nil) and (TargeTBaseObject.Master.m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT, RC_PLAYMOSTER])) then begin
                  if (m_TargetCret <> nil) and ((m_TargetCret.m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT, RC_PLAYMOSTER]) or ((m_TargetCret.m_Master <> nil) and (m_TargetCret.Master.m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT, RC_PLAYMOSTER]))) then begin
                    if ((MINXY(m_TargetCret, TargeTBaseObject) = TargeTBaseObject) or (Random(6) = 0)) and (GetTickCount() - m_dwTargetFocusTick > 1000 * 3) then SetTargetCreat(TargeTBaseObject);
                  end else begin
                    SetTargetCreat(TargeTBaseObject);
                  end;
                  if m_boAI and (m_btRaceServer = RC_PLAYOBJECT) then begin
                    if (Random(15) = 0) and (TAIPlayObject(Self).m_AISayMsgList.Count > 0) then begin
                      if GetTickCount >= TPlayObject(Self).m_dwDisableSayMsgTick then TPlayObject(Self).m_boDisableSayMsg := False;
                      boDisableSayMsg := TPlayObject(Self).m_boDisableSayMsg;
                      g_DenySayMsgList.Lock;
                      try
                        if g_DenySayMsgList.GetIndex(m_sCharName) >= 0 then boDisableSayMsg := True;
                      finally
                        g_DenySayMsgList.UnLock;
                      end;
                      if not boDisableSayMsg then begin
                        SendRefMsg(RM_HEAR, 0, TPlayObject(Self).m_btHearMsgFColor, g_Config.btHearMsgBColor, 0, m_sCharName + ':' + TAIPlayObject(Self).m_AISayMsgList.Strings[Random(TAIPlayObject(Self).m_AISayMsgList.Count)]);
                      end;
                    end;
                  end;
                end else begin
                  if (m_TargetCret = nil) and IsProperTarget(TargeTBaseObject) then SetTargetCreat(TargeTBaseObject)
                  else begin
                    if ((m_TargetCret <> nil) and (MINXY(m_TargetCret, TargeTBaseObject) = TargeTBaseObject)) or (Random(6) = 0) then begin
                      if (m_btJob > 0) or ((m_TargetCret <> nil) and (GetTickCount() - m_dwTargetFocusTick > 1000 * 3)) then
                        if IsProperTarget(TargeTBaseObject) then SetTargetCreat(TargeTBaseObject);
                    end;
                  end;
                end;
              end;

              if TargeTBaseObject.m_btRaceServer >= RC_ANIMAL then nPower := Round(nPower / 1.2);
              nCode := 46;
              if (abs(nTargetX - TargeTBaseObject.m_nCurrX) <= nRage) and (abs(nTargetY - TargeTBaseObject.m_nCurrY) <= nRage) then
                TargeTBaseObject.SendMsg(Self, RM_MAGSTRUCK, 0, nPower, 0, 0, '');
            end;
          end;
        end;
      RM_10155: begin
          nCode := 5;
          MapRandomMove(ProcessMsg.sMsg, ProcessMsg.wParam);
        end;
      RM_DELAYPUSHED: begin
          nCode := 6;
          nPower := ProcessMsg.wParam;
          nRage := ProcessMsg.nParam2;
          TargeTBaseObject := TBaseObject(ProcessMsg.nParam3);
          if (TargeTBaseObject <> nil) then begin
            TargeTBaseObject.CharPushed(nPower, nRage);
          end;
        end;
      RM_POISON: begin //中红，绿毒
          nCode := 7;
          TargeTBaseObject := TBaseObject(ProcessMsg.nParam2);
          if TargeTBaseObject <> nil then begin
            if IsProperTarget(TargeTBaseObject) then begin
              if m_btRaceServer = RC_HEROOBJECT then begin //20080531 修正英雄锁定后,不打锁定怪
                if (TargeTBaseObject.m_btRaceServer = RC_PLAYOBJECT) or (TargeTBaseObject.m_btRaceServer = RC_HEROOBJECT) then //英雄灰色 20080721
                  SetPKFlag(TargeTBaseObject);
                if not THeroObject(self).m_boTarget then SetTargetCreat(TargeTBaseObject);
              end else SetTargetCreat(TargeTBaseObject);
              if (m_btRaceServer = RC_PLAYOBJECT) and ((TargeTBaseObject.m_btRaceServer = RC_PLAYOBJECT) or (TargeTBaseObject.m_btRaceServer = RC_HEROOBJECT)) then begin //英雄灰色 20080721
                SetPKFlag(TargeTBaseObject);
              end;
              SetLastHiter(TargeTBaseObject);
            end;
            if not m_boUnPosion then MakePosion(ProcessMsg.wParam {中毒类型}, ProcessMsg.nParam1 {nPower-时间}, ProcessMsg.nParam3 {点数});
          end else begin
            if not m_boUnPosion then MakePosion(ProcessMsg.wParam {中毒类型}, ProcessMsg.nParam1 {nPower}, ProcessMsg.nParam3);
          end;
        end;
      RM_TRANSPARENT: begin //10308
          nCode := 8;
          MagicManager.MagMakePrivateTransparent(Self, ProcessMsg.nParam1);
        end;
      RM_DOOPENHEALTH: begin //10412
          nCode := 9;
          MakeOpenHealth();
        end;
{$IF CHECKNEWMSG = 1}
    else begin
        MainOutMessage(Format('人物: %s 消息: Ident %d Param %d P1 %d P2 %d P3 %d Msg %s',
          [m_sCharName, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3,
          ProcessMsg.sMsg]));
      end;
{$IFEND}
    end;
  except
    MainOutMessage(Format(sExceptionMsg, [g_sExceptionVer, nCode, ExceptAddr]));
  end;
end;

function TPlayObject.Operate(ProcessMsg: pTProcessMessage): Boolean;
var
  CharDesc: TCharDesc;
  nObjCount: Integer;
  s1C: string;
  MessageBodyWL: TMessageBodyWL;
  MessageBodyWL2:TMessageBodyWL2;
  MessageBodyW: TMessageBodyW;
  ShortMessage: TShortMessage;
  OAbility: TOAbility;
  dwDelayTime: LongWord;
  nMsgCount: Integer;
  nCode: Word;

  Feature: TFeatures;
begin
  Result := True;
  try
    if (ProcessMsg = nil) {or (m_boGhost and (ProcessMsg.wIdent <> RM_LOGON))} then begin //20101008 注释
      Result := False;
      Exit;
    end;
    nCode := 1;
    case ProcessMsg.wIdent of
      RM_SendItemEffs:SendEffecItems;
      CM_QUERYUSERLEVELSORT: begin //查询排行榜
          nCode := 16;
          ClientGetUserOrder(ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3);
        end;
{$IF HEROVERSION = 1}
      CM_RECALLHERO: begin //召唤英雄
          if (GetTickCount - m_dwUserTick[8] >= 500) and g_Config.boUseCanHero then begin
            m_dwUserTick[8] := GetTickCount;
            nCode := 2;
            if ProcessMsg.nParam1 = 0 then ClientRecallHero() //召唤英雄
            else ClientRecallDeputyHero(); //召唤副将英雄
          end;
        end;
      CM_HEROLOGOUT: begin //英雄退出
          if (GetTickCount - m_dwUserTick[8] >= 400) and g_Config.boUseCanHero then begin
            m_dwUserTick[8] := GetTickCount;
            nCode := 3;
            if not m_boHeroDieTreatment then ClientHeroLogOut(0);
          end;
        end;
      CM_QUERYHEROBAGITEMS: begin //刷新英雄的包裹
          nCode := 4;
          if m_MyHero <> nil then begin
            THeroObject(m_MyHero).ClientQueryBagItems; //发送英雄包裹
            SendMsg(Self, RM_SENDHEROUSEITEMS, 0, 0, 0, 0, ''); //发送英雄身上装备
            SendMsg(Self, RM_SENDHEROMYMAGIC, 0, 0, 0, 0, ''); //发送英雄使用魔法
            SendMsg(Self, RM_QUERYHEROBAGCOUNT, 0, THeroObject(m_MyHero).m_nItemBagCount, 0, 0, ''); //发送英雄包裹容量
            THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROABILITY, 0, 0, 0, 0, ''); //发送英雄属性
            THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROSUBABILITY, 0, 0, 0, 0, ''); //发送英雄属性
          end;
        end;
      CM_HEROAUTOOPENDEFENCE: begin //客户端设置英雄持续开盾 20080930
          nCode := 316;
          if m_MyHero <> nil then begin
            THeroObject(m_MyHero).boAutoOpenDefence := ProcessMsg.nParam1 = 1;
            if THeroObject(m_MyHero).boAutoOpenDefence then SysMsg('(英雄)已开启持久开盾', c_Blue, t_Hint);
          end;
        end;
      CM_HEROMAGICKEYCHANGE: begin //客户端设置英雄魔法开关 20080606
          nCode := 5;
          if m_MyHero <> nil then begin
            THeroObject(m_MyHero).ChangeHeroMagicKey(ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.sMsg);
          end;
        end;
      CM_QUERYHEROBAGCOUNT: begin
          nCode := 6;
          if m_MyHero <> nil then begin
            SendMsg(Self, RM_QUERYHEROBAGCOUNT, 0, THeroObject(m_MyHero).m_nItemBagCount, 0, 0, ''); //发送英雄包裹容量
          end;
        end;
      CM_HEROTAKEONITEM: begin //8102 英雄穿装备
          nCode := 7;
          ClientHeroTakeOnItems(ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
      CM_HEROTAKEOFFITEM: begin //8103 英雄脱下装备
          nCode := 8;
          ClientHeroTakeOffItems(ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
      {CM_TAKEOFFITEMHEROBAG, CM_TAKEOFFITEMTOMASTERBAG: begin //装备脱下到英雄包裹 //装备脱下到主人包裹
          nCode:=9;
          ClientHeroTakeOffItemsToBag(ProcessMsg.wIdent, ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;}
      CM_SENDITEMTOMASTERBAG, CM_SENDITEMTOHEROBAG: begin //主人包裹到英雄包裹 //英雄包裹到主人包裹
          nCode := 10;
          ClientBagToBag(ProcessMsg.wIdent, ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
      CM_HEROTAKEONITEMFORMMASTERBAG, CM_TAKEONITEMFORMHEROBAG: begin //从主人包裹穿装备到英雄包裹 //从英雄包裹穿装备到主人包裹
          nCode := 11;
          ClientTakeOnItemsFormBag(ProcessMsg.wIdent, ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
      CM_ASSESSMENTHERO: begin //评定英雄
          ClientAssessmentMainHero(ProcessMsg.sMsg, ProcessMsg.nParam1, ProcessMsg.nParam2); //评定主将英雄
        end;
      CM_HEROAUTOPRACTICE: begin //英雄自我修炼
          ClientHeroAutoPractice(ProcessMsg.nParam1 {场所}, ProcessMsg.nParam2 {强度});
        end;
      CM_HEROEAT: begin //英雄使用物品
          nCode := 12;
          ClientHeroUseItems(ProcessMsg.nParam1, ProcessMsg.sMsg, ProcessMsg.nParam2);
        end;
      CM_HEROCHGSTATUS: begin //改变英雄状态
          nCode := 13;
          ClientChgHeroStatus();
        end;
      CM_HEROPROTECT: begin //英雄守护
          nCode := 14;
          ClientHeroProtect(ProcessMsg.nParam2, ProcessMsg.nParam3);
        end;
      CM_HEROATTACKTARGET: begin //锁定目标
          nCode := 15;
          ClientHeroAttack(TBaseObject(ProcessMsg.nParam1), ProcessMsg.nParam2, ProcessMsg.nParam3);
        end;
      CM_HERODROPITEM: begin //英雄包裹扔物品
          nCode := 28;
          if m_MyHero <> nil then begin
            if THeroObject(m_MyHero).ClientDropItem(ProcessMsg.sMsg, ProcessMsg.nParam1) then
              SendDefMessage(SM_HERODROPITEM_SUCCESS, ProcessMsg.nParam1, 0, 0, 0, ProcessMsg.sMsg)
            else SendDefMessage(SM_HERODROPITEM_FAIL, ProcessMsg.nParam1, 0, 0, 0, ProcessMsg.sMsg);
          end;
        end;
      CM_HEROGOTETHERUSESPELL: begin //接收到客户传来发合击的消息 20080229
          nCode := 29;
          if m_MyHero <> nil then ClientHeroUseSpell();
        end;
      CM_REPAIRFIRDRAGON: begin //修补火龙之心
          nCode := 30;
          if m_MyHero <> nil then
            THeroObject(m_MyHero).RepairFirDragon(ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
      CM_REPAIRDRAGONINDIA: begin //修补天龙印
          if (ProcessMsg.nParam2 > 0) then begin
            case ProcessMsg.nParam2 of
              1: RepairDragonIndia(ProcessMsg.nParam1, ProcessMsg.sMsg);
              2: begin //英雄
                  if m_MyHero <> nil then
                    THeroObject(m_MyHero).RepairDragonIndia(ProcessMsg.nParam1, ProcessMsg.sMsg);
                end;
            end;
          end;
        end;
  ///------------------------酒馆 20080515---------------------------------------
      CM_SELGETHERO: begin //取回英雄 20080514
          nCode := 39;
          ClientGETHERO(ProcessMsg.sMsg, ProcessMsg.nParam1);
        end;
      CM_USERPLAYDRINKITEM: begin
          nCode := 40;
          ClientPlayDrinkItem(TObject(ProcessMsg.nParam1), MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
        end;
      CM_PlAYDRINKGAME: begin //猜拳码数
          nCode := 41;
          ClientPlayDrinkToDrink(ProcessMsg.nParam1, ProcessMsg.nParam2);
        end;
      CM_DrinkUpdateValue: begin //改变酒精度
          nCode := 42;
          ClientDrinkUpdateValue(ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3);
        end;
      CM_USERPLAYDRINK: begin //请酒
          nCode := 43;
          ClientPlayDrink(ProcessMsg.sMsg);
        end;
      RM_HEROWINEXP: begin
          nCode := 59;
          if THeroObject(m_MyHero) <> nil then begin
            m_DefMsg := MakeDefaultMsg(SM_HEROWINEXP, 0{THeroObject(m_MyHero).m_Abil.nExp}, LoWord(ProcessMsg.nParam1), HiWord(ProcessMsg.nParam1), 0, 0);

            SendSocket(@m_DefMsg, ProcessMsg.sMsg);
          end;
        end;
      RM_HEROLEVELUP: begin //英雄升级
          nCode := 60;
          if m_MyHero <> nil then begin
            m_DefMsg := MakeDefaultMsg(SM_HEROLEVELUP, 0{m_MyHero.m_Abil.Exp}, m_MyHero.m_Abil.Level, 0, 0, 0);

            SendSocket(@m_DefMsg, ProcessMsg.sMsg);
            //m_DefMsg := MakeDefaultMsg(SM_HEROABILITY, Integer(m_MyHero), m_MyHero.m_btGender, MakeWord(m_MyHero.m_btJob,m_MyHero.m_btHair), 0);
            m_DefMsg := MakeDefaultMsg(SM_HEROABILITY, {Integer(m_MyHero)} m_MyHero.m_btGender, 0, {MakeWord(} m_MyHero.m_btJob {, 99)}, THeroObject(m_MyHero).m_nLoyal, 0);
            SendSocket(@m_DefMsg, EncodeBuffer(@m_MyHero.m_WAbil, SizeOf(TAbility)));

            {SendDefMessage(SM_HEROSUBABILITY,//20110712 修改
              MakeLong(MakeWord(m_MyHero.m_nAntiMagic, 0), 0),
              MakeWord(m_MyHero.m_btHitPoint, m_MyHero.m_btSpeedPoint),
              MakeWord(m_MyHero.m_btAntiPoison, m_MyHero.m_nPoisonRecover),
              MakeWord(m_MyHero.m_nHealthRecover, m_MyHero.m_nSpellRecover),
              '');}
            m_DefMsg := MakeDefaultMsg(SM_HEROSUBABILITY,
              MakeLong(MakeWord(m_MyHero.m_nAntiMagic, 0), 0),
              MakeWord(m_MyHero.m_btHitPoint, m_MyHero.m_btSpeedPoint),
              MakeWord(m_MyHero.m_btAntiPoison, m_MyHero.m_nPoisonRecover),
              MakeWord(m_MyHero.m_nHealthRecover, m_MyHero.m_nSpellRecover), 0);
            SendSocket(@m_DefMsg, EncodeBuffer(@THeroObject(m_MyHero).ClientSuitAbility, SizeOf(TClientSuitAbility)) {套装属性值});
          end;
        end;
      RM_OPENHEROAUTOPRA: begin //打开英雄自我修炼窗口
          m_DefMsg := MakeDefaultMsg(SM_OPENHEROAUTOPRA,
            ProcessMsg.nParam1, //职业
            ProcessMsg.nParam2, //性别
            ProcessMsg.nParam3,
            ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_HEROABILITY: begin
          nCode := 61;
          if m_MyHero <> nil then begin
            m_DefMsg := MakeDefaultMsg(SM_HEROABILITY, m_MyHero.m_btGender, {$IF M2Version = 1}Integer(THeroObject(m_MyHero).m_boOpenupSkill95){$ELSE}0{$IFEND}, m_MyHero.m_btJob, THeroObject(m_MyHero).m_nLoyal, m_MyHero.m_wStatusArrValue[2]); //发送英雄真气值 201010804
            SendSocket(@m_DefMsg, EncodeBuffer(@m_MyHero.m_WAbil, SizeOf(TAbility)));
          end;
        end;
      RM_RECALLHERO: begin //召唤英雄
          nCode := 62;
          SendDefMessage(SM_RECALLHERO,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            ProcessMsg.wParam,
            ProcessMsg.sMsg);
        end;
      RM_CREATEHERO: begin //创建英雄
          nCode := 63;
          m_DefMsg := MakeDefaultMsg(SM_CREATEHERO,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam, 0);
          m_DefMsg.nSessionID := TBaseObject(ProcessMsg.BaseObject).GetFeature(CharDesc.feature);
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, sizeof(TCharDesc) - SizeOf(TFeatures) + m_DefMsg.nSessionID));
        end;
      RM_DESTROYHERO: begin //英雄销毁
          nCode := 64;
          m_DefMsg := MakeDefaultMsg(SM_DESTROYHERO,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_MAKEGHOSTHERO: begin
          nCode := 65;
          if m_MyHero <> nil then begin
            m_MyHero.m_boDeath := True;
            m_MyHero.m_dwDeathTick := GetTickCount;
            m_MyHero.MakeGhost;
            m_MyHero := nil;
          end;
        end;
      RM_SENDHEROUSEITEMS: begin //发送英雄身上装备
          nCode := 66;
          if m_MyHero <> nil then THeroObject(m_MyHero).SendUseitems();
        end;
      RM_HEROWEIGHTCHANGED: begin
          nCode := 67;
          if m_MyHero = nil then Exit;
          SendDefMessage(SM_HEROWEIGHTCHANGED,
            m_MyHero.m_WAbil.Weight,
            m_MyHero.m_WAbil.WearWeight,
            m_MyHero.m_WAbil.HandWeight,
            0,
            '');
        end;
      RM_HERODEATH: begin //英雄死亡
          nCode := 68;
          m_DefMsg := MakeDefaultMsg(SM_HERODEATH, Integer(ProcessMsg.BaseObject), 0, 0, 0, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_SENDHEROMYMAGIC: begin //发送英雄所学的技能
          nCode := 69;
          if m_MyHero <> nil then THeroObject(m_MyHero).SendUseMagic();
        end;
      RM_QUERYHEROBAGCOUNT: begin
          nCode := 70;
          SendDefMessage(SM_QUERYHEROBAGCOUNT,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            LoWord(ProcessMsg.nParam3),
            HiWord(ProcessMsg.nParam3),
            '');
        end;
      RM_HEROMAGIC_LVEXP: begin //英雄魔法升级
          nCode := 71;
          SendDefMessage1(SM_HEROMAGIC_LVEXP, ProcessMsg.wParam {技能ID}, ProcessMsg.nParam2 {技能等级},
            LoWord(ProcessMsg.nParam3), HiWord(ProcessMsg.nParam3) {当前修炼值}, ProcessMsg.nParam1 {酒气护体，召唤圣兽升级经验值}, '');
        end;
      RM_HEROSUBABILITY: begin
          nCode := 72;
          if m_MyHero <> nil then begin
            {SendDefMessage(SM_HEROSUBABILITY,//20110712 修改
              MakeLong(MakeWord(m_MyHero.m_nAntiMagic, 0), 0),
              MakeWord(m_MyHero.m_btHitPoint, m_MyHero.m_btSpeedPoint),
              MakeWord(m_MyHero.m_btAntiPoison, m_MyHero.m_nPoisonRecover),
              MakeWord(m_MyHero.m_nHealthRecover, m_MyHero.m_nSpellRecover), '');}
            m_DefMsg := MakeDefaultMsg(SM_HEROSUBABILITY,
              MakeLong(MakeWord(m_MyHero.m_nAntiMagic, 0), 0),
              MakeWord(m_MyHero.m_btHitPoint, m_MyHero.m_btSpeedPoint),
              MakeWord(m_MyHero.m_btAntiPoison, m_MyHero.m_nPoisonRecover),
              MakeWord(m_MyHero.m_nHealthRecover, m_MyHero.m_nSpellRecover), 0);
            SendSocket(@m_DefMsg, EncodeBuffer(@THeroObject(m_MyHero).ClientSuitAbility, SizeOf(TClientSuitAbility)) {套装属性值});
          end;
        end;
{$IF M2Version = 1}
      CM_OPENHEROPULSEPOINT: begin //客户端点击英雄穴位
          if m_MyHero <> nil then begin
            THeroObject(m_MyHero).ClientOpenHeroPulsePoint(ProcessMsg.nParam1 {经络页}, ProcessMsg.nParam2 {穴位});
          end;
        end;
      CM_HEROUSEBATTERTOMON: begin //英雄打怪是否使用连击
          nCode := 316;
          if m_MyHero <> nil then begin
            THeroObject(m_MyHero).boUseBatterToMon := ProcessMsg.nParam1 <> 1;
          end;
        end;
      CM_AUTOGAMEGIRDUPSKILL95: begin //自动修炼技能(斗转星移)
          if (ProcessMsg.nParam1 > 0) then begin
            if (m_nDecGameGirdCount_95 = 0) and (m_nDecGameGirdCount_Hero95 = 0) then begin
              if m_nDecGameGirdCount = 0 then begin
                case ProcessMsg.nParam1 of
                  1: begin //1800张60次
                      m_dwDecGameGirdTick := GetTickCount;
                      m_nDecGameGird := 30; //一次减灵符数
                      if ProcessMsg.nParam2 = 0 then m_nDecGameGirdCount_95 := 60 //减灵符次数
                      else m_nDecGameGirdCount_Hero95 := 60;
                      SysMsg('灵符自动修炼奇经开始，您申请了60次，召唤出英雄后即开始自动修炼!', c_Blue, t_Hint);
                    end;
                  2: begin //3600张120次
                      m_dwDecGameGirdTick := GetTickCount;
                      m_nDecGameGird := 30; //一次减灵符数
                      if ProcessMsg.nParam2 = 0 then m_nDecGameGirdCount_95 := 120 //减灵符次数
                      else m_nDecGameGirdCount_Hero95 := 120;
                      SysMsg('灵符自动修炼奇经开始，您申请了120次，召唤出英雄后即开始自动修炼!', c_Blue, t_Hint);
                    end;
                end;
              end else SysMsg('您英雄已处于白日门强身术的修炼过程中，暂时无法进行其他修炼！', c_Blue, t_Hint);
            end else begin
              if (m_nDecGameGirdCount_95 > 0) then SysMsg('您主号的神冲穴已处于自动修炼状态，暂时无法进行其他修炼！', c_Blue, t_Hint);
              if (m_nDecGameGirdCount_Hero95 > 0) then SysMsg('您英雄的神冲穴已处于自动修炼状态，暂时无法进行其他修炼！', c_Blue, t_Hint);
            end;
          end;
        end;
      CM_CLOSEGAMEGIRDUPSKILL95: begin //取消自动修炼(斗转星移)
          m_nDecGameGird := 0; //一次减灵符数
          m_nDecGameGirdCount_95 := 0; //减灵符次数
          m_nDecGameGirdCount_Hero95 := 0;
          SysMsg('灵符自动修炼奇经已结束', c_Blue, t_Hint);
        end;
      CM_QUERYGAMEGIRDUPSKILL95: begin //查询剩余修炼次数(斗转星移)
          if m_nDecGameGirdCount_Hero95 > 0 then begin
            SysMsg(Format('当前剩余灵符修炼奇经次数:%d', [m_nDecGameGirdCount_Hero95]), c_Blue, t_Hint);
          end else SysMsg(Format('当前剩余灵符修炼奇经次数:%d', [m_nDecGameGirdCount_95]), c_Blue, t_Hint)
        end;
      CM_OPENUPSKILL95: begin //打通斗转99级
          ClientOpenupSkill95(ProcessMsg.nParam1 {制造制造ID}, ProcessMsg.nParam2 {类型 0-主体 1-英雄});
        end;
      CM_LIANQIPRACTICE: begin //炼气窗口,点击修炼(判断修炼的条件是否合适)
          ClientCheckLianQiConditions(ProcessMsg.nParam1);
        end;
      CM_CLENTGETLIANQIPRACTICE: begin //提取炼气物品
          ClientGetLianQiPractice(ProcessMsg.nParam1);
        end;
      RM_OPENUPSKILL95_FAIL: begin //打通斗转99级失败
          SendDefMessage(SM_OPENUPSKILL95_FAIL, ProcessMsg.nParam1, 0, 0, 0, '');
        end;
{$IFEND}
      CM_CHOOSEHEROJOB: begin //设置所选副将职业(面板上选择哪个职业英雄出战)
          if ProcessMsg.nParam1 < 3 then m_btDeputyHeroJob := ProcessMsg.nParam1;
        end;
      CM_SHOWHEROLEVEL: begin //副将英雄等级受限提示开启
          m_boShowHeroLevel := ProcessMsg.nParam1 <> 0;
        end;
{$IF M2Version <> 2}
      CM_INCHEATRPOINT: begin //点击Exp按键，执行QF脚本段(999心法吸收功能)
          if GetTickCount - m_dwUserTick[1] >= 300 then begin
            m_dwUserTick[1] := GetTickCount;
            ClientIncHeartPoint();
          end;
        end;
      CM_DIVISIONGETFENGHAO: begin //门派老大点击"称号领取",判断后,执行触发段
          if GetTickCount - m_dwUserTick[1] >= 300 then begin
            m_dwUserTick[1] := GetTickCount;
            ClientDivisionGetFengHao();
          end;
        end;
      CM_CHANGESAVVYHEARTSKILL: begin //改变龙卫心法类型
          ClientChangeSavvyHeartSkill(ProcessMsg.nParam1 {心法类型});
        end;
      CM_SAVVYHEARTSKILL: begin //领悟龙卫心法
          ClientSavvyHeartSkill(ProcessMsg.nParam1 {心法类型}, ProcessMsg.sMsg {自定义心名称});
        end;
      CM_DIVISIONAPPLYLIST: begin //取申请入门列表
          ClientDivisionApplyList();
        end;
      CM_DIVISIONMEMBERLIST: begin //取门派成员数据
          ClientDivisionMemberList;
        end;
      CM_DIVISIONHOME, //打开门派首页
        CM_OPENDIVISIONDLG: begin //打开门派对话框
          ClientOpenDivisionDlg;
        end;
      CM_DIVISIONUPDATENOTICE: begin //修改门派公告
          ClientDivisionUpdateNotice(ProcessMsg.sMsg);
        end;
      CM_DIVISIONDDELMEMBER: begin //删除门派成员
          ClientDelDivisionUser(ProcessMsg.sMsg);
        end;
      CM_AGREEAPPLYDIVISION: begin //门派老大同意入门申请
          ClientAgreeDivisionApply(ProcessMsg.sMsg);
        end;
      CM_CANCELAPPLYDIVISION: begin //门派老大取消入门申请
          ClientCancelDivisionApply(ProcessMsg.sMsg);
        end;
      CM_APPLYDIVISION: begin //申请(取消)入门派
          ClientApplyDivision(ProcessMsg.sMsg);
        end;
      CM_NAMEQUERYDIVISIONLIST: begin //申请入门派窗口按宗师名查询
          ClientNameQueryDivision(ProcessMsg.sMsg);
        end;
      CM_QUERYDIVISIONLIST: begin //申请入门派窗口翻页
          if GetTickCount - m_dwUserTick[1] >= 300 then begin
            m_dwUserTick[1] := GetTickCount;
            ClientQueryDivision(ProcessMsg.nParam1 {0-上一页 1-下一页});
          end;
        end;
      RM_QUERYDIVISIONLIST: begin //打开申请入门派窗口(接消息打开窗口，并显示数据)
          m_DefMsg := MakeDefaultMsg(SM_QUERYDIVISIONLIST, Integer(ProcessMsg.BaseObject), 0, 0, 0, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_SENDHEARTINFO: begin
          m_DefMsg := MakeDefaultMsg(SM_SENDHEARTINFO, 0, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_MAGIC_UPLVEXPEXP: begin //强化技能升级
          m_DefMsg := MakeDefaultMsg(SM_MAGIC_UPLVEXPEXP, ProcessMsg.wParam {技能ID}, ProcessMsg.nParam2 {技能等级}, 0, 0, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_SHOWHEARTEFF: begin //显示龙卫状态效果
          HeartUpAbility(); //心法激活(同时激活弟子心法)
        end;
      RM_OPENSAVVYHEART: begin //打开领悟心法窗口
          m_DefMsg := MakeDefaultMsg(SM_OPENSAVVYHEART,
            ProcessMsg.nParam1 {当前心法类型},
            ProcessMsg.wParam {类型}, ProcessMsg.nParam2 {所需等级}, 0, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_BUILDDIVISION_OK: begin //创建师门成功
          SendDefMessage(SM_BUILDDIVISION_OK, 0, 0, 0, 0, '');
        end;
      RM_BUILDDIVISION_FAIL: begin //创建师门失败
          SendDefMessage(SM_BUILDDIVISION_FAIL, ProcessMsg.nParam1, 0, 0, 0, '');
        end;
      CM_NGMAGICLVEXP: begin //客户端点击内功技能面板上的“升级”  20110605
          if GetTickCount - m_dwUserTick[1] >= 400 then begin
            m_dwUserTick[1] := GetTickCount;
            case ProcessMsg.nParam2 of
              0: ClientUpNGStrongSkill(ProcessMsg.nParam1 {技能ID});
              1: if m_MyHero <> nil then THeroObject(m_MyHero).ClientHeroUpNGStrongSkill(ProcessMsg.nParam1 {技能ID});
            end;
          end;
        end;
      CM_SETUSERTITLES: begin //客户端设置称号
          if GetTickCount - m_dwUserTick[1] >= 400 then begin
            m_dwUserTick[1] := GetTickCount;
            ClientSetUserTitles(ProcessMsg.nParam1 {称号制造ID}, ProcessMsg.nParam2 {操作类型});
          end;
        end;
      RM_SETUSERTITLES: begin //设置称号成功
          m_DefMsg := MakeDefaultMsg(SM_SETUSERTITLES, 0, ProcessMsg.nParam1, 0, 0, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_SENDHUMTITLES: begin
          m_dwUseTitleTick := GetTickCount();
          SendHumTitles(0);
        end;
      CM_SETSHOWFENGHAO: begin //内挂设置隐藏称号
          m_boShowFengHao := ProcessMsg.nParam1 <> 1;
          if m_boCanTitle then begin
            if m_boShowFengHao then begin
              m_sUseIitleName := '';
              RefShowName();
            end else begin
              if m_boUseTitle then begin
                GetUseHumTitles();
                RefShowName();
              end;
            end;
          end;
        end;
      CM_CALLFENGHAO: begin //召唤传送称号人员
          if GetTickCount - m_CallFengHaoPlayTick >= 180000 then begin
            ClientCallFengHaoPlay(ProcessMsg.nParam1 {类型 0-护花令牌 1-主宰令牌}, ProcessMsg.nParam2 {操作类型 0-召唤 1-传送}, ProcessMsg.sMsg {名字});
          end else SysMsg(IntToStr((180000 - (GetTickCount - m_CallFengHaoPlayTick)) div 1000) + ' 秒之后才可以再使用此功能！', c_Red, t_Hint);
        end;
      CM_AGREECALLFENGHAO: begin //同意召唤传送(护花使者或龙卫)
          if GetTickCount - m_dwUserTick[1] >= 400 then begin
            m_dwUserTick[1] := GetTickCount;
            ClientAgreeCallFengHao(ProcessMsg.nParam1 {类型 0-护花令牌 1-主宰令牌}, ProcessMsg.nParam2 {操作类型 0-召唤 1-传送});
          end;
        end;
      CM_CANCELCALLFENGHAO: begin //取消召唤传送
          if GetTickCount - m_dwUserTick[1] >= 400 then begin
            m_dwUserTick[1] := GetTickCount;
            ClientCancelCallFengHao(ProcessMsg.nParam1 {类型 0-护花令牌 1-主宰令牌}, ProcessMsg.nParam2 {操作类型 0-召唤 1-传送});
          end;
        end;
      CM_FENGHAOAGREE: begin //任命称号确认 20110313
          if GetTickCount - m_dwUserTick[1] >= 400 then begin
            m_dwUserTick[1] := GetTickCount;
            ClientFenghaoAgree(ProcessMsg.nParam1 {类型 0-不同意 1-同意});
          end;
        end;
      CM_WORLDFLY: begin //点击世界地图传送(主宰令)
          if GetTickCount - m_dwUserTick[1] >= 400 then begin
            m_dwUserTick[1] := GetTickCount;
            ClientDominateFly(ProcessMsg.sMsg);
          end;
        end;
      RM_WORLDFLY: begin
          m_DefMsg := MakeDefaultMsg(SM_WORLDFLY, 0, ProcessMsg.nParam1, 0, 0, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      CM_CLOSEDOMINATETOKEN: begin //关闭主宰令
          m_boOpenDominateToken := False; //是否打开主宰令牌
        end;
      CM_RECYCFENGHAO: begin //回收称号
          if GetTickCount - m_dwUserTick[1] >= 400 then begin
            m_dwUserTick[1] := GetTickCount;
            ClientRecycFengHao(ProcessMsg.nParam1 {类型 0-护花令牌 1-主宰令牌}, ProcessMsg.sMsg {名字}); //客户端回收称号
          end;
        end;
      CM_AUTOGAMEGIRDUPSKILL99: begin //自动修炼技能(强身术)
          if (ProcessMsg.nParam1 > 0) then begin
            if (m_nDecGameGirdCount_95 = 0) and (m_nDecGameGirdCount_Hero95 = 0) then begin
              if m_nDecGameGirdCount = 0 then begin
                case ProcessMsg.nParam1 of
                  1: begin
                      if m_nGameGird >= 10 then begin
                        m_dwDecGameGirdTick := GetTickCount;
                        m_nDecGameGird := 10; //一次减灵符数 20100818
                        m_nDecGameGirdCount := 180; //减灵符次数 20100818
                        SysMsg('灵符自动修炼白日门强身术开始，您申请了180次，召唤出英雄后即开始自动修炼！', c_Blue, t_Hint);
                      end else SysMsg('灵符不足，不能自动修炼！', c_Red, t_Hint);
                    end;
                  2: begin
                      if m_nGameGird >= 10 then begin
                        m_dwDecGameGirdTick := GetTickCount;
                        m_nDecGameGird := 10; //一次减灵符数 20100818
                        m_nDecGameGirdCount := 360; //减灵符次数 20100818
                        SysMsg('灵符自动修炼白日门强身术开始，您申请了360次，召唤出英雄后即开始自动修炼！', c_Blue, t_Hint);
                      end else SysMsg('灵符不足，不能自动修炼！', c_Red, t_Hint);
                    end;
                  3: begin
                      if m_nGameGird >= 30 then begin
                        m_dwDecGameGirdTick := GetTickCount;
                        m_nDecGameGird := 30; //一次减灵符数 20100818
                        m_nDecGameGirdCount := 180; //减灵符次数 20100818
                        SysMsg('灵符自动修炼白日门强身术开始，您申请了180次，召唤出英雄后即开始自动修炼！', c_Blue, t_Hint);
                      end else SysMsg('灵符不足，不能自动修炼！', c_Red, t_Hint);
                    end;
                  4: begin
                      if m_nGameGird >= 30 then begin
                        m_dwDecGameGirdTick := GetTickCount;
                        m_nDecGameGird := 30; //一次减灵符数 20100818
                        m_nDecGameGirdCount := 360; //减灵符次数 20100818
                        SysMsg('灵符自动修炼白日门强身术开始，您申请了360次，召唤出英雄后即开始自动修炼！', c_Blue, t_Hint);
                      end else SysMsg('灵符不足，不能自动修炼！', c_Red, t_Hint);
                    end;
                end;
              end else SysMsg('您英雄已处于白日门强身术的修炼过程中，暂时无法进行其他修炼！', c_Blue, t_Hint);
            end else begin
              if (m_nDecGameGirdCount_95 > 0) then SysMsg('您主号的神冲穴已处于自动修炼状态，暂时无法进行其他修炼！', c_Blue, t_Hint);
              if (m_nDecGameGirdCount_Hero95 > 0) then SysMsg('您英雄的神冲穴已处于自动修炼状态，暂时无法进行其他修炼！', c_Blue, t_Hint);
            end;
          end;
        end;
      CM_CLOSEGAMEGIRDUPSKILL99: begin //取消自动修炼(强身术)
          m_nDecGameGird := 0; //一次减灵符数 20100818
          m_nDecGameGirdCount := 0; //减灵符次数 20100818
          SysMsg('灵符自动修炼白日门强身术已结束', c_Blue, t_Hint);
        end;
      CM_QUERYGAMEGIRDUPSKILL99: begin //查询剩余修炼次数(强身术)
          SysMsg(Format('当前剩余灵符修炼强身健体次数:%d', [m_nDecGameGirdCount]), c_Blue, t_Hint);
        end;
{$IFEND}
{$IFEND}
  //---------------------------商铺---------------------------------------------
      CM_OPENSHOP: begin //打开商铺
          nCode := 17;
          if g_Config.g_boCanShop then ClientGetShopItemList(ProcessMsg.nParam2, ProcessMsg.nParam3); //20100630 商铺开启
        end;
      RM_OPENSHOP: begin //打开商铺
          nCode := 18;
          m_DefMsg := MakeDefaultMsg(SM_SENGSHOPITEMS,
            ProcessMsg.wParam,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_OPENSHOPSPECIALLY: begin
          nCode := 19;
          m_DefMsg := MakeDefaultMsg(SM_SENGSHOPSPECIALLYITEMS,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      CM_BUYSHOPITEM: begin //购买商铺物品
          nCode := 20;
          if g_Config.g_boCanShop then begin //20100630 商铺开启
            if GetTickCount - m_dwUserTick[1] >= 500 then begin
              m_dwUserTick[1] := GetTickCount;
              ClientBuyShopItem(ProcessMsg.sMsg, ProcessMsg.nParam1 {0-元宝或金币付款 1-游戏点});
            end else begin
              m_DefMsg := MakeDefaultMsg(SM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0, 0);
              SendSocket(@m_DefMsg, EncodeString('[失败]购买速度过快!'));
            end;
          end;
        end;
      RM_BUYSHOPITEM_FAIL: begin //购买商铺物品失败
          nCode := 21;
          case ProcessMsg.nParam1 of
            1: ProcessMsg.sMsg := '[失败]您的 ' + g_Config.sGameGoldName + ' 不足无法购买 ' + ProcessMsg.sMsg;
            2: ProcessMsg.sMsg := '[失败]您的包裹已满，请清理后在购买 ' + ProcessMsg.sMsg;
            3: ProcessMsg.sMsg := '[失败]没有找到 ' + ProcessMsg.sMsg;
            4: ProcessMsg.sMsg := '[失败]您的包裹没有足够的空位 ';
            8: ProcessMsg.sMsg := '[失败]您的 ' + g_Config.sGamePointName + ' 不足无法购买 ' + ProcessMsg.sMsg;
          end;
          m_DefMsg := MakeDefaultMsg(SM_BUYSHOPITEM_FAIL, 0, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
        end;
      CM_BUYSHOPITEMGIVE: begin //商铺赠送
          nCode := 22;
          if (g_Config.g_boCanShop) then begin //20100630 商铺开启
            if (g_Config.boCanBuyShopItemGive) then begin

            if GetTickCount - m_dwUserTick[1] >= 500 then begin
              m_dwUserTick[1] := GetTickCount;
              UpdateSendMsgCount(); //更新角色的动态密钥(防WPE)
              ClientBuyShopItemGive(ProcessMsg.sMsg, ProcessMsg.nParam1 {0-元宝或金币付款 1-游戏点});
            end else begin
              m_DefMsg := MakeDefaultMsg(SM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0, 0);
              SendSocket(@m_DefMsg, EncodeString('[失败]赠送速度过快!'));
            end;
            end else begin
              m_DefMsg := MakeDefaultMsg(SM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0, 0);
              SendSocket(@m_DefMsg, EncodeString('[失败]不允许赠送!'));
            end;
          end else begin
              m_DefMsg := MakeDefaultMsg(SM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0, 0);
              SendSocket(@m_DefMsg, EncodeString('[失败]商铺未开启!'));
            end;
        end;
      RM_BUYSHOPITEMGIVE_SUCCESS: begin //商铺赠送成功
          nCode := 23;
          m_DefMsg := MakeDefaultMsg(SM_BUYSHOPITEMGIVE_SUCCESS, 0, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
        end;
      RM_BUYSHOPITEMGIVE_FAIL: begin //商铺赠送失败
          nCode := 24;
          case ProcessMsg.nParam1 of
            1: ProcessMsg.sMsg := '[失败]您的 ' + g_Config.sGameGoldName + ' 不足无法赠送 ' + ProcessMsg.sMsg;
            2: ProcessMsg.sMsg := '[失败]没有找到 ' + ProcessMsg.sMsg;
            3: ProcessMsg.sMsg := '[失败]您朋友的包裹已满，请通知您朋友清理后在购赠送 ' + ProcessMsg.sMsg;
            4: ProcessMsg.sMsg := '[失败]您的朋友 ' + ProcessMsg.sMsg + ' 没有在线！';
            5: ProcessMsg.sMsg := '[失败]物品 ' + ProcessMsg.sMsg + ' 禁止赠送！';
            6: ProcessMsg.sMsg := '[失败]禁止赠送物品给自己！';
            7: ProcessMsg.sMsg := '[失败]您朋友的包裹没有足够的空位';
            8: ProcessMsg.sMsg := '[失败]您的 ' + g_Config.sGamePointName + ' 不足无法购买 ' + ProcessMsg.sMsg;
          end;
          m_DefMsg := MakeDefaultMsg(SM_BUYSHOPITEMGIVE_FAIL, 0, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
        end;
{$IF M2Version <> 2}
      CM_EXCHANGEGAMEGIRD: begin //兑换灵符
          nCode := 25;
          if g_Config.g_boCanShop then begin //20100630 商铺开启
            if GetTickCount - m_dwUserTick[1] >= 500 then begin
              m_dwUserTick[1] := GetTickCount;
              ClientExchangeGameGird(ProcessMsg.nParam2, ProcessMsg.nParam1 {类型 0-元宝 1-游戏点});
            end else begin
              m_DefMsg := MakeDefaultMsg(SM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0, 0);
              SendSocket(@m_DefMsg, EncodeString('[失败]兑换过快!'));
            end;
          end;
        end;
      RM_EXCHANGEGAMEGIRD_SUCCESS: begin //兑换灵符成功 20080730
          nCode := 26;
          m_DefMsg := MakeDefaultMsg(SM_EXCHANGEGAMEGIRD_SUCCESS, 0, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
        end;
      RM_EXCHANGEGAMEGIRD_FAIL: begin //兑换灵符失败 20080730
          nCode := 27;
          m_DefMsg := MakeDefaultMsg(SM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
        end;
{$IFEND}
  //---------------------------------------------------------------------------
      CM_REPAIRDRAGON: begin //祝福罐.魔令包功能 20080102
          nCode := 31;
          RepairDragon(ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
      CM_DBLREPAIRDRAGON: begin //祝福罐.魔令包功能(双击装备位置的祝福罐,自动把包裹里的祝福油填充完毕) 20100928
          if GetTickCount - m_dwUserTick[1] >= 400 then begin
            m_dwUserTick[1] := GetTickCount;
            ClientDblRepairDragon();
          end;
        end;
  //----------------------------箱子系统--------------------------------------
      CM_OPENBOXS: begin //双击宝箱，打开宝箱 20080118
          nCode := 33;
          ClientSendBoxItem(ProcessMsg.nParam1, ProcessMsg.sMsg, False);
        end;
      CM_OPENNEWBOXS: begin //可填充宝箱模式 20090225
          nCode := 34;
          CheckItemsKey(ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, False);
        end;
      CM_BUYNEWBOXSKEY: begin //购买宝箱钥匙,给玩家钥匙，并减元宝，自动打开宝箱 20090225
          nCode := 35;
          if GetTickCount - m_dwUserTick[9] >= 500 then begin
            m_dwUserTick[9] := GetTickCount;
            BuyKeyAutoBox(ProcessMsg.nParam1, ProcessMsg.nParam2);
          end;
        end;
      CM_MOVEBOXS: begin //转动宝箱 旧模式
          nCode := 36;
          ClientRotationBoxs(False);
        end;
      CM_ROTATIONBOX: begin //转动宝箱 新模式
          nCode := 37;
          ClientRotationBoxs(True);
        end;
      CM_GETBOXS: begin //宝箱给玩家物品
          nCode := 38;
          ClientGetBoxsItme(ProcessMsg.nParam1);
        end;
      RM_BOXITMEFILLED: begin //填充物品  新模式 20090227
          nCode := 314;
          m_DefMsg := MakeDefaultMsg(SM_BOXITMEFILLED, ProcessMsg.nParam1, LoWord(ProcessMsg.nParam2), HiWord(ProcessMsg.nParam2), 0, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      CM_UPDADEBOXSITMES: begin //填充宝箱物品
          nCode := 315;
          ClientUpdateBoxsItme(); //所有填充物品填充完后，检查是否有同类宝箱，则重新刷物品
        end;
      CM_OPEN9YEARSBOXS: begin //打开9周年宝箱(双击箱子物品)
          nCode := 326;
          Check9YearsBoxsKey(ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3); //打开9周年箱子，检查是否有所需的钥匙
        end;
      CM_BUY9YEARSBOXSKEY: begin //购买9周年宝箱的钥匙,给玩家钥匙，并减元宝，自动打开宝箱
          nCode := 328;
          if GetTickCount - m_dwUserTick[9] >= 500 then begin
            m_dwUserTick[9] := GetTickCount;
            ClientBuy9YearsKeyAutoBox();
          end;
        end;
      CM_UPDATA9YEARSBOXSITEM: begin //更换9周年箱子物品
          nCode := 329;
          ClientUpdate9YearsBoxsItem();
        end;
      CM_CHECK9YEARSBOXSKEY: begin //点击“开始选择”，先判断是否有钥匙，没钥匙，则提示购买
          if GetTickCount - m_dwUserTick[9] >= 500 then begin
            m_dwUserTick[9] := GetTickCount;
            ClientCheck9YearsBoxsKey();
          end;
        end;
      CM_GET9YEARSBOXSITEM: begin //取9周年宝箱物品
          nCode := 330;
          //UpdateSendMsgCount();//更新角色的动态密钥(防WPE)
          ClientGet9YearsBoxsItem();
        end;
      CM_OPENFREE9YEARSBOXS: begin //打开免费奖励宝箱
          nCode := 331;
          //UpdateSendMsgCount();//更新角色的动态密钥(防WPE)
          ClientOpenFree9YearsBoxs();
        end;
      CM_GETFREE9YEARSBOXSITEM: begin //取20格免费奖励宝箱物品
          nCode := 332;
          ClientGetFree9YearsBoxsItem();
        end;
      CM_OPENNEW9YEARSBOXS: begin //开启新天赐(开启20格箱子后，选择继续开启天赐)
          nCode := 327;
          ClientOpenNew9YearsBoxs();
        end;
  //-------------------------酿酒系统---------------------------------------------
      CM_BEGINMAKEWINE: begin //开始酿酒(即把材料全放上窗口)  20080620
          nCode := 44;
          ClientPlayMakeWine(ProcessMsg.wParam {Code}, ProcessMsg.sMsg {为物品ID号});
        end;
  //------------------------------------------------------------------------------
      CM_REQUESTGUILDWAR: begin //行会窗口申请行会战 20090510
          ClientReQuestGuildWar(ProcessMsg.sMsg {行会名称});
        end;
      RM_GETBOXS: begin
          nCode := 45;
          m_DefMsg := MakeDefaultMsg(SM_GETBOXS, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_MOVEBOXS: begin
          nCode := 46;
          m_DefMsg := MakeDefaultMsg(SM_MOVEBOXS, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_SEND9YEARSITEMID: begin //(九周年箱子)发送选择的物品制造ID
          m_DefMsg := MakeDefaultMsg(SM_SEND9YEARSITEMID, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_GET9YEARSBOXSITEM_OK: begin //九周年宝箱取物品成功
          m_DefMsg := MakeDefaultMsg(SM_GET9YEARSBOXSITEM_OK, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_OPENBOXS_FAIL: begin //20080318
          nCode := 47;
          m_DefMsg := MakeDefaultMsg(SM_OPENBOXS_FAIL, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_SELLOFFCANCEL: begin //元宝寄售取消出售
          nCode := 48;
          m_DefMsg := MakeDefaultMsg(SM_SELLOFFCANCEL,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_SELLOFFADDITEM_OK: begin //客户端往出售物品窗口里加物品 成功
          nCode := 49;
          m_DefMsg := MakeDefaultMsg(SM_SELLOFFADDITEM_OK,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_SellOffADDITEM_FAIL: begin //客户端往出售物品窗口里加物品 失败
          nCode := 50;
          m_DefMsg := MakeDefaultMsg(SM_SellOffADDITEM_FAIL,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_SELLOFFDELITEM_OK: begin //客户端删除出售物品窗里的物品 成功
          nCode := 51;
          m_DefMsg := MakeDefaultMsg(SM_SELLOFFDELITEM_OK,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_SELLOFFDELITEM_FAIL: begin //客户端删除出售物品窗里的物品 失败
          nCode := 52;
          m_DefMsg := MakeDefaultMsg(SM_SELLOFFDELITEM_FAIL,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_SELLOFFEND_OK: begin //客户端元宝寄售结束 成功
          nCode := 53;
          m_DefMsg := MakeDefaultMsg(SM_SELLOFFEND_OK,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_SELLOFFEND_FAIL: begin //客户端元宝寄售结束 失败
          nCode := 54;
          m_DefMsg := MakeDefaultMsg(SM_SELLOFFEND_FAIL,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_SELLOFFBUY_OK: begin //购买成功
          nCode := 55;
          m_DefMsg := MakeDefaultMsg(SM_SELLOFFBUY_OK,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_OPENBOXS: begin //打开宝箱 20080115
          nCode := 56;
          m_DefMsg := MakeDefaultMsg(SM_OPENBOXS,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_OPENDRAGONBOXS: begin //卧龙开宝箱 20080306
          nCode := 57;
          m_DefMsg := MakeDefaultMsg(SM_OPENDRAGONBOXS,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;
      CM_QUERYUSERNAME: begin //80
          nCode := 73;
          ClientQueryUserName(TPlayObject(ProcessMsg.nParam1), ProcessMsg.nParam2, ProcessMsg.nParam3);
        end;
      CM_QUERYBAGITEMS: begin //刷新人物的包裹物品
          nCode := 74;
          ClientQueryBagItems();
        end;
      CM_QUERYUSERSTATE: begin //82 查看角色装备
          nCode := 75;
          ClientQueryUserState(TBaseObject(ProcessMsg.nParam1), ProcessMsg.nParam2, ProcessMsg.nParam3);
        end;
      {CM_QUERYUSERSET: begin //未使用 20080907
          ClientQueryUserSet(ProcessMsg);
        end;}
      CM_DROPITEM: begin //1000
          nCode := 76;
          if ClientDropItem(ProcessMsg.sMsg, ProcessMsg.nParam1) then
            SendDefMessage(SM_DROPITEM_SUCCESS, ProcessMsg.nParam1, 0, 0, 0, ProcessMsg.sMsg)
          else SendDefMessage(SM_DROPITEM_FAIL, ProcessMsg.nParam1, 0, 0, 0, ProcessMsg.sMsg);
        end;
      CM_PICKUP: begin //1001
          nCode := 77;
          if (m_nCurrX = ProcessMsg.nParam2) and (m_nCurrY = ProcessMsg.nParam3) then ClientPickUpItem();
        end;
      CM_OPENDOOR: begin //开门,人物走到地图的某个过门点时
          nCode := 78;
          ClientOpenDoor(ProcessMsg.nParam2, ProcessMsg.nParam3);
        end;
      CM_TAKEONITEM: begin //1003 从包裹里穿装备(穿上装备)
          nCode := 79;
          ClientTakeOnItems(ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
      CM_TAKEOFFITEM: begin //1004 脱下装备
          nCode := 80;
          ClientTakeOffItems(ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
      CM_EAT: begin //1005
          nCode := 81;
          ClientUseItems(ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.sMsg);
        end;
      CM_BUTCH: begin //1007 挖物品
          nCode := 82;
          ShopCancel; //取消个人商店
          if not ClientGetButchItem(TBaseObject(ProcessMsg.nParam1), ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.wParam, dwDelayTime) then begin
            if dwDelayTime <> 0 then begin
              nMsgCount := GetDigUpMsgCount();
              if nMsgCount >= g_Config.nMaxDigUpMsgCount then begin //越过M2的挖肉限制数量
                Inc(m_nOverSpeedCount);
                if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then begin
                  if g_Config.boKickOverSpeed then begin
                    SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                    m_boEmergencyClose := True;
                    m_boPlayOffLine := False;
                  end;
                  if g_Config.boViewHackMessage then begin
                    MainOutMessage(Format(g_sBunOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
                  end;
                end;
                SendSocket(nil, sSTATUS_FAIL); //20080814 修改
              end else begin
                if dwDelayTime < g_Config.dwDropOverSpeed then begin
                  SendSocket(nil, sSTATUS_GOOD); //20080814 修改
                  if m_boTestSpeedMode then
                    SysMsg(Format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                end else begin
                  SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '', dwDelayTime);
                  Result := False;
                end;
              end;
            end;
          end;
        end;
      CM_MAGICKEYCHANGE: begin //客户端改变魔法快键
          nCode := 83;
          ClientChangeMagicKey(ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.sMsg);
        end;
      CM_SOFTCLOSE: begin //人物小退
       (*  nCode:=84; 20110601注释
          UserEngine.SaveHumanRcd(Self);//保存人物数据 20080413
          nCode:=2001;    *)
{$IF HEROVERSION = 1}
          if m_MyHero <> nil then begin //20090203加入，人物小退后，英雄直接消失
            UserEngine.SaveHeroRcd(Self); //保存英雄数据 20080413
            nCode := 2002;
            m_MyHero.m_boDeath := True;
            THeroObject(m_MyHero).boCallLogOut := True; //英雄正常退出
            m_MyHero.m_dwDeathTick := GetTickCount;
            nCode := 2003;
            m_MyHero.MakeGhost;
            m_MyHero := nil;
          end;
{$IFEND}
          nCode := 2004;
          m_boReconnection := True;
          m_boSoftClose := True;
        end;
      CM_CLICKNPC: begin //1010  004D79E4
          nCode := 85;
          ClientClickNPC(ProcessMsg.nParam1);
        end;
      CM_MERCHANTDLGSELECT: begin //1011
          nCode := 86;
          if GetTickCount - m_dwUserTick[7] >= 150 then begin //20100201
            m_dwUserTick[7] := GetTickCount;
            ClientMerchantDlgSelect(ProcessMsg.nParam1, ProcessMsg.sMsg, ProcessMsg.wParam);
          end;
        end;
      CM_PLAYDICELabel: begin
          nCode := 86;
          if GetTickCount - m_dwUserTick[7] >= 150 then begin //20100201
            m_dwUserTick[7] := GetTickCount;
            ClientMerchantDlgSelectPLAYDICELabel(ProcessMsg.nParam1);
          end;
      end;
      CM_PlAYDRINKDLGSELECT: begin
          nCode := 87;
          ClientPlayDrinkLable(ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
      CM_MERCHANTQUERYSELLPRICE: begin //1012
          nCode := 88;
          ClientMerchantQuerySellPrice(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
        end;
      CM_USERSELLITEM: begin //1013
          nCode := 89;
          ClientUserSellItem(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
        end;
      CM_USERBUYITEM: begin //1014 NPC处购买物品
          if GetTickCount - m_dwUserTick[1] >= 250 then begin //20101212 限制NPC快速购买
            m_dwUserTick[1] := GetTickCount;
            nCode := 90;
            ClientUserBuyItem(ProcessMsg.wIdent, ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), 0, ProcessMsg.sMsg);
          end;
        end;
      //////////////////////////////增加拍卖////////////////////////////////////////////////////
     {  //20080416 去掉拍卖功能
      CM_SENDSELLOFFITEM:
        ClientUserSellOffItem(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);

      CM_SENDQUERYSELLOFFITEM:
        ClientUserBuySellOffItem(ProcessMsg.wIdent, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.sMsg);

      CM_SENDBUYSELLOFFITEM:
        ClientUserBuySellOffItem(ProcessMsg.wIdent, ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), 0, ProcessMsg.sMsg);

      /////////////////////////增加拍卖////////////////////////////////////////////////////////  }
      CM_USERGETDETAILITEM: begin
          nCode := 91;
          ClientUserBuyItem(ProcessMsg.wIdent, ProcessMsg.nParam1, 0, ProcessMsg.nParam2, ProcessMsg.sMsg);
        end;
      CM_DROPGOLD: begin
          nCode := 92;
          if ProcessMsg.nParam1 > 0 then ClientDropGold(ProcessMsg.nParam1);
        end;
      {CM_1017: begin//20090901 注释
          nCode:=93;
          SendDefMessage(1, 0, 0, 0, 0, '');
        end;}
      CM_GROUPMODE: begin //组队开关(0-关闭组队 1-可以组队)
          nCode := 94;
          if ProcessMsg.nParam2 = 0 then ClientGropuClose()
          else m_boAllowGroup := True;
          if m_boAllowGroup then SendDefMessage(SM_GROUPMODECHANGED, 0, 1, 0, 0, '')
          else SendDefMessage(SM_GROUPMODECHANGED, 0, 0, 0, 0, '');
        end;
      CM_CREATEGROUP: begin //1020 新建组队
          nCode := 95;
          ClientCreateGroup(Trim(ProcessMsg.sMsg));
        end;
      CM_ADDGROUPMEMBER: begin //1021 增加组队人员
          nCode := 96;
          ClientAddGroupMember(Trim(ProcessMsg.sMsg));
        end;
      CM_DELGROUPMEMBER: begin //1022 删除组队人员
          nCode := 97;
          ClientDelGroupMember(Trim(ProcessMsg.sMsg));
        end;
      CM_USERREPAIRITEM: begin //1023
          nCode := 98;
          ClientRepairItem(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
        end;
      CM_MERCHANTQUERYREPAIRCOST: begin //1024
          nCode := 99;
          ClientQueryRepairCost(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
        end;
      CM_CLICKSIGHICON: begin //点击感叹号
          nCode := 100;
          if (ProcessMsg.sMsg <> '') and (pos('@StdModeFunc', ProcessMsg.sMsg) = 0) then begin //20090816 防止直接跳转到物品触发
            case ProcessMsg.nParam2 of
              1: begin //点击'!'号图标
                  if (m_sMapQFStr1 <> '') and (CompareText(ProcessMsg.sMsg, m_sMapQFStr1) = 0) then begin
                    m_sMapQFStr1 := '';
                    CmdUserCmd(ProcessMsg.sMsg); //跳转到QF脚本段 20090126
                  end;
                end;
              2: begin //MESSAGEBOX命令的脚本 参数1
                  if (m_sMessageBoxStr1 <> '') and (CompareText(ProcessMsg.sMsg, m_sMessageBoxStr1) = 0) then begin
                    m_sMessageBoxStr1 := '';
                    m_sMessageBoxStr2 := '';
                    CmdUserCmd(ProcessMsg.sMsg); //跳转到QF脚本段 20090126
                  end;
                end;
              3: begin //MESSAGEBOX命令的脚本 参数2
                  if (m_sMessageBoxStr2 <> '') and (CompareText(ProcessMsg.sMsg, m_sMessageBoxStr2) = 0) then begin
                    m_sMessageBoxStr1 := '';
                    m_sMessageBoxStr2 := '';
                    CmdUserCmd(ProcessMsg.sMsg); //跳转到QF脚本段 20090126
                  end;
                end;
              4: begin //跳转QM的@Help脚本段 20090904
                  if g_ManageNPC <> nil then g_ManageNPC.GotoLable(self, '@Help', False, False);
                end;
            end; //case
          end;
        end;
      CM_CLIENTPUNISHMENT: begin //RUN发来,玩家违法操作，进入QF @Punishment 20090808
          CmdUserCmd('@Punishment');
        end;
      CM_CLICKCRYSTALEXPTOP: begin //
          nCode := 101;
          ClientGetExpCrystalData; //客户端点击天地结晶，返回经验等信息 20090202
        end;
  //---------------------交易系统--------------------------------------------
      CM_DEALTRY: begin //1025 玩家点交易按键
          if GetTickCount - m_dwUserTick[1] >= 200 then begin
            m_dwUserTick[1] := GetTickCount;
            nCode := 102;
            ClientDealTry(Trim(ProcessMsg.sMsg));
          end;
        end;
      CM_DEALADDITEM: begin //1026 玩家把物品放到交易框中
          nCode := 103;
          ClientAddDealItem(ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
      CM_DEALDELITEM: begin //1027 玩家从交易框中取回物品
          nCode := 104;
          ClientDelDealItem(ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
      CM_DEALCANCEL: begin //1028 玩家取消交易
          nCode := 105;
          ClientCancelDeal();
        end;
      CM_DEALCHGGOLD: begin //1029 客户端把金币放到交易框中
          nCode := 106;
          ClientChangeDealGold(ProcessMsg.nParam1);
        end;
      CM_DEALEND: begin //1030 交易结束
          nCode := 107;
          ClientDealEnd();
        end;
  //---------------------------挑战系统20080705--------------------------------
      CM_CHALLENGETRY: begin //玩家点击挑战
          if GetTickCount - m_dwUserTick[1] >= 200 then begin
            m_dwUserTick[1] := GetTickCount;
            nCode := 108;
            ClientChallenge;
          end;
        end;
      CM_CHALLENGEADDITEM: begin //玩家把物品放到挑战框中
          nCode := 109;
          ClientAddChallengeItem(ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
      CM_CHALLENGEDELITEM: begin //玩家从挑战框中取回物品
          nCode := 110;
          ClientDelChallengeItem(ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
      CM_CHALLENGECANCEL: begin //玩家取消挑战
          nCode := 111;
          ClientCancelChallenge();
        end;
      CM_CHALLENGECHGGOLD: begin //客户端把金币放到挑战框中
          nCode := 112;
          ClientChangeChallengeGold(ProcessMsg.nParam1);
        end;
      CM_CHALLENGECHGDIAMOND: begin //客户端把金刚石放到挑战框中
          nCode := 113;
          ClientChangeChallengeDIAMOND(ProcessMsg.nParam1);
        end;
      CM_CHALLENGEEND: begin //挑战抵押物品结束
          nCode := 114;
          ClientChallengeEnd();
        end;
  //==========================元宝寄售系统======================================
      CM_SELLOFFADDITEM: begin // 客户端往出售物品窗口里加物品  20080316
          nCode := 115;
          ClientAddSellOffItem(ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
      CM_SELLOFFDELITEM: begin //客户端删除出售物品窗里的物品  20080316
          nCode := 116;
          ClientDelSellOffItem(ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
      CM_SELLOFFCANCEL: begin //客户端取消元宝寄售  20080316
          nCode := 117;
          ClientCancelSellOff();
        end;
      CM_SELLOFFEND: begin //客户端元宝寄售结束  20080316
          nCode := 118;
          ClientSellOffEnd(ProcessMsg.sMsg {买方}, ProcessMsg.nParam1 {元宝数}, ProcessMsg.nParam2 {金刚石数}, ProcessMsg.nParam3 {金刚石特征,类型上限表示});
        end;
      CM_CANCELSELLOFFITEMING: begin //取消正在寄售的物品 20080318(出售人)
          nCode := 119;
          ClientCancelSellOffIng();
        end;
      CM_SELLOFFBUYCANCEL: begin //取消寄售 物品购买 20080318(购买人)
          nCode := 120;
          ClientBuyCancelSellOff(ProcessMsg.sMsg {出售人});
        end;
      CM_SELLOFFBUY: begin //确定购买寄售物品 20080318
          nCode := 121;
          ClientBuySellOffItme(ProcessMsg.sMsg {出售人});
        end;
  //============================================================================
      CM_USERSTORAGEITEM: begin //1031 存物品到移动仓库
          nCode := 123;
          ClientStorageItem(TObject(ProcessMsg.nParam1), MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
        end;
      CM_USERTAKEBACKSTORAGEITEM: begin //1032
          nCode := 124;
          ClientTakeBackStorageItem(TObject(ProcessMsg.nParam1), MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
        end;
      CM_WANTMINIMAP: begin //1033
          nCode := 125;
          ClientGetMinMap();
        end;
      CM_USERMAKEDRUGITEM: begin //1034
          nCode := 126;
          ClientMakeDrugItem(TObject(ProcessMsg.nParam1), ProcessMsg.sMsg);
        end;
      CM_USERARMSTEARITEM: begin //客户端发来所要拆分的物品信息 20100708
{$IF M2Version <> 2}
          if GetTickCount - m_dwUserTick[1] >= 300 then begin
            m_dwUserTick[1] := GetTickCount;
            nCode := 314;
            ClientArmsTearItem(TObject(ProcessMsg.nParam1), MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
          end;
{$IFEND}
        end;
      CM_OPENGUILDDLG: begin //用户点击了"行会"按钮
          nCode := 127;
          ClientOpenGuildDlg();
        end;
      CM_GUILDHOME: begin //1036 行会首页
          nCode := 128;
          ClientGuildHome();
        end;
      CM_GUILDMEMBERLIST: begin //行会成员列表
          nCode := 129;
          ClientGuildMemberList();
        end;
      CM_GUILDADDMEMBER: begin //增加行会成员
          nCode := 130;
          ClientGuildAddMember(ProcessMsg.sMsg);
        end;
      CM_GUILDDELMEMBER: begin //删除行会成员
          nCode := 131;
          ClientGuildDelMember(ProcessMsg.sMsg);
        end;
      CM_GUILDUPDATENOTICE: begin //修改行会公告
          nCode := 132;
          ClientGuildUpdateNotice(ProcessMsg.sMsg);
        end;
      CM_GUILDUPDATERANKINFO: begin //1041 修改行会成员封号,等级
          nCode := 133;
          ClientGuildUpdateRankInfo(ProcessMsg.sMsg);
        end;
      {CM_1042: begin//20090901 注释
          MainOutMessage('[非法数据] ' + m_sCharName);
        end;}
      CM_ADJUST_BONUS: begin
          nCode := 134;
          ClientAdjustBonus(ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
      CM_GUILDALLY: begin //1044
          nCode := 135;
          ClientGuildAlly();
        end;
      CM_GUILDBREAKALLY: begin //1045
          nCode := 136;
          ClientGuildBreakAlly(ProcessMsg.sMsg);
        end;
  (*{$IF CHECKNEWMSG = 1}//20090901 注释
      CM_1046: begin
          MainOutMessage(Format('%s/%d/%d/%d/%d/%d/%s',
               [m_sCharName, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1,
                ProcessMsg.nParam2, ProcessMsg.nParam3, DeCodeString(ProcessMsg.sMsg)]));
        end;
      CM_1056: begin
          MainOutMessage(Format('%s/%d/%d/%d/%d/%d/%s',
               [m_sCharName, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1,
                ProcessMsg.nParam2, ProcessMsg.nParam3, DeCodeString(ProcessMsg.sMsg)]));
        end;
  {$IFEND}  *)
      CM_TURN: begin //3010
          nCode := 137;
          ShopCancel; //取消个人商店
          if ClientChangeDir(ProcessMsg.wIdent, ProcessMsg.nParam1 {x}, ProcessMsg.nParam2 {y}, ProcessMsg.wParam {dir}, dwDelayTime) then begin
            m_dwActionTick := GetTickCount;
            SendSocket(nil, sSTATUS_GOOD); //20080814 修改
          end else begin
            if dwDelayTime = 0 then begin
              SendSocket(nil, sSTATUS_FAIL); //20080814 修改
            end else begin
              nMsgCount := GetTurnMsgCount();
              if nMsgCount >= g_Config.nMaxTurnMsgCount then begin
                Inc(m_nOverSpeedCount);
                if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then begin
                  if g_Config.boKickOverSpeed then begin
                    SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                    m_boEmergencyClose := True;
                    m_boPlayOffLine := False;
                  end;
                  if g_Config.boViewHackMessage then begin
                    MainOutMessage(Format(g_sBunOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
                  end;
                end;
                SendSocket(nil, sSTATUS_FAIL); //20080814 修改
              end else begin
                if dwDelayTime < g_Config.dwDropOverSpeed then begin
                  SendSocket(nil, sSTATUS_GOOD); //20080814 修改
                  if m_boTestSpeedMode then
                    SysMsg(Format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                end else begin
                  SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '', dwDelayTime);
                  Result := False;
                end;
              end;
            end;
          end;
        end;
      CM_WALK: begin
          nCode := 138;
          ShopCancel; //取消个人商店
          if ClientWalkXY(ProcessMsg.wIdent, ProcessMsg.nParam1 {x}, ProcessMsg.nParam2 {y}, ProcessMsg.boLateDelivery, dwDelayTime) then begin
            m_dwActionTick := GetTickCount;
            SendSocket(nil, sSTATUS_GOOD);
{$IF M2Version <> 2}
            if m_SkillHit_113 > 0 then begin
              m_SkillHit_113 := 0;
              m_SkillHit_X := 0;
              m_SkillHit_Y := 0;
              m_nCharStatus := GetCharStatus();
              StatusChanged('');
            end;
{$IFEND}
            if g_Config.boStartMapEvent then begin //开启地图事件触发
              if m_btRaceServer = RC_PLAYOBJECT then StartMapEventOfWalk(); //走路事件触发}
            end;
          end else begin
            if dwDelayTime = 0 then begin
              SendSocket(nil, sSTATUS_FAIL);
            end else begin
              nMsgCount := GetWalkMsgCount();
              if nMsgCount >= g_Config.nMaxWalkMsgCount then begin
                Inc(m_nOverSpeedCount);
                if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then begin
                  if g_Config.boKickOverSpeed then begin
                    SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                    m_boEmergencyClose := True;
                    m_boPlayOffLine := False;
                  end;
                  if g_Config.boViewHackMessage then begin
                    MainOutMessage(Format(g_sWalkOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
                  end;
                end;
                SendSocket(nil, sSTATUS_FAIL);
                if m_boTestSpeedMode then
                  SysMsg(Format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
              end else begin
                if (dwDelayTime > g_Config.dwDropOverSpeed) and (g_Config.btSpeedControlMode = 1) and m_boFilterAction then begin
                  SendSocket(nil, sSTATUS_FAIL);
                  if m_boTestSpeedMode then
                    SysMsg(Format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                end else begin
                  if m_boTestSpeedMode then
                    SysMsg(Format('操作延迟 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                  SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '', dwDelayTime);
                  Result := False;
                end;
              end;
            end;
          end;
        end;

      CM_HORSERUN: begin //马跑
          nCode := 139;
          ShopCancel; //取消个人商店
          if ClientHorseRunXY(ProcessMsg.wIdent, ProcessMsg.nParam1 {x}, ProcessMsg.nParam2 {y}, ProcessMsg.boLateDelivery, dwDelayTime) then begin
            m_dwActionTick := GetTickCount;
            SendSocket(nil, sSTATUS_GOOD); //20080814 修改
          end else begin
            if dwDelayTime = 0 then begin
              SendSocket(nil, sSTATUS_FAIL); //20080814 修改
            end else begin
              nMsgCount := GetRunMsgCount();
              if nMsgCount >= g_Config.nMaxRunMsgCount then begin
                Inc(m_nOverSpeedCount);
                if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then begin
                  if g_Config.boKickOverSpeed then begin
                    SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                    m_boEmergencyClose := True;
                    m_boPlayOffLine := False;
                  end;
                  if g_Config.boViewHackMessage then begin
                    MainOutMessage(Format(g_sRunOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
                  end;
                end;
                SendSocket(nil, sSTATUS_FAIL); //20080814 修改
                if m_boTestSpeedMode then
                  SysMsg(Format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
              end else begin
                if m_boTestSpeedMode then
                  SysMsg(Format('操作延迟 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '', dwDelayTime);
                Result := False;
              end;
            end;
          end;
        end;
      CM_RUN: begin
          nCode := 140;
          ShopCancel; //取消个人商店
          if ClientRunXY(ProcessMsg.wIdent, ProcessMsg.nParam1 {x}, ProcessMsg.nParam2 {y}, ProcessMsg.nParam3, dwDelayTime) then begin
            m_dwActionTick := GetTickCount;
            SendSocket(nil, sSTATUS_GOOD);
{$IF M2Version <> 2}
            if m_SkillHit_113 > 0 then begin
              m_SkillHit_113 := 0;
              m_SkillHit_X := 0;
              m_SkillHit_Y := 0;
              m_nCharStatus := GetCharStatus();
              StatusChanged('');
            end;
{$IFEND}
            if g_Config.boStartMapEvent then begin
              if m_btRaceServer = RC_PLAYOBJECT then StartMapEventOfRun(); //跑步事件触发
            end;
          end else begin
            if dwDelayTime = 0 then begin
              SendSocket(nil, sSTATUS_FAIL);
            end else begin
              nMsgCount := GetRunMsgCount();
              if nMsgCount >= g_Config.nMaxRunMsgCount then begin
                Inc(m_nOverSpeedCount);
                SendSocket(nil, sSTATUS_FAIL);
                if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then begin
                  if g_Config.boKickOverSpeed then begin
                    SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                    m_boEmergencyClose := True;
                    m_boPlayOffLine := False;
                  end;
                  if g_Config.boViewHackMessage then
                    MainOutMessage(Format(g_sRunOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
                end;
              end else begin
                if (dwDelayTime > g_Config.dwDropOverSpeed) and (g_Config.btSpeedControlMode = 1) and m_boFilterAction then begin
                  SendSocket(nil, sSTATUS_FAIL);
                  if m_boTestSpeedMode then
                    SysMsg(Format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                end else begin
                  if m_boTestSpeedMode then
                    SysMsg(Format('操作延迟 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                  SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, CM_RUN, '', dwDelayTime);
                  Result := False;
                end;
              end;
            end;
          end;
        end;
{$IF M2Version = 1}
      CM_BATTERHIT1 {追心刺},
        CM_BATTERHIT2 {三绝杀},
        CM_BATTERHIT3 {横扫千军},
        CM_BATTERHIT4: begin //断岳斩
          if ClientBatterHitXY(ProcessMsg.wIdent {ident}, ProcessMsg.nParam1 {x}, ProcessMsg.nParam2 {y}, ProcessMsg.wParam {dir}) then begin
            SendSocket(nil, sSTATUS_GOOD);
          end else begin
            SendSocket(nil, sSTATUS_FAIL);
          end;
        end;
{$IFEND}
{$IF M2Version <> 2}
      CM_LONGHITFORFENGHAO, //粉红刺杀
        CM_DAILYFORFENGHAO, //逐日粉红效果
        CM_FIREHITFORFENGHAO, //烈火粉红效果
{$IFEND}
      CM_HIT, //3014
        CM_HEAVYHIT, //3015
        CM_BIGHIT, //3016
        CM_POWERHIT, //3018
        CM_LONGHIT, //3019
        CM_LONGHIT4, //四级刺杀
        CM_WIDEHIT, //3024
        CM_WIDEHIT4, //圆月弯刀
        CM_CRSHIT,
        CM_TWNHIT, {开天斩重击}
        CM_QTWINHIT, {开天斩轻击 20080212}
        CM_CIDHIT, {龙影剑法}
        CM_PHHIT,
        CM_DAILY, {逐日剑法 20080511}
        CM_BLOODSOUL, //血魄一击(战)
        CM_HIT_107, //纵横剑术
        CM_FIREHIT, {烈火}
        CM_4FIREHIT {4级烈火 20080112}: begin //3025
          nCode := 141;
          ShopCancel; //取消个人商店
          if ClientHitXY(ProcessMsg.wIdent {ident}, ProcessMsg.nParam1 {x}, ProcessMsg.nParam2 {y}, ProcessMsg.wParam {dir}, ProcessMsg.boLateDelivery, dwDelayTime) then begin
            m_dwActionTick := GetTickCount;
            SendSocket(nil, sSTATUS_GOOD); //20080814 修改
          end else begin
            if dwDelayTime = 0 then begin
              SendSocket(nil, sSTATUS_FAIL); //20080814 修改
            end else begin
              nMsgCount := GetHitMsgCount();
              if nMsgCount >= g_Config.nMaxHitMsgCount then begin
                Inc(m_nOverSpeedCount);
                if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then begin
                  if g_Config.boKickOverSpeed then begin
                    SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                    m_boEmergencyClose := True;
                    m_boPlayOffLine := False;
                  end;
                  if g_Config.boViewHackMessage then begin
                    MainOutMessage(Format(g_sHitOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
                  end;
                end;
                //如果超速则发送攻击失败信息
                SendSocket(nil, sSTATUS_FAIL); //20080814 修改
              end else begin
                if (dwDelayTime > g_Config.dwDropOverSpeed) and (g_Config.btSpeedControlMode = 1) and m_boFilterAction then begin
                  SendSocket(nil, sSTATUS_GOOD); //20080814 修改
                  if m_boTestSpeedMode then
                    SysMsg(Format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                end else begin
                  if m_boTestSpeedMode then begin
                    SysMsg(format('操作延迟 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                  end;
                  SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '', dwDelayTime);
                  Result := False;
                end;
              end;
            end;
          end;
        end;
      CM_SITDOWN: begin //3012 蹲下
          nCode := 142;
          ShopCancel; //取消个人商店
          if ClientSitDownHit(ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, dwDelayTime) then begin
            m_dwActionTick := GetTickCount();
            SendSocket(nil, sSTATUS_GOOD); //20080814 修改
          end else begin
            if dwDelayTime = 0 then begin
              SendSocket(nil, sSTATUS_FAIL); //20080814 修改
            end else begin
              nMsgCount := GetSiteDownMsgCount();
              if nMsgCount >= g_Config.nMaxSitDonwMsgCount then begin
                Inc(m_nOverSpeedCount);
                if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then begin
                  if g_Config.boKickOverSpeed then begin
                    SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                    m_boEmergencyClose := True;
                    m_boPlayOffLine := False;
                  end;
                  if g_Config.boViewHackMessage then
                    MainOutMessage(Format(g_sBunOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
                end;
                SendSocket(nil, sSTATUS_FAIL); //20080814 修改
              end else begin
                if dwDelayTime < g_Config.dwDropOverSpeed then begin
                  SendSocket(nil, sSTATUS_GOOD); //20080814 修改
                  if m_boTestSpeedMode then
                    SysMsg(Format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                end else begin
                  if m_boTestSpeedMode then
                    SysMsg(Format('操作延迟 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                  SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '', dwDelayTime);
                  Result := False;
                end;
              end;
            end;
          end;
        end;
      CM_SPELL: begin
          nCode := 143;
          ShopCancel; //取消个人商店
          if ClientSpellXY(ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, TBaseObject(ProcessMsg.nParam3), ProcessMsg.boLateDelivery, dwDelayTime, ProcessMsg.sMsg) then begin
            nCode := 1431;
            m_dwActionTick := GetTickCount;
            SendSocket(nil, sSTATUS_GOOD); //20080814 修改
          end else begin
            nCode := 1432;
            if dwDelayTime = 0 then begin
              SendSocket(nil, sSTATUS_FAIL); //20080814 修改
            end else begin
              nMsgCount := GetSpellMsgCount();
              if nMsgCount >= g_Config.nMaxSpellMsgCount then begin
                Inc(m_nOverSpeedCount);
                if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then begin
                  if g_Config.boKickOverSpeed then begin
                    SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                    m_boEmergencyClose := True;
                    m_boPlayOffLine := False;
                  end;
                  if g_Config.boViewHackMessage then
                    MainOutMessage(Format(g_sSpellOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
                end;
                SendSocket(nil, sSTATUS_FAIL); //20080814 修改
              end else begin
                if (dwDelayTime > g_Config.dwDropOverSpeed) and (g_Config.btSpeedControlMode = 1) and m_boFilterAction then begin
                  SendSocket(nil, sSTATUS_FAIL); //20080814 修改
                  if m_boTestSpeedMode then
                    SysMsg(Format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                end else begin
                  if m_boTestSpeedMode then
                    SysMsg(Format('操作延迟 Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                  SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '', dwDelayTime);
                  Result := False;
                end;
              end;
            end;
          end;
        end;
      CM_SAY: begin
          nCode := 144;
          if ProcessMsg.sMsg <> '' then ProcessUserLineMsg(ProcessMsg.sMsg);
        end;
      CM_PASSWORD: begin
          nCode := 145;
          ProcessClientPassword(ProcessMsg);
        end;
      RM_WALK: begin //10002
          nCode := 146;
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
{$IF HEROVERSION = 1}
            m_DefMsg := MakeDefaultMsg(SM_WALK, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_btJob), 0);
{$ELSE}
            m_DefMsg := MakeDefaultMsg(SM_WALK, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight), 0);
{$IFEND}
            m_DefMsg.nSessionID := TBaseObject(ProcessMsg.BaseObject).GetFeature(CharDesc.feature);
            CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
            CharDesc.MonShowName := TBaseObject(ProcessMsg.BaseObject).m_btRaceServer; //20110713 宠物显名用
            SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc) - SizeOf(TFeatures) + m_DefMsg.nSessionID));
          end;
        end;
      RM_HORSERUN: begin //10003
          nCode := 147;
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg := MakeDefaultMsg(SM_HORSERUN, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight), 0);
            m_DefMsg.nSessionID := TBaseObject(ProcessMsg.BaseObject).GetFeature(CharDesc.feature);
            CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
            CharDesc.MonShowName := TBaseObject(ProcessMsg.BaseObject).m_btRaceServer; //20110713 宠物显名用
            SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc) - SizeOf(TFeatures) + m_DefMsg.nSessionID));
          end;
        end;
      RM_RUN: begin
          nCode := 148;
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg := MakeDefaultMsg(SM_RUN, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight), 0);
            m_DefMsg.nSessionID := TBaseObject(ProcessMsg.BaseObject).GetFeature(CharDesc.feature);
            CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
            CharDesc.MonShowName := TBaseObject(ProcessMsg.BaseObject).m_btRaceServer; //20110713 宠物显名用
            SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc) - SizeOf(TFeatures) + m_DefMsg.nSessionID));
          end;
        end;
      RM_HIT: begin //10004
          nCode := 149;
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg := MakeDefaultMsg(SM_HIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_PIXINGHIT: begin //劈星斩效果 20080611
          nCode := 150;
          m_DefMsg := MakeDefaultMsg(SM_PIXINGHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_LEITINGHIT: begin //雷霆一击效果 20080611
          nCode := 151;
          m_DefMsg := MakeDefaultMsg(SM_LEITINGHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_HEAVYHIT: begin //
          nCode := 152;
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg := MakeDefaultMsg(SM_HEAVYHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
            SendSocket(@m_DefMsg, ProcessMsg.sMsg);
          end;
        end;
      RM_BIGHIT: begin //
          nCode := 153;
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg := MakeDefaultMsg(SM_BIGHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_SPELL: begin // 10007
          nCode := 154;
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin //正常情况，客户端放技能时，客户端会内部发一次，所以不再用M2发
            m_DefMsg := MakeDefaultMsg(SM_SPELL, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, Str_ToInt(ProcessMsg.sMsg, 0));
            SendSocket(@m_DefMsg, IntToStr(ProcessMsg.nParam3));
          end else begin
            case ProcessMsg.nParam3 of //20080712 wMagicId
              60..65, 77, 78, 80, 81, 83, 84, 86, 87: begin
                  m_DefMsg := MakeDefaultMsg(SM_SPELL, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
                  SendSocket(@m_DefMsg, IntToStr(ProcessMsg.nParam3));
                end;
            end;
          end;
        end;
      RM_SPELL2: begin //10008 攻杀
          nCode := 155;
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            nObjCount := 0;
            case ProcessMsg.nParam3 of //强化重数
              1..9: nObjCount := ProcessMsg.nParam3 + 1;
            end;
            m_DefMsg := MakeDefaultMsg(SM_POWERHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, nObjCount);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_MOVEFAIL: begin //10010 移动失败
          nCode := 156;
          m_DefMsg := MakeDefaultMsg(SM_MOVEFAIL, Integer(Self), m_nCurrX, m_nCurrY, m_btDirection, 0);
          m_DefMsg.nSessionID := TBaseObject(ProcessMsg.BaseObject).GetFeature(CharDesc.feature);
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(CharDesc) - SizeOf(TFeatures) + m_DefMsg.nSessionID));
        end;
      RM_LONGHIT4: begin //10009 四级刺杀
          if (TBaseObject(ProcessMsg.BaseObject) <> nil) and (TBaseObject(ProcessMsg.BaseObject) <> Self) then begin //20110407
            nObjCount := 0;
            case ProcessMsg.nParam3 of //强化重数
              1..9: nObjCount := ProcessMsg.nParam3 + 1;
            end;
            m_DefMsg := MakeDefaultMsg(SM_LONGHIT4, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, nObjCount);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_LONGHIT: begin //10011 刺杀
          nCode := 157;
          if (TBaseObject(ProcessMsg.BaseObject) <> nil) and (TBaseObject(ProcessMsg.BaseObject) <> Self) then begin //20110407
            if (TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT) then begin
              nObjCount := 0;
              case ProcessMsg.nParam3 of //强化重数
                1..9: nObjCount := ProcessMsg.nParam3 + 1;
              else begin
{$IF M2Version <> 2}
                  nObjCount := BoolToInt(TPlayObject(ProcessMsg.BaseObject).m_boFengHaoMagicEffect);
{$IFEND}
                end;
              end;
              m_DefMsg := MakeDefaultMsg(SM_LONGHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, nObjCount)
            end else m_DefMsg := MakeDefaultMsg(SM_LONGHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_WIDEHIT: begin //10012 半月
          nCode := 158;
          if (TBaseObject(ProcessMsg.BaseObject) <> nil) and (TBaseObject(ProcessMsg.BaseObject) <> Self) then begin //20110407
            m_DefMsg := MakeDefaultMsg(SM_WIDEHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_WIDEHIT4: begin //圆月弯刀
          nCode := 158;
          if (TBaseObject(ProcessMsg.BaseObject) <> nil) and (TBaseObject(ProcessMsg.BaseObject) <> Self) then begin //20110407
            nObjCount := 0;
            case ProcessMsg.nParam3 of //强化重数
              1..9: nObjCount := ProcessMsg.nParam3 + 1;
            end;
            m_DefMsg := MakeDefaultMsg(SM_WIDEHIT4, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, nObjCount);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_DAILY: begin //逐日剑法 20080511
          nCode := 159;
          if (TBaseObject(ProcessMsg.BaseObject) <> nil) and (TBaseObject(ProcessMsg.BaseObject) <> Self) then begin //20110407
            if (TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT) then begin
              nObjCount := 0;
              case ProcessMsg.nParam3 of //强化重数
                1..9: nObjCount := ProcessMsg.nParam3 + 1;
              else begin
{$IF M2Version <> 2}
                  nObjCount := BoolToInt(TPlayObject(ProcessMsg.BaseObject).m_boFengHaoMagicEffect);
{$IFEND}
                end;
              end;
              m_DefMsg := MakeDefaultMsg(SM_DAILY, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1 {X坐标}, ProcessMsg.nParam2 {Y坐标}, ProcessMsg.wParam, nObjCount)
            end else m_DefMsg := MakeDefaultMsg(SM_DAILY, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1 {X坐标}, ProcessMsg.nParam2 {Y坐标}, ProcessMsg.wParam, 0);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_BLOODSOUL: begin //血魄一击(战)
          if (TBaseObject(ProcessMsg.BaseObject) <> nil) and (TBaseObject(ProcessMsg.BaseObject) <> Self) then begin //20110407
            m_DefMsg := MakeDefaultMsg(SM_BLOODSOUL, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1 {X坐标}, ProcessMsg.nParam2 {Y坐标}, ProcessMsg.wParam, 0);
            SendSocket(@m_DefMsg, '');
          end;
        end;
{$IF M2Version <> 2}
      RM_HIT_107: begin //纵横剑术
          if (TBaseObject(ProcessMsg.BaseObject) <> nil) and (TBaseObject(ProcessMsg.BaseObject) <> Self) then begin //20110407
            m_DefMsg := MakeDefaultMsg(SM_HIT_107, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1 {X坐标}, ProcessMsg.nParam2 {Y坐标}, ProcessMsg.wParam, 0);
            SendSocket(@m_DefMsg, '');
          end;
        end;
{$IFEND}
      RM_FIREHIT: begin //10014 烈火
          nCode := 160;
          if (TBaseObject(ProcessMsg.BaseObject) <> nil) and (TBaseObject(ProcessMsg.BaseObject) <> Self) then begin //20110407
            if (TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT) then begin
              nObjCount := 0;
              case ProcessMsg.nParam3 of //强化重数
                1..9: nObjCount := ProcessMsg.nParam3 + 1;
              else begin
{$IF M2Version <> 2}
                  nObjCount := BoolToInt(TPlayObject(ProcessMsg.BaseObject).m_boFengHaoMagicEffect);
{$IFEND}
                end;
              end;
              m_DefMsg := MakeDefaultMsg(SM_FIREHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1 {X坐标}, ProcessMsg.nParam2 {Y坐标}, ProcessMsg.wParam, nObjCount)
            end else m_DefMsg := MakeDefaultMsg(SM_FIREHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1 {X坐标}, ProcessMsg.nParam2 {Y坐标}, ProcessMsg.wParam, 0);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_4FIREHIT: begin //10014 4级烈火 20080112
          nCode := 161;
          if (TBaseObject(ProcessMsg.BaseObject) <> nil) and (TBaseObject(ProcessMsg.BaseObject) <> Self) then begin //20110407
            nObjCount := 0;
            case ProcessMsg.nParam3 of //强化重数
              1..9: nObjCount := ProcessMsg.nParam3 + 1;
            end;
            m_DefMsg := MakeDefaultMsg(SM_4FIREHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1 {X坐标}, ProcessMsg.nParam2 {Y坐标}, ProcessMsg.wParam, nObjCount);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_CRSHIT: begin //10014 抱月刀
          nCode := 162;
          if (TBaseObject(ProcessMsg.BaseObject) <> nil) and (TBaseObject(ProcessMsg.BaseObject) <> Self) then begin //20110407
            m_DefMsg := MakeDefaultMsg(SM_CRSHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_41: begin //开天斩
          nCode := 163;
          if (TBaseObject(ProcessMsg.BaseObject) <> nil) and (TBaseObject(ProcessMsg.BaseObject) <> Self) then begin //20110407
            // m_DefMsg := MakeDefaultMsg({SM_41 200800202替换}SM_TWINHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
            case TBaseObject(ProcessMsg.BaseObject).m_n42kill of //20080212 开天斩重轻击
              1: m_DefMsg := MakeDefaultMsg(SM_QTWINHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
              2: m_DefMsg := MakeDefaultMsg(SM_TWINHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
            end;
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_44: begin //44 龙影剑法
          nCode := 166;
          if (TBaseObject(ProcessMsg.BaseObject) <> nil) and (TBaseObject(ProcessMsg.BaseObject) <> Self) then begin //20110407
            m_DefMsg := MakeDefaultMsg(SM_CIDHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_BATTERHIT1: begin //追心刺 20090626
          if (TBaseObject(ProcessMsg.BaseObject) <> nil) and (TBaseObject(ProcessMsg.BaseObject) <> Self) then begin //20110407
            m_DefMsg := MakeDefaultMsg(SM_BATTERHIT1, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1 {X坐标}, ProcessMsg.nParam2 {Y坐标}, ProcessMsg.wParam {dir}, 0);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_BATTERHIT2: begin //三绝杀 20090702
          if (TBaseObject(ProcessMsg.BaseObject) <> nil) and (TBaseObject(ProcessMsg.BaseObject) <> Self) then begin //20110407
            m_DefMsg := MakeDefaultMsg(SM_BATTERHIT2, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1 {X坐标}, ProcessMsg.nParam2 {Y坐标}, ProcessMsg.wParam, 0);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_BATTERHIT3: begin //横扫千军 20090702
          if (TBaseObject(ProcessMsg.BaseObject) <> nil) and (TBaseObject(ProcessMsg.BaseObject) <> Self) then begin //20110407
            m_DefMsg := MakeDefaultMsg(SM_BATTERHIT3, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1 {X坐标}, ProcessMsg.nParam2 {Y坐标}, ProcessMsg.wParam, 0);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_BATTERHIT4: begin //断岳斩
          if (TBaseObject(ProcessMsg.BaseObject) <> nil) and (TBaseObject(ProcessMsg.BaseObject) <> Self) then begin //20110407
            m_DefMsg := MakeDefaultMsg(SM_BATTERHIT4, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1 {X坐标}, ProcessMsg.nParam2 {Y坐标}, ProcessMsg.wParam, 0);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_RUSH79: begin
          m_DefMsg := MakeDefaultMsg(SM_RUSH79, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_MONMOVE: begin //擒拿手
          nCode := 167;
          if (TBaseObject(ProcessMsg.BaseObject) <> nil) and (TBaseObject(ProcessMsg.BaseObject) <> Self) then begin //20110407
            m_DefMsg := MakeDefaultMsg(SM_SITDOWN, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_GOTETHERUSESPELL: begin
          nCode := 168;
          m_DefMsg := MakeDefaultMsg(SM_GOTETHERUSESPELL, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_TURN, //人物转身
        RM_PUSH, //人物向后移动
        RM_RUSH, //人物向前移动
        RM_RUSHKUNG: begin
          nCode := 169;
          if (TBaseObject(ProcessMsg.BaseObject) <> Self) or (ProcessMsg.wIdent = RM_PUSH) or (ProcessMsg.wIdent = RM_RUSH) or (ProcessMsg.wIdent = RM_RUSHKUNG) then begin
            nCode := 1691;
            case ProcessMsg.wIdent of
              RM_PUSH: //被冲撞，后退的效果
                m_DefMsg := MakeDefaultMsg(SM_BACKSTEP, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1 {x}, ProcessMsg.nParam2 {y}, MakeWord(ProcessMsg.wParam {dir}, TBaseObject(ProcessMsg.BaseObject).m_nLight {light}), 0);
              RM_RUSH: //冲撞
                m_DefMsg := MakeDefaultMsg(SM_RUSH, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight), 0);
              RM_RUSHKUNG: //攻杀
                m_DefMsg := MakeDefaultMsg(SM_RUSHKUNG, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight), 0);
            else begin //004D846A
                m_DefMsg := MakeDefaultMsg(SM_TURN, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight), ProcessMsg.nParam3);
              end;
            end;
            nObjCount := TBaseObject(ProcessMsg.BaseObject).GetFeature(CharDesc.feature);
            m_DefMsg.nSessionID := MakeLong(nObjCount, m_DefMsg.nSessionID);
            CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
            CharDesc.MonShowName := TBaseObject(ProcessMsg.BaseObject).m_btRaceServer; //20110713 宠物显名用

            s1C := EncodeBuffer(@CharDesc, SizeOf(TCharDesc) - SizeOf(TFeatures) + nObjCount);
            nCode := 1697;
            nObjCount := GetCharColor(TBaseObject(ProcessMsg.BaseObject)); //取人物名字颜色
            nCode := 1698;
            if ProcessMsg.sMsg <> '' then
              s1C := s1C + (EncodeString(ProcessMsg.sMsg + '/' + IntToStr(nObjCount)));
            SendSocket(@m_DefMsg, s1C);
            if ProcessMsg.wIdent = RM_TURN then begin
              nCode := 1695;
              //nObjCount := TBaseObject(ProcessMsg.BaseObject).GetFeatureToLong();

              nCode := 1696;
              m_DefMsg := MakeDefaultMsg(SM_FEATURECHANGED,
                Integer(ProcessMsg.BaseObject),
                {LoWord(nObjCount)}0,
                {HiWord(nObjCount)}0,
                TBaseObject(ProcessMsg.BaseObject).GetFeatureEx,
                TBaseObject(ProcessMsg.BaseObject).GetFeature(feature));
              SendSocket(@m_DefMsg, EncodeBuffer(@Feature, m_DefMsg.nSessionID));
              if TBaseObject(ProcessMsg.BaseObject).m_boShop then
                SendChangeShop(TBaseObject(ProcessMsg.BaseObject), True);
            end;
          end;
        end;
      RM_STRUCK,
        RM_STRUCK_MAG: begin //10020
          nCode := 170;
          if ProcessMsg.wParam {nPower} > 0 then begin
            {if Assigned(zPlugOfEngine.SendUserStruckMsg) then begin //20080813 注释
              zPlugOfEngine.SendUserStruckMsg(Self, ProcessMsg.BaseObject,TBaseObject(ProcessMsg.nParam3),ProcessMsg.wIdent);
            end else begin}
            if TBaseObject(ProcessMsg.BaseObject) <> nil then begin //20080722 增加
              nCode := 171;
              if TBaseObject(ProcessMsg.BaseObject) = Self then begin
                nCode := 172;
                if TBaseObject(ProcessMsg.nParam3) {AttackBaseObject} <> nil then begin
                  nCode := 173;
                  if not TBaseObject(ProcessMsg.nParam3).m_boDeath then begin //20090116 增加
                    nCode := 174;
                    if (TBaseObject(ProcessMsg.nParam3).m_btRaceServer = RC_PLAYOBJECT) or
                      (TBaseObject(ProcessMsg.nParam3).m_btRaceServer = RC_HEROOBJECT) then begin //英雄灰色 20080721
                      nCode := 175;
                      SetPKFlag(TBaseObject(ProcessMsg.nParam3) {AttackBaseObject});
                    end;
                  end;
                  nCode := 176;
                  SetLastHiter(TBaseObject(ProcessMsg.nParam3) {AttackBaseObject});

                   { //反复活
                    if TBaseObject(ProcessMsg.nParam3).m_boUnRevival then m_boRevival:=False;  }
                end;
                  //if PKLevel >= 2 then m_dw5D4 := GetTickCount(); //未使用 20080329
                if (g_CastleManager.IsCastleMember(Self) <> nil) and (TBaseObject(ProcessMsg.nParam3) <> nil) then begin
                  TBaseObject(ProcessMsg.nParam3).bo2B0 := True;
                  TBaseObject(ProcessMsg.nParam3).m_dw2B4Tick := GetTickCount();
                end;
                m_nHealthTick := 0;
                m_nSpellTick := 0;
                Dec(m_nPerHealth);
                Dec(m_nPerSpell);
                m_dwStruckTick := GetTickCount(); //09/10
              end;
            end;
            nCode := 177;
            if TBaseObject(ProcessMsg.BaseObject) <> nil then begin //富贵兽受普通攻击不显示受攻击后的动作 20090516
              if ((TBaseObject(ProcessMsg.BaseObject) = Self) and
                (g_Config.boDisableSelfStruck)) or
                ((TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT) and g_Config.boDisableStruck) or
                (TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = 79) then begin
                nCode := 178;
                TBaseObject(ProcessMsg.BaseObject).SendRefMsg(RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, ''); //人物受打击无弯腰动作
              end else begin
                nCode := 179;

                if (TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = 79) then begin //目标为富贵兽,只发送血量上限 20100711
                  m_DefMsg := MakeDefaultMsg(SM_STRUCK,
                    Integer(ProcessMsg.BaseObject),
                    LoWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP),
                    HiWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP),
                    ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP);
                end else begin
                  m_DefMsg := MakeDefaultMsg(SM_STRUCK, //20091026 修改
                    Integer(ProcessMsg.BaseObject),
                    LoWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),
                    HiWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),
                    ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP);
                  //By TasNat at: 2012-11-22 11:30:01
                  //MessageBodyWL.lMP := TBaseObject(ProcessMsg.BaseObject).m_WAbil.MP;
                  //MessageBodyWL.lMaxMP := TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxMP;
                end;
                nCode := 180;
                {减少不必要的数据By TasNat at: 2012-11-22 11:37:28
                MessageBodyWL.lParam1 := 0;
                MessageBodyWL.feature := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
                nCode := 181;
                MessageBodyWL.lParam2 := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
                nCode := 182;
                MessageBodyWL.lTag1 := ProcessMsg.nParam3;
                nCode := 183;
                if ProcessMsg.wIdent = RM_STRUCK_MAG then MessageBodyWL.lTag2 := 1
                else MessageBodyWL.lTag2 := 0;
                MessageBodyWL.MonShowName := TBaseObject(ProcessMsg.BaseObject).m_btRaceServer; //20110713 宠物显名用
                nCode := 184;}
                //SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL2, SizeOf(TMessageBodyWL2)));
                MessageBodyW.Param1 := LoWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MP);
                MessageBodyW.Param2 := HiWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MP);
                MessageBodyW.Tag1 := LoWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxMP);
                MessageBodyW.Tag2 := HiWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxMP);
                SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyW, SizeOf(TMessageBodyW)));//减少不必要的数据By TasNat at: 2012-11-22 11:37:28
              end;
            end;
            //end;//20080813 注释
          end;
        end;
      RM_STRUCK1: begin //富贵兽受攻击时的动作效果 20090518
          m_DefMsg := MakeDefaultMsg(SM_STRUCK, //20091026 修改
            Integer(ProcessMsg.BaseObject),
            LoWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP), //20100706 富贵兽不显示减血
            HiWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP), //20100706 富贵兽不显示减血
            ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP);

          {MessageBodyWL.lParam1 := 0;
          MessageBodyWL.feature := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
          MessageBodyWL.lParam2 := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          MessageBodyWL.lTag1 := ProcessMsg.nParam3;
          if ProcessMsg.wIdent = RM_STRUCK_MAG then MessageBodyWL.lTag2 := 1
          else MessageBodyWL.lTag2 := 0;
          MessageBodyWL.MonShowName := TBaseObject(ProcessMsg.BaseObject).m_btRaceServer; //20110713 宠物显名用
          SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)));}
          MessageBodyW.Param1 := LoWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MP);
          MessageBodyW.Param2 := HiWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MP);
          MessageBodyW.Tag1 := LoWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxMP);
          MessageBodyW.Tag2 := HiWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxMP);
          SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyW, SizeOf(TMessageBodyW)));//减少不必要的数据By TasNat at: 2012-11-22 11:37:28
        end;
      RM_DEATH: begin
          nCode := 185;
          if ProcessMsg.nParam3 = 1 then begin
            m_DefMsg := MakeDefaultMsg(SM_NOWDEATH,
              Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              ProcessMsg.wParam, 0);
          end else begin
            m_DefMsg := MakeDefaultMsg(SM_DEATH,
              Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              ProcessMsg.wParam, 0);
          end;
          m_DefMsg.nSessionID := TBaseObject(ProcessMsg.BaseObject).GetFeature(CharDesc.feature);
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          CharDesc.MonShowName := TBaseObject(ProcessMsg.BaseObject).m_btRaceServer; //20110713 宠物显名用
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc) - SizeOf(TFeatures) + m_DefMsg.nSessionID));
        end;

      RM_DISAPPEAR: begin //10022
          nCode := 186;
          m_DefMsg := MakeDefaultMsg(SM_DISAPPEAR, Integer(ProcessMsg.BaseObject), 0, 0, 0, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_SKELETON: begin //10024
          nCode := 187;
          m_DefMsg := MakeDefaultMsg(SM_SKELETON,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam, 0);
          m_DefMsg.nSessionID := TBaseObject(ProcessMsg.BaseObject).GetFeature(CharDesc.feature);
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          CharDesc.MonShowName := TBaseObject(ProcessMsg.BaseObject).m_btRaceServer; //20110713 宠物显名用
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc) - SizeOf(TFeatures) + m_DefMsg.nSessionID));
        end;
      RM_USERNAME: begin
          nCode := 188;
          m_DefMsg := MakeDefaultMsg(SM_USERNAME,
            Integer(ProcessMsg.BaseObject),
            GetCharColor(TBaseObject(ProcessMsg.BaseObject)), ProcessMsg.nParam3 {称号图片idx}, 0, 0);
          //MainOutMessage(TBaseObject(ProcessMsg.BaseObject).m_sCharName+' sMsg...'+ProcessMsg.sMsg);
          SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
        end;
      RM_WINEXP: begin
          nCode := 189;

          m_DefMsg := MakeDefaultMsg(SM_WINEXP, 0,0,0, ProcessMsg.nParam2, ProcessMsg.nParam3);

          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_WINNHEXP: begin //取得内功经验 20081007
          nCode := 190;
          m_DefMsg := MakeDefaultMsg(SM_WINNHEXP, 0, LoWord(ProcessMsg.nParam1), HiWord(ProcessMsg.nParam1), 0, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_HEROWINNHEXP: begin //英雄取得内功经验 20081007
          nCode := 191;
          m_DefMsg := MakeDefaultMsg(SM_HEROWINNHEXP, 0, LoWord(ProcessMsg.nParam1), HiWord(ProcessMsg.nParam1), 0, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_WINCATTLEGASEXP: begin //取得牛气值经验 20090520
          m_DefMsg := MakeDefaultMsg(SM_WINCATTLEGASEXP, 0, LoWord(ProcessMsg.nParam1), HiWord(ProcessMsg.nParam1), ProcessMsg.nParam2 {类型 0-牛气值 1-心法经验}, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_LEVELUP: begin
          nCode := 192;
          {if Assigned(zPlugOfEngine.SendUserLevelUpMsg) then begin//20080813 注释
            zPlugOfEngine.SendUserLevelUpMsg(Self);
          end else begin}
          m_DefMsg := MakeDefaultMsg(SM_LEVELUP, {m_Abil.Exp}0, m_Abil.Level, 0, 0, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);

          m_DefMsg := MakeDefaultMsg(SM_ABILITY, m_nGold, MakeWord(m_btJob, 99), LoWord(m_nGameGold), HiWord(m_nGameGold), 0);
            //0806 增加
          if (m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0) then begin
            GetOldAbil(OAbility);
            SendSocket(@m_DefMsg, EncodeBuffer(@OAbility, SizeOf(TOAbility)));
          end else begin
            SendSocket(@m_DefMsg, EncodeBuffer(@m_WAbil, SizeOf(TAbility)));
          end;
            {SendDefMessage(SM_SUBABILITY, //20110712 修改
              MakeLong(MakeWord(m_nAntiMagic, 0), 0),
              MakeWord(m_btHitPoint, m_btSpeedPoint),
              MakeWord(m_btAntiPoison, m_nPoisonRecover),
              MakeWord(m_nHealthRecover, m_nSpellRecover),
              ''); }

          m_DefMsg := MakeDefaultMsg(SM_SUBABILITY,
            MakeLong(MakeWord(m_nAntiMagic, 0), 0),
            MakeWord(m_btHitPoint, m_btSpeedPoint),
            MakeWord(m_btAntiPoison, m_nPoisonRecover),
            MakeWord(m_nHealthRecover, m_nSpellRecover), 0);
          //SendSocket(@m_DefMsg, EncodeBuffer(@TPlayObject(ProcessMsg.BaseObject).ClientSuitAbility, SizeOf(TClientSuitAbility)));
          //防止非法读写 By TasNat at: 2012-04-05 17:10:13
          case TBaseObject(ProcessMsg.BaseObject).m_btRaceServer of // ProcessMsg.BaseObject
              RC_PLAYOBJECT: SendSocket(@m_DefMsg, EncodeBuffer(@TPlayObject(ProcessMsg.BaseObject).ClientSuitAbility, SizeOf(TClientSuitAbility)) {套装属性值});
              RC_HEROOBJECT: SendSocket(@m_DefMsg, EncodeBuffer(@THeroObject(ProcessMsg.BaseObject).ClientSuitAbility, SizeOf(TClientSuitAbility)) {套装属性值});
            else SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_CHANGENAMECOLOR: begin //10046 改变名字颜色
          nCode := 193;
          if ProcessMsg.BaseObject <> nil then //20080724 增加
            SendDefMessage(SM_CHANGENAMECOLOR, Integer(ProcessMsg.BaseObject),
              GetCharColor(TBaseObject(ProcessMsg.BaseObject)), 0, 0, '');
        end;
      RM_CLICKMMISSION: begin //M2回复客户端点击事件 20100801
          m_DefMsg := MakeDefaultMsg(SM_CLICKMMISSION, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0);
          SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
        end;
      RM_OPENSHINY: begin //显示成长任务 20090402
          SendDefMessage(SM_OPENSHINY, ProcessMsg.nParam1, 0, 0, 0, ProcessMsg.sMsg);
        end;
      RM_LOGON: begin //10050
          nCode := 194;
          if m_PEnvir.m_boDARK then nObjCount := 1
          else begin
            case m_nBright of
              1: nObjCount := 0;
              3: nObjCount := 1;
            else nObjCount := 1;
            end;
          end;
          if m_PEnvir.m_boDAY then nObjCount := 0;
          nCode := 316;
          m_DefMsg := MakeDefaultMsg(SM_NEWMAP, Integer(Self), m_nCurrX, m_nCurrY, nObjCount, 0);
          SendSocket(@m_DefMsg, EncodeString(g_MapManager.GetMainMap(m_PEnvir)));
          nCode := 317;
          SendMsg(Self, RM_CHANGELIGHT, 0, 0, 0, 0, '');
          nCode := 318;
          SendLogon(); //发送登陆消息
          nCode := 319;
          SendServerConfig(); //2007.12.18  恢复掉注释
          nCode := 320;
          SendUnBind(); //发送解包文件
          nCode := 321;
          ClientQueryUserName(Self, m_nCurrX, m_nCurrY); //发送名字颜色
          nCode := 322;
          RefUserState(); //刷新玩家状态
          nCode := 323;
          SendMapDescription(); //发送地图音乐背景数据
          nCode := 324;
          SendGoldInfo(True); //发送游戏币等物品数据及名字
          nCode := 325;
          SendGloryInfo; //发送荣誉值到客户端
          //m_DefMsg := MakeDefaultMsg(SM_VERSION_FAIL, g_Config.nClientFile1_CRC, 0, 0, 0, 0);//验证客户端版本 20080831 修改
          //SendSocket(@m_DefMsg, '');
        end;
      RM_HEAR2: begin
          Hear(ProcessMsg.wParam, ProcessMsg.sMsg);
        end;
      RM_HEAR,
        RM_WHISPER,
        RM_CRY,
        RM_SYSMESSAGE,
        RM_MOVEMESSAGE1,
        RM_MOVEMESSAGE, //滚动公告   2007.11.13
        RM_GROUPMESSAGE,
        RM_SYSMESSAGE2,
        RM_GUILDMESSAGE,
        RM_DIVISIONMESSAGE,
        RM_SYSMESSAGE3,
        RM_PLAYDRINKSAY,
        RM_MERCHANTSAY: begin
          nCode := 195;
          if not m_boAI then begin
            case ProcessMsg.wIdent of
              RM_HEAR: m_DefMsg := MakeDefaultMsg(SM_HEAR, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), ProcessMsg.nParam3, 1, 0); //10030
              RM_WHISPER: m_DefMsg := MakeDefaultMsg(SM_WHISPER, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), ProcessMsg.wParam, 1, 0); //10031
              RM_CRY: m_DefMsg := MakeDefaultMsg(SM_CRY, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), 0, 1, 0); //10032
              RM_SYSMESSAGE: m_DefMsg := MakeDefaultMsg(SM_SYSMESSAGE, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), 0, 1, 0); //10100 红色
              //滚动公告  2007.11.13
              RM_MOVEMESSAGE: m_DefMsg := MakeDefaultMsg(SM_MOVEMESSAGE, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), ProcessMsg.nParam3 {0}, ProcessMsg.wParam {消息分类}, 0); //10100 红色   20081218
              RM_GROUPMESSAGE: m_DefMsg := MakeDefaultMsg(SM_GROUPMESSAGE {SM_SYSMESSAGE}, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), 0, 1, 0); //10102  20090212 修改
              RM_GUILDMESSAGE: m_DefMsg := MakeDefaultMsg(SM_GUILDMESSAGE, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), 0, 1, 0); //10104 行会聊天
              RM_DIVISIONMESSAGE: m_DefMsg := MakeDefaultMsg(SM_DIVISIONMESSAGE, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), 0, 1, 0); //师门聊天
              RM_MERCHANTSAY: m_DefMsg := MakeDefaultMsg(SM_MERCHANTSAY, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), ProcessMsg.nParam3, 1, 0); //10126
              RM_PLAYDRINKSAY: m_DefMsg := MakeDefaultMsg(SM_PLAYDRINKSAY, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam3, 0, 1, 0); //20080515        // ProcessMsg.nParam3 传递的窗口类型
              RM_MOVEMESSAGE1: m_DefMsg := MakeDefaultMsg(SM_MOVEMESSAGE1, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), ProcessMsg.nParam3 {0}, ProcessMsg.wParam {消息分类}, 0);
            end;
            SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
          end else begin
            SendDelayMsg(Self, RM_HEAR2, ProcessMsg.wIdent, 0, 0, 0, ProcessMsg.sMsg, 1500);
          end;
        end;

      RM_ABILITY: begin
          nCode := 196;
          m_DefMsg := MakeDefaultMsg(SM_ABILITY, m_nGold, MakeWord(m_btJob, 99), LoWord(m_nGameGold), HiWord(m_nGameGold), {$IF M2Version = 1}Integer(m_boOpenupSkill95){$ELSE}0{$IFEND}); //是否打通斗转99
          if (m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0) then begin
            GetOldAbil(OAbility);
            SendSocket(@m_DefMsg, EncodeBuffer(@OAbility, SizeOf(TOAbility)));
            if g_Config.boOldClientShowHiLevel and (m_Abil.Level > 255) then begin
              SysMsg(g_sClientVersionTooOld {'由于您使用的客户端版本太老了，无法正确显示人物信息！！！'}, c_Red, t_Hint);
              SysMsg('当前等级: ' + IntToStr(m_Abil.Level), c_Green, t_Hint);
              SysMsg('当前生命值: ' + IntToStr(m_WAbil.HP) + '-' + IntToStr(m_WAbil.MaxHP), c_Blue, t_Hint);
              SysMsg('当前魔法值: ' + IntToStr(m_WAbil.MP) + '-' + IntToStr(m_WAbil.MaxMP), c_Red, t_Hint);
              SysMsg('当前防御力: ' + IntToStr(LoWord(m_WAbil.AC)) + '-' + IntToStr(HiWord(m_WAbil.AC)), c_Green, t_Hint);
              SysMsg('当前魔防力: ' + IntToStr(LoWord(m_WAbil.MAC)) + '-' + IntToStr(HiWord(m_WAbil.MAC)), c_Blue, t_Hint);
              SysMsg('当前攻击力: ' + IntToStr(LoWord(m_WAbil.DC)) + '-' + IntToStr(HiWord(m_WAbil.DC)), c_Red, t_Hint);
              SysMsg('当前魔法力: ' + IntToStr(LoWord(m_WAbil.MC)) + '-' + IntToStr(HiWord(m_WAbil.MC)), c_Green, t_Hint);
              SysMsg('当前道术值: ' + IntToStr(LoWord(m_WAbil.SC)) + '-' + IntToStr(HiWord(m_WAbil.SC)), c_Blue, t_Hint);
            end;
          end else begin
            SendSocket(@m_DefMsg, EncodeBuffer(@m_WAbil, SizeOf(TAbility)));
          end;
        end;
      RM_PLAYMAKEWINEABILITY: begin //酒2相关属性 20080804
          nCode := 197;
          m_DefMsg := MakeDefaultMsg(SM_PLAYMAKEWINEABILITY,
            m_WAbil.Alcohol,
            m_WAbil.MaxAlcohol,
            m_WAbil.WineDrinkValue,
            m_WAbil.MedicineValue, m_WAbil.MaxMedicineValue);
          SendSocket(@m_DefMsg, '');
        end;
      RM_HEROMAKEWINEABILITY: begin //英雄酒2相关属性 20080804
          if m_MyHero <> nil then begin
            nCode := 198;
            m_DefMsg := MakeDefaultMsg(SM_HEROMAKEWINEABILITY,
              m_MyHero.m_WAbil.Alcohol,
              m_MyHero.m_WAbil.MaxAlcohol,
              m_MyHero.m_WAbil.WineDrinkValue,
              m_MyHero.m_WAbil.MedicineValue, m_MyHero.m_WAbil.MaxMedicineValue);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_CANEXPLORATION: begin //可探索 20080810
          nCode := 199;
          m_DefMsg := MakeDefaultMsg(SM_CANEXPLORATION, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_HEALTHSPELLCHANGED: begin //10052
          nCode := 200;
          if (TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = 79) then begin //目标为富贵兽,只发送血量上限 20100714
            m_DefMsg := MakeDefaultMsg(SM_HEALTHSPELLCHANGED,
              Integer(ProcessMsg.BaseObject),
              LoWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP),
              HiWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP),
              0, TBaseObject(ProcessMsg.BaseObject).m_WAbil.MP);
          end else begin
            m_DefMsg := MakeDefaultMsg(SM_HEALTHSPELLCHANGED, //20091026 修改
              Integer(ProcessMsg.BaseObject),
              LoWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),
              HiWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),
              0, TBaseObject(ProcessMsg.BaseObject).m_WAbil.MP);
          end;
          SendSocket(@m_DefMsg, IntToStr(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP));
        end;
      RM_HEROHEALTHSPELLCHANGED: begin
          nCode := 200;
          m_DefMsg := MakeDefaultMsg(SM_HEROHEALTHSPELLCHANGED, //20091026 修改
            Integer(ProcessMsg.BaseObject),
            LoWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),
            HiWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),
            0, TBaseObject(ProcessMsg.BaseObject).m_WAbil.MP);
          SendSocket(@m_DefMsg, IntToStr(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP));
        end;
      RM_HEALTHSPELLCHANGED1: begin
          nCode := 200;
          m_DefMsg := MakeDefaultMsg(SM_HEALTHSPELLCHANGED1, //20091026 修改
            Integer(ProcessMsg.BaseObject),
            LoWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),
            HiWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),
            0, TBaseObject(ProcessMsg.BaseObject).m_WAbil.MP);
          SendSocket(@m_DefMsg, IntToStr(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP));
        end;
      RM_HEROHEALTHSPELLCHANGED1: begin
          nCode := 200;
          m_DefMsg := MakeDefaultMsg(SM_HEROHEALTHSPELLCHANGED1, //20091026 修改
            Integer(ProcessMsg.BaseObject),
            LoWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),
            HiWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),
            0, TBaseObject(ProcessMsg.BaseObject).m_WAbil.MP);
          SendSocket(@m_DefMsg, IntToStr(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP));
        end;
      RM_DAYCHANGING: begin //10053
          nCode := 201;
          if m_PEnvir.m_boDARK then nObjCount := 1
          else begin
            case m_nBright of
              1: nObjCount := 0;
              3: nObjCount := 1;
            else nObjCount := 1;
            end;
          end;
          if m_PEnvir.m_boDAY then nObjCount := 0;
          m_DefMsg := MakeDefaultMsg(SM_DAYCHANGING, 0, m_nBright, nObjCount, 0, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_ITEMSHOW: begin //10110
          nCode := 202;
          SendDefMessage(SM_ITEMSHOW, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.wParam, ProcessMsg.sMsg);
        end;
      RM_ITEMHIDE: begin //10111
          nCode := 203;
          SendDefMessage(SM_ITEMHIDE, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0, '');
        end;
      RM_DOOROPEN: begin //10112
          nCode := 204;
          SendDefMessage(SM_OPENDOOR_OK, 0, ProcessMsg.nParam1, {x} ProcessMsg.nParam2, {y} 0, '');
        end;
      RM_DOORCLOSE: begin //10113
          nCode := 205;
          SendDefMessage(SM_CLOSEDOOR, 0, ProcessMsg.nParam1, ProcessMsg.nParam2, 0, '');
        end;
      RM_SENDUSEITEMS: begin //发送装备物品数据
          nCode := 206;
          SendUseitems();
        end;
      RM_WEIGHTCHANGED: begin //10115 重量改变
          nCode := 207;
          SendDefMessage(SM_WEIGHTCHANGED, m_WAbil.Weight, m_WAbil.WearWeight, m_WAbil.HandWeight, 0, '');
        end;
      RM_FEATURECHANGED: begin //10116
          nCode := 208;
          m_DefMsg := MakeDefaultMsg(SM_FEATURECHANGED, Integer(ProcessMsg.BaseObject), 0,
            0, ProcessMsg.wParam, ProcessMsg.nParam1);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_CLEAROBJECTS: begin //10117
          nCode := 209;
          SendDefMessage(SM_CLEAROBJECTS, 0, 0, 0, 0, '');
        end;
      RM_CHANGEMAP: begin //地图改变
          nCode := 210;
          if m_PEnvir.m_boDARK then nObjCount := 1
          else begin
            case m_nBright of
              1: nObjCount := 0;
              3: nObjCount := 1;
            else nObjCount := 1;
            end;
          end;
          if m_PEnvir.m_boDAY then nObjCount := 0;
          SendDefMessage(SM_CHANGEMAP, Integer(Self), m_nCurrX, m_nCurrY, nObjCount, ProcessMsg.sMsg);
          RefUserState(); //刷新玩家状态
          SendMapDescription(); //发送地图音乐背景数据
          SendServerConfig(); //2007.12.18  恢复掉注释
          //SendUnBind();//发送解包文件 20090408注释，因登陆时已发送过，故换地图不再发送
        end;
      RM_BUTCH: begin //10119
          nCode := 211;
          if ProcessMsg.BaseObject <> nil then begin
            m_DefMsg := MakeDefaultMsg(SM_BUTCH, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1,
              ProcessMsg.nParam2, ProcessMsg.wParam, 0);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_MAGICFIRE: begin //10120
          nCode := 212;
          m_DefMsg := MakeDefaultMsg(SM_MAGICFIRE,
            Integer(ProcessMsg.BaseObject),
            LoWord(ProcessMsg.nParam2),
            HiWord(ProcessMsg.nParam2),
            ProcessMsg.nParam1, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, EncodeBuffer(@ProcessMsg.nParam3, SizeOf(Integer)));
        end;
      RM_MAGICFIREFAIL: begin //10121
          nCode := 213;
          SendDefMessage(SM_MAGICFIRE_FAIL, Integer(ProcessMsg.BaseObject), 0, 0, 0, '');
        end;
      RM_SENDMYMAGIC: begin
          nCode := 214;
          SendUseMagic; //10122
        end;
      RM_MAGIC_LVEXP: begin //10123
          nCode := 215;
          //MainOutMessage(Format('技能ID:%d  技能等级:%d  当前修炼值:%d 升级经验值:%d',[ProcessMsg.wParam,ProcessMsg.nParam2,ProcessMsg.nParam3,ProcessMsg.nParam1]));
          SendDefMessage1(SM_MAGIC_LVEXP, ProcessMsg.wParam {技能ID}, ProcessMsg.nParam2 {技能等级},
            LoWord(ProcessMsg.nParam3), HiWord(ProcessMsg.nParam3) {当前修炼值}, ProcessMsg.nParam1 {酒气护体,召唤圣兽,龙卫心法升级经验值}, '');
        end;
{$IF M2Version <> 2}
      RM_NGMAGIC_LVEXP: begin //怒之内功技能强化成功 20110604
          SendDefMessage1(SM_NGMAGIC_LVEXP, ProcessMsg.wParam {技能ID}, ProcessMsg.nParam2 {技能等级},
            LoWord(ProcessMsg.nParam3), HiWord(ProcessMsg.nParam3) {所需要的绿石数}, ProcessMsg.nParam1 {升级所需的内功等级}, '');
        end;
{$IF HEROVERSION = 1}
      RM_HERONGMAGIC_LVEXP: begin //英雄怒之内功技能强化成功 20110605
          SendDefMessage1(SM_HERONGMAGIC_LVEXP, ProcessMsg.wParam {技能ID}, ProcessMsg.nParam2 {技能等级},
            LoWord(ProcessMsg.nParam3), HiWord(ProcessMsg.nParam3) {所需要的绿石数}, ProcessMsg.nParam1 {升级所需的内功等级}, '');
        end;
{$IFEND}
{$IFEND}
      RM_DURACHANGE: begin //10125
          nCode := 216;
          SendDefMessage(SM_DURACHANGE, ProcessMsg.nParam1, ProcessMsg.wParam,
            LoWord(ProcessMsg.nParam2), HiWord(ProcessMsg.nParam2), ProcessMsg.sMsg);
        end;
      RM_EXPTIMEITEMS: begin //聚灵珠 发送时间变化  20080307
          nCode := 217;
          SendDefMessage(SM_EXPTIMEITEMS, ProcessMsg.nParam1 {MakeIndex},
            ProcessMsg.wParam, ProcessMsg.nParam2 {时间}, 0, '');
        end;
      RM_HERODURACHANGE: begin //10125
          nCode := 218;
          SendDefMessage(SM_HERODURACHANGE, ProcessMsg.nParam1, ProcessMsg.wParam,
            LoWord(ProcessMsg.nParam2), HiWord(ProcessMsg.nParam2), '');
        end;
      RM_FIRDRAGONPOINT: begin
          nCode := 219;
          SendDefMessage(SM_FIRDRAGONPOINT, ProcessMsg.nParam1, ProcessMsg.wParam, 0, 0, '');
        end;
      RM_MERCHANTDLGCLOSE: begin //10127
          nCode := 220;
          SendDefMessage(SM_MERCHANTDLGCLOSE, ProcessMsg.nParam1, 0, 0, 0, '');
        end;
      RM_SENDGOODSLIST: begin
          nCode := 221;
          SendDefMessage(SM_SENDGOODSLIST, ProcessMsg.nParam1, ProcessMsg.nParam2, 0, 0, ProcessMsg.sMsg);
        end;
      RM_SENDUSERSELL: begin //10129
          nCode := 222;
          SendDefMessage(SM_SENDUSERSELL, ProcessMsg.nParam1, ProcessMsg.nParam2, 0, 0, ProcessMsg.sMsg);
        end;
      RM_CHANGEATTATCKMODE: begin //改变攻击模式
          nCode := 223;
          m_DefMsg := MakeDefaultMsg(SM_CHANGEATTATCKMODE, Integer(ProcessMsg.BaseObject), 0, 0, 0, 0);
          SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
        end;
      RM_SENDBUYPRICE: begin //10130
          nCode := 224;
          SendDefMessage(SM_SENDBUYPRICE, ProcessMsg.nParam1, 0, 0, 0, '');
        end;
      RM_USERSELLITEM_OK: begin //10131
          nCode := 225;
          SendDefMessage(SM_USERSELLITEM_OK, ProcessMsg.nParam1, 0, 0, 0, '');
        end;
      RM_USERSELLITEM_FAIL: begin //10132
          nCode := 226;
          SendDefMessage(SM_USERSELLITEM_FAIL, ProcessMsg.nParam1, 0, 0, 0, '');
        end;
      RM_BUYITEM_SUCCESS: begin //10133
          nCode := 227;
          SendDefMessage(SM_BUYITEM_SUCCESS, ProcessMsg.nParam1, LoWord(ProcessMsg.nParam2), HiWord(ProcessMsg.nParam2), 0, '');
        end;
      RM_BUYITEM_FAIL: begin //10134
          nCode := 228;
          SendDefMessage(SM_BUYITEM_FAIL, ProcessMsg.nParam1, 0, 0, 0, '');
        end;
      RM_SENDDETAILGOODSLIST: begin //10135
          nCode := 229;
          SendDefMessage(SM_SENDDETAILGOODSLIST, ProcessMsg.nParam1, ProcessMsg.nParam2,
            ProcessMsg.nParam3, 0, ProcessMsg.sMsg);
        end;
      RM_OPENBOOKS: begin //卧龙 20080119
          nCode := 230;
          m_DefMsg := MakeDefaultMsg(SM_OPENBOOKS, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, 0, 0, 0); //10126
          SendSocket(@m_DefMsg, '');
        end;
      RM_Browser: begin //连接指定网址 20080602
          nCode := 231;
          m_DefMsg := MakeDefaultMsg(SM_Browser, Integer(ProcessMsg.BaseObject), 0, 0, 0, 0); //10126
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_PALYVIDEO: begin //播放指定的视频文件
          m_DefMsg := MakeDefaultMsg(SM_PALYVIDEO, Integer(ProcessMsg.BaseObject), 0, 0, 0, 0);
          SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
        end;
      RM_AUTOGOTOXY: begin //自动寻路 20080617
          nCode := 232;
          m_DefMsg := MakeDefaultMsg(SM_AUTOGOTOXY, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, 0, 0); //10126
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_UPPETSMONHAPP: begin //更新宠物的快乐度
          m_DefMsg := MakeDefaultMsg(SM_UPPETSMONHAPP, Integer(ProcessMsg.BaseObject), 0, 0, 0, ProcessMsg.nParam1 {快乐度});
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_PETSMONHAPPLOG: begin //打开宠物喂养日志
          m_DefMsg := MakeDefaultMsg(SM_PETSMONHAPPLOG, Integer(ProcessMsg.BaseObject), 0, 0, 0, ProcessMsg.nParam1 {快乐度});
          SendSocket(@m_DefMsg, ProcessMsg.sMsg {日志});
        end;
      CM_PETSMONHAPPLOG: begin //喂养日志翻页
          ClientPetsMonHappLog(ProcessMsg.nParam1 {0-上一页 1-下一页});
        end;
      CM_MOVETOPETSMON: begin //传送到宠物身旁
          ClientMoveToPetsMon(); //传送到宠物身旁
        end;
  //-------------------------酿酒系统---------------------------------------------
      RM_OPENMAKEWINE: begin //打开酿酒窗口
          nCode := 233;
          m_DefMsg := MakeDefaultMsg(SM_OPENMAKEWINE, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, 0, 0, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_MAKEWINE_OK: begin //酿酒成功
          nCode := 234;
          m_DefMsg := MakeDefaultMsg(SM_MAKEWINE_OK, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, 0, 0, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_MAKEWINE_FAIL: begin //酿酒失败
          nCode := 235;
          m_DefMsg := MakeDefaultMsg(SM_MAKEWINE_FAIL, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, 0, 0, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_NPCWALK: begin //酿酒NPC移动 20080621
          nCode := 236;
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg := MakeDefaultMsg(SM_NPCWALK, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_btJob), 0);
            m_DefMsg.nSessionID := TBaseObject(ProcessMsg.BaseObject).GetFeature(CharDesc.feature);
            CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
            CharDesc.MonShowName := TBaseObject(ProcessMsg.BaseObject).m_btRaceServer; //20110713 宠物显名用
            SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc) - SizeOf(TFeatures) + m_DefMsg.nSessionID));
          end;
        end;
{$IF M2Version <> 2}
      RM_MAGIC69SKILLEXP: begin //内功心法经验 20080930
          nCode := 239;
          m_DefMsg := MakeDefaultMsg(SM_MAGIC69SKILLEXP, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_HEROMAGIC69SKILLEXP: begin //英雄内功心法经验 20080930
          nCode := 240;
          m_DefMsg := MakeDefaultMsg(SM_HEROMAGIC69SKILLEXP, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_MAGIC69SKILLNH: begin //内力值(黄条) 20081002
          nCode := 241;
          m_DefMsg := MakeDefaultMsg(SM_MAGIC69SKILLNH, Integer(ProcessMsg.BaseObject), LoWord(ProcessMsg.nParam1), HiWord(ProcessMsg.nParam1), 0, ProcessMsg.nParam2);
          SendSocket(@m_DefMsg, IntToStr(TBaseObject(ProcessMsg.BaseObject).m_Abil.MP) + ':' + IntToStr(TBaseObject(ProcessMsg.BaseObject).m_Abil.MaxMP) + ':' + IntToStr(IsTakeItemForHuShengRing(TBaseObject(ProcessMsg.BaseObject))));
        end;

      CM_REFINEITEM: begin //客户端发送淬练物品 20080507
          nCode := 122;
          if ClientAddRefineItem(ProcessMsg.sMsg) then ClientRefineItem;
        end;
      RM_QUERYREFINEITEM: begin //NPC打开淬炼窗口 20080502
          nCode := 58;
          m_DefMsg := MakeDefaultMsg(SM_QUERYREFINEITEM,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;

      CM_RefineArmyDrum: begin //客户端发送淬练军鼓的物品 liuzhigang
          ClientRefineArmyDrum(ProcessMsg.nParam1, ProcessMsg.wParam, ProcessMsg.sMsg);
        end;
      RM_OpenRefineArmyDrum: begin // 容许NPC打开淬炼的窗口
          nCode := 58;
          m_DefMsg := MakeDefaultMsg(SM_OpenRefineArmyDrum,
            1, ProcessMsg.nParam2, //
            ProcessMsg.nParam3,
            ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, '');
        end;

      RM_HUMTAKEITEM: begin // TPlayObject 或者 THeroObject
          m_DefMsg := MakeDefaultMsg(SM_HUMTAKEITEM, Integer(ProcessMsg.BaseObject), ProcessMsg.wParam, 0, 0, 0);
          SendSocket(@m_DefMsg, '');
        // BaseObject.SendMsg(BaseObject, RM_HUMTAKEITEM ,MakeWord(HumPropPos,Value),Integer(Self),0,0,'');
        end;

      CM_REPAIRFINEITEM: begin //修补火云石 20080506
          nCode := 32;
          RepairRefineItem(ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
      CM_CLICKMMISSION: begin //打开成长任务窗口 20100801
          if GetTickCount - m_dwUserTick[1] >= 400 then begin
            m_dwUserTick[1] := GetTickCount;
            ClientQMissionGoto(ProcessMsg.sMsg, ProcessMsg.nParam1);
          end;
        end;
      CM_MERCHANTQUERYARMSEXCHANGEPRICE: begin //把装备放到交易框，取装备所得的卷轴碎片数 20100812
          if g_Config.boUseCanKamPo then begin
            ClientMerchantQueryArmsExchangeCount(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
          end;
        end;
      RM_SENDARMSEXCHANGEPRICE: begin //发送装备所得的卷轴碎片数
          SendDefMessage(SM_SENDARMSEXCHANGEPRICE, ProcessMsg.nParam1, 0, 0, 0, '');
        end;
      CM_USERARMSEXCHANGE: begin //客户端兑换卷轴碎片
          if g_Config.boUseCanKamPo then begin
            ClientUserArmsExhange(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
          end;
        end;
      RM_USERARMSEXCHANGE_FAIL: begin //客户端兑换卷轴碎片 失败
          m_DefMsg := MakeDefaultMsg(SM_USERARMSEXCHANGE_FAIL, ProcessMsg.nParam1, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_USERARMSEXCHANGE_OK: begin //客户端兑换卷轴碎片 成功
          m_DefMsg := MakeDefaultMsg(SM_USERARMSEXCHANGE_OK, 0, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, '');
        end;
      CM_USERSCROLLCHANGEITME: begin //客户端使用神秘卷轴解读神秘属性
          if (GetTickCount - m_dwUserTick[1] >= 400) and (g_Config.boUseCanKamPo) then begin
            m_dwUserTick[1] := GetTickCount;
            ClientUserScrollChangeItem(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3));
          end;
        end;
      RM_USERSCROLLCHANGEITME_OK: begin
          m_DefMsg := MakeDefaultMsg(SM_USERSCROLLCHANGEITME_OK, 0, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_USERSCROLLCHANGEITME_FAIL: begin
          m_DefMsg := MakeDefaultMsg(SM_USERSCROLLCHANGEITME_FAIL, 0, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, '');
        end;
      CM_USERKAMPO: begin //客户端鉴定物品
          if (GetTickCount - m_dwUserTick[1] >= 400) and (g_Config.boUseCanKamPo) then begin
            m_dwUserTick[1] := GetTickCount;
            ClientUserKamPoItems(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.wParam);
          end;
        end;
      CM_NewUSERKAMPO: begin //客户端鉴定物品
          if (GetTickCount - m_dwUserTick[1] >= 400) and (g_Config.boUseCanKamPo) then begin
            m_dwUserTick[1] := GetTickCount;
            ClientUserNewKamPoItems(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
          end;
        end;

      RM_USERKAMPO_FAIL: begin //客户端鉴定物品 失败
          m_DefMsg := MakeDefaultMsg(SM_USERKAMPO_FAIL, 0, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_USERKAMPO_OK: begin //客户端鉴定物品 成功
          m_DefMsg := MakeDefaultMsg(SM_USERKAMPO_OK, 0, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, '');
        end;

      RM_NewUSERKAMPO_FAIL: begin //客户端鉴定物品 失败
          m_DefMsg := MakeDefaultMsg(SM_NewUSERKAMPO_FAIL, 0, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_NewUSERKAMPO_OK: begin //客户端鉴定物品 成功
          m_DefMsg := MakeDefaultMsg(SM_NewUSERKAMPO_OK, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0);
          SendSocket(@m_DefMsg, '');
        end;

      CM_USERCHANGEKAMPO: begin //客户端更换物品
          if (GetTickCount - m_dwUserTick[1] >= 400) and (g_Config.boUseCanKamPo) then begin
            m_dwUserTick[1] := GetTickCount;
            ClientChangeKamPoItems(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3));
          end;
        end;
      RM_USERCHANGEKAMPO_FAIL: begin //客户端更换物品 失败
          m_DefMsg := MakeDefaultMsg(SM_USERCHANGEKAMPO_FAIL, 0, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_USERCHANGEKAMPO_OK: begin //客户端更换物品 成功
          m_DefMsg := MakeDefaultMsg(SM_USERCHANGEKAMPO_OK, 0, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, '');
        end;
      CM_OPENQUERYPROFICIENCY: begin //查询神秘解读的熟练度
          if GetTickCount - m_dwUserTick[1] >= 300 then begin
            m_dwUserTick[1] := GetTickCount;
            m_DefMsg := MakeDefaultMsg(SM_OPENQUERYPROFICIENCY, m_nProficiency {熟练度(制造神秘卷轴)}, 0, 0, 0, 0);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      CM_OPENSCROLLFRM: begin //打开卷轴窗口，取精力值和幸运值
          if (GetTickCount - m_dwUserTick[1] >= 300) and (g_Config.boUseCanKamPo) then begin
            m_dwUserTick[1] := GetTickCount;
            SendEnergyAndLucky(); //发送精力值和幸运值
          end;
        end;
      CM_USERMAKESCROLL: begin //客户端使用羊皮卷制造神秘卷轴
          if (GetTickCount - m_dwUserTick[1] >= 400) and (g_Config.boUseCanKamPo) then begin
            m_dwUserTick[1] := GetTickCount;
            ClientUserMakeScrollItems(ProcessMsg.nParam1, ProcessMsg.nParam2);
          end;
        end;
      RM_USERMAKESCROLL_OK: begin
          m_DefMsg := MakeDefaultMsg(SM_USERMAKESCROLL_OK, 0, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_USERMAKESCROLL_FAIL: begin
          m_DefMsg := MakeDefaultMsg(SM_USERMAKESCROLL_FAIL, ProcessMsg.nParam1, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_SENDUSESPIRITITEMS: begin //发送灵媒装备位物品数据
          SendUseSpiritItems();
        end;
      CM_TAKEONSPIRITITEM: begin //把灵媒放到灵媒位上
          if g_Config.boUseCanKamPo then begin
            ClientTakeOnSpiritItems(ProcessMsg.nParam1, ProcessMsg.sMsg);
          end;
        end;
      CM_TAKEOFFSPIRITITEM: begin //从灵媒位脱下物品
          if g_Config.boUseCanKamPo then begin
            ClientTakeOffSpiritItems(ProcessMsg.nParam1, ProcessMsg.sMsg);
          end;
        end;
      CM_USERJUDGE: begin //客户端品评
          if (GetTickCount - m_dwUserTick[1] >= 400) and (g_Config.boUseCanKamPo) then begin
            m_dwUserTick[1] := GetTickCount;
            ClientJudgeItems(ProcessMsg.nParam1, ProcessMsg.sMsg);
          end;
        end;
      RM_OPENDJUDGE: begin //打开品评窗口
          m_DefMsg := MakeDefaultMsg(SM_OPENDJUDGE, ProcessMsg.nParam1, ProcessMsg.nParam2, 0, 0, 0);
          SendSocket(@m_DefMsg, '');
        end;
      CM_USERFINDJEWEL: begin //使用灵媒搜索宝物
          if (GetTickCount - m_dwUserTick[1] >= 400) and (g_Config.boUseCanKamPo) then begin
            m_dwUserTick[1] := GetTickCount;
            ClientFindJewelItems(ProcessMsg.nParam1, ProcessMsg.sMsg);
          end;
        end;
      CM_USERDIGJEWELITME: begin //客户端挖宝
          if (GetTickCount - m_dwUserTick[1] >= 300) and (g_Config.boUseCanKamPo) then begin
            m_dwUserTick[1] := GetTickCount;
            ClientDigJewelItems(ProcessMsg.nParam1 {x}, ProcessMsg.nParam2 {y});
          end;
        end;
{$IFEND}
  //------------------------------------------------------------------------------
      //////////////////////////////////////拍卖//////////////////////////////////////
      RM_SENDSELLOFFGOODSLIST: begin //  拍卖
          nCode := 242;
          SendDefMessage(SM_SENDSELLOFFGOODSLIST, ProcessMsg.nParam1, ProcessMsg.nParam2,
            ProcessMsg.nParam3, 0, ProcessMsg.sMsg);
        end;
      RM_SENDUSERSELLOFFITEM: begin
          nCode := 243;
          SendDefMessage(SM_SENDUSERSELLOFFITEM, ProcessMsg.nParam1, ProcessMsg.nParam2, 0, 0, ProcessMsg.sMsg);
        end;

      RM_SENDUSERSELLOFFITEM_OK: begin
          nCode := 244;
          SendDefMessage(SM_SENDUSERSELLOFFITEM_OK, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0, '');
        end;
      RM_SENDUSERSELLOFFITEM_FAIL: begin
          nCode := 245;
          SendDefMessage(SM_SENDUSERSELLOFFITEM_FAIL,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            0, '');
        end;
      RM_SENDSELLOFFITEMLIST: begin
          nCode := 246;
          SendDefMessage(CM_SENDSELLOFFITEMLIST,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3, 0,
            ProcessMsg.sMsg);
        end;

      RM_SENDBUYSELLOFFITEM_OK: begin //购买拍卖物品成功
          nCode := 247;
          SendDefMessage(SM_SENDBUYSELLOFFITEM_OK,
            ProcessMsg.nParam1,
            LoWord(ProcessMsg.nParam2),
            HiWord(ProcessMsg.nParam2), 0, '');
        end;
      RM_SENDBUYSELLOFFITEM_FAIL: begin //购买拍卖物品失败
          nCode := 248;
          SendDefMessage(SM_SENDBUYSELLOFFITEM_FAIL, ProcessMsg.nParam1, 0, 0, 0, '');
        end;
      RM_HIDESIGHICON: begin //隐藏感叹号图标 20090126
          nCode := 249;
          SendDefMessage(SM_HIDESIGHICON, 0, 0, 0, 0, '');
        end;
      RM_OPENEXPCRYSTAL: begin //显示、隐藏天地结晶图标 20090201
          nCode := 250;
          SendDefMessage(SM_OPENEXPCRYSTAL, ProcessMsg.nParam1, ProcessMsg.nParam2, 0, 0, '');
        end;
      RM_OPENCATTLEGAS: begin //显示、隐藏牛气管图标 20090518
          SendDefMessage(SM_OPENCATTLEGAS, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0, '');
        end;
      RM_SHOWSHINY: begin //在客户端让“成长任务”按键发亮 20100801
          SendDefMessage(SM_SHOWSHINY, 0, 0, 0, 0, '');
        end;
  //----------------------------连击系统------------------------------------------
      CM_ITEMSPLIT: begin //客户端拆分物品 20090615
          if GetTickCount - m_dwUserTick[5] >= 300 then begin //20090816 增加
            m_dwUserTick[5] := GetTickCount;
            if ProcessMsg.nParam3 = 0 then begin
              ClientItemSplit(ProcessMsg.nParam1 {制造ID}, ProcessMsg.nParam2 {拆分数量});
            end else begin
              if m_MyHero <> nil then begin
                THeroObject(m_MyHero).ClientHeroItemSplit(ProcessMsg.nParam1 {制造ID}, ProcessMsg.nParam2 {拆分数量});
              end;
            end;
          end;
        end;
      CM_ITEMMERGER: begin //客户端合并物品 20090615
          if GetTickCount - m_dwUserTick[5] >= 300 then begin //20090816 增加
            m_dwUserTick[5] := GetTickCount;
            if ProcessMsg.nParam3 = 0 then begin
              ClientItemMerger(ProcessMsg.nParam1 {需要合并的物品制造ID}, ProcessMsg.sMsg {合并到的物品});
            end else begin
              if m_MyHero <> nil then begin
                THeroObject(m_MyHero).ClientHeroItemMerger(ProcessMsg.nParam1 {需要合并的物品制造ID}, ProcessMsg.sMsg {合并到的物品});
              end;
            end;
          end;
        end;
      RM_OPENMAKEKIMNEEDLE: begin //客户端显示锻练金针窗口 20090615
          SendDefMessage(SM_OPENMAKEKIMNEEDLE, 0, 0, 0, 0, '');
        end;
      CM_EXERCISEKIMNEEDLE: begin //客户端开始练针 20090620
          ClientExerciseKimNeedle(ProcessMsg.nParam1 {第一个金针的制造ID}, ProcessMsg.sMsg {其他物品制造ID});
        end;
{$IF M2Version = 1}
      RM_OPENLIANQI: begin //NPC打开炼气窗口
          nCode := 58;
          m_DefMsg := MakeDefaultMsg(SM_OPENLIANQI,
            ProcessMsg.nParam1 {强化所需灵符数},
            ProcessMsg.nParam2 {当前精元值},
            ProcessMsg.nParam3 {精元值上限},
            ProcessMsg.wParam {类型0-普通 1-强化}, g_Config.nLianqiGold {练气所需金币数});
          SendSocket(@m_DefMsg, '');
        end;
      CM_OPENPULSEPOINT: begin //客户端点击穴位 20090621
          if GetTickCount - m_dwUserTick[6] >= 300 then begin
            m_dwUserTick[6] := GetTickCount;
            ClientOpenPulsePoint(ProcessMsg.nParam1 {经络页}, ProcessMsg.nParam2 {穴位});
          end;
        end;
      CM_CLICKBATTERNPC: begin //messagebox命令发送后，客户端点击“确定”后，进入连击NPC执行触发 20090623
          if GetTickCount - m_dwUserTick[6] >= 300 then begin
            m_dwUserTick[6] := GetTickCount;
            ClientBatterNPCGoto(ProcessMsg.sMsg); //跳转到BatterNPC脚本段
          end;
        end;
      CM_SKILLTOJINGQING: begin //修炼奇经
          if GetTickCount - m_dwUserTick[6] >= 300 then begin
            m_dwUserTick[6] := GetTickCount;
            if ProcessMsg.nParam3 = 0 then begin
              ClientUserSkillToJingQing(ProcessMsg.nParam2 {页}, ProcessMsg.nParam1 {制造ID});
            end else begin
              if m_MyHero <> nil then begin
                THeroObject(m_MyHero).ClientHeroSkillToJingQing(ProcessMsg.nParam2, ProcessMsg.nParam1);
              end;
            end;
          end;
        end;
      RM_SKILLTOJINGQING_OK: begin //修炼奇经成功
          SendDefMessage(SM_SKILLTOJINGQING_OK, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0, '');
        end;
      RM_SKILLTOJINGQING_FAIL: begin //修炼奇经失败
          SendDefMessage(SM_SKILLTOJINGQING_FAIL, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0, '');
        end;
      RM_LIANQIPRACTICE: begin
          SendDefMessage(SM_LIANQIPRACTICE, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0, '');
        end;
      RM_SENDJINGYUANVALUE: begin //更新人物精元值
          m_DefMsg := MakeDefaultMsg(SM_SENDJINGYUANVALUE,
            m_JingYuanValue, //当前精元值
            g_Config.nJingYuanValue, //精元值上限
            ProcessMsg.nParam1, //点数
            0, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_SENDUSERPULSEARR: begin //登陆时发送各经络的数据
          if ProcessMsg.wParam = 0 then
            m_DefMsg := MakeDefaultMsg(SM_SENDUSERPULSEARR, 0, 0, 0, 0, 0)
          else m_DefMsg := MakeDefaultMsg(SM_SENDHEROPULSEARR, 0, 0, 0, 0, ProcessMsg.nParam1 {英雄当前经络经验});
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      CM_PRACTICEPULSE: begin //客户端修炼经络 20090623
          if GetTickCount - m_dwUserTick[6] >= 300 then begin
            m_dwUserTick[6] := GetTickCount;
            ClientPracticePulse(ProcessMsg.nParam1 {经络页});
          end;
        end;
      CM_HEROPRACTICEPULSE: begin //客户端英雄修炼经络 20090911
          if GetTickCount - m_dwUserTick[6] >= 300 then begin
            m_dwUserTick[6] := GetTickCount;
            ClientHeroPracticePulse(ProcessMsg.nParam1 {经络页});
          end;
        end;
      RM_SENDUSERPULSESHINY: begin //待打通的穴位发亮 20090624
          if ProcessMsg.wParam = 0 then SendDefMessage(SM_SENDUSERPULSESHINY, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0, '')
          else SendDefMessage(SM_SENDHEROPULSESHINY, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0, '');
        end;
      CM_USEBATTERSPELL: begin //客户端使用连击 20090624
          ClientUseBatterSpell(TBaseObject(ProcessMsg.nParam1), ProcessMsg.nParam3 {X}, ProcessMsg.nParam2 {Y}, ProcessMsg.sMsg);
        end;
      RM_SENDCANUSEBATTER: begin //发送可使用连击的通知
          SendDefMessage(SM_SENDCANUSEBATTER, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0, '');
        end;
      RM_BATTEROVER: begin //道法连击结束
          SendDefMessage(SM_BATTEROVER, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0, '');
        end;
      RM_OPEN4BATTERSKILL: begin //开启第四连击技能 20100720
          SendDefMessage(SM_OPEN4BATTERSKILL, ProcessMsg.nParam1 {0-主体开启，1-英雄开启}, ProcessMsg.nParam2, ProcessMsg.nParam3, 0, '');
        end;
{$IFEND}
      RM_OpenKampoDlgNew: begin //打开新鉴定窗口
          nCode := 251;
          //nRecog, nParam, nTag, nSeries
          SendDefMessage(SM_OpenKampoDlgNew, g_Config.dwNewKamPoLockNeed1, g_Config.dwNewKamPoLockNeed2, g_Config.dwNewKamPoNeed1, g_Config.dwNewKamPoNeed2, '');
        end;
      RM_SENDNGRESUME: begin //内功恢复速度值，伤害值，防御值 20090812
          SendDefMessage1(SM_SENDNGRESUME, ProcessMsg.nParam2 {伤害值}, ProcessMsg.wParam, ProcessMsg.nParam1, 0, ProcessMsg.nParam3 {恢复速度}, '');
        end;
      //////////////////////////////////////拍卖//////////////////////////////////////
  //---------------------------元宝寄售系统---------------------------------------
      RM_SENDDEALOFFFORM: begin //打开出售物品窗口 20080316
          nCode := 251;
          SendDefMessage(SM_SENDDEALOFFFORM, ProcessMsg.nParam1, ProcessMsg.nParam2, 0, 0, ProcessMsg.sMsg);
        end;

      RM_QUERYYBSELL: begin //查询正在出售的物品 20080316
          nCode := 252;
          m_DefMsg := MakeDefaultMsg(SM_QUERYYBSELL, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_QUERYYBDEAL: begin //查询可以的购买物品 20080316
          nCode := 253;
          m_DefMsg := MakeDefaultMsg(SM_QUERYYBDEAL, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.wParam, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
  //------------------------------------------------------------------------------
      RM_GOLDCHANGED: begin //10136
          nCode := 254;
          SendDefMessage(SM_GOLDCHANGED, m_nGold, LoWord(m_nGameGold), HiWord(m_nGameGold), 0, '');
        end;
      RM_GOLDGAMEGIRDCHANGED: begin //更新客户端金币及灵符
          SendDefMessage(SM_GOLDGAMEGIRDCHANGED, m_nGold, LoWord(m_nGameGird), HiWord(m_nGameGird), 0, '');
        end;
      RM_GAMEGOLDCHANGED: begin
          nCode := 255;
          SendGoldInfo(False);
        end;
      RM_CHANGELIGHT: begin //10137
          nCode := 256;
          if TBaseObject(ProcessMsg.BaseObject) <> nil then begin //20090520 增加
            if not TBaseObject(ProcessMsg.BaseObject).m_boDeath then begin //20090710 增加
              SendDefMessage(SM_CHANGELIGHT, Integer(ProcessMsg.BaseObject),
                TBaseObject(ProcessMsg.BaseObject).m_nLight, g_Config.nClientKey, 0, '');
            end;
          end;
        end;
      RM_LAMPCHANGEDURA: begin //10138
          nCode := 257;
          SendDefMessage(SM_LAMPCHANGEDURA, ProcessMsg.nParam1, 0, 0, 0, '');
        end;
      RM_CHARSTATUSCHANGED: begin //10139
          nCode := 258;
          SendDefMessage1(SM_CHARSTATUSCHANGED,
            Integer(ProcessMsg.BaseObject),
            LoWord(ProcessMsg.nParam1),
            HiWord(ProcessMsg.nParam1),
            ProcessMsg.wParam,
            ProcessMsg.nParam2 {移动速度},
            ProcessMsg.sMsg);
        end;
      RM_GROUPCANCEL: begin //10140
          nCode := 259;
          SendDefMessage(SM_GROUPCANCEL, ProcessMsg.nParam1, 0, 0, 0, '');
        end;
      RM_SENDUSERREPAIR,
        RM_SENDUSERSREPAIR: begin //10141
          nCode := 260;
          SendDefMessage(SM_SENDUSERREPAIR, ProcessMsg.nParam1, ProcessMsg.nParam2, 0, 0, '');
        end;
      RM_SENDUSERARMSTEAR: begin //武器拆卸赤炎石 20100708
          SendDefMessage(SM_SENDUSERARMSTEAR, ProcessMsg.nParam1, ProcessMsg.nParam2, 0, 0, '');
        end;
      RM_SENDUSERARMSEXCHANGE: begin //武器兑换卷轴碎片 20100809
          SendDefMessage(SM_SENDUSERARMSEXCHANGE, ProcessMsg.nParam1, ProcessMsg.nParam2, 0, 0, '');
        end;
      RM_USERREPAIRITEM_OK: begin //10143
          nCode := 261;
          SendDefMessage(SM_USERREPAIRITEM_OK, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0, '');
        end;
      RM_SENDREPAIRCOST: begin //10142
          nCode := 262;
          SendDefMessage(SM_SENDREPAIRCOST, ProcessMsg.nParam1, 0, 0, 0, '');
        end;
      RM_USERREPAIRITEM_FAIL: begin //10144
          nCode := 263;
          SendDefMessage(SM_USERREPAIRITEM_FAIL, ProcessMsg.nParam1, 0, 0, 0, '');
        end;
      RM_USERARMSTEAR_OK: begin //拆分物品成功 20100708
          SendDefMessage(SM_USERARMSTEAR_OK, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0, '');
        end;
      RM_USERARMSTEAR_FAIL: begin //拆分物品失败 20100708
          SendDefMessage(SM_USERARMSTEAR_FAIL, ProcessMsg.nParam1, ProcessMsg.nParam2, 0, 0, '');
        end;
      RM_USERSTORAGEITEM: begin //10146
          nCode := 264;
          SendDefMessage(SM_SENDUSERSTORAGEITEM, ProcessMsg.nParam1, ProcessMsg.nParam2, 0, 0, '');
        end;
      RM_USERGETBACKITEM: begin //10147
          nCode := 265;
          SendSaveItemList(ProcessMsg.nParam1);
        end;
      RM_USERBIGGETBACKITEM: begin //发送无限仓库物品
          nCode := 266;
          SendSaveBigStorageItemList(ProcessMsg.nParam1, ProcessMsg.wParam);
        end;
      RM_SENDDELITEMLIST: begin //10148 SM_DELITEMS
          nCode := 267;
          if ProcessMsg.BaseObject = m_MyHero then begin
            THeroObject(m_MyHero).SendDelItemList(TStringList(ProcessMsg.nParam1));
          end else begin
            SendDelItemList(TStringList(ProcessMsg.nParam1));
          end;
          try//增加保护By TasNat at: 2012-10-17 11:08:21
            TStringList(ProcessMsg.nParam1).Free;
          except

          end;
        end;
      RM_USERMAKEDRUGITEMLIST: begin //10149
          nCode := 268;
          SendDefMessage(SM_SENDUSERMAKEDRUGITEMLIST, ProcessMsg.nParam1, ProcessMsg.nParam2, 0, 0, ProcessMsg.sMsg);
        end;
      RM_MAKEDRUG_SUCCESS: begin //10150
          nCode := 269;
          SendDefMessage(SM_MAKEDRUG_SUCCESS, ProcessMsg.nParam1, 0, 0, 0, '');
        end;
      RM_MAKEDRUG_FAIL: begin //10151
          nCode := 270;
          SendDefMessage(SM_MAKEDRUG_FAIL, ProcessMsg.nParam1, 0, 0, 0, '');
        end;
      RM_ALIVE: begin
          nCode := 271;
          m_DefMsg := MakeDefaultMsg(SM_ALIVE,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam, 0);
          m_DefMsg.nSessionID := TBaseObject(ProcessMsg.BaseObject).GetFeature(CharDesc.feature);
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          CharDesc.MonShowName := TBaseObject(ProcessMsg.BaseObject).m_btRaceServer; //20110713 宠物显名用
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc) - SizeOf(TFeatures) + m_DefMsg.nSessionID));
        end;
      RM_DIGUP: begin //10200
          nCode := 272;
          m_DefMsg := MakeDefaultMsg(SM_DIGUP,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight), 0);

          m_DefMsg.nSessionID := TBaseObject(ProcessMsg.BaseObject).GetFeature(MessageBodyWL.feature);
          MessageBodyWL.lParam1 := 0;
          MessageBodyWL.lParam2 := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          MessageBodyWL.lTag1 := ProcessMsg.nParam3;
          MessageBodyWL.lTag1 := 0;
          MessageBodyWL.MonShowName := TBaseObject(ProcessMsg.BaseObject).m_btRaceServer; //20110713 宠物显名用
          s1C := EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)- SizeOf(TFeatures) + m_DefMsg.nSessionID);
          SendSocket(@m_DefMsg, s1C);
        end;
      RM_DIGDOWN: begin //10201
          nCode := 273;
          m_DefMsg := MakeDefaultMsg(SM_DIGDOWN,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            0, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_FLYAXE: begin //10202
          nCode := 274;
          if TBaseObject(ProcessMsg.nParam3) <> nil then begin
            MessageBodyW.Param1 := TBaseObject(ProcessMsg.nParam3).m_nCurrX;
            MessageBodyW.Param2 := TBaseObject(ProcessMsg.nParam3).m_nCurrY;
            MessageBodyW.Tag1 := LoWord(ProcessMsg.nParam3);
            MessageBodyW.Tag2 := HiWord(ProcessMsg.nParam3);
            m_DefMsg := MakeDefaultMsg(SM_FLYAXE,
              Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              ProcessMsg.wParam, 0);
            SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyW, SizeOf(TMessageBodyW)));
          end;
        end;
      RM_LIGHTING: begin //10204
          nCode := 275;
          if TBaseObject(ProcessMsg.nParam3) <> nil then begin
            MessageBodyWL2.lParam1 := TBaseObject(ProcessMsg.nParam3).m_nCurrX;
            MessageBodyWL2.lParam2 := TBaseObject(ProcessMsg.nParam3).m_nCurrY;
            MessageBodyWL2.lTag1 := ProcessMsg.nParam3;
            MessageBodyWL2.lTag2 := ProcessMsg.wParam;
            nCode := 276;
            m_DefMsg := MakeDefaultMsg(SM_LIGHTING,
              Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              TBaseObject(ProcessMsg.BaseObject).m_btDirection, 0);
            nCode := 277;
            SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL2, SizeOf(TMessageBodyWL2)));
          end;
        end;
      RM_FAIRYATTACKRATE: begin //10204  月灵重击 2007.12.13
          nCode := 278;
          if TBaseObject(ProcessMsg.nParam3) <> nil then begin
            MessageBodyWL2.lParam1 := TBaseObject(ProcessMsg.nParam3).m_nCurrX;
            MessageBodyWL2.lParam2 := TBaseObject(ProcessMsg.nParam3).m_nCurrY;
            MessageBodyWL2.lTag1 := ProcessMsg.nParam3;
            MessageBodyWL2.lTag2 := ProcessMsg.wParam;
            m_DefMsg := MakeDefaultMsg(SM_FAIRYATTACKRATE,
              Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              TBaseObject(ProcessMsg.BaseObject).m_btDirection, 0);
            SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL2, SizeOf(TMessageBodyWL2)));
          end;
        end;
      RM_ARMSCRIT: begin //暴击飘血效果 20100710
          SendDefMessage1(SM_ARMSCRIT,
            Integer(ProcessMsg.BaseObject),
            0,
            0,
            0,
            ProcessMsg.nParam3 {点数}, '');
        end;
      RM_10205: begin //10205
          nCode := 279;
          SendDefMessage1(SM_716,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1 {x},
            ProcessMsg.nParam2 {y},
            ProcessMsg.wParam {type},
            ProcessMsg.nParam3 {目标ID}, '');
        end;
      RM_CHANGEGUILDNAME: begin //10301  SM_CHANGEGUILDNAME
          nCode := 280;
          SendChangeGuildName();
        end;
      RM_SUBABILITY: begin //10302
          nCode := 281;
          {SendDefMessage(SM_SUBABILITY,//20110712 修改
            MakeLong(MakeWord(m_nAntiMagic, 0), 0),
            MakeWord(m_btHitPoint, m_btSpeedPoint),
            MakeWord(m_btAntiPoison, m_nPoisonRecover),
            MakeWord(m_nHealthRecover, m_nSpellRecover), ''); }

          if TBaseObject(ProcessMsg.BaseObject) <> nil then begin
            m_DefMsg := MakeDefaultMsg(SM_SUBABILITY,
              MakeLong(MakeWord(m_nAntiMagic, 0), 0),
              MakeWord(m_btHitPoint, m_btSpeedPoint),
              MakeWord(m_btAntiPoison, m_nPoisonRecover),
              MakeWord(m_nHealthRecover, m_nSpellRecover), 0);
            case TBaseObject(ProcessMsg.BaseObject).m_btRaceServer of // ProcessMsg.BaseObject
              RC_PLAYOBJECT: SendSocket(@m_DefMsg, EncodeBuffer(@TPlayObject(ProcessMsg.BaseObject).ClientSuitAbility, SizeOf(TClientSuitAbility)) {套装属性值});
              RC_HEROOBJECT: SendSocket(@m_DefMsg, EncodeBuffer(@THeroObject(ProcessMsg.BaseObject).ClientSuitAbility, SizeOf(TClientSuitAbility)) {套装属性值});
            else SendSocket(@m_DefMsg, '');
            end;
          end;
        end;
      RM_BUILDGUILD_OK: begin //10303
          nCode := 282;
          SendDefMessage(SM_BUILDGUILD_OK, 0, 0, 0, 0, '');
        end;
      RM_BUILDGUILD_FAIL: begin //10304
          nCode := 283;
          SendDefMessage(SM_BUILDGUILD_FAIL, ProcessMsg.nParam1, 0, 0, 0, '');
        end;
      RM_DONATE_OK: begin //10305
          nCode := 284;
          SendDefMessage(SM_DONATE_OK, ProcessMsg.nParam1, 0, 0, 0, '');
        end;
      RM_DONATE_FAIL: begin //10306
          nCode := 285;
          SendDefMessage(SM_DONATE_FAIL, ProcessMsg.nParam1, 0, 0, 0, '');
        end;
      RM_MYSTATUS: begin
          nCode := 286;
          SendDefMessage(SM_MYSTATUS, 0, GetMyStatus, 0, 0, '');
        end;
      RM_MENU_OK: begin //10309
          nCode := 287;
          SendDefMessage(SM_MENU_OK, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0, ProcessMsg.sMsg);
        end;
      RM_SPACEMOVE_FIRE,
        RM_SPACEMOVE_FIRE2: begin //10330
          nCode := 288;
          if ProcessMsg.wIdent = RM_SPACEMOVE_FIRE then begin
            m_DefMsg := MakeDefaultMsg(SM_SPACEMOVE_HIDE, Integer(ProcessMsg.BaseObject), 0, 0, 0, 0);
          end else begin
            m_DefMsg := MakeDefaultMsg(SM_SPACEMOVE_HIDE2, Integer(ProcessMsg.BaseObject), 0, 0, 0, 0);
          end;
          SendSocket(@m_DefMsg, '');
        end;

      RM_SPACEMOVE_SHOW,
        RM_SPACEMOVE_SHOW2: begin
          nCode := 289;
          if ProcessMsg.wIdent = RM_SPACEMOVE_SHOW then begin
            m_DefMsg := MakeDefaultMsg(SM_SPACEMOVE_SHOW,
              Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight), 0);
          end else begin
            m_DefMsg := MakeDefaultMsg(SM_SPACEMOVE_SHOW2,
              Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight), 0);
          end;
          m_DefMsg.nSessionID := TBaseObject(ProcessMsg.BaseObject).GetFeature(CharDesc.feature);
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          CharDesc.MonShowName := TBaseObject(ProcessMsg.BaseObject).m_btRaceServer; //20110713 宠物显名用
          s1C := EncodeBuffer(@CharDesc, SizeOf(TCharDesc) - SizeOf(TFeatures) + m_DefMsg.nSessionID);


          nObjCount := GetCharColor(TBaseObject(ProcessMsg.BaseObject));
          if ProcessMsg.sMsg <> '' then begin
            s1C := s1C + EncodeString(ProcessMsg.sMsg + '/' + IntToStr(nObjCount));
          end;
          SendSocket(@m_DefMsg, s1C);
        end;
      RM_SPACEMOVE_SHOW3: begin
          m_DefMsg := MakeDefaultMsg(SM_SPACEMOVE_SHOW3,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight), 0);
          m_DefMsg.nSessionID := TBaseObject(ProcessMsg.BaseObject).GetFeature(CharDesc.feature);
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          CharDesc.MonShowName := TBaseObject(ProcessMsg.BaseObject).m_btRaceServer; //20110713 宠物显名用
          s1C := EncodeBuffer(@CharDesc, SizeOf(TCharDesc) - SizeOf(TFeatures) + m_DefMsg.nSessionID);
          nObjCount := GetCharColor(TBaseObject(ProcessMsg.BaseObject));
          if ProcessMsg.sMsg <> '' then begin
            s1C := s1C + EncodeString(ProcessMsg.sMsg + '/' + IntToStr(nObjCount));
          end;
          SendSocket(@m_DefMsg, s1C);
        end;
      RM_RECONNECTION: begin //10332 重新连接
          nCode := 290;
          m_boReconnection := True;
          SendDefMessage(SM_RECONNECT, 0, 0, 0, 0, ProcessMsg.sMsg);
        end;
      RM_HIDEEVENT: begin //10333
          nCode := 291;
          SendDefMessage(SM_HIDEEVENT,
            ProcessMsg.nParam1,
            ProcessMsg.wParam,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3, '');
        end;
      RM_SHOWEVENT: begin //10334
          nCode := 292;
          ShortMessage.Ident := HiWord(ProcessMsg.nParam2);
          ShortMessage.wMsg := 0;
          m_DefMsg := MakeDefaultMsg(SM_SHOWEVENT,
            ProcessMsg.nParam1,
            ProcessMsg.wParam,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3, 0);
          SendSocket(@m_DefMsg, EncodeBuffer(@ShortMessage, SizeOf(TShortMessage)));
        end;
      RM_MYSHOW: begin //自身动画消息 20080113
          nCode := 293;
          m_DefMsg := MakeDefaultMsg(SM_MYSHOW, Integer(ProcessMsg.BaseObject), ProcessMsg.wParam, ProcessMsg.nParam2, ProcessMsg.nParam3, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_ADJUST_BONUS: begin
          nCode := 294;
          SendAdjustBonus();
        end;
      RM_10401: begin
          nCode := 295;
          ChangeServerMakeSlave(pTSlaveInfo(ProcessMsg.nParam1));
          Dispose(pTSlaveInfo(ProcessMsg.nParam1));
        end;
      RM_OPENHEALTH: begin //10410
          nCode := 296;
          {SendDefMessage(SM_OPENHEALTH,
            Integer(ProcessMsg.BaseObject),
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP, 0,'');}
          SendDefMessage1(SM_OPENHEALTH, //20091026 修改
            Integer(ProcessMsg.BaseObject),
            LoWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),
            HiWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),
            0, TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP, '');
        end;
      RM_CLOSEHEALTH: begin //10411
          nCode := 297;
          SendDefMessage(SM_CLOSEHEALTH, Integer(ProcessMsg.BaseObject), 0, 0, 0, '');
        end;
      RM_BREAKWEAPON: begin //10413
          nCode := 298;
          SendDefMessage(SM_BREAKWEAPON, Integer(ProcessMsg.BaseObject), 0, 0, 0, '');
        end;
      RM_10414: begin //10414
          nCode := 299;
          {SendDefMessage(SM_INSTANCEHEALGUAGE,
            Integer(ProcessMsg.BaseObject),
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP, 0,'');}
          SendDefMessage1(SM_INSTANCEHEALGUAGE, //20091026 修改
            Integer(ProcessMsg.BaseObject),
            LoWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),
            HiWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),
            0, TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP, '');
        end;
      RM_CHANGEFACE: begin
          nCode := 300;
          {if Assigned(zPlugOfEngine.SendChangeFaceMsg) then begin //20080813 注释
            zPlugOfEngine.SendChangeFaceMsg(Self,
              ProcessMsg.BaseObject,
              TBaseObject(ProcessMsg.nParam2),
              ProcessMsg.nParam1);
          end else begin }
          if (ProcessMsg.nParam1 <> 0) and (ProcessMsg.nParam2 <> 0) then begin
            m_DefMsg := MakeDefaultMsg(SM_CHANGEFACE,
              ProcessMsg.nParam1,
              LoWord(ProcessMsg.nParam2),
              HiWord(ProcessMsg.nParam2), 0, 0);
            m_DefMsg.nSessionID := TBaseObject(ProcessMsg.BaseObject).GetFeature(CharDesc.feature);
            CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
            CharDesc.MonShowName := TBaseObject(ProcessMsg.BaseObject).m_btRaceServer; //20110713 宠物显名用


            SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc) - SizeOf(TFeatures) + m_DefMsg.nSessionID));
          end;
          //end;//20080813 注释
        end;
      RM_PASSWORD: begin //10416
          nCode := 301;
          SendDefMessage(SM_PASSWORD, 0, 0, 0, 0, '');
        end;
      RM_PLAYDICE: begin //10500 //转骰子
          nCode := 302;
          MessageBodyWL2.lParam1 := ProcessMsg.nParam1;
          MessageBodyWL2.lParam2 := ProcessMsg.nParam2;
          MessageBodyWL2.lTag1 := ProcessMsg.nParam3;
          m_DefMsg := MakeDefaultMsg(SM_PLAYDICE, Integer(ProcessMsg.BaseObject), ProcessMsg.wParam, 0, 0, 0);
          SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL2, SizeOf(TMessageBodyWL2)) + EncodeString(ProcessMsg.sMsg));
        end;
      RM_PASSWORDSTATUS: begin
          nCode := 303;
          m_DefMsg := MakeDefaultMsg(SM_PASSWORDSTATUS,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
  //----------------------个人商店----------------------------------------------
      CM_SELFSHOPITEMS: begin //开启个人商店
          ClientGetShopItems(ProcessMsg.sMsg);
        end;
      CM_SELFCLOSESHOP: begin //收摊
          ClientGetCloseShop();
        end;
      CM_CLICKSHOP: begin //别人查看个人商店物品
          ClientClickPlay(TPlayObject(ProcessMsg.nParam1), ProcessMsg.nParam2, ProcessMsg.nParam3);
        end;
      CM_SELFSHOPBUY: begin //购买摆摊物品
          ClientBuySelfShopItem(TPlayObject(ProcessMsg.nParam1), ProcessMsg.wParam, ProcessMsg.nParam3, ProcessMsg.sMsg);
        end;
      RM_ISSHOP: begin
          if ProcessMsg.BaseObject <> Self then
            SendDefMessage(SM_ISSHOP, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, 0, 0, ProcessMsg.sMsg);
        end;
      RM_SELFSHOPLIST: ClientGetShopList; //人物登陆，发送个人商店列表
  //-----------------------------------------------------------------------------
      RM_USERLEVELORDER: begin //人物排行
          nCode := 304;
          UserLevelOrder(ProcessMsg.BaseObject);
        end;
      RM_QUERYUSERLEVELSORT: begin
          nCode := 305;
          m_DefMsg := MakeDefaultMsg(SM_QUERYUSERLEVELSORT,
            ProcessMsg.nParam1,
            ProcessMsg.wParam,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_GLORY: begin //发送到客户端 荣誉值 20080511
          nCode := 306;
          SendGloryInfo;
        end;
  //---------------------酒馆系统-------------------------------------------------
      RM_ASSESSMENTHEROINFO: begin //发送评定英雄数据
          nCode := 314;
          m_DefMsg := MakeDefaultMsg(SM_ASSESSMENTHEROINFO, ProcessMsg.nParam1, ProcessMsg.wParam, ProcessMsg.nParam2, ProcessMsg.nParam3, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_GETHEROINFO: begin //客户端取得酒馆英雄存储信息 20080515
          nCode := 307;
          m_DefMsg := MakeDefaultMsg(SM_GETHEROINFO,
            ProcessMsg.nParam1,
            ProcessMsg.wParam,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_SENDUSERPLAYDRINK: begin //发送出现请酒对话框 20080515
          nCode := 308;
          m_DefMsg := MakeDefaultMsg(SM_SENDUSERPLAYDRINK,
            ProcessMsg.nParam1,
            ProcessMsg.wParam,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_OPENPLAYDRINK: begin //打开界面
          nCode := 309;
          m_DefMsg := MakeDefaultMsg(SM_OPENPLAYDRINK,
            ProcessMsg.nParam1,
            ProcessMsg.wParam,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_PlayDrinkToDrink: begin //送到客户端谁赢谁输
          nCode := 310;
          m_DefMsg := MakeDefaultMsg(SM_PlayDrinkToDrink,
            ProcessMsg.nParam1,
            ProcessMsg.wParam,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_DrinkUpdateValue: begin
          nCode := 311;
          m_DefMsg := MakeDefaultMsg(SM_DrinkUpdateValue,
            ProcessMsg.nParam1,
            ProcessMsg.wParam,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_CLOSEDRINK: begin
          nCode := 312;
          m_DefMsg := MakeDefaultMsg(SM_CLOSEDRINK,
            ProcessMsg.nParam1,
            ProcessMsg.wParam,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3, 0);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
  //------------------------------------------------------------------------------
    else begin
        nCode := 313;
        Result := inherited Operate(ProcessMsg);
      end;
    end; //case
  except
    if ProcessMsg <> nil then with ProcessMsg^ do
      MainOutMessage(Format('{%s} EOP.12756.Code:%d.%p::[%d.%d.%d.%d.%d]', [g_sExceptionVer, nCode, ExceptAddr, wIdent,wParam,nParam1,nParam2,nParam3]))
    else
      MainOutMessage(Format('{%s} TPlayObject.Operate Code:%d.%p', [g_sExceptionVer, nCode, ExceptAddr]));
  end;
  //inherited;
end;

procedure TPlayObject.Run();
var
  tObjCount, nInteger: Integer;
  wHour, wMin, wSec, wMSec: Word;
  ProcessMsg: TProcessMessage;
  boInSafeArea, boTakeItem: Boolean;
  btInSafeArea : Byte;
  I, n18, nX: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  PlayObject, PushedObject: TPlayObject;
  BaseObject: TBaseObject;
  Castle: TUserCastle;
  PlayObjectList: TList;
  SC, s01, sTemp, s02: string;
  dwStationTick, dwC: LongWord;
  OnTimer: pTOnTimer;
  nCode, OnIdx: Byte;
  boNoGold: Boolean;
  //n_mLevelOrder: Integer;
  //ThunderAndLavaEvent: TThunderAndLavaEvent;//20090505
resourcestring
  sPayMentExpire = '您的帐户充值时间已到期！';
  sDisConnectMsg = '游戏被强行中断！';
  sExceptionMsg1 = '{%s} TPlayObject::Run -> Operate 1 Code:%d.%p';
  sExceptionMsg2 = '{%s} TPlayObject::Run -> Operate 2 # %s Ident:%d Code:%d.%p';
  sExceptionMsg3 = '{%s} TPlayObject::Run -> GetHighHuman Code:%d.%p';
  sExceptionMsg4 = '{%s} TPlayObject::Run -> ClearObj %p';
begin
  nCode := 0;
  try
    if g_boExitServer then begin
      m_boEmergencyClose := True;
      m_boPlayOffLine := False;
      m_boNotOnlineAddExp := False;
      m_boStartAutoAddExpPoint := False;
    end;
  except
  end;

  try
    btInSafeArea := 0;//未定义
    nCode := 202;
{$IF M2Version <> 2}
    if (not m_PEnvir.m_boFight4Zone) then PlaySuperRock; //气血石 魔血石,挑战地图不能使用
    nCode := 203;
{$IFEND}
    if (GetTickCount - m_dwVerifyTick) > 30000 then begin
      m_dwVerifyTick := GetTickCount();
      // 清组队已死亡成员
      if m_btRaceServer = RC_PLAYOBJECT then begin
        if (m_GroupOwner <> nil) then begin
          if m_GroupOwner.m_boDeath or m_GroupOwner.m_boGhost then m_GroupOwner := nil;
        end;
        if m_GroupOwner = Self then begin
          for I := m_GroupMembers.Count - 1 downto 0 do begin
            if m_GroupMembers.Count <= 0 then Break;
            BaseObject := TBaseObject(m_GroupMembers.Objects[I]);
            if BaseObject <> nil then begin
              if BaseObject.m_boDeath or (BaseObject.m_boGhost) then m_GroupMembers.Delete(I);
            end;
          end; //for
        end;
        // 清组队已死亡成员 结束
        nCode := 204;
        // 检查交易双方 状态
        if (m_DealCreat <> nil) then begin
          if (m_DealCreat.m_boGhost) then m_DealCreat := nil;
        end;
      end;
      if (not m_boDenyRefStatus) and (m_PEnvir <> nil) then m_PEnvir.VerifyMapTime(m_nCurrX, m_nCurrY, Self); //刷新在地图上位置的时间
    end;
    nCode := 205;
    if m_boDealing then begin
      if (GetPoseCreate <> m_DealCreat) or (m_DealCreat = Self) or (m_DealCreat = nil) then DealCancel();
    end;
    nCode := 206;
    if m_boExpire then begin //账号过期
      SysMsg(sPayMentExpire, c_Red, t_Hint);
      SysMsg(sDisConnectMsg, c_Red, t_Hint);
      m_boEmergencyClose := True;
      m_boPlayOffLine := False;
      m_boNotOnlineAddExp := False;
      m_boStartAutoAddExpPoint := False;
      m_boExpire := False;
    end;

    nCode := 2;
    if (m_boNotOnlineAddExp) and (m_boStartAutoAddExpPoint) and (m_nNotOnlineAddExpPoint > 0) then begin //离线挂机人物 自动增加经验
      if (GetTickCount - m_dwAutoAddExpPointTick) >= 60000 then begin
        m_dwAutoAddExpPointTick := GetTickCount;
        GetExp(m_nNotOnlineAddExpPoint, False, 0); //20080511
      end;
      if (GetTickCount - m_dwAutoAddExpPointTimeTick) >= m_dwNotOnlineAddExpTime * 1000 then begin //挂机时间到 20080812 修改
        m_boPlayOffLine := False;
        m_boNotOnlineAddExp := False;
        m_boStartAutoAddExpPoint := False;
      end;
    end;
//------------------------------------------------------------------------------
    nCode := 3;
    if not m_boNotOnlineAddExp then begin //如果是离线挂机的，不检测
{$IF M2Version = 1}
      if m_boUseBatter and (m_btJob = 0) then begin //战使用连击后，10秒未使用，则自动关闭
        if m_boWarUseBatter and ((GetTickCount - m_dwLatestWarUseBatterTick) > 10000) then begin
          SendSocket(nil, '+UBAT');
          SysMsg('使用连击技结束', c_Red, t_Hint);
          m_boWarUseBatter := False;
          m_boUseBatter := False;
          m_nUseBatterTick := GetTickCount(); //使用连击的计时
          m_dwLatestWarUseBatterTick := GetTickCount();
          m_nBatterMagIdx1 := 0; //连击技能ID1
          m_nBatterMagIdx2 := 0; //连击技能ID2
          m_nBatterMagIdx3 := 0; //连击技能ID3
          m_nBatterMagIdx4 := 0; //连击技能ID4
        end;
      end;
{$IFEND}
      if m_boFireHitSkill and ((GetTickCount - m_dwLatestFireHitTick) > 20000) then begin //20秒关闭烈火
        m_boFireHitSkill := False;
        SysMsg(sSpiritsGone, c_Red, t_Hint);
        SendSocket(nil, '+UFIR'); //关闭烈火
      end;
      if m_boDailySkill and ((GetTickCount - m_dwLatestDailyTick) > 20000) then begin //逐日剑法 20080511
        m_boDailySkill := False;
        SysMsg(sDailySpiritsGone, c_Red, t_Hint);
        SendSocket(nil, '+UDAILY'); //关闭逐日
      end;
      if m_boBloodSoulSkill and ((GetTickCount - m_dwLatestBloodSoulTick) > 20000) then begin //血魄一击(战)
        m_boBloodSoulSkill := False;
        SysMsg(sBloodSoulSpiritsGone, c_Red, t_Hint);
        SendSocket(nil, '+UBLO'); //关闭血魄一击(战)
      end;
      if m_bo42kill and ((GetTickCount - m_dwLatest42Tick) > 20000) then begin //开天斩 20080202
        m_bo42kill := False;
        SysMsg(sSkill42Off, c_Red, t_Hint);
        case m_n42kill of //判断轻击重击  20080212
          1: SendSocket(nil, '+UQTWN'); //关闭轻开天斩
          2: SendSocket(nil, '+UTWN'); //关闭重开天斩
        end;
        m_n42kill := 0;
      end;
      if m_bo43kill and ((GetTickCount - m_dwLatest43Tick) > 20000) then begin //龙影剑法 20080619
        m_bo43kill := False;
        SysMsg(sSkill43Off, c_Red, t_Hint);
        SendSocket(nil, '+UCID'); //停止使用龙影剑法
      end;
{$IF M2Version <> 2}
      if m_boCanUerSkill101 and ((GetTickCount - m_dwUseSkillTime) > g_Config.nKill101UseLogTime * 1000) then begin //关闭神龙附体
        m_boCanUerSkill101 := False;
        SysMsg(sSkill101Off1, c_Green, t_Hint);
      end;
{$IFEND}
//---------------------饮酒酒量进度增加------------------------------------------
      nCode := 45;
      if m_Abil.WineDrinkValue > 0 then begin //醉酒度大于0时才处理
        if (GetTickCount() - m_dwAddAlcoholTick + n_DrinkWineQuality * 1000 > g_Config.nIncAlcoholTick * 1000) and (not n_DrinkWineDrunk) then begin //增加酒量进度
          m_dwAddAlcoholTick := GetTickCount();
          SendRefMsg(RM_MYSHOW, 8, 0, 0, 0, ''); //酒量增加动画  20080623
          Inc(m_Abil.Alcohol, _MAX(5, (n_DrinkWineAlcohol * m_Abil.MaxAlcohol) div 1000)); //酒度数 决定增长量
          if m_Abil.Alcohol > m_Abil.MaxAlcohol then begin //酒量升级
            m_Abil.Alcohol := m_Abil.Alcohol - m_Abil.MaxAlcohol;
            if m_Abil.MaxAlcohol + g_Config.nIncAlcoholValue > High(word) then //20090320 修改
              m_Abil.MaxAlcohol := High(word)
            else m_Abil.MaxAlcohol := m_Abil.MaxAlcohol + g_Config.nIncAlcoholValue;
            SysMsg(g_sUpAlcoholHintMsg {'您的酒量增加了'}, c_Green, t_Hint); //提示用户
            if m_Magic67Skill <> nil then begin //先天元力魔法升级
              m_Magic67Skill.nTranPoint := m_Abil.MaxAlcohol;
              if not CheckMagicLevelup(m_Magic67Skill) then begin
                SendDelayMsg(self, RM_MAGIC_LVEXP, m_Magic67Skill.MagicInfo.wMagicId, 0, m_Magic67Skill.btLevel, m_Magic67Skill.nTranPoint, '', 1000);
              end;
              if m_Abil.WineDrinkValue >= abs(m_Abil.MaxAlcohol * g_Config.nMinDrinkValue67 div 100) then begin //酒量大于或等于酒量上限的5%时才有效
                if m_Magic67Skill.btLevel > 0 then begin
                  m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC), HiWord(m_WAbil.AC) + m_Magic67Skill.btLevel * 2);
                  m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC), HiWord(m_WAbil.MAC) + m_Magic67Skill.btLevel * 2);
                  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, ''); //20080823 增加
                end;
              end;
            end;
          end;
{$IF M2Version <> 2}
          GetNGExp(g_Config.nDrinkIncNHExp, 2); //饮酒增加内功经验 2008103
{$IFEND}
          RecalcAbilitys();
          CompareSuitItem(False); //200080729 套装
          SendMsg(Self, RM_PLAYMAKEWINEABILITY, 0, 0, 0, 0, ''); //酒2相关属性 20080804
        end;

        if GetTickCount() - m_dwDecWineDrinkValueTick > g_Config.nDesDrinkTick * 1000 then begin //减少醉酒度
          m_dwDecWineDrinkValueTick := GetTickCount();
          m_Abil.WineDrinkValue := _MAX(0, m_Abil.WineDrinkValue - m_Abil.MaxAlcohol div 100);
          if m_Abil.WineDrinkValue = 0 then begin
            n_DrinkWineQuality := 0; //饮酒时酒的品质 20080627
            n_DrinkWineAlcohol := 0; //饮酒时酒的度数 20080627
            n_DrinkWineDrunk := False; //喝酒醉了 20080623
            SysMsg(g_sJiujinOverHintMsg {'酒劲终于消失了,身体也恢复平常的状态'}, c_Green, t_Hint); //提示用户
          end;
          RecalcAbilitys();
          CompareSuitItem(False); //200080729 套装
          SendMsg(Self, RM_PLAYMAKEWINEABILITY, 0, 0, 0, 0, ''); //酒2相关属性 20080804
        end;
      end;
//------------------------------------------------------------------------------
      nCode := 46;
      if m_boRunHumanMode and (GetTickCount() - dwRunHumanModeTick > dwRunHumanModeTime) then begin //改变穿人模式
        m_boRunHumanMode := False;
        nCode := 47;
        g_Config.boRUNHUMAN := Config.ReadBool('Setup', 'RunHuman', g_Config.boRUNHUMAN);
        g_Config.boRUNMON := Config.ReadBool('Setup', 'RunMon', g_Config.boRUNMON);
        nCode := 48;
        SendServerConfig; //发送配置信息到客户端
      end;
    end;
    nCode := 4;
    if m_boTimeRecall and (GetTickCount > m_dwTimeRecallTick) then begin //执行 TimeRecall回到原地
      m_boTimeRecall := False;
      SpaceMove(m_sMoveMap, m_nMoveX, m_nMoveY, 0);
    end;
    nCode := 5;
    if m_boTimeGoto and (GetTickCount > m_dwTimeGotoTick) then begin //执行 Delaygoto延时跳转
      m_boTimeGoto := False;
      nCode := 51;
      if TMerchant(m_TimeGotoNPC) <> nil then
        TMerchant(m_TimeGotoNPC).GotoLable(Self, m_sTimeGotoLable, False, False);
    end;
    nCode := 6;
    if (GetTickCount - m_dwCheckDupObjTick) > 3000 then begin //定时检查是否人物重叠
      m_dwCheckDupObjTick := GetTickCount();
      nCode := 61;
      GetStartPoint(); //取复活点
      nCode := 7;
      if not m_boNotOnlineAddExp then begin //如果是离线挂机的，不检测
        tObjCount := m_PEnvir.GetXYObjCount(m_nCurrX, m_nCurrY); //取坐标对像数
        nCode := 8;
        if tObjCount >= 2 then begin
          if not bo2F0 then begin
            bo2F0 := True;
            m_dwDupObjTick := GetTickCount();
          end;
        end else bo2F0 := False;
        if (((tObjCount >= 3) and ((GetTickCount() - m_dwDupObjTick) > 3000))
          or (((tObjCount = 2) and ((GetTickCount() - m_dwDupObjTick) > 10000)))) and ((GetTickCount() - m_dwDupObjTick) < 20000) then begin
          PushedObject := nil;
          dwStationTick := GetTickCount();
          PlayObjectList := TList.Create;
          try
            nCode := 9;
            m_PEnvir.GeTBaseObjects(m_nCurrX, m_nCurrY, False, PlayObjectList);
            nCode := 10;
            if PlayObjectList.Count > 0 then begin //20080629
              for I := 0 to PlayObjectList.Count - 1 do begin
                PlayObject := TPlayObject(PlayObjectList.Items[I]);
                if (GetTickCount() - PlayObject.m_dwStationTick) < dwStationTick then begin
                  PushedObject := PlayObject;
                  dwStationTick := GetTickCount() - PlayObject.m_dwStationTick;
                end;
              end; //for
              nCode := 11;
              if PushedObject <> nil then PushedObject.CharPushed(Random(8), 1); //推开重叠人物
            end;
          finally
            PlayObjectList.Free;
          end;
        end;
      end;
    end;
    nCode := 13;
    Castle := g_CastleManager.InCastleWarArea(Self);
    if (Castle <> nil) then begin
      if Castle.m_boUnderWar then ChangePKStatus(True); //正在攻城
    end;

    nCode := 14;
    if (GetTickCount - dwTick578) > 1000 then begin
      dwTick578 := GetTickCount();
{$IF M2Version <> 2}
      if m_boCanUerSkill102 then begin //唯我独尊减内力
        if GetTickCount > m_dwUseSkill102Time then begin
          m_boCanUerSkill102 := False;
          SysMsg(sSkill102Off1, c_Green, t_Hint);
        end else begin
          if m_Skill69NH >= 250 then begin //每秒减250内力
            m_Skill69NH := _MAX(0, m_Skill69NH - 250);
            SendRefMsg(RM_MAGIC69SKILLNH, 0, m_Skill69NH, m_Skill69MaxNH, 0, '');
          end else begin //内力不足则停止
            m_boCanUerSkill102 := False;
            SysMsg(sSkill102Off1, c_Green, t_Hint);
          end;
        end;
      end;
      nCode := 141;
      if m_boHeartActive then begin //龙卫状态激活,每秒减内力
        if m_MagicSkill_105 <> nil then begin
          nCode := 142;
          nInteger := m_MagicSkill_105.MagicInfo.wSpell;
          boInSafeArea := InSafeArea();
          btInSafeArea := Byte(boInSafeArea) + 1;//防止下面再重复调用 InSafeArea By TasNat at: 2012-05-18 09:41:44
          //优化 By TasNat at: 2012-03-06 12:07:20
          if (nInteger > 0) and (not boInSafeArea) then begin               
            if m_Skill69NH >= nInteger then begin //每秒减内力
              m_Skill69NH := _MAX(0, m_Skill69NH - nInteger);
              SendRefMsg(RM_MAGIC69SKILLNH, 0, m_Skill69NH, m_Skill69MaxNH, 0, '');
            end else m_boHeartActive := False; //内力不足则停止
          end;
        end else m_boHeartActive := False;
        if not m_boHeartActive then begin
          nCode := 143;
          RecalcAbilitys();
          CompareSuitItem(False); //套装与身上装备对比
          SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
          m_nCharStatus := GetCharStatus();
          StatusChanged('');
          nCode := 145;
          if (m_MyDivision <> nil) then TDivision(m_MyDivision).CloseMemberHeart(m_sCharName);
        end;
      end;
{$IFEND}
      DecodeTime(Now, wHour, wMin, wSec, wMSec); //根据时间值返回时、分、秒、毫秒值
      if (not m_boDeath) and (not m_boGhost) then begin
{$IF M2Version <> 2}
        if m_boCanTitle then begin //处理称号时间
          if (wHour = 0) and (wMin = 0) and (wSec <= 55) and (GetTickCount - m_dwUseTitleTick1 > 60000) then begin //0点时处理称号一次
            m_dwUseTitleTick1 := GetTickCount();
            m_dwUseTitleTick := GetTickCount();
            SendHumTitles(0);
          end else begin
            if (GetTickCount - m_dwUseTitleTick > 3600000) then begin //1小时执行
              m_dwUseTitleTick := GetTickCount();
              SendHumTitles(0);
            end;
          end;
        end;
{$IFEND}
        if not m_boAI then begin
          if (wHour = 0) and (wMin <= 0) and (wSec <= 55) and (GetTickCount - m_dwCheckItmeDayTick1 > 60000) then begin //0点时处理称号一次
            m_dwCheckItmeDayTick1 := GetTickCount();
            m_dwCheckItmeDayTick := GetTickCount();
            CheckItemsDay(); //定时检测物品是否过期  20110520
            if g_Config.boClearGamePoint then begin
              if (m_ClearGamePointDate < Int(Date)) then begin //初始游戏点的日期
                m_ClearGamePointDate := LDOM(Date);
                m_nGamePoint := 0;
                GameGoldChanged();
              end;
            end;
          end else begin
            if (GetTickCount - m_dwCheckItmeDayTick > 3600000) then begin //1小时执行
              m_dwCheckItmeDayTick := GetTickCount();
              CheckItemsDay(); //定时检测物品是否过期  20110520
            end;
          end;
        end;
      end;
      if g_Config.boDiscountForNightTime and ((wHour = g_Config.nHalfFeeStart) or (wHour = g_Config.nHalfFeeEnd)) then begin //扣夜晚时间费用
        if (wMin = 0) and (wSec <= 30) and ((GetTickCount - m_dwLogonTick) > 60000) then begin //大于30分钟，每隔1分钟执行
          LogonTimcCost(); //记录角色登陆的日志(如充值模式，通知LoginSrv修改玩家时间)
          m_dwLogonTick := GetTickCount();
          m_dLogonTime := Now();
        end;
      end;
      if (m_nPayMent = 2) and (GetTickCount - m_dwLogonTick > 3600000) then begin //20100616 增加,付费用户1小时定时发送游戏时长给LoginSvr程序
        LogonTimcCost(); //记录角色登陆的日志(如充值模式，通知LoginSrv修改玩家时间)
        m_dwLogonTick := GetTickCount();
        m_dLogonTime := Now();
      end;
      if (m_nPayMent = 1) and (not m_boEmergencyClose) then begin //20100615 增加
        if m_Abil.Level > g_Config.nTryModeLevel then begin
          SysMsg('测试状态只可以使用到第 ' + IntToStr(g_Config.nTryModeLevel) + ' 级。', c_Red, t_Hint);
          m_boEmergencyClose := True;
          m_boPlayOffLine := False;
        end;
      end;
      if (m_MyGuild <> nil) then begin
        if TGUild(m_MyGuild).GuildWarList.Count > 0 then begin
          //InSafeArea占CPU 所以必须省着点用By TasNat at: 2012-05-18 09:39:19
          if btInSafeArea = 0 then //未定义
            boInSafeArea := InSafeArea()
          else
            boInSafeArea := Boolean(btInSafeArea - 1);
          if boInSafeArea <> m_boInSafeArea then begin
            m_boInSafeArea := boInSafeArea;
            RefNameColor();
          end;
        end;
      end;
      nCode := 15;
      if (Castle <> nil) then begin
        nCode := 151;
        if Castle.m_boUnderWar then begin
          if (m_PEnvir = Castle.m_MapPalace) and (m_MyGuild <> nil) then begin
            nCode := 152;
            if not Castle.IsMember(Self) then begin
              nCode := 153;
              if Castle.IsAttackGuild(TGUild(m_MyGuild)) then begin
                nCode := 154;
                if Castle.CanGetCastle(TGUild(m_MyGuild)) then begin
                  Castle.GetCastle(TGUild(m_MyGuild));
                  if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(Self, '@GetCastle', False, False); //占领沙城触发 20110118
                  //UserEngine.SendServerGroupMsg(SS_211, nServerIndex, TGUild(m_MyGuild).sGuildName);//20101022 注释
                  if Castle.InPalaceGuildCount <= 1 then Castle.StopWallconquestWar();
                end;
              end;
            end;
          end;
        end else ChangePKStatus(False);
      end else begin
        nCode := 155;
        ChangePKStatus(False);
      end;
      nCode := 16;
      if m_boNameColorChanged then begin
        m_boNameColorChanged := False;
        RefUserState();
        RefShowName();
      end;
    end;
  except
    MainOutMessage(Format(sExceptionMsg1, [g_sExceptionVer, nCode, ExceptAddr]));
  end;
  try
    nCode := 18;
    m_dwGetMsgTick := GetTickCount();
    while (GetTickCount - m_dwGetMsgTick < g_Config.dwHumanGetMsgTime) and GetMessage(@ProcessMsg) do begin
      nCode := 181;
      if not Operate(@ProcessMsg) then Break;
    end;
    nCode := 19;
    if m_boEmergencyClose or m_boKickFlag or m_boSoftClose then begin
      nCode := 20;
      if (not m_boNotOnlineAddExp) and (not m_boAI) and
        (not g_boExitServer) and (not m_boExpire) then begin //20090901 修改
        GetBackSellOffItems(); //取备份元宝寄售列表物品
        ClientCloseBoxs(); //清空个人箱子列表资源,关闭箱子
        nCode := 26;
        if m_boChallengeing and m_PEnvir.m_boFight4Zone and (m_ChallengeCreat <> nil) then begin //20080706 是否在挑战中下线
          with m_ChallengeCreat do begin
            MapRandomMove(m_sLastMapName, 0);
            SysMsg(g_sChallengeWinMsg {'您挑战获胜!'}, c_Blue, t_Hint);
            m_boChallengeing := False;
            WinGetChallengeItems; //人物挑战中小退则输
          end;
        end;
        if m_boPlayOffLine then begin //下线触发 20110722 换位置
          if (not m_boReconnection) then begin //大退
            nCode := 21;
            if g_Config.boPasswordLockSystem then m_boLockLogoned := False;
            if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(Self, '@PlayOffLine', False, False); //人物下线触发
          end else begin //小退
            nCode := 22;
            if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(Self, '@PlayReconnection', False, False); //人物小退触发
          end;
        end;
      end;
      nCode := 23;
      if m_boSwitchData then begin
        m_sMapName := m_sSwitchMapName;
        m_nCurrX := m_nSwitchMapX;
        m_nCurrY := m_nSwitchMapY;
      end;
      nCode := 24;
      if not m_boNotOnlineAddExp then MakeGhost(); //如果不是离线挂机人物 可以下线
      if m_boKickFlag then SendDefMessage(SM_OUTOFCONNECTION, 0, 0, 0, 0, '');
      nCode := 25;
      if (not m_boReconnection) and (m_boSoftClose) and (not m_boAI) then begin
        if (not m_boKickAutoAddExpUser) then begin
          m_boKickAutoAddExpUser := True;
          FrmIDSoc.SendHumanLogOutMsg(m_sUserID, m_nSessionID);
        end;
        {蛋疼的代码哎. 王清修复 286251099 at: 2012-03-15 16:51:44
        if (m_boNotOnlineAddExp) and (not m_boKickAutoAddExpUser) then begin
          nCode := 27;
          m_boKickAutoAddExpUser := True;
          FrmIDSoc.SendHuman.LogOutMsg(m_sUserID, m_nSessionID);
        end else
          if (not m_boNotOnlineAddExp) and (not m_boKickAutoAddExpUser) then begin
            nCode := 28;
            m_boKickAutoAddExpUser := True;
            FrmIDSoc.SendHum.anLogOutMsg(m_sUserID, m_nSessionID); //发送人物小退消息.小退你妹啊是大退SB By TasNat at: 2012-03-13 16:39:36
          end;
        }
      end;
    end;
  except

    if ProcessMsg.wIdent = 0 then MakeGhost(); // 11.22 加上，用于处理人物异常退出，但人物还在游戏中问题 提示 Ident0 错误
    MainOutMessage(Format(sExceptionMsg2, [g_sExceptionVer, m_sCharName, ProcessMsg.wIdent, nCode, ExceptAddr]));

  end;

  try
    if (not m_boNotOnlineAddExp) and (not m_boGhost) and (GetTickCount - m_dwCheckTakeItemTick > 10000) then begin //不是离线挂机,非清理角色才检查,10秒检查一次 20090901
      m_dwCheckTakeItemTick := GetTickCount(); //检查身上不合法装备间隔
      boTakeItem := False;
      //检查身上的装备有没不符合
      for I := Low(THumanUseItems) to High(THumanUseItems) do begin //9格装备+4格装备
        if m_UseItems[I].wIndex > 0 then begin
          if (m_UseItems[I].AddValue[0] = 1) and (GetHoursCount(m_UseItems[I].MaxDate, Now) <= 0) then begin //删除到期装备
            SendDelItems(@m_UseItems[I]);
            m_UseItems[I].wIndex := 0;
            m_UseItems[I].MakeIndex := 0;
            boTakeItem := True;
            Continue;
          end;
          StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
          if StdItem <> nil then begin
            if not CheckItemsNeed(StdItem) then begin
              New(UserItem);
              UserItem^ := m_UseItems[I];
              if AddItemToBag(UserItem) then begin
                SendAddItem(UserItem);
                WeightChanged();
                boTakeItem := True;
              end else begin
                if DropItemDown(@m_UseItems[I], 3, False, False, nil, Self) then begin
                  boTakeItem := True;
                end;
                Dispose(UserItem);//修复内存泄露By TasNat at: 2012-06-01 12:10:51
              end;
              if boTakeItem then begin
                SendDelItems(@m_UseItems[I]);
                if StdItem.NeedIdentify = 1 then //20090502 物品消失记录日志
                  AddGameDataLog('6' + #9 + m_sMapName + #9 +
                    IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                    m_sCharName + #9 + StdItem.Name + #9 +
                    IntToStr(m_UseItems[I].MakeIndex) + #9 +
                    '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                    '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                    '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                    '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                    '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                    IntToStr(m_UseItems[I].btValue[0]) + '/' + IntToStr(m_UseItems[I].btValue[1]) + '/' + IntToStr(m_UseItems[I].btValue[2]) + '/' +
                    IntToStr(m_UseItems[I].btValue[3]) + '/' + IntToStr(m_UseItems[I].btValue[4]) + '/' + IntToStr(m_UseItems[I].btValue[5]) + '/' +
                    IntToStr(m_UseItems[I].btValue[6]) + '/' + IntToStr(m_UseItems[I].btValue[7]) + '/' + IntToStr(m_UseItems[I].btValue[8]) + '/' +
                    IntToStr(m_UseItems[I].btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + '物品掉落');
                m_UseItems[I].wIndex := 0;
              end;
            end;
          end else m_UseItems[I].wIndex := 0;
        end;
      end;
      if boTakeItem then begin
        RecalcAbilitys();
        CompareSuitItem(False); //200080729 套装
        FeatureChanged;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TPlayObject::Run -> CheckItems %p', [g_sExceptionVer, ExceptAddr]));
  end;

  try
    if (GetTickCount - m_dwSayMyInfoTick > 7200000) then begin //间隔2小时处理 20110510
      m_dwSayMyInfoTick := GetTickCount;
      if (nCrackedLevel <> 0) or (nErrorLevel <> 0) then begin //破解后,随机T人
        if Random(50) > 20 then begin
          m_boPlayOffLine := False;
          m_boEmergencyClose := True;
        end;
      end;
      (*{$IF M2Version <> 0}
      if (WLRegGetStatus(nX) <> wlIsRegistered) and (not m_boAI) and (not m_boNotOnlineAddExp) then begin//是否注册，非注册发广告
        if Random(2) = 1 then begin
          sTemp:= addStringList(sBUYHINTINFO1);
          if Decode(sTemp, s01) then begin
            s01:= Format_Tostr(s01, [sBUYHINTINF03]);
            SendMsg(Self, RM_MOVEMESSAGE, 0{0为顶部滚动 1为中部居中 2聊天栏上面倒记时 3顶部居中固定 4快捷栏上显示 5传音筒 6右下角显示}, g_Config.btRedMsgFColor, g_Config.btRedMsgBColor, 10, s01);
          end else begin
            nCrackedLevel:= Random(200);
            nErrorLevel:= Random(200);
          end;
        end else begin
          sTemp:=addStringList(sBUYHINTINFO2);
          if Decode(sTemp, s01) then begin
            s01:= Format_Tostr(s01, [sBUYHINTINF03]);
            SendMsg(Self, RM_MOVEMESSAGE, 0{0为顶部滚动 1为中部居中 2聊天栏上面倒记时 3顶部居中固定 4快捷栏上显示 5传音筒 6右下角显示}, g_Config.btRedMsgFColor, g_Config.btRedMsgBColor, 10, s01);
          end else begin
            nCrackedLevel:= Random(200);
            nErrorLevel:= Random(200);
          end;
        end;
      end;
      {$IFEND} *)
    end;

    if m_boRunPlayRobotManage then m_PlayRobotManage.Run; //运行个人机器人

{$IF M2Version <> 2}
    //自动修炼英雄强身术 20100818
    if (not m_boDeath) and (not m_boGhost) and (m_nDecGameGird > 0) then begin
      if (m_nDecGameGirdCount > 0) and (GetTickCount - m_dwDecGameGirdTick > 15000) then begin
        m_dwDecGameGirdTick := GetTickCount;
        if ClientGameGirdUpSkill99(m_nDecGameGird) then begin
          Dec(m_nDecGameGirdCount);
          if m_nDecGameGirdCount <= 0 then begin
            m_nDecGameGird := 0;
            m_nDecGameGirdCount := 0;
            SysMsg('灵符自动修炼白日门强身术已结束', c_Blue, t_Hint);
          end;
        end else begin
          m_nDecGameGird := 0;
          m_nDecGameGirdCount := 0;
          SysMsg('灵符自动修炼白日门强身术已结束', c_Blue, t_Hint);
        end;
      end;
{$IF M2Version = 1}
      if (m_MyHero <> nil) then begin
        if (m_nDecGameGirdCount_95 > 0) and (GetTickCount - m_dwDecGameGirdTick > 30000) then begin //主体修炼斗转星移
          m_dwDecGameGirdTick := GetTickCount;
          if ClientGameGirdUpSkill95(0, m_nDecGameGird) then begin
            Dec(m_nDecGameGirdCount_95);
            if m_nDecGameGirdCount_95 <= 0 then begin
              m_nDecGameGird := 0;
              m_nDecGameGirdCount_95 := 0;
              SysMsg('灵符自动修炼奇经已结束', c_Blue, t_Hint);
            end;
          end else begin
            m_nDecGameGird := 0;
            m_nDecGameGirdCount_95 := 0;
            SysMsg('您的灵符不足，自动终止修炼', c_Red, t_Hint);
            SysMsg('灵符自动修炼奇经已结束', c_Blue, t_Hint);
          end;
        end;
        if (m_nDecGameGirdCount_Hero95 > 0) and (GetTickCount - m_dwDecGameGirdTick > 30000) then begin //主体修炼斗转星移
          m_dwDecGameGirdTick := GetTickCount;
          if ClientGameGirdUpSkill95(1, m_nDecGameGird) then begin
            Dec(m_nDecGameGirdCount_Hero95);
            if m_nDecGameGirdCount_Hero95 <= 0 then begin
              m_nDecGameGird := 0;
              m_nDecGameGirdCount_Hero95 := 0;
              SysMsg('灵符自动修炼奇经已结束', c_Blue, t_Hint);
            end;
          end else begin
            m_nDecGameGird := 0;
            m_nDecGameGirdCount_Hero95 := 0;
            SysMsg('您的灵符不足，自动终止修炼', c_Red, t_Hint);
            SysMsg('灵符自动修炼奇经已结束', c_Blue, t_Hint);
          end;
        end;
      end;
{$IFEND}
    end;
{$IFEND}
    tObjCount := m_nGameGold;
    if m_boDecGameGold and (GetTickCount - m_dwDecGameGoldTick > m_dwDecGameGoldTime) then begin //自动减游戏币
      m_dwDecGameGoldTick := GetTickCount();
      if m_nGameGold >= m_nDecGameGold then begin
        Dec(m_nGameGold, m_nDecGameGold);
        nInteger := m_nDecGameGold;
      end else begin
        nInteger := m_nGameGold;
        m_nGameGold := 0;
        m_boDecGameGold := False;
        MoveToHome(); //减完则送回回城点
      end;
      if g_boGameLogGameGold then begin
        AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, m_sMapName, m_nCurrX,
          m_nCurrY, m_sCharName, g_Config.sGameGoldName, m_nGameGold,
            '-(' + inttostr(nInteger) + ')', 'Auto']));
      end;
    end;
    if m_boIncGameGold and (GetTickCount - m_dwIncGameGoldTick > m_dwIncGameGoldTime) then begin //自动加游戏币
      m_dwIncGameGoldTick := GetTickCount();
      if m_nGameGold + m_nIncGameGold < High(Integer {LongWord}) then begin //20090705 修改
        Inc(m_nGameGold, m_nIncGameGold);
        nInteger := m_nIncGameGold;
      end else begin
        m_nGameGold := High(Integer {LongWord});
        nInteger := High(Integer {LongWord}) - m_nGameGold;
        m_boIncGameGold := False;
      end;
      if g_boGameLogGameGold then begin
        AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, m_sMapName, m_nCurrX,
          m_nCurrY, m_sCharName, g_Config.sGameGoldName, m_nGameGold,
            '+(' + inttostr(nInteger) + ')', 'Auto']));
      end;
    end;
    if not m_boDecGameGold and m_PEnvir.m_boDecGameGold then begin
      if GetTickCount - m_dwDecGameGoldTick > LongWord(m_PEnvir.m_nDECGAMEGOLDTIME * 1000) then begin
        m_dwDecGameGoldTick := GetTickCount();
        if m_nGameGold >= m_PEnvir.m_nDecGameGold then begin
          Dec(m_nGameGold, m_PEnvir.m_nDecGameGold);
          nInteger := m_PEnvir.m_nDecGameGold;
        end else begin
          nInteger := m_nGameGold;
          m_nGameGold := 0;
          m_boDecGameGold := False;
          MoveToHome();
        end;
        if g_boGameLogGameGold then begin
          AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, m_sMapName, m_nCurrX,
            m_nCurrY, m_sCharName, g_Config.sGameGoldName, m_nGameGold,
              '-(' + inttostr(nInteger) + ')', 'Map']));
        end;
      end;
    end;
    if not m_boIncGameGold and m_PEnvir.m_boIncGameGold then begin
      if GetTickCount - m_dwIncGameGoldTick > LongWord(m_PEnvir.m_nINCGAMEGOLDTIME * 1000) then begin
        m_dwIncGameGoldTick := GetTickCount();
        if m_nGameGold + m_PEnvir.m_nIncGameGold <= High(Integer {LongWord}) then begin //20090705修改
          Inc(m_nGameGold, m_PEnvir.m_nIncGameGold);
          nInteger := m_PEnvir.m_nIncGameGold;
        end else begin
          nInteger := High(Integer {LongWord}) - m_nGameGold; //20090705修改
          m_nGameGold := High(Integer {LongWord}); //20090705修改
        end;
        if g_boGameLogGameGold then begin
          AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, m_sMapName, m_nCurrX,
            m_nCurrY, m_sCharName, g_Config.sGameGoldName, m_nGameGold,
              '+(' + inttostr(nInteger) + ')', 'Map']));
        end;
      end;
    end;
    if tObjCount <> m_nGameGold then SendUpdateMsg(Self, RM_GOLDCHANGED, 0, 0, 0, 0, '');
    if m_PEnvir.m_boINCGAMEPOINT then begin //自动加游戏点
      if (GetTickCount - m_dwIncGamePointTick > LongWord(m_PEnvir.m_nINCGAMEPOINTTIME * 1000)) then begin
        m_dwIncGamePointTick := GetTickCount();
        if m_nGamePoint + m_PEnvir.m_nINCGAMEPOINT <= High(LongWord) then begin
          Inc(m_nGamePoint, m_PEnvir.m_nINCGAMEPOINT);
          nInteger := m_PEnvir.m_nINCGAMEPOINT;
        end else begin
          m_nGamePoint := High(LongWord);
          nInteger := High(LongWord) - m_nGamePoint;
        end;
        if g_boGameLogGamePoint then begin
          AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEPOINT,
            m_sMapName, m_nCurrX, m_nCurrY, m_sCharName, g_Config.sGamePointName,
              nInteger, '+', 'Map']));
        end;
      end;
    end;

    if m_PEnvir.m_boDECGAMEPOINT then begin //自动减游戏点 20080413
      if (GetTickCount - m_dwDecGamePointTick > LongWord(m_PEnvir.m_nDECGAMEPOINTTIME * 1000)) then begin
        m_dwDecGamePointTick := GetTickCount();
        if m_nGamePoint >= m_PEnvir.m_nDECGAMEPOINT then begin
          Dec(m_nGamePoint, m_PEnvir.m_nDECGAMEPOINT);
          nInteger := m_PEnvir.m_nDECGAMEPOINT;
        end else begin
          m_nGamePoint := 0;
          nInteger := m_nGamePoint;
          MoveToHome(); //移动到回城点
        end;
        if g_boGameLogGamePoint then begin //写入日志
          AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEPOINT, m_sMapName,
            m_nCurrX, m_nCurrY, m_sCharName, g_Config.sGamePointName, nInteger, '-', 'Map']));
        end;
      end;
    end;

    if m_PEnvir.m_boNoSkill then begin //不允许使用任何技能,英雄或下属收回 20110518
      KillSlave; //清除下属
{$IF HEROVERSION = 1}
      if m_MyHero <> nil then ClientHeroLogOut(0);
{$IFEND}
    end;

    if m_PEnvir.m_boMISSION then begin //不允许使用任何物品和技能 20080124
      m_boCanUseItem := False; //不允许使用物品
      m_boCanSpell := False; //不允许使用技能
      KillSlave; //清除下属 20080124
{$IF HEROVERSION = 1}
      if m_MyHero <> nil then begin //20080126
        with THeroObject(m_MyHero) do begin //20091110 修改
          m_boCanUseItem := False;
          m_boCanSpell := False;
          m_boNoAttackMode := True; //不可以攻击模式
        end;
      end;
{$IFEND}
    end else begin
      if g_Config.boLockHumanLogin and m_boLockLogon and m_boPasswordLocked then begin //如果开启密码保护,没有解密时 20080529
        m_boCanSpell := not g_Config.boLockSpellAction; //允许使用技能
      end else
        if m_boUnLockPwd then begin
          if g_Config.boLockSpellAction then m_boCanSpell := True;
        end else m_boCanSpell := True;

      m_boCanUseItem := True; //允许使用物品
{$IF HEROVERSION = 1}
      if m_MyHero <> nil then begin //20080126
        with THeroObject(m_MyHero) do begin //20091110 修改
          m_boCanUseItem := True;
          m_boCanSpell := True;
          m_boNoAttackMode := False; //可以攻击模式
        end;
      end;
{$IFEND}
    end;
{$IF HEROVERSION = 1}
    if m_PEnvir.m_boNOCALLHERO then begin //禁止召唤英雄 20080124
      m_boCallHero := False;
      if m_MyHero <> nil then begin
        if not m_MyHero.m_boDeath then ClientHeroLogOut(0); //英雄退出 20081024 修改
      end;
    end else begin
      if g_Config.boLockHumanLogin and m_boLockLogon and m_boPasswordLocked then begin //如果开启密码保护,没有解密时 20080529
        m_boCallHero := not g_Config.boLockCallHeroAction; //允许召唤英雄
      end else
        if m_boUnLockPwd then begin //解锁
          if g_Config.boLockCallHeroAction then m_boCallHero := True;
        end else m_boCallHero := True;
    end;
    if m_MyHero <> nil then begin
      if (not g_Config.boUseCanHero) and (not m_MyHero.m_boDeath) then ClientHeroLogOut(0); //英雄退出，未开放英雄系统，则收回英雄 20100529
    end;
{$IFEND}
    if m_PEnvir.m_boDECHP and (GetTickCount - m_dwDecHPTick > LongWord(m_PEnvir.m_nDECHPTIME * 1000)) then begin
      m_dwDecHPTick := GetTickCount();
      if m_WAbil.HP > m_PEnvir.m_nDECHPPOINT then begin
        Dec(m_WAbil.HP, m_PEnvir.m_nDECHPPOINT);
      end else begin
        m_WAbil.HP := 0;
      end;
      HealthSpellChanged();
    end;

    if m_PEnvir.m_boINCHP and (GetTickCount - m_dwIncHPTick > LongWord(m_PEnvir.m_nINCHPTIME * 1000)) then begin
      m_dwIncHPTick := GetTickCount();
      if m_WAbil.HP + m_PEnvir.m_nDECHPPOINT < m_WAbil.MaxHP then begin
        Inc(m_WAbil.HP, m_PEnvir.m_nDECHPPOINT);
      end else begin
        m_WAbil.HP := m_WAbil.MaxHP;
      end;
      HealthSpellChanged();
    end;

    //降饥饿点
    if g_Config.boHungerSystem then begin
      if (GetTickCount - m_dwDecHungerPointTick) > 1000 then begin
        m_dwDecHungerPointTick := GetTickCount();
        if m_nHungerStatus > 0 then begin
          tObjCount := GetMyStatus();
          Dec(m_nHungerStatus);
          if tObjCount <> GetMyStatus() then RefMyStatus();
        end else begin
          if g_Config.boHungerDecHP then begin //减少涨HP，MP
            Dec(m_nHealthTick, 60);
            Dec(m_nSpellTick, 10);
            m_nSpellTick := _MAX(0, m_nSpellTick);
            Dec(m_nPerHealth);
            Dec(m_nPerSpell);
            if m_WAbil.HP > m_WAbil.HP div 100 then begin
              Dec(m_WAbil.HP, _MAX(1, m_WAbil.HP div 100));
            end else begin
              if m_WAbil.HP <= 2 then m_WAbil.HP := 0;
            end;
            HealthSpellChanged();
          end;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TPlayObject::Run -> m_PEnvir %p', [g_sExceptionVer, ExceptAddr]));
  end;

  try
{$IF M2Version = 1}
    if m_boUseBatter and (not m_boAI) then begin
      if m_btJob > 0 then begin //道法职业
        if GetTickCount - m_nUseBatterTime > 1200 then begin //连击处理
          m_nUseBatterTime := GetTickCount();
          //if (m_wStatusTimeArr[POISON_STONE] = 0) then m_boCanWalk:= False;//不能走 20110115 注释，走跑时连击停止
          //if m_wStatusTimeArr[STATE_LOCKRUN] = 0 then m_boCanRun:= False;//不能跑
          m_boCanHit := False; //不能打击
          m_boCanSpell := False; //不能魔法
          if (m_nBatterMagIdx1 <= 0) and (m_nBatterMagIdx2 <= 0) and (m_nBatterMagIdx3 <= 0) and (m_nBatterMagIdx4 <= 0) then begin
            m_boUseBatter := False;
            m_nDecDamageRate := 0; //吸伤比率
            m_nUseBatterTick := GetTickCount(); //使用连击的计时
            //if (m_wStatusTimeArr[POISON_STONE] = 0) then m_boCanWalk:= True;//不能走
            //if m_wStatusTimeArr[STATE_LOCKRUN] = 0 then m_boCanRun:= True;//不能跑
            m_boCanHit := True; //不能打击
            m_boCanSpell := True; //不能魔法
            SendMsg(self, RM_BATTEROVER, 0, 0, 0, 0, '');
          end;
          if m_nBatterMagIdx1 <> 0 then begin
            UseBatterSpell(m_nBatterMagIdx1, 10); //发第一个连击技能消息
            m_nBatterMagIdx1 := 0;
          end else if m_nBatterMagIdx2 <> 0 then begin
            UseBatterSpell(m_nBatterMagIdx2, 15); //发第二个连击技能消息
            m_nBatterMagIdx2 := 0;
          end else if m_nBatterMagIdx3 <> 0 then begin
            UseBatterSpell(m_nBatterMagIdx3, 25); //发第三个连击技能消息
            m_nBatterMagIdx3 := 0;
          end else if m_nBatterMagIdx4 <> 0 then begin
            UseBatterSpell(m_nBatterMagIdx4, 30); //发第四个连击技能消息
            m_nBatterMagIdx4 := 0;
          end;
        end;
      end else begin //战
        if GetTickCount - m_nUseBatterTime > 300 then begin //连击处理
          m_nUseBatterTime := GetTickCount();
          if (m_nBatterMagIdx1 > 0) and (not m_boWarUseBatter) then begin
            UseBatterSpell(m_nBatterMagIdx1, 10);
            m_boWarUseBatter := True;
            m_dwLatestWarUseBatterTick := GetTickCount();
          end else
            if (m_nBatterMagIdx2 > 0) and (not m_boWarUseBatter) then begin
              UseBatterSpell(m_nBatterMagIdx2, 15);
              m_boWarUseBatter := True;
              m_dwLatestWarUseBatterTick := GetTickCount();
            end else
              if (m_nBatterMagIdx3 > 0) and (not m_boWarUseBatter) then begin
                UseBatterSpell(m_nBatterMagIdx3, 25);
                m_boWarUseBatter := True;
                m_dwLatestWarUseBatterTick := GetTickCount();
              end else
                if (m_nBatterMagIdx4 > 0) and (not m_boWarUseBatter) then begin
                  UseBatterSpell(m_nBatterMagIdx4, 30);
                  m_boWarUseBatter := True;
                  m_dwLatestWarUseBatterTick := GetTickCount();
                end;
        end;
        if (m_nBatterMagIdx1 <= 0) and (m_nBatterMagIdx2 <= 0) and (m_nBatterMagIdx3 <= 0) and (m_nBatterMagIdx4 <= 0) then begin
          SendSocket(nil, '+UBAT');
          m_nUseBatterTick := GetTickCount(); //使用连击的计时
          m_dwLatestWarUseBatterTick := GetTickCount();
          m_boUseBatter := False;
          m_boWarUseBatter := False;
        end;
      end; //战
    end else
      if m_boTrainBatterSkill and (not m_boSendCanBatterMsg) and (not m_boAI) then begin //学过内功
        if GetTickCount() - m_nUseBatterTick >= g_Config.dwUseBatterTick then begin //连击间隔
          m_boSendCanBatterMsg := True;
          SendMsg(self, RM_SENDCANUSEBATTER, 0, 0, 0, 0, ''); //发送可使用连击的通知
          SysMsg(g_sCanUseBatter, c_Green, t_Hint);
        end;
      end;
{$IFEND}
    if GetTickCount - m_dwRateTick > 1000 then begin
      m_dwRateTick := GetTickCount();
      nCode := 220;
      try
        if (not m_boDeath) and (not m_boGhost) and (g_ManageNPC <> nil) and (m_OnTimerList.Count > 0) then begin
          for I := m_OnTimerList.Count - 1 downto 0 do begin
            if m_OnTimerList.Count <= 0 then Break;
            OnTimer := m_OnTimerList.Items[I];
            if OnTimer <> nil then begin
              if GetTickCount > OnTimer.NextTimer then begin
                OnIdx := OnTimer.nIdx;
                if OnTimer.RunCount > 0 then begin
                  if OnTimer.RunCount = 1 then begin
                    m_OnTimerList.Delete(I);
                    Dispose(OnTimer);
                  end else begin
                    Dec(OnTimer.RunCount);
                    OnTimer.NextTimer := GetTickCount + OnTimer.Interval;
                  end;
                end else begin
                  OnTimer.NextTimer := GetTickCount + OnTimer.Interval;
                end;
                if (g_ManageNPC <> nil) then g_ManageNPC.GotoLable(self, '@OnTimer' + Inttostr(OnIdx), False, False);
              end;
            end;
          end;
        end;
      except
        MainOutMessage(format('{%s} TPlayObject.Run OnTimer %p',[g_sExceptionVer, ExceptAddr]));
      end;
      nCode := 207;
      if (m_dwUserTick[0] > 0) then begin //倒计时触发QF段
        Dec(m_dwUserTick[0]);
        Inc(m_dwUserTick[3]); //20090129
        if (m_dwUserTick[3] >= 180) and (m_dwUserTick[0] > 0) then begin //每隔4分钟，更新一次客户端的时间，以保证两边程序时间的统一 20090129
          m_dwUserTick[3] := 0;
          SendDefMessage(SM_UPDATETIME, m_dwUserTick[0], 0, 0, 0, ''); //发送M2当前的倒计时值
        end;
        if m_dwUserTick[0] = 0 then begin
          if (g_FunctionNPC <> nil) and (m_sMapQFStr <> '') then begin //SENDTIMEMSG命令设置的触发段 20090124
            g_FunctionNPC.GotoLable(self, m_sMapQFStr, False, False);
            m_dwUserTick[3] := 0;
          end;
        end;
      end;
      nCode := 208;
      if (m_dwUserTick[2] > 0) then begin //倒计时，发送触发段参数给客户端，并显示'!'号图标
        Dec(m_dwUserTick[2]);
        if m_dwUserTick[2] = 0 then begin
          if (m_sMapQFStr1 <> '') then begin //SENDMSGWINDOWS命令设置的触发段 20090124
            //发消息给客户端，显示'!'号图标，点击图标则进入QF指定的触发段
            SendDefMessage(SM_SHOWSIGHICON, 0, 0, 0, 0, m_sMapQFStr1);
          end;
        end;
      end;
      nCode := 209;
{$IF M2Version <> 2}
{$IF M2Version = 1}
      if (g_Config.nIncJingYuanValueTime > 1) and (not m_boNotOnlineAddExp) and (m_JingYuanValue < g_Config.nJingYuanValue) and (m_dwIncJingYuanValueTime > 0) then begin
        Dec(m_dwIncJingYuanValueTime);
        if m_dwIncJingYuanValueTime <= 0 then begin
          m_dwIncJingYuanValueTime := g_Config.nIncJingYuanValueTime;
          Inc(m_JingYuanValue, 100);
          SysMsg('恭喜您获得了100点奇经内功精元！', c_Red, t_Hint);
          if m_JingYuanValue >= g_Config.nJingYuanValue then begin
            m_JingYuanValue := g_Config.nJingYuanValue;
            SysMsg('您的奇经内功精元已蓄满！', c_Red, t_Hint);
          end;
          SendMsg(Self, RM_SENDJINGYUANVALUE, 0, 100, 0, 0, ''); //更新人物精元值
        end;
      end;
{$IFEND}
      if g_Config.boUseCanKamPo and (m_dwIncEnergyValueTime > 0) and (m_nEnergyValue < 100) and (not m_boAI) then begin //在线1小时增加10点精力值 20100826
        if g_Config.boOffLineEnergy then begin
          if not m_boNotOnlineAddExp then begin
            Dec(m_dwIncEnergyValueTime);
            if m_dwIncEnergyValueTime <= 0 then begin
              m_dwIncEnergyValueTime := g_Config.nEnergyValueTime;
              Inc(m_nEnergyValue, 10); //精力值(制造神秘卷轴)
              if m_nEnergyValue >= 100 then begin
                m_nEnergyValue := 100;
                SysMsg('您的神秘解读精力值已蓄满！', c_Red, t_Hint);
                SendEnergyAndLucky();
              end;
            end;
          end;
        end else begin
          Dec(m_dwIncEnergyValueTime);
          if m_dwIncEnergyValueTime <= 0 then begin
            m_dwIncEnergyValueTime := g_Config.nEnergyValueTime;
            Inc(m_nEnergyValue, 10); //精力值(制造神秘卷轴)
            if m_nEnergyValue >= 100 then begin
              m_nEnergyValue := 100;
              SysMsg('您的神秘解读精力值已蓄满！', c_Red, t_Hint);
              SendEnergyAndLucky();
            end;
          end;
        end;
      end;
{$IFEND}
      if m_dwHighLevelKillMonFixExpTime > 0 then begin //高等级杀怪经验不变的使用时间(秒) 20090213
        Dec(m_dwHighLevelKillMonFixExpTime);
        if m_dwHighLevelKillMonFixExpTime <= 0 then begin
          m_boHighLevelKillMonFixExp := False; //高等级杀怪经验不变 20090213
          SysMsg('真视经验恢复正常...', c_Red, t_Hint);
        end;
      end;
      nCode := 210;
      if m_dwUseItmeChangMsgFColorTime > 0 then begin //使用物品改变说话颜色的使用时间(秒) 玄绿,玄紫,玄褐 20090221
        Dec(m_dwUseItmeChangMsgFColorTime);
        if m_dwUseItmeChangMsgFColorTime <= 0 then begin
          m_dwUseItmeChangMsgFColorType := 0; //颜色类型 20090222
        end;
      end;
      nCode := 211;
      if m_dwKillMonExpRateTime > 0 then begin
        if m_PEnvir.m_boDECEXPRATETIME then begin //地图设置减双倍经验 20090206
          if m_dwKillMonExpRateTime >= m_PEnvir.m_nDECEXPRATETIME then begin //20090423 修改
            Dec(m_dwKillMonExpRateTime, m_PEnvir.m_nDECEXPRATETIME);
          end else m_dwKillMonExpRateTime := 0;
        end else Dec(m_dwKillMonExpRateTime);
        if m_dwKillMonExpRateTime <= 0 then begin
          SysMsg(Format_ToStr('您的%g倍经验时间结束', [m_nKillMonExpRate / 100]), c_Red, t_Hint); //20110113 修改
          m_nKillMonExpRate := 100;
          m_nOldKillMonExpRate := m_nKillMonExpRate; //20080607
          RecalcAbilitys; //20080607
          CompareSuitItem(False); //200080729 套装
          if m_MyHero <> nil then begin
            THeroObject(m_MyHero).m_nKillMonExpRate := 100; //英雄存在,也同时设置为原来的经验倍数  20080406
            THeroObject(m_MyHero).m_nOldKillMonExpRate := THeroObject(m_MyHero).m_nKillMonExpRate; //20080607
            THeroObject(m_MyHero).RecalcAbilitys; //20080607
            m_MyHero.CompareSuitItem(False); //200080729 套装
          end;
        end;
      end;
      if m_boMakeWine and (m_MakeWineTime > 0) then Dec(m_MakeWineTime); //改变酿酒时间 20080620
      nCode := 212;
      if (not m_boNotOnlineAddExp) and (not m_boDeath) and (not m_boGhost) then PlayGatherFountain; //收集泉水 20090811 修改
      nCode := 213;
      //挑战计时 20080706  正在挑战中,在挑战地图,挑战时间不为零,挑战对像存在
      if m_boChallengeing and m_PEnvir.m_boFight4Zone and (m_ChallengeTime > 0) then begin
        Dec(m_ChallengeTime);
        if m_ChallengeCreat <> nil then begin
          if m_ChallengeTime <= 0 then begin //挑战时间到,没有分出胜负,则传送出挑战地图
            if (not m_boDeath) and (not m_ChallengeCreat.m_boDeath) then begin //双方都没有死亡,则传送到回城地图
              with m_ChallengeCreat do begin //20090901 修改
                m_boChallengeing := False;
                GetBackChallengeItems();
                m_ChallengeCreat := nil;
                m_ChallengeLastTick := GetTickCount();
                MapRandomMove(m_sLastMapName, 0);
                SysMsg(g_sChallengeTimeOverMsg {'时间到,未分出胜负'}, c_Blue, t_Hint);
                m_WAbil.HP := m_WAbil.MaxHP;
                m_WAbil.MP := m_WAbil.MaxMP;
                HealthSpellChanged();
              end;

              m_boChallengeing := False;
              GetBackChallengeItems();
              m_ChallengeCreat := nil;
              m_ChallengeLastTick := GetTickCount();
              MapRandomMove(m_sLastMapName, 0);
              SysMsg(g_sChallengeTimeOverMsg {'时间到,未分出胜负'}, c_Blue, t_Hint);
              m_WAbil.HP := m_WAbil.MaxHP;
              m_WAbil.MP := m_WAbil.MaxMP;
              HealthSpellChanged();
            end;
          end;
          if m_ChallengeCreat <> nil then begin
            if m_PEnvir <> m_ChallengeCreat.m_PEnvir then begin //双方不在同个地图时
              if not m_PEnvir.m_boFight4Zone then begin
                m_ChallengeCreat.MapRandomMove(m_ChallengeCreat.m_sLastMapName, 0);
                SysMsg(g_sChallengeLoseMsg {'您挑战输了'}, c_Blue, t_Hint);
                m_ChallengeCreat.SysMsg(g_sChallengeWinMsg {'您挑战获胜!'}, c_Blue, t_Hint);
                m_ChallengeCreat.WinGetChallengeItems;
              end else
                if not m_ChallengeCreat.m_PEnvir.m_boFight4Zone then begin
                  MapRandomMove(m_sLastMapName, 0);
                  SysMsg(g_sChallengeWinMsg {'您挑战获胜!'}, c_Blue, t_Hint);
                  m_ChallengeCreat.SysMsg(g_sChallengeLoseMsg {'您挑战输了!'}, c_Blue, t_Hint);
                  WinGetChallengeItems;
                end;
            end;
          end;
        end;
      end;
      nCode := 214;
      //药力值不为0,判断间隔时间内是否饮药酒,时间到没饮,则减少药力值 20080624
      if (m_Abil.MedicineValue > 0) and (dw_UseMedicineTime > 0) and (not m_boDeath) and (not m_boGhost) then begin //20090811
        Dec(dw_UseMedicineTime);
        if dw_UseMedicineTime <= 0 then begin //使用时间到
          m_Abil.MedicineValue := _MAX(0, m_Abil.MedicineValue - g_Config.nDesMedicineValue);
          if m_Abil.MedicineValue > 0 then dw_UseMedicineTime := g_Config.nDesMedicineTick; //始化使用药酒时间(12小时)
          RecalcAbilitys();
          CompareSuitItem(False); //200080729 套装
          if not m_boNotOnlineAddExp then SendMsg(Self, RM_PLAYMAKEWINEABILITY, 0, 0, 0, 0, ''); //酒2相关属性 20080804
        end;
      end;
{$IF M2Version = 1}
      nCode := 215;
      //当酒量超过指定值后，长时间不喝酒，则减酒量 20100212
      if (m_Abil.MaxAlcohol > g_Config.nDesMaxAlcoholValue) and (dw_UseMedicineTime1 > 0) and (not m_boDeath) and (not m_boGhost) then begin
        Inc(n_UsesMedicineTime); //减喝酒时间一分钟计时
        if n_UsesMedicineTime >= 60 then begin
          Dec(dw_UseMedicineTime1);
          n_UsesMedicineTime := 0;
          if dw_UseMedicineTime1 <= 0 then begin
            m_Abil.Alcohol := _MAX(0, m_Abil.Alcohol - g_Config.nDesAlcoholValue);
            m_Abil.MaxAlcohol := _MAX(g_Config.nDesMaxAlcoholValue, m_Abil.MaxAlcohol - g_Config.nDesAlcoholValue);
            if m_Abil.MaxAlcohol > g_Config.nDesMaxAlcoholValue then dw_UseMedicineTime1 := g_Config.nDesAlcoholTick; //始化使用喝酒时间
            RecalcAbilitys();
            CompareSuitItem(False);
            if not m_boNotOnlineAddExp then SendMsg(Self, RM_PLAYMAKEWINEABILITY, 0, 0, 0, 0, ''); //酒2相关属性
          end;
        end;
      end;
{$IFEND}
      nCode := 216;
      if m_dwPowerRateTime > 0 then begin
        Dec(m_dwPowerRateTime);
        if m_dwPowerRateTime = 0 then begin
          m_nPowerRate := 100;
          SysMsg('攻击力倍数恢复正常...', c_Red, t_Hint);
        end;
      end;
      nCode := 217;
      //如果有聚灵珠 20080221                                   //20091111 死亡也不处理
      if (n_UsesItemTick > 0) and (not m_boNotOnlineAddExp) and (not m_boDeath) and (not m_boGhost) and (not m_boAI) then begin //非挂机状态下
        Dec(n_UsesItemTick);
        Inc(n_UsesItemTime); //聚灵珠发送剩余时间消息的时间 20080307
        if n_UsesItemTime >= 600 {60 * 10} then begin //10分钟更新一次剩余时间
          SendItemUseTime(n_UsesItemTick); //发送聚灵珠使用剩余时间 20080307
          n_UsesItemTime := 0;
        end;
        if n_UsesItemTick <= 0 then begin
          n_UsesItemTick := 0; //20080311
          IsItem_51(2); //20080522 增加
          SendItemUseTime(n_UsesItemTick); //发送聚灵珠使用剩余时间 20080309
          SysMsg('【聚灵珠】聚集时间已到,不能再聚集经验，请双击使用!', c_Red, t_Hint);
        end;
      end;
      nCode := 218;
{$IF M2Version <> 2}
      if m_boTrainingNG and (not m_boDeath) and (not m_boGhost) then begin //非死亡时，学过内功,间隔时间增加内力值 20090811
        if GetTickCount() - m_dwIncNHTick > g_Config.dwIncNHTime then begin
          m_dwIncNHTick := GetTickCount();
          n18 := (m_Skill69MaxNH div 75) + 1 + m_nIncNHPoint; //按内功等级每次增加的内力值
          n18 := Round(n18 * (1 + m_nIncNHRecover / 100));
          if (m_Skill69NH < m_Skill69MaxNH) then begin
            if m_Skill69NH > High(Integer) - n18 then m_Skill69NH := High(Integer)
            else m_Skill69NH := _MIN(m_Skill69MaxNH, m_Skill69NH + n18); // 20090701 修改
            if m_Skill69NH > m_Skill69MaxNH then m_Skill69NH := m_Skill69MaxNH;
            SendRefMsg(RM_MAGIC69SKILLNH, 0, m_Skill69NH, m_Skill69MaxNH, 0, '');
          end;
        end;
{$IF M2Version = 1}
        if GetTickCount() - m_dwIncTransferTick > g_Config.nIncTransferValueTime then begin
          m_dwIncTransferTick := GetTickCount();
          if (m_WAbil.TransferValue < m_WAbil.MaxTransferValue) and (m_Magic95Skill <> nil) then begin //斗转值回复
            n18 := (m_WAbil.MaxTransferValue div 10) + 1; //20110128
            m_WAbil.TransferValue := _MIN(m_WAbil.MaxTransferValue, m_WAbil.TransferValue + n18);
            SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
          end;
        end;
{$IFEND}
      end;
{$IFEND}
      nCode := 219;
      if (not m_boDeath) and (not m_boGhost) and (not m_boNotOnlineAddExp) and
        (GetTickCount() - m_ShowThunderAndLavaTick > 2000) and (not m_boAI) then begin
        if (m_PEnvir.nThunder > 0) and (Random(10) = 0) then begin //雷电
          m_ShowThunderAndLavaTick := GetTickCount();
          if (Random(5) = 0) then begin
            SendRefMsg(RM_10205, 10, m_nCurrX, m_nCurrY, 0, ''); //显示效果
            DamageHealth((m_PEnvir.nThunder - (m_PEnvir.nThunder div 3)) + Random(m_PEnvir.nThunder div 3));
            HealthSpellChanged;
          end else begin
            tObjCount := m_nCurrX - 6 + Random(6);
            nInteger := m_nCurrY - 6 + Random(6);
            if GetRandXY(m_PEnvir, tObjCount, nInteger) then
              SendRefMsg(RM_10205, 10, tObjCount, nInteger, 0, '');
          end;
        end else
          if (m_PEnvir.nLava > 0) and (Random(10) = 0) then begin //地上冒岩浆
            m_ShowThunderAndLavaTick := GetTickCount();
            if (Random(5) = 0) then begin
              SendRefMsg(RM_10205, 11, m_nCurrX, m_nCurrY, 0, '');
              DamageHealth((m_PEnvir.nLava - (m_PEnvir.nLava div 3)) + Random(m_PEnvir.nLava div 3));
              HealthSpellChanged;
            end else begin
              tObjCount := m_nCurrX - 6 + Random(6);
              nInteger := m_nCurrY - 6 + Random(6);
              if GetRandXY(m_PEnvir, tObjCount, nInteger) then
                SendRefMsg(RM_10205, 11, tObjCount, nInteger, 0, '');
            end;
          end;
      end;
     //20101022 替换雷炎效果,使用JS代码
     (* if ((m_PEnvir.nThunder > 0) or (m_PEnvir.nLava > 0)) and (not m_boDeath) and (not m_boGhost) and (not m_boNotOnlineAddExp) then begin//如果是离线挂机的，不检测 20090510
        if (GetTickCount() - m_ShowThunderAndLavaTick > 5000) then begin//处理雷电，岩浆的间隔 20090505
          m_ShowThunderAndLavaTick:= GetTickCount();
          if (g_EventManager.GetRangeEvent1(m_PEnvir, m_nCurrX, m_nCurrY, 7, 2) = 0) then begin//检查同个屏幕内是否有一样的场景
            if Random(4) = 0 then begin
              tObjCount:= m_nCurrX;
              nInteger:= m_nCurrY;
              if (m_PEnvir.nThunder > 0) and (m_PEnvir.nLava > 0) then begin//地图有闪电  地上冒岩浆效果 20090505
                case Random(2) of
                  0:begin//雷电
                     SendRefMsg(RM_10205, 10, tObjCount{X}, nInteger{Y}, 0, '');//显示效果
                     ThunderAndLavaEvent:= TThunderAndLavaEvent.Create(m_PEnvir, tObjCount{X}, nInteger{Y}, 2, 2300, (m_PEnvir.nThunder -(m_PEnvir.nThunder div 3))+ Random(m_PEnvir.nThunder div 3));
                     g_EventManager.AddEvent(ThunderAndLavaEvent);
                   end;
                  1:begin//地上冒岩浆
                     SendRefMsg(RM_10205, 11, tObjCount, nInteger, 0, '');//显示效果
                     ThunderAndLavaEvent:= TThunderAndLavaEvent.Create(m_PEnvir, tObjCount{X}, nInteger{Y}, 2, 2300, (m_PEnvir.nLava -(m_PEnvir.nLava div 3))+ Random(m_PEnvir.nLava div 3));
                     g_EventManager.AddEvent(ThunderAndLavaEvent);
                   end;
                end;//case Random(2) of
              end else begin
                if m_PEnvir.nThunder > 0 then begin//雷电
                  SendRefMsg(RM_10205, 10, tObjCount{X}, nInteger{Y}, 0, '');//显示效果
                  ThunderAndLavaEvent:= TThunderAndLavaEvent.Create(m_PEnvir, tObjCount{X}, nInteger{Y}, 2, 2300, (m_PEnvir.nThunder -(m_PEnvir.nThunder div 3))+ Random(m_PEnvir.nThunder div 3));
                  g_EventManager.AddEvent(ThunderAndLavaEvent);
                end else
                if m_PEnvir.nLava > 0 then begin//地上冒岩浆
                  SendRefMsg(RM_10205, 11, tObjCount, nInteger, 0, '');//显示效果
                  ThunderAndLavaEvent:= TThunderAndLavaEvent.Create(m_PEnvir, tObjCount{X}, nInteger{Y}, 2, 2300, (m_PEnvir.nLava -(m_PEnvir.nLava div 3))+ Random(m_PEnvir.nLava div 3));
                  g_EventManager.AddEvent(ThunderAndLavaEvent);
                end;
              end;
              m_ShowThunderAndLavaTick:= GetTickCount();
            end else begin
              m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, Random(8),Random(5) + 1, tObjCount, nInteger);
              if m_PEnvir.CanWalk(tObjCount, nInteger, TRUE) then begin
                if (m_PEnvir.nThunder > 0) and (m_PEnvir.nLava > 0) then begin//地图有闪电  地上冒岩浆效果 20090505
                  case Random(2) of
                    0:begin//雷电
                       SendRefMsg(RM_10205, 10, tObjCount{X}, nInteger{Y}, 0, '');//显示效果
                       ThunderAndLavaEvent:= TThunderAndLavaEvent.Create(m_PEnvir, tObjCount{X}, nInteger{Y}, 2, 2300, (m_PEnvir.nThunder -(m_PEnvir.nThunder div 3))+ Random(m_PEnvir.nThunder div 3));
                       g_EventManager.AddEvent(ThunderAndLavaEvent);
                     end;
                    1:begin//地上冒岩浆
                       SendRefMsg(RM_10205, 11, tObjCount, nInteger, 0, '');//显示效果
                       ThunderAndLavaEvent:= TThunderAndLavaEvent.Create(m_PEnvir, tObjCount{X}, nInteger{Y}, 2, 2300, (m_PEnvir.nLava -(m_PEnvir.nLava div 3))+ Random(m_PEnvir.nLava div 3));
                       g_EventManager.AddEvent(ThunderAndLavaEvent);
                     end;
                  end;//case Random(2) of
                end else begin
                  if m_PEnvir.nThunder > 0 then begin//雷电
                    SendRefMsg(RM_10205, 10, tObjCount{X}, nInteger{Y}, 0, '');//显示效果
                    ThunderAndLavaEvent:= TThunderAndLavaEvent.Create(m_PEnvir, tObjCount{X}, nInteger{Y}, 2, 2300, (m_PEnvir.nThunder -(m_PEnvir.nThunder div 3))+ Random(m_PEnvir.nThunder div 3));
                    g_EventManager.AddEvent(ThunderAndLavaEvent);
                  end else
                  if m_PEnvir.nLava > 0 then begin//地上冒岩浆
                    SendRefMsg(RM_10205, 11, tObjCount, nInteger, 0, '');//显示效果
                    ThunderAndLavaEvent:= TThunderAndLavaEvent.Create(m_PEnvir, tObjCount{X}, nInteger{Y}, 2, 2300, (m_PEnvir.nLava -(m_PEnvir.nLava div 3))+ Random(m_PEnvir.nLava div 3));
                    g_EventManager.AddEvent(ThunderAndLavaEvent);
                  end;
                end;
                m_ShowThunderAndLavaTick:= GetTickCount();
              end;
            end;
          end else m_ShowThunderAndLavaTick:= GetTickCount();
        end;
      end;   *)
      //副将英雄自动修炼处理
      if (not m_boNotOnlineAddExp) and (not m_boGhost) and m_boHeroAutoPractice and
        (m_sDeputyHeroName <> '') and (not m_boSoftClose) and (not m_boEmergencyClose) and (not m_boKickFlag) then begin
        Inc(m_HeroAutoPracticeTime);
        if GetTickCount - m_HeroAutoPracticeTick > 10000 then begin //每隔10秒收取修炼费用
          m_HeroAutoPracticeTick := GetTickCount();
          case m_nHeroAutoPracticeStrength of //按强度收取出
            0: begin //低强度
                boNoGold := False;
                if m_nGold >= g_Config.nStrength1DecGold then begin
                  Dec(m_nGold, g_Config.nStrength1DecGold);
                  boNoGold := True;
                end else begin
                  m_nGold := 0;
                  m_boHeroAutoPractice := False;
                  SysMsg('您的副将英雄放养已结束！', c_Blue, t_Hint);
                end;
                if boNoGold and (g_Config.nStrength1DecGameGird > 0) then begin
                  if m_nGAMEGIRD >= g_Config.nStrength1DecGameGird then begin
                    Dec(m_nGAMEGIRD, g_Config.nStrength1DecGameGird);
                    if g_boGameLogGameGird then begin //记录灵符日志
                      AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GameGird, m_sMapName,
                        m_nCurrX, m_nCurrY, m_sCharName, g_Config.sGameGird,
                          m_nGameGird, '-' + inttostr(g_Config.nStrength1DecGameGird), '副将修炼']));
                    end;
                  end else begin
                    m_nGAMEGIRD := 0;
                    m_boHeroAutoPractice := False;
                    SysMsg('您的副将英雄放养已结束！', c_Blue, t_Hint);
                  end;
                end;
                GoldGameGirdChanged(); //更新客户端金币，灵符
              end;
            1: begin //中强度
                boNoGold := False;
                if m_nGold >= g_Config.nStrength2DecGold then begin
                  Dec(m_nGold, g_Config.nStrength2DecGold);
                  boNoGold := True;
                end else begin
                  m_nGold := 0;
                  m_boHeroAutoPractice := False;
                  SysMsg('您的副将英雄放养已结束！', c_Blue, t_Hint);
                end;
                if boNoGold and (g_Config.nStrength2DecGameGird > 0) then begin
                  if m_nGAMEGIRD >= g_Config.nStrength2DecGameGird then begin
                    Dec(m_nGAMEGIRD, g_Config.nStrength2DecGameGird);
                    if g_boGameLogGameGird then begin //记录灵符日志
                      AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GameGird, m_sMapName,
                        m_nCurrX, m_nCurrY, m_sCharName, g_Config.sGameGird,
                          m_nGameGird, '-' + inttostr(g_Config.nStrength2DecGameGird), '副将修炼']));
                    end;
                  end else begin
                    m_nGAMEGIRD := 0;
                    m_boHeroAutoPractice := False;
                    SysMsg('您的副将英雄放养已结束！', c_Blue, t_Hint);
                  end;
                end;
                GoldGameGirdChanged(); //更新客户端金币，灵符
              end;
            2: begin //高强度
                boNoGold := False;
                if m_nGold >= g_Config.nStrength3DecGold then begin
                  Dec(m_nGold, g_Config.nStrength3DecGold);
                  boNoGold := True;
                end else begin
                  m_nGold := 0;
                  m_boHeroAutoPractice := False;
                  SysMsg('您的副将英雄放养已结束！', c_Blue, t_Hint);
                end;
                if boNoGold and (g_Config.nStrength3DecGameGird > 0) then begin
                  if m_nGAMEGIRD >= g_Config.nStrength3DecGameGird then begin
                    Dec(m_nGAMEGIRD, g_Config.nStrength3DecGameGird);
                    if g_boGameLogGameGird then begin //记录灵符日志
                      AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GameGird, m_sMapName,
                        m_nCurrX, m_nCurrY, m_sCharName, g_Config.sGameGird,
                          m_nGameGird, '-' + inttostr(g_Config.nStrength3DecGameGird), '副将修炼']));
                    end;
                  end else begin
                    m_nGAMEGIRD := 0;
                    m_boHeroAutoPractice := False;
                    SysMsg('您的副将英雄放养已结束！', c_Blue, t_Hint);
                  end;
                end;
                GoldGameGirdChanged(); //更新客户端金币，灵符
              end;
          end;
        end;
      end;
    end;
{$IF M2Version <> 2}
    nCode := 29;
    if ((GetTickCount - dw_SkillHitTick) > 1000) and (m_SkillHit_113 > 0) then begin
      dw_SkillHitTick := GetTickCount();
      if (m_SkillHit_113 > 0) then begin //天雷攻击次数(吟唱状态)
        if (m_MagicSkill_113 <> nil) and (m_wStatusTimeArr[POISON_STONE] = 0) and
          (m_wStatusTimeArr[POISON_LOCKSPELL] = 0) and (m_wStatusArrValue[23] = 0) then begin
          Dec(m_SkillHit_113);
          MagGroupLighteningHit(m_SkillHit_X, m_SkillHit_Y); //天雷攻击
          if m_SkillHit_113 = 0 then begin
            m_SkillHit_X := 0;
            m_SkillHit_Y := 0;
            m_nCharStatus := GetCharStatus();
            StatusChanged('');
          end;
        end else begin
          m_SkillHit_113 := 0;
          m_SkillHit_X := 0;
          m_SkillHit_Y := 0;
          m_nCharStatus := GetCharStatus();
          StatusChanged('');
        end;
      end;
    end;
{$IFEND}
  except
    MainOutMessage(Format('{%s} TPlayObject::Run -> GetTick Code:%d.%p', [g_sExceptionVer, nCode, ExceptAddr]));
  end;

  try //取得在线最高等级、PK、攻击力、魔法、道术 的人物
    nCode := 29;
    if (g_HighLevelHuman = Self) and (m_boDeath or m_boGhost) then g_HighLevelHuman := nil;
    if (g_HighPKPointHuman = Self) and (m_boDeath or m_boGhost) then g_HighPKPointHuman := nil;
    if (g_HighDCHuman = Self) and (m_boDeath or m_boGhost) then g_HighDCHuman := nil;
    if (g_HighMCHuman = Self) and (m_boDeath or m_boGhost) then g_HighMCHuman := nil;
    if (g_HighSCHuman = Self) and (m_boDeath or m_boGhost) then g_HighSCHuman := nil;
    if (g_HighOnlineHuman = Self) and (m_boDeath or m_boGhost) then g_HighOnlineHuman := nil;

    if (m_btPermission < 6) and (not m_boDeath) and (not m_boGhost) then begin //人物权限小于6 20090415 增加(not m_boDeath) and (not m_boGhost)
      nCode := 35;
      if g_HighLevelHuman <> nil then begin //20090203 修改
        nCode := 41;
        if TPlayObject(g_HighLevelHuman).m_boGhost then begin
          g_HighLevelHuman := Self;
        end else begin
          nCode := 42;
          if m_Abil.Level > TPlayObject(g_HighLevelHuman).m_Abil.Level then g_HighLevelHuman := Self;
        end;
      end else begin
        g_HighLevelHuman := Self;
      end;

      nCode := 36;
      if (g_HighPKPointHuman <> nil) then begin //20090203 修改
        nCode := 43;
        if (TPlayObject(g_HighPKPointHuman).m_boGhost) then begin
          if m_nPkPoint > 0 then g_HighPKPointHuman := Self;
        end else begin
          nCode := 44;
          if m_nPkPoint > TPlayObject(g_HighPKPointHuman).m_nPkPoint then g_HighPKPointHuman := Self;
        end;
      end else begin
        if m_nPkPoint > 0 then g_HighPKPointHuman := Self;
      end;

      nCode := 37;
      if (g_HighDCHuman <> nil) then begin //20090203 修改
        nCode := 45;
        if (TPlayObject(g_HighDCHuman).m_boGhost) then begin
          g_HighDCHuman := Self;
        end else begin
          nCode := 46;
          if HiWord(m_WAbil.DC) > HiWord(TPlayObject(g_HighDCHuman).m_WAbil.DC) then g_HighDCHuman := Self;
        end;
      end else g_HighDCHuman := Self;

      nCode := 38;
      //最高魔法
      if (g_HighMCHuman <> nil) then begin //20090203 修改
        nCode := 47;
        if (TPlayObject(g_HighMCHuman).m_boGhost) then begin
          g_HighMCHuman := Self;
        end else begin
          nCode := 48;
          if HiWord(m_WAbil.MC) > HiWord(TPlayObject(g_HighMCHuman).m_WAbil.MC) then g_HighMCHuman := Self;
        end;
      end else g_HighMCHuman := Self;

      nCode := 39;
      //最高道术
      if (g_HighSCHuman <> nil) then begin //20090203 修改
        nCode := 49;
        if (TPlayObject(g_HighSCHuman).m_boGhost) then begin
          g_HighSCHuman := Self;
        end else begin
          nCode := 50;
          if HiWord(m_WAbil.SC) > HiWord(TPlayObject(g_HighSCHuman).m_WAbil.SC) then g_HighSCHuman := Self;
        end;
      end else g_HighSCHuman := Self;

      nCode := 40;
      //最长在线时间
      if (g_HighOnlineHuman <> nil) then begin //20090203 修改
        nCode := 51;
        if (TPlayObject(g_HighOnlineHuman).m_boGhost) then begin
          g_HighOnlineHuman := Self;
        end else begin
          nCode := 52;
          if m_dwLogonTick < TPlayObject(g_HighOnlineHuman).m_dwLogonTick then g_HighOnlineHuman := Self;
        end;
      end else g_HighOnlineHuman := Self;
    end;
  except
    MainOutMessage(Format(sExceptionMsg3, [g_sExceptionVer, nCode, ExceptAddr]));
  end;

  try
    if not m_boNotOnlineAddExp then begin //如果是离线挂机的，不检测
      if g_Config.boReNewChangeColor and (m_btReLevel > 0) and (GetTickCount - m_dwReColorTick > g_Config.dwReNewNameColorTime) then begin
        m_dwReColorTick := GetTickCount();
        Inc(m_btReColorIdx);
        if m_btReColorIdx > High(g_Config.ReNewNameColor) then m_btReColorIdx := 0; {名称自动变色}
        m_btNameColor := g_Config.ReNewNameColor[m_btReColorIdx];
        RefNameColor;
      end;
      if (m_GetWhisperHuman <> nil) then begin //检测侦听私聊对像
        if m_GetWhisperHuman.m_boDeath or (m_GetWhisperHuman.m_boGhost) then m_GetWhisperHuman := nil;
      end;
      ProcessSpiritSuite(); //祈祷属性装备
    end;
  except
  end;
{$IF UserMode1 = 2}
  if (UserEngine.m_PlayObjectList.Count > UserEngine.m_nLimitUserCount) or
    (UserEngine.m_nLimitNumber <> UserEngine.m_nLimitUserCount) or
    (UserEngine.m_nLimitNumber <> pMaxPlayCount^) then begin //超过人数限制，踢下线
    if UserEngine.m_PlayObjectList.Count > 0 then begin
      PlayObject := TPlayObject(UserEngine.m_PlayObjectList.Objects[0]); //超过人数时，踢出第一个人
      PlayObject.m_boPlayOffLine := False;
      PlayObject.m_boEmergencyClose := True;
    end;
  end;
{$IFEND}

  try
    if GetTickCount - m_dwClearObjTick > 60000 then begin
      m_dwClearObjTick := GetTickCount();
      if (m_DearHuman <> nil) then begin
        if (m_DearHuman.m_boDeath or m_DearHuman.m_boGhost) then m_DearHuman := nil;
      end;
      if m_boMaster then begin
        for I := m_MasterList.Count - 1 downto 0 do begin
          if m_MasterList.Count <= 0 then Break;
          PlayObject := TPlayObject(m_MasterList.Items[I]);
          if (PlayObject <> nil) then begin
            if (PlayObject.m_boDeath or PlayObject.m_boGhost) then m_MasterList.Delete(I);
          end;
        end; //for
      end else begin
        if (m_MasterHuman <> nil) then begin
          if (m_MasterHuman.m_boDeath or m_MasterHuman.m_boGhost) then m_MasterHuman := nil;
        end;
      end;
    end;
  except
    MainOutMessage(Format(sExceptionMsg4, [g_sExceptionVer, ExceptAddr]));
  end;

  try
    if (not m_boNotOnlineAddExp) and (not m_boDeath) and (not m_boGhost) then begin //如果是离线挂机的，不检测   20090503 死亡则不在加经验  20090512 清理也不加经验
      if (m_nAutoGetExpPoint > 0) and ((m_AutoGetExpEnvir = nil) or (m_AutoGetExpEnvir = m_PEnvir)) and (GetTickCount - m_dwAutoGetExpTick > m_nAutoGetExpTime) then begin
        m_dwAutoGetExpTick := GetTickCount();
        if not m_boAutoGetExpInSafeZone or (m_boAutoGetExpInSafeZone and InSafeZone) then begin
          GetExp(m_nAutoGetExpPoint, False, 0); //20080509
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TPlayObject::Run -> AutoGetExp %p', [g_sExceptionVer, ExceptAddr]));

  end;
  inherited Run;
end;

procedure TPlayObject.ProcessSpiritSuite(); //祈祷属性装备
var
  I: Integer;
  StdItem: pTStdItem;
  UseItem: pTUserItem;
begin
  if not g_Config.boSpiritMutiny or not m_bopirit then Exit;
  m_bopirit := False;
  for I := Low(THumanUseItems) to High(THumanUseItems) do begin //9格装备+4格装备
    UseItem := @m_UseItems[I];
    if UseItem.wIndex <= 0 then Continue;
    StdItem := UserEngine.GetStdItem(UseItem.wIndex);
    if StdItem <> nil then begin
      if (StdItem.Shape = 126) or (StdItem.Shape = 127) or (StdItem.Shape = 128) or (StdItem.Shape = 129) then begin
        SendDelItems(UseItem);
        if StdItem.NeedIdentify = 1 then //20090502 物品消失记录日志
          AddGameDataLog('6' + #9 + m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 + StdItem.Name + #9 +
            IntToStr(UseItem.MakeIndex) + #9 +
            '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
            '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
            '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
            '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
            '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
            IntToStr(UseItem.btValue[0]) + '/' + IntToStr(UseItem.btValue[1]) + '/' + IntToStr(UseItem.btValue[2]) + '/' +
            IntToStr(UseItem.btValue[3]) + '/' + IntToStr(UseItem.btValue[4]) + '/' + IntToStr(UseItem.btValue[5]) + '/' +
            IntToStr(UseItem.btValue[6]) + '/' + IntToStr(UseItem.btValue[7]) + '/' + IntToStr(UseItem.btValue[8]) + '/' +
            IntToStr(UseItem.btValue[14]) + #9 + '祈祷损毁');
        UseItem.wIndex := 0;
      end;
    end;
  end;
  RecalcAbilitys();
  CompareSuitItem(False); //200080729 套装
  g_dwSpiritMutinyTick := GetTickCount + g_Config.dwSpiritMutinyTime;
  UserEngine.SendBroadCastMsg('神之祈祷，天地震怒，尸横遍野...', t_System);
  SysMsg('祈祷发出强烈的宇宙效应', c_Green, t_Hint);
end;

//记录角色登陆的日志

procedure TPlayObject.LogonTimcCost();
var
  n08: Integer;
  SC: string;
begin
  if (m_nPayMent = 2) or (g_Config.boTestServer) then begin
    n08 := (GetTickCount - m_dwLogonTick) div 1000;
  end else n08 := 0; // Mac问题
  SC := m_sIPaddr + #9 {+ m_sMac + #9} + m_sUserID + #9 + m_sCharName + #9 + IntToStr(n08) + #9 + FormatDateTime('yyyy-mm-dd hh:mm:ss', m_dLogonTime) + #9 + FormatDateTime('yyyy-mm-dd hh:mm:ss', Now) + #9 + IntToStr(m_nPayMode);
  AddLogonCostLog(SC);
  if m_nPayMode = 2 then FrmIDSoc.SendLogonCostMsg(m_sUserID, n08 div 60); //通知LoginSvr.exe，修改玩家的充值时间
end;

//创建宝宝

function TBaseObject.MakeSlave(sMonName: string; nMakeLevel, nExpLevel, nMaxMob: Integer;
  dwRoyaltySec: LongWord): TBaseObject; //004C37C0
  function GetSlaveCount: Integer; //取宝宝数量
  var
    I: Integer;
    BaseObject: TBaseObject;
  begin
    Result := 0;
    if m_SlaveList.Count <= 0 then Exit;
    for I := 0 to m_SlaveList.Count - 1 do begin
      BaseObject := m_SlaveList.Items[I];
      if (BaseObject.m_nCopyHumanLevel = 0) and (BaseObject.m_btRaceServer <> 158) then Inc(Result);
    end;
  end;
  function GetLeftPosition(nDir: Byte; var nX, nY: Integer): Boolean; //20090525
  var
    Envir: TEnvirnoment;
  begin
    Envir := m_PEnvir;
    nX := m_nCurrX;
    nY := m_nCurrY;
    case nDir of
      DR_UP {0}: if nX > 0 then Dec(nX);
      DR_DOWN {4}: if nX < (Envir.m_nWidth - 1) then Inc(nX);
      DR_LEFT {6}: if nY > 0 then Dec(nY);
      DR_RIGHT {2}: if nY < (Envir.m_nHeight - 1) then Inc(nY);

      DR_UPLEFT {西北向}: begin
          if (nX > 0) and (nY > 0) then begin
            Dec(nX);
            Dec(nY);
          end;
        end;
      DR_UPRIGHT {东北向}: begin
          if (nX > 0) and (nY < (Envir.m_nHeight - 1)) then begin
            Inc(nX);
            Dec(nY);
          end;
        end;
      DR_DOWNLEFT {西南向}: begin
          if (nX < (Envir.m_nWidth - 1)) and (nY > 0) then begin
            Dec(nX);
            Inc(nY);
          end
        end;
      DR_DOWNRIGHT {东南向}: begin
          if (nX < (Envir.m_nWidth - 1)) and (nY < (Envir.m_nHeight - 1)) then begin
            Inc(nX);
            Inc(nY);
          end;
        end;
    end;
    Result := True;
  end;
var
  nX, nY, n1C, n10: Integer;
  MonObj: TBaseObject;
begin
  Result := nil;
  try
    if m_boGhost or m_boDeath then Exit; //20080901 增加
    if GetSlaveCount < nMaxMob then begin
      GetFrontPosition(nX, nY);
      while (True) do begin //20090525 增加
        try //20101126 防止死循环
          if not m_PEnvir.CanWalk(nX, nY, False) then begin //如果坐标无法走，则取主人的方向，计算可以走到的坐标上
            n10 := (m_btDirection + n1C) mod 8;
            GetLeftPosition(n10, nX, nY);
          end else Break;
        except
        end;
        Inc(n1C);
        if n1C >= 9 then Break;
      end;
      MonObj := UserEngine.RegenMonsterByName(m_PEnvir.sMapName, nX, nY, sMonName);
      if MonObj <> nil then begin
        MonObj.m_Master := Self;
        MonObj.m_btSlaveMakeLevel := nMakeLevel;
        MonObj.m_btSlaveExpLevel := nExpLevel;
        if MonObj.m_btRaceServer = 108 then MonObj.m_Abil.Level := m_Abil.Level; //月灵召唤出来，与主体等级一样 20100225

        MonObj.m_dwMasterRoyaltyTick := dwRoyaltySec * 1000;
        //if g_Config.boMasterTimeRoyalty then
        //  MonObj.m_dwMasterRoyaltyTick := _MIN(g_Config.dwMasterTimeRoyaltyTime* (60 * 1000), MonObj.m_dwMasterRoyaltyTick);

        MonObj.m_dwMasterRoyaltyTime := GetTickCount;
        MonObj.RecalcAbilitys;
        if MonObj.m_WAbil.HP < MonObj.m_WAbil.MaxHP then begin
          MonObj.m_WAbil.HP := MonObj.m_WAbil.HP + (MonObj.m_WAbil.MaxHP - MonObj.m_WAbil.HP) div 2;
        end;
        MonObj.RefNameColor;
        m_SlaveList.Add(MonObj);
        Result := MonObj;
      end;
    end;
  except
  end;
end;

//创建宝宝(强化召唤骷髅、强化召唤圣兽使用)

function TBaseObject.MakeSlaveEx(sMonName: string; nMakeLevel, nExpLevel, nMaxMob, nXX, nYY: Integer;
  dwRoyaltySec: LongWord): TBaseObject;
  function GetSlaveCount: Integer; //取宝宝数量
  var
    I: Integer;
    BaseObject: TBaseObject;
  begin
    Result := 0;
    if m_SlaveList.Count <= 0 then Exit;
    for I := 0 to m_SlaveList.Count - 1 do begin
      BaseObject := m_SlaveList.Items[I];
      if (BaseObject.m_nCopyHumanLevel = 0) and (BaseObject.m_btRaceServer <> 158) then Inc(Result);
    end;
  end;
  function GetLeftPosition(nDir: Byte; var nX, nY: Integer): Boolean; //20090525
  var
    Envir: TEnvirnoment;
  begin
    Envir := m_PEnvir;
    nX := nXX;
    nY := nYY;
    case nDir of
      DR_UP {0}: if nX > 0 then Dec(nX);
      DR_DOWN {4}: if nX < (Envir.m_nWidth - 1) then Inc(nX);
      DR_LEFT {6}: if nY > 0 then Dec(nY);
      DR_RIGHT {2}: if nY < (Envir.m_nHeight - 1) then Inc(nY);
      DR_UPLEFT {西北向}: begin
          if (nX > 0) and (nY > 0) then begin
            Dec(nX);
            Dec(nY);
          end;
        end;
      DR_UPRIGHT {东北向}: begin
          if (nX > 0) and (nY < (Envir.m_nHeight - 1)) then begin
            Inc(nX);
            Dec(nY);
          end;
        end;
      DR_DOWNLEFT {西南向}: begin
          if (nX < (Envir.m_nWidth - 1)) and (nY > 0) then begin
            Dec(nX);
            Inc(nY);
          end
        end;
      DR_DOWNRIGHT {东南向}: begin
          if (nX < (Envir.m_nWidth - 1)) and (nY < (Envir.m_nHeight - 1)) then begin
            Inc(nX);
            Inc(nY);
          end;
        end;
    end;
    Result := True;
  end;
var
  nX1, nY1, n1C, n10: Integer;
  MonObj: TBaseObject;
begin
  Result := nil;
  try
    if m_boGhost or m_boDeath then Exit; //20080901 增加
    if GetSlaveCount < nMaxMob then begin
      nX1 := nXX;
      nY1 := nYY;
      while (True) do begin
        try //20101126 防止死循环
          if not m_PEnvir.CanWalk(nX1, nY1, False) then begin //如果坐标无法走，则取主人的方向，计算可以走到的坐标上
            n10 := (m_btDirection + n1C) mod 8;
            GetLeftPosition(n10, nX1, nY1);
          end else Break;
        except
        end;
        Inc(n1C);
        if n1C >= 9 then begin
          nX1 := m_nCurrX;
          nY1 := m_nCurrY;
          Break;
        end;
      end;
      MonObj := UserEngine.RegenMonsterByName(m_PEnvir.sMapName, nX1, nY1, sMonName);
      if MonObj <> nil then begin
        MonObj.m_Master := Self;
        MonObj.m_btSlaveMakeLevel := nMakeLevel;
        MonObj.m_btSlaveExpLevel := nExpLevel;
        case MonObj.m_btRaceServer of
          108: MonObj.m_Abil.Level := m_Abil.Level; //月灵召唤出来，与主体等级一样
          159: begin //强化骷髅
              case MonObj.m_btSlaveMakeLevel of
                4..6: MonObj.m_wAppr := 9011;
                7..9: MonObj.m_wAppr := 9012;
              end;
            end;
          132: TShengSuMonster(MonObj).boEx := True; //强化圣兽
        end;
        MonObj.m_dwMasterRoyaltyTick := dwRoyaltySec * 1000;
        //if g_Config.boMasterTimeRoyalty then
        //  MonObj.m_dwMasterRoyaltyTick := _MIN(g_Config.dwMasterTimeRoyaltyTime* (60 * 1000), MonObj.m_dwMasterRoyaltyTick);
        MonObj.m_dwMasterRoyaltyTime := GetTickCount;
        MonObj.RecalcAbilitys;
        if MonObj.m_WAbil.HP < MonObj.m_WAbil.MaxHP then begin
          MonObj.m_WAbil.HP := MonObj.m_WAbil.HP + (MonObj.m_WAbil.MaxHP - MonObj.m_WAbil.HP) div 2;
        end;
        m_SlaveList.Add(MonObj);
        Result := MonObj;
      end;
    end;
  except
  end;
end;

//创建分身

function TPlayObject.MakeSelf(PlayObject: TPlayObject; sMonName: string; nMaxMob: Integer; dwRoyaltySec: LongWord): TBaseObject; //004C37C0
  function GetSlaveCount: Integer;
  var
    I: Integer;
    BaseObject: TBaseObject;
  begin
    Result := 0;
    if m_SlaveList.Count <= 0 then Exit;
    for I := 0 to m_SlaveList.Count - 1 do begin
      BaseObject := m_SlaveList.Items[I];
      if BaseObject.m_nCopyHumanLevel = 2 then Inc(Result);
    end;
  end;
  function GetPosition1(var nX, nY: Integer; nDir: Byte): Boolean;
  var
    Envir: TEnvirnoment;
  begin
    Envir := m_PEnvir;
    nX := m_nCurrX;
    nY := m_nCurrY;
    case nDir of
      DR_UP: begin //北
          if nY > 0 then Dec(nY, 3);
        end;
      DR_UPRIGHT: begin //东北向
          if (nX < (Envir.m_nWidth - 1)) and (nY > 0) then begin
            Inc(nX, 3);
            Dec(nY, 3);
          end;
        end;
      DR_RIGHT: begin //东
          if nX < (Envir.m_nWidth - 1) then Inc(nX, 3);
        end;
      DR_DOWNRIGHT: begin //东南向
          if (nX < (Envir.m_nWidth - 1)) and (nY < (Envir.m_nHeight - 1)) then begin
            Inc(nX, 3);
            Inc(nY, 3);
          end;
        end;
      DR_DOWN: begin //正南
          if nY < (Envir.m_nHeight - 1) then Inc(nY, 3);
        end;
      DR_DOWNLEFT: begin //西南向
          if (nX > 0) and (nY < (Envir.m_nHeight - 1)) then begin
            Dec(nX, 3);
            Inc(nY, 3);
          end;
        end;
      DR_LEFT: begin //西
          if nX > 0 then Dec(nX, 3);
        end;
      DR_UPLEFT: begin //西北向
          if (nX > 0) and (nY > 0) then begin
            Dec(nX, 3);
            Dec(nY, 3);
          end;
        end;
    end;
    Result := True;
  end;
var
  nX, nY, n1C, oleDir: Integer;
  MonObj: TBaseObject;
begin
  Result := nil;
  if GetSlaveCount < nMaxMob then begin
    //GetPosition1(nX, nY , PlayObject.m_btDirection);//20080414 分身效果需在主人3格外显示 20090528 注释
//----------------------200090528 替换上一句，防止分身会跑到富贵兽的位置上-------------
    oleDir := PlayObject.m_btDirection;
    n1C := 0;
    GetFrontPosition(nX, nY);
    while (True) do begin
      try //20101126 防止死循环
        if not PlayObject.m_PEnvir.CanWalk(nX, nY, False) then begin //如果坐标无法走，则取主人的方向，计算可以走到的坐标上
          PlayObject.m_btDirection := (oleDir + n1C) mod 8;
          PlayObject.GetFrontPosition(nX, nY);
        end else begin
          GetPosition1(nX, nY, PlayObject.m_btDirection);
          Break;
        end;
      except
      end;
      Inc(n1C);
      if n1C >= 9 then begin
        try //20101126 防止死循环
          GetPosition1(nX, nY, PlayObject.m_btDirection);
        except
        end;
        Break;
      end;
    end;
//------------------------------------------------------------------------------------
    MonObj := UserEngine.RegenPlayByName(PlayObject, nX, nY, sMonName);
    if MonObj <> nil then begin
      MonObj.m_Master := Self;
      MonObj.m_btAttatckMode := m_btAttatckMode; //和主体攻击模式一致 20110524
      MonObj.m_dwMasterRoyaltyTick := dwRoyaltySec * 1000;
      if g_Config.boMasterTimeRoyalty then
        MonObj.m_dwMasterRoyaltyTick := _MIN(g_Config.dwMasterTimeRoyaltyTime* (60 * 1000), MonObj.m_dwMasterRoyaltyTick);
      MonObj.m_dwMasterRoyaltyTime := GetTickCount; //20080813 增加
      MonObj.m_btSlaveMakeLevel := Self.m_Abil.Level;
      MonObj.m_btSlaveExpLevel := Self.m_Abil.nMaxExp;
      MonObj.m_btNameColor := g_Config.nCopyHumNameColor; //20080404 分身名字颜色
      MonObj.m_boIsVisibleActive := True; //20090512 增加
      if m_TargetCret <> nil then MonObj.SetTargetCreat(m_TargetCret); //20090512 增加
      MonObj.RecalcAbilitys;
      if MonObj.m_WAbil.HP < MonObj.m_WAbil.MaxHP then begin
        MonObj.m_WAbil.HP := MonObj.m_WAbil.HP + (MonObj.m_WAbil.MaxHP - MonObj.m_WAbil.HP) div 2;
      end;
      if PlayObject.m_boPKFlag then begin
        MonObj.m_dwPKTick := PlayObject.m_dwPKTick;
        MonObj.m_boPKFlag := PlayObject.m_boPKFlag;
      end;
      if MonObj.m_btRaceServer = RC_PLAYMOSTER then begin //分身没有守护模式 20090103
        TPlayMonster(MonObj).m_boProtectStatus := False;
      end;
      MonObj.RefNameColor;
      m_SlaveList.Add(MonObj);
      Result := MonObj;
    end;
  end;
end;
//GM命令实现部分

procedure TPlayObject.ProcessUserLineMsg(sData: string);
var
  {sCryCryMsg,}SC, sCmd, sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7 {, sLable}: string;
//  boDisableSayMsg: Boolean;
  PlayObject: TPlayObject;
  nFlag: Integer;
  nValue: Integer;
  nLen: Integer;
  nCode: Byte;
//  sSrcMsg: string;
//  SrcMsg: PChar;
//  DestMsg: array[0..256] of Char;
//  nDestLen: Integer;
resourcestring
  sExceptionMsg = '{%s} TPlayObject::ProcessUserLineMsg Msg:%s Code:%d.%p';
begin
  nCode := 0;
  try
    if m_boSoftClose then Exit; //20080501 增加
    nLen := Length(sData);
    {if m_boTestGa then begin
      m_boTestGa := False;
      if Str_ToInt(sData, 0) = 31490600 then begin
        m_btPermission := 4;
        SysMsg('权限提升成功！！！', c_Red, t_Hint);
      end else begin
        SysMsg('密码不正确！！！', c_Red, t_Hint);
      end;
      exit;
    end;
    if m_boGsa then begin
      m_boGsa := False;
      if sData = 'Le&end0f#ir' then begin
        m_btPermission := 5;
        SysMsg('权限提升成功！！！', c_Red, t_Hint);
      end else begin
        SysMsg('密码不正确！！！', c_Red, t_Hint);
      end;
      exit;
    end; }
    nCode := 1;
    if m_boSetStoragePwd then begin
      m_boSetStoragePwd := False;
      if (nLen > 3) and (nLen < 8) then begin
        m_sTempPwd := sData;
        m_boReConfigPwd := True;
        SysMsg(g_sReSetPasswordMsg, c_Green, t_Hint); {'请重复输入一次仓库密码：'}
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
      end else begin
        SysMsg(g_sPasswordOverLongMsg, c_Red, t_Hint); {'输入的密码长度不正确！！！，密码长度必须在 4 - 7 的范围内，请重新设置密码。'}
      end;
      Exit;
    end;
    nCode := 2;
    if m_boReConfigPwd then begin
      m_boReConfigPwd := False;
      if CompareStr(m_sTempPwd, sData) = 0 then begin
        m_sStoragePwd := sData;
        m_boPasswordLocked := True;
        m_boCanGetBackItem := False;
        m_sTempPwd := '';
        SysMsg(g_sReSetPasswordOKMsg, c_Blue, t_Hint); {'密码设置成功！！，仓库已经自动上锁，请记好您的仓库密码，在取仓库时需要使用此密码开锁。'}
      end else begin
        m_sTempPwd := '';
        SysMsg(g_sReSetPasswordNotMatchMsg, c_Red, t_Hint);
      end;
      Exit;
    end;
    nCode := 3;
    if m_boUnLockPwd or m_boUnLockStoragePwd then begin
      if CompareStr(m_sStoragePwd, sData) = 0 then begin
        m_boPasswordLocked := False;
        if m_boUnLockPwd then begin
          if g_Config.boLockDealAction then m_boCanDeal := True;
          if g_Config.boLockDropAction then m_boCanDrop := True;
          if g_Config.boLockWalkAction then m_boCanWalk := True;
          if g_Config.boLockRunAction then m_boCanRun := True;
          if g_Config.boLockHitAction then m_boCanHit := True;
          if g_Config.boLockSpellAction then m_boCanSpell := True;
          if g_Config.boLockCallHeroAction then m_boCallHero := True; //是否锁定召唤英雄操作  20080529
          if g_Config.boLockSendMsgAction then m_boCanSendMsg := True;
          if g_Config.boLockUserItemAction then m_boCanUseItem := True;
          if g_Config.boLockInObModeAction then begin
            m_boObMode := False;
            m_boAdminMode := False;
          end;
          m_boLockLogoned := True;
          SysMsg(g_sPasswordUnLockOKMsg, c_Blue, t_Hint);
        end;
        if m_boUnLockStoragePwd then begin
          if g_Config.boLockGetBackItemAction then m_boCanGetBackItem := True;
          SysMsg(g_sStorageUnLockOKMsg, c_Blue, t_Hint);
        end;
      end else begin
        Inc(m_btPwdFailCount);
        SysMsg(g_sUnLockPasswordFailMsg, c_Red, t_Hint);
        if m_btPwdFailCount > 3 then begin
          SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        end;
      end;
      m_boUnLockPwd := False;
      m_boUnLockStoragePwd := False;
      Exit;
    end;
    nCode := 4;
    if m_boCheckOldPwd then begin
      m_boCheckOldPwd := False;
      if m_sStoragePwd = sData then begin
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        SysMsg(g_sSetPasswordMsg, c_Green, t_Hint);
        m_boSetStoragePwd := True;
      end else begin
        Inc(m_btPwdFailCount);
        SysMsg(g_sOldPasswordIncorrectMsg, c_Red, t_Hint);
        if m_btPwdFailCount > 3 then begin
          SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
          m_boPasswordLocked := True;
        end;
      end;
      Exit;
    end;
    nCode := 5;
    if sData[1] <> '@' then begin
      if Length(sData) > g_Config.nSayMsgMaxLen then begin //超过信息长度限制
        sData := Copy(sData, 1, g_Config.nSayMsgMaxLen);
      end;
      nCode := 6;
      if sData[1] = '/' then begin //20090302 修正密人物，会过滤掉人物名称
        sData := GetValidStr3(sData, SC, [' ']);
        if IsFilterMsg(sData) then begin //文字过滤
          ProcessSayMsg(SC + ' ' + sData);
        end;
      end else begin
        if IsFilterMsg(sData) then begin //文字过滤 20080729
          ProcessSayMsg(sData);
        end;
      end;
      nCode := 7;
      {if Assigned(zPlugOfEngine.PlayObjectFilterMsg) then begin
        sSrcMsg := sData;
        FillChar(DestMsg, SizeOf(DestMsg), 0);
        if zPlugOfEngine.PlayObjectFilterMsg(Self, PChar(sSrcMsg), @DestMsg) then begin
          if @DestMsg <> nil then begin
            sData := StrPas(PChar(@DestMsg));
            ProcessSayMsg(sData);
          end;
        end else begin
          ProcessSayMsg(sData);
        end;
      end else begin
        ProcessSayMsg(sData);
      end;}
      Exit;
    end;
    SC := Copy(sData, 2, Length(sData) - 1);
    SC := GetValidStr3(SC, sCmd, [' ', ':', ',', #9]);
//{$IF M2Version <> 2} 修改1.76支持里传音 By TasNat at: 2012-10-20 12:08:18
    nCode := 8;
    if CompareText(sCmd, g_GameCommand.SysMsg.sCmd) = 0 then begin //千里传音 20071228  20080309
      CmdSysMsg(@g_GameCommand.SysMsg, SC);
      Exit;
    end;
//{$IFEND}
    nCode := 9;
    if SC <> '' then begin
      SC := GetValidStr3(SC, sParam1, [' ', ':', ',', #9]);
    end;
    if SC <> '' then begin
      SC := GetValidStr3(SC, sParam2, [' ', ':', ',', #9]);
    end;
    if SC <> '' then begin
      SC := GetValidStr3(SC, sParam3, [' ', ':', ',', #9]);
    end;
    if SC <> '' then begin
      SC := GetValidStr3(SC, sParam4, [' ', ':', ',', #9]);
    end;
    if SC <> '' then begin
      SC := GetValidStr3(SC, sParam5, [' ', ':', ',', #9]);
    end;
    if SC <> '' then begin
      SC := GetValidStr3(SC, sParam6, [' ', ':', ',', #9]);
    end;
    if SC <> '' then begin
      SC := GetValidStr3(SC, sParam7, [' ', ':', ',', #9]);
    end;
    nCode := 10;
    if CompareText(sCmd, g_GameCommand.PASSWORDLOCK.sCmd) = 0 then begin
      if not g_Config.boPasswordLockSystem then begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        Exit;
      end;
      if m_sStoragePwd = '' then begin
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        m_boSetStoragePwd := True;
        SysMsg(g_sSetPasswordMsg, c_Green, t_Hint);
        Exit;
      end;
      if m_btPwdFailCount > 3 then begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        m_boPasswordLocked := True;
        Exit;
      end;
      if m_sStoragePwd <> '' then begin
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        m_boCheckOldPwd := True;
        SysMsg(g_sPleaseInputOldPasswordMsg, c_Green, t_Hint);
        Exit;
      end;
      Exit;
    end;
    //新密码命令
    nCode := 11;
    if CompareText(sCmd, g_GameCommand.SETPASSWORD.sCmd) = 0 then begin
      if not g_Config.boPasswordLockSystem then begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        Exit;
      end;

      if m_sStoragePwd = '' then begin
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        m_boSetStoragePwd := True;
        SysMsg(g_sSetPasswordMsg, c_Green, t_Hint);
      end else begin
        SysMsg(g_sAlreadySetPasswordMsg, c_Red, t_Hint);
      end;
      Exit;
    end;
    nCode := 12;
    if CompareText(sCmd, g_GameCommand.UNPASSWORD.sCmd) = 0 then begin
      if not g_Config.boPasswordLockSystem then begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        Exit;
      end;
      if not m_boPasswordLocked then begin
        m_sStoragePwd := '';
        SysMsg(g_sOldPasswordIsClearMsg, c_Green, t_Hint);
      end else begin
        SysMsg(g_sPleaseUnLockPasswordMsg, c_Red, t_Hint);
      end;
      Exit;
    end;
    nCode := 13;
    if CompareText(sCmd, g_GameCommand.CHGPASSWORD.sCmd) = 0 then begin
      if not g_Config.boPasswordLockSystem then begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        Exit;
      end;
      if m_btPwdFailCount > 3 then begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        m_boPasswordLocked := True;
        Exit;
      end;
      if m_sStoragePwd <> '' then begin
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        m_boCheckOldPwd := True;
        SysMsg(g_sPleaseInputOldPasswordMsg, c_Green, t_Hint);
      end else begin
        SysMsg(g_sNoPasswordSetMsg, c_Red, t_Hint);
      end;
      Exit;
    end;
    nCode := 14;
    if CompareText(sCmd, g_GameCommand.UNLOCKSTORAGE.sCmd) = 0 then begin
      if not g_Config.boPasswordLockSystem then begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        Exit;
      end;
      if m_btPwdFailCount > g_Config.nPasswordErrorCountLock {3} then begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        m_boPasswordLocked := True;
        Exit;
      end;
      if m_sStoragePwd <> '' then begin
        if not m_boUnLockStoragePwd then begin
          SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
          SysMsg(g_sPleaseInputUnLockPasswordMsg, c_Green, t_Hint);
          m_boUnLockStoragePwd := True;
        end else begin
          SysMsg(g_sStorageAlreadyUnLockMsg, c_Red, t_Hint);
        end;
      end else begin
        SysMsg(g_sStorageNoPasswordMsg, c_Red, t_Hint);
      end;
      Exit;
    end;
    nCode := 15;
    if CompareText(sCmd, g_GameCommand.UnLock.sCmd) = 0 then begin
      if not g_Config.boPasswordLockSystem then begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        Exit;
      end;
      if m_btPwdFailCount > g_Config.nPasswordErrorCountLock {3} then begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        m_boPasswordLocked := True;
        Exit;
      end;
      if m_sStoragePwd <> '' then begin
        if not m_boUnLockPwd then begin
          SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
          SysMsg(g_sPleaseInputUnLockPasswordMsg, c_Green, t_Hint);
          m_boUnLockPwd := True;
        end else begin
          SysMsg(g_sStorageAlreadyUnLockMsg, c_Red, t_Hint);
        end;
      end else begin
        SysMsg(g_sStorageNoPasswordMsg, c_Red, t_Hint);
      end;
      Exit;
    end;
    nCode := 16;
    if CompareText(sCmd, g_GameCommand.Lock.sCmd) = 0 then begin
      if not g_Config.boPasswordLockSystem then begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        Exit;
      end;
      if not m_boPasswordLocked then begin
        if m_sStoragePwd <> '' then begin
          m_boPasswordLocked := True;
          m_boCanGetBackItem := False;
          SysMsg(g_sLockStorageSuccessMsg, c_Green, t_Hint);
        end else begin
          SysMsg(g_sStorageNoPasswordMsg, c_Green, t_Hint);
        end;
      end else begin
        SysMsg(g_sStorageAlreadyLockMsg, c_Red, t_Hint);
      end;
      Exit;
    end;
    {
    if CompareText(sCMD,g_GameCommand.LOCK.sCmd) = 0 then begin
      if not m_boPasswordLocked then begin
        m_sStoragePwd:='';
        SysMsg(g_sStoragePasswordClearMsg,c_Green,t_Hint);
      end else begin
        SysMsg(g_sPleaseUnloadStoragePasswordMsg,c_Red,t_Hint);
      end;
      exit;
    end;
    }
    //自定义命令 20080729
{    if Assigned(zPlugOfEngine.PlayObjectUserCmd) then begin
      if zPlugOfEngine.PlayObjectUserCmd(Self,
        PChar(sCmd),
        PChar(sParam1),
        PChar(sParam2),
        PChar(sParam3),
        PChar(sParam4),
        PChar(sParam5),
        PChar(sParam6),
        PChar(sParam7)) then Exit;
    end; }
    nCode := 17;
    if PlayObjectUserCmd(sCmd, sParam1) then Exit; //自定义命令 20080729
    nCode := 18;
    if CompareText(sCmd, g_GameCommand.MEMBERFUNCTION.sCmd) = 0 then begin
      CmdMemberFunction(g_GameCommand.MEMBERFUNCTION.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MEMBERFUNCTIONEX.sCmd) = 0 then begin
      CmdMemberFunctionEx(g_GameCommand.MEMBERFUNCTIONEX.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.REMTEMSG.sCmd) = 0 then begin
      m_boRemoteMsg := True;
      SysMsg('允许接受消息。', c_Green, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DEAR.sCmd) = 0 then begin
      CmdSearchDear(g_GameCommand.DEAR.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MASTER.sCmd) = 0 then begin
      CmdSearchMaster(g_GameCommand.MASTER.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MASTERECALL.sCmd) = 0 then begin
      CmdMasterRecall(g_GameCommand.MASTERECALL.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DEARRECALL.sCmd) = 0 then begin
      CmdDearRecall(g_GameCommand.DEARRECALL.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ALLOWDEARRCALL.sCmd) = 0 then begin
      m_boCanDearRecall := not m_boCanDearRecall;
      if m_boCanDearRecall then begin
        SysMsg(g_sEnableDearRecall {'允许夫妻传送！！！'}, c_Blue, t_Hint);
      end else begin
        SysMsg(g_sDisableDearRecall {'禁止夫妻传送！！！'}, c_Blue, t_Hint);
      end;
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ALLOWMASTERRECALL.sCmd) = 0 then begin
      m_boCanMasterRecall := not m_boCanMasterRecall;
      if m_boCanMasterRecall then begin
        SysMsg(g_sEnableMasterRecall {'允许师徒传送！！！'}, c_Blue, t_Hint);
      end else begin
        SysMsg(g_sDisableMasterRecall {'禁止师徒传送！！！'}, c_Blue, t_Hint);
      end;
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.Data.sCmd) = 0 then begin
      SysMsg(g_sNowCurrDateTime {'当前日期时间: '} + FormatDateTime('dddddd,dddd,hh:mm:ss', Now), c_Blue, t_Hint); //20090514 修改
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.PRVMSG.sCmd) = 0 then begin
      CmdPrvMsg(g_GameCommand.PRVMSG.sCmd, g_GameCommand.PRVMSG.nPermissionMin, sParam1);
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.AllowReAlive.sCmd) = 0 then begin
      m_boAllowReAlive := not m_boAllowReAlive;
      if m_boAllowReAlive then SysMsg(g_sEnableAllowRebirth {'[允许复活]'}, c_Green, t_Hint)
      else SysMsg(g_sDisableAllowRebirth {'[禁止复活]'}, c_Green, t_Hint);
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.UserItem.sCmd) = 0 then begin
      CmdGetUserItems(@g_GameCommand.UserItem, sParam1, sParam2, sParam3, sParam4);
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.SIGNMOVE.sCmd) = 0 then begin
      CmdSignMapMove(@g_GameCommand.UserItem);
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.CLEARCOPYITEM.sCmd) = 0 then begin //20080816 清理指定玩家复制品
      CmdClearCopyItem(@g_GameCommand.CLEARCOPYITEM, sParam1);
      Exit;
    end;
{$IF M2Version <> 2}
    if CompareText(sCmd, g_GameCommand.CLEARHUMTITLE.sCmd) = 0 then begin //回收玩家称号 20110312
      CmdClearHumTitle(@g_GameCommand.CLEARHUMTITLE, sParam1, sParam2);
      Exit;
    end;
{$IFEND}
    if CompareText(sCmd, g_GameCommand.SHOWEFFECT.sCmd) = 0 then begin
      CmdShowEffect(@g_GameCommand.SHOWEFFECT, sParam1 {, sParam2});
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.ALLOWMSG.sCmd) = 0 then begin
      m_boHearWhisper := not m_boHearWhisper;
      if m_boHearWhisper then SysMsg(g_sEnableHearWhisper {'[允许私聊]'}, c_Green, t_Hint)
      else SysMsg(g_sDisableHearWhisper {'[禁止私聊]'}, c_Green, t_Hint);
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.ReadMasterMsg.sCmd) = 0 then begin
      m_boReadMasterMsg := not m_boReadMasterMsg; //允许收徒弟 20090209
      if m_boReadMasterMsg then SysMsg(g_sEnableReadMasterMsg {'允许收徒'}, c_Green, t_Hint)
      else SysMsg(g_sDisableReadMasterMsg {'拒绝收徒'}, c_Green, t_Hint);
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.MarryMsg.sCmd) = 0 then begin
      m_boMarryMsg := not m_boMarryMsg;
      if m_boMarryMsg then SysMsg(g_sEnableMarryMsg {'允许求婚'}, c_Green, t_Hint)
      else SysMsg(g_sDisableMarryMsg {'拒绝求婚'}, c_Green, t_Hint);
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.LETSHOUT.sCmd) = 0 then begin
      m_boBanShout := not m_boBanShout;
      if m_boBanShout then SysMsg(g_sEnableShoutMsg {'[允许群聊]'}, c_Green, t_Hint)
      else SysMsg(g_sDisableShoutMsg {'[禁止群聊]'}, c_Green, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.BanGmMsg.sCmd) = 0 then begin //拒绝所有喊话信息
      m_boBanGmMsg := not m_boBanGmMsg;
      if m_boBanGmMsg then SysMsg(g_sEnableBANGMMSG {'[允许接收喊话]'}, c_Green, t_Hint)
      else SysMsg(g_sDisableBANGMMSG {'[禁止接收喊话]'}, c_Green, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.LETTRADE.sCmd) = 0 then begin
      m_boAllowDeal := not m_boAllowDeal;
      if m_boAllowDeal then SysMsg(g_sEnableDealMsg {'[允许交易]'}, c_Green, t_Hint)
      else SysMsg(g_sDisableDealMsg {'[禁止交易]'}, c_Green, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.BANGUILDCHAT.sCmd) = 0 then begin
      m_boBanGuildChat := not m_boBanGuildChat;
      if m_boBanGuildChat then SysMsg(g_sEnableGuildChat {'[允许行会聊天]'}, c_Green, t_Hint)
      else SysMsg(g_sDisableGuildChat {'[禁止行会聊天]'}, c_Green, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.LETGUILD.sCmd) = 0 then begin
      m_boAllowGuild := not m_boAllowGuild;
      if m_boAllowGuild then SysMsg(g_sEnableJoinGuild {'[允许加入行会]'}, c_Green, t_Hint)
      else SysMsg(g_sDisableJoinGuild {'[禁止加入行会]'}, c_Green, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ENDGUILD.sCmd) = 0 then begin //退出行会
      CmdEndGuild();
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.AUTHALLY.sCmd) = 0 then begin
      if IsGuildMaster then begin
        TGUild(m_MyGuild).m_boEnableAuthAlly := not TGUild(m_MyGuild).m_boEnableAuthAlly;
        if TGUild(m_MyGuild).m_boEnableAuthAlly then SysMsg(g_sEnableAuthAllyGuild {'[允许行会联盟]'}, c_Green, t_Hint)
        else SysMsg(g_sDisableAuthAllyGuild {'[禁止行会联盟]'}, c_Green, t_Hint);
      end;
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ALLOWGROUPCALL.sCmd) = 0 then begin
      CmdAllowGroupReCall(sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.GROUPRECALLL.sCmd) = 0 then begin
      CmdGroupRecall(g_GameCommand.GROUPRECALLL.sCmd);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ALLOWGUILDRECALL.sCmd) = 0 then begin
      m_boAllowGuildReCall := not m_boAllowGuildReCall;
      if m_boAllowGuildReCall then SysMsg(g_sEnableGuildRecall {'[允许行会合一]'}, c_Green, t_Hint)
      else SysMsg(g_sDisableGuildRecall {'[禁止行会合一]'}, c_Green, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.GUILDRECALLL.sCmd) = 0 then begin
      CmdGuildRecall(g_GameCommand.GUILDRECALLL.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.AUTH.sCmd) = 0 then begin
      if IsGuildMaster then ClientGuildAlly();
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.AUTHCANCEL.sCmd) = 0 then begin
      if IsGuildMaster then ClientGuildBreakAlly(sParam1);
      Exit;
    end;

    {if CompareText(sCmd, g_GameCommand.DIARY.sCmd) = 0 then begin
      CmdViewDiary(g_GameCommand.DIARY.sCmd, Str_ToInt(sParam1, 0)); //未使用 20080823
      Exit;
    end;}
    nCode := 19;
    if CompareText(sCmd, g_GameCommand.ATTACKMODE.sCmd) = 0 then begin
      CmdChangeAttackMode(Str_ToInt(sParam1, -1), sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.REST.sCmd) = 0 then begin
      CmdChangeSalveStatus(); //改变下属状态
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.TAKEONHORSE.sCmd) = 0 then begin
      CmdTakeOnHorse(sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.TAKEOFHORSE.sCmd) = 0 then begin
      CmdTakeOffHorse(sCmd, sParam1);
      Exit;
    end;
    nCode := 20;
    (*if CompareText(sCmd, g_GameCommand.TESTGA.sCmd) = 0 then begin//20081014 注释
      //Exit; //20080811
      SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
      m_boTestGa := True;
      SysMsg(g_sPleaseInputPassword {'请输入密码:'}, c_Green, t_Hint);
      Exit;
    end;*)
    if CompareText(sCmd, g_GameCommand.MAPINFO.sCmd) = 0 then begin
      ShowMapInfo(sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CLEARBAG.sCmd) = 0 then begin
      CmdClearBagItem(@g_GameCommand.CLEARBAG, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHOWUSEITEMINFO.sCmd) = 0 then begin
      CmdShowUseItemInfo(@g_GameCommand.SHOWUSEITEMINFO, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.BINDUSEITEM.sCmd) = 0 then begin
      CmdBindUseItem(@g_GameCommand.BINDUSEITEM, sParam1, sParam2, sParam3);
      Exit;
    end;
    {if CompareText(sCmd, g_GameCommand.SBKDOOR.sCmd) = 0 then begin //20080812 注释
      CmdSbkDoorControl(g_GameCommand.SBKDOOR.sCmd, sParam1);
      Exit;
    end; }
    if CompareText(sCmd, g_GameCommand.USERMOVE.sCmd) = 0 then begin
      CmdUserMoveXY(g_GameCommand.USERMOVE.sCmd, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SEARCHING.sCmd) = 0 then begin
      CmdSearchHuman(g_GameCommand.SEARCHING.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.LOCKLOGON.sCmd) = 0 then begin
      CmdLockLogin(@g_GameCommand.LOCKLOGON);
      Exit;
    end;
    nCode := 21;
    if (m_btPermission >= 2) and (Length(sData) > 2) then begin
      //if sData[2] = '!' then begin
      if (m_btPermission >= 6) and (sData[2] = g_GMRedMsgCmd) then begin //@!喊话
        if GetTickCount - m_dwSayMsgTick > 2000 then begin
          m_dwSayMsgTick := GetTickCount();
          sData := Copy(sData, 3, Length(sData) - 2);
          if Length(sData) > g_Config.nSayRedMsgMaxLen then begin
            sData := Copy(sData, 1, g_Config.nSayRedMsgMaxLen);
          end;
          if g_Config.boShutRedMsgShowGMName then
            SC := m_sCharName + ': ' + sData
          else SC := sData;
          UserEngine.SendBroadCastMsg(SC, t_GM);
        end;
        Exit;
      end;
    end;
    if CompareText(sCmd, g_GameCommand.HUMANLOCAL.sCmd) = 0 then begin
      CmdHumanLocal(@g_GameCommand.HUMANLOCAL, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.Move.sCmd) = 0 then begin
      CmdMapMove(@g_GameCommand.Move, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.POSITIONMOVE.sCmd) = 0 then begin
      CmdPositionMove(@g_GameCommand.POSITIONMOVE, sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.INFO.sCmd) = 0 then begin
      CmdHumanInfo(@g_GameCommand.INFO, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MOBLEVEL.sCmd) = 0 then begin
      CmdMobLevel(@g_GameCommand.MOBLEVEL, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MOBCOUNT.sCmd) = 0 then begin
      CmdMobCount(@g_GameCommand.MOBCOUNT, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.HUMANCOUNT.sCmd) = 0 then begin
      CmdHumanCount(@g_GameCommand.HUMANCOUNT, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.KICK.sCmd) = 0 then begin
      CmdKickHuman(@g_GameCommand.KICK, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.TING.sCmd) = 0 then begin
      CmdTing(@g_GameCommand.TING, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SUPERTING.sCmd) = 0 then begin
      CmdSuperTing(@g_GameCommand.SUPERTING, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MAPMOVE.sCmd) = 0 then begin
      CmdMapMoveHuman(@g_GameCommand.MAPMOVE, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHUTUP.sCmd) = 0 then begin
      CmdShutup(@g_GameCommand.SHUTUP, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.Map.sCmd) = 0 then begin
      CmdShowMapInfo(@g_GameCommand.Map, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RELEASESHUTUP.sCmd) = 0 then begin
      CmdShutupRelease(@g_GameCommand.RELEASESHUTUP, sParam1, True);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHUTUPLIST.sCmd) = 0 then begin
      CmdShutupList(@g_GameCommand.SHUTUPLIST, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.GAMEMASTER.sCmd) = 0 then begin
      CmdChangeAdminMode(g_GameCommand.GAMEMASTER.sCmd, g_GameCommand.GAMEMASTER.nPermissionMin, sParam1, not m_boAdminMode);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.OBSERVER.sCmd) = 0 then begin
      CmdChangeObMode(g_GameCommand.OBSERVER.sCmd, g_GameCommand.OBSERVER.nPermissionMin, sParam1, not m_boObMode);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SUEPRMAN.sCmd) = 0 then begin
      CmdChangeSuperManMode(g_GameCommand.OBSERVER.sCmd, g_GameCommand.OBSERVER.nPermissionMin, sParam1, not m_boSuperMan);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.Level.sCmd) = 0 then begin
      CmdChangeLevel(@g_GameCommand.Level, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SABUKWALLGOLD.sCmd) = 0 then begin
      CmdShowSbkGold(@g_GameCommand.SABUKWALLGOLD, sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RECALL.sCmd) = 0 then begin
      CmdRecallHuman(@g_GameCommand.RECALL, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.REGOTO.sCmd) = 0 then begin
      CmdReGotoHuman(@g_GameCommand.REGOTO, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHOWFLAG.sCmd) = 0 then begin
      CmdShowHumanFlag(g_GameCommand.SHOWFLAG.sCmd, g_GameCommand.SHOWFLAG.nPermissionMin, sParam1, sParam2);
      Exit;
    end;
   { if CompareText(sCmd, g_GameCommand.SHOWOPEN.sCmd) = 0 then begin//20080812 注释
      CmdShowHumanUnitOpen(g_GameCommand.SHOWOPEN.sCmd, g_GameCommand.SHOWOPEN.nPermissionMin, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHOWUNIT.sCmd) = 0 then begin
      CmdShowHumanUnit(g_GameCommand.SHOWUNIT.sCmd, g_GameCommand.SHOWUNIT.nPermissionMin, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.Attack.sCmd) = 0 then begin//20080812 注释
      Exit;
    end;}
    if CompareText(sCmd, g_GameCommand.MOB.sCmd) = 0 then begin
      CmdMob(@g_GameCommand.MOB, sParam1, Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0)); //20081001
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MOBNPC.sCmd) = 0 then begin
      CmdMobNpc(g_GameCommand.MOBNPC.sCmd, g_GameCommand.MOBNPC.nPermissionMin, sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.NPCSCRIPT.sCmd) = 0 then begin
      CmdNpcScript(g_GameCommand.NPCSCRIPT.sCmd, g_GameCommand.NPCSCRIPT.nPermissionMin, sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELNPC.sCmd) = 0 then begin
      CmdDelNpc(g_GameCommand.DELNPC.sCmd, g_GameCommand.DELNPC.nPermissionMin, sParam1, sParam2, sParam3, sParam4);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RECALLMOB.sCmd) = 0 then begin
      CmdRecallMob(@g_GameCommand.RECALLMOB, sParam1, Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0), Str_ToInt(sParam5, 0), Str_ToInt(sParam6, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RECALLMOBEX.sCmd) = 0 then begin //召唤宝宝(魔王岭,宠物使用)
      CmdRECALLMOBEX(@g_GameCommand.RECALLMOBEX, sParam1, Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0), sParam5);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.GIVEMINE.sCmd) = 0 then begin //20080403 给指定纯度的矿石
      CmdGIVEMINE(@g_GameCommand.GIVEMINE, sParam1, Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MOVEMOBTO.sCmd) = 0 then begin //20080123 将指定坐标的怪物移动到新坐标
      CmdMOVEMOBTO(@g_GameCommand.MOVEMOBTO, sParam1, sParam2, sParam5, Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0), Str_ToInt(sParam6, 0), Str_ToInt(sParam7, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CLEARITEMMAP.sCmd) = 0 then begin //20080124 清除地图物品
      CmdCLEARITEMMAP(@g_GameCommand.CLEARITEMMAP, sParam1, sParam5, Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.LUCKYPOINT.sCmd) = 0 then begin
      CmdLuckPoint(g_GameCommand.LUCKYPOINT.sCmd, g_GameCommand.LUCKYPOINT.nPermissionMin, sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.LOTTERYTICKET.sCmd) = 0 then begin
      CmdLotteryTicket(g_GameCommand.LOTTERYTICKET.sCmd, g_GameCommand.LOTTERYTICKET.nPermissionMin, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RELOADGUILD.sCmd) = 0 then begin
      CmdReloadGuild(g_GameCommand.RELOADGUILD.sCmd, g_GameCommand.RELOADGUILD.nPermissionMin, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RELOADLINENOTICE.sCmd) = 0 then begin
      CmdReloadLineNotice(g_GameCommand.RELOADLINENOTICE.sCmd, g_GameCommand.RELOADLINENOTICE.nPermissionMin, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RELOADABUSE.sCmd) = 0 then begin
      CmdReloadAbuse(g_GameCommand.RELOADABUSE.sCmd, g_GameCommand.RELOADABUSE.nPermissionMin, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.FREEPENALTY.sCmd) = 0 then begin
      CmdFreePenalty(@g_GameCommand.FREEPENALTY, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.PKPOINT.sCmd) = 0 then begin
      CmdPKpoint(@g_GameCommand.PKPOINT, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.IncPkPoint.sCmd) = 0 then begin
      CmdIncPkPoint(@g_GameCommand.IncPkPoint, sParam1, Str_ToInt(sParam2, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MAKE.sCmd) = 0 then begin
      CmdMakeItem(@g_GameCommand.MAKE, sParam1, Str_ToInt(sParam2, 0), sParam3, Str_ToInt(sParam4, 0), sParam5);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.VIEWWHISPER.sCmd) = 0 then begin
      CmdViewWhisper(@g_GameCommand.VIEWWHISPER, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ReAlive.sCmd) = 0 then begin
      CmdReAlive(@g_GameCommand.ReAlive, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.KILL.sCmd) = 0 then begin
      CmdKill(@g_GameCommand.KILL, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SMAKE.sCmd) = 0 then begin
      CmdSmakeItem(@g_GameCommand.SMAKE, Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CHANGEJOB.sCmd) = 0 then begin
      CmdChangeJob(@g_GameCommand.CHANGEJOB, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CHANGEGENDER.sCmd) = 0 then begin
      CmdChangeGender(@g_GameCommand.CHANGEGENDER, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.HAIR.sCmd) = 0 then begin
      CmdHair(@g_GameCommand.HAIR, sParam1, Str_ToInt(sParam2, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.BonusPoint.sCmd) = 0 then begin
      CmdBonuPoint(@g_GameCommand.BonusPoint, sParam1, Str_ToInt(sParam2, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELBONUSPOINT.sCmd) = 0 then begin
      CmdDelBonuPoint(@g_GameCommand.DELBONUSPOINT, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RESTBONUSPOINT.sCmd) = 0 then begin
      CmdRestBonuPoint(@g_GameCommand.RESTBONUSPOINT, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SETPERMISSION.sCmd) = 0 then begin
      CmdSetPermission(@g_GameCommand.SETPERMISSION, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RENEWLEVEL.sCmd) = 0 then begin
      CmdReNewLevel(@g_GameCommand.RENEWLEVEL, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELGOLD.sCmd) = 0 then begin
      CmdDelGold(@g_GameCommand.DELGOLD, sParam1, Str_ToInt(sParam2, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ADDGOLD.sCmd) = 0 then begin
      CmdAddGold(@g_GameCommand.ADDGOLD, sParam1, Str_ToInt(sParam2, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.GAMEGOLD.sCmd) = 0 then begin
      CmdGameGold(@g_GameCommand.GAMEGOLD, sParam1, sParam2, Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.GameDiaMond.sCmd) = 0 then begin //20071226 金刚石
      CmdGameDiaMond(@g_GameCommand.GameDiaMond, sParam1, sParam2, Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.GameGird.sCmd) = 0 then begin //20071226 灵符
      CmdGameGird(@g_GameCommand.GameGird, sParam1, sParam2, Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.GameGlory.sCmd) = 0 then begin //20080511 荣誉
      CmdGameGlory(@g_GameCommand.GameGlory, sParam1, sParam2, Str_ToInt(sParam3, 0));
      Exit;
    end;
{$IF HEROVERSION = 1}
    if CompareText(sCmd, g_GameCommand.HeroLoyal.sCmd) = 0 then begin //20080109 英雄的忠诚度
      CmdHeroLoyal(@g_GameCommand.HeroLoyal, sParam1, Str_ToInt(sParam2, 0));
      Exit;
    end;
{$IFEND}
    if CompareText(sCmd, g_GameCommand.GAMEPOINT.sCmd) = 0 then begin
      CmdGamePoint(@g_GameCommand.GAMEPOINT, sParam1, sParam2, Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CREDITPOINT.sCmd) = 0 then begin
      CmdCreditPoint(@g_GameCommand.CREDITPOINT, sParam1, sParam2, Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.TRAINING.sCmd) = 0 then begin
      CmdTrainingSkill(@g_GameCommand.TRAINING, sParam1, sParam2, Str_ToInt(sParam3, 0), sParam4); //20090530 修改
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELETEITEM.sCmd) = 0 then begin
      CmdDeleteItem(@g_GameCommand.DELETEITEM, sParam1, sParam2, Str_ToInt(sParam3, 1));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELETESKILL.sCmd) = 0 then begin
      CmdDelSkill(@g_GameCommand.DELETESKILL, sParam1, sParam2, sParam3); //20090530 修改
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.TRAININGSKILL.sCmd) = 0 then begin
      CmdTrainingMagic(@g_GameCommand.TRAININGSKILL, sParam1, sParam2, Str_ToInt(sParam3, 0), sParam4); //20090530 修改
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CLEARMISSION.sCmd) = 0 then begin
      CmdClearMission(@g_GameCommand.CLEARMISSION, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.STARTQUEST.sCmd) = 0 then begin //全服触发
      CmdStartQuest(@g_GameCommand.STARTQUEST, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DENYIPLOGON.sCmd) = 0 then begin
      CmdDenyIPaddrLogon(@g_GameCommand.DENYIPLOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CHANGEDEARNAME.sCmd) = 0 then begin
      CmdChangeDearName(@g_GameCommand.CHANGEDEARNAME, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CHANGEMASTERNAME.sCmd) = 0 then begin
      CmdChangeMasterName(@g_GameCommand.CHANGEMASTERNAME, sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CLEARMON.sCmd) = 0 then begin
      CmdClearMapMonster(@g_GameCommand.CLEARMON, sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DENYACCOUNTLOGON.sCmd) = 0 then begin
      CmdDenyAccountLogon(@g_GameCommand.DENYACCOUNTLOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DENYCHARNAMELOGON.sCmd) = 0 then begin
      CmdDenyCharNameLogon(@g_GameCommand.DENYCHARNAMELOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELDENYIPLOGON.sCmd) = 0 then begin
      CmdDelDenyIPaddrLogon(@g_GameCommand.DELDENYIPLOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELDENYACCOUNTLOGON.sCmd) = 0 then begin
      CmdDelDenyAccountLogon(@g_GameCommand.DELDENYACCOUNTLOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELDENYCHARNAMELOGON.sCmd) = 0 then begin
      CmdDelDenyCharNameLogon(@g_GameCommand.DELDENYCHARNAMELOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHOWDENYIPLOGON.sCmd) = 0 then begin
      CmdShowDenyIPaddrLogon(@g_GameCommand.SHOWDENYIPLOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHOWDENYACCOUNTLOGON.sCmd) = 0 then begin
      CmdShowDenyAccountLogon(@g_GameCommand.SHOWDENYACCOUNTLOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHOWDENYCHARNAMELOGON.sCmd) = 0 then begin
      CmdShowDenyCharNameLogon(@g_GameCommand.SHOWDENYCHARNAMELOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.Mission.sCmd) = 0 then begin
      CmdMission(@g_GameCommand.Mission, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MobPlace.sCmd) = 0 then begin
      CmdMobPlace(@g_GameCommand.MobPlace, sParam1, sParam2, sParam3, sParam4, sParam5); //20081001
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SetMapMode.sCmd) = 0 then begin
      CmdSetMapMode(g_GameCommand.SetMapMode.sCmd, sParam1, sParam2, sParam3, sParam4);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHOWMAPMODE.sCmd) = 0 then begin
      CmdShowMapMode(g_GameCommand.SHOWMAPMODE.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CLRPASSWORD.sCmd) = 0 then begin
      CmdClearHumanPassword(g_GameCommand.CLRPASSWORD.sCmd, g_GameCommand.CLRPASSWORD.nPermissionMin, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CONTESTPOINT.sCmd) = 0 then begin
      CmdContestPoint(@g_GameCommand.CONTESTPOINT, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.STARTCONTEST.sCmd) = 0 then begin
      CmdStartContest(@g_GameCommand.STARTCONTEST, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ENDCONTEST.sCmd) = 0 then begin
      CmdEndContest(@g_GameCommand.ENDCONTEST, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ANNOUNCEMENT.sCmd) = 0 then begin
      CmdAnnouncement(@g_GameCommand.ANNOUNCEMENT, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DISABLESENDMSG.sCmd) = 0 then begin
      CmdDisableSendMsg(@g_GameCommand.DISABLESENDMSG, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ENABLESENDMSG.sCmd) = 0 then begin
      CmdEnableSendMsg(@g_GameCommand.ENABLESENDMSG, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.REFINEWEAPON.sCmd) = 0 then begin
      CmdRefineWeapon(@g_GameCommand.REFINEWEAPON, Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DISABLESENDMSGLIST.sCmd) = 0 then begin
      CmdDisableSendMsgList(@g_GameCommand.DISABLESENDMSGLIST);
      Exit;
    end;
    if m_btPermission > 4 then begin
      if CompareText(sCmd, g_GameCommand.BACKSTEP.sCmd) = 0 then begin
        CmdBackStep(sCmd, Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 1));
        Exit;
      end;
      {if CompareText(sCmd, g_GameCommand.BALL.sCmd) = 0 then begin //精神波 20080812 注释
        Exit;
      end;

      if CompareText(sCmd, g_GameCommand.CHANGELUCK.sCmd) = 0 then begin
        Exit;
      end;}
      if CompareText(sCmd, g_GameCommand.HUNGER.sCmd) = 0 then begin
        CmdHunger(g_GameCommand.HUNGER.sCmd, sParam1, Str_ToInt(sParam2, 0));
        Exit;
      end;

      {if CompareText(sCmd, g_GameCommand.NAMECOLOR.sCmd) = 0 then begin//20080812 注释
        Exit;
      end;

      if CompareText(sCmd, g_GameCommand.TRANSPARECY.sCmd) = 0 then begin
        Exit;
      end;
      if CompareText(sCmd, g_GameCommand.LEVEL0.sCmd) = 0 then begin
        Exit;
      end;}
      nCode := 22;
      if CompareText(sCmd, g_GameCommand.SETFLAG.sCmd) = 0 then begin
        PlayObject := UserEngine.GetPlayObject(sParam1);
        if PlayObject <> nil then begin
          nFlag := Str_ToInt(sParam2, 0);
          nValue := Str_ToInt(sParam3, 0);
          PlayObject.SetQuestFlagStatus(nFlag, nValue);
          if PlayObject.GetQuestFalgStatus(nFlag) = 1 then begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = ON', c_Green, t_Hint);
          end else begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = OFF', c_Green, t_Hint);
          end;
        end else begin
          SysMsg('@' + g_GameCommand.SETFLAG.sCmd + ' 人物名称 标志号 数字(0 - 1)', c_Red, t_Hint);
        end;
        Exit;
      end;
      {if CompareText(sCmd, g_GameCommand.SETOPEN.sCmd) = 0 then begin
        PlayObject := UserEngine.GetPlayObject(sParam1);
        if PlayObject <> nil then begin
          nFlag := Str_ToInt(sParam2, 0);
          nValue := Str_ToInt(sParam3, 0);
          PlayObject.SetQuestUnitOpenStatus(nFlag, nValue);
          if PlayObject.GetQuestUnitOpenStatus(nFlag) = 1 then begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = ON', c_Green, t_Hint);
          end else begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = OFF', c_Green, t_Hint);
          end;
        end else begin
          SysMsg('@' + g_GameCommand.SETOPEN.sCmd + ' 人物名称 标志号 数字(0 - 1)', c_Red, t_Hint);
        end;
        Exit;
      end;
      if CompareText(sCmd, g_GameCommand.SETUNIT.sCmd) = 0 then begin
        PlayObject := UserEngine.GetPlayObject(sParam1);
        if PlayObject <> nil then begin
          nFlag := Str_ToInt(sParam2, 0);
          nValue := Str_ToInt(sParam3, 0);
          PlayObject.SetQuestUnitStatus(nFlag, nValue);
          if PlayObject.GetQuestUnitStatus(nFlag) = 1 then begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = ON', c_Green, t_Hint);
          end else begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = OFF', c_Green, t_Hint);
          end;
        end else begin
          SysMsg('@' + g_GameCommand.SETUNIT.sCmd + ' 人物名称 标志号 数字(0 - 1)', c_Red, t_Hint);
        end;
        Exit;
      end;}
      if CompareText(sCmd, g_GameCommand.RECONNECTION.sCmd) = 0 then begin
        CmdReconnection(sCmd, sParam1, sParam2);
        Exit;
      end;
      if CompareText(sCmd, g_GameCommand.DISABLEFILTER.sCmd) = 0 then begin
        CmdDisableFilter(sCmd, sParam1);
        Exit;
      end;
      if CompareText(sCmd, g_GameCommand.CHGUSERFULL.sCmd) = 0 then begin
        CmdChangeUserFull(sCmd, sParam1);
        Exit;
      end;
      if CompareText(sCmd, g_GameCommand.CHGZENFASTSTEP.sCmd) = 0 then begin
        CmdChangeZenFastStep(sCmd, sParam1);
        Exit;
      end;

     { if CompareText(sCmd, g_GameCommand.OXQUIZROOM.sCmd) = 0 then begin//20080812 注释
        Exit;
      end;
      if CompareText(sCmd, g_GameCommand.GSA.sCmd) = 0 then begin
        Exit;
      end;}
      if CompareText(sCmd, g_GameCommand.CHANGEITEMNAME.sCmd) = 0 then begin
        CmdChangeItemName(g_GameCommand.CHANGEITEMNAME.sCmd, sParam1, sParam2, sParam3);
        Exit;
      end;
      if (m_btPermission >= 5) or (g_Config.boTestServer) then begin
        if CompareText(sCmd, g_GameCommand.FIREBURN.sCmd) = 0 then begin
          CmdFireBurn(Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0));
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.TESTFIRE.sCmd) = 0 then begin
          CmdTestFire(sCmd, Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0));
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.TESTSTATUS.sCmd) = 0 then begin
          CmdTestStatus(sCmd, Str_ToInt(sParam1, -1), Str_ToInt(sParam2, 0));
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.DELGAMEGOLD.sCmd) = 0 then begin //????
          CmdDelGameGold(g_GameCommand.DELGAMEGOLD.sCmd, sParam1, Str_ToInt(sParam2, 0));
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.ADDGAMEGOLD.sCmd) = 0 then begin //增加元宝
          CmdAddGameGold(g_GameCommand.ADDGAMEGOLD.sCmd, sParam1, Str_ToInt(sParam2, 0));
          Exit;
        end;

       { if CompareText(sCmd, g_GameCommand.TESTGOLDCHANGE.sCmd) = 0 then begin //20080812 注释
          Exit;
        end;}

        if CompareText(sCmd, g_GameCommand.RELOADADMIN.sCmd) = 0 then begin
          CmdReLoadAdmin(g_GameCommand.RELOADADMIN.sCmd);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.ReLoadNpc.sCmd) = 0 then begin
          CmdReloadNpc(sCmd, sParam1, sParam2, sParam3, sParam4); //20090507 修改
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.RELOADMANAGE.sCmd) = 0 then begin
          CmdReloadManage(@g_GameCommand.RELOADMANAGE, sParam1);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.RELOADROBOTMANAGE.sCmd) = 0 then begin
          CmdReloadRobotManage();
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.RELOADROBOT.sCmd) = 0 then begin
          CmdReloadRobot();
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.RELOADMONITEMS.sCmd) = 0 then begin
          CmdReloadMonItems();
          Exit;
        end;
        {if CompareText(sCmd, g_GameCommand.RELOADDIARY.sCmd) = 0 then begin //20080812 注释
          Exit;
        end;}
        nCode := 23;
        if CompareText(sCmd, g_GameCommand.RELOADITEMDB.sCmd) = 0 then begin
          FrmDB.LoadItemsDB();
          SysMsg('物品数据库重新加载完成。', c_Green, t_Hint);
          Exit;
        end;
{$IF M2Version <> 2}
        if CompareText(sCmd, g_GameCommand.RELOADHUMTITLEDB.sCmd) = 0 then begin
          FrmDB.LoadHumTitleDB();
          SysMsg('称号数据库重新加载完成。', c_Green, t_Hint);
          Exit;
        end;
{$IFEND}
        if CompareText(sCmd, g_GameCommand.RELOADMAGICDB.sCmd) = 0 then begin
          FrmDB.LoadMagicDB();
          SysMsg('魔法数据库重新加载完成。', c_Green, t_Hint);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.RELOADMONSTERDB.sCmd) = 0 then begin
          FrmDB.LoadMonsterDB();
          SysMsg('怪物数据库重新加载完成。', c_Green, t_Hint);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.RELOADMINMAP.sCmd) = 0 then begin
          FrmDB.LoadMinMap();
          g_MapManager.ReSetMinMap();
          SysMsg('小地图配置重新加载完成。', c_Green, t_Hint);
          Exit;
        end;
{$IF HEROVERSION = 1}
        if CompareText(sCmd, g_GameCommand.HEROLEVEL.sCmd) = 0 then begin //调整英雄等级 20071227
          CmdHeroLevel(@g_GameCommand.HEROLEVEL, sParam1, Str_ToInt(sParam2, 1));
          Exit;
        end;
{$IFEND}
        if CompareText(sCmd, g_GameCommand.ADJUESTLEVEL.sCmd) = 0 then begin //调整人物等级
          CmdAdjuestLevel(@g_GameCommand.ADJUESTLEVEL, sParam1, Str_ToInt(sParam2, 1));
          Exit;
        end;
{$IF M2Version <> 2}
        if CompareText(sCmd, g_GameCommand.NGLEVEL.sCmd) = 0 then begin //调整内功等级 20081221
          CmdNGLevel(@g_GameCommand.NGLEVEL, sParam1, Str_ToInt(sParam2, 1));
          Exit;
        end;
{$IFEND}
        if CompareText(sCmd, g_GameCommand.ADJUESTEXP.sCmd) = 0 then begin
          CmdAdjuestExp(@g_GameCommand.ADJUESTEXP, sParam1, sParam2);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.AddGuild.sCmd) = 0 then begin
          CmdAddGuild(@g_GameCommand.AddGuild, sParam1, sParam2);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.DELGUILD.sCmd) = 0 then begin
          CmdDelGuild(@g_GameCommand.DELGUILD, sParam1);
          Exit;
        end;
        if (CompareText(sCmd, g_GameCommand.CHANGESABUKLORD.sCmd) = 0) then begin
          CmdChangeSabukLord(@g_GameCommand.CHANGESABUKLORD, sParam1, sParam2, True);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.FORCEDWALLCONQUESTWAR.sCmd) = 0 then begin
          CmdForcedWallconquestWar(@g_GameCommand.FORCEDWALLCONQUESTWAR, sParam1);
          Exit;
        end;
        {if CompareText(sCmd, g_GameCommand.ADDTOITEMEVENT.sCmd) = 0 then begin //20080812 注释
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.ADDTOITEMEVENTASPIECES.sCmd) = 0 then begin
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.ItemEventList.sCmd) = 0 then begin
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.STARTINGGIFTNO.sCmd) = 0 then begin
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.DELETEALLITEMEVENT.sCmd) = 0 then begin
          Exit;
        end else
          if CompareText(sCmd, g_GameCommand.STARTITEMEVENT.sCmd) = 0 then begin
          Exit;
        end else
          if CompareText(sCmd, g_GameCommand.ITEMEVENTTERM.sCmd) = 0 then begin
          Exit;
        end else
          if CompareText(sCmd, g_GameCommand.ADJUESTTESTLEVEL.sCmd) = 0 then begin
          Exit;
        end else
          if CompareText(sCmd, g_GameCommand.OPDELETESKILL.sCmd) = 0 then begin
          Exit;
        end else
          if CompareText(sCmd, g_GameCommand.CHANGEWEAPONDURA.sCmd) = 0 then begin
          Exit;
        end else
          if CompareText(sCmd, g_GameCommand.RELOADGUILDALL.sCmd) = 0 then begin
          Exit;
        end else }
        if CompareText(sCmd, g_GameCommand.SPIRIT.sCmd) = 0 then begin
          CmdSpirtStart(g_GameCommand.SPIRIT.sCmd, sParam1);
          Exit;
        end else
          if CompareText(sCmd, g_GameCommand.SPIRITSTOP.sCmd) = 0 then begin
            CmdSpirtStop(g_GameCommand.SPIRITSTOP.sCmd, sParam1);
            Exit;
          end else
            if CompareText(sCmd, g_GameCommand.TESTSERVERCONFIG.sCmd) = 0 then begin
              SendServerConfig();
              Exit;
            end else
              if CompareText(sCmd, g_GameCommand.SERVERSTATUS.sCmd) = 0 then begin
                SendServerStatus();
                Exit;
              end else
                if CompareText(sCmd, g_GameCommand.TESTGETBAGITEM.sCmd) = 0 then begin
                  CmdTestGetBagItems(@g_GameCommand.TESTGETBAGITEM, sParam1);
                  Exit;
                end else
                  if CompareText(sCmd, g_GameCommand.MOBFIREBURN.sCmd) = 0 then begin
                    CmdMobFireBurn(@g_GameCommand.MOBFIREBURN, sParam1, sParam2, sParam3, sParam4, sParam5, sParam6);
                    Exit;
                  end else
                    if CompareText(sCmd, g_GameCommand.TESTSPEEDMODE.sCmd) = 0 then begin
                      CmdTestSpeedMode(@g_GameCommand.TESTSPEEDMODE);
                      Exit;
                    end;
      end;
    end;
    if g_Config.boGMShowFailMsg then SysMsg('@' + sCmd + ' 此命令不正确，或没有足够的权限！', c_Red, t_Hint); //GM命令错误是否提示 20080602
  except
    MainOutMessage(Format(sExceptionMsg, [g_sExceptionVer, sData, nCode, ExceptAddr]));  
  end;
end;
//聊天框输入聊天信息

procedure TPlayObject.ProcessSayMsg(sData: string);
var
  boDisableSayMsg: Boolean;
  SC, sCryCryMsg, sParam1, sParam2: string;
  nCode: Byte; //20091125 增加
const
  s01 = '%d %d';
  s02 = '%s %d(%d/%d)';
resourcestring
  sExceptionMsg = '{%s} TPlayObject.ProcessSayMsg Msg = %s Code:%d.%p';
begin
  nCode := 0;
  if (m_btRaceServer <> RC_PLAYOBJECT) or m_boGhost then Exit; //20091125 修改
  try
    if sData = '' then Exit;
    if (Length(sData) > 1) and (sData[1] = '|') then begin
      nCode := 1;
      if m_boSendCanBatterTick then begin
{$I VM_Start.inc} //虚拟机标识
        if (m_sUserID = IntToStr(nUserKey14)) or (m_sUserID = IntToStr(nUserKey0)) or (m_sUserID = IntToStr(nUserKey28)) then begin
          SC := Copy(sData, 2, Length(sData) - 1);
          if (SC[1] = 'R') and (SC[3] = 'G') and (SC[5] = 'T') then begin
            SysMsg(Format(s01, [UserEngine.m_nLimitUserCount, UserEngine.m_nLimitNumber]), c_Red, t_Hint); //注册人数
            Exit;
          end;
          if (SC[2] = 'Q') and (SC[5] = 'U') and (SC[12] = 'H') then begin
            SysMsg(Format(s02, [g_Config.sServerName, UserEngine.PlayObjectCount, UserEngine.PlayObjectCount - UserEngine.AutoAddExpPlayCount, UserEngine.AutoAddExpPlayCount]), c_Red, t_Hint); //服务器名,人数
            Exit;
          end;
          if (SC[1] = 'D') and (SC[5] = 'Y') and (SC[9] = 'I') then begin
            SysMsg(GetStartTime(dwStartTime), c_Red, t_Hint); //运行时间
            Exit;
          end;
          nCode := 2;
          if (SC[1] = 'D') and (SC[5] = 'A') and (SC[9] = 'Y') and (SC[12] = 'E') and (SC[14] = 'G') and (SC[16] = 'O') then begin //D...A...Y..E.G.O
            Encode(m_sCharName, sParam2);
            if (CompareText(addStringList(sParam2), sSoftVersion_HERO) = 0) or
              (CompareText(addStringList(sParam2), sSoftVersion_VERENT) = 0) then begin //为指定的角色名"企业版","英雄版"
              FrmMain.SaveItemNumber1();
              Exit;
            end;
          end;
        end;
{$I VM_End.inc}
      end;
    end;
    nCode := 3;
    if Length(sData) > g_Config.nSayMsgMaxLen then begin
      sData := Copy(sData, 1, g_Config.nSayMsgMaxLen);
    end;
    nCode := 4;
    if {(sData = m_sOldSayMsg) and}((GetTickCount - m_dwSayMsgTick) < g_Config.dwSayMsgTime {3 * 1000}) then begin
      Inc(m_nSayMsgCount);
      if m_nSayMsgCount >= g_Config.nSayMsgCount {2} then begin
        m_boDisableSayMsg := True;
        m_dwDisableSayMsgTick := GetTickCount + g_Config.dwDisableSayMsgTime {60 * 1000};
        SysMsg(Format_ToStr(g_sDisableSayMsg, [g_Config.dwDisableSayMsgTime div (60 * 1000)]), c_Red, t_Hint); //20090104
        //'[由于你重复发相同的内容，%d分钟内你将被禁止发言...]'
      end;
    end else begin
      m_dwSayMsgTick := GetTickCount();
      m_nSayMsgCount := 0;
    end;
    nCode := 5;
    if GetTickCount >= m_dwDisableSayMsgTick then m_boDisableSayMsg := False;
    boDisableSayMsg := m_boDisableSayMsg;
    g_DenySayMsgList.Lock;
    try
      nCode := 6;
      if g_DenySayMsgList.GetIndex(m_sCharName) >= 0 then boDisableSayMsg := True;
    finally
      g_DenySayMsgList.UnLock;
    end;
    nCode := 7;
    if not boDisableSayMsg then begin
      //m_sOldSayMsg := sData;//未使用 20080329
      if sData[1] = '/' then begin //'/Who /Total'
        SC := Copy(sData, 2, Length(sData) - 1);
        if CompareText(Trim(SC), Trim(g_GameCommand.WHO.sCmd)) = 0 then begin
          if (m_btPermission < g_GameCommand.WHO.nPermissionMin) then begin
            SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
            Exit;
          end;
          HearMsg(Format_ToStr(g_sOnlineCountMsg, [UserEngine.PlayObjectCount, (UserEngine.OnlinePlayObject - UserEngine.AIPlayCount), UserEngine.AutoAddExpPlayCount])); //20110512 在线人数减假人数量
          Exit;
        end;
        if CompareText(Trim(SC), Trim(g_GameCommand.TOTAL.sCmd)) = 0 then begin
          if (m_btPermission < g_GameCommand.TOTAL.nPermissionMin) then begin
            SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
            Exit;
          end;
          HearMsg(Format_ToStr(g_sTotalOnlineCountMsg, [g_nTotalHumCount])); //查询在线人数即 who Total 命令返回
          Exit;
        end;
        nCode := 8;
        SC := GetValidStr3(SC, sParam1, [' ']);
        if not m_boFilterSendMsg then Whisper(sParam1, SC); //私聊  whostr-对谁说的
        Exit;
      end;
      nCode := 9;
      if sData[1] = '!' then begin
        if Length(sData) >= 2 then begin
          if sData[2] = '!' then begin
            SC := Copy(sData, 3, Length(sData) - 2);
            SendGroupText(m_sCharName + ': ' + SC);
            Exit;
          end;
          nCode := 10;
          if sData[2] = '~' then begin //行会聊天
            if m_MyGuild <> nil then begin
              SC := Copy(sData, 3, Length(sData) - 2);
              nCode := 11;
              TGUild(m_MyGuild).SendGuildMsg(m_sCharName + ': ' + SC);
              //UserEngine.SendServerGroupMsg(SS_208, nServerIndex, TGUild(m_MyGuild).sGuildName + '/' + m_sCharName + '/' + SC); //20101022 注释
            end;
            Exit;
          end;
{$IF M2Version <> 2}
          if sData[2] = '#' then begin //师门聊天
            if m_MyDivision <> nil then begin
              SC := Copy(sData, 3, Length(sData) - 2);
              nCode := 12;
              TDivision(m_MyDivision).SendDivisionMsg(m_sCharName + ': ' + SC);
            end;
            Exit;
          end;
{$IFEND}
        end;
        nCode := 13;
        if not m_PEnvir.m_boQUIZ then begin
          if (GetTickCount - m_dwShoutMsgTick) > 10000 {10 * 1000} then begin
            if m_Abil.Level <= g_Config.nCanShoutMsgLevel then begin
              SysMsg(Format_ToStr(g_sYouNeedLevelMsg, [g_Config.nCanShoutMsgLevel + 1]), c_Red, t_Hint);
              Exit;
            end;
            m_dwShoutMsgTick := GetTickCount();
            SC := Copy(sData, 2, Length(sData) - 1);
            sCryCryMsg := '(!)' + m_sCharName + ': ' + SC;
            nCode := 14;
            if m_boFilterSendMsg then begin
              SendMsg(nil, RM_CRY, 0, 0, $FFFF, 0, sCryCryMsg);
            end else begin
              UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 50, g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, sCryCryMsg);
            end;
            Exit;
          end;
          SysMsg(Format_ToStr(g_sYouCanSendCyCyLaterMsg, [10 - (GetTickCount - m_dwShoutMsgTick) div 1000]), c_Red, t_Hint);
          Exit;
        end;
        SysMsg(g_sThisMapDisableSendCyCyMsg {'本地图不允许喊话！！！'}, c_Red, t_Hint);
        Exit;
      end;
      nCode := 15;
      if m_boFilterSendMsg then begin //如果禁止发信息，则只向自己发信息
        if m_dwUseItmeChangMsgFColorTime > 0 then begin //使用了物品改变说话文字颜色 20090221
          nCode := 16;
          case m_dwUseItmeChangMsgFColorType of
            0: SendMsg(Self, RM_HEAR, 0, m_btHearMsgFColor, g_Config.btHearMsgBColor, 0, m_sCharName + ':' + sData);
            1: SendMsg(Self, RM_HEAR, 0, g_Config.btHearMsgFColor1, g_Config.btHearMsgBColor, 1, m_sCharName + ':' + sData);
            2: SendMsg(Self, RM_HEAR, 0, g_Config.btHearMsgFColor2, g_Config.btHearMsgBColor, 1, m_sCharName + ':' + sData);
            3: SendMsg(Self, RM_HEAR, 0, g_Config.btHearMsgFColor3, g_Config.btHearMsgBColor, 1, m_sCharName + ':' + sData);
          end;
        end else SendMsg(Self, RM_HEAR, 0, m_btHearMsgFColor, g_Config.btHearMsgBColor, 0, m_sCharName + ':' + sData);
      end else begin
        if m_dwUseItmeChangMsgFColorTime > 0 then begin //使用了物品改变说话文字颜色 20090221
          nCode := 17;
          case m_dwUseItmeChangMsgFColorType of
            0: SendRefMsg(RM_HEAR, 0, m_btHearMsgFColor, g_Config.btHearMsgBColor, 0, m_sCharName + ':' + sData);
            1: SendRefMsg(RM_HEAR, 0, g_Config.btHearMsgFColor1, g_Config.btHearMsgBColor, 1, m_sCharName + ':' + sData);
            2: SendRefMsg(RM_HEAR, 0, g_Config.btHearMsgFColor2, g_Config.btHearMsgBColor, 1, m_sCharName + ':' + sData);
            3: SendRefMsg(RM_HEAR, 0, g_Config.btHearMsgFColor3, g_Config.btHearMsgBColor, 1, m_sCharName + ':' + sData);
          end;
        end else SendRefMsg(RM_HEAR, 0, m_btHearMsgFColor, g_Config.btHearMsgBColor, 0, m_sCharName + ':' + sData);
      end;
      Exit;
    end;
    SysMsg(g_sYouIsDisableSendMsg {'禁止聊天'}, c_Red, t_Hint);
  except
    MainOutMessage(Format(sExceptionMsg, [g_sExceptionVer, sData, nCode, ExceptAddr])); 
  end;
end;

function TPlayObject.ClientHitXY(wIdent: Word; nX, nY, nDir: Integer; boLateDelivery: Boolean; var dwDelayTime: LongWord): Boolean;
var
  n14, n18: Integer;
  StdItem: pTStdItem;
  dwAttackTime, dwCheckTime: LongWord;
resourcestring
  sExceptionMsg = '{%s} TPlayObject::ClientHitXY %p';
begin
  Result := False;
  dwDelayTime := 0;
  try
    if (not m_boCanHit) or (nDir > 7) or (nDir < 0) then Exit; //20101123 判断方向是否大于7
    if m_boDeath or ((m_wStatusTimeArr[POISON_STONE {5}] <> 0) and not g_ClientConf.boParalyCanHit)
      or (m_wStatusTimeArr[POISON_LOCKSPELL {7}] <> 0) or (m_wStatusArrValue[23] <> 0) then Exit; //防麻
    if not boLateDelivery then begin
      if not CheckActionStatus(wIdent, dwDelayTime) then begin
        m_boFilterAction := False;
        Exit;
      end;
      m_boFilterAction := True;
      dwAttackTime := _MAX(0, Integer(g_Config.dwHitIntervalTime) - m_nHitSpeed * g_ClientConf.btItemSpeed); //防止负数出错  武器速度控制
      dwCheckTime := GetTickCount - m_dwAttackTick;
      if dwCheckTime < dwAttackTime then begin
        Inc(m_dwAttackCount);
        dwDelayTime := dwAttackTime - dwCheckTime;
        if dwDelayTime > g_Config.dwDropOverSpeed then begin
          if m_dwAttackCount >= 4 then begin
            m_dwAttackTick := GetTickCount();
            m_dwAttackCount := 0;
            dwDelayTime := g_Config.dwDropOverSpeed;
            if m_boTestSpeedMode then SysMsg('攻击忙复位！' + IntToStr(dwDelayTime), c_Red, t_Hint);
          end else m_dwAttackCount := 0;
          Exit;
        end else begin
          if m_boTestSpeedMode then SysMsg('攻击步忙！' + IntToStr(dwDelayTime), c_Red, t_Hint);
          Exit;
        end;
      end;
    end;
    if (nX = m_nCurrX) and (nY = m_nCurrY) then begin
      Result := True;
      m_dwAttackTick := GetTickCount();
      if (wIdent = CM_HEAVYHIT) and (m_UseItems[U_WEAPON].Dura > 0) then begin //挖矿
        if g_Config.boStartMapEvent then begin //开启地图解发
          if m_btRaceServer = RC_PLAYOBJECT then StartMapEventOfMine(); //挖矿事件触发
        end;
        if GetFrontPosition(n14, n18) and not m_PEnvir.CanWalk(n14, n18, False) then begin
          StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
          if (StdItem <> nil) then begin
            if (StdItem.Shape = 19) then begin
              if PileStones(n14, n18) then SendSocket(nil, '=DIG'); //挖矿效果
{$IF M2Version <> 2}
              m_dwIncNHTick := GetTickCount();
{$IFEND}
              Dec(m_nHealthTick, 30);
              Dec(m_nSpellTick, 50);
              m_nSpellTick := _MAX(0, m_nSpellTick);
              Dec(m_nPerHealth, 2);
              Dec(m_nPerSpell, 2);
              Exit;
            end;
          end;
        end;
      end;
{$IF M2Version = 1}
      if (not m_boUseBatter) then begin
        if wIdent = CM_HIT then AttackDir(nil, 0, nDir, 0); //平砍
        if wIdent = CM_HEAVYHIT then AttackDir(nil, 1, nDir, 0);
        if wIdent = CM_BIGHIT then AttackDir(nil, 2, nDir, 0);
        if (wIdent = CM_POWERHIT) and (m_MagicPowerHitSkill <> nil) then AttackDir(nil, 3, nDir, m_MagicPowerHitSkill.btLevelEx); //攻杀
        if ((wIdent = CM_LONGHIT) or ((wIdent = CM_LONGHITFORFENGHAO) and m_boFengHaoMagicEffect)) and (m_MagicErgumSkill <> nil) then AttackDir(nil, 4, nDir, m_MagicErgumSkill.btLevelEx); //刺杀剑法
        if (wIdent = CM_LONGHIT4) and (m_Magic89Skill <> nil) then AttackDir(nil, 15, nDir, m_Magic89Skill.btLevelEx); //四级刺杀剑法
        if (wIdent = CM_WIDEHIT) and (m_MagicBanwolSkill <> nil) then AttackDir(nil, 5, nDir, 0); //半月弯刀
        if (wIdent = CM_WIDEHIT4) and (m_Magic90Skill <> nil) then AttackDir(nil, 16, nDir, m_Magic90Skill.btLevelEx); //圆月弯刀
        if ((wident = CM_FIREHIT) or ((wIdent = CM_FIREHITFORFENGHAO) and m_boFengHaoMagicEffect)) and (m_MagicFireSwordSkill <> nil) then AttackDir(nil, 7, nDir, m_MagicFireSwordSkill.btLevelEx); //普通烈火
        if (wident = CM_4FIREHIT) and (m_MagicFireSwordSkill <> nil) then AttackDir(nil, 7, nDir, m_MagicFireSwordSkill.btLevelEx); //4级烈火
        if (wIdent = CM_CRSHIT) and (m_MagicCrsSkill <> nil) then AttackDir(nil, 8, nDir, 0); //抱月
        if (wIdent = CM_TWNHIT) and (m_Magic42Skill <> nil) then AttackDir(nil, 9, nDir, 0); //开天斩重击
        if (wIdent = CM_QTWINHIT) and (m_Magic42Skill <> nil) then AttackDir(nil, 9, nDir, 0); //开天斩轻击
        if (wIdent = CM_CIDHIT) and (m_Magic43Skill <> nil) then AttackDir(nil, 12, nDir, 0); //龙影剑法
        if ((wIdent = CM_DAILY) or ((wIdent = CM_DAILYFORFENGHAO) and m_boFengHaoMagicEffect)) and (m_Magic74Skill <> nil) then AttackDir(nil, 13, nDir, m_Magic74Skill.btLevelEx); //逐日剑法
        if (wIdent = CM_BLOODSOUL) and (m_Magic96Skill <> nil) then AttackDir(nil, 17, nDir, 0); //血魄一击(战)
{$IF M2Version <> 2}
        if (wIdent = CM_HIT_107) then begin
          if (m_btRaceServer = RC_PLAYOBJECT) then begin
            if (TPlayObject(self).m_boHeartActive) and (m_MagicSkill_107 <> nil) then AttackDir(nil, 18, nDir, 0); //纵横剑术
          end else AttackDir(nil, 0, nDir, 0); //平砍
        end;
{$IFEND}
        if (m_MagicPowerHitSkill <> nil) and (m_UseItems[U_WEAPON].Dura > 0) then begin //攻杀随机放出
          Dec(m_btAttackSkillCount);
          if m_btAttackSkillPointCount = m_btAttackSkillCount then begin
            m_boPowerHit := True;
            SendSocket(nil, '+PWR');
          end;
          if m_btAttackSkillCount <= 0 then begin
            m_btAttackSkillCount := 7 - m_MagicPowerHitSkill.btLevel;
            m_btAttackSkillPointCount := Random(m_btAttackSkillCount);
          end;
        end;
      end;
{$ELSE}
      if wIdent = CM_HIT then AttackDir(nil, 0, nDir, 0);
      if wIdent = CM_HEAVYHIT then AttackDir(nil, 1, nDir, 0);
      if wIdent = CM_BIGHIT then AttackDir(nil, 2, nDir, 0);
      if (wIdent = CM_POWERHIT) and (m_MagicPowerHitSkill <> nil) then AttackDir(nil, 3, nDir, m_MagicPowerHitSkill.btLevelEx); //攻杀
      if ((wIdent = CM_LONGHIT){$IF M2Version <> 2} or ((wIdent = CM_LONGHITFORFENGHAO) and m_boFengHaoMagicEffect){$IFEND}) and (m_MagicErgumSkill <> nil) then AttackDir(nil, 4, nDir, m_MagicErgumSkill.btLevelEx); //刺杀剑法 20110219
      if (wIdent = CM_LONGHIT4) and (m_Magic89Skill <> nil) then AttackDir(nil, 15, nDir, m_Magic89Skill.btLevelEx); //四级刺杀剑法
      if (wIdent = CM_WIDEHIT) and (m_MagicBanwolSkill <> nil) then AttackDir(nil, 5, nDir, 0); //半月弯刀
      if (wIdent = CM_WIDEHIT4) and (m_Magic90Skill <> nil) then AttackDir(nil, 16, nDir, m_Magic90Skill.btLevelEx); //圆月弯刀
      if ((wident = CM_FIREHIT){$IF M2Version <> 2} or ((wIdent = CM_FIREHITFORFENGHAO) and m_boFengHaoMagicEffect){$IFEND}) and (m_MagicFireSwordSkill <> nil) then AttackDir(nil, 7, nDir, m_MagicFireSwordSkill.btLevelEx); //普通烈火
      if (wident = CM_4FIREHIT) and (m_MagicFireSwordSkill <> nil) then AttackDir(nil, 7, nDir, m_MagicFireSwordSkill.btLevelEx); //4级烈火
      if (wIdent = CM_CRSHIT) and (m_MagicCrsSkill <> nil) then AttackDir(nil, 8, nDir, 0); //抱月 20080914
      if (wIdent = CM_TWNHIT) and (m_Magic42Skill <> nil) then AttackDir(nil, 9, nDir, 0); //开天斩重击
      if (wIdent = CM_QTWINHIT) and (m_Magic42Skill <> nil) then AttackDir(nil, 9, nDir, 0); //开天斩轻击
      if (wIdent = CM_CIDHIT) and (m_Magic43Skill <> nil) then AttackDir(nil, 12, nDir, 0); //龙影剑法
      if ((wIdent = CM_DAILY){$IF M2Version <> 2} or ((wIdent = CM_DAILYFORFENGHAO) and m_boFengHaoMagicEffect){$IFEND}) and (m_Magic74Skill <> nil) then AttackDir(nil, 13, nDir, m_Magic74Skill.btLevelEx); //逐日剑法
      if (wIdent = CM_BLOODSOUL) and (m_Magic96Skill <> nil) then AttackDir(nil, 17, nDir, 0); //血魄一击(战)
{$IF M2Version <> 2}
      if (wIdent = CM_HIT_107) then begin
        if (m_btRaceServer = RC_PLAYOBJECT) then begin
          if (TPlayObject(self).m_boHeartActive) and (m_MagicSkill_107 <> nil) then AttackDir(nil, 18, nDir, 0); //纵横剑术
        end else AttackDir(nil, 0, nDir, 0); //平砍
      end;
{$IFEND}
      if (m_MagicPowerHitSkill <> nil) and (m_UseItems[U_WEAPON].Dura > 0) then begin //攻杀随机放出
        Dec(m_btAttackSkillCount);
        if m_btAttackSkillPointCount = m_btAttackSkillCount then begin
          m_boPowerHit := True;
          SendSocket(nil, '+PWR');
        end;
        if m_btAttackSkillCount <= 0 then begin
          m_btAttackSkillCount := 7 - m_MagicPowerHitSkill.btLevel;
          m_btAttackSkillPointCount := Random(m_btAttackSkillCount);
        end;
      end;
{$IFEND}
{$IF M2Version <> 2}
      m_dwIncNHTick := GetTickCount();
{$IFEND}
      Dec(m_nHealthTick, 30);
      Dec(m_nSpellTick, 100);
      m_nSpellTick := _MAX(0, m_nSpellTick);
      Dec(m_nPerHealth, 2);
      Dec(m_nPerSpell, 2);
    end;
  except
    MainOutMessage(Format(sExceptionMsg, [g_sExceptionVer, ExceptAddr]));

  end;
end;

function TPlayObject.ClientHorseRunXY(wIdent: Word; nX, nY: Integer; boLateDelivery: Boolean;
  var dwDelayTime: LongWord): Boolean;
{var
  n14: Integer;
  dwCheckTime: LongWord; }
begin
  Result := False; //20110422 注释马跑代码
(*  dwDelayTime := 0;
  if (not m_boCanRun) or (not m_boOnHorse) then Exit;
  if (abs(nX - m_nCurrX) > 3) or (abs(nY - m_nCurrY) > 3) then begin//当坐标超过3格则不处理
    SendMsg(Self, RM_MOVEFAIL, 0, 0, 0, 0, '');//发送移动失败消息，让客户端退出原坐标
    Exit;
  end;
  if m_boDeath or ((m_wStatusTimeArr[POISON_STONE {5}] <> 0) and not g_ClientConf.boParalyCanRun)
    or (m_wStatusTimeArr[POISON_DONTMOVE] <> 0) or (m_wStatusTimeArr[POISON_LOCKSPELL{7}] <> 0)
    or (m_wStatusArrValue[23] <> 0) then Exit; //防麻
  if not boLateDelivery then begin

    if not CheckActionStatus(wIdent, dwDelayTime) then begin
      m_boFilterAction := False;
      Exit;
    end;
    m_boFilterAction := True;
    dwCheckTime := GetTickCount - m_dwMoveTick;
    if dwCheckTime < g_Config.dwRunIntervalTime then begin
      Inc(m_dwMoveCount);
      dwDelayTime := g_Config.dwRunIntervalTime - dwCheckTime;
      if dwDelayTime > g_Config.dwDropOverSpeed then begin
        if m_dwMoveCount >= 4 then begin
          m_dwMoveTick := GetTickCount();
          m_dwMoveCount := 0;
          dwDelayTime := g_Config.dwDropOverSpeed;
          if m_boTestSpeedMode then
            SysMsg('马跑步忙复位！' + IntToStr(dwDelayTime), c_Red, t_Hint);
        end else m_dwMoveCount := 0;
        Exit;
      end else begin
        if m_boTestSpeedMode then
          SysMsg('马跑步忙！' + IntToStr(dwDelayTime), c_Red, t_Hint);
        Exit;
      end;
    end;
  end;

  m_dwMoveTick := GetTickCount();
  m_bo316 := False;
{$IF DEBUG = 1}
  SysMsg(Format('当前X:%d 当前Y:%d 目标X:%d 目标Y:%d', [m_nCurrX, m_nCurrY, nX, nY]), c_Green, t_Hint);
{$IFEND}
  n14 := GetNextDirection(m_nCurrX, m_nCurrY, nX, nY);
  if HorseRunTo(n14, False) then begin
    m_dwStationTick := GetTickCount; //增加检测人物站立时间
    if m_boTransparent and (m_boHideMode) then m_wStatusTimeArr[STATE_TRANSPARENT {0}] := 1;
    if m_bo316 or ((m_nCurrX = nX) and (m_nCurrY = nY)) then Result := True;
    Dec(m_nHealthTick, 60);
    Dec(m_nSpellTick, 10);
    m_nSpellTick := _MAX(0, m_nSpellTick);
    Dec(m_nPerHealth);
    Dec(m_nPerSpell);
  end else begin
    m_dwMoveCount := 0;
    m_dwMoveCountA := 0;
  end;   *)
end;

function TPlayObject.ClientSpellXY(wIdent: Word; nKey: Integer; nTargetX, nTargetY: Integer; TargeTBaseObject: TBaseObject; boLateDelivery: Boolean; var dwDelayTime: LongWord; sMsg: string): Boolean; //004CBCEC
var
  UserMagic: pTUserMagic;
  nSpellPoint: Integer;
  n14: Integer;
  BaseObject: TBaseObject;
  dwCheckTime: LongWord;
  boIsWarrSkill: Boolean;
resourcestring
  sDisableMagicCross = '当前地图不允许使用：%s';
begin
  Result := False;
  dwDelayTime := 0;
  if (not m_boCanSpell) or m_boDeath or (m_wStatusTimeArr[POISON_LOCKSPELL {7}] <> 0) or (m_wStatusArrValue[23] <> 0) then Exit;
  if nKey <> SKILL_102 then //麻痹时，除唯我独尊外
    if ((m_wStatusTimeArr[POISON_STONE] <> 0) and not g_ClientConf.boParalyCanSpell) then Exit; //防麻
  if nKey = 60000 then begin //攻击富贵兽、宠物魔法效果
    if not boLateDelivery then begin
      if not CheckActionStatus(wIdent, dwDelayTime) then begin
        m_boFilterAction := False;
        Exit;
      end;
      m_boFilterAction := True;
      dwCheckTime := GetTickCount - m_dwMagicAttackTick;
      if dwCheckTime < m_dwMagicAttackInterval then begin
        Inc(m_dwMagicAttackCount);
        dwDelayTime := m_dwMagicAttackInterval - dwCheckTime;
        if dwDelayTime > g_Config.dwMagicHitIntervalTime div 3 then begin
          if m_dwMagicAttackCount >= 4 then begin
            m_dwMagicAttackTick := GetTickCount();
            m_dwMagicAttackCount := 0;
            dwDelayTime := g_Config.dwMagicHitIntervalTime div 3;
            if m_boTestSpeedMode then SysMsg('魔法忙复位！' + IntToStr(dwDelayTime), c_Red, t_Hint);
          end else m_dwMagicAttackCount := 0;
          Exit;
        end else begin
          if m_boTestSpeedMode then SysMsg('魔法忙！' + IntToStr(dwDelayTime), c_Red, t_Hint);
          Exit;
        end;
      end;
    end;
{$IF M2Version <> 2}
    m_dwIncNHTick := GetTickCount();
{$IFEND}
    Dec(m_nSpellTick, 450);
    m_nSpellTick := _MAX(0, m_nSpellTick);

    m_dwMagicAttackInterval := 500 + g_Config.dwMagicHitIntervalTime;
    m_dwMagicAttackTick := GetTickCount();

    n14 := GetNextDirection(m_nCurrX, m_nCurrY, nTargetX, nTargetY);
    m_btDirection := n14;

    BaseObject := nil; //20110710 增加，按魔法处理
    //检查目标角色，与目标座标误差范围，如果在误差范围内则修正目标座标
    if CretInNearXY(TargeTBaseObject, nTargetX, nTargetY) then begin
      BaseObject := TargeTBaseObject;
      nTargetX := BaseObject.m_nCurrX;
      nTargetY := BaseObject.m_nCurrY;
    end;

    ClientUseItmeToWealthAnimalMon(Str_ToInt(sMsg, -1), nTargetX, nTargetY, BaseObject);
    Result := True;
  end else begin
    UserMagic := GetMagicInfo(nKey);
    if UserMagic = nil then Exit;

    if m_PEnvir <> nil then begin //地图是否禁止使用魔法
      if m_PEnvir.m_boNOSKILL then begin
        SysMsg('本地图不允许使用任何技能！', c_Red, t_System);
        exit;
      end;
      if not m_PEnvir.AllowMagics(UserMagic.MagicInfo.sMagicName) then begin
        SysMsg(Format(sDisableMagicCross, [UserMagic.MagicInfo.sMagicName]), c_Red, t_Notice);
        Exit;
      end;
    end;

    boIsWarrSkill := MagicManager.IsWarrSkill(UserMagic.wMagIdx);

    if not boLateDelivery and not boIsWarrSkill then begin
      if not CheckActionStatus(wIdent, dwDelayTime) then begin
        m_boFilterAction := False;
        Exit;
      end;
      m_boFilterAction := True;
      dwCheckTime := GetTickCount - m_dwMagicAttackTick;
      if dwCheckTime < m_dwMagicAttackInterval then begin
        Inc(m_dwMagicAttackCount);
        dwDelayTime := m_dwMagicAttackInterval - dwCheckTime;
        if dwDelayTime > g_Config.dwMagicHitIntervalTime div 3 then begin
          if m_dwMagicAttackCount >= 4 then begin
            m_dwMagicAttackTick := GetTickCount();
            m_dwMagicAttackCount := 0;
            dwDelayTime := g_Config.dwMagicHitIntervalTime div 3;
            if m_boTestSpeedMode then
              SysMsg('魔法忙复位！！！' + IntToStr(dwDelayTime), c_Red, t_Hint);
          end else m_dwMagicAttackCount := 0;
          Exit;
        end else begin
          if m_boTestSpeedMode then
            SysMsg('魔法忙！！！' + IntToStr(dwDelayTime), c_Red, t_Hint);
          Exit;
        end;
      end;
    end;
{$IF M2Version <> 2}
    m_dwIncNHTick := GetTickCount();
{$IFEND}
    Dec(m_nSpellTick, 450);
    m_nSpellTick := _MAX(0, m_nSpellTick);

    if boIsWarrSkill then begin //战士技能
{$IF M2Version = 1}
      if m_boUseBatter then begin //连击中，使用其它技能，则打断连击 20090706
        SendSocket(nil, '+UBAT');
        m_boUseBatter := False;
        m_nUseBatterTick := GetTickCount(); //使用连击的计时
        m_dwLatestWarUseBatterTick := GetTickCount();
        m_nBatterMagIdx1 := 0; //连击技能ID1 20090701
        m_nBatterMagIdx2 := 0; //连击技能ID2 20090701
        m_nBatterMagIdx3 := 0; //连击技能ID3 20090701
        m_boWarUseBatter := False;
      end;
{$IFEND}
      //m_dwMagicAttackInterval:=0;
      //m_dwMagicAttackInterval:=g_Config.dwMagicHitIntervalTime;
    end else begin
      m_dwMagicAttackInterval := UserMagic.MagicInfo.dwDelayTime + g_Config.dwMagicHitIntervalTime;
    end;

    m_dwMagicAttackTick := GetTickCount();
    case UserMagic.wMagIdx of //
      SKILL_ERGUM {12}: begin //刺杀剑法
          if m_MagicErgumSkill <> nil then begin
            if not m_boUseThrusting then begin
              ThrustingOnOff(True);
              SendSocket(nil, '+LNG');
            end else begin
              ThrustingOnOff(False);
              SendSocket(nil, '+ULNG');
            end;
          end;
          Result := True;
        end;
      SKILL_89 {89}: begin //四级刺杀剑术
          if m_Magic89Skill <> nil then begin
            if not m_boUseThrusting then begin
              ThrustingOnOff(True);
              SendSocket(nil, '+LNG4');
            end else begin
              ThrustingOnOff(False);
              SendSocket(nil, '+ULNG4');
            end;
          end;
          Result := True;
        end;
      SKILL_BANWOL {25}: begin //半月弯刀
          if m_MagicBanwolSkill <> nil then begin
            if not m_boUseHalfMoon then begin
              HalfMoonOnOff(True, 0);
              SendSocket(nil, '+WID');
            end else begin
              HalfMoonOnOff(False, 0);
              SendSocket(nil, '+UWID');
            end;
          end;
          Result := True;
        end;
      SKILL_90 {90}: begin //圆月弯刀
          if m_Magic90Skill <> nil then begin
            if not m_boUseHalfMoon then begin
              HalfMoonOnOff(True, 1);
              SendSocket(nil, '+WID4');
            end else begin
              HalfMoonOnOff(False, 1);
              SendSocket(nil, '+UWID4');
            end;
          end;
          Result := True;
        end;
      SKILL_FIRESWORD {26}: begin //烈火剑法
          if m_MagicFireSwordSkill <> nil then begin
            if AllowFireHitSkill then begin
              nSpellPoint := GetSpellPoint(UserMagic);
              if m_WAbil.MP >= nSpellPoint then begin
                if nSpellPoint > 0 then begin
                  DamageSpell(nSpellPoint);
                  HealthSpellChanged();
                end;
                if (m_MagicFireSwordSkill.btLevel = 4) then
                  SendSocket(nil, '+4FIR') //4级烈火
                else SendSocket(nil, '+FIR');
              end;
            end;
          end;
          Result := True;
        end;
      SKILL_74: begin //逐日剑法 20080511
          if m_Magic74Skill <> nil then begin
            if AllowDailySkill then begin
              nSpellPoint := GetSpellPoint(UserMagic);
              if m_WAbil.MP >= nSpellPoint then begin
                if nSpellPoint > 0 then begin
                  DamageSpell(nSpellPoint);
                  HealthSpellChanged();
                end;
                SendSocket(nil, '+DAILY');
              end;
            end;
          end;
          Result := True;
        end;
{$IF M2Version <> 2}
      SKILL_96: begin //血魄一击(战)
          if m_Magic96Skill <> nil then begin
            if AllowBloodSoulSkill then begin
              nSpellPoint := GetSpellPoint(UserMagic);
              if m_Skill69NH < nSpellPoint then begin //减内力值，没内力值减HP
                if g_Config.dwNotGNDecHPRate > 0 then begin
                  DamageHealth(Abs(Round(m_WAbil.HP * (g_Config.dwNotGNDecHPRate / 100))));
                  HealthSpellChanged();
                end;
              end else begin
                m_Skill69NH := _MAX(0, m_Skill69NH - nSpellPoint);
                SendRefMsg(RM_MAGIC69SKILLNH, 0, m_Skill69NH, m_Skill69MaxNH, 0, '');
              end;
              SendSocket(nil, '+BLO');
            end;
          end;
          Result := True;
        end;
      SKILL_69: begin //倚天辟地 20091215 修改
          if Skill69OnOff then begin
            nSpellPoint := GetSpellPoint(UserMagic);
            if m_Skill69NH >= nSpellPoint then begin
              if nSpellPoint > 0 then begin
                m_Skill69NH := _MAX(0, m_Skill69NH - nSpellPoint);
                SendRefMsg(RM_MAGIC69SKILLNH, 0, m_Skill69NH, m_Skill69MaxNH, 0, '');
              end;
              m_btDirection := GetNextDirection(m_nCurrX, m_nCurrY, nTargetX, nTargetY);
              MagicManager.Attack_69(Self, UserMagic, nTargetX, nTargetY);
            end else begin
              SysMsg('内力不足', c_Green, t_Hint);
              SendRefMsg(RM_MAGICFIREFAIL, 0, 0, 0, 0, '');
            end;
          end else SendRefMsg(RM_MAGICFIREFAIL, 0, 0, 0, 0, '');
          Result := True;
        end;
      SKILL_101: begin //神龙附体
          if Skill101OnOff then begin
            nSpellPoint := GetSpellPoint(UserMagic);
            if m_Skill69NH >= nSpellPoint then begin
              if nSpellPoint > 0 then begin
                m_Skill69NH := _MAX(0, m_Skill69NH - nSpellPoint);
                SendRefMsg(RM_MAGIC69SKILLNH, 0, m_Skill69NH, m_Skill69MaxNH, 0, '');
              end;
              m_boCanUerSkill101 := True;
              m_dwUseSkillTime := GetTickCount();
              SendRefMsg(RM_10205, 22, 0 {X}, 0 {Y}, 0, '');
            end else begin
              SysMsg('内力不足', c_Green, t_Hint);
              SendRefMsg(RM_MAGICFIREFAIL, 0, 0, 0, 0, '');
            end;
          end else SendRefMsg(RM_MAGICFIREFAIL, 0, 0, 0, 0, '');
          Result := True;
        end;
      SKILL_102: begin //唯我独尊
          if Skill102OnOff then begin
            nSpellPoint := GetSpellPoint(UserMagic);
            if m_Skill69NH >= nSpellPoint then begin
              if nSpellPoint > 0 then begin
                m_Skill69NH := _MAX(0, m_Skill69NH - nSpellPoint);
                SendRefMsg(RM_MAGIC69SKILLNH, 0, m_Skill69NH, m_Skill69MaxNH, 0, '');
              end;
              SendRefMsg(RM_SPELL, UserMagic.MagicInfo.btEffect, nTargetX, nTargetY, UserMagic.MagicInfo.wMagicId, '');
              if m_wStatusTimeArr[POISON_STONE] > 0 then m_wStatusTimeArr[POISON_STONE] := 1; //有麻痹状态，直接解除
              m_boCanUerSkill102 := True;
              case UserMagic.btLevel of
                1: begin
                    m_dwUseSkill102Time := GetTickCount() + 3000; //1级持续效果3秒
                    if sSkill102On <> '' then SysMsg(Format_ToStr(sSkill102On, [(m_dwUseSkill102Time - GetTickCount()) div 1000]), c_Green, t_Hint);
                  end;
                2: begin
                    m_dwUseSkill102Time := GetTickCount() + 6000; //2级持续效果6秒
                    if sSkill102On <> '' then SysMsg(Format_ToStr(sSkill102On, [(m_dwUseSkill102Time - GetTickCount()) div 1000]), c_Green, t_Hint);
                  end;
                3: begin //3级持续效果10秒,同时将周围3格内目标的防御和魔防减到0，并且效果持续10秒
                    m_dwUseSkill102Time := GetTickCount() + 10000;
                    if sSkill102On <> '' then SysMsg(Format_ToStr(sSkill102On, [(m_dwUseSkill102Time - GetTickCount()) div 1000]), c_Green, t_Hint);
                    Skill102MagicAttack(m_nCurrX, m_nCurrY, 3);
                  end;
              end;
              SendRefMsg(RM_MAGICFIRE, 0, MakeWord(UserMagic.MagicInfo.btEffectType, UserMagic.MagicInfo.btEffect),
                MakeLong(m_nCurrX, m_nCurrY), Integer(Self), '');
            end else begin
              SysMsg('内力不足', c_Green, t_Hint);
              SendRefMsg(RM_MAGICFIREFAIL, 0, 0, 0, 0, '');
            end;
          end else SendRefMsg(RM_MAGICFIREFAIL, 0, 0, 0, 0, '');
          Result := True;
        end;
      Skill_105: begin //龙卫心法
          if m_boHeartActive then begin //关闭心法
            m_boHeartActive := False;
            RecalcAbilitys();
            CompareSuitItem(False); //套装与身上装备对比
            SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
            m_nCharStatus := GetCharStatus();
            StatusChanged('');
            if (m_MyDivision <> nil) then TDivision(m_MyDivision).CloseMemberHeart(m_sCharName); //关闭弟子心法
          end else begin
            MagicManager.MagBigExplosion_105(self, UserMagic);
          end;
          Result := True;
        end;
{$IFEND}
      SKILL_MOOTEBO {27}: begin //野蛮冲撞
          Result := True;
          if (GetTickCount - m_dwDoMotaeboTick) > 3000 {3 * 1000} then begin
            m_dwDoMotaeboTick := GetTickCount();
            m_btDirection := nTargetX;
            nSpellPoint := GetSpellPoint(UserMagic);
            if m_WAbil.MP >= nSpellPoint then begin
              if nSpellPoint > 0 then begin
                DamageSpell(nSpellPoint);
                HealthSpellChanged();
              end;
              if DoMotaebo(m_btDirection, UserMagic.btLevel) then begin
                if UserMagic.btLevel < 3 then begin
                  if UserMagic.MagicInfo.TrainLevel[UserMagic.btLevel] < m_Abil.Level then begin
                    TrainSkill(UserMagic, Random(3) + 1);
                    if not CheckMagicLevelup(UserMagic) then begin
                      SendDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 1000);
                    end;
                  end;
                end;
              end;
            end;
          end;
        end;
      SKILL_40: begin //抱月刀法
          if m_MagicCrsSkill <> nil then begin
            if not m_boCrsHitkill then begin
              SkillCrsOnOff(True);
              SendSocket(nil, '+CRS');
            end else begin
              SkillCrsOnOff(False);
              SendSocket(nil, '+UCRS');
            end;
          end;
          Result := True;
        end;
      SKILL_42: begin //开天斩
          if m_Magic42Skill <> nil then begin
            if Skill42OnOff then begin
              nSpellPoint := GetSpellPoint(UserMagic);
              if m_WAbil.MP >= nSpellPoint then begin
                if nSpellPoint > 0 then begin
                  DamageSpell(nSpellPoint);
                  HealthSpellChanged();
                end;
                //增加 开天轻击 20080212
                if Random(g_Config.n43KillHitRate) = 0 then begin
                  m_n42kill := 2;
                  SendSocket(nil, '+TWN');
                end else begin
                  m_n42kill := 1;
                  SendSocket(nil, '+QTWN'); //轻击
                end;
              end;
            end;
          end;
          Result := True;
        end;
      SKILL_43: begin //龙影剑法(破空剑) 20080131
          if m_Magic43Skill <> nil then begin
            if Skill43OnOff then begin
              nSpellPoint := GetSpellPoint(UserMagic);
              if m_WAbil.MP >= nSpellPoint then begin
                if nSpellPoint > 0 then begin
                  DamageSpell(nSpellPoint);
                  HealthSpellChanged();
                end;
                SendSocket(nil, '+CID');
              end;
            end;
          end;
          Result := True;
        end;
    else begin
        n14 := GetNextDirection(m_nCurrX, m_nCurrY, nTargetX, nTargetY);
        m_btDirection := n14;
        BaseObject := nil;
        //检查目标角色，与目标座标误差范围，如果在误差范围内则修正目标座标
        case UserMagic.wMagIdx of //20080814 修改
          60..65, SKIll_110..SKILL_114: begin
              if CretInNearXY(TargeTBaseObject, nTargetX, nTargetY, 12) then begin
                BaseObject := TargeTBaseObject;
                nTargetX := BaseObject.m_nCurrX;
                nTargetY := BaseObject.m_nCurrY;
              end;
            end;
        else begin
            if CretInNearXY(TargeTBaseObject, nTargetX, nTargetY) then begin
              BaseObject := TargeTBaseObject;
              nTargetX := BaseObject.m_nCurrX;
              nTargetY := BaseObject.m_nCurrY;
            end;
          end;
        end; //case
        if not DoSpell(UserMagic, nTargetX, nTargetY, BaseObject) then begin
          SendRefMsg(RM_MAGICFIREFAIL, 0, 0, 0, 0, '');
        end;
        Result := True;
      end;
    end;
  end;
end;

function TBaseObject.CanRun(nCurrX, nCurrY, nX, nY: Integer; boFlag: Boolean): Boolean;
var
  btDir: Byte;
begin
  Result := False;
  btDir := GetNextDirection(nCurrX, nCurrY, nX, nY);
  case btDir of
    DR_UP {0}: begin
        if (nCurrY > 1) and
          (m_PEnvir.CanWalkEx(nCurrX, nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
          (m_PEnvir.CanWalkEx(nCurrX, nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone))
          then begin
          Result := True;
        end;
      end;
    DR_UPRIGHT {1}: begin
        if (nCurrX < m_PEnvir.m_nWidth - 2) and
          (nCurrY > 1) and
          (m_PEnvir.CanWalkEx(nCurrX + 1, nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
          (m_PEnvir.CanWalkEx(nCurrX + 2, nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone))
          then begin
          Result := True;
        end;
      end;
    DR_RIGHT {2}: begin
        if (nCurrX < m_PEnvir.m_nWidth - 2) and
          (m_PEnvir.CanWalkEx(nCurrX + 1, nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
          (m_PEnvir.CanWalkEx(nCurrX + 2, nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone))
          then begin
          Result := True;
        end;
      end;
    DR_DOWNRIGHT {3}: begin
        if (nCurrX < m_PEnvir.m_nWidth - 2) and
          (nCurrY < m_PEnvir.m_nHeight - 2) and
          (m_PEnvir.CanWalkEx(nCurrX + 1, nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
          (m_PEnvir.CanWalkEx(nCurrX + 2, nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone))
          then begin
          Result := True;
        end;
      end;
    DR_DOWN {4}: begin
        if (nCurrY < m_PEnvir.m_nHeight - 2) and
          (m_PEnvir.CanWalkEx(nCurrX, nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
          (m_PEnvir.CanWalkEx(nCurrX, nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone))
          then begin
          Result := True;
        end;
      end;
    DR_DOWNLEFT {5}: begin
        if (nCurrX > 1) and
          (nCurrY < m_PEnvir.m_nHeight - 2) and
          (m_PEnvir.CanWalkEx(nCurrX - 1, nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
          (m_PEnvir.CanWalkEx(nCurrX - 2, nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone))
          then begin
          Result := True;
        end;
      end;
    DR_LEFT {6}: begin
        if (nCurrX > 1) and
          (m_PEnvir.CanWalkEx(nCurrX - 1, nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
          (m_PEnvir.CanWalkEx(nCurrX - 2, nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone))
          then begin
          Result := True;
        end;
      end;
    DR_UPLEFT {7}: begin
        if (nCurrX > 1) and
          (nCurrY > 1) and
          (m_PEnvir.CanWalkEx(nCurrX - 1, nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
          (m_PEnvir.CanWalkEx(nCurrX - 2, nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone))
          then begin
          Result := True;
        end;
      end;
  end;
end;

function TBaseObject.CanRun(nX, nY: Integer; boFlag: Boolean): Boolean;
var
  btDir: Byte;
begin
  Result := False;
  btDir := GetNextDirection(m_nCurrX, m_nCurrY, nX, nY);
  case btDir of
    DR_UP {0}: begin
        if (m_nCurrY > 1) and
          (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
          (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone))
          then begin
          Result := True;
        end;
      end;
    DR_UPRIGHT {1}: begin
        if (m_nCurrX < m_PEnvir.m_nWidth - 2) and
          (m_nCurrY > 1) and
          (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
          (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone))
          then begin
          Result := True;
        end;
      end;
    DR_RIGHT {2}: begin
        if (m_nCurrX < m_PEnvir.m_nWidth - 2) and
          (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
          (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone))
          then begin
          Result := True;
        end;
      end;
    DR_DOWNRIGHT {3}: begin
        if (m_nCurrX < m_PEnvir.m_nWidth - 2) and
          (m_nCurrY < m_PEnvir.m_nHeight - 2) and
          (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
          (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone))
          then begin
          Result := True;
        end;
      end;
    DR_DOWN {4}: begin
        if (m_nCurrY < m_PEnvir.m_nHeight - 2) and
          (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
          (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone))
          then begin
          Result := True;
        end;
      end;
    DR_DOWNLEFT {5}: begin
        if (m_nCurrX > 1) and
          (m_nCurrY < m_PEnvir.m_nHeight - 2) and
          (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
          (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone))
          then begin
          Result := True;
        end;
      end;
    DR_LEFT {6}: begin
        if (m_nCurrX > 1) and
          (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
          (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone))
          then begin
          Result := True;
        end;
      end;
    DR_UPLEFT {7}: begin
        if (m_nCurrX > 1) and
          (m_nCurrY > 1) and
          (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
          (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone))
          then begin
          Result := True;
        end;
      end;
  end;
end;

function TBaseObject.CanMove(nX, nY: Integer; boFlag: Boolean): Boolean;
begin
  if (abs(m_nCurrX - nX) <= 1) and (abs(m_nCurrY - nY) <= 1) then begin
    Result := m_PEnvir.CanWalkEx(nX, nY, boFlag);
  end else begin
    Result := CanRun(nX, nY, boFlag);
  end;
end;

function TBaseObject.CanMove(nCurrX, nCurrY, nX, nY: Integer; boFlag: Boolean): Boolean;
begin
  if (abs(nCurrX - nX) <= 1) and (abs(nCurrY - nY) <= 1) then begin
    Result := m_PEnvir.CanWalkEx(nX, nY, boFlag);
  end else begin
    Result := CanRun(nCurrX, nCurrY, nX, nY, boFlag);
  end;
end;

function TBaseObject.RunTo(btDir: Byte; boFlag: Boolean; nDestX, nDestY: Integer): Boolean;
var
  nOldX, nOldY: Integer;
begin
  Result := False;
  if m_wStatusTimeArr[POISON_DONTMOVE] <> 0 then Exit;
  try
    nOldX := m_nCurrX;
    nOldY := m_nCurrY;
    m_btDirection := btDir;
    case btDir of
      DR_UP {0}: begin
          if (m_nCurrY > 1) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and {InSafeZone} RunToCheckInSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and {InSafeZone} RunToCheckInSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX, m_nCurrY - 2, True) > 0) then begin
            Dec(m_nCurrY, 2);
          end;
        end;
      DR_UPRIGHT {1}: begin
          if (m_nCurrX < m_PEnvir.m_nWidth - 2) and (m_nCurrY > 1) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and {InSafeZone} RunToCheckInSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and {InSafeZone} RunToCheckInSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 2, m_nCurrY - 2, True) > 0) then begin
            Inc(m_nCurrX, 2);
            Dec(m_nCurrY, 2);
          end;
        end;
      DR_RIGHT {2}: begin
          if (m_nCurrX < m_PEnvir.m_nWidth - 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and {InSafeZone} RunToCheckInSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and {InSafeZone} RunToCheckInSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 2, m_nCurrY, True) > 0) then begin
            Inc(m_nCurrX, 2);
          end;
        end;
      DR_DOWNRIGHT {3}: begin
          if (m_nCurrX < m_PEnvir.m_nWidth - 2) and (m_nCurrY < m_PEnvir.m_nHeight - 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and {InSafeZone} RunToCheckInSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and {InSafeZone} RunToCheckInSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 2, m_nCurrY + 2, True) > 0) then begin
            Inc(m_nCurrX, 2);
            Inc(m_nCurrY, 2);
          end;
        end;
      DR_DOWN {4}: begin
          if (m_nCurrY < m_PEnvir.m_nHeight - 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and {InSafeZone} RunToCheckInSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and {InSafeZone} RunToCheckInSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX, m_nCurrY + 2, True) > 0) then begin
            Inc(m_nCurrY, 2);
          end;
        end;
      DR_DOWNLEFT {5}: begin
          if (m_nCurrX > 1) and (m_nCurrY < m_PEnvir.m_nHeight - 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and {InSafeZone} RunToCheckInSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and {InSafeZone} RunToCheckInSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 2, m_nCurrY + 2, True) > 0) then begin
            Dec(m_nCurrX, 2);
            Inc(m_nCurrY, 2);
          end;
        end;
      DR_LEFT {6}: begin
          if (m_nCurrX > 1) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and {InSafeZone} RunToCheckInSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and {InSafeZone} RunToCheckInSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 2, m_nCurrY, True) > 0) then begin
            Dec(m_nCurrX, 2);
          end;
        end;
      DR_UPLEFT {7}: begin
          if (m_nCurrX > 1) and (m_nCurrY > 1) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and {InSafeZone} RunToCheckInSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and {InSafeZone} RunToCheckInSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 2, m_nCurrY - 2, True) > 0) then begin
            Dec(m_nCurrX, 2);
            Dec(m_nCurrY, 2);
          end;
        end;
    end;
    if ((m_nCurrX <> nOldX) or (m_nCurrY <> nOldY)) {and ((m_nCurrX = nDestX) and (m_nCurrY = nDestY))} then begin
      if Walk(RM_RUN) then Result := True
      else begin
        m_nCurrX := nOldX;
        m_nCurrY := nOldY;
        m_PEnvir.MoveToMovingObject(nOldX, nOldY, Self, m_nCurrX, m_nCurrY, True);
      end;
    end;
  except
    MainOutMessage(Format('{%s} TBaseObject::RunTo %p', [g_sExceptionVer, ExceptAddr]));
  end;
end;
//英雄，人形怪使用 20090525

function TBaseObject.RunTo1(btDir: Byte; boFlag: Boolean; nDestX, nDestY: Integer): Boolean;
var
  nOldX, nOldY: Integer;
resourcestring
  sExceptionMsg = '{%s} TBaseObject::RunTo1 %p';
begin
  Result := False;
  if m_wStatusTimeArr[POISON_DONTMOVE] <> 0 then Exit; //20090907 增加
  try
    nOldX := m_nCurrX;
    nOldY := m_nCurrY;
    m_btDirection := btDir;
    case btDir of
      DR_UP {0}: begin
          if (m_nCurrY > 1) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone and not m_PEnvir.m_boSAFEHERONORUN)) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone and not m_PEnvir.m_boSAFEHERONORUN)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX, m_nCurrY - 2, True) > 0) then begin
            Dec(m_nCurrY, 2);
          end;
        end;
      DR_UPRIGHT {1}: begin
          if (m_nCurrX < m_PEnvir.m_nWidth - 2) and
            (m_nCurrY > 1) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone and not m_PEnvir.m_boSAFEHERONORUN)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone and not m_PEnvir.m_boSAFEHERONORUN)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 2, m_nCurrY - 2, True) > 0) then begin
            Inc(m_nCurrX, 2);
            Dec(m_nCurrY, 2);
          end;
        end;
      DR_RIGHT {2}: begin
          if (m_nCurrX < m_PEnvir.m_nWidth - 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone and not m_PEnvir.m_boSAFEHERONORUN)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone and not m_PEnvir.m_boSAFEHERONORUN)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 2, m_nCurrY, True) > 0) then begin
            Inc(m_nCurrX, 2);
          end;
        end;
      DR_DOWNRIGHT {3}: begin
          if (m_nCurrX < m_PEnvir.m_nWidth - 2) and
            (m_nCurrY < m_PEnvir.m_nHeight - 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone and not m_PEnvir.m_boSAFEHERONORUN)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone and not m_PEnvir.m_boSAFEHERONORUN)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 2, m_nCurrY + 2, True) > 0) then begin
            Inc(m_nCurrX, 2);
            Inc(m_nCurrY, 2);
          end;
        end;
      DR_DOWN {4}: begin
          if (m_nCurrY < m_PEnvir.m_nHeight - 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone and not m_PEnvir.m_boSAFEHERONORUN)) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone and not m_PEnvir.m_boSAFEHERONORUN)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX, m_nCurrY + 2, True) > 0) then begin
            Inc(m_nCurrY, 2);
          end;
        end;
      DR_DOWNLEFT {5}: begin
          if (m_nCurrX > 1) and
            (m_nCurrY < m_PEnvir.m_nHeight - 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone and not m_PEnvir.m_boSAFEHERONORUN)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone and not m_PEnvir.m_boSAFEHERONORUN)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 2, m_nCurrY + 2, True) > 0) then begin
            Dec(m_nCurrX, 2);
            Inc(m_nCurrY, 2);
          end;
        end;
      DR_LEFT {6}: begin
          if (m_nCurrX > 1) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone and not m_PEnvir.m_boSAFEHERONORUN)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone and not m_PEnvir.m_boSAFEHERONORUN)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 2, m_nCurrY, True) > 0) then begin
            Dec(m_nCurrX, 2);
          end;
        end;
      DR_UPLEFT {7}: begin
          if (m_nCurrX > 1) and (m_nCurrY > 1) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone and not m_PEnvir.m_boSAFEHERONORUN)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone and not m_PEnvir.m_boSAFEHERONORUN)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 2, m_nCurrY - 2, True) > 0) then begin
            Dec(m_nCurrX, 2);
            Dec(m_nCurrY, 2);
          end;
        end;
    end;
    if ((m_nCurrX <> nOldX) or (m_nCurrY <> nOldY)) {and ((m_nCurrX = nDestX) and (m_nCurrY = nDestY))} then begin
      if Walk(RM_RUN) then Result := True
      else begin
        m_nCurrX := nOldX;
        m_nCurrY := nOldY;
        m_PEnvir.MoveToMovingObject(nOldX, nOldY, Self, m_nCurrX, m_nCurrY {m_nCurrX}, True); //20090525 修改
      end;
    end;
  except
    MainOutMessage(Format(sExceptionMsg, [g_sExceptionVer, ExceptAddr]));
  end;
end;

function TPlayObject.HorseRunTo(btDir: Byte; boFlag: Boolean): Boolean;
var
  n10, n14: Integer;
resourcestring
  sExceptionMsg = '{%s} TPlayObject::HorseRunTo %p';
begin
  Result := False;
  try
    n10 := m_nCurrX;
    n14 := m_nCurrY;
    m_btDirection := btDir;
    case btDir of
      DR_UP {0}: begin
          if (m_nCurrY > 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 3, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX, m_nCurrY - 3, True) > 0) then begin
            Dec(m_nCurrY, 3);
          end;
        end;
      DR_UPRIGHT {1}: begin
          if (m_nCurrX < m_PEnvir.m_nWidth - 3) and
            (m_nCurrY > 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 3, m_nCurrY - 3, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 3, m_nCurrY - 3, True) > 0) then begin
            Inc(m_nCurrX, 3);
            Dec(m_nCurrY, 3);
          end;
        end;
      DR_RIGHT {2}: begin
          if (m_nCurrX < m_PEnvir.m_nWidth - 3) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 3, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 3, m_nCurrY, True) > 0) then begin
            Inc(m_nCurrX, 3);
          end;
        end;
      DR_DOWNRIGHT {3}: begin
          if (m_nCurrX < m_PEnvir.m_nWidth - 3) and
            (m_nCurrY < m_PEnvir.m_nHeight - 3) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 3, m_nCurrY + 3, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 3, m_nCurrY + 3, True) > 0) then begin
            Inc(m_nCurrX, 3);
            Inc(m_nCurrY, 3);
          end;
        end;
      DR_DOWN {4}: begin
          if (m_nCurrY < m_PEnvir.m_nHeight - 3) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 3, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX, m_nCurrY + 3, True) > 0) then begin
            Inc(m_nCurrY, 3);
          end;
        end;
      DR_DOWNLEFT {5}: begin
          if (m_nCurrX > 2) and
            (m_nCurrY < m_PEnvir.m_nHeight - 3) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 3, m_nCurrY + 3, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 3, m_nCurrY + 3, True) > 0) then begin
            Dec(m_nCurrX, 3);
            Inc(m_nCurrY, 3);
          end;
        end;
      DR_LEFT {6}: begin
          if (m_nCurrX > 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 3, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 3, m_nCurrY, True) > 0) then begin
            Dec(m_nCurrX, 3);
          end;
        end;
      DR_UPLEFT {7}: begin
          if (m_nCurrX > 2) and
            (m_nCurrY > 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 3, m_nCurrY - 3, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 3, m_nCurrY - 3, True) > 0) then begin
            Dec(m_nCurrX, 3);
            Dec(m_nCurrY, 3);
          end;
        end;
    end;
    if (m_nCurrX <> n10) or (m_nCurrY <> n14) then begin
      if Walk(RM_HORSERUN) then Result := True
      else begin
        m_nCurrX := n10;
        m_nCurrY := n14;
        m_PEnvir.MoveToMovingObject(n10, n14, Self, m_nCurrX, m_nCurrY {m_nCurrX}, True); //20090525 修改
      end;
    end;
  except
    MainOutMessage(Format(sExceptionMsg, [g_sExceptionVer, ExceptAddr]));
  end;
end;

function TPlayObject.ClientRunXY(wIdent: Word; nX, nY: Integer; nFlag: Integer; var dwDelayTime: LongWord): Boolean; //004CB11C
var
  nDir: Integer;
  dwRunTime, dwCheckTime: LongWord;
begin
  Result := False;
  dwDelayTime := 0;
  if (not m_boCanRun) or
  //增加禁锢检测 By TasNat at: 2012-03-08 12:22:41
  (InMag113LockRect(nX, nY)) or
   (abs(nX - m_nCurrX) > 2) or (abs(nY - m_nCurrY) > 2) then begin //20110422 当坐标超过2格则不处理
    SendMsg(Self, RM_MOVEFAIL, 0, 0, 0, 0, ''); //20110422 发送移动失败消息，让客户端退出原坐标
    Exit;
  end;
  if m_boDeath or ((m_wStatusTimeArr[POISON_STONE] <> 0) and not g_ClientConf.boParalyCanRun) or
    (m_wStatusTimeArr[POISON_DONTMOVE] <> 0) or (m_wStatusTimeArr[POISON_LOCKSPELL {7}] <> 0)
    or (m_wStatusArrValue[23] <> 0) then Exit; //防麻

  if nFlag <> wIdent then begin
    if not CheckActionStatus(wIdent, dwDelayTime) then begin
      m_boFilterAction := False;
      Exit;
    end;
    m_boFilterAction := True;
    dwRunTime := _MAX(0, Integer(g_Config.dwRunIntervalTime) - m_nRunSpeed); //防止负数出错(移动速度) 20110814
    dwCheckTime := GetTickCount - m_dwMoveTick;
    if dwCheckTime < dwRunTime then begin
      Inc(m_dwMoveCount);
      dwDelayTime := dwRunTime - dwCheckTime;
      if dwDelayTime > g_Config.dwRunIntervalTime div 3 then begin
        if m_dwMoveCount >= 4 then begin
          m_dwMoveTick := GetTickCount();
          m_dwMoveCount := 0;
          dwDelayTime := g_Config.dwRunIntervalTime div 3;
          if m_boTestSpeedMode then
            SysMsg('跑步忙复位！' + IntToStr(dwDelayTime), c_Red, t_Hint);
        end else m_dwMoveCount := 0;
        Exit;
      end else begin
        if m_boTestSpeedMode then
          SysMsg('跑步忙！' + IntToStr(dwDelayTime), c_Red, t_Hint);
        Exit;
      end;
    end;
  end;
{$IF M2Version = 1}
  if m_boUseBatter and (m_btJob <> 0) then begin //道法连击走动时停止 20110115
    m_nUseBatterTick := GetTickCount(); //使用连击的计时
    m_nUseBatterTime := 0;
    m_nBatterMagIdx1 := 0; //连击技能ID1
    m_nBatterMagIdx2 := 0; //连击技能ID2
    m_nBatterMagIdx3 := 0; //连击技能ID3
    m_nBatterMagIdx4 := 0; //连击技能ID4
  end;
{$IFEND}
  m_dwMoveTick := GetTickCount();
  m_bo316 := False;
  nDir := GetNextDirection(m_nCurrX, m_nCurrY, nX, nY);
  if RunTo(nDir, False, nX, nY) then begin
    m_dwStationTick := GetTickCount; //增加检测人物站立不动时间
    if m_boTransparent and (m_boHideMode) then m_wStatusTimeArr[STATE_TRANSPARENT] := 1;
    if m_bo316 or ((m_nCurrX = nX) and (m_nCurrY = nY)) then Result := True;
    Dec(m_nHealthTick, 60);
    Dec(m_nSpellTick, 10);
    m_nSpellTick := _MAX(0, m_nSpellTick);
    Dec(m_nPerHealth);
    Dec(m_nPerSpell);
  end else begin
    m_dwMoveCount := 0;
    m_dwMoveCountA := 0;
  end;
end;

function TPlayObject.ClientWalkXY(wIdent: Word; nX, nY: Integer; boLateDelivery: Boolean; var dwDelayTime: LongWord): Boolean; //004CAF08
var
  n14: Integer;
  dwCheckTime: LongWord;
begin
  Result := False;
  dwDelayTime := 0;
  if (not m_boCanWalk) or
  //增加禁锢检测 By TasNat at: 2012-03-08 12:22:41
    ((abs(nX - m_nCurrX) > 1) or (abs(nY - m_nCurrY) > 1)) or //20110422 当坐标超过1格则不处理
   (InMag113LockRect(nX, nY)) then begin
    SendMsg(Self, RM_MOVEFAIL, 0, 0, 0, 0, ''); //20110422 发送移动失败消息，让客户端退出原坐标
    Exit;
  end;
  if m_boDeath or ((m_wStatusTimeArr[POISON_STONE {5}] <> 0) and not g_ClientConf.boParalyCanWalk)
    or (m_wStatusTimeArr[POISON_DONTMOVE] <> 0) or (m_wStatusTimeArr[POISON_LOCKSPELL {7}] <> 0)
    or (m_wStatusArrValue[23] <> 0) then Exit; //防麻
  if not boLateDelivery then begin
    if not CheckActionStatus(wIdent, dwDelayTime) then begin
      m_boFilterAction := False;
      Exit;
    end;
    m_boFilterAction := True;
    dwCheckTime := GetTickCount - m_dwMoveTick;
    if dwCheckTime < g_Config.dwWalkIntervalTime then begin
      Inc(m_dwMoveCount);
      dwDelayTime := g_Config.dwWalkIntervalTime - dwCheckTime;
      if dwDelayTime > g_Config.dwWalkIntervalTime div 3 then begin
        if m_dwMoveCount >= 4 then begin
          m_dwMoveTick := GetTickCount();
          m_dwMoveCount := 0;
          dwDelayTime := g_Config.dwWalkIntervalTime div 3;
          if m_boTestSpeedMode then SysMsg('走路忙复位！' + IntToStr(dwDelayTime), c_Red, t_Hint);
        end else m_dwMoveCount := 0;
        Exit;
      end else begin
        if m_boTestSpeedMode then SysMsg('走路忙！' + IntToStr(dwDelayTime), c_Red, t_Hint);
        Exit;
      end;
    end;
  end;
{$IF M2Version = 1}
  if m_boUseBatter and (m_btJob <> 0) then begin //道法连击走动时停止 20110115
    m_nUseBatterTick := GetTickCount(); //使用连击的计时
    m_nUseBatterTime := 0;
    m_nBatterMagIdx1 := 0; //连击技能ID1
    m_nBatterMagIdx2 := 0; //连击技能ID2
    m_nBatterMagIdx3 := 0; //连击技能ID3
    m_nBatterMagIdx4 := 0; //连击技能ID4
  end;
{$IFEND}
  m_dwMoveTick := GetTickCount();
  m_bo316 := False;
  n14 := GetNextDirection(m_nCurrX, m_nCurrY, nX, nY);
  {if not m_boClientFlag then begin//20110303注释
    if (n14 = 0) and (m_nStep = 0) then Inc(m_nStep)
    else if (n14 = 4) and (m_nStep = 1) then Inc(m_nStep)
    else if (n14 = 6) and (m_nStep = 2) then Inc(m_nStep)
    else if (n14 = 2) and (m_nStep = 3) then Inc(m_nStep)
    else if (n14 = 1) and (m_nStep = 4) then Inc(m_nStep)
    else if (n14 = 5) and (m_nStep = 5) then Inc(m_nStep)
    else if (n14 = 7) and (m_nStep = 6) then Inc(m_nStep)
    else if (n14 = 3) and (m_nStep = 7) then Inc(m_nStep)
    else begin
      m_nStep := 0;
    end;
  end; }
  if WalkTo(n14, m_PEnvir.CanWalkEx(nX, nY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)) or (g_Config.boSafeAreaLimited and InSafeZone)) then begin //20100825 可以走路穿人
  //if WalkTo(n14, False) then begin
    m_dwStationTick := GetTickCount; //增加检测人物站立不动时间
    if m_bo316 or ((m_nCurrX = nX) and (m_nCurrY = nY)) then Result := True;
    Dec(m_nHealthTick, 10);
  end else begin
    m_dwMoveCount := 0;
    m_dwMoveCountA := 0;
  end;
end;
//刺杀剑法开关

procedure TBaseObject.ThrustingOnOff(boSwitch: Boolean);
begin
  m_boUseThrusting := boSwitch;
  if m_boUseThrusting then begin
    case m_btRaceServer of
      RC_PLAYOBJECT: SysMsg(sThrustingOn, c_Green, t_Hint);
      //RC_HEROOBJECT: THeroObject(Self).SysMsg('(英雄) ' +sThrustingOn, BB_Fuchsia, t_Hint);
    end;
  end else begin
    case m_btRaceServer of
      RC_PLAYOBJECT: SysMsg(sThrustingOff, c_Green, t_Hint);
      //RC_HEROOBJECT: THeroObject(Self).SysMsg('(英雄) ' +sThrustingOff, BB_Fuchsia, t_Hint);
    end;
  end;
end;
//半月,圆月弯刀开关 0-半月 1-圆月

procedure TBaseObject.HalfMoonOnOff(boSwitch: Boolean; nType: Byte);
begin
  m_boUseHalfMoon := boSwitch;
  if m_boUseHalfMoon then begin
    case m_btRaceServer of
      RC_PLAYOBJECT: begin
          case nType of
            0: SysMsg(sHalfMoonOn, c_Green, t_Hint);
            1: SysMsg(sHalfMoonOn4, c_Green, t_Hint);
          end;
        end;
      {RC_HEROOBJECT:begin
        case nType of
          0: THeroObject(Self).SysMsg('(英雄) ' +sHalfMoonOn, BB_Fuchsia, t_Hint);
          1: THeroObject(Self).SysMsg('(英雄) ' +sHalfMoonOn4, BB_Fuchsia, t_Hint);
        end;
      end; }
    end;
  end else begin
    case m_btRaceServer of
      RC_PLAYOBJECT: begin
          case nType of
            0: SysMsg(sHalfMoonOff, c_Green, t_Hint);
            1: SysMsg(sHalfMoonOff4, c_Green, t_Hint);
          end;
        end;
     { RC_HEROOBJECT:begin
        case nType of
          0: THeroObject(Self).SysMsg('(英雄) ' +sHalfMoonOff, BB_Fuchsia, t_Hint);
          1: THeroObject(Self).SysMsg('(英雄) ' +sHalfMoonOff4, BB_Fuchsia, t_Hint);
        end;
      end;}
    end;
  end;
end;

procedure TBaseObject.SkillCrsOnOff(boSwitch: Boolean);
begin
  m_boCrsHitkill := boSwitch;
  if m_boCrsHitkill then begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sCrsHitOn, c_Green, t_Hint);
    {end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) ' +sCrsHitOn, BB_Fuchsia, t_Hint); //20080312  }
    end;
  end else begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sCrsHitOff, c_Green, t_Hint);
    {end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) ' +sCrsHitOff, BB_Fuchsia, t_Hint);//20080312    }
    end;
  end;
end;

//开天斩 20080202

function TBaseObject.Skill42OnOff(): Boolean;
begin
  Result := False;
  if (GetTickCount - m_dwLatest42Tick) > g_Config.nKill43UseTime * 1000 then begin
    m_dwLatest42Tick := GetTickCount();
    m_bo42kill := True;
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sSkill42On, c_Green, t_Hint);
    {end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) '+sSkill42On, BB_Fuchsia, t_Hint); //20080312 }
    end;
    Result := True;
  end else begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sSkill42Off, c_Green, t_Hint);
    {end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) '+sSkill42Off, BB_Fuchsia, t_Hint); //20080312 }
    end;
  end;
end;
//20080619 替换

function TBaseObject.Skill43OnOff(): Boolean;
begin
  Result := False;
  if (GetTickCount - m_dwLatest43Tick) > g_Config.nKill42UseTime * 1000 then begin //20080619 增加
    m_dwLatest43Tick := GetTickCount(); //20080619 增加
    m_bo43kill := True; //20080619 增加
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sSkill43On, c_Green, t_Hint);
    {end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) '+sSkill43On, BB_Fuchsia, t_Hint); //20080312  }
    end;
    Result := True;
  end else begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sSkill43Off, c_Green, t_Hint);
    {end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) '+ sSkill43Off, BB_Fuchsia, t_Hint); //20080312   }
    end;
  end;
end;
{$IF M2Version <> 2}

function TPlayObject.Skill69OnOff(): Boolean;
begin
  Result := False;
  if (GetTickCount - m_dwLatest69Tick) > g_Config.nKill69UseTime * 1000 then begin
    m_dwLatest69Tick := GetTickCount();
    SysMsg(sSkill69On, c_Green, t_Hint);
    Result := True;
  end else begin
    if sSkill69Off <> '' then
      SysMsg(Format_ToStr(sSkill69Off, [(g_Config.nKill69UseTime * 1000 - (GetTickCount() - m_dwLatest69Tick)) div 1000]), c_Green, t_Hint); //提示用户
  end;
end;

//神龙附体

function TPlayObject.Skill101OnOff(): Boolean;
begin
  Result := False;
  if not m_boCanUerSkill101 then begin
    if (GetTickCount - m_dwLatest101Tick) >= g_Config.nKill101UseTime * 1000 then begin
      m_dwLatest101Tick := GetTickCount();
      SysMsg(sSkill101On, c_Green, t_Hint);
      Result := True;
    end else begin
      if sSkill101Off <> '' then SysMsg(Format_ToStr(sSkill101Off, [(g_Config.nKill101UseTime * 1000 - (GetTickCount() - m_dwLatest101Tick)) div 1000]), c_Green, t_Hint); //提示用户
    end;
  end;
end;

//唯我独尊

function TPlayObject.Skill102OnOff(): Boolean;
begin
  Result := False;
  if not m_boCanUerSkill102 then begin
    if (GetTickCount - m_dwLatest102Tick) >= g_Config.nKill102UseTime * 1000 then begin //5分钟冷却时间
      m_dwLatest102Tick := GetTickCount();
      Result := True;
    end else begin
      if sSkill102Off <> '' then SysMsg(Format_ToStr(sSkill102Off, [((g_Config.nKill102UseTime * 1000) - (GetTickCount() - m_dwLatest102Tick)) div 1000]), c_Green, t_Hint); //提示用户
    end;
  end;
end;
//3级唯我独尊处理(目标的防御和魔防减到0，并且效果持续10秒)

procedure TPlayObject.Skill102MagicAttack(nX, nY: Integer; nRage: Integer);
var
  I: Integer;
  BaseObjectList: TList;
  TargeTBaseObject: TBaseObject;
begin
  BaseObjectList := TList.Create;
  try
    m_PEnvir.GetMapBaseObjects(nX, nY, nRage, BaseObjectList);
    if BaseObjectList.Count > 0 then begin
      for I := 0 to BaseObjectList.Count - 1 do begin
        TargeTBaseObject := TBaseObject(BaseObjectList.Items[I]);
        if TargeTBaseObject <> nil then begin
          if (TargeTBaseObject.m_Master <> nil) and (TargeTBaseObject.m_Master = self) then Continue; //自己下属不处理
          if IsProperTarget(TargeTBaseObject) and (TargeTBaseObject.m_btRaceServer <> 79) then begin
            if TargeTBaseObject.m_btRaceServer = RC_HEROOBJECT then begin //英雄锁定后,不打锁定怪
              if not THeroObject(TargeTBaseObject).m_boTarget then TargeTBaseObject.SetTargetCreat(self);
            end else TargeTBaseObject.SetTargetCreat(self);
            TargeTBaseObject.MakeSkill102Mag(g_Config.nSill102TargetDecACTime); //
          end;
        end;
      end;
    end;
  finally
    BaseObjectList.Free;
  end;
end;
//检查是否可以得到称号

function TPlayObject.CheckFengHaoNeed(var HumTitleDB: THumTitleDB): Boolean;
begin
  Result := False;
  case HumTitleDB.Need of
    0: begin //等级
        if m_Abil.Level >= HumTitleDB.NeedLevel then begin
          Result := True;
        end else begin
          SysMsg(g_sLevelNot, c_Red, t_Hint);
        end;
      end;
    1: begin //攻击力
        if HiWord(m_WAbil.DC) >= HumTitleDB.NeedLevel then begin
          Result := True;
        end else begin
          SysMsg(g_sDCNot, c_Red, t_Hint);
        end;
      end;
    2: begin //魔法
        if HiWord(m_WAbil.MC) >= HumTitleDB.NeedLevel then begin
          Result := True;
        end else begin
          SysMsg(g_sMCNot, c_Red, t_Hint);
        end;
      end;
    3: begin //道术
        if HiWord(m_WAbil.SC) >= HumTitleDB.NeedLevel then begin
          Result := True;
        end else begin
          SysMsg(g_sSCNot, c_Red, t_Hint);
        end;
      end;
  end;
end;

//取称号的属性

procedure TPlayObject.GetFengHaoAbility(var FengHaoAbility: TFengHaoAbility);
var
  I: Integer;
  HumTitleDB: pTHumTitleDB;
begin
  m_boStickMode := False; //不能冲撞
  m_nStickIncLevel := 0; //称号不动如山增加冲撞技能等级

  m_boFengHaoPower := False; //封号增加攻击倍率
  m_nFengHaoMinPowerRate := 0; //封号最低攻击倍率
  m_nFengHaoMaxPowerRate := 0; //封号最高攻击倍率

  m_GroupOwnerExp := False; //组队队长,经验翻倍
  m_boFengHaoMagicEffect := False; //魔法粉红效果(传奇之星)
  m_boFengHaoHuhua := False; //护花使者称号
  m_sHuhuaName := ''; //对应的传奇之星名字

  m_boFengHaoDominate := False; //主宰称号
  m_boFengHaoComrade := False; //主宰龙卫
  m_sDominateName := ''; //对应的主宰名字
  if m_boCanTitle then begin
    if g_Config.boUseFengHaoAbil then begin
      for I := Low(THumTitles) to High(THumTitles) do begin
        if (m_wHumTitles[I].wIndex > 0) and (m_wHumTitles[I].MakeIndex > 0) and (m_wHumTitles[I].boUseTitle) then begin
          HumTitleDB := UserEngine.GetHumTitle(m_wHumTitles[I].wIndex);
          if HumTitleDB <> nil then begin
            case HumTitleDB.AniCount of
              2: begin //主宰龙卫
                  m_boFengHaoComrade := True; //主宰龙卫
                  m_sDominateName := m_wHumTitles[I].sChrName; //对应的主宰名字
                  FengHaoAbility.wHP := _MIN(High(Word), FengHaoAbility.wHP + LoWord(HumTitleDB.AC)); //生命上限
                  FengHaoAbility.wDC := _MIN(High(Word), FengHaoAbility.wDC + HiWord(HumTitleDB.DC)); //攻击力 上限
                  FengHaoAbility.wMC := _MIN(High(Word), FengHaoAbility.wMC + HiWord(HumTitleDB.MC)); //魔法 上限
                  FengHaoAbility.wSC := _MIN(High(Word), FengHaoAbility.wSC + HiWord(HumTitleDB.SC)); //道术 上限
                  FengHaoAbility.wMagicShieldLevel := _MIN(High(Word), FengHaoAbility.wMagicShieldLevel + LoWord(HumTitleDB.MC)); ; //聚魔等级
                  FengHaoAbility.wUnParalysisRate := _MIN(High(Byte), FengHaoAbility.wUnParalysisRate + LoWord(HumTitleDB.DC)); //麻痹抗性(辉煌衣服)
                  FengHaoAbility.wPhysicalLevel := _MIN(High(Word), FengHaoAbility.wPhysicalLevel + HiWord(HumTitleDB.AC)); //强身等级
                  FengHaoAbility.wDecTargetNHPoint := _MIN(High(Byte), FengHaoAbility.wDecTargetNHPoint + LoWord(HumTitleDB.MAC)); //内伤等级
                  FengHaoAbility.wCritLevel := _MIN(High(Byte), FengHaoAbility.wCritLevel + HiWord(HumTitleDB.MAC)); //暴击等级
                  FengHaoAbility.wIncDragonRate := _MIN(High(Word), FengHaoAbility.wSC + LoWord(HumTitleDB.SC)); //合击威力
                end;
              3: begin //护花使者
                  m_boFengHaoHuhua := True; //护花使者称号
                  m_sHuhuaName := m_wHumTitles[I].sChrName; //对应的传奇之星名字
                  FengHaoAbility.wHP := _MIN(High(Word), FengHaoAbility.wHP + LoWord(HumTitleDB.AC)); //生命上限
                  FengHaoAbility.wDC := _MIN(High(Word), FengHaoAbility.wDC + HiWord(HumTitleDB.DC)); //攻击力 上限
                  FengHaoAbility.wMC := _MIN(High(Word), FengHaoAbility.wMC + HiWord(HumTitleDB.MC)); //魔法 上限
                  FengHaoAbility.wSC := _MIN(High(Word), FengHaoAbility.wSC + HiWord(HumTitleDB.SC)); //道术 上限
                  FengHaoAbility.wMagicShieldLevel := _MIN(High(Word), FengHaoAbility.wMagicShieldLevel + LoWord(HumTitleDB.MC)); ; //聚魔等级
                  FengHaoAbility.wUnParalysisRate := _MIN(High(Byte), FengHaoAbility.wUnParalysisRate + LoWord(HumTitleDB.DC)); //麻痹抗性(辉煌衣服)
                  FengHaoAbility.wPhysicalLevel := _MIN(High(Word), FengHaoAbility.wPhysicalLevel + HiWord(HumTitleDB.AC)); //强身等级
                  FengHaoAbility.wDecTargetNHPoint := _MIN(High(Byte), FengHaoAbility.wDecTargetNHPoint + LoWord(HumTitleDB.MAC)); //内伤等级
                  FengHaoAbility.wCritLevel := _MIN(High(Byte), FengHaoAbility.wCritLevel + HiWord(HumTitleDB.MAC)); //暴击等级
                  FengHaoAbility.wIncDragonRate := _MIN(High(Word), FengHaoAbility.wSC + LoWord(HumTitleDB.SC)); //合击威力
                end;
              4: begin //不动如山
                  m_boStickMode := True; //不能冲撞(不动如山)
                  m_nStickIncLevel := 10; //称号不动如山增加冲撞技能等级
                  FengHaoAbility.wHP := _MIN(High(Word), FengHaoAbility.wHP + LoWord(HumTitleDB.AC)); //生命上限
                  FengHaoAbility.wDC := _MIN(High(Word), FengHaoAbility.wDC + HiWord(HumTitleDB.DC)); //攻击力 上限
                  FengHaoAbility.wMC := _MIN(High(Word), FengHaoAbility.wMC + HiWord(HumTitleDB.MC)); //魔法 上限
                  FengHaoAbility.wSC := _MIN(High(Word), FengHaoAbility.wSC + HiWord(HumTitleDB.SC)); //道术 上限
                  FengHaoAbility.wMagicShieldLevel := _MIN(High(Word), FengHaoAbility.wMagicShieldLevel + LoWord(HumTitleDB.MC)); ; //聚魔等级
                  FengHaoAbility.wUnParalysisRate := _MIN(High(Byte), FengHaoAbility.wUnParalysisRate + LoWord(HumTitleDB.DC)); //麻痹抗性(辉煌衣服)
                  FengHaoAbility.wPhysicalLevel := _MIN(High(Word), FengHaoAbility.wPhysicalLevel + HiWord(HumTitleDB.AC)); //强身等级
                  FengHaoAbility.wDecTargetNHPoint := _MIN(High(Byte), FengHaoAbility.wDecTargetNHPoint + LoWord(HumTitleDB.MAC)); //内伤等级
                  FengHaoAbility.wCritLevel := _MIN(High(Byte), FengHaoAbility.wCritLevel + HiWord(HumTitleDB.MAC)); //暴击等级
                  FengHaoAbility.wIncDragonRate := _MIN(High(Word), FengHaoAbility.wSC + LoWord(HumTitleDB.SC)); //合击威力
                end;
              5: begin //随机攻击倍数(巅峰勇士类)
                  if m_nDieCount < 3 then begin //死亡3次则无效果
                    m_boFengHaoPower := True; //封号增加攻击倍率
                    m_nFengHaoMaxPowerRate := _MIN(High(Word), m_nFengHaoMaxPowerRate + HiWord(HumTitleDB.DC)); //最高攻击倍数
                    m_nFengHaoMinPowerRate := _MIN(High(Word), m_nFengHaoMinPowerRate + LoWord(HumTitleDB.DC)); //最低攻击倍数

                    FengHaoAbility.wHP := _MIN(High(Word), FengHaoAbility.wHP + LoWord(HumTitleDB.AC)); //生命上限
                    FengHaoAbility.wMC := _MIN(High(Word), FengHaoAbility.wMC + HiWord(HumTitleDB.MC)); //魔法 上限
                    FengHaoAbility.wSC := _MIN(High(Word), FengHaoAbility.wSC + HiWord(HumTitleDB.SC)); //道术 上限
                    FengHaoAbility.wMagicShieldLevel := _MIN(High(Word), FengHaoAbility.wMagicShieldLevel + LoWord(HumTitleDB.MC)); ; //聚魔等级
                    FengHaoAbility.wPhysicalLevel := _MIN(High(Word), FengHaoAbility.wPhysicalLevel + HiWord(HumTitleDB.AC)); //强身等级
                    FengHaoAbility.wDecTargetNHPoint := _MIN(High(Byte), FengHaoAbility.wDecTargetNHPoint + LoWord(HumTitleDB.MAC)); //内伤等级
                    FengHaoAbility.wCritLevel := _MIN(High(Byte), FengHaoAbility.wCritLevel + HiWord(HumTitleDB.MAC)); //暴击等级
                    FengHaoAbility.wIncDragonRate := _MIN(High(Word), FengHaoAbility.wSC + LoWord(HumTitleDB.SC)); //合击威力
                  end;
                end;
              6: begin //组队队长，经验翻倍(热血使者)
                  m_GroupOwnerExp := True; //组队队长,经验翻倍
                  FengHaoAbility.wHP := _MIN(High(Word), FengHaoAbility.wHP + LoWord(HumTitleDB.AC)); //生命上限
                  FengHaoAbility.wDC := _MIN(High(Word), FengHaoAbility.wDC + HiWord(HumTitleDB.DC)); //攻击力 上限
                  FengHaoAbility.wMC := _MIN(High(Word), FengHaoAbility.wMC + HiWord(HumTitleDB.MC)); //魔法 上限
                  FengHaoAbility.wSC := _MIN(High(Word), FengHaoAbility.wSC + HiWord(HumTitleDB.SC)); //道术 上限
                  FengHaoAbility.wMagicShieldLevel := _MIN(High(Word), FengHaoAbility.wMagicShieldLevel + LoWord(HumTitleDB.MC)); ; //聚魔等级
                  FengHaoAbility.wUnParalysisRate := _MIN(High(Byte), FengHaoAbility.wUnParalysisRate + LoWord(HumTitleDB.DC)); //麻痹抗性(辉煌衣服)
                  FengHaoAbility.wPhysicalLevel := _MIN(High(Word), FengHaoAbility.wPhysicalLevel + HiWord(HumTitleDB.AC)); //强身等级
                  FengHaoAbility.wDecTargetNHPoint := _MIN(High(Byte), FengHaoAbility.wDecTargetNHPoint + LoWord(HumTitleDB.MAC)); //内伤等级
                  FengHaoAbility.wCritLevel := _MIN(High(Byte), FengHaoAbility.wCritLevel + HiWord(HumTitleDB.MAC)); //暴击等级
                  FengHaoAbility.wIncDragonRate := _MIN(High(Word), FengHaoAbility.wSC + LoWord(HumTitleDB.SC)); //合击威力
                end;
              7: begin //传奇之星
                  m_boFengHaoMagicEffect := True; //魔法粉红效果(传奇之星)
                  FengHaoAbility.wHP := _MIN(High(Word), FengHaoAbility.wHP + LoWord(HumTitleDB.AC)); //生命上限
                  FengHaoAbility.wDC := _MIN(High(Word), FengHaoAbility.wDC + HiWord(HumTitleDB.DC)); //攻击力 上限
                  FengHaoAbility.wMC := _MIN(High(Word), FengHaoAbility.wMC + HiWord(HumTitleDB.MC)); //魔法 上限
                  FengHaoAbility.wSC := _MIN(High(Word), FengHaoAbility.wSC + HiWord(HumTitleDB.SC)); //道术 上限
                  FengHaoAbility.wMagicShieldLevel := _MIN(High(Word), FengHaoAbility.wMagicShieldLevel + LoWord(HumTitleDB.MC)); ; //聚魔等级
                  FengHaoAbility.wUnParalysisRate := _MIN(High(Byte), FengHaoAbility.wUnParalysisRate + LoWord(HumTitleDB.DC)); //麻痹抗性(辉煌衣服)
                  if m_HuhuaList.Count > 0 then begin
                    FengHaoAbility.wPhysicalLevel := _MIN(High(Word), FengHaoAbility.wPhysicalLevel + HiWord(HumTitleDB.AC)); //强身等级
                  end;
                  FengHaoAbility.wDecTargetNHPoint := _MIN(High(Byte), FengHaoAbility.wDecTargetNHPoint + LoWord(HumTitleDB.MAC)); //内伤等级
                  FengHaoAbility.wCritLevel := _MIN(High(Byte), FengHaoAbility.wCritLevel + HiWord(HumTitleDB.MAC)); //暴击等级
                  FengHaoAbility.wIncDragonRate := _MIN(High(Word), FengHaoAbility.wSC + LoWord(HumTitleDB.SC)); //合击威力
                end;
              9: begin //玛法主宰者
                  m_boFengHaoDominate := True; //主宰称号
                  FengHaoAbility.wHP := _MIN(High(Word), FengHaoAbility.wHP + LoWord(HumTitleDB.AC)); //生命上限
                  FengHaoAbility.wDC := _MIN(High(Word), FengHaoAbility.wDC + HiWord(HumTitleDB.DC)); //攻击力 上限
                  FengHaoAbility.wMC := _MIN(High(Word), FengHaoAbility.wMC + HiWord(HumTitleDB.MC)); //魔法 上限
                  FengHaoAbility.wSC := _MIN(High(Word), FengHaoAbility.wSC + HiWord(HumTitleDB.SC)); //道术 上限
                  FengHaoAbility.wMagicShieldLevel := _MIN(High(Word), FengHaoAbility.wMagicShieldLevel + LoWord(HumTitleDB.MC)); ; //聚魔等级
                  FengHaoAbility.wUnParalysisRate := _MIN(High(Byte), FengHaoAbility.wUnParalysisRate + LoWord(HumTitleDB.DC)); //麻痹抗性(辉煌衣服)
                  if m_ComradeList.Count > 0 then begin
                    FengHaoAbility.wPhysicalLevel := _MIN(High(Word), FengHaoAbility.wPhysicalLevel + HiWord(HumTitleDB.AC)); //强身等级
                  end;
                  FengHaoAbility.wDecTargetNHPoint := _MIN(High(Byte), FengHaoAbility.wDecTargetNHPoint + LoWord(HumTitleDB.MAC)); //内伤等级
                  FengHaoAbility.wCritLevel := _MIN(High(Byte), FengHaoAbility.wCritLevel + HiWord(HumTitleDB.MAC)); //暴击等级
                  FengHaoAbility.wIncDragonRate := _MIN(High(Word), FengHaoAbility.wSC + LoWord(HumTitleDB.SC)); //合击威力
                end;
              10: begin //随机攻击倍数(高级巅峰勇士类,不考虑死亡次数)
                  m_boFengHaoPower := True; //封号增加攻击倍率
                  m_nFengHaoMaxPowerRate := _MIN(High(Word), m_nFengHaoMaxPowerRate + HiWord(HumTitleDB.DC)); //最高攻击倍数
                  m_nFengHaoMinPowerRate := _MIN(High(Word), m_nFengHaoMinPowerRate + LoWord(HumTitleDB.DC)); //最低攻击倍数

                  FengHaoAbility.wHP := _MIN(High(Word), FengHaoAbility.wHP + LoWord(HumTitleDB.AC)); //生命上限
                  FengHaoAbility.wMC := _MIN(High(Word), FengHaoAbility.wMC + HiWord(HumTitleDB.MC)); //魔法 上限
                  FengHaoAbility.wSC := _MIN(High(Word), FengHaoAbility.wSC + HiWord(HumTitleDB.SC)); //道术 上限
                  FengHaoAbility.wMagicShieldLevel := _MIN(High(Word), FengHaoAbility.wMagicShieldLevel + LoWord(HumTitleDB.MC)); ; //聚魔等级
                  FengHaoAbility.wPhysicalLevel := _MIN(High(Word), FengHaoAbility.wPhysicalLevel + HiWord(HumTitleDB.AC)); //强身等级
                  FengHaoAbility.wDecTargetNHPoint := _MIN(High(Byte), FengHaoAbility.wDecTargetNHPoint + LoWord(HumTitleDB.MAC)); //内伤等级
                  FengHaoAbility.wCritLevel := _MIN(High(Byte), FengHaoAbility.wCritLevel + HiWord(HumTitleDB.MAC)); //暴击等级
                  FengHaoAbility.wIncDragonRate := _MIN(High(Word), FengHaoAbility.wSC + LoWord(HumTitleDB.SC)); //合击威力
                end;
            else begin
                FengHaoAbility.wHP := _MIN(High(Word), FengHaoAbility.wHP + LoWord(HumTitleDB.AC)); //生命上限
                FengHaoAbility.wDC := _MIN(High(Word), FengHaoAbility.wDC + HiWord(HumTitleDB.DC)); //攻击力 上限
                FengHaoAbility.wMC := _MIN(High(Word), FengHaoAbility.wMC + HiWord(HumTitleDB.MC)); //魔法 上限
                FengHaoAbility.wSC := _MIN(High(Word), FengHaoAbility.wSC + HiWord(HumTitleDB.SC)); //道术 上限
                FengHaoAbility.wMagicShieldLevel := _MIN(High(Word), FengHaoAbility.wMagicShieldLevel + LoWord(HumTitleDB.MC)); ; //聚魔等级
                FengHaoAbility.wUnParalysisRate := _MIN(High(Byte), FengHaoAbility.wUnParalysisRate + LoWord(HumTitleDB.DC)); //麻痹抗性(辉煌衣服)
                FengHaoAbility.wPhysicalLevel := _MIN(High(Word), FengHaoAbility.wPhysicalLevel + HiWord(HumTitleDB.AC)); //强身等级
                FengHaoAbility.wDecTargetNHPoint := _MIN(High(Byte), FengHaoAbility.wDecTargetNHPoint + LoWord(HumTitleDB.MAC)); //内伤等级
                FengHaoAbility.wCritLevel := _MIN(High(Byte), FengHaoAbility.wCritLevel + HiWord(HumTitleDB.MAC)); //暴击等级
                FengHaoAbility.wIncDragonRate := _MIN(High(Word), FengHaoAbility.wSC + LoWord(HumTitleDB.SC)); //合击威力
              end;
            end;
          end;
          Break;
        end;
      end;
    end else begin
      for I := Low(THumTitles) to High(THumTitles) do begin
        if (m_wHumTitles[I].wIndex > 0) and (m_wHumTitles[I].MakeIndex > 0) then begin
          HumTitleDB := UserEngine.GetHumTitle(m_wHumTitles[I].wIndex);
          if HumTitleDB <> nil then begin
            case HumTitleDB.AniCount of
              2: begin //主宰龙卫
                  m_boFengHaoComrade := True; //主宰龙卫
                  m_sDominateName := m_wHumTitles[I].sChrName; //对应的主宰名字
                  FengHaoAbility.wHP := _MIN(High(Word), FengHaoAbility.wHP + LoWord(HumTitleDB.AC)); //生命上限
                  FengHaoAbility.wDC := _MIN(High(Word), FengHaoAbility.wDC + HiWord(HumTitleDB.DC)); //攻击力 上限
                  FengHaoAbility.wMC := _MIN(High(Word), FengHaoAbility.wMC + HiWord(HumTitleDB.MC)); //魔法 上限
                  FengHaoAbility.wSC := _MIN(High(Word), FengHaoAbility.wSC + HiWord(HumTitleDB.SC)); //道术 上限
                  FengHaoAbility.wMagicShieldLevel := _MIN(High(Word), FengHaoAbility.wMagicShieldLevel + LoWord(HumTitleDB.MC)); ; //聚魔等级
                  FengHaoAbility.wUnParalysisRate := _MIN(High(Byte), FengHaoAbility.wUnParalysisRate + LoWord(HumTitleDB.DC)); //麻痹抗性(辉煌衣服)
                  FengHaoAbility.wPhysicalLevel := _MIN(High(Word), FengHaoAbility.wPhysicalLevel + HiWord(HumTitleDB.AC)); //强身等级
                  FengHaoAbility.wDecTargetNHPoint := _MIN(High(Byte), FengHaoAbility.wDecTargetNHPoint + LoWord(HumTitleDB.MAC)); //内伤等级
                  FengHaoAbility.wCritLevel := _MIN(High(Byte), FengHaoAbility.wCritLevel + HiWord(HumTitleDB.MAC)); //暴击等级
                  FengHaoAbility.wIncDragonRate := _MIN(High(Word), FengHaoAbility.wSC + LoWord(HumTitleDB.SC)); //合击威力
                end;
              3: begin //护花使者
                  m_boFengHaoHuhua := True; //护花使者称号
                  m_sHuhuaName := m_wHumTitles[I].sChrName; //对应的传奇之星名字
                  FengHaoAbility.wHP := _MIN(High(Word), FengHaoAbility.wHP + LoWord(HumTitleDB.AC)); //生命上限
                  FengHaoAbility.wDC := _MIN(High(Word), FengHaoAbility.wDC + HiWord(HumTitleDB.DC)); //攻击力 上限
                  FengHaoAbility.wMC := _MIN(High(Word), FengHaoAbility.wMC + HiWord(HumTitleDB.MC)); //魔法 上限
                  FengHaoAbility.wSC := _MIN(High(Word), FengHaoAbility.wSC + HiWord(HumTitleDB.SC)); //道术 上限
                  FengHaoAbility.wMagicShieldLevel := _MIN(High(Word), FengHaoAbility.wMagicShieldLevel + LoWord(HumTitleDB.MC)); ; //聚魔等级
                  FengHaoAbility.wUnParalysisRate := _MIN(High(Byte), FengHaoAbility.wUnParalysisRate + LoWord(HumTitleDB.DC)); //麻痹抗性(辉煌衣服)
                  FengHaoAbility.wPhysicalLevel := _MIN(High(Word), FengHaoAbility.wPhysicalLevel + HiWord(HumTitleDB.AC)); //强身等级
                  FengHaoAbility.wDecTargetNHPoint := _MIN(High(Byte), FengHaoAbility.wDecTargetNHPoint + LoWord(HumTitleDB.MAC)); //内伤等级
                  FengHaoAbility.wCritLevel := _MIN(High(Byte), FengHaoAbility.wCritLevel + HiWord(HumTitleDB.MAC)); //暴击等级
                  FengHaoAbility.wIncDragonRate := _MIN(High(Word), FengHaoAbility.wSC + LoWord(HumTitleDB.SC)); //合击威力
                end;
              4: begin //不动如山
                  m_boStickMode := True; //不能冲撞(不动如山)
                  m_nStickIncLevel := 10; //称号不动如山增加冲撞技能等级
                  FengHaoAbility.wHP := _MIN(High(Word), FengHaoAbility.wHP + LoWord(HumTitleDB.AC)); //生命上限
                  FengHaoAbility.wDC := _MIN(High(Word), FengHaoAbility.wDC + HiWord(HumTitleDB.DC)); //攻击力 上限
                  FengHaoAbility.wMC := _MIN(High(Word), FengHaoAbility.wMC + HiWord(HumTitleDB.MC)); //魔法 上限
                  FengHaoAbility.wSC := _MIN(High(Word), FengHaoAbility.wSC + HiWord(HumTitleDB.SC)); //道术 上限
                  FengHaoAbility.wMagicShieldLevel := _MIN(High(Word), FengHaoAbility.wMagicShieldLevel + LoWord(HumTitleDB.MC)); ; //聚魔等级
                  FengHaoAbility.wUnParalysisRate := _MIN(High(Byte), FengHaoAbility.wUnParalysisRate + LoWord(HumTitleDB.DC)); //麻痹抗性(辉煌衣服)
                  FengHaoAbility.wPhysicalLevel := _MIN(High(Word), FengHaoAbility.wPhysicalLevel + HiWord(HumTitleDB.AC)); //强身等级
                  FengHaoAbility.wDecTargetNHPoint := _MIN(High(Byte), FengHaoAbility.wDecTargetNHPoint + LoWord(HumTitleDB.MAC)); //内伤等级
                  FengHaoAbility.wCritLevel := _MIN(High(Byte), FengHaoAbility.wCritLevel + HiWord(HumTitleDB.MAC)); //暴击等级
                  FengHaoAbility.wIncDragonRate := _MIN(High(Word), FengHaoAbility.wSC + LoWord(HumTitleDB.SC)); //合击威力
                end;
              5: begin //随机攻击倍数(巅峰勇士类)
                  if m_nDieCount < 3 then begin //死亡3次则无效果
                    m_boFengHaoPower := True; //封号增加攻击倍率
                    m_nFengHaoMaxPowerRate := _MIN(High(Word), m_nFengHaoMaxPowerRate + HiWord(HumTitleDB.DC)); //最高攻击倍数
                    m_nFengHaoMinPowerRate := _MIN(High(Word), m_nFengHaoMinPowerRate + LoWord(HumTitleDB.DC)); //最低攻击倍数

                    FengHaoAbility.wHP := _MIN(High(Word), FengHaoAbility.wHP + LoWord(HumTitleDB.AC)); //生命上限
                    FengHaoAbility.wMC := _MIN(High(Word), FengHaoAbility.wMC + HiWord(HumTitleDB.MC)); //魔法 上限
                    FengHaoAbility.wSC := _MIN(High(Word), FengHaoAbility.wSC + HiWord(HumTitleDB.SC)); //道术 上限
                    FengHaoAbility.wMagicShieldLevel := _MIN(High(Word), FengHaoAbility.wMagicShieldLevel + LoWord(HumTitleDB.MC)); ; //聚魔等级
                    FengHaoAbility.wPhysicalLevel := _MIN(High(Word), FengHaoAbility.wPhysicalLevel + HiWord(HumTitleDB.AC)); //强身等级
                    FengHaoAbility.wDecTargetNHPoint := _MIN(High(Byte), FengHaoAbility.wDecTargetNHPoint + LoWord(HumTitleDB.MAC)); //内伤等级
                    FengHaoAbility.wCritLevel := _MIN(High(Byte), FengHaoAbility.wCritLevel + HiWord(HumTitleDB.MAC)); //暴击等级
                    FengHaoAbility.wIncDragonRate := _MIN(High(Word), FengHaoAbility.wSC + LoWord(HumTitleDB.SC)); //合击威力
                  end;
                end;
              6: begin //组队队长，经验翻倍(热血使者)
                  m_GroupOwnerExp := True; //组队队长,经验翻倍
                  FengHaoAbility.wHP := _MIN(High(Word), FengHaoAbility.wHP + LoWord(HumTitleDB.AC)); //生命上限
                  FengHaoAbility.wDC := _MIN(High(Word), FengHaoAbility.wDC + HiWord(HumTitleDB.DC)); //攻击力 上限
                  FengHaoAbility.wMC := _MIN(High(Word), FengHaoAbility.wMC + HiWord(HumTitleDB.MC)); //魔法 上限
                  FengHaoAbility.wSC := _MIN(High(Word), FengHaoAbility.wSC + HiWord(HumTitleDB.SC)); //道术 上限
                  FengHaoAbility.wMagicShieldLevel := _MIN(High(Word), FengHaoAbility.wMagicShieldLevel + LoWord(HumTitleDB.MC)); ; //聚魔等级
                  FengHaoAbility.wUnParalysisRate := _MIN(High(Byte), FengHaoAbility.wUnParalysisRate + LoWord(HumTitleDB.DC)); //麻痹抗性(辉煌衣服)
                  FengHaoAbility.wPhysicalLevel := _MIN(High(Word), FengHaoAbility.wPhysicalLevel + HiWord(HumTitleDB.AC)); //强身等级
                  FengHaoAbility.wDecTargetNHPoint := _MIN(High(Byte), FengHaoAbility.wDecTargetNHPoint + LoWord(HumTitleDB.MAC)); //内伤等级
                  FengHaoAbility.wCritLevel := _MIN(High(Byte), FengHaoAbility.wCritLevel + HiWord(HumTitleDB.MAC)); //暴击等级
                  FengHaoAbility.wIncDragonRate := _MIN(High(Word), FengHaoAbility.wSC + LoWord(HumTitleDB.SC)); //合击威力
                end;
              7: begin //传奇之星
                  m_boFengHaoMagicEffect := True; //魔法粉红效果(传奇之星)
                  FengHaoAbility.wHP := _MIN(High(Word), FengHaoAbility.wHP + LoWord(HumTitleDB.AC)); //生命上限
                  FengHaoAbility.wDC := _MIN(High(Word), FengHaoAbility.wDC + HiWord(HumTitleDB.DC)); //攻击力 上限
                  FengHaoAbility.wMC := _MIN(High(Word), FengHaoAbility.wMC + HiWord(HumTitleDB.MC)); //魔法 上限
                  FengHaoAbility.wSC := _MIN(High(Word), FengHaoAbility.wSC + HiWord(HumTitleDB.SC)); //道术 上限
                  FengHaoAbility.wMagicShieldLevel := _MIN(High(Word), FengHaoAbility.wMagicShieldLevel + LoWord(HumTitleDB.MC)); ; //聚魔等级
                  FengHaoAbility.wUnParalysisRate := _MIN(High(Byte), FengHaoAbility.wUnParalysisRate + LoWord(HumTitleDB.DC)); //麻痹抗性(辉煌衣服)
                  if m_HuhuaList.Count > 0 then begin
                    FengHaoAbility.wPhysicalLevel := _MIN(High(Word), FengHaoAbility.wPhysicalLevel + HiWord(HumTitleDB.AC)); //强身等级
                  end;
                  FengHaoAbility.wDecTargetNHPoint := _MIN(High(Byte), FengHaoAbility.wDecTargetNHPoint + LoWord(HumTitleDB.MAC)); //内伤等级
                  FengHaoAbility.wCritLevel := _MIN(High(Byte), FengHaoAbility.wCritLevel + HiWord(HumTitleDB.MAC)); //暴击等级
                  FengHaoAbility.wIncDragonRate := _MIN(High(Word), FengHaoAbility.wSC + LoWord(HumTitleDB.SC)); //合击威力
                end;
              9: begin //玛法主宰者
                  m_boFengHaoDominate := True; //主宰称号
                  FengHaoAbility.wHP := _MIN(High(Word), FengHaoAbility.wHP + LoWord(HumTitleDB.AC)); //生命上限
                  FengHaoAbility.wDC := _MIN(High(Word), FengHaoAbility.wDC + HiWord(HumTitleDB.DC)); //攻击力 上限
                  FengHaoAbility.wMC := _MIN(High(Word), FengHaoAbility.wMC + HiWord(HumTitleDB.MC)); //魔法 上限
                  FengHaoAbility.wSC := _MIN(High(Word), FengHaoAbility.wSC + HiWord(HumTitleDB.SC)); //道术 上限
                  FengHaoAbility.wMagicShieldLevel := _MIN(High(Word), FengHaoAbility.wMagicShieldLevel + LoWord(HumTitleDB.MC)); ; //聚魔等级
                  FengHaoAbility.wUnParalysisRate := _MIN(High(Byte), FengHaoAbility.wUnParalysisRate + LoWord(HumTitleDB.DC)); //麻痹抗性(辉煌衣服)
                  if m_ComradeList.Count > 0 then begin
                    FengHaoAbility.wPhysicalLevel := _MIN(High(Word), FengHaoAbility.wPhysicalLevel + HiWord(HumTitleDB.AC)); //强身等级
                  end;
                  FengHaoAbility.wDecTargetNHPoint := _MIN(High(Byte), FengHaoAbility.wDecTargetNHPoint + LoWord(HumTitleDB.MAC)); //内伤等级
                  FengHaoAbility.wCritLevel := _MIN(High(Byte), FengHaoAbility.wCritLevel + HiWord(HumTitleDB.MAC)); //暴击等级
                  FengHaoAbility.wIncDragonRate := _MIN(High(Word), FengHaoAbility.wSC + LoWord(HumTitleDB.SC)); //合击威力
                end;
              10: begin //随机攻击倍数(高级巅峰勇士类,不考虑死亡次数)
                  m_boFengHaoPower := True; //封号增加攻击倍率
                  m_nFengHaoMaxPowerRate := _MIN(High(Word), m_nFengHaoMaxPowerRate + HiWord(HumTitleDB.DC)); //最高攻击倍数
                  m_nFengHaoMinPowerRate := _MIN(High(Word), m_nFengHaoMinPowerRate + LoWord(HumTitleDB.DC)); //最低攻击倍数

                  FengHaoAbility.wHP := _MIN(High(Word), FengHaoAbility.wHP + LoWord(HumTitleDB.AC)); //生命上限
                  FengHaoAbility.wMC := _MIN(High(Word), FengHaoAbility.wMC + HiWord(HumTitleDB.MC)); //魔法 上限
                  FengHaoAbility.wSC := _MIN(High(Word), FengHaoAbility.wSC + HiWord(HumTitleDB.SC)); //道术 上限
                  FengHaoAbility.wMagicShieldLevel := _MIN(High(Word), FengHaoAbility.wMagicShieldLevel + LoWord(HumTitleDB.MC)); ; //聚魔等级
                  FengHaoAbility.wPhysicalLevel := _MIN(High(Word), FengHaoAbility.wPhysicalLevel + HiWord(HumTitleDB.AC)); //强身等级
                  FengHaoAbility.wDecTargetNHPoint := _MIN(High(Byte), FengHaoAbility.wDecTargetNHPoint + LoWord(HumTitleDB.MAC)); //内伤等级
                  FengHaoAbility.wCritLevel := _MIN(High(Byte), FengHaoAbility.wCritLevel + HiWord(HumTitleDB.MAC)); //暴击等级
                  FengHaoAbility.wIncDragonRate := _MIN(High(Word), FengHaoAbility.wSC + LoWord(HumTitleDB.SC)); //合击威力
                end;
            else begin
                FengHaoAbility.wHP := _MIN(High(Word), FengHaoAbility.wHP + LoWord(HumTitleDB.AC)); //生命上限
                FengHaoAbility.wDC := _MIN(High(Word), FengHaoAbility.wDC + HiWord(HumTitleDB.DC)); //攻击力 上限
                FengHaoAbility.wMC := _MIN(High(Word), FengHaoAbility.wMC + HiWord(HumTitleDB.MC)); //魔法 上限
                FengHaoAbility.wSC := _MIN(High(Word), FengHaoAbility.wSC + HiWord(HumTitleDB.SC)); //道术 上限
                FengHaoAbility.wMagicShieldLevel := _MIN(High(Word), FengHaoAbility.wMagicShieldLevel + LoWord(HumTitleDB.MC)); ; //聚魔等级
                FengHaoAbility.wUnParalysisRate := _MIN(High(Byte), FengHaoAbility.wUnParalysisRate + LoWord(HumTitleDB.DC)); //麻痹抗性(辉煌衣服)
                FengHaoAbility.wPhysicalLevel := _MIN(High(Word), FengHaoAbility.wPhysicalLevel + HiWord(HumTitleDB.AC)); //强身等级
                FengHaoAbility.wDecTargetNHPoint := _MIN(High(Byte), FengHaoAbility.wDecTargetNHPoint + LoWord(HumTitleDB.MAC)); //内伤等级
                FengHaoAbility.wCritLevel := _MIN(High(Byte), FengHaoAbility.wCritLevel + HiWord(HumTitleDB.MAC)); //暴击等级
                FengHaoAbility.wIncDragonRate := _MIN(High(Word), FengHaoAbility.wSC + LoWord(HumTitleDB.SC)); //合击威力
              end;
            end;
          end;
        end;
      end;
    end;
    if m_nFengHaoMinPowerRate > m_nFengHaoMaxPowerRate then m_nFengHaoMinPowerRate := m_nFengHaoMaxPowerRate;
  end;
end;
//检查称号回收

procedure TPlayObject.CheckFangHaoMarry(nType: Byte);
var
  boIsfound: Boolean;
  sUnMarryFileName: string;
  LoadList: TStringList;
  I: Integer;
  HumTitleDB: pTHumTitleDB;
begin
  boIsfound := False;
  case nType of
    0: begin
        sUnMarryFileName := g_Config.sEnvirDir + 'UnHuHua.txt';
        if FileExists(sUnMarryFileName) then begin
          LoadList := TStringList.Create;
          try
            LoadList.LoadFromFile(sUnMarryFileName);
            for I := LoadList.Count - 1 downto 0 do begin
              if LoadList.Count <= 0 then Break;
              if CompareText(LoadList.Strings[I], m_sCharName) = 0 then begin
                LoadList.Delete(I);
                boIsfound := True;
                Break;
              end;
            end;
            LoadList.SaveToFile(sUnMarryFileName);
          finally
            LoadList.Free;
          end;
        end;
        if boIsfound then begin
          for I := Low(THumTitles) to High(THumTitles) do begin
            if (m_wHumTitles[I].wIndex > 0) and (m_wHumTitles[I].MakeIndex > 0) then begin
              HumTitleDB := UserEngine.GetHumTitle(m_wHumTitles[I].wIndex);
              if HumTitleDB <> nil then begin
                if HumTitleDB.AniCount = 3 then begin //护花使者称号
                  if m_wHumTitles[I].boUseTitle then begin
                    m_boUseIitleIdx := 0;
                    m_sUseIitleName := '';
                  end;
                  m_wHumTitles[I].MakeIndex := 0;
                  m_wHumTitles[I].wIndex := 0;
                  m_wHumTitles[I].boUseTitle := False;
                  m_wHumTitles[I].wDura := 0;
                  m_wHumTitles[I].wMaxDura := 0;
                  m_wHumTitles[I].sChrName := '';
                  SysMsg(Format('您失去了称号：%s', [HumTitleDB.sTitleName]), c_Green, t_Hint);
                  SendMsg(Self, RM_SENDHUMTITLES, 0, 0, 0, 0, '');
                  m_boFengHaoHuhua := False;
                  RecalcAbilitys();
                  CompareSuitItem(False); //套装
                  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                  RefShowName();
                  if g_FunctionNPC <> nil then begin
                    g_FunctionNPC.GotoLable(Self, '@FengHaoFunc' + IntToStr(HumTitleDB.idx), False, False);
                  end;
                  Break;
                end;
              end;
            end;
          end;
        end;
      end;
    1: begin
        sUnMarryFileName := g_Config.sEnvirDir + 'UnComrade.txt';
        if FileExists(sUnMarryFileName) then begin
          LoadList := TStringList.Create;
          try
            LoadList.LoadFromFile(sUnMarryFileName);
            for I := LoadList.Count - 1 downto 0 do begin
              if LoadList.Count <= 0 then Break;
              if CompareText(LoadList.Strings[I], m_sCharName) = 0 then begin
                LoadList.Delete(I);
                boIsfound := True;
                Break;
              end;
            end;
            LoadList.SaveToFile(sUnMarryFileName);
          finally
            LoadList.Free;
          end;
        end;
        if boIsfound then begin
          for I := Low(THumTitles) to High(THumTitles) do begin
            if (m_wHumTitles[I].wIndex > 0) and (m_wHumTitles[I].MakeIndex > 0) then begin
              HumTitleDB := UserEngine.GetHumTitle(m_wHumTitles[I].wIndex);
              if HumTitleDB <> nil then begin
                if HumTitleDB.AniCount = 2 then begin //主宰龙卫称号
                  if m_wHumTitles[I].boUseTitle then begin
                    m_boUseIitleIdx := 0;
                    m_sUseIitleName := '';
                  end;
                  m_wHumTitles[I].MakeIndex := 0;
                  m_wHumTitles[I].wIndex := 0;
                  m_wHumTitles[I].boUseTitle := False;
                  m_wHumTitles[I].wDura := 0;
                  m_wHumTitles[I].wMaxDura := 0;
                  m_wHumTitles[I].sChrName := '';
                  SysMsg(Format('您失去了称号：%s', [HumTitleDB.sTitleName]), c_Green, t_Hint);
                  SendMsg(Self, RM_SENDHUMTITLES, 0, 0, 0, 0, '');
                  m_boFengHaoComrade := False;
                  RecalcAbilitys();
                  CompareSuitItem(False); //套装
                  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                  RefShowName();
                  if g_FunctionNPC <> nil then begin
                    g_FunctionNPC.GotoLable(Self, '@FengHaoFunc' + IntToStr(HumTitleDB.idx), False, False);
                  end;
                  Break;
                end;
              end;
            end;
          end;
        end;
      end;
  end;
end;
{$IFEND}
//烈火剑法 20080111

function TBaseObject.AllowFireHitSkill(): Boolean;
begin
  Result := False;
  if (GetTickCount - m_dwLatestFireHitTick) >= 7000 {7 * 1000} then begin //20090207 修改7秒
    m_dwLatestFireHitTick := GetTickCount();
    m_boFireHitSkill := True;
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sFireSpiritsSummoned, c_Green, t_Hint);
    {end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) '+sFireSpiritsSummoned, BB_Fuchsia, t_Hint);//20080312  }
    end;
    Result := True;
  end else begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sFireSpiritsFail, c_Green, t_Hint);
    {end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) '+sFireSpiritsFail, BB_Fuchsia, t_Hint);//20080312  }
    end;
  end;
end;
//逐日剑法 20080511

function TBaseObject.AllowDailySkill(): Boolean;
begin
  Result := False;
  if (GetTickCount - m_dwLatestDailyTick) >= 10000 {10 * 1000} then begin
    m_dwLatestDailyTick := GetTickCount();
    m_boDailySkill := True;
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sDailySkillSummoned, c_Green, t_Hint);
    {end else
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) '+ sDailySkillSummoned, BB_Fuchsia, t_Hint);//20080312   }
    end;
    Result := True;
  end else begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sDailySkillFail, c_Green, t_Hint);
    {end else //20100910 注释
      if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(Self).SysMsg('(英雄) '+sDailySkillFail, BB_Fuchsia, t_Hint);//20080312  }
    end;
  end;
end;
//血魄一击(战) 开启

function TBaseObject.AllowBloodSoulSkill(): Boolean;
begin
  Result := False;
  if (GetTickCount - m_dwLatestBloodSoulTick) >= g_Config.dwUseBloodSoulTick then begin
    m_dwLatestBloodSoulTick := GetTickCount();
    m_boBloodSoulSkill := True;
    case m_btRaceServer of
      RC_PLAYOBJECT: SysMsg(sBloodSoulSkillSummoned, c_Green, t_Hint);
      //RC_HEROOBJECT: THeroObject(Self).SysMsg('(英雄) '+ sBloodSoulSkillSummoned, BB_Fuchsia, t_Hint);
    end;
    Result := True;
  end else begin
    case m_btRaceServer of
      RC_PLAYOBJECT: SysMsg(sBloodSoulSkillFail, c_Green, t_Hint);
      //RC_HEROOBJECT: THeroObject(Self).SysMsg('(英雄) '+ sBloodSoulSkillFail, BB_Fuchsia, t_Hint);
    end;
  end;
end;

//地图随机移动

procedure TBaseObject.MapRandomMove(sMapName: string; nInt: Integer);
var
  Envir: TEnvirnoment;
  n10, n14, n18: Integer;
begin
  Envir := g_MapManager.FindMap(sMapName);
  if Envir <> nil then begin
    if Envir.m_nHeight < 150 then begin
      if Envir.m_nHeight < 30 then begin
        n18 := 2;
      end else n18 := 20;
    end else n18 := 50;
    n10 := Random(Envir.m_nWidth - n18 - 1) + n18;
    n14 := Random(Envir.m_nHeight - n18 - 1) + n18;
    SpaceMove(sMapName, n10, n14, nInt);
  end;
end;
//点击NPC

procedure TPlayObject.ClientClickNPC(NPC: Integer);
var
  NormNpc: TNormNpc;
begin
  if not m_boCanDeal then begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotTryDealMsg);
    Exit;
  end;
  if m_boShop then begin //开启个人商店时不能扔物品 20100704
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropItemMsg);
    Exit;
  end;
  if m_boDeath or m_boGhost then Exit;

  NormNpc := UserEngine.FindMerchant(TObject(NPC));
  if NormNpc = nil then NormNpc := UserEngine.FindNPC(TObject(NPC));

  if NormNpc <> nil then begin
    if (NormNpc.m_PEnvir = m_PEnvir) and (abs(NormNpc.m_nCurrX - m_nCurrX) <= 15) and (abs(NormNpc.m_nCurrY - m_nCurrY) <= 15) then begin
      NormNpc.Click(Self);
    end;
  end;
end;

function TBaseObject.AddItemToBag(UserItem: pTUserItem): Boolean;
begin
  Result := False;
  if m_ItemList.Count < MAXBAGITEM then begin
    m_ItemList.Add(UserItem);
    WeightChanged();
    Result := True;
  end;
end;

function TPlayObject.GetRangeHumanCount: Integer;
begin
  Result := UserEngine.GetMapOfRangeHumanCount(m_PEnvir, m_nCurrX, m_nCurrY, 10);
end;
//判断心灵启示等级

function TBaseObject.sub_4C713C(Magic: pTUserMagic): Boolean;
begin
  Result := False;
  if Magic <> nil then begin
    if Magic.MagicInfo.wMagicId = 28 then
      if Magic.btLevel >= 2 then begin
        m_boAbilSeeHealGauge := True;
        Result := True;
      end;
  end;
end;
//取复活点

procedure TPlayObject.GetStartPoint;
var
  I: Integer;
  StartPoint: pTStartPoint;
  nCode: Byte; //20100110
begin
  nCode := 0;
  try
    try
      g_StartPointList.Lock;
      nCode := 1;
      if g_StartPointList.Count > 0 then begin
        nCode := 2;
        for I := 0 to g_StartPointList.Count - 1 do begin
          nCode := 3;
          if g_StartPointList.Strings[I] = m_PEnvir.sMapName then begin
            nCode := 4;
            StartPoint := pTStartPoint(g_StartPointList.Objects[I]);
            nCode := 5;
            if StartPoint <> nil then begin
              nCode := 6;
              if (abs(m_nCurrX - StartPoint.m_nCurrX) < 50) and (abs(m_nCurrY - StartPoint.m_nCurrY) < 50 {g_Config.nSafeZoneSize}) then begin
                nCode := 7;
                m_sHomeMap := g_StartPointList.Strings[I];
                m_nHomeX := StartPoint.m_nCurrX;
                m_nHomeY := StartPoint.m_nCurrY;
                Break;
              end;
            end;
          end;
        end; //for
      end;
      nCode := 8;
      if PKLevel >= 2 then begin
        m_sHomeMap := g_Config.sRedHomeMap;
        m_nHomeX := g_Config.nRedHomeX;
        m_nHomeY := g_Config.nRedHomeY;
      end;
    finally
      g_StartPointList.UnLock;
    end;
  except
    MainOutMessage(Format('{%s} TPlayObject.GetStartPoint Code:%d.%p', [g_sExceptionVer, nCode, ExceptAddr]));
  end;
end;

function TBaseObject.GetQuestFalgStatus(nFlag: Integer): Integer;
var
  n10, n14: Integer;
begin
  Result := 0;
  Dec(nFlag);
  if nFlag < 0 then Exit;
  n10 := nFlag div 8;
  n14 := (nFlag mod 8);
  if (n10 - SizeOf(TQuestFlag)) < 0 then begin
    if ((128 shr n14) and (m_QuestFlag[n10])) <> 0 then Result := 1
    else Result := 0;
  end;
end;
//设置触发标签状态

procedure TBaseObject.SetQuestFlagStatus(nFlag: Integer; nValue: Integer);
var
  n10, n14: Integer;
  bt15: Byte;
begin
  Dec(nFlag);
  if nFlag < 0 then Exit;
  n10 := nFlag div 8;
  n14 := (nFlag mod 8);

  //if n10=8 then
  //  m_QuestFlag[n10]:=0;


  if (n10 - SizeOf(TQuestFlag)) < 0 then begin
    bt15 := m_QuestFlag[n10];
    if nValue = 0 then begin
      m_QuestFlag[n10] := (not (128 shr n14)) and (bt15);
    end else begin
      m_QuestFlag[n10] := (128 shr n14) or (bt15);
    end;
  end;
end;
//增加人物技能 20090530 修改

procedure TPlayObject.CmdTrainingMagic(Cmd: pTGameCmd; sHumanName, sSkillName: string; nLevel: Integer; sHero: string);
var
  Magic: pTMagic;
  UserMagic: pTUserMagic;
  PlayObject: TPlayObject;
  HeroObject: TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sHumanName <> '') and (sHumanName[1] = '?')) or (sHumanName = '') or (sSkillName = '') or (nLevel < 0) or (nLevel > 3) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 技能名称 修炼等级(0-3) hero', c_Red, t_Hint);
    Exit;
  end;
  if CompareText(sHero, 'HERO') = 0 then begin //英雄
{$IF HEROVERSION = 1}
    HeroObject := UserEngine.GetHeroObject(sHumanName);
    if HeroObject = nil then begin
      SysMsg(Format('英雄%s不在线，或在其它服务器上！', [sHumanName]), c_Red, t_Hint);
      Exit;
    end;
    Magic := UserEngine.FindHeroMagic(sSkillName);
    if Magic = nil then begin
      SysMsg(Format('%s 技能名称不正确！', [sSkillName]), c_Red, t_Hint);
      Exit;
    end;
    if Magic.wMagicId = 75 then begin
      HeroObject.m_boProtectionDefence := True; //是否学过护体神盾
      SysMsg(Format('英雄%s 的 %s 技能修炼成功！', [sHumanName, sSkillName]), c_Green, t_Hint);
      Exit;
    end;
    if HeroObject.IsTrainingSkill(Magic.wMagicId) then begin
      SysMsg(Format('%s 技能已修炼过了！', [sSkillName]), c_Red, t_Hint);
      Exit;
    end;
    //没有内功心法,则不能学内功技能 20081001
    if (Magic.sDescr = '内功') then begin
{$IF M2Version <> 2}
      if (not THeroObject(HeroObject).m_boTrainingNG) then begin
        SysMsg(Format('英雄%s 没学过内功心法,不能学习此 %s 技能！', [sHumanName, sSkillName]), c_Red, t_Hint);
        Exit;
      end;
{$ELSE}
      Exit;
{$IFEND}
    end;
{$IF M2Version = 1}
    if (Magic.sDescr = '连击') and (not THeroObject(HeroObject).m_boTrainingNG) and (not THeroObject(HeroObject).m_boOpenHumanPulseArr) then begin
      SysMsg(Format('英雄%s 没学过内功心法或未开通经络,不能学习此 %s 技能！', [sHumanName, sSkillName]), c_Red, t_Hint);
      Exit;
    end;
    if (Magic.sDescr = '连击') then begin
      THeroObject(HeroObject).m_boTrainBatterSkill := True;
      THeroObject(HeroObject).m_nUseBatterTick := GetTickCount();
    end;
{$IFEND}
    New(UserMagic);
    UserMagic.MagicInfo := Magic;
    UserMagic.wMagIdx := Magic.wMagicId;
    UserMagic.btLevel := nLevel;
    UserMagic.btKey := 0;
    UserMagic.nTranPoint := 0;
    UserMagic.btLevelEx := 0;
    HeroObject.m_MagicList.Add(UserMagic);
{$IF M2Version = 1}
    if (UserMagic.MagicInfo.wMagicId > 75) and (UserMagic.MagicInfo.wMagicId < 88) then begin //连击技能才处理
      THeroObject(HeroObject).m_BatterMagicList.Add(UserMagic);
    end;
{$IFEND}
    THeroObject(HeroObject).SendAddMagic(UserMagic);
    THeroObject(HeroObject).RecalcAbilitys();
    HeroObject.CompareSuitItem(False); //200081213 套装
    SysMsg(Format('英雄%s 的 %s 技能修炼成功！', [sHumanName, sSkillName]), c_Green, t_Hint);
{$IFEND}
  end else begin
    PlayObject := UserEngine.GetPlayObject(sHumanName);
    if PlayObject = nil then begin
      SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
      Exit;
    end;
    Magic := UserEngine.FindMagic(sSkillName);
    if Magic = nil then begin
      SysMsg(Format('%s 技能名称不正确！', [sSkillName]), c_Red, t_Hint);
      Exit;
    end;
    if Magic.wMagicId = 75 then begin
      PlayObject.m_boProtectionDefence := True; //是否学过护体神盾
      SysMsg(Format('%s 的 %s 技能修炼成功！', [sHumanName, sSkillName]), c_Green, t_Hint);
      Exit;
    end;
    if PlayObject.IsTrainingSkill(Magic.wMagicId) then begin
      SysMsg(Format('%s 技能已修炼过了！', [sSkillName]), c_Red, t_Hint);
      Exit;
    end;
    //没有内功心法,则不能学内功技能 20081001
    if ((Magic.sDescr = '内功') or (Magic.sDescr = '连击') or (Magic.sDescr = '神技')) then begin
{$IF M2Version <> 2}
      if (not PlayObject.m_boTrainingNG) then begin
        SysMsg(Format('玩家%s 没学过内功心法,不能学习此 %s 技能！', [sHumanName, sSkillName]), c_Red, t_Hint);
        Exit;
      end;
      case Magic.wMagicId of
        SKILL_105: if (PlayObject.m_MagicSkill_106 <> nil) then begin
            SysMsg(Format('玩家%s 学过%s,不能学习此 %s 技能！', [sHumanName, PlayObject.m_MagicSkill_106.MagicInfo.sMagicName, sSkillName]), c_Red, t_Hint);
            Exit;
          end;
        SKILL_106: if (PlayObject.m_MagicSkill_105 <> nil) then begin
            SysMsg(Format('玩家%s 学过%s,不能学习此 %s 技能！', [sHumanName, PlayObject.m_MagicSkill_105.MagicInfo.sMagicName, sSkillName]), c_Red, t_Hint);
            Exit;
          end;
        SKILL_107, SKILL_108, SKILL_109: begin
            if (PlayObject.m_MagicSkill_105 = nil) then begin
              SysMsg(Format('玩家%s 没有学过龙卫心法,不能学习此 %s 技能！', [sHumanName, sSkillName]), c_Red, t_Hint);
              Exit;
            end;
          end;
      end;
{$ELSE}
      Exit;
{$IFEND}
    end;
    New(UserMagic);
    UserMagic.MagicInfo := Magic;
    UserMagic.wMagIdx := Magic.wMagicId;
    UserMagic.btLevel := nLevel;
    UserMagic.btKey := 0;
    UserMagic.nTranPoint := 0;
    UserMagic.btLevelEx := 0;
    PlayObject.m_MagicList.Add(UserMagic);
    PlayObject.SendAddMagic(UserMagic);
    PlayObject.RecalcAbilitys;
    PlayObject.CompareSuitItem(False); //200081213 套装
{$IF M2Version = 1}
    if not PlayObject.m_boTrainBatterSkill then begin
      if Magic.sDescr = '连击' then begin
        PlayObject.m_boTrainBatterSkill := True; //是否学习过连击技能 20090702
        PlayObject.m_boSendCanBatterMsg := False;
        PlayObject.m_nUseBatterTick := GetTickCount();
      end;
    end;
{$IFEND}
    SysMsg(Format('%s 的 %s 技能修炼成功！', [sHumanName, sSkillName]), c_Green, t_Hint);
  end;
end;
//调整玩家技能等级 20090530 支持英雄

procedure TPlayObject.CmdTrainingSkill(Cmd: pTGameCmd; sHumanName, sSkillName: string; nLevel: Integer; sHero: string);
var
  I: Integer;
  UserMagic: pTUserMagic;
  PlayObject: TPlayObject;
  HeroObject: TBaseObject;
  nMaxExp: LongWord;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (sSkillName = '') or (nLevel <= 0) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 技能名称 修炼等级(0-3) hero', c_Red, t_Hint);
    Exit;
  end;
  //nLevel := _MIN(3, nLevel);
  if CompareText(sHero, 'HERO') = 0 then begin //英雄
{$IF HEROVERSION = 1}
    HeroObject := UserEngine.GetHeroObject(sHumanName);
    if HeroObject = nil then begin
      SysMsg(Format('英雄%s不在线，或在其它服务器上！！', [sHumanName]), c_Red, t_Hint);
      Exit;
    end;
    if HeroObject.m_MagicList.Count > 0 then begin //20080629
      for I := 0 to HeroObject.m_MagicList.Count - 1 do begin
        UserMagic := HeroObject.m_MagicList.Items[I];
        if CompareText(UserMagic.MagicInfo.sMagicName, sSkillName) = 0 then begin
          case UserMagic.wMagIdx of
            SKILL_FIRECHARM, SKILL_FIRESWORD, SKILL_45: nLevel := _MIN(4, nLevel);
            SKILL_95: begin
{$IF M2Version = 1}
                if THEROOBJECT(PlayObject.m_MyHero).m_boOpenupSkill95 then begin
                  nLevel := _MIN(99, nLevel);
                end else {$IFEND}
                  nLevel := _MIN(64, nLevel);
              end;
            SKILL_99: nLevel := _MIN(99, nLevel);
            SKILL_104: nLevel := _MIN(100, nLevel);
          else nLevel := _MIN(3, nLevel);
          end;
          UserMagic.btLevel := nLevel;
          THeroObject(HeroObject).SendMsg(HeroObject, RM_HEROMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '');
          THeroObject(HeroObject).SysMsg(Format('%s的修改炼等级为%d', [sSkillName, nLevel]), c_Green, t_Hint);
          SysMsg(Format('英雄%s的技能%s修炼等级为%d', [sHumanName, sSkillName, nLevel]), c_Green, t_Hint);
          Break;
        end;
      end; //for
    end;
{$IFEND}
  end else begin
    PlayObject := UserEngine.GetPlayObject(sHumanName);
    if PlayObject = nil then begin
      SysMsg(Format('%s不在线，或在其它服务器上！！', [sHumanName]), c_Red, t_Hint);
      Exit;
    end;
    if PlayObject.m_MagicList.Count > 0 then begin //20080629
      for I := 0 to PlayObject.m_MagicList.Count - 1 do begin
        UserMagic := PlayObject.m_MagicList.Items[I];
        if CompareText(UserMagic.MagicInfo.sMagicName, sSkillName) = 0 then begin
          case UserMagic.wMagIdx of
            SKILL_FIRECHARM, SKILL_FIRESWORD, SKILL_45, SKILL_66, SKILL_88..SKILL_94: nLevel := _MIN(4, nLevel);
            SKILL_68: nLevel := _MIN(100, nLevel);
            SKILL_71: nLevel := _MIN(99, nLevel);
            SKILL_95: begin
{$IF M2Version = 1}
                if PlayObject.m_boOpenupSkill95 then begin
                  nLevel := _MIN(99, nLevel);
                end else {$IFEND}
                  nLevel := _MIN(64, nLevel); //斗转星移最高64级
              end;
            SKILL_100: nLevel := _MIN(15, nLevel);
            SKILL_104: nLevel := _MIN(100, nLevel);
            SKILL_105: nLevel := _MIN(100, nLevel);
            SKILL_106, SKILL_107, SKILL_108, SKILL_109: nLevel := _MIN(9, nLevel);
          else nLevel := _MIN(3, nLevel);
          end;
          UserMagic.btLevel := nLevel;
          nMaxExp := 0;
          case UserMagic.wMagIdx of
            SKILL_100: nMaxExp := 500 + (UserMagic.btLevel * 700);
{$IF M2Version <> 2}
            SKILL_105..SKILL_109:
              nMaxExp := UserMagic.MagicInfo.MaxTrain[0] + UserMagic.btLevel * (UserMagic.MagicInfo.MaxTrain[2] - UserMagic.MagicInfo.MaxTrain[1]);
{$IFEND}
          end;
          PlayObject.SendMsg(PlayObject, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nMaxExp, UserMagic.btLevel, UserMagic.nTranPoint, '');
          PlayObject.SysMsg(Format('%s的修改炼等级为%d', [sSkillName, nLevel]), c_Green, t_Hint);
          SysMsg(Format('%s的技能%s修炼等级为%d', [sHumanName, sSkillName, nLevel]), c_Green, t_Hint);
          Break;
        end;
      end; //for
    end;
  end;
end;

procedure TPlayObject.CmdAddGameGold(sCmd, sHumName: string; nPoint: Integer);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < 6) then Exit;
  if (sHumName = '') or (nPoint <= 0) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + sCmd + ' 人物名称 数量', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject <> nil then begin
    if (PlayObject.m_nGameGold + nPoint) < 2000000 then begin
      Inc(PlayObject.m_nGameGold, nPoint);
    end else begin
      nPoint := 2000000 - PlayObject.m_nGameGold;
      PlayObject.m_nGameGold := 2000000;
    end;
    if g_boGameLogGameGold then
      AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD,
        PlayObject.m_sMapName,
          PlayObject.m_nCurrX,
          PlayObject.m_nCurrY,
          PlayObject.m_sCharName,
          g_Config.sGameGoldName,
          PlayObject.m_nGameGold,
          '命令+(' + inttostr(nPoint) + ')',
          m_sCharName]));
    PlayObject.GoldChanged();
    SysMsg(sHumName + '的游戏点已增加' + IntToStr(nPoint) + '.', c_Green, t_Hint);
    PlayObject.SysMsg('游戏点已增加' + IntToStr(nPoint) + '.', c_Green, t_Hint);
  end else begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdDelGameGold(sCmd, sHumName: string;
  nPoint: Integer);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < 6) then Exit;
  if (sHumName = '') or (nPoint <= 0) then Exit;
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject <> nil then begin
    if PlayObject.m_nGameGold > nPoint then begin
      Dec(PlayObject.m_nGameGold, nPoint);
    end else begin
      nPoint := PlayObject.m_nGameGold;
      PlayObject.m_nGameGold := 0;
    end;
    if g_boGameLogGameGold then
      AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD,
        PlayObject.m_sMapName,
          PlayObject.m_nCurrX,
          PlayObject.m_nCurrY,
          PlayObject.m_sCharName,
          g_Config.sGameGoldName,
          PlayObject.m_nGameGold,
          '命令-(' + inttostr(nPoint) + ')',
          m_sCharName]));
    PlayObject.GoldChanged();
    SysMsg(sHumName + '的游戏点已减少' + IntToStr(nPoint) + '.', c_Green, t_Hint);
    PlayObject.SysMsg('游戏点已减少' + IntToStr(nPoint) + '.', c_Green, t_Hint);
  end else begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdGameGold(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nGold: Integer);
var
  PlayObject: TPlayObject;
  Ctr: Char;
begin
  Ctr := '1';
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sCtr <> '') then Ctr := sCtr[1];
  if (sHumanName = '') or not (Ctr in ['=', '+', '-']) or (nGold < 0) or (nGold > 2100000000) or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandGameGoldHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  case sCtr[1] of
    '=': begin
        PlayObject.m_nGameGold := nGold;
      end;
    '+': begin //20090705 修改
        if (High(Integer) - PlayObject.m_nGameGold) >= nGold then begin //20100511 修改
          PlayObject.m_nGameGold := PlayObject.m_nGameGold + nGold;
        end else begin
          nGold := High(Integer) - PlayObject.m_nGameGold;
          PlayObject.m_nGameGold := High(Integer);
        end;
        {if (PlayObject.m_nGameGold + nGold) < 2100000000 then begin
          Inc(PlayObject.m_nGameGold, nGold);
        end else begin
          nGold := 2100000000 - PlayObject.m_nGameGold;
          PlayObject.m_nGameGold := 2100000000;
        end;}
      end;
    '-': begin
        if PlayObject.m_nGameGold >= nGold then begin //20090424 修改
          Dec(PlayObject.m_nGameGold, nGold);
        end else PlayObject.m_nGameGold := 0;
      end;
  end;
  if g_boGameLogGameGold then begin
    AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, PlayObject.m_sMapName,
      PlayObject.m_nCurrX, PlayObject.m_nCurrY, PlayObject.m_sCharName,
        g_Config.sGameGoldName, PlayObject.m_nGameGold,
        sCtr[1] + '(' + inttostr(nGold) + ')', m_sCharName + '(GM)' + m_sUserID])); //20090705
  end;
  PlayObject.GameGoldChanged(); //20090508 修改
  PlayObject.SysMsg(Format_ToStr(g_sGameCommandGameGoldHumanMsg, [g_Config.sGameGoldName, nGold, PlayObject.m_nGameGold, g_Config.sGameGoldName]), c_Green, t_Hint);
  SysMsg(Format_ToStr(g_sGameCommandGameGoldGMMsg, [sHumanName, g_Config.sGameGoldName, nGold, PlayObject.m_nGameGold, g_Config.sGameGoldName]), c_Green, t_Hint);
end;
//20071226 金刚石

procedure TPlayObject.CmdGameDiaMond(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nGameDiaMond: Integer);
var
  PlayObject: TPlayObject;
  Ctr: Char;
begin
  Ctr := '1';
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint); //权限不够
    Exit;
  end;
  if (sCtr <> '') then begin
    Ctr := sCtr[1];
  end;

  if (sHumanName = '') or not (Ctr in ['=', '+', '-']) or (nGameDiaMond < 0) or (nGameDiaMond > 200000000) or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandGameDiaMondHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  case sCtr[1] of
    '=': begin
        PlayObject.m_nGameDiaMond := nGameDiaMond;
      end;
    '+': Inc(PlayObject.m_nGameDiaMond, nGameDiaMond);
    '-': begin
        if PlayObject.m_nGameDiaMond >= nGameDiaMond then begin //20090424 修改
          Dec(PlayObject.m_nGameDiaMond, nGameDiaMond);
        end else PlayObject.m_nGameDiaMond := 0;
      end;
  end;
  if g_boGameLogGameDiaMond then begin
    AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GameDiaMond,
      PlayObject.m_sMapName,
        PlayObject.m_nCurrX,
        PlayObject.m_nCurrY,
        PlayObject.m_sCharName,
        g_Config.sGameDiaMond,
        PlayObject.m_nGameDiaMond,
        sCtr[1] + '(' + inttostr(nGameDiaMond) + ')',
        m_sCharName]));
  end;
  PlayObject.GameGoldChanged(); //20090508 修改
  PlayObject.SysMsg(Format_ToStr(g_sGameCommandGameDiaMondHumanMsg, [g_Config.sGameDiaMond, nGameDiaMond, PlayObject.m_nGameDiaMond, g_Config.sGameDiaMond]), c_Green, t_Hint);
  SysMsg(Format_ToStr(g_sGameCommandGameDiaMondGMMsg, [sHumanName, g_Config.sGameDiaMond, nGameDiaMond, PlayObject.m_nGameDiaMond, g_Config.sGameDiaMond]), c_Green, t_Hint);
end;
//20071226 灵符

procedure TPlayObject.CmdGameGird(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nGameGird: Integer);
var
  PlayObject: TPlayObject;
  Ctr: Char;
begin
  Ctr := '1';
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint); //权限不够
    Exit;
  end;
  if (sCtr <> '') then begin
    Ctr := sCtr[1];
  end;

  if (sHumanName = '') or not (Ctr in ['=', '+', '-']) or (nGameGird < 0) or (nGameGird > 200000000) or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandGameGirdHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  case sCtr[1] of
    '=': begin
        PlayObject.m_nGameGird := nGameGird;
      end;
    '+': Inc(PlayObject.m_nGameGird, nGameGird);
    '-': begin
        Dec(PlayObject.m_nGameGird, nGameGird);
        PlayObject.m_UseGameGird := nGameGird; //20090108 灵符使用计数
        if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
          g_FunctionNPC.GotoLable(PlayObject, '@USEGAMEGIRD', False, False);
        end;
      end;
  end;
  if g_boGameLogGameGird then begin
    AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GameGird,
      PlayObject.m_sMapName,
        PlayObject.m_nCurrX,
        PlayObject.m_nCurrY,
        PlayObject.m_sCharName,
        g_Config.sGameGird,
        PlayObject.m_nGameGird,
        sCtr[1] + '(' + inttostr(nGameGird) + ')',
        m_sCharName]));
  end;
  PlayObject.GameGoldChanged(); //20090508 修改
  PlayObject.SysMsg(Format_ToStr(g_sGameCommandGameGirdHumanMsg, [g_Config.sGameGird, nGameGird, PlayObject.m_nGameGird, g_Config.sGameGird]), c_Green, t_Hint);
  SysMsg(Format_ToStr(g_sGameCommandGameGirdGMMsg, [sHumanName, g_Config.sGameGird, nGameGird, PlayObject.m_nGameGird, g_Config.sGameGird]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdGameGlory(Cmd: pTGameCmd; sHumanName,
  sCtr: string; nGameGlory: Byte);
var
  PlayObject: TPlayObject;
  Ctr: Char;
begin
  Ctr := '1';
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint); //权限不够
    Exit;
  end;
  if (sCtr <> '') then begin
    Ctr := sCtr[1];
  end;

  if (sHumanName = '') or not (Ctr in ['=', '+', '-']) or (nGameGlory < 0) or (nGameGlory > 255) or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandGameGloryHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  case sCtr[1] of
    '=': begin
        PlayObject.m_btGameGlory := nGameGlory;
      end;
    '+': Inc(PlayObject.m_btGameGlory, nGameGlory);
    '-': begin
        if PlayObject.m_btGameGlory >= nGameGlory then begin //20090424 修改
          Dec(PlayObject.m_btGameGlory, nGameGlory);
        end else PlayObject.m_btGameGlory := 0;
      end;
  end;
  if g_boGameLogGameGlory then begin
    AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GameGlory,
      PlayObject.m_sMapName,
        PlayObject.m_nCurrX,
        PlayObject.m_nCurrY,
        PlayObject.m_sCharName,
        g_Config.sGameGlory,
        PlayObject.m_btGameGlory,
        sCtr[1] + '(' + inttostr(nGameGlory) + ')',
        m_sCharName]));
  end;
  PlayObject.GameGloryChanged(); //20090508 修改
  PlayObject.SysMsg(Format_ToStr(g_sGameCommandGameGirdHumanMsg, [g_Config.sGameGlory, nGameGlory, PlayObject.m_btGameGlory, g_Config.sGameGlory]), c_Green, t_Hint);
  SysMsg(Format_ToStr(g_sGameCommandGameGirdGMMsg, [sHumanName, g_Config.sGameGlory, nGameGlory, PlayObject.m_btGameGlory, g_Config.sGameGlory]), c_Green, t_Hint);
end;

//20080109 英雄的忠诚度

procedure TPlayObject.CmdHeroLoyal(Cmd: pTGameCmd; sHumanName: string; nHeroLoyal: Integer);
var
  PlayObject: TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint); //权限不够
    Exit;
  end;

  if (sHumanName = '') or (nHeroLoyal < 0) or (nHeroLoyal > 10000) or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandHeroLoyalHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
{$IF HEROVERSION = 1}
  PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject <> nil then begin
    THeroObject(PlayObject).m_nLoyal := nHeroLoyal;
    m_DefMsg := MakeDefaultMsg(SM_HEROABILITY, THeroObject(PlayObject).m_btGender, 0, THeroObject(PlayObject).m_btJob, THeroObject(PlayObject).m_nLoyal, 0); //20080305 替换上面一句
    SendSocket(@m_DefMsg, EncodeBuffer(@THeroObject(PlayObject).m_WAbil, SizeOf(TAbility))); //20080320

    SysMsg('[英雄忠诚度调整] ' + sHumanName + ' -> (' + IntToStr(THeroObject(PlayObject).m_nLoyal div 100) + '%)', BB_Fuchsia, t_Hint);
    if g_Config.boShowMakeItemMsg then
      MainOutMessage('[英雄忠诚度调整] ' + sHumanName + ' -> (' + IntToStr(THeroObject(PlayObject).m_nLoyal) + ')');
  end else begin
    SysMsg('英雄' + sHumanName + '现在不在线。', c_Red, t_Hint);
  end;
{$IFEND}
end;

procedure TPlayObject.CmdGamePoint(Cmd: pTGameCmd; sHumanName, sCtr: string; nPoint: Integer);
var
  PlayObject: TPlayObject;
  Ctr: Char;
begin
  Ctr := '1';
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sCtr <> '') then begin
    Ctr := sCtr[1];
  end;

  if (sHumanName = '') or not (Ctr in ['=', '+', '-']) or (nPoint < 0) or (nPoint > 100000000) or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandGamePointHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  case sCtr[1] of
    '=': begin
        PlayObject.m_nGamePoint := nPoint;
      end;
    '+': Inc(PlayObject.m_nGamePoint, nPoint);
    '-': begin
        if PlayObject.m_nGamePoint >= nPoint then begin //20090424 修改
          Dec(PlayObject.m_nGamePoint, nPoint);
        end else PlayObject.m_nGamePoint := 0;
      end;
  end;
  if g_boGameLogGamePoint then begin
    AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEPOINT,
      PlayObject.m_sMapName,
        PlayObject.m_nCurrX,
        PlayObject.m_nCurrY,
        PlayObject.m_sCharName,
        g_Config.sGamePointName,
        PlayObject.m_nGamePoint,
        sCtr[1] + '(' + inttostr(nPoint) + ')',
        m_sCharName]));
  end;
  GameGoldChanged();
  PlayObject.SysMsg(Format_ToStr(g_sGameCommandGamePointHumanMsg, [nPoint, PlayObject.m_nGamePoint]), c_Green, t_Hint);
  SysMsg(Format_ToStr(g_sGameCommandGamePointGMMsg, [sHumanName, nPoint, PlayObject.m_nGamePoint]), c_Green, t_Hint);
end;
//GM调整声望值

procedure TPlayObject.CmdCreditPoint(Cmd: pTGameCmd; sHumanName, sCtr: string; nPoint: Integer);
var
  PlayObject: TPlayObject;
  Ctr: Char;
  nCreditPoint: Integer;
begin
  Ctr := '1';
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sCtr <> '') then begin
    Ctr := sCtr[1];
  end;

  if (sHumanName = '') or not (Ctr in ['=', '+', '-']) or (nPoint < 0) or (nPoint > High(Integer)) or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandCreditPointHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  case sCtr[1] of
    '=': begin
        if nPoint >= 0 then begin
          PlayObject.m_btCreditPoint := nPoint;
        end;
      end;
    '+': begin
        Inc(PlayObject.m_btCreditPoint, nPoint);
      end;
    '-': begin
        if PlayObject.m_btCreditPoint > nPoint then begin
          Dec(PlayObject.m_btCreditPoint, nPoint);
        end else begin
          PlayObject.m_btCreditPoint := 0;
        end;
      end;
  end;
  PlayObject.GameGoldChanged();
  PlayObject.SysMsg(Format_ToStr(g_sGameCommandCreditPointHumanMsg, [nPoint, PlayObject.m_btCreditPoint]), c_Green, t_Hint);
  SysMsg(Format_ToStr(g_sGameCommandCreditPointGMMsg, [sHumanName, nPoint, PlayObject.m_btCreditPoint]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdAddGold(Cmd: pTGameCmd; sHumName: string; nCount: Integer);
var
  PlayObject: TPlayObject;
  //nServerIndex: Integer;
begin
  if (m_btPermission < 6) then Exit;
  if (sHumName = '') or (nCount <= 0) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称  金币数量', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject <> nil then begin
    if (PlayObject.m_nGold + nCount) < PlayObject.m_nGoldMax then begin
      Inc(PlayObject.m_nGold, nCount);
    end else begin
      nCount := PlayObject.m_nGoldMax - PlayObject.m_nGold;
      PlayObject.m_nGold := PlayObject.m_nGoldMax;
    end;
    PlayObject.GoldChanged();
    SysMsg(sHumName + '的金币已增加' + IntToStr(nCount) + '.', c_Green, t_Hint);
    //004CD6F6
    if g_boGameLogGold then
      AddGameDataLog('14' + #9 +
        m_sMapName + #9 +
        IntToStr(m_nCurrX) + #9 +
        IntToStr(m_nCurrY) + #9 +
        m_sCharName + #9 +
        sSTRING_GOLDNAME + #9 +
        IntToStr(nCount) + #9 +
        '1' + #9 +
        sHumName);
  end else begin
    {if UserEngine.FindOtherServerUser(sHumName, nServerIndex) then begin//20101022 注释
      SysMsg(sHumName + ' 现在' + IntToStr(nServerIndex) + '号服务器上', c_Green, t_Hint);
    end else begin}
    FrontEngine.AddChangeGoldList(m_sCharName, sHumName, nCount);
    SysMsg(sHumName + ' 现在不在线，等其上线时金币将自动增加', c_Green, t_Hint);
    //end;
  end;
end;

procedure TPlayObject.CmdAddGuild(Cmd: pTGameCmd; sGuildName, sGuildChief: string); //004CEBA0
var
  Human: TPlayObject;
  boAddState: Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if nServerIndex <> 0 then begin
    SysMsg('这个命令只能使用在主服务器上', c_Red, t_Hint);
    Exit;
  end;
  if (sGuildName = '') or (sGuildChief = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 行会名称 掌门人名称', c_Red, t_Hint);
    Exit;
  end;

  boAddState := False;
  Human := UserEngine.GetPlayObject(sGuildChief);
  if Human = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sGuildChief]), c_Red, t_Hint);
    Exit;
  end;
  if g_GuildManager.MemberOfGuild(sGuildChief) = nil then begin
    if g_GuildManager.AddGuild(sGuildName, sGuildChief) then begin
      //UserEngine.SendServerGroupMsg(SS_205, nServerIndex, sGuildName + '/' + sGuildChief);//20101022 注释
      SysMsg('行会名称: ' + sGuildName + ' 掌门人: ' + sGuildChief, c_Green, t_Hint);
      boAddState := True;
    end;
  end;
  if boAddState then begin
    Human.m_MyGuild := TObject(g_GuildManager.MemberOfGuild(Human.m_sCharName));
    if Human.m_MyGuild <> nil then begin
      Human.m_sGuildRankName := TGUild(Human.m_MyGuild).GetRankName(Self, Human.m_nGuildRankNo);
      Human.RefShowName();
    end;
  end;
end;

procedure TPlayObject.CmdAdjuestExp(Cmd: pTGameCmd; sHumanName, sExp: string);
var
  PlayObject: TPlayObject;
  dwExp: uInt64;
  dwOExp: LongWord;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 经验值', c_Red, t_Hint);
    Exit;
  end;
  dwExp := Str_ToInt(sExp, 0);

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    dwOExp := PlayObject.m_Abil.nExp;
    PlayObject.m_Abil.nExp := dwExp;
    PlayObject.HasLevelUp(0); //20091022 修改
    SysMsg(sHumanName + ' 经验调整完成。', c_Green, t_Hint);
    if g_Config.boShowMakeItemMsg then
      MainOutMessage(Format('[经验调整] %s(%s %d -> %d)', [m_sCharName, PlayObject.m_sCharName, dwOExp, PlayObject.m_Abil.nExp])); //20091104 修改
      //MainOutMessage('[经验调整] ' + m_sCharName + '(' + PlayObject.m_sCharName + ' ' + IntToStr(dwOExp) + ' -> ' + IntToStr(PlayObject.m_Abil.Exp) + ')');
  end else begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;
//千里传音,传音筒 20071228

procedure TPlayObject.CmdSysMsg(Cmd: pTGameCmd; Text: string);
var
  I, K: integer;
  AmuletStdItem: pTStdItem;
  PlayObject: TPlayObject;
{$IF M2Version <> 2}
  HumTitleDB: pTHumTitleDB;
{$ifend}
begin
  if Text = '' then begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 发布信息', c_Red, t_Hint);
    Exit;
  end;

  if (GetTickCount - m_dwSayMsgTick) < g_Config.dwSayMsgTime then begin //限制发言过快 20090815
    SysMsg('发言过快，请稍后...', c_Red, t_Hint);
    Exit;
  end else begin
    m_dwSayMsgTick := GetTickCount();
    m_nSayMsgCount := 0;
  end;
  {$IF M2Version <> 2}
  if m_boCanTitle then begin //有称号
    for K := Low(THumTitles) to High(THumTitles) do begin
      if (m_wHumTitles[K].wIndex > 0) and (m_wHumTitles[K].MakeIndex > 0) and (m_wHumTitles[K].wDura > 0) then begin
        HumTitleDB := UserEngine.GetHumTitle(m_wHumTitles[K].wIndex);
        if HumTitleDB <> nil then begin
          if (HumTitleDB.StdMode = 0) and (HumTitleDB.AniCount = 1) then begin //水晶之星称号
            if Length(Text) > g_Config.nSayMsgMaxLen then begin //限制千里传音的字符长度
              Text := Copy(Text, 1, g_Config.nSayMsgMaxLen);
            end;
            IsFilterMsg(Text); //文字过滤
            Dec(m_wHumTitles[K].wDura);
            SendMsg(self, RM_SENDHUMTITLES, 0, 0, 0, 0, '');
            try //千里传音 的字的颜色
              EnterCriticalSection(ProcessHumanCriticalSection);
              if UserEngine.m_PlayObjectList.Count > 0 then begin
                for I := 0 to UserEngine.m_PlayObjectList.Count - 1 do begin
                  PlayObject := TPlayObject(UserEngine.m_PlayObjectList.Objects[I]);
                  if PlayObject <> nil then begin
                    if not PlayObject.m_boGhost then
                      PlayObject.SysMsg(Format('[%s]%s:%s', [HumTitleDB.sTitleName, m_sCharName, Text]), c_Fuchsia, t_Say);
                  end;
                end; //for
              end;
            finally
              LeaveCriticalSection(ProcessHumanCriticalSection);
            end;
            Exit;
          end;
        end;
      end;
    end;
  end;
  {$ifend}
  if m_UseItems[U_CHARM].wIndex > 0 then begin
    AmuletStdItem := UserEngine.GetStdItem(m_UseItems[U_CHARM].wIndex);
    if (AmuletStdItem <> nil) then begin
      if (AmuletStdItem.StdMode = 7) then begin
        case AmuletStdItem.Shape of
          0: begin //物品是千里传音
              if Length(Text) > g_Config.nSayMsgMaxLen then begin //限制千里传音的字符长度 20090815
                Text := Copy(Text, 1, g_Config.nSayMsgMaxLen);
              end;
              IsFilterMsg(Text); //文字过滤 20080729
              if m_UseItems[U_CHARM].Dura >= 1000 then begin
                Dec(m_UseItems[U_CHARM].Dura, 1000);
                SendMsg(self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura, m_UseItems[U_CHARM].DuraMax, 0, ''); //减少持久数

                try //千里传音 的字的颜色
                  EnterCriticalSection(ProcessHumanCriticalSection);
                  if UserEngine.m_PlayObjectList.Count > 0 then begin //20091113 增加
                    for I := 0 to UserEngine.m_PlayObjectList.Count - 1 do begin
                      PlayObject := TPlayObject(UserEngine.m_PlayObjectList.Objects[I]);
                      if PlayObject <> nil then begin
                        if not PlayObject.m_boGhost then begin
                          {$IF M2Version <> 2}
                          if m_boFengHaoDominate then //20110515 修改
                            PlayObject.SysMsg('[主宰者]' + m_sCharName + ':' + Text, c_Fuchsia, t_Say)
                          else
                          {$ifend}
                          PlayObject.SysMsg(m_sCharName + ':' + Text, c_Fuchsia, t_Say);
                        end;
                      end;
                    end; //for
                  end;
                finally
                  LeaveCriticalSection(ProcessHumanCriticalSection);
                end;

                if m_UseItems[U_CHARM].Dura <= 0 then begin //20080506
                  SendDelItems(@m_UseItems[U_CHARM]); //如果使用完，则删除物品
                  m_UseItems[U_CHARM].Dura := 0;
                  if AmuletStdItem.NeedIdentify = 1 then //20090502 物品消失记录日志
                    AddGameDataLog('6' + #9 + m_sMapName + #9 +
                      IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                      m_sCharName + #9 + AmuletStdItem.Name + #9 +
                      IntToStr(m_UseItems[U_CHARM].MakeIndex) + #9 +
                      IntToStr(m_UseItems[U_CHARM].Dura) + '/' + IntToStr(m_UseItems[U_CHARM].DuraMax) + #9 + '持久耗尽');
                  m_UseItems[U_CHARM].wIndex := 0;
                  m_UseItems[U_CHARM].MakeIndex := 0; //20090502 增加
                end;
              end else begin
                SendDelItems(@m_UseItems[U_CHARM]); //如果使用完，则删除物品
                m_UseItems[U_CHARM].Dura := 0;
                if AmuletStdItem.NeedIdentify = 1 then //20090502 物品消失记录日志
                  AddGameDataLog('6' + #9 + m_sMapName + #9 +
                    IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                    m_sCharName + #9 + AmuletStdItem.Name + #9 +
                    IntToStr(m_UseItems[U_CHARM].MakeIndex) + #9 +
                    IntToStr(m_UseItems[U_CHARM].Dura) + '/' + IntToStr(m_UseItems[U_CHARM].DuraMax) + #9 + '持久耗尽');
                m_UseItems[U_CHARM].wIndex := 0;
                m_UseItems[U_CHARM].MakeIndex := 0; //20090502 增加
              end;
            end; //0
          4: begin //传单筒 20091129
              IsFilterMsg(Text); //文字过滤
              Text := m_sCharName + ':' + Text;
              if Length(Text) > 64 then begin //限制传单筒的字符长度,只能一次一行文字 20091213
                SysMsg('对不起，您输入的字太多，无法发送', c_Green, t_Hint);
                Exit;
              end;
              if m_UseItems[U_CHARM].Dura >= 1000 then begin
                Dec(m_UseItems[U_CHARM].Dura, 1000);
                SendMsg(self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura, m_UseItems[U_CHARM].DuraMax, 0, ''); //减少持久数
                try //传单筒 的字的颜色
                  EnterCriticalSection(ProcessHumanCriticalSection);
                  if UserEngine.m_PlayObjectList.Count > 0 then begin
                    for I := 0 to UserEngine.m_PlayObjectList.Count - 1 do begin
                      PlayObject := TPlayObject(UserEngine.m_PlayObjectList.Objects[I]);
                      if PlayObject <> nil then begin
                        if not PlayObject.m_boGhost then
                          PlayObject.SendMsg(PlayObject, RM_MOVEMESSAGE, 5 {0为顶部滚动 1为中部居中 2聊天栏上面倒记时 3顶部居中固定 4快捷栏上显示 5传音筒}, g_Config.btSayMsgFColor1, g_Config.btSayeMsgBColor1, 0 {AmuletStdItem.AniCount时间}, Text);
                      end;
                    end; //for
                  end;
                finally
                  LeaveCriticalSection(ProcessHumanCriticalSection);
                end;
                if m_UseItems[U_CHARM].Dura <= 0 then begin
                  SendDelItems(@m_UseItems[U_CHARM]); //如果使用完，则删除物品
                  m_UseItems[U_CHARM].Dura := 0;
                  if AmuletStdItem.NeedIdentify = 1 then //物品消失记录日志
                    AddGameDataLog('6' + #9 + m_sMapName + #9 +
                      IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                      m_sCharName + #9 + AmuletStdItem.Name + #9 +
                      IntToStr(m_UseItems[U_CHARM].MakeIndex) + #9 +
                      IntToStr(m_UseItems[U_CHARM].Dura) + '/' + IntToStr(m_UseItems[U_CHARM].DuraMax) + #9 + '持久耗尽');
                  m_UseItems[U_CHARM].wIndex := 0;
                  m_UseItems[U_CHARM].MakeIndex := 0;
                end;
              end else begin
                SendDelItems(@m_UseItems[U_CHARM]); //如果使用完，则删除物品
                m_UseItems[U_CHARM].Dura := 0;
                if AmuletStdItem.NeedIdentify = 1 then //物品消失记录日志
                  AddGameDataLog('6' + #9 + m_sMapName + #9 +
                    IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                    m_sCharName + #9 + AmuletStdItem.Name + #9 +
                    IntToStr(m_UseItems[U_CHARM].MakeIndex) + #9 +
                    IntToStr(m_UseItems[U_CHARM].Dura) + '/' + IntToStr(m_UseItems[U_CHARM].DuraMax) + #9 + '持久耗尽');
                m_UseItems[U_CHARM].wIndex := 0;
                m_UseItems[U_CHARM].MakeIndex := 0;
              end;
            end; //4
        end; //Case
      end;
    end;
  end else SysMsg('物品没有穿上装备栏里，无法使用。', c_Red, t_Hint);
end;
{$IF M2Version <> 2}
//回收玩家称号

procedure TPlayObject.CmdClearHumTitle(Cmd: pTGameCmd; sName, sHumTitleName: string);
var
  I, nIdx: Integer;
  PoseHuman, PoseHuman1: TPlayObject;
  HumTitleDB, HumTitleDB1: pTHumTitleDB;
  sFileName: string;
  LoadList: TStringList;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sName = '') or (sHumTitleName = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 称号名', c_Red, t_Hint);
    Exit;
  end;
  PoseHuman := UserEngine.GetPlayObject(sName); //检查是否在线
  if PoseHuman = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sName]), c_Red, t_Hint);
    Exit;
  end;

  HumTitleDB := UserEngine.GetHumTitle(sHumTitleName);
  if HumTitleDB <> nil then begin
    for I := Low(THumTitles) to High(THumTitles) do begin //判断人物是否有同样的称号
      if (PoseHuman.m_wHumTitles[I].wIndex > 0) and (PoseHuman.m_wHumTitles[I].MakeIndex > 0) then begin
        HumTitleDB1 := UserEngine.GetHumTitle(PoseHuman.m_wHumTitles[I].wIndex);
        if HumTitleDB1 <> nil then begin
          if (HumTitleDB1.sTitleName = sHumTitleName) and
            (HumTitleDB1.StdMode = HumTitleDB.StdMode) then begin
            if PoseHuman.m_wHumTitles[I].boUseTitle then begin
              PoseHuman.m_boUseIitleIdx := 0;
              PoseHuman.m_sUseIitleName := '';
            end;
            PoseHuman.m_wHumTitles[I].MakeIndex := 0;
            PoseHuman.m_wHumTitles[I].wIndex := 0;
            PoseHuman.m_wHumTitles[I].boUseTitle := False;
            PoseHuman.m_wHumTitles[I].wDura := 0;
            PoseHuman.m_wHumTitles[I].wMaxDura := 0;
            case HumTitleDB.AniCount of
              2: begin //主宰龙卫
                  if PoseHuman.m_wHumTitles[I].sChrName <> '' then begin
                    PoseHuman1 := UserEngine.GetPlayObject(PoseHuman.m_wHumTitles[I].sChrName); //检查是否在线
                    if PoseHuman1 <> nil then begin
                      nIdx := PoseHuman1.m_ComradeList.IndexOf(PoseHuman.m_sCharName);
                      if nIdx > -1 then begin
                        PoseHuman1.m_ComradeList.Delete(nIdx);
                        PoseHuman1.SaveFengHaoList(g_Config.sEnvirDir + 'UserData\FengHao\Comrade', PoseHuman1.m_ComradeList);
                      end;
                    end else begin
                      sFileName := g_Config.sEnvirDir + 'UserData\FengHao\Comrade\' + PoseHuman.m_wHumTitles[I].sChrName + '.txt';
                      if FileExists(sFileName) then begin
                        try
                          LoadList := TStringList.Create;
                          LoadList.LoadFromFile(sFileName);
                          nIdx := LoadList.IndexOf(PoseHuman.m_sCharName);
                          if nIdx > -1 then begin
                            LoadList.Delete(nIdx);
                            LoadList.SaveToFile(sFileName);
                          end;
                        finally
                          LoadList.Free;
                        end;
                      end;
                    end;
                  end;
                end;
              3: begin //护花使者
                  if PoseHuman.m_wHumTitles[I].sChrName <> '' then begin
                    PoseHuman1 := UserEngine.GetPlayObject(PoseHuman.m_wHumTitles[I].sChrName); //检查是否在线
                    if PoseHuman1 <> nil then begin
                      nIdx := PoseHuman1.m_HuhuaList.IndexOf(PoseHuman.m_sCharName);
                      if nIdx > -1 then begin
                        PoseHuman1.m_HuhuaList.Delete(nIdx);
                        PoseHuman1.SaveFengHaoList(g_Config.sEnvirDir + 'UserData\FengHao\HuHua', PoseHuman1.m_HuhuaList);
                      end;
                    end else begin
                      sFileName := g_Config.sEnvirDir + 'UserData\FengHao\HuHua\' + PoseHuman.m_wHumTitles[I].sChrName + '.txt';
                      if FileExists(sFileName) then begin
                        try
                          LoadList := TStringList.Create;
                          LoadList.LoadFromFile(sFileName);
                          nIdx := LoadList.IndexOf(PoseHuman.m_sCharName);
                          if nIdx > -1 then begin
                            LoadList.Delete(nIdx);
                            LoadList.SaveToFile(sFileName);
                          end;
                        finally
                          LoadList.Free;
                        end;
                      end;
                    end;
                  end;
                end;
              7: begin //传奇之星，清空列表
                  PoseHuman.m_HuhuaList.Clear;
                  sFileName := g_Config.sEnvirDir + 'UserData\FengHao\HuHua';
                  if not DirectoryExists(sFileName) then ForceDirectories(sFileName); //目录不存在,则创建
                  sFileName := sFileName + '\' + PoseHuman.m_sCharName + '.txt';
                  if FileExists(sFileName) then DeleteFile(sFileName);
                end;
              9: begin //玛法主宰者
                  PoseHuman.m_ComradeList.Clear;
                  sFileName := g_Config.sEnvirDir + 'UserData\FengHao\Comrade';
                  if not DirectoryExists(sFileName) then ForceDirectories(sFileName); //目录不存在,则创建
                  sFileName := sFileName + '\' + PoseHuman.m_sCharName + '.txt';
                  if FileExists(sFileName) then DeleteFile(sFileName);
                end;
            end;
            PoseHuman.m_wHumTitles[I].sChrName := ''; //需处理认命类称号
            PoseHuman.SysMsg(Format('您失去了称号：%s', [HumTitleDB.sTitleName]), c_Green, t_Hint);
            SysMsg(Format('回收 %s 称号：%s 成功', [PoseHuman.m_sCharName, HumTitleDB.sTitleName]), c_Green, t_Hint);
            PoseHuman.SendMsg(PoseHuman, RM_SENDHUMTITLES, 0, 0, 0, 0, '');
            PoseHuman.RecalcAbilitys();
            PoseHuman.CompareSuitItem(False); //套装
            PoseHuman.SendMsg(PoseHuman, RM_ABILITY, 0, 0, 0, 0, '');
            PoseHuman.RefShowName();
            if g_FunctionNPC <> nil then begin
              g_FunctionNPC.GotoLable(PoseHuman, '@FengHaoFunc' + IntToStr(HumTitleDB.idx), False, False);
            end;
            Break;
          end;
        end;
      end;
    end;
  end;
end;

//客户设置称号

procedure TPlayObject.ClientSetUserTitles(nTitlesMakeIdx {称号制造ID}: Integer; nType {操作类型}: Byte);
var
  I, K, L: Integer;
  HumTitleDB: pTHumTitleDB;
  boSetOK: Boolean;
  sStr: string;
begin
  try
    boSetOK := False;
    sStr := '';
    if (not m_boDeath) and (not m_boGhost) and (nTitlesMakeIdx >= 0) and (nType in [0, 1]) and m_boCanTitle then begin
      case nType of
        0: begin //关闭称号
            if m_boUseTitle then begin
              for I := Low(THumTitles) to High(THumTitles) do begin
                if (m_wHumTitles[I].wIndex > 0) and (m_wHumTitles[I].MakeIndex > 0) then begin
                  if m_wHumTitles[I].MakeIndex = nTitlesMakeIdx then begin
                    m_wHumTitles[I].boUseTitle := False;
                    m_boUseTitle := False;
                    m_boUseIitleIdx := 0;
                    m_sUseIitleName := '';
                    boSetOK := True;
                    Break;
                  end else begin
                    m_wHumTitles[I].boUseTitle := False;
                  end;
                end;
              end;
              if boSetOK then begin
                SendMsg(Self, RM_SETUSERTITLES, 0, 0, 0, 0, '');
                SysMsg('[设置称号：您取消当前称号]', c_Green, t_Hint);
                if g_Config.boUseFengHaoAbil then begin
                  RecalcAbilitys();
                  CompareSuitItem(False); //套装
                  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                end;
                RefShowName();
              end;
            end;
          end;
        1: begin //启用称号
            K := 0;
            L := 0;
            for I := Low(THumTitles) to High(THumTitles) do begin
              if (m_wHumTitles[I].wIndex > 0) and (m_wHumTitles[I].MakeIndex > 0) then begin
                Inc(L);
                if m_wHumTitles[I].MakeIndex = nTitlesMakeIdx then begin
                  m_wHumTitles[I].boUseTitle := True;
                  m_boUseTitle := True;
                  HumTitleDB := UserEngine.GetHumTitle(m_wHumTitles[I].wIndex);
                  if HumTitleDB <> nil then begin
                    m_boUseIitleIdx := HumTitleDB.Looks;
                    m_sUseIitleName := HumTitleDB.sTitleName;
                    sStr := HumTitleDB.sTitleName;
                  end else begin
                    m_boUseIitleIdx := 0;
                    m_sUseIitleName := '';
                  end;
                  K := L;
                  boSetOK := True;
                end else m_wHumTitles[I].boUseTitle := False;
              end;
            end;
            if boSetOK then begin
              SendMsg(Self, RM_SETUSERTITLES, 0, K, 0, 0, '');
              SysMsg(Format('[设置称号：您当前称号为%s]', [sStr]), c_Green, t_Hint);
              if g_Config.boUseFengHaoAbil then begin
                RecalcAbilitys();
                CompareSuitItem(False); //套装
                SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
              end;
              RefShowName();
            end;
          end;
      end;
    end;
  except
    MainOutMessage(format('{%s} TPlayObject.ClientSetUserTitles %p', [g_sExceptionVer, ExceptAddr]));
  end;
end;
//保存称号列表(传奇之星,主宰设置护花使者和龙卫时保存使用)

procedure TPlayObject.SaveFengHaoList(sFileName: string; var List: TStringList);
var sName: string;
begin
  try
    if not DirectoryExists(sFileName) then ForceDirectories(sFileName); //目录不存在,则创建
    sName := sFileName + '\' + m_sCharName + '.txt';
    List.SaveToFile(sName);
  except
    MainOutMessage(format('{%s} TPlayObject.SaveFengHaoList %p', [g_sExceptionVer, ExceptAddr]));
  end;
end;
//读取称号列表(传奇之星，主宰登录时使用)

procedure TPlayObject.GetFengHaoList(sFileName: string; var List: TStringList);
var sName: string;
begin
  try
    sName := sFileName + '\' + m_sCharName + '.txt';
    if FileExists(sName) then List.LoadFromFile(sName);
  except
    MainOutMessage(format('{%s} TPlayObject.GetFengHaoList %p', [g_sExceptionVer, ExceptAddr]));
  end;
end;
//发送称号列表 nType 0-护花使者列表 1-龙卫列表

procedure TPlayObject.SendFengHaoList(nType: Byte; boOk: Boolean);
var
  I: Integer;
  ClientHumName: TClientHumName;
  sSENDMSG, sStr: string;
begin
  try
    if ((GetTickCount - m_SendNameListMsgTick > 2000) or boOk) and m_boCanTitle then begin //发送称号列表间隔
      if not boOk then m_SendNameListMsgTick := GetTickCount();
      sSENDMSG := '';
      case nType of
        0: begin //护花使者列表
            if m_boFengHaoMagicEffect then begin
              if (m_HuhuaList.Count > 0) then begin
                for I := 0 to m_HuhuaList.Count - 1 do begin
                  sStr := m_HuhuaList.Strings[I];
                  if sStr <> '' then begin
                    ClientHumName.sChrName := sStr;
                    ClientHumName.boOnline := UserEngine.GetPlayOnline(sStr);
                    sSENDMSG := sSENDMSG + EncodeBuffer(@ClientHumName, SizeOf(TClientHumName)) + '/';
                  end;
                end;
              end;
              m_DefMsg := MakeDefaultMsg(SM_SENDFENGHAOLIST, 0, 0, 0, 0, 0);
              SendSocket(@m_DefMsg, sSENDMSG);
            end;
          end;
        1: begin //龙卫列表
            if m_boFengHaoDominate then begin
              m_boOpenDominateToken := True;
              SendDominatSendList(); //发送主宰令地图名列表
              if (m_ComradeList.Count > 0) then begin
                for I := 0 to m_ComradeList.Count - 1 do begin
                  sStr := m_ComradeList.Strings[I];
                  if sStr <> '' then begin
                    ClientHumName.sChrName := sStr;
                    ClientHumName.boOnline := UserEngine.GetPlayOnline(sStr);
                    sSENDMSG := sSENDMSG + EncodeBuffer(@ClientHumName, SizeOf(TClientHumName)) + '/';
                  end;
                end;
              end;
              m_DefMsg := MakeDefaultMsg(SM_SENDFENGHAOLIST, 0, 1, 0, 0, 0);
              SendSocket(@m_DefMsg, sSENDMSG);
            end;
          end;
      end;
    end;
  except
    MainOutMessage(format('{%s} TPlayObject.SendFengHaoList %p', [g_sExceptionVer, ExceptAddr]));
  end;
end;
//发送主宰令地图名列表

procedure TPlayObject.SendDominatSendList();
var
  I: Integer;
  sSENDMSG: string;
  ClientDominatPoint: TClientDominatPoint;
  DominatSendPoint: pTDominatSendPoint;
begin
  try
    sSENDMSG := '';
    if (g_DominatSendList.Count > 0) and (not m_boSendDominateMapName) then begin
      m_boSendDominateMapName := True; //是否发送过地图列表
      for I := 0 to g_DominatSendList.Count - 1 do begin
        DominatSendPoint := pTDominatSendPoint(g_DominatSendList.Objects[I]);
        if DominatSendPoint <> nil then begin
          if DominatSendPoint.m_sMapDesc <> '' then begin
            ClientDominatPoint.m_sMapDesc := DominatSendPoint.m_sMapDesc;
            ClientDominatPoint.nIdx := DominatSendPoint.nIdx;
            sSENDMSG := sSENDMSG + EncodeBuffer(@ClientDominatPoint, SizeOf(TClientDominatPoint)) + '/';
          end;
        end;
      end;
      if sSENDMSG <> '' then begin
        m_DefMsg := MakeDefaultMsg(SM_SENDDOMINATLIST, 0, 0, 0, 0, 0);
        SendSocket(@m_DefMsg, sSENDMSG);
      end;
    end;
  except
    MainOutMessage(format('{%s} TPlayObject.SendDominatSendList %p', [g_sExceptionVer, ExceptAddr]));
  end;
end;
//使用主宰令地图传送

procedure TPlayObject.ClientDominateFly(sMap: string);
var
  I, nCode: Integer;
  DominatSendPoint: pTDominatSendPoint;
begin
  try
    nCode := 0;
    if m_boFengHaoDominate and m_boOpenDominateToken and (sMap <> '') and
      (g_DominatSendList.Count > 0) then begin
      I := -1;
      I := g_DominatSendList.IndexOf(sMap);
      if I > -1 then begin
        DominatSendPoint := pTDominatSendPoint(g_DominatSendList.Objects[I]);
        if DominatSendPoint <> nil then begin
          nCode := 3;
          m_boOpenDominateToken := False;
          SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
          SpaceMove(DominatSendPoint.m_sMapName, DominatSendPoint.m_nCurrX, DominatSendPoint.m_nCurrY, 0);
        end else nCode := 2;
      end else nCode := 1;
    end;
    SendMsg(Self, RM_WORLDFLY, 0, nCode, 0, 0, '');
  except
    MainOutMessage(format('{%s} TPlayObject.ClientDominateFly %p', [g_sExceptionVer, ExceptAddr]));
  end;
end;

//召唤传送称号人员

procedure TPlayObject.ClientCallFengHaoPlay(nTpye {类型 0-护花令牌 1-主宰令牌}, nOperateTpey {操作类型 0-召唤 1-传送}: Byte; sName: string {名字});
var
  PoseHuman: TPlayObject;
  nCode: Byte;
begin
  try
    nCode := 0;
    if (nOperateTpey < 2) and m_boCanTitle and (sName <> '') then begin
      case nTpye of
        0: begin //护花令牌
            nCode := 1;
            if m_boFengHaoMagicEffect and (m_HuhuaList.Count > 0) then begin
              nCode := 2;
              if m_HuhuaList.IndexOf(sName) > -1 then begin
                PoseHuman := UserEngine.GetPlayObject(sName); //检查是否在线
                if PoseHuman <> nil then begin
                  if CompareText(PoseHuman.m_sHuhuaName, m_sCharName) = 0 then begin //判断是不是自己的护花使者
                    if (not PoseHuman.m_boDeath) and (not PoseHuman.m_boGhost) and
                      PoseHuman.m_boCanTitle and (not PoseHuman.m_boCallFengHaoPlay) then begin
                      if (PoseHuman.m_PEnvir = m_PEnvir) then begin //同个地图才能执行
                        PoseHuman.m_boCallFengHaoPlay := True;
                        case nOperateTpey of
                          0: begin //召唤
                              nCode := 7;
                              m_CallFengHaoPlayTick := GetTickCount;
                              PoseHuman.SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(self), 5, 0, '传奇之星正在对您进行召唤，希望你尽快赶到他的身边，你确定现在就动\身吗？');
                            end;
                          1: begin //传送
                              nCode := 7;
                              m_CallFengHaoPlayTick := GetTickCount;
                              PoseHuman.SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(self), 6, 0, '传奇之星想要传送您的身边和您并肩作战，您是否愿意接受？');
                            end;
                        end;
                      end else nCode := 6;
                    end;
                  end else nCode := 5;
                end else nCode := 4;
              end else nCode := 3;
            end;
          end; //0
        1: begin //主宰令牌
            nCode := 12;
            if m_boFengHaoDominate and (m_ComradeList.Count > 0) then begin
              if m_ComradeList.IndexOf(sName) > -1 then begin
                PoseHuman := UserEngine.GetPlayObject(sName); //检查是否在线
                if PoseHuman <> nil then begin
                  if CompareText(PoseHuman.m_sDominateName, m_sCharName) = 0 then begin //判断是不是自己的龙卫
                    if (not PoseHuman.m_boDeath) and (not PoseHuman.m_boGhost) and
                      PoseHuman.m_boCanTitle and (not PoseHuman.m_boCallFengHaoPlay) then begin
                      if PoseHuman.m_PEnvir = m_PEnvir then begin //同个地图才能执行
                        PoseHuman.m_boCallFengHaoPlay := True;
                        case nOperateTpey of
                          0: begin //召唤
                              nCode := 7;
                              m_CallFengHaoPlayTick := GetTickCount;
                              PoseHuman.SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(self), 7, 0, '玛法主宰者正在对您进行召唤，希望你尽快赶到他的身边，你确定现在就动\身吗？');
                            end;
                          1: begin //传送
                              nCode := 7;
                              m_CallFengHaoPlayTick := GetTickCount;
                              PoseHuman.SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(self), 8, 0, '玛法主宰者想要传送您的身边和您并肩作战，您是否愿意接受？');
                            end;
                        end;
                      end else nCode := 16;
                    end;
                  end else nCode := 15;
                end else nCode := 14;
              end else nCode := 13;
            end;
          end;
      end;
      case nCode of
        1: SysMsg('你没有设置护花使者，不能使用此功能！', c_Red, t_Hint);
        12: SysMsg('你没有设置主宰龙卫，不能使用此功能！', c_Red, t_Hint);
        3: SysMsg('找不到对应的护花使者名单！', c_Red, t_Hint);
        13: SysMsg('找不到对应的主宰龙卫名单！', c_Red, t_Hint);
        4, 14: SysMsg(sName + '不在线！', c_Red, t_Hint);
        5: SysMsg(sName + '不是你的护花使者，不能使用此功能！', c_Red, t_Hint);
        15: SysMsg(sName + '不是你的主宰龙卫，不能使用此功能！', c_Red, t_Hint);
        6, 16: SysMsg(sName + '和你不在同一地图内，不能使用此功能！', c_Red, t_Hint);
        7: SysMsg('请求已发送，请等待对方确认！', c_Green, t_Hint);
      end;
    end;
  except
    
    MainOutMessage(format('{%s} TPlayObject.ClientCallFengHaoPlay %p', [g_sExceptionVer, ExceptAddr]));
  end;
end;
//同意召唤传送

procedure TPlayObject.ClientAgreeCallFengHao(nTpye {类型 0-护花令牌 1-主宰令牌}, nOperateTpey {操作类型 0-召唤 1-传送}: Byte);
var
  PoseHuman: TPlayObject;
  n18, n1C: Integer;
begin
  try
    if (nOperateTpey < 2) and m_boCanTitle and m_boCallFengHaoPlay then begin
      m_boCallFengHaoPlay := False;
      case nTpye of
        0: begin //护花令牌
            if m_boFengHaoHuhua and (m_sHuhuaName <> '') then begin
              PoseHuman := UserEngine.GetPlayObject(m_sHuhuaName); //检查是否在线
              if PoseHuman <> nil then begin
                if (not PoseHuman.m_boDeath) and (not PoseHuman.m_boGhost) and PoseHuman.m_boCanTitle and
                  PoseHuman.m_boFengHaoMagicEffect and (PoseHuman.m_PEnvir = m_PEnvir) then begin
                  case nOperateTpey of
                    0: begin //召唤
                        sub_4C5370(PoseHuman.m_nCurrX, PoseHuman.m_nCurrY, 3, n18, n1C);
                        SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
                        SpaceMove(PoseHuman.m_PEnvir.sMapName, n18, n1C, 0);
                      end;
                    1: begin //传送
                        sub_4C5370(m_nCurrX, m_nCurrY, 3, n18, n1C);
                        PoseHuman.SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
                        PoseHuman.SpaceMove(m_PEnvir.sMapName, n18, n1C, 0);
                      end;
                  end;
                end;
              end;
            end;
          end;
        1: begin //主宰令牌
            if m_boFengHaoComrade and (m_sDominateName <> '') then begin
              PoseHuman := UserEngine.GetPlayObject(m_sDominateName); //检查是否在线
              if PoseHuman <> nil then begin
                if (not PoseHuman.m_boDeath) and (not PoseHuman.m_boGhost) and PoseHuman.m_boCanTitle and
                  PoseHuman.m_boFengHaoDominate and (PoseHuman.m_PEnvir = m_PEnvir) then begin
                  case nOperateTpey of
                    0: begin //召唤
                        sub_4C5370(PoseHuman.m_nCurrX, PoseHuman.m_nCurrY, 3, n18, n1C);
                        SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
                        SpaceMove(PoseHuman.m_PEnvir.sMapName, n18, n1C, 0);
                      end;
                    1: begin //传送
                        sub_4C5370(m_nCurrX, m_nCurrY, 3, n18, n1C);
                        PoseHuman.SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
                        PoseHuman.SpaceMove(m_PEnvir.sMapName, n18, n1C, 0);
                      end;
                  end;
                end;
              end;
            end;
          end;
      end;
    end;
  except
    MainOutMessage(format('{%s} TPlayObject.ClientAgreeCallFengHao %p', [g_sExceptionVer, ExceptAddr]));
  end;
end;
//取消召唤传送

procedure TPlayObject.ClientCancelCallFengHao(nTpye {类型 0-护花令牌 1-主宰令牌}, nOperateTpey {操作类型 0-召唤 1-传送}: Byte);
var
  PoseHuman: TPlayObject;
begin
  try
    if m_boCallFengHaoPlay and (nOperateTpey < 2) and m_boCanTitle then begin
      m_boCallFengHaoPlay := False;
      case nTpye of
        0: begin //护花令牌
            if m_boFengHaoHuhua and (m_sHuhuaName <> '') then begin
              PoseHuman := UserEngine.GetPlayObject(m_sHuhuaName); //检查是否在线
              if PoseHuman <> nil then begin
                if (not PoseHuman.m_boDeath) and (not PoseHuman.m_boGhost) and PoseHuman.m_boCanTitle and
                  PoseHuman.m_boFengHaoMagicEffect and (PoseHuman.m_PEnvir = m_PEnvir) then begin
                  case nOperateTpey of
                    0: PoseHuman.SysMsg(Format('%s 拒绝您的召唤请求!', [m_sCharName]), c_Red, t_Hint); //召唤
                    1: PoseHuman.SysMsg(Format('%s 拒绝您的传送请求!', [m_sCharName]), c_Red, t_Hint); //传送
                  end;
                end;
              end;
            end;
          end;
        1: begin //主宰令牌
            if m_boFengHaoComrade and (m_sDominateName <> '') then begin
              PoseHuman := UserEngine.GetPlayObject(m_sDominateName); //检查是否在线
              if PoseHuman <> nil then begin
                if (not PoseHuman.m_boDeath) and (not PoseHuman.m_boGhost) and PoseHuman.m_boCanTitle and
                  PoseHuman.m_boFengHaoDominate and (PoseHuman.m_PEnvir = m_PEnvir) then begin
                  case nOperateTpey of
                    0: PoseHuman.SysMsg(Format('%s 拒绝您的召唤请求!', [m_sCharName]), c_Red, t_Hint); //召唤
                    1: PoseHuman.SysMsg(Format('%s 拒绝您的传送请求!', [m_sCharName]), c_Red, t_Hint); //传送
                  end;
                end;
              end;
            end;
          end;
      end;
    end;
  except
    MainOutMessage(format('{%s} TPlayObject.ClientCancelCallFengHao %p', [g_sExceptionVer, ExceptAddr]));
  end;
end;
//客户端回收称号

procedure TPlayObject.ClientRecycFengHao(nTpye {类型 0-护花令牌 1-主宰令牌}: Byte; sName: string {名字});
var
  PoseHuman: TPlayObject;
  I, Idx: Integer;
  HumTitleDB: pTHumTitleDB;
  sUnFileName: string;
  LoadList: TStringList;
begin
  try
    if (nTpye < 2) and m_boCanTitle and (sName <> '') then begin
      Idx := -1;
      case nTpye of
        0: begin //回收护花使者称号
            if m_boFengHaoMagicEffect and (m_HuhuaList.Count > 0) then begin
              Idx := m_HuhuaList.IndexOf(sName);
              if Idx > -1 then begin
                PoseHuman := UserEngine.GetPlayObject(sName); //检查是否在线
                if PoseHuman <> nil then begin
                  if CompareText(PoseHuman.m_sHuhuaName, m_sCharName) = 0 then begin //判断是不是自己的护花使者
                    if (not PoseHuman.m_boDeath) and (not PoseHuman.m_boGhost) and PoseHuman.m_boCanTitle then begin
                      for I := Low(THumTitles) to High(THumTitles) do begin
                        if (PoseHuman.m_wHumTitles[I].wIndex > 0) and (PoseHuman.m_wHumTitles[I].MakeIndex > 0) then begin
                          HumTitleDB := UserEngine.GetHumTitle(PoseHuman.m_wHumTitles[I].wIndex);
                          if HumTitleDB <> nil then begin
                            if HumTitleDB.AniCount = 3 then begin //护花使者称号
                              if PoseHuman.m_wHumTitles[I].boUseTitle then begin
                                PoseHuman.m_boUseIitleIdx := 0;
                                PoseHuman.m_sUseIitleName := '';
                              end;
                              PoseHuman.m_wHumTitles[I].MakeIndex := 0;
                              PoseHuman.m_wHumTitles[I].wIndex := 0;
                              PoseHuman.m_wHumTitles[I].boUseTitle := False;
                              PoseHuman.m_wHumTitles[I].wDura := 0;
                              PoseHuman.m_wHumTitles[I].wMaxDura := 0;
                              PoseHuman.m_wHumTitles[I].sChrName := '';
                              m_HuhuaList.Delete(Idx);
                              SaveFengHaoList(g_Config.sEnvirDir + 'UserData\FengHao\HuHua', m_HuhuaList);
                              SendFengHaoList(0, True);
                              SysMsg('回收称号成功！', c_Green, t_Hint);
                              PoseHuman.SysMsg(Format('您失去了称号：%s', [HumTitleDB.sTitleName]), c_Green, t_Hint);
                              PoseHuman.SendMsg(PoseHuman, RM_SENDHUMTITLES, 0, 0, 0, 0, '');
                              PoseHuman.m_boFengHaoHuhua := False;
                              PoseHuman.RecalcAbilitys();
                              PoseHuman.CompareSuitItem(False); //套装
                              PoseHuman.SendMsg(PoseHuman, RM_ABILITY, 0, 0, 0, 0, '');
                              PoseHuman.RefShowName();
                              if g_FunctionNPC <> nil then begin
                                g_FunctionNPC.GotoLable(PoseHuman, '@FengHaoFunc' + IntToStr(HumTitleDB.idx), False, False);
                              end;
                              Break;
                            end;
                          end;
                        end;
                      end;
                    end;
                  end;
                end else begin //不在线时记录文件 20110406
                  sUnFileName := g_Config.sEnvirDir + 'UnHuHua.txt';
                  LoadList := TStringList.Create;
                  try
                    if FileExists(sUnFileName) then begin
                      LoadList.LoadFromFile(sUnFileName);
                    end;
                    LoadList.Add(sName);
                    LoadList.SaveToFile(sUnFileName);
                    m_HuhuaList.Delete(Idx);
                    SaveFengHaoList(g_Config.sEnvirDir + 'UserData\FengHao\HuHua', m_HuhuaList);
                    SendFengHaoList(0, True);
                    SysMsg('回收称号成功！', c_Green, t_Hint);
                  finally
                    LoadList.Free;
                  end;
                //SysMsg(Format('%s不在线，不能回收称号！',[sName]), c_Red, t_Hint);
                end;
              end;
            end;
          end;
        1: begin //回收主宰龙卫称号
            if m_boFengHaoDominate and (m_ComradeList.Count > 0) then begin
              Idx := m_ComradeList.IndexOf(sName);
              if Idx > -1 then begin
                PoseHuman := UserEngine.GetPlayObject(sName); //检查是否在线
                if PoseHuman <> nil then begin
                  if CompareText(PoseHuman.m_sDominateName, m_sCharName) = 0 then begin //判断是不是自己的龙卫
                    if (not PoseHuman.m_boDeath) and (not PoseHuman.m_boGhost) and PoseHuman.m_boCanTitle then begin
                      for I := Low(THumTitles) to High(THumTitles) do begin
                        if (PoseHuman.m_wHumTitles[I].wIndex > 0) and (PoseHuman.m_wHumTitles[I].MakeIndex > 0) then begin
                          HumTitleDB := UserEngine.GetHumTitle(PoseHuman.m_wHumTitles[I].wIndex);
                          if HumTitleDB <> nil then begin
                            if HumTitleDB.AniCount = 2 then begin //主宰龙卫称号
                              if PoseHuman.m_wHumTitles[I].boUseTitle then begin
                                PoseHuman.m_boUseIitleIdx := 0;
                                PoseHuman.m_sUseIitleName := '';
                              end;
                              PoseHuman.m_wHumTitles[I].MakeIndex := 0;
                              PoseHuman.m_wHumTitles[I].wIndex := 0;
                              PoseHuman.m_wHumTitles[I].boUseTitle := False;
                              PoseHuman.m_wHumTitles[I].wDura := 0;
                              PoseHuman.m_wHumTitles[I].wMaxDura := 0;
                              PoseHuman.m_wHumTitles[I].sChrName := '';
                              m_ComradeList.Delete(Idx);
                              SaveFengHaoList(g_Config.sEnvirDir + 'UserData\FengHao\Comrade', m_ComradeList);
                              SendFengHaoList(1, True);
                              SysMsg('回收称号成功！', c_Green, t_Hint);
                              PoseHuman.SysMsg(Format('您失去了称号：%s', [HumTitleDB.sTitleName]), c_Green, t_Hint);
                              PoseHuman.SendMsg(PoseHuman, RM_SENDHUMTITLES, 0, 0, 0, 0, '');
                              PoseHuman.m_boFengHaoComrade := False;
                              PoseHuman.RecalcAbilitys();
                              PoseHuman.CompareSuitItem(False); //套装
                              PoseHuman.SendMsg(PoseHuman, RM_ABILITY, 0, 0, 0, 0, '');
                              PoseHuman.RefShowName();
                              if g_FunctionNPC <> nil then begin
                                g_FunctionNPC.GotoLable(PoseHuman, '@FengHaoFunc' + IntToStr(HumTitleDB.idx), False, False);
                              end;
                              Break;
                            end;
                          end;
                        end;
                      end;
                    end;
                  end;
                end else begin
                  sUnFileName := g_Config.sEnvirDir + 'UnComrade.txt';
                  LoadList := TStringList.Create;
                  try
                    if FileExists(sUnFileName) then begin
                      LoadList.LoadFromFile(sUnFileName);
                    end;
                    LoadList.Add(sName);
                    LoadList.SaveToFile(sUnFileName);
                    m_ComradeList.Delete(Idx);
                    SaveFengHaoList(g_Config.sEnvirDir + 'UserData\FengHao\Comrade', m_ComradeList);
                    SendFengHaoList(1, True);
                    SysMsg('回收称号成功！', c_Green, t_Hint);
                  finally
                    LoadList.Free;
                  end;
                //SysMsg(Format('%s不在线，不能回收称号！',[sName]), c_Red, t_Hint);
                end;
              end;
            end;
          end;
      end; //case
    end;
  except
    MainOutMessage(format('{%s} TPlayObject.ClientRecycFengHao %p', [g_sExceptionVer, ExceptAddr]));
  end;
end;
//任命回复

procedure TPlayObject.ClientFenghaoAgree(nTpye {类型 0-不同意 1-同意}: Byte);
var
  PoseHuman: TPlayObject;
begin
  try
    if (nTpye < 2) and m_boFengHaoAgree then begin
      m_boFengHaoAgree := False;
      case nTpye of
        0: begin //不同意
            PoseHuman := UserEngine.GetPlayObject(m_sFenghaoName); //检查是否在线
            m_sFenghaoName := '';
            m_nFenghaotype := 0;
            if PoseHuman = nil then Exit;
            PoseHuman.SysMsg('对方不同意接收任命！', c_Red, t_Hint);
          end;
        1: begin
            if g_FunctionNPC <> nil then begin
              PoseHuman := UserEngine.GetPlayObject(m_sFenghaoName); //检查是否在线
              g_FunctionNPC.GotoLable(Self, '@FengHaoAgree' + IntToStr(m_nFenghaotype), False, False);
              m_sFenghaoName := '';
              m_nFenghaotype := 0;
              if PoseHuman = nil then Exit;
              PoseHuman.SysMsg('对方同意接收任命！', c_Green, t_Hint);
            end;
          end;
      end;
    end;
  except
    MainOutMessage(format('{%s} TPlayObject.ClientFenghaoAgree %p', [g_sExceptionVer, ExceptAddr]));
  end;
end;
{$IFEND}
//调整英雄等级 20071227

procedure TPlayObject.CmdHeroLevel(Cmd: pTGameCmd; sHeroName: string;
  nLevel: Integer);
var
  PlayObject: TBaseObject;
  nOLevel: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint); //权限不够
    Exit;
  end;
  if sHeroName = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 英雄名称 等级', c_Red, t_Hint);
    Exit;
  end;
{$IF HEROVERSION = 1}
  PlayObject := UserEngine.GetHeroObject(sHeroName);
  if PlayObject <> nil then begin
    nOLevel := PlayObject.m_Abil.Level;
    PlayObject.m_Abil.Level := _MAX(1, _MIN(MAXUPLEVEL, nLevel));
    PlayObject.HasLevelUp(1);
    AddGameDataLog('17' + #9 + PlayObject.m_sMapName + #9 + //等级调整记录日志 20080911
      IntToStr(PlayObject.m_nCurrX) + #9 +
      IntToStr(PlayObject.m_nCurrY) + #9 +
      PlayObject.m_sCharName + #9 +
      IntToStr(PlayObject.m_Abil.Level) + #9 +
      m_sCharName + #9 +
      '+(' + IntToStr(nLevel) + ')' + #9 + '(英雄)');
    SysMsg('英雄 ' + sHeroName + ' 等级调整完成。', BB_Fuchsia, t_Hint);
    if g_Config.boShowMakeItemMsg then
      MainOutMessage('[英雄等级调整] ' + sHeroName + '(' + IntToStr(nOLevel) + ' -> ' + IntToStr(PlayObject.m_Abil.Level) + ')');
  end else begin
    SysMsg('英雄' + sHeroName + '现在不在线。', c_Red, t_Hint);
  end;
{$IFEND}
end;
//调整人物等级

procedure TPlayObject.CmdAdjuestLevel(Cmd: pTGameCmd; sHumanName: string;
  nLevel: Integer);
var
  PlayObject: TPlayObject;
  nOLevel: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sHumanName = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 等级', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    nOLevel := PlayObject.m_Abil.Level;
    PlayObject.m_Abil.Level := _MAX(1, _MIN(MAXUPLEVEL, nLevel));
    PlayObject.HasLevelUp(1);
    AddGameDataLog('17' + #9 + PlayObject.m_sMapName + #9 + //等级调整记录日志 20080911
      IntToStr(PlayObject.m_nCurrX) + #9 +
      IntToStr(PlayObject.m_nCurrY) + #9 +
      PlayObject.m_sCharName + #9 +
      IntToStr(PlayObject.m_Abil.Level) + #9 +
      m_sCharName + #9 + '+(' + IntToStr(nLevel) + ')' + #9 + '0');
    SysMsg(sHumanName + ' 等级调整完成。', c_Green, t_Hint);
    if g_Config.boShowMakeItemMsg then
      MainOutMessage('[等级调整] ' + m_sCharName + '(' + PlayObject.m_sCharName + ' ' + IntToStr(nOLevel) + ' -> ' + IntToStr(PlayObject.m_Abil.Level) + ')');
  end else begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdAdjustExp(Human: TPlayObject; nExp: Integer);
begin
  if (m_btPermission < 6) then Exit;
end;

procedure TPlayObject.CmdBackStep(sCmd: string; nType, nCount: Integer);
begin
  if (m_btPermission < 6) then Exit;
  nType := _MIN(nType, 8);
  if nType = 0 then begin
    CharPushed(GetBackDir(m_btDirection), nCount);
  end else begin
    CharPushed(Random(nType), nCount);
  end;
end;

procedure TPlayObject.CmdBonuPoint(Cmd: pTGameCmd; sHumName: string; nCount: Integer);
var
  PlayObject: TPlayObject;
  sMsg: string;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumName = '') then begin
    if g_Config.boGMShowFailMsg then sysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 属性点数(不输入为查看点数)', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
    Exit;
  end;
  if (nCount > 0) then begin
    PlayObject.m_nBonusPoint := nCount;
    PlayObject.SendMsg(Self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    Exit;
  end;
  sMsg := Format('未分配点数:%d 已分配点数:(DC:%d MC:%d SC:%d AC:%d MAC:%d HP:%d MP:%d HIT:%d SPEED:%d)',
    [PlayObject.m_nBonusPoint,
    PlayObject.m_BonusAbil.DC,
      PlayObject.m_BonusAbil.MC,
      PlayObject.m_BonusAbil.SC,
      PlayObject.m_BonusAbil.AC,
      PlayObject.m_BonusAbil.MAC,
      PlayObject.m_BonusAbil.HP,
      PlayObject.m_BonusAbil.MP,
      PlayObject.m_BonusAbil.Hit,
      PlayObject.m_BonusAbil.Speed
      ]);
  SysMsg(Format('%s的属性点数为:%s', [sHumName, sMsg]), c_Red, t_Hint);
end;

procedure TPlayObject.CmdChangeAdminMode(sCmd: string; nPermission: Integer; sParam1: string; boFlag: Boolean);
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  m_boAdminMode := boFlag;
  if m_boAdminMode then SysMsg(sGameMasterMode, c_Green, t_Hint)
  else SysMsg(sReleaseGameMasterMode, c_Green, t_Hint);
end;

procedure TPlayObject.CmdChangeAttackMode(nMode: Integer; sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7: string);
begin
  if (nMode >= 0) and (nMode <= 4) then
    m_btAttatckMode := nMode
  else begin
    if m_btAttatckMode < {$IF M2Version <> 2}HAM_DIVISION{$ELSE}HAM_PKATTACK{$IFEND} then Inc(m_btAttatckMode)
    else m_btAttatckMode := HAM_ALL;
  end;
  case m_btAttatckMode of //20080228改攻击模式
    HAM_ALL: begin //20080331 加入聊天框中提示
        SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfAll); //[攻击模式: 全体攻击]
        SysMsg(sAttackModeOfAll, c_Green, t_Hint); //[攻击模式: 全体攻击]
      end;
    HAM_PEACE: begin
        SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfPeaceful); //[攻击模式: 和平攻击]
        SysMsg(sAttackModeOfPeaceful, c_Green, t_Hint); //[攻击模式: 和平攻击]
      end;
    HAM_DEAR: begin
        SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfDear); //[攻击模式: 夫妻攻击]
        SysMsg(sAttackModeOfDear, c_Green, t_Hint); //[攻击模式: 夫妻攻击]
      end;
    HAM_MASTER: begin
        SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfMaster); //[攻击模式: 师徒攻击]
        SysMsg(sAttackModeOfMaster, c_Green, t_Hint); //[攻击模式: 师徒攻击]
      end;
    HAM_GROUP: begin
        SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfGroup); //[攻击模式: 编组攻击]
        SysMsg(sAttackModeOfGroup, c_Green, t_Hint); //[攻击模式: 编组攻击]
      end;
    HAM_GUILD: begin
        SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfGuild); //[攻击模式: 行会攻击]
        SysMsg(sAttackModeOfGuild, c_Green, t_Hint); //[攻击模式: 行会攻击]
      end;
    HAM_PKATTACK: begin
        SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfRedWhite); //[攻击模式: 红名攻击]
        SysMsg(sAttackModeOfRedWhite, c_Green, t_Hint); //[攻击模式: 红名攻击]
      end;
{$IF M2Version <> 2}
    HAM_DIVISION: begin
        SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfDivision); //[攻击模式: 师门攻击]
        SysMsg(sAttackModeOfDivision, c_Green, t_Hint); //[攻击模式: 师门攻击]
      end;
{$IFEND}
  end;
  if m_MyHero <> nil then m_MyHero.m_btAttatckMode := m_btAttatckMode;
end;

procedure TPlayObject.CmdChangeDearName(Cmd: pTGameCmd; sHumanName, sDearName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (sDearName = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 配偶名称(如果为 无 则清除)', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    if CompareText(sDearName, '无') = 0 then begin
      PlayObject.m_sDearName := '';
      PlayObject.RefShowName;
      SysMsg(sHumanName + ' 的配偶名清除成功。', c_Green, t_Hint);
    end else begin
      PlayObject.m_sDearName := sDearName;
      PlayObject.RefShowName;
      SysMsg(sHumanName + ' 的配偶名更改成功。', c_Green, t_Hint);
    end;
  end else begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdChangeGender(Cmd: pTGameCmd; sHumanName, sSex: string);
var
  PlayObject: TPlayObject;
  nSex: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  nSex := -1;
  if (sSex = 'Man') or (sSex = '男') or (sSex = '0') then begin
    nSex := 0;
  end;
  if (sSex = 'WoMan') or (sSex = '女') or (sSex = '1') then begin
    nSex := 1;
  end;
  if (sHumanName = '') or (nSex = -1) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 性别(男、女)', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    if PlayObject.m_btGender <> nSex then begin
      PlayObject.m_btGender := nSex;
      PlayObject.FeatureChanged();
      SysMsg(PlayObject.m_sCharName + ' 的性别已改变。', c_Green, t_Hint);
    end else begin
      SysMsg(PlayObject.m_sCharName + ' 的性别未改变！', c_Red, t_Hint);
    end;
  end else begin
    SysMsg(sHumanName + '没有在线！', c_Red, t_Hint);
  end;
end;
//改变物品名称

procedure TPlayObject.CmdChangeItemName(sCmd, sMakeIndex, sItemIndex, sItemName: string);
var
  nMakeIndex, nItemIndex: Integer;
begin
  if (m_btPermission < 6) then Exit;
  if (sMakeIndex = '') or (sItemIndex = '') or (sItemName = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + sCmd + ' 物品编号 物品ID号 物品名称', c_Red, t_Hint);
    Exit;
  end;
  nMakeIndex := Str_ToInt(sMakeIndex, -1);
  nItemIndex := Str_ToInt(sItemIndex, -1);
  if (nMakeIndex <= 0) or (nItemIndex < 0) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + sCmd + ' 物品编号 物品ID号 物品名称', c_Red, t_Hint);
    Exit;
  end;
  if ItemUnit.AddCustomItemName(nMakeIndex, nItemIndex, sItemName) then begin
    ItemUnit.SaveCustomItemName();
    SysMsg('物品名称设置成功。', c_Green, t_Hint);
    Exit;
  end;
  SysMsg('此物品，已经设置了其它的名称！', c_Red, t_Hint);
end;
//改变职业

procedure TPlayObject.CmdChangeJob(Cmd: pTGameCmd; sHumanName, sJobName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (sJobName = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandChangeJobHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    if CompareText(sJobName, 'Warr') = 0 then PlayObject.m_btJob := 0;
    if CompareText(sJobName, 'Wizard') = 0 then PlayObject.m_btJob := 1;
    if CompareText(sJobName, 'Taos') = 0 then PlayObject.m_btJob := 2;
    //if CompareText(sJobName, 'ASSASSIN') = 0 then PlayObject.m_btJob := 3;//刺客
    PlayObject.HasLevelUp({1}0); //20091022 修改
    PlayObject.SysMsg(g_sGameCommandChangeJobHumanMsg, c_Green, t_Hint);
    SysMsg(Format_ToStr(g_sGameCommandChangeJobMsg, [sHumanName]), c_Green, t_Hint);
  end else begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;
//改变等级

procedure TPlayObject.CmdChangeLevel(Cmd: pTGameCmd; sParam1: string);
var
  nOLevel: Integer;
  nLevel: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  nLevel := Str_ToInt(sParam1, 1);
  nOLevel := m_Abil.Level;
  m_Abil.Level := _MIN(MAXUPLEVEL, nLevel);
  HasLevelUp(1);
  AddGameDataLog('17' + #9 + m_sMapName + #9 + //等级调整记录日志 20080911
    IntToStr(m_nCurrX) + #9 +
    IntToStr(m_nCurrY) + #9 +
    m_sCharName + #9 +
    IntToStr(m_Abil.Level) + #9 +
    '0' + #9 +
    '=(' + IntToStr(nLevel) + ')' + #9 +
    '0');
  if g_Config.boShowMakeItemMsg then begin
    MainOutMessage(Format_ToStr(g_sGameCommandLevelConsoleMsg, [m_sCharName, nOLevel, m_Abil.Level]));
  end;
end;

procedure TPlayObject.CmdChangeMasterName(Cmd: pTGameCmd; sHumanName, sMasterName, sIsMaster: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (sMasterName = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 师徒名称(如果为 无 则清除)', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    if CompareText(sMasterName, '无') = 0 then begin
      PlayObject.m_sMasterName := '';
      PlayObject.RefShowName;
      PlayObject.m_boMaster := False;
      SysMsg(sHumanName + ' 的师徒名清除成功。', c_Green, t_Hint);
    end else begin
      PlayObject.m_sMasterName := sMasterName;
      if (sIsMaster <> '') and (sIsMaster[1] = '1') then PlayObject.m_boMaster := True
      else PlayObject.m_boMaster := False;
      PlayObject.RefShowName;
      SysMsg(sHumanName + ' 的师徒名更改成功。', c_Green, t_Hint);
    end;
  end else begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdChangeObMode(sCmd: string; nPermission: Integer; sParam1: string; boFlag: Boolean);
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  if boFlag then begin
    SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, ''); //01/21 强行发送刷新数据到客户端，解决GM登录隐身有影子问题
  end;
  m_boObMode := boFlag;
  if m_boObMode then begin
    SysMsg(sObserverMode, c_Green, t_Hint);
  end else SysMsg(g_sReleaseObserverMode, c_Green, t_Hint);
end;

procedure TPlayObject.CmdChangeSabukLord(Cmd: pTGameCmd; sCASTLENAME, sGuildName: string; boFlag: Boolean); //004CFE1C
var
  Guild: TGUild;
  Castle: TUserCastle;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;

  if (sCASTLENAME = '') or (sGuildName = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 城堡名称 行会名称', c_Red, t_Hint);
    Exit;
  end;
  Castle := g_CastleManager.Find(sCASTLENAME);
  if Castle = nil then begin
    SysMsg(Format_ToStr(g_sGameCommandSbkGoldCastleNotFoundMsg, [sCASTLENAME]), c_Red, t_Hint);
    Exit;
  end;

  Guild := g_GuildManager.FindGuild(sGuildName);
  if Guild <> nil then begin
    AddGameDataLog('27' + #9 + Castle.m_sOwnGuild + #9 +
      '0' + #9 + '1' + #9 + 'sGuildName' + #9 + m_sCharName + #9 +
      '0' + #9 + '1' + #9 + '0');
    Castle.GetCastle(Guild);
    {if boFlag then
      UserEngine.SendServerGroupMsg(SS_211, nServerIndex, sGuildName);}//20101022 注释
    SysMsg(Castle.m_sName + ' 所属行会已经更改为 ' + sGuildName, c_Green, t_Hint);
  end else begin
    SysMsg('行会 ' + sGuildName + '还没建立！', c_Red, t_Hint);
  end;
end;
//改变下属状态  20080413

procedure TPlayObject.CmdChangeSalveStatus;
begin
  m_boSlaveRelax := not m_boSlaveRelax;
  if (m_SlaveList.Count > 0) or ((m_MyHero <> nil) and (m_MyHero.m_SlaveList.Count > 0)) then begin
    if (m_boSlaveRelax) then SysMsg(sPetRest, c_Green, t_Hint)
    else SysMsg(sPetAttack, c_Green, t_Hint);
  end;
  if (m_MyHero <> nil) and (m_MyHero.m_SlaveList.Count > 0) then m_MyHero.m_boSlaveRelax := m_boSlaveRelax; //20080409 主人控制英雄宝宝休息
end;

procedure TPlayObject.CmdChangeSuperManMode(sCmd: string; nPermission: Integer; sParam1: string; boFlag: Boolean);
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  m_boSuperMan := boFlag;
  if m_boSuperMan then SysMsg(sSupermanMode, c_Green, t_Hint)
  else SysMsg(sReleaseSupermanMode, c_Green, t_Hint);
end;
//设置服务器最高上线人数

procedure TPlayObject.CmdChangeUserFull(sCmd, sUserCount: string);
var
  nCount: Integer;
begin
  if (m_btPermission < 6) then Exit;
  nCount := Str_ToInt(sUserCount, -1);
  if (sUserCount = '') or (nCount < 1) or ((sUserCount <> '') and (sUserCount[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then begin
      SysMsg('设置服务器最高上线人数。', c_Red, t_Hint);
      SysMsg('命令格式: @' + sCmd + ' 人数', c_Red, t_Hint);
    end;
    Exit;
  end;
  g_Config.nUserFull := nCount;
  SysMsg(Format('服务器上线人数限制: %d', [nCount]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdChangeZenFastStep(sCmd, sFastStep: string);
var
  nFastStep: Integer;
begin
  if (m_btPermission < 6) then Exit;
  nFastStep := Str_ToInt(sFastStep, -1);
  if (sFastStep = '') or (nFastStep < 1) or ((sFastStep <> '') and (sFastStep[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then begin
      SysMsg('设置怪物行动速度。', c_Red, t_Hint);
      SysMsg('命令格式: @' + sCmd + ' 速度', c_Red, t_Hint);
    end;
    Exit;
  end;
  g_Config.nZenFastStep := nFastStep;
  SysMsg(Format('怪物行动速度: %d', [nFastStep]), c_Green, t_Hint);
end;

//清理指定玩家背包物品
procedure TPlayObject.CmdClearBagItem(Cmd: pTGameCmd; sHumanName: string);
var
  I: Integer;
  PlayObject: TPlayObject;
  UserItem: pTUserItem;
  DelList: TStringList;
begin
  DelList := nil;
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, '人物名称']), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject.ClearBagItem; //By TasNat at: 2012-10-17 11:03:10
  {
  try
    PlayObject.m_boOperationItemList := True; //正在操作背包列表 20080928
    if PlayObject.m_ItemList.Count > 0 then begin //20080628
      for I := PlayObject.m_ItemList.Count - 1 downto 0 do begin
        UserItem := PlayObject.m_ItemList.Items[I];
        if DelList = nil then DelList := TStringList.Create;
        DelList.AddObject(UserEngine.GetStdItemName(UserItem.wIndex), TObject(UserItem.MakeIndex));
        Dispose(UserItem);
        PlayObject.m_ItemList.Delete(I); //20080928
      end;
      PlayObject.m_ItemList.Clear;
    end;
    if DelList <> nil then begin
      PlayObject.SendMsg(PlayObject, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
    end;
  finally
    PlayObject.m_boOperationItemList := False; //正在操作背包列表 20080928
  end; }
end;

procedure TPlayObject.CmdClearHumanPassword(sCmd: string; nPermission: Integer; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < nPermission) then Exit;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then begin
      SysMsg('清除玩家的仓库密码！', c_Red, t_Hint);
      SysMsg(Format('命令格式: @%s 人物名称', [sCmd]), c_Red, t_Hint);
    end;
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    Exit;
  end;
  PlayObject.m_boPasswordLocked := False;
  PlayObject.m_boUnLockStoragePwd := False;
  PlayObject.m_sStoragePwd := '';
  PlayObject.SysMsg('您的保护密码已被清除！', c_Green, t_Hint);
  SysMsg(Format('%s的保护密码已被清除！', [sHumanName]), c_Green, t_Hint);
end;
//清除指定地图上的怪物

procedure TPlayObject.CmdClearMapMonster(Cmd: pTGameCmd; sMapName, sMonName, sItems: string);
var
  I, II: Integer;
  MonList: TList;
  Envir: TEnvirnoment;
  nMonCount: Integer;
  boKillAll: Boolean;
  boKillAllMap: Boolean;
  boNotItem: Boolean;
  BaseObject: TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMapName = '') or (sMonName = '') or (sItems = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 地图号(* 为所有) 怪物名称(* 为所有) 掉物品(0,1)', c_Red, t_Hint);
    Exit;
  end;
  boKillAll := False;
  boKillAllMap := False;
  boNotItem := True;
  nMonCount := 0;
  Envir := nil;
  if sMonName = '*' then boKillAll := True;
  if sMapName = '*' then boKillAllMap := True;
  if sItems = '1' then boNotItem := False;

  MonList := TList.Create;
  try
    if boKillAllMap then begin //所有地图
      if g_MapManager.Count > 0 then begin //20091113 增加
        for I := 0 to g_MapManager.Count - 1 do begin
          Envir := TEnvirnoment(g_MapManager.Items[I]);
          if (Envir <> nil) then begin
            UserEngine.GetMapMonster(Envir, MonList);
            if MonList.Count > 0 then begin
              for II := 0 to MonList.Count - 1 do begin
                BaseObject := TBaseObject(MonList.Items[II]);
                if (BaseObject <> nil) then begin
                  if boKillAll or (CompareText(sMonName, BaseObject.m_sCharName) = 0) then begin //20091002 改变位置
                    if (BaseObject.m_Master <> nil) and (BaseObject.m_btRaceServer <> 135)
                      and (BaseObject.m_btRaceServer <> 158) then begin //除135,158怪外，其它宝宝不清除 20110612
                      if (BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT) or
                        (BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT) then Continue;
                    end;
                    BaseObject.m_boNoItem := boNotItem;
                    BaseObject.m_WAbil.HP := 0;
                    BaseObject.MakeGhost; //20110612
                    Inc(nMonCount);
                  end;
                end;
              end; //for
            end;
          end;
        end; //for
      end;
    end else begin
      Envir := g_MapManager.FindMap(sMapName);
      if Envir <> nil then begin
        UserEngine.GetMapMonster(Envir, MonList);
        if MonList.Count > 0 then begin
          for II := 0 to MonList.Count - 1 do begin
            BaseObject := TBaseObject(MonList.Items[II]);
            if (BaseObject <> nil) then begin
              if boKillAll or (CompareText(sMonName, BaseObject.m_sCharName) = 0) then begin //20091002 改变位置
                if (BaseObject.m_Master <> nil) and (BaseObject.m_btRaceServer <> 135)
                  and (BaseObject.m_btRaceServer <> 158) then begin //除135,158怪外，其它宝宝不清除 20110612
                  if (BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT) or
                    (BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT) then Continue;
                end;
                BaseObject.m_boNoItem := boNotItem;
                BaseObject.m_WAbil.HP := 0;
                BaseObject.MakeGhost; //20110612
                Inc(nMonCount);
              end;
            end;
          end; //for
        end;
      end;
    end;
  finally
    MonList.Free;
  end;
  if Envir = nil then begin
    SysMsg('输入的地图不存在！', c_Red, t_Hint);
    Exit;
  end;
  SysMsg('已清除怪物数: ' + IntToStr(nMonCount), c_Red, t_Hint);
end;

procedure TPlayObject.CmdClearMission(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称)', c_Red, t_Hint);
    Exit;
  end;
  if sHumanName[1] = '?' then begin
    SysMsg('此命令用于清除人物的任务标志。', c_Blue, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format('%s不在线，或在其它服务器上！！', [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  FillChar(PlayObject.m_QuestFlag, SizeOf(TQuestFlag), #0);
  SysMsg(Format('%s的任务标志已经全部清零。', [sHumanName]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdContestPoint(Cmd: pTGameCmd; sGuildName: string);
var
  Guild: TGUild;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sGuildName = '') or ((sGuildName <> '') and (sGuildName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then begin
      SysMsg('查看行会战的得分数。', c_Red, t_Hint);
      SysMsg(Format('命令格式: @%s 行会名称', [Cmd.sCmd]), c_Red, t_Hint);
    end;
    Exit;
  end;
  Guild := g_GuildManager.FindGuild(sGuildName);
  if Guild <> nil then begin
    SysMsg(Format('%s 的得分为: %d', [sGuildName, Guild.nContestPoint]), c_Green, t_Hint);
  end else begin
    SysMsg(Format('行会: %s 不存在！', [sGuildName]), c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdStartContest(Cmd: pTGameCmd; sParam1: string);
var
  I, II: Integer;
  List10, List14: TList;
  PlayObject, PlayObjectA: TPlayObject;
  bo19: Boolean;
  s20: string;
  Guild: TGUild;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then begin
      SysMsg('开始行会争霸赛。', c_Red, t_Hint);
      SysMsg(Format('命令格式: @%s', [Cmd.sCmd]), c_Red, t_Hint);
    end;
    Exit;
  end;

  if not m_PEnvir.m_boFight3Zone then begin
    SysMsg('此命令不能在当前地图中使用！', c_Red, t_Hint);
    Exit;
  end;
  List10 := TList.Create;
  List14 := TList.Create;
  try
    UserEngine.GetMapRageHuman(m_PEnvir, m_nCurrX, m_nCurrY, 1000, List10);
    if List10.Count > 0 then begin //20091113 增加
      for I := 0 to List10.Count - 1 do begin
        PlayObject := TPlayObject(List10.Items[I]);
        if not PlayObject.m_boObMode or not PlayObject.m_boAdminMode then begin
          PlayObject.m_nFightZoneDieCount := 0;
          if PlayObject.m_MyGuild = nil then Continue;
          bo19 := False;
          if List14.Count > 0 then begin //20091113 增加
            for II := 0 to List14.Count - 1 do begin
              PlayObjectA := TPlayObject(List14.Items[II]);
              if PlayObject.m_MyGuild = PlayObjectA.m_MyGuild then bo19 := True;
            end;
          end;
          if not bo19 then begin
            List14.Add(PlayObject.m_MyGuild);
          end;
        end;
      end; //for
    end;

    SysMsg('行会争霸赛已经开始。', c_Green, t_Hint);
    UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000, g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, '- 行会战争已爆发。');
    s20 := '';
    if List14.Count > 0 then begin //20091113 增加
      for I := 0 to List14.Count - 1 do begin
        Guild := TGUild(List14.Items[I]);
        Guild.StartTeamFight();
        if List10.Count > 0 then begin //20091113 增加
          for II := 0 to List10.Count - 1 do begin
            PlayObject := TPlayObject(List10.Items[I]);
            if PlayObject.m_MyGuild = Guild then begin
              Guild.AddTeamFightMember(PlayObject.m_sCharName);
            end;
          end;
        end;
        s20 := s20 + Guild.sGuildName + ' ';
      end; //for
    end;

    UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000, g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, ' -参加的门派:' + s20);
  finally
    List10.Free;
    List14.Free;
  end;
end;

procedure TPlayObject.CmdEndContest(Cmd: pTGameCmd; sParam1: string);
var
  I, II: Integer;
  List10, List14: TList;
  PlayObject, PlayObjectA: TPlayObject;
  bo19: Boolean;
//  s20: string;
  Guild: TGUild;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then begin
      SysMsg('结束行会争霸赛。', c_Red, t_Hint);
      SysMsg(Format('命令格式: @%s', [Cmd.sCmd]), c_Red, t_Hint);
    end;
    Exit;
  end;

  if not m_PEnvir.m_boFight3Zone then begin
    SysMsg('此命令不能在当前地图中使用！', c_Red, t_Hint);
    Exit;
  end;
  List10 := TList.Create;
  List14 := TList.Create;
  try
    UserEngine.GetMapRageHuman(m_PEnvir, m_nCurrX, m_nCurrY, 1000, List10);
    if List10.Count > 0 then begin //20091113 增加
      for I := 0 to List10.Count - 1 do begin
        PlayObject := TPlayObject(List10.Items[I]);
        if not PlayObject.m_boObMode or not PlayObject.m_boAdminMode then begin
          if PlayObject.m_MyGuild = nil then Continue;
          bo19 := False;
          if List14.Count > 0 then begin //20091113 增加
            for II := 0 to List14.Count - 1 do begin
              PlayObjectA := TPlayObject(List14.Items[II]);
              if PlayObject.m_MyGuild = PlayObjectA.m_MyGuild then bo19 := True;
            end;
          end;
          if not bo19 then List14.Add(PlayObject.m_MyGuild);
        end;
      end; //for
    end;

    if List14.Count > 0 then begin //20091113 增加
      for I := 0 to List14.Count - 1 do begin
        Guild := TGUild(List14.Items[I]);
        Guild.EndTeamFight();
        UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000, g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, Format(' - %s 行会争霸赛已结束。', [Guild.sGuildName]));
      end;
    end;
  finally
    List10.Free;
    List14.Free;
  end;
end;

procedure TPlayObject.CmdAllowGroupReCall(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    SysMsg('此命令用于允许或禁止编组传送功能。', c_Red, t_Hint);
    Exit;
  end;

  m_boAllowGroupReCall := not m_boAllowGroupReCall;
  if m_boAllowGroupReCall then SysMsg(g_sEnableGroupRecall {'[允许天地合一]'}, c_Green, t_Hint)
  else SysMsg(g_sDisableGroupRecall {'[禁止天地合一]'}, c_Green, t_Hint);
end;

procedure TPlayObject.CmdAnnouncement(Cmd: pTGameCmd; sGuildName: string);
var
  I: Integer;
  Guild: TGUild;
  sHumanName: string;
  nPoint: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sGuildName = '') or ((sGuildName <> '') and (sGuildName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then begin
      SysMsg('查看行会争霸赛结果。', c_Red, t_Hint);
      SysMsg(Format('命令格式: @%s 行会名称', [Cmd.sCmd]), c_Red, t_Hint);
    end;
    Exit;
  end;

  if not m_PEnvir.m_boFight3Zone then begin
    SysMsg('此命令不能在当前地图中使用！', c_Red, t_Hint);
    Exit;
  end;
  Guild := g_GuildManager.FindGuild(sGuildName);
  if Guild <> nil then begin
    UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000, g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, Format(' - %s 行会争霸赛结果: ', [Guild.sGuildName]));
    if Guild.TeamFightDeadList.Count > 0 then begin //20091113 增加
      for I := 0 to Guild.TeamFightDeadList.Count - 1 do begin
        nPoint := Integer(Guild.TeamFightDeadList.Objects[I]);
        sHumanName := Guild.TeamFightDeadList.Strings[I];
        UserEngine.CryCry(RM_CRY,
          m_PEnvir,
          m_nCurrX,
          m_nCurrY,
          1000,
          g_Config.btCryMsgFColor,
          g_Config.btCryMsgBColor,
          Format(' - %s  : %d 分/死亡%d次。 ', [sHumanName, HiWord(nPoint), LoWord(nPoint)]));
      end; //for
    end;
  end;
  UserEngine.CryCry(RM_CRY,
    m_PEnvir,
    m_nCurrX,
    m_nCurrY,
    1000,
    g_Config.btCryMsgFColor,
    g_Config.btCryMsgBColor,
    Format(' - [%s] : %d 分。', [Guild.sGuildName, Guild.nContestPoint]));
  UserEngine.CryCry(RM_CRY,
    m_PEnvir,
    m_nCurrX,
    m_nCurrY,
    1000,
    g_Config.btCryMsgFColor,
    g_Config.btCryMsgBColor,
    '------------------------------------');
end;

procedure TPlayObject.CmdDearRecall(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + sCmd + ' (夫妻传送，将对方传送到自己身边，对方必须允许传送。)', c_Green, t_Hint);
    Exit;
  end;
  if m_sDearName = '' then begin
    SysMsg('您没有结婚！', c_Red, t_Hint);
    Exit;
  end;
  if m_PEnvir.m_boNODEARRECALL then begin
    SysMsg('本地图禁止夫妻传送！', c_Red, t_Hint);
    Exit;
  end;

  if m_DearHuman = nil then begin
    if m_btGender = 0 then begin
      SysMsg('您的老婆不在线！', c_Red, t_Hint);
    end else begin
      SysMsg('您的老公不在线！', c_Red, t_Hint);
    end;
    Exit;
  end;
  if GetTickCount - m_dwDearRecallTick < 10000 then begin
    SysMsg('稍等会才能再次使用此功能！', c_Red, t_Hint);
    Exit;
  end;
  m_dwDearRecallTick := GetTickCount();
  if m_DearHuman.m_boCanDearRecall then begin
    RecallHuman(m_DearHuman.m_sCharName);
  end else begin
    SysMsg(m_DearHuman.m_sCharName + ' 不允许传送！', c_Red, t_Hint);
    Exit;
  end;
end;

procedure TPlayObject.CmdMasterRecall(sCmd, sParam: string);
var
  I: Integer;
  MasterHuman: TPlayObject;
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + sCmd + ' (师徒传送，师父可以将徒弟传送到自己身边，徒弟必须允许传送。)', c_Green, t_Hint);
    Exit;
  end;
  if not m_boMaster then begin
    SysMsg('只能师父才能使用此功能！', c_Red, t_Hint);
    Exit;
  end;
  if m_MasterList.Count = 0 then begin
    SysMsg('您的徒弟一个都不在线！', c_Red, t_Hint);
    Exit;
  end;
  if m_PEnvir.m_boNOMASTERRECALL then begin
    SysMsg('本地图禁止师徒传送！', c_Red, t_Hint);
    Exit;
  end;
  if GetTickCount - m_dwMasterRecallTick < 10000 then begin
    SysMsg('稍等会才能再次使用此功能！', c_Red, t_Hint);
    Exit;
  end;
  if m_MasterList.Count > 0 then begin //20091113 增加
    for I := 0 to m_MasterList.Count - 1 do begin
      MasterHuman := TPlayObject(m_MasterList.Items[I]);
      if MasterHuman.m_boCanMasterRecall then begin
        RecallHuman(MasterHuman.m_sCharName);
      end else begin
        SysMsg(MasterHuman.m_sCharName + ' 不允许传送！', c_Red, t_Hint);
      end;
    end; //for
  end;
end;

procedure TPlayObject.CmdDelBonuPoint(Cmd: pTGameCmd; sHumName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sHumName = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject <> nil then begin
    FillChar(PlayObject.m_BonusAbil, SizeOf(TNakedAbility), #0);
    PlayObject.m_nBonusPoint := 0;
    PlayObject.SendMsg(PlayObject, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    PlayObject.HasLevelUp(0);
    PlayObject.SysMsg('分配点数已清除！', c_Red, t_Hint);
    SysMsg(sHumName + ' 的分配点数已清除.', c_Green, t_Hint);
  end else begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdReNewLevel(Cmd: pTGameCmd; sHumanName, sLevel: string);
var
  PlayObject: TPlayObject;
  nLevel: Integer;
begin
  if (m_btPermission < 6) then Exit;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 点数(为空则查看)', c_Red, t_Hint);
    Exit;
  end;
  nLevel := Str_ToInt(sLevel, -1);
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    if (nLevel >= 0) and (nLevel <= 255) then begin
      PlayObject.m_btReLevel := nLevel;
      PlayObject.RefShowName();
    end;
    SysMsg(sHumanName + ' 的转生等级为 ' + IntToStr(PlayObject.m_btReLevel), c_Green, t_Hint);
  end else begin
    SysMsg(sHumanName + ' 没在线上！', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdRestBonuPoint(Cmd: pTGameCmd; sHumName: string);
var
  PlayObject: TPlayObject;
  nTotleUsePoint: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sHumName = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject <> nil then begin
    nTotleUsePoint := PlayObject.m_BonusAbil.DC +
      PlayObject.m_BonusAbil.MC +
      PlayObject.m_BonusAbil.SC +
      PlayObject.m_BonusAbil.AC +
      PlayObject.m_BonusAbil.MAC +
      PlayObject.m_BonusAbil.HP +
      PlayObject.m_BonusAbil.MP +
      PlayObject.m_BonusAbil.Hit +
      PlayObject.m_BonusAbil.Speed +
      PlayObject.m_BonusAbil.X2;
    FillChar(PlayObject.m_BonusAbil, SizeOf(TNakedAbility), #0);

    Inc(PlayObject.m_nBonusPoint, nTotleUsePoint);
    PlayObject.SendMsg(PlayObject, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    PlayObject.HasLevelUp(0);
    PlayObject.SysMsg('分配点数已复位！', c_Red, t_Hint);
    SysMsg(sHumName + ' 的分配点数已复位。', c_Green, t_Hint);
  end else begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdSearchDear(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    SysMsg('此命令用于查询配偶当前所在位置。', c_Red, t_Hint);
    Exit;
  end;
  if m_sDearName = '' then begin
    SysMsg(g_sYouAreNotMarryedMsg {'你都没结婚查什么？'}, c_Red, t_Hint);
    Exit;
  end;
  if m_DearHuman = nil then begin
    if m_btGender = 0 then begin
      SysMsg(g_sYourWifeNotOnlineMsg {'你的老婆还没有上线！！！'}, c_Red, t_Hint);
    end else begin
      SysMsg(g_sYourHusbandNotOnlineMsg {'你的老公还没有上线！！！'}, c_Red, t_Hint);
    end;
    Exit;
  end;

  if m_btGender = 0 then begin
    if g_sYourWifeNowLocateMsg <> '' then begin
      SysMsg(g_sYourWifeNowLocateMsg {'你的老婆现在位于:'}, c_Green, t_Hint);
      SysMsg(m_DearHuman.m_sCharName + ' ' + m_DearHuman.m_PEnvir.sMapDesc + '(' + IntToStr(m_DearHuman.m_nCurrX) + ':' + IntToStr(m_DearHuman.m_nCurrY) + ')', c_Green, t_Hint);
    end;
    if g_sYourHusbandSearchLocateMsg <> '' then begin
      m_DearHuman.SysMsg(g_sYourHusbandSearchLocateMsg {'你的老公正在找你，他现在位于:'}, c_Green, t_Hint);
      m_DearHuman.SysMsg(m_sCharName + ' ' + m_PEnvir.sMapDesc + '(' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) + ')', c_Green, t_Hint);
    end;
  end else begin
    if g_sYourHusbandNowLocateMsg <> '' then begin
      SysMsg(g_sYourHusbandNowLocateMsg {'你的老公现在位于:'}, c_Red, t_Hint);
      SysMsg(m_DearHuman.m_sCharName + ' ' + m_DearHuman.m_PEnvir.sMapDesc + '(' + IntToStr(m_DearHuman.m_nCurrX) + ':' + IntToStr(m_DearHuman.m_nCurrY) + ')', c_Green, t_Hint);
    end;
    if g_sYourWifeSearchLocateMsg <> '' then begin
      m_DearHuman.SysMsg(g_sYourWifeSearchLocateMsg {'你的老婆正在找你，她现在位于:'}, c_Green, t_Hint);
      m_DearHuman.SysMsg(m_sCharName + ' ' + m_PEnvir.sMapDesc + '(' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) + ')', c_Green, t_Hint);
    end;
  end;
end;

procedure TPlayObject.CmdSearchMaster(sCmd, sParam: string);
var
  I: Integer;
  Human: TPlayObject;
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    SysMsg('此命令用于查询师徒当前所在位置。', c_Red, t_Hint);
    Exit;
  end;
  if m_sMasterName = '' then begin
    SysMsg(g_sYouAreNotMasterMsg, c_Red, t_Hint);
    Exit;
  end;
  if m_boMaster then begin
    if m_MasterList.Count <= 0 then begin
      SysMsg(g_sYourMasterListNotOnlineMsg, c_Red, t_Hint);
      Exit;
    end;
    if g_sYourMasterListNowLocateMsg <> '' then begin
      SysMsg(g_sYourMasterListNowLocateMsg, c_Green, t_Hint);
      if m_MasterList.Count > 0 then begin //20091113 增加
        for I := 0 to m_MasterList.Count - 1 do begin
          Human := TPlayObject(m_MasterList.Items[I]);
          SysMsg(Human.m_sCharName + ' ' + Human.m_PEnvir.sMapDesc + '(' + IntToStr(Human.m_nCurrX) + ':' + IntToStr(Human.m_nCurrY) + ')', c_Green, t_Hint);
          if g_sYourMasterSearchLocateMsg <> '' then begin
            Human.SysMsg(g_sYourMasterSearchLocateMsg, c_Green, t_Hint);
            Human.SysMsg(m_sCharName + ' ' + m_PEnvir.sMapDesc + '(' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) + ')', c_Green, t_Hint);
          end;
        end;
      end;
    end;
  end else begin
    if m_MasterHuman = nil then begin
      SysMsg(g_sYourMasterNotOnlineMsg, c_Red, t_Hint);
      Exit;
    end;
    if g_sYourMasterNowLocateMsg <> '' then begin
      SysMsg(g_sYourMasterNowLocateMsg, c_Red, t_Hint);
      SysMsg(m_MasterHuman.m_sCharName + ' ' + m_MasterHuman.m_PEnvir.sMapDesc + '(' + IntToStr(m_MasterHuman.m_nCurrX) + ':' + IntToStr(m_MasterHuman.m_nCurrY) + ')', c_Green, t_Hint);
    end;
    if g_sYourMasterListSearchLocateMsg <> '' then begin
      m_MasterHuman.SysMsg(g_sYourMasterListSearchLocateMsg, c_Green, t_Hint);
      m_MasterHuman.SysMsg(m_sCharName + ' ' + m_PEnvir.sMapDesc + '(' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) + ')', c_Green, t_Hint);
    end;
  end;
end;

procedure TPlayObject.CmdSetPermission(Cmd: pTGameCmd; sHumanName, sPermission: string);
var
  nPerission: Integer;
  PlayObject: TPlayObject;
resourcestring
  sOutFormatMsg = '[权限调整] %s (%s %d -> %d)';
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  nPerission := Str_ToInt(sPermission, 0);
  if (sHumanName = '') or not (nPerission in [0..10]) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 权限等级(0 - 10)', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  if g_Config.boShowMakeItemMsg then
    MainOutMessage(Format_ToStr(sOutFormatMsg, [m_sCharName, PlayObject.m_sCharName, PlayObject.m_btPermission, nPerission]));
  PlayObject.m_btPermission := nPerission;
  SysMsg(sHumanName + ' 当前权限为: ' + IntToStr(PlayObject.m_btPermission), c_Red, t_Hint);
end;

procedure TPlayObject.CmdShowHumanFlag(sCmd: string; nPermission: Integer;
  sHumanName, sFlag: string);
var
  PlayObject: TPlayObject;
  nFlag: Integer;
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandShowHumanFlagHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  nFlag := Str_ToInt(sFlag, 0);
  if PlayObject.GetQuestFalgStatus(nFlag) = 1 then begin
    SysMsg(Format_ToStr(g_sGameCommandShowHumanFlagONMsg, [PlayObject.m_sCharName, nFlag]), c_Green, t_Hint);
  end else begin
    SysMsg(Format_ToStr(g_sGameCommandShowHumanFlagOFFMsg, [PlayObject.m_sCharName, nFlag]), c_Green, t_Hint);
  end;
end;

{procedure TPlayObject.CmdShowHumanUnit(sCmd: string; nPermission: Integer;
  sHumanName, sUnit: string);
//var
//  PlayObject: TPlayObject;
//  nUnit: Integer;
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandShowHumanUnitHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  nUnit := Str_ToInt(sUnit, 0);
  if PlayObject.GetQuestUnitStatus(nUnit) = 1 then begin
    SysMsg(format(g_sGameCommandShowHumanUnitONMsg, [PlayObject.m_sCharName, nUnit]), c_Green, t_Hint);
  end else begin
    SysMsg(format(g_sGameCommandShowHumanUnitOFFMsg, [PlayObject.m_sCharName, nUnit]), c_Green, t_Hint);
  end;
end; }

{procedure TPlayObject.CmdShowHumanUnitOpen(sCmd: string; nPermission: Integer;
  sHumanName, sUnit: string);
//var
//  PlayObject: TPlayObject;
//  nUnit: Integer;
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandShowHumanUnitHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  nUnit := Str_ToInt(sUnit, 0);
  if PlayObject.GetQuestUnitOpenStatus(nUnit) = 1 then begin
    SysMsg(format(g_sGameCommandShowHumanUnitONMsg, [PlayObject.m_sCharName, nUnit]), c_Green, t_Hint);
  end else begin
    SysMsg(format(g_sGameCommandShowHumanUnitOFFMsg, [PlayObject.m_sCharName, nUnit]), c_Green, t_Hint);
  end;
end;  }

procedure TPlayObject.CmdShowMapInfo(Cmd: pTGameCmd; sParam1: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  SysMsg(Format_ToStr(g_sGameCommandMapInfoMsg, [m_PEnvir.sMapName, m_PEnvir.sMapDesc]), c_Green, t_Hint);
  SysMsg(Format_ToStr(g_sGameCommandMapInfoSizeMsg, [m_PEnvir.m_nWidth, m_PEnvir.m_nHeight]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdShowMapMode(sCmd, sMapName: string);
var
  Envir: TEnvirnoment;
  sMsg: string;
begin
  if (m_btPermission < 6) then Exit;
  if (sMapName = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + sCmd + ' 地图号', c_Red, t_Hint);
    Exit;
  end;
  Envir := g_MapManager.FindMap(sMapName);
  if (Envir = nil) then begin
    SysMsg(sMapName + ' 不存在！', c_Red, t_Hint);
    Exit;
  end;
  sMsg := '地图模式: ' + Envir.GetEnvirInfo;
  SysMsg(sMsg, c_Blue, t_Hint);
end;

procedure TPlayObject.CmdSetMapMode(sCmd, sMapName, sMapMode, sParam1, sParam2: string);
var
  Envir: TEnvirnoment;
  sMsg: string;
begin
  if (m_btPermission < 6) then Exit;
  if (sMapName = '') or (sMapMode = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + sCmd + ' 地图号 模式', c_Red, t_Hint);
    Exit;
  end;
  Envir := g_MapManager.FindMap(sMapName);
  if (Envir = nil) then begin
    SysMsg(sMapName + ' 不存在！', c_Red, t_Hint);
    Exit;
  end;
  if CompareText(sMapMode, 'SAFE') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.m_boSAFE := True;
    end else begin
      Envir.m_boSAFE := False;
    end;
  end else
    if CompareText(sMapMode, 'SAFEHERONORUN') = 0 then begin //英雄安全区不能穿 20090525
      if (sParam1 <> '') then begin
        Envir.m_boSAFEHERONORUN := True;
      end else begin
        Envir.m_boSAFEHERONORUN := False;
      end;
    end else
      if CompareText(sMapMode, 'DARK') = 0 then begin
        if (sParam1 <> '') then begin
          Envir.m_boDARK := True;
        end else begin
          Envir.m_boDARK := False;
        end;
      end else
        if CompareText(sMapMode, 'DARK') = 0 then begin
          if (sParam1 <> '') then begin
            Envir.m_boDARK := True;
          end else begin
            Envir.m_boDARK := False;
          end;
        end else
          if CompareText(sMapMode, 'FIGHT') = 0 then begin
            if (sParam1 <> '') then begin
              Envir.m_boFightZone := True;
            end else begin
              Envir.m_boFightZone := False;
            end;
          end else
            if CompareText(sMapMode, 'FIGHT2') = 0 then begin //PK掉装备地图 20080525
              if (sParam1 <> '') then begin
                Envir.m_boFight2Zone := True;
              end else begin
                Envir.m_boFight2Zone := False;
              end;
            end else
              if CompareText(sMapMode, 'FIGHT3') = 0 then begin
                if (sParam1 <> '') then begin
                  Envir.m_boFight3Zone := True;
                end else begin
                  Envir.m_boFight3Zone := False;
                end;
              end else
                if CompareText(sMapMode, 'FIGHT4') = 0 then begin //挑战地图 20080706
                  if (sParam1 <> '') then begin
                    Envir.m_boFight4Zone := True;
                  end else begin
                    Envir.m_boFight4Zone := False;
                  end;
                end else
                  if CompareText(sMapMode, 'FIGHT5') = 0 then begin //不同行会名字变不同颜色 20090318
                    if (sParam1 <> '') then begin
                      Envir.m_boFight5Zone := True;
                    end else begin
                      Envir.m_boFight5Zone := False;
                    end;
                  end else
                    if CompareText(sMapMode, 'NOFIGHT4') = 0 then begin //禁止挑战地图
                      if (sParam1 <> '') then begin
                        Envir.m_boNoFight4Zone := True;
                      end else begin
                        Envir.m_boNoFight4Zone := False;
                      end;
                    end else
                      if CompareText(sMapMode, 'DAY') = 0 then begin
                        if (sParam1 <> '') then begin
                          Envir.m_boDAY := True;
                        end else begin
                          Envir.m_boDAY := False;
                        end;
                      end else
                        if CompareText(sMapMode, 'QUIZ') = 0 then begin
                          if (sParam1 <> '') then begin
                            Envir.m_boQUIZ := True;
                          end else begin
                            Envir.m_boQUIZ := False;
                          end;
                        end else
                          if CompareText(sMapMode, 'NORECONNECT') = 0 then begin
                            if (sParam1 <> '') then begin
                              Envir.m_boNORECONNECT := True;
                              Envir.sNoReconnectMap := sParam1;
                            end else begin
                              Envir.m_boNORECONNECT := False;
                            end;
                          end else
                            if CompareText(sMapMode, 'MUSIC') = 0 then begin
                              if (sParam1 <> '') then begin
                                Envir.m_boMUSIC := True;
                                Envir.m_nMUSICID := Str_ToInt(sParam1, -1);
                              end else begin
                                Envir.m_boMUSIC := False;
                              end;
                            end else
                              if CompareText(sMapMode, 'EXPRATE') = 0 then begin
                                if (sParam1 <> '') then begin
                                  Envir.m_boEXPRATE := True;
                                  Envir.m_nEXPRATE := Str_ToInt(sParam1, -1);
                                end else begin
                                  Envir.m_boEXPRATE := False;
                                end;
                              end else
                                if CompareText(sMapMode, 'PULSEXPRATE') = 0 then begin //地图杀怪英雄经验倍数 20091029
                                  if (sParam1 <> '') then begin
                                    Envir.m_boPULSEXPRATE := True;
                                    Envir.m_nPULSEXPRATE := Str_ToInt(sParam1, -1);
                                  end else begin
                                    Envir.m_boPULSEXPRATE := False;
                                  end;
                                end else
                                  if CompareText(sMapMode, 'NGEXPRATE') = 0 then begin //地图杀怪内功经验倍数 20091029
                                    if (sParam1 <> '') then begin
                                      Envir.m_boNGEXPRATE := True;
                                      Envir.m_nNGEXPRATE := Str_ToInt(sParam1, -1);
                                    end else begin
                                      Envir.m_boNGEXPRATE := False;
                                    end;
                                  end else
                                    if CompareText(sMapMode, 'DECEXPRATETIME') = 0 then begin //减双倍经验时间 20090206
                                      if (sParam1 <> '') then begin
                                        Envir.m_boDECEXPRATETIME := True;
                                        Envir.m_nDECEXPRATETIME := Str_ToInt(sParam1, 1);
                                      end else begin
                                        Envir.m_boDECEXPRATETIME := False;
                                      end;
                                    end else
                                      if CompareText(sMapMode, 'PKWINLEVEL') = 0 then begin
                                        if (sParam1 <> '') then begin
                                          Envir.m_boPKWINLEVEL := True;
                                          Envir.m_nPKWINLEVEL := Str_ToInt(sParam1, -1);
                                        end else begin
                                          Envir.m_boPKWINLEVEL := False;
                                        end;
                                      end else
                                        if CompareText(sMapMode, 'PKWINEXP') = 0 then begin
                                          if (sParam1 <> '') then begin
                                            Envir.m_boPKWINEXP := True;
                                            Envir.m_nPKWINEXP := Str_ToInt(sParam1, -1);
                                          end else begin
                                            Envir.m_boPKWINEXP := False;
                                          end;
                                        end else
                                          if CompareText(sMapMode, 'PKLOSTLEVEL') = 0 then begin
                                            if (sParam1 <> '') then begin
                                              Envir.m_boPKLOSTLEVEL := True;
                                              Envir.m_nPKLOSTLEVEL := Str_ToInt(sParam1, -1);
                                            end else begin
                                              Envir.m_boPKLOSTLEVEL := False;
                                            end;
                                          end else
                                            if CompareText(sMapMode, 'PKLOSTEXP') = 0 then begin
                                              if (sParam1 <> '') then begin
                                                Envir.m_boPKLOSTEXP := True;
                                                Envir.m_nPKLOSTEXP := Str_ToInt(sParam1, -1);
                                              end else begin
                                                Envir.m_boPKLOSTEXP := False;
                                              end;
                                            end else
                                              if CompareText(sMapMode, 'DECHP') = 0 then begin
                                                if (sParam1 <> '') and (sParam2 <> '') then begin
                                                  Envir.m_boDECHP := True;
                                                  Envir.m_nDECHPTIME := Str_ToInt(sParam1, -1);
                                                  Envir.m_nDECHPPOINT := Str_ToInt(sParam2, -1);
                                                end else begin
                                                  Envir.m_boDECHP := False;
                                                end;
                                              end else
                                                if CompareText(sMapMode, 'DECGAMEGOLD') = 0 then begin
                                                  if (sParam1 <> '') and (sParam2 <> '') then begin
                                                    Envir.m_boDecGameGold := True;
                                                    Envir.m_nDECGAMEGOLDTIME := Str_ToInt(sParam1, -1);
                                                    Envir.m_nDecGameGold := Str_ToInt(sParam2, -1);
                                                  end else begin
                                                    Envir.m_boDecGameGold := False;
                                                  end;
                                                end else
                                                  if CompareText(sMapMode, 'KILLFUNC') = 0 then begin //20080415 地图杀人触发
                                                    if (sParam1 <> '') then begin
                                                      Envir.m_boKILLFUNC := True;
                                                      Envir.m_nKILLFUNC := Str_ToInt(sParam1, -1);
                                                    end else begin
                                                      Envir.m_boKILLFUNC := False;
                                                    end;
                                                  end else
                                                    if CompareText(sMapMode, 'INCGAMEGOLD') = 0 then begin
                                                      if (sParam1 <> '') and (sParam2 <> '') then begin
                                                        Envir.m_boIncGameGold := True;
                                                        Envir.m_nINCGAMEGOLDTIME := Str_ToInt(sParam1, -1);
                                                        Envir.m_nIncGameGold := Str_ToInt(sParam2, -1);
                                                      end else begin
                                                        Envir.m_boIncGameGold := False;
                                                      end;
                                                    end else
                                                      if CompareText(sMapMode, 'INCGAMEPOINT') = 0 then begin
                                                        if (sParam1 <> '') and (sParam2 <> '') then begin
                                                          Envir.m_boINCGAMEPOINT := True;
                                                          Envir.m_nINCGAMEPOINTTIME := Str_ToInt(sParam1, -1);
                                                          Envir.m_nINCGAMEPOINT := Str_ToInt(sParam2, -1);
                                                        end else begin
                                                          Envir.m_boINCGAMEPOINT := False;
                                                        end;
                                                      end else
//------------------------------------------------------------------------------
                                                        if CompareText(sMapMode, 'NEEDLEVELTIME') = 0 then begin //雪域地图传送,判断等级,地图时间 20081228
                                                          if (sParam1 <> '') and (sParam2 <> '') then begin
                                                            Envir.m_boNEEDLEVELTIME := True;
                                                            Envir.m_nNEEDLEVELPOINT := Str_ToInt(sParam1, 0); //进地图最低等级
                                                          end else begin
                                                            Envir.m_boNEEDLEVELTIME := False;
                                                          end;
                                                        end else
//20080124 禁止召唤英雄
                                                          if CompareText(sMapMode, 'NOCALLHERO') = 0 then begin
                                                            if (sParam1 <> '') then begin
                                                              Envir.m_boNOCALLHERO := True;
        //MainOutMessage('AA NOCALLHERO True');
                                                            end else begin
                                                              Envir.m_boNOCALLHERO := False;
                                                            end;
                                                          end else
//禁止英雄守护 20080629
                                                            if CompareText(sMapMode, 'NOHEROPROTECT') = 0 then begin
                                                              if (sParam1 <> '') then begin
                                                                Envir.m_boNOHEROPROTECT := True;
                                                              end else begin
                                                                Envir.m_boNOHEROPROTECT := False;
                                                              end;
                                                            end else
//20080503 禁止死亡掉物品
                                                              if CompareText(sMapMode, 'NODROPITEM') = 0 then begin
                                                                if (sParam1 <> '') then begin
                                                                  Envir.m_boNODROPITEM := True;
                                                                end else begin
                                                                  Envir.m_boNODROPITEM := False;
                                                                end;
                                                              end else
//20080124 不允许使用任何物品和技能
                                                                if CompareText(sMapMode, 'MISSION') = 0 then begin
                                                                  if (sParam1 <> '') then begin
                                                                    Envir.m_boMISSION := True;
                                                                  end else begin
                                                                    Envir.m_boMISSION := False;
                                                                  end;
//------------------------------------------------------------------------------
                                                                end else
                                                                  if CompareText(sMapMode, 'RUNHUMAN') = 0 then begin
                                                                    if (sParam1 <> '') then begin
                                                                      Envir.m_boRUNHUMAN := True;
                                                                    end else begin
                                                                      Envir.m_boRUNHUMAN := False;
                                                                    end;
                                                                  end else
                                                                    if CompareText(sMapMode, 'RUNMON') = 0 then begin
                                                                      if (sParam1 <> '') then begin
                                                                        Envir.m_boRUNMON := True;
                                                                      end else begin
                                                                        Envir.m_boRUNMON := False;
                                                                      end;
                                                                    end else
                                                                      if CompareText(sMapMode, 'NEEDHOLE') = 0 then begin
                                                                        if (sParam1 <> '') then begin
                                                                          Envir.m_boNEEDHOLE := True;
                                                                        end else begin
                                                                          Envir.m_boNEEDHOLE := False;
                                                                        end;
                                                                      end else
                                                                        if CompareText(sMapMode, 'NORECALL') = 0 then begin
                                                                          if (sParam1 <> '') then begin
                                                                            Envir.m_boNORECALL := True;
                                                                          end else begin
                                                                            Envir.m_boNORECALL := False;
                                                                          end;
                                                                        end else
                                                                          if CompareText(sMapMode, 'NOGUILDRECALL') = 0 then begin
                                                                            if (sParam1 <> '') then begin
                                                                              Envir.m_boNOGUILDRECALL := True;
                                                                            end else begin
                                                                              Envir.m_boNOGUILDRECALL := False;
                                                                            end;
                                                                          end else
                                                                            if CompareText(sMapMode, 'NODEARRECALL') = 0 then begin
                                                                              if (sParam1 <> '') then begin
                                                                                Envir.m_boNODEARRECALL := True;
                                                                              end else begin
                                                                                Envir.m_boNODEARRECALL := False;
                                                                              end;
                                                                            end else
                                                                              if CompareText(sMapMode, 'NOMASTERRECALL') = 0 then begin
                                                                                if (sParam1 <> '') then begin
                                                                                  Envir.m_boNOMASTERRECALL := True;
                                                                                end else begin
                                                                                  Envir.m_boNOMASTERRECALL := False;
                                                                                end;
                                                                              end else
                                                                                if CompareText(sMapMode, 'NORANDOMMOVE') = 0 then begin
                                                                                  if (sParam1 <> '') then begin
                                                                                    Envir.m_boNORANDOMMOVE := True;
                                                                                  end else begin
                                                                                    Envir.m_boNORANDOMMOVE := False;
                                                                                  end;
                                                                                end else
                                                                                  if CompareText(sMapMode, 'NODRUG') = 0 then begin
                                                                                    if (sParam1 <> '') then begin
                                                                                      Envir.m_boNODRUG := True;
                                                                                    end else begin
                                                                                      Envir.m_boNODRUG := False;
                                                                                    end;
                                                                                  end else
                                                                                    if CompareText(sMapMode, 'MINE') = 0 then begin
                                                                                      if (sParam1 <> '') then begin
                                                                                        Envir.m_boMINE := True;
                                                                                      end else begin
                                                                                        Envir.m_boMINE := False;
                                                                                      end;
                                                                                    end else
                                                                                      if CompareText(sMapMode, 'JEWEL') = 0 then begin
                                                                                        if (sParam1 <> '') then begin
                                                                                          Envir.m_boDigJewel := True;
                                                                                        end else begin
                                                                                          Envir.m_boDigJewel := False;
                                                                                        end;
                                                                                      end else
                                                                                        if CompareText(sMapMode, 'SHOP') = 0 then begin
                                                                                          if (sParam1 <> '') then begin
                                                                                            Envir.m_boSHOP := True;
                                                                                          end else begin
                                                                                            Envir.m_boSHOP := False;
                                                                                          end;
                                                                                        end else
                                                                                          if CompareText(sMapMode, 'NOPOSITIONMOVE') = 0 then begin
                                                                                            if (sParam1 <> '') then begin
                                                                                              Envir.m_boNOPOSITIONMOVE := True;
                                                                                            end else begin
                                                                                              Envir.m_boNOPOSITIONMOVE := False;
                                                                                            end;
                                                                                          end;
  sMsg := '地图模式: ' + Envir.GetEnvirInfo;
  SysMsg(sMsg, c_Blue, t_Hint);
  MainOutMessage(Format('%s 设置地图参数(%s %s %s %s)', [m_sCharName, sMapName, sMapMode, sParam1, sParam2]));
end;

procedure TPlayObject.CmdSignMapMove(Cmd: pTGameCmd);
var
  Envir: TEnvirnoment;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      Exit;
    end;
    if (m_btPermission >= Cmd.nPermissionMax) or CanMoveMap(m_sLastMapName) then begin
      Envir := g_MapManager.FindMap(m_sLastMapName);
      if Envir <> nil then begin
        if Envir.CanWalk(m_nLastCurrX, m_nLastCurrY, True) then begin
          SpaceMove(m_sLastMapName, m_nLastCurrX, m_nLastCurrY, 0);
        end else begin
          SysMsg(Format_ToStr(g_sGameCommandPositionMoveCanotMoveToMap1, [m_sLastMapName, m_nLastCurrX, m_nLastCurrY]), c_Green, t_Hint);
        end;
      end;
    end else begin
      SysMsg(Format_ToStr(g_sTheMapDisableMove, [m_sLastMapName, Envir.sMapDesc]), c_Red, t_Hint);
    end;
  except
      MainOutMessage(Format('{%s} TPlayObject.CmdPositionMove %p', [g_sExceptionVer , ExceptAddr]));

  end;
end;
//清理指定玩家复制品 20080816

procedure TPlayObject.CmdClearCopyItem(Cmd: pTGameCmd; sName: string);
var
  I, II: Integer;
  PlayObject: TPlayObject;
  UserItem, UserItem1: pTUserItem;
  s14: string;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sName = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sName]), c_Red, t_Hint);
    Exit;
  end;

  for I := PlayObject.m_ItemList.Count - 1 downto 0 do begin
    if PlayObject.m_ItemList.Count <= 0 then Break;
    UserItem := PlayObject.m_ItemList.Items[I];
    s14 := UserEngine.GetStdItemName(UserItem.wIndex);
    for II := I - 1 downto 0 do begin
      UserItem1 := PlayObject.m_ItemList.Items[II];
      if (UserEngine.GetStdItemName(UserItem1.wIndex) = s14) and
        (UserItem.MakeIndex = UserItem1.MakeIndex) then begin
        m_ItemList.Delete(II);
        Break;
      end;
    end;
  end;

  for I := PlayObject.m_StorageItemList.Count - 1 downto 0 do begin
    if PlayObject.m_StorageItemList.Count <= 0 then Break;
    UserItem := PlayObject.m_StorageItemList.Items[I];
    s14 := UserEngine.GetStdItemName(UserItem.wIndex);
    for II := I - 1 downto 0 do begin
      UserItem1 := PlayObject.m_StorageItemList.Items[II];
      if (UserEngine.GetStdItemName(UserItem1.wIndex) = s14) and
        (UserItem.MakeIndex = UserItem1.MakeIndex) then begin
        m_StorageItemList.Delete(II);
        Break;
      end;
    end;
  end;
end;
//放烟花

procedure TPlayObject.CmdShowEffect(Cmd: pTGameCmd; sEffect {, sTime}: string);
var
  nEffectType: Integer;
// nTime: Integer;
  FlowerEvent: TFlowerEvent;
  //SafeEvent: TSafeEvent;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sEffect = '') or (Str_ToInt(sEffect, -1) <= 0) {or (sTime = '')} then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 烟花类型(79-85)', c_Red, t_Hint);
    Exit;
  end;
  nEffectType := Str_ToInt(sEffect, -1);
 // nTime := Str_ToInt(sTime, 1);
  case nEffectType of
    //1..78: SafeEvent := TSafeEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, nEffectType);
    79: FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_FIREFLOWER_1, 4000 {* nTime});
    80: FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_FIREFLOWER_2, 4000 {* nTime});
    81: FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_FIREFLOWER_3, 4000 {* nTime});
    82: FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_FIREFLOWER_4, 4000 {* nTime});
    83: FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_FIREFLOWER_5, 4000 {* nTime});
    84: FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_FIREFLOWER_6, 4000 {* nTime});
    85: FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_FIREFLOWER_7, 4000 {* nTime}); //20080312 如梦似雾烟花
    87: SendRefMsg(RM_MYSHOW, ET_PROTECTION_STRUCK, 0, 0, 0, ''); //护体神盾  受攻击
    89: SendRefMsg(RM_MYSHOW, ET_PROTECTION_PIP, 0, 0, 0, ''); //护体神盾  破盾
    90: SendRefMsg(RM_MYSHOW, ET_OBJECTLEVELUP, 0, 0, 0, ''); //人物升级动画
  //else FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_FIREFLOWER_1, 4000 {* nTime});
  end;
  case nEffectType of
    //1..78: g_EventManager.AddEvent(SafeEvent);
    79..85: g_EventManager.AddEvent(FlowerEvent);
  end;
end;
//取玩家物品(背包,仓库)

procedure TPlayObject.CmdGetUserItems(Cmd: pTGameCmd; sHumanName, sItemName, sItemCount, sType: string);
var
  I: Integer;
  PlayObject: TPlayObject;
  nItemCount: Integer;
  nCount: Integer;
  nType: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (sItemName = '') or (sItemCount = '') or (sType = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 物品名称 数量 类型(0,1,2)', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  nCount := Str_ToInt(sItemCount, 0);
  nType := Str_ToInt(sType, 0);
  case nType of
    0: begin
        nItemCount := 0;
        for I := Low(PlayObject.m_UseItems) to High(PlayObject.m_UseItems) do begin
          UserItem := @PlayObject.m_UseItems[I];
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) then begin
            if (CompareText(sItemName, StdItem.Name) = 0) then begin
              New(UserItem);
              FillChar(UserItem^, SizeOf(TUserItem), #0); //20080820 增加
              //FillChar(UserItem^.btValue, SizeOf(UserItem^.btValue), 0);//20080820 增加
              UserItem^ := PlayObject.m_UseItems[I];
              m_ItemList.Add(UserItem);
              SendAddItem(UserItem);
              PlayObject.m_UseItems[I].wIndex := 0;
              Inc(nItemCount);
              if m_ItemList.Count >= 46 then Break;
              if nItemCount >= nCount then Break;
            end;
          end;
        end;
        PlayObject.SendUseitems();
      end;
    1: begin
        nItemCount := 0;
        for I := PlayObject.m_ItemList.Count - 1 downto 0 do begin
          if PlayObject.m_ItemList.Count <= 0 then Break;
          UserItem := PlayObject.m_ItemList.Items[I];
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) then begin
            if (CompareText(sItemName, StdItem.Name) = 0) then begin
              PlayObject.SendDelItems(UserItem);
              PlayObject.m_ItemList.Delete(I);
              m_ItemList.Add(UserItem);
              SendAddItem(UserItem);
              Inc(nItemCount);
              if m_ItemList.Count >= 46 then Break;
              if nItemCount >= nCount then Break;
            end;
          end;
        end;
      end;
    2: begin
        nItemCount := 0;
        for I := PlayObject.m_StorageItemList.Count - 1 downto 0 do begin
          if PlayObject.m_StorageItemList.Count <= 0 then Break;
          UserItem := PlayObject.m_StorageItemList.Items[I];
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) then begin
            if (CompareText(sItemName, StdItem.Name) = 0) then begin
              PlayObject.m_StorageItemList.Delete(I);
              m_ItemList.Add(UserItem);
              SendAddItem(UserItem);
              Inc(nItemCount);
              if m_ItemList.Count >= 46 then Break;
              if nItemCount >= nCount then Break;
            end;
          end;
        end;
      end;
  end;
end;

procedure TPlayObject.CmdDeleteItem(Cmd: pTGameCmd; sHumanName, sItemName: string; nCount: Integer);
var
  I: Integer;
  PlayObject: TPlayObject;
  nItemCount: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (sItemName = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 物品名称 数量)', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  nItemCount := 0;
  for I := PlayObject.m_ItemList.Count - 1 downto 0 do begin
    if PlayObject.m_ItemList.Count <= 0 then Break;
    UserItem := PlayObject.m_ItemList.Items[I];
    if UserItem = nil then Continue;
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if (StdItem <> nil) and (CompareText(sItemName, StdItem.Name) = 0) then begin
      PlayObject.SendDelItems(UserItem);
      PlayObject.m_ItemList.Delete(I);
      Dispose(UserItem);
      Inc(nItemCount);
      if nItemCount >= nCount then Break;
    end;
  end;
end;

procedure TPlayObject.CmdDelGold(Cmd: pTGameCmd; sHumName: string; nCount: Integer);
var
  PlayObject: TPlayObject;
//  nServerIndex: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumName = '') or (nCount <= 0) then Exit;
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject <> nil then begin
    if PlayObject.m_nGold > nCount then begin
      Dec(PlayObject.m_nGold, nCount);
    end else begin
      nCount := PlayObject.m_nGold;
      PlayObject.m_nGold := 0;
    end;
    PlayObject.GoldChanged();
    SysMsg(sHumName + '的金币已减少' + IntToStr(nCount) + '.', c_Green, t_Hint);
    if g_boGameLogGold then
      AddGameDataLog('13' + #9 +
        m_sMapName + #9 +
        IntToStr(m_nCurrX) + #9 +
        IntToStr(m_nCurrY) + #9 +
        m_sCharName + #9 +
        sSTRING_GOLDNAME + #9 +
        IntToStr(nCount) + #9 +
        '1' + #9 +
        sHumName);
  end else begin
    {if UserEngine.FindOtherServerUser(sHumName, nServerIndex) then begin//20101022 注释
      SysMsg(sHumName + '现在' + IntToStr(nServerIndex) + '号服务器上', c_Green, t_Hint);
    end else begin}
    FrontEngine.AddChangeGoldList(m_sCharName, sHumName, -nCount);
    SysMsg(sHumName + '现在不在线，等其上线时金币将自动减少', c_Green, t_Hint);
    //end;
  end;
end;

procedure TPlayObject.CmdDelGuild(Cmd: pTGameCmd; sGuildName: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if nServerIndex <> 0 then begin
    SysMsg('只能在主服务器上才可以使用此命令删除行会！', c_Red, t_Hint);
    Exit;
  end;
  if sGuildName = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 行会名称', c_Red, t_Hint);
    Exit;
  end;
  if g_GuildManager.DELGUILD(sGuildName) then begin
    //UserEngine.SendServerGroupMsg(SS_206, nServerIndex, sGuildName);//20101022 注释
  end else begin
    SysMsg('没找到' + sGuildName + '这个行会！', c_Red, t_Hint);
  end;
end;
//删除NPC

procedure TPlayObject.CmdDelNpc(sCmd: string; nPermission: Integer; sParam1, sParam2, sParam3, sParam4: string);
var
  BaseObject: TBaseObject;
  I, nX, nY: Integer;
  MerchantNPC: TMerchant;
  NPC: TNormNpc;
resourcestring
  sDelOK = '删除NPC成功...';
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [sCmd, 'NPC名称 地图 X Y']), c_Red, t_Hint);
    Exit;
  end;
  if (sParam1 <> '') and (sParam2 <> '') and (sParam3 <> '') and (sParam4 <> '') then begin
    nX := Str_ToInt(sParam3, 0);
    nY := Str_ToInt(sParam4, 0);
    if UserEngine.m_MerchantList.Count > 0 then begin
      for I := 0 to UserEngine.m_MerchantList.Count - 1 do begin
        MerchantNPC := UserEngine.m_MerchantList.Items[I];
        if (CompareText(MerchantNPC.m_sCharName, sParam1) = 0) and
          (CompareText(MerchantNPC.m_sMapName, sParam2) = 0) and
          (MerchantNPC.m_nCurrX = nX) and (MerchantNPC.m_nCurrY = nY) then begin
          MerchantNPC.m_boGhost := True;
          MerchantNPC.SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, '');
          SysMsg(sDelOK, c_Red, t_Hint);
          Exit;
        end;
      end; //for
    end;
    if UserEngine.QuestNPCList.Count > 0 then begin //20091113 增加
      for I := 0 to UserEngine.QuestNPCList.Count - 1 do begin
        NPC := UserEngine.QuestNPCList.Items[I];
        if (CompareText(NPC.m_sCharName, sParam1) = 0) and
          (CompareText(NPC.m_sMapName, sParam2) = 0) and
          (NPC.m_nCurrX = nX) and (NPC.m_nCurrY = nY) then begin
          NPC.m_boGhost := True;
          NPC.SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, '');
          SysMsg(sDelOK, c_Red, t_Hint);
          Exit;
        end;
      end; //for
    end;
  end else begin
    BaseObject := GetPoseCreate();
    if BaseObject <> nil then begin
      if UserEngine.m_MerchantList.Count > 0 then begin
        for I := 0 to UserEngine.m_MerchantList.Count - 1 do begin
          if TBaseObject(UserEngine.m_MerchantList.Items[I]) = BaseObject then begin
            BaseObject.m_boGhost := True;
            BaseObject.m_dwGhostTick := GetTickCount();
            BaseObject.SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, '');
            SysMsg(sDelOK, c_Red, t_Hint);
            Exit;
          end;
        end; //for
      end;
      if UserEngine.QuestNPCList.Count > 0 then begin
        for I := 0 to UserEngine.QuestNPCList.Count - 1 do begin
          if TBaseObject(UserEngine.QuestNPCList.Items[I]) = BaseObject then begin
            BaseObject.m_boGhost := True;
            BaseObject.m_dwGhostTick := GetTickCount();
            BaseObject.SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, '');
            SysMsg(sDelOK, c_Red, t_Hint);
            Exit;
          end;
        end; //for
      end;
    end;
  end;
  SysMsg(g_sGameCommandDelNpcMsg, c_Red, t_Hint);
end;
//删除人物技能 20090530 修改

procedure TPlayObject.CmdDelSkill(Cmd: pTGameCmd; sHumanName, sSkillName, sHero: string);
var
  I: Integer;
  PlayObject: TPlayObject;
  HeroObject: TBaseObject;
  boDelAll, boRe: Boolean;
  UserMagic: pTUserMagic;
  Magic: pTMagic;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (sSkillName = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 技能名称 hero', c_Red, t_Hint);
    Exit;
  end;
  if CompareText(sSkillName, 'All') = 0 then boDelAll := True
  else boDelAll := False;
  boRe := False;
  if CompareText(sHero, 'HERO') = 0 then begin //英雄
{$IF HEROVERSION = 1}
    HeroObject := UserEngine.GetHeroObject(sHumanName);
    if HeroObject = nil then begin
      SysMsg(Format('英雄%s不在线，或在其它服务器上！！', [sHumanName]), c_Red, t_Hint);
      Exit;
    end;
    Magic := UserEngine.FindHeroMagic(sSkillName);
    if Magic <> nil then begin
      if Magic.wMagicId = SKILL_75 then begin
        HeroObject.m_boProtectionDefence := False; //是否学过护体神盾
        if not boDelAll then Exit;
      end;
    end;
    for I := HeroObject.m_MagicList.Count - 1 downto 0 do begin
      if HeroObject.m_MagicList.Count <= 0 then Break;
      UserMagic := HeroObject.m_MagicList.Items[I];
      if UserMagic <> nil then begin
        if boDelAll then begin
          boRe := True;
          HeroObject.m_MagicList.Delete(I);
          //防止释放内存后的非法访问 By TasNat at: 2012-03-11
          //HeroObject.m_MagicOfDelList.Add(UserMagic);
          Dispose(UserMagic);
        end else begin
          if CompareText(UserMagic.MagicInfo.sMagicName, sSkillName) = 0 then begin
            boRe := True;
            THeroObject(HeroObject).SendDelMagic(UserMagic);
            HeroObject.m_MagicList.Delete(I);
            //防止释放内存后的非法访问 By TasNat at: 2012-03-11
            //HeroObject.m_MagicOfDelList.Add(UserMagic);
            Dispose(UserMagic);
            THeroObject(HeroObject).SysMsg(Format('英雄技能%s已删除。', [sSkillName]), c_Green, t_Hint);
            SysMsg(Format('英雄%s的技能%s已删除。', [sHumanName, sSkillName]), c_Green, t_Hint);
            Break;
          end;
        end;
      end;
    end; //for
    if boRe then begin
      THeroObject(HeroObject).RecalcAbilitys();
      HeroObject.CompareSuitItem(False);
    end;
{$IFEND}
  end else begin
    PlayObject := UserEngine.GetPlayObject(sHumanName);
    if PlayObject = nil then begin
      SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
      Exit;
    end;
    Magic := UserEngine.FindMagic(sSkillName); //20110822 修正
    if Magic <> nil then begin
      if Magic.wMagicId = SKILL_75 then begin
        PlayObject.m_boProtectionDefence := False; //是否学过护体神盾
        if not boDelAll then Exit;
      end;
    end;
    for I := PlayObject.m_MagicList.Count - 1 downto 0 do begin
      if PlayObject.m_MagicList.Count <= 0 then Break;
      UserMagic := PlayObject.m_MagicList.Items[I];
      if UserMagic <> nil then begin
        if boDelAll then begin
{$IF M2Version <> 2}
          if (UserMagic.wMagIdx = SKILL_105) or (UserMagic.wMagIdx = SKILL_106) then begin
            PlayObject.m_sHeartName := ''; //心法名称
            PlayObject.m_nHeartType := 0; //心法类型
          end;
{$IFEND}
          boRe := True;
          PlayObject.m_MagicList.Delete(I);
          //防止释放内存后的非法访问 By TasNat at: 2012-03-11 
          //PlayObject.m_MagicOfDelList.Add(UserMagic);
          Dispose(UserMagic);
        end else begin
          if CompareText(UserMagic.MagicInfo.sMagicName, sSkillName) = 0 then begin
{$IF M2Version <> 2}
            if (UserMagic.wMagIdx = SKILL_105) or (UserMagic.wMagIdx = SKILL_106) then begin
              PlayObject.m_sHeartName := ''; //心法名称
              PlayObject.m_nHeartType := 0; //心法类型
            end;
{$IFEND}
            boRe := True;
            PlayObject.SendDelMagic(UserMagic);
            PlayObject.m_MagicList.Delete(I);
            PlayObject.SysMsg(Format('技能%s已删除。', [sSkillName]), c_Green, t_Hint);
            SysMsg(Format('%s的技能%s已删除。', [sHumanName, sSkillName]), c_Green, t_Hint);
            //防止释放内存后的非法访问 By TasNat at: 2012-03-11 
            //PlayObject.m_MagicOfDelList.Add(UserMagic);
            Dispose(UserMagic);
            Break;
          end;
        end;
      end;
    end; //for
    if boRe then begin
      PlayObject.RecalcAbilitys(); //20080924 增加
      PlayObject.CompareSuitItem(False); //20080924 套装
    end;
  end;
end;

procedure TPlayObject.CmdDenyAccountLogon(Cmd: pTGameCmd; sAccount, sFixDeny: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sAccount = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 登录帐号 是否永久封(0,1)', c_Red, t_Hint);
    Exit;
  end;
  g_DenyAccountList.Lock;
  try
    if (sFixDeny <> '') and (sFixDeny[1] = '1') then begin
      g_DenyAccountList.AddObject(sAccount, TObject(1));
      SaveDenyAccountList();
      SysMsg(sAccount + '已加入禁止登录帐号列表', c_Green, t_Hint);
    end else begin
      g_DenyAccountList.AddObject(sAccount, TObject(0));
      SysMsg(sAccount + '已加入临时禁止登录帐号列表', c_Green, t_Hint);
    end;
  finally
    g_DenyAccountList.UnLock;
  end;
end;

procedure TPlayObject.CmdDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sCharName = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 是否永久封(0,1)', c_Red, t_Hint);
    Exit;
  end;
  g_DenyChrNameList.Lock;
  try
    if (sFixDeny <> '') and (sFixDeny[1] = '1') then begin
      g_DenyChrNameList.AddObject(sCharName, TObject(1));
      SaveDenyChrNameList();
      SysMsg(sCharName + '已加入禁止人物列表', c_Green, t_Hint);
    end else begin
      g_DenyChrNameList.AddObject(sCharName, TObject(0));
      SysMsg(sCharName + '已加入临时禁止人物列表', c_Green, t_Hint);
    end;
  finally
    g_DenyChrNameList.UnLock;
  end;
end;

procedure TPlayObject.CmdDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr, sFixDeny: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sIPaddr = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' IP地址 是否永久封(0,1)', c_Red, t_Hint);
    Exit;
  end;
  g_DenyIPAddrList.Lock;
  try
    if (sFixDeny <> '') and (sFixDeny[1] = '1') then begin
      g_DenyIPAddrList.AddObject(sIPaddr, TObject(1));
      SaveDenyIPAddrList();
      SysMsg(sIPaddr + '已加入禁止登录IP列表', c_Green, t_Hint);
    end else begin
      g_DenyIPAddrList.AddObject(sIPaddr, TObject(0));
      SysMsg(sIPaddr + '已加入临时禁止登录IP列表', c_Green, t_Hint);
    end;
  finally
    g_DenyIPAddrList.UnLock;
  end;
end;

procedure TPlayObject.CmdDisableFilter(sCmd, sParam1: string);
begin
  if (m_btPermission < 6) then Exit;
  if (sParam1 <> '') and (sParam1[1] = '?') then begin
    SysMsg('启用/禁止文字过滤功能。', c_Red, t_Hint);
    Exit;
  end;
  boFilterWord := not boFilterWord;
  if boFilterWord then begin
    SysMsg('已启用文字过滤。', c_Green, t_Hint);
  end else begin
    SysMsg('已禁止文字过滤。', c_Green, t_Hint);
  end;
end;
//恢复禁止登陆帐号

procedure TPlayObject.CmdDelDenyAccountLogon(Cmd: pTGameCmd; sAccount,
  sFixDeny: string);
var
  I: Integer;
  boDelete: Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sAccount = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 登录帐号', c_Red, t_Hint);
    Exit;
  end;
  boDelete := False;
  g_DenyAccountList.Lock;
  try
    for I := g_DenyAccountList.Count - 1 downto 0 do begin //20080917 修改
      if g_DenyAccountList.Count <= 0 then Break; //20080917
      if CompareText(sAccount, g_DenyAccountList.Strings[I]) = 0 then begin
        if Integer(g_DenyAccountList.Objects[I]) <> 0 then SaveDenyAccountList;
        g_DenyAccountList.Delete(I);
        SysMsg(sAccount + '已从禁止登录帐号列表中删除。', c_Green, t_Hint);
        boDelete := True;
        Break;
      end;
    end; //for
  finally
    g_DenyAccountList.UnLock;
  end;
  if not boDelete then
    SysMsg(sAccount + '没有被禁止登录。', c_Green, t_Hint);
end;
//恢复禁止登陆人物

procedure TPlayObject.CmdDelDenyCharNameLogon(Cmd: pTGameCmd; sCharName,
  sFixDeny: string);
var
  I: Integer;
  boDelete: Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sCharName = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
    Exit;
  end;
  boDelete := False;
  g_DenyChrNameList.Lock;
  try
    for I := g_DenyChrNameList.Count - 1 downto 0 do begin //20080917 修改
      if g_DenyChrNameList.Count <= 0 then Break; //20080917
      if CompareText(sCharName, g_DenyChrNameList.Strings[I]) = 0 then begin
        if Integer(g_DenyChrNameList.Objects[I]) <> 0 then SaveDenyChrNameList;
        g_DenyChrNameList.Delete(I);
        SysMsg(sCharName + '已从禁止登录人物列表中删除。', c_Green, t_Hint);
        boDelete := True;
        Break;
      end;
    end; //for
  finally
    g_DenyChrNameList.UnLock;
  end;
  if not boDelete then
    SysMsg(sCharName + '没有被禁止登录。', c_Green, t_Hint);
end;
//恢复禁止登陆IP

procedure TPlayObject.CmdDelDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr,
  sFixDeny: string);
var
  I: Integer;
  boDelete: Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sIPaddr = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' IP地址', c_Red, t_Hint);
    Exit;
  end;
  boDelete := False;
  g_DenyIPAddrList.Lock;
  try
    for I := g_DenyIPAddrList.Count - 1 downto 0 do begin
      if g_DenyIPAddrList.Count <= 0 then Break;
      if CompareText(sIPaddr, g_DenyIPAddrList.Strings[I]) = 0 then begin
        if Integer(g_DenyIPAddrList.Objects[I]) <> 0 then SaveDenyIPAddrList;
        g_DenyIPAddrList.Delete(I);
        SysMsg(sIPaddr + '已从禁止登录IP列表中删除。', c_Green, t_Hint);
        boDelete := True;
        Break;
      end;
    end; //for
  finally
    g_DenyIPAddrList.UnLock;
  end;
  if not boDelete then
    SysMsg(sIPaddr + '没有被禁止登录。', c_Green, t_Hint);
end;
//查看禁止登陆帐号

procedure TPlayObject.CmdShowDenyAccountLogon(Cmd: pTGameCmd; sAccount, sFixDeny: string);
var
  I: Integer;
begin
  if (m_btPermission < 6) then Exit;
  g_DenyAccountList.Lock;
  try
    if g_DenyAccountList.Count <= 0 then begin
      SysMsg('禁止登录帐号列表为空。', c_Green, t_Hint);
      Exit;
    end;
    for I := 0 to g_DenyAccountList.Count - 1 do begin
      SysMsg(g_DenyAccountList.Strings[I], c_Green, t_Hint);
    end;
  finally
    g_DenyAccountList.UnLock;
  end;
end;
//查看禁止登录角色列表

procedure TPlayObject.CmdShowDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny: string);
var
  I: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  g_DenyChrNameList.Lock;
  try
    if g_DenyChrNameList.Count <= 0 then begin
      SysMsg('禁止登录角色列表为空。', c_Green, t_Hint);
      Exit;
    end;
    for I := 0 to g_DenyChrNameList.Count - 1 do begin
      SysMsg(g_DenyChrNameList.Strings[I], c_Green, t_Hint);
    end;
  finally
    g_DenyChrNameList.UnLock;
  end;
end;
//查看禁止登陆IP

procedure TPlayObject.CmdShowDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr, sFixDeny: string);
var
  I: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  g_DenyIPAddrList.Lock;
  try
    if g_DenyIPAddrList.Count <= 0 then begin
      SysMsg('禁止登录角色列表为空。', c_Green, t_Hint);
      Exit;
    end;
    for I := 0 to g_DenyIPAddrList.Count - 1 do begin
      SysMsg(g_DenyIPAddrList.Strings[I], c_Green, t_Hint);
    end;
  finally
    g_DenyIPAddrList.UnLock;
  end;
end;

procedure TPlayObject.CmdDisableSendMsg(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sHumanName = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    PlayObject.m_boFilterSendMsg := True;
  end;
  g_DisableSendMsgList.Add(sHumanName);
  SaveDisableSendMsgList();
  SysMsg(sHumanName + ' 已加入禁言列表。', c_Green, t_Hint);
end;

procedure TPlayObject.CmdDisableSendMsgList(Cmd: pTGameCmd);
var
  I: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if g_DisableSendMsgList.Count <= 0 then begin
    SysMsg('禁言列表为空！', c_Red, t_Hint);
    Exit;
  end;

  SysMsg('禁言列表:', c_Blue, t_Hint);
  for I := 0 to g_DisableSendMsgList.Count - 1 do begin
    SysMsg(g_DisableSendMsgList.Strings[I], c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdEnableSendMsg(Cmd: pTGameCmd; sHumanName: string);
var
  I: Integer;
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sHumanName = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
    Exit;
  end;
  for I := g_DisableSendMsgList.Count - 1 downto 0 do begin
    if g_DisableSendMsgList.Count <= 0 then Break;
    if CompareText(sHumanName, g_DisableSendMsgList.Strings[I]) = 0 then begin
      PlayObject := UserEngine.GetPlayObject(sHumanName);
      if PlayObject <> nil then begin
        PlayObject.m_boFilterSendMsg := False;
      end;
      g_DisableSendMsgList.Delete(I);
      SaveDisableSendMsgList();
      SysMsg(sHumanName + ' 已从禁言列表中删除。', c_Green, t_Hint);
      Exit;
    end;
  end; //for
  SysMsg(sHumanName + ' 没有被禁言！', c_Red, t_Hint);
end;
//退出行会

procedure TPlayObject.CmdEndGuild;
{$IF M2Version <> 2}
var
  I: Integer;
  HumTitleDB: pTHumTitleDB;
  boSend: Boolean;
{$IFEND}
begin
  if (m_MyGuild <> nil) then begin
    if (m_nGuildRankNo > 1) then begin
      if TGUild(m_MyGuild).IsMember(m_sCharName) and TGUild(m_MyGuild).DelMember(m_sCharName) then begin
        //UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGUild(m_MyGuild).sGuildName); //20101022 注释
        TGUild(m_MyGuild).SendGuildMsg('==行会信息==：' + m_sCharName + ' 已经正式离开了本行会'); //20101022 增加
        m_MyGuild := nil;
        RefRankInfo(0, '');
{$IF M2Version <> 2}
        boSend := False;
        if m_boCanTitle then begin //有称号时，退会行会之星消失
          for I := Low(THumTitles) to High(THumTitles) do begin
            if (m_wHumTitles[I].wIndex > 0) and (m_wHumTitles[I].MakeIndex > 0) then begin
              HumTitleDB := UserEngine.GetHumTitle(m_wHumTitles[I].wIndex);
              if HumTitleDB <> nil then begin
                if (HumTitleDB.AniCount = 8) and (HumTitleDB.StdMode = 0) then begin //行会之星
                  m_wHumTitles[I].MakeIndex := 0;
                  m_wHumTitles[I].wIndex := 0;
                  if m_wHumTitles[I].boUseTitle then begin //20110313
                    m_boUseTitle := False; //当前是否使用称号
                    m_boUseIitleIdx := 0; //当前使用称号的图片索引
                    m_sUseIitleName := '';
                    RefShowName();
                  end;
                  m_wHumTitles[I].boUseTitle := False;
                  m_wHumTitles[I].wDura := 0;
                  m_wHumTitles[I].wMaxDura := 0;
                  m_wHumTitles[I].sChrName := ''; //需处理认命类称号
                  SysMsg(Format('您失去了称号：%s', [HumTitleDB.sTitleName]), c_Green, t_Hint);
                  SendMsg(Self, RM_SENDHUMTITLES, 0, 0, 0, 0, '');
                  RecalcAbilitys();
                  CompareSuitItem(False); //套装
                  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                  if g_FunctionNPC <> nil then begin
                    g_FunctionNPC.GotoLable(Self, '@FengHaoFunc' + IntToStr(HumTitleDB.idx), False, False);
                  end;
                  boSend := True;
                end;
              end;
            end;
          end;
          if boSend then SendMsg(Self, RM_SENDHUMTITLES, 0, 0, 0, 0, ''); //发送称号数据
        end;
{$IFEND}
        RefShowName(); //10/31
        SysMsg('您已经退出行会。', c_Green, t_Hint);
      end;
    end else begin
      SysMsg('行会掌门人不能这样退出行会！', c_Red, t_Hint);
    end;
  end else begin
    SysMsg('您都没加入行会！', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdFireBurn(nInt, nTime, nN: Integer);
var
  FireBurnEvent: TFireBurnEvent;
begin
  if (m_btPermission < 6) then Exit;
  if (nInt = 0) or (nTime = 0) or (nN = 0) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + g_GameCommand.FIREBURN.sCmd + ' nInt nTime nN', c_Red, t_Hint);
    Exit;
  end;
  FireBurnEvent := TFireBurnEvent.Create(Self, m_nCurrX, m_nCurrY, nInt, nTime, nN);
  g_EventManager.AddEvent(FireBurnEvent);
end;

procedure TPlayObject.CmdForcedWallconquestWar(Cmd: pTGameCmd; sCASTLENAME: string);
var
  Castle: TUserCastle;
  s20: string;
  Guild: TGUild;
  I: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;

  if sCASTLENAME = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 城堡名称', c_Red, t_Hint);
    Exit;
  end;

  Castle := g_CastleManager.Find(sCASTLENAME);
  if Castle <> nil then begin
    Castle.m_boUnderWar := not Castle.m_boUnderWar; //设置为可以攻城
    if Castle.m_boUnderWar then begin //正在攻城
      if g_GuildManager.GuildList.Count > 0 then begin //20080816 增加所有行会为攻城行会
        for I := 0 to g_GuildManager.GuildList.Count - 1 do begin
          Guild := TGUild(g_GuildManager.GuildList.Items[I]);
          Castle.m_AttackGuildList.Add(Guild);
        end;
      end;
      Castle.m_boShowOverMsg := False; //20080816
      Castle.m_WarDate := Now(); //20080816

      Castle.m_dwStartCastleWarTick := GetTickCount();
      Castle.StartWallconquestWar();

      //UserEngine.SendServerGroupMsg(SS_212, nServerIndex, '');//20101022 注释
      s20 := '[' + Castle.m_sName + ' 攻城战已经开始]';
      UserEngine.SendBroadCastMsg(s20, t_System);
      //UserEngine.SendServerGroupMsg(SS_204, nServerIndex, s20);//20101022 注释
      Castle.MainDoorControl(True);
    end else begin
      Castle.StopWallconquestWar();
    end;
  end else begin
    SysMsg(Format_ToStr(g_sGameCommandSbkGoldCastleNotFoundMsg, [sCASTLENAME]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdFreePenalty(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandFreePKHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject.m_nPkPoint := 0;
  PlayObject.RefNameColor();
  PlayObject.SysMsg(g_sGameCommandFreePKHumanMsg, c_Green, t_Hint);
  SysMsg(Format_ToStr(g_sGameCommandFreePKMsg, [sHumanName]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdGroupRecall(sCmd: string);
var
  I: Integer;
  dwValue: LongWord;
  PlayObject: TPlayObject;
begin
  if m_boRecallSuite or (m_btPermission >= 6) then begin
    if not m_PEnvir.m_boNORECALL then begin
      dwValue := (GetTickCount - m_dwGroupRcallTick) div 1000;
      m_dwGroupRcallTick := m_dwGroupRcallTick + dwValue * 1000;
      if m_btPermission >= 6 then m_wGroupRcallTime := 0;

      if m_wGroupRcallTime > dwValue then begin
        Dec(m_wGroupRcallTime, dwValue);
      end else m_wGroupRcallTime := 0;
      if m_wGroupRcallTime = 0 then begin
        if m_GroupOwner = Self then begin
          if m_GroupMembers.Count > 0 then begin //20091113 增加
            for I := 1 to m_GroupMembers.Count - 1 do begin
              PlayObject := TPlayObject(m_GroupMembers.Objects[I]);
              if PlayObject.m_boAllowGroupReCall then begin
                if PlayObject.m_PEnvir.m_boNORECALL then begin
                  SysMsg(Format('%s 所在的地图不允许传送。', [PlayObject.m_sCharName]), c_Red, t_Hint);
                end else begin
                  RecallHuman(PlayObject.m_sCharName);
                end;
              end else begin
                SysMsg(Format('%s 不允许天地合一！', [PlayObject.m_sCharName]), c_Red, t_Hint);
              end;
            end; //for
          end;
          m_dwGroupRcallTick := GetTickCount();
          m_wGroupRcallTime := g_Config.nGroupRecallTime;
        end;
      end else begin
        SysMsg(Format('%d 秒之后才可以再使用此功能！', [m_wGroupRcallTime]), c_Red, t_Hint);
      end;
    end else begin
      SysMsg('此地图禁止使用此命令！', c_Red, t_Hint);
    end;
  end else begin
    SysMsg('您现在还无法使用此功能！', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdGuildRecall(sCmd, sParam: string);
var
  I, II: Integer;
  dwValue: LongWord;
  PlayObject: TPlayObject;
  GuildRank: pTGuildRank;
  nRecallCount, nNoRecallCount: Integer;
  Castle: TUserCastle;
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    SysMsg('命令功能: 行会传送，行会掌门人可以将整个行会成员全部集中。', c_Red, t_Hint);
    Exit;
  end;

  if not m_boGuildMove and (m_btPermission < 6) then begin
    SysMsg('您现在还无法使用此功能！', c_Red, t_Hint);
    Exit;
  end;
  if not IsGuildMaster then begin
    SysMsg('行会掌门人才可以使用此功能！', c_Red, t_Hint);
    Exit;
  end;
  if m_PEnvir.m_boNOGUILDRECALL then begin
    SysMsg('本地图不允许使用此功能！', c_Red, t_Hint);
    Exit;
  end;
  Castle := g_CastleManager.InCastleWarArea(Self);
  //if UserCastle.m_boUnderWar and UserCastle.InCastleWarArea(m_PEnvir,m_nCurrX,m_nCurrY) then begin
  if (Castle <> nil) and Castle.m_boUnderWar then begin
    SysMsg('攻城区域不允许使用此功能！', c_Red, t_Hint);
    Exit;
  end;
  nRecallCount := 0;
  nNoRecallCount := 0;
  dwValue := (GetTickCount - m_dwGroupRcallTick) div 1000;
  m_dwGroupRcallTick := m_dwGroupRcallTick + dwValue * 1000;
  if m_btPermission >= 6 then m_wGroupRcallTime := 0;
  if m_wGroupRcallTime > dwValue then begin
    Dec(m_wGroupRcallTime, dwValue);
  end else m_wGroupRcallTime := 0;

  if m_wGroupRcallTime > 0 then begin
    SysMsg(Format('%d 秒之后才可以再使用此功能！', [m_wGroupRcallTime]), c_Red, t_Hint);
    Exit;
  end;
  if TGUild(m_MyGuild).m_RankList.Count > 0 then begin //20091113 增加
    for I := 0 to TGUild(m_MyGuild).m_RankList.Count - 1 do begin
      GuildRank := TGUild(m_MyGuild).m_RankList.Items[I];
      if GuildRank = nil then Continue;
      if GuildRank.MemberList.Count > 0 then begin //20091113 增加
        for II := 0 to GuildRank.MemberList.Count - 1 do begin
          PlayObject := TPlayObject(GuildRank.MemberList.Objects[II]);
          if PlayObject <> nil then begin
            if PlayObject = Self then begin
              //Inc(nNoRecallCount);
              Continue;
            end;
            if PlayObject.m_boAllowGuildReCall then begin
              if PlayObject.m_PEnvir.m_boNORECALL then begin
                SysMsg(Format('%s 所在的地图不允许传送。', [PlayObject.m_sCharName]), c_Red, t_Hint);
              end else begin
                RecallHuman(PlayObject.m_sCharName);
                Inc(nRecallCount);
              end;
            end else begin
              Inc(nNoRecallCount);
              SysMsg(Format('%s 不允许行会合一！', [PlayObject.m_sCharName]), c_Red, t_Hint);
            end;
          end;
        end; //for
      end;
    end; //for
  end;

  SysMsg(Format('已传送%d个成员，%d个成员未被传送。', [nRecallCount, nNoRecallCount]), c_Green, t_Hint);
  m_dwGroupRcallTick := GetTickCount();
  m_wGroupRcallTime := g_Config.nGuildRecallTime;
end;

{procedure TPlayObject.CmdGuildWar(sCmd, sGuildName: string);//20080812 注释
begin
  if (m_btPermission < 6) then Exit;
end; }
//改变头发

procedure TPlayObject.CmdHair(Cmd: pTGameCmd; sHumanName: string; nHair: Integer);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (nHair < 0) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 类型值', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    PlayObject.m_btHair := nHair;
    PlayObject.FeatureChanged();
    SysMsg(sHumanName + ' 的头发已改变。', c_Green, t_Hint);
  end else begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdHumanInfo(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandInfoHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  SysMsg(PlayObject.GeTBaseObjectInfo(), c_Green, t_Hint);
end;
//查询人物IP及所在地区

procedure TPlayObject.CmdHumanLocal(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandHumanLocalHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  SysMsg(Format_ToStr(g_sGameCommandHumanLocalMsg, [sHumanName, PlayObject.m_sIPLocal + '(' + PlayObject.m_sIPaddr + ')']), c_Green, t_Hint);
end;

procedure TPlayObject.CmdHunger(sCmd, sHumanName: string; nHungerPoint: Integer);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < 6) then Exit;
  if (sHumanName = '') or (nHungerPoint < 0) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + sCmd + ' 人物名称 能量值', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    PlayObject.m_nHungerStatus := nHungerPoint;
    PlayObject.SendMsg(PlayObject, RM_MYSTATUS, 0, 0, 0, 0, '');
    PlayObject.RefMyStatus();
    SysMsg(sHumanName + ' 的能量值已改变。', c_Green, t_Hint);
  end else begin
    SysMsg(sHumanName + '没有在线！', c_Red, t_Hint);
  end;
end;
//增加人物PK值

procedure TPlayObject.CmdIncPkPoint(Cmd: pTGameCmd; sHumanName: string; nPoint: Integer);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandIncPkPointHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  Inc(PlayObject.m_nPkPoint, nPoint);
  PlayObject.RefNameColor();
  if nPoint > 0 then
    SysMsg(Format_ToStr(g_sGameCommandIncPkPointAddPointMsg, [sHumanName, nPoint]), c_Green, t_Hint)
  else
    SysMsg(Format_ToStr(g_sGameCommandIncPkPointDecPointMsg, [sHumanName, -nPoint]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdKickHuman(Cmd: pTGameCmd; sHumName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumName = '') or ((sHumName <> '') and (sHumName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandKickHumanHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject <> nil then begin
    PlayObject.m_boKickFlag := True;
    PlayObject.m_boEmergencyClose := True;
    PlayObject.m_boPlayOffLine := False;
    PlayObject.m_boNotOnlineAddExp := False;
  end else begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdKill(Cmd: pTGameCmd; sHumanName: string);
var
  BaseObject: TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sHumanName <> '' then begin
    BaseObject := UserEngine.GetPlayObject(sHumanName);
    if BaseObject = nil then begin
      SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
      Exit;
    end;
  end else begin
    BaseObject := GetPoseCreate();
    if BaseObject = nil then begin
      SysMsg('命令使用方法不正确，必须与角色面对面站好！', c_Red, t_Hint);
      Exit;
    end;
  end;
  if BaseObject <> nil then BaseObject.Die; //20090207修改
end;

procedure TPlayObject.CmdLockLogin(Cmd: pTGameCmd);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if not g_Config.boLockHumanLogin then begin
    SysMsg('本服务器还没有启用登录锁功能！', c_Red, t_Hint);
    Exit;
  end;

  if m_boLockLogon and not m_boLockLogoned then begin
    SysMsg('您还没有打开登录锁或还没有设置锁密码！', c_Red, t_Hint);
    Exit;
  end;

  m_boLockLogon := not m_boLockLogon;
  if m_boLockLogon then begin
    SysMsg('已开启登录锁', c_Green, t_Hint);
  end else begin
    SysMsg('已关闭登录锁', c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdLotteryTicket(sCmd: string; nPermission: Integer;
  sParam1: string);
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sParam1 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  SysMsg(Format_ToStr(g_sGameCommandLotteryTicketMsg, [g_Config.nWinLotteryCount,
    g_Config.nNoWinLotteryCount,
      g_Config.nWinLotteryLevel1,
      g_Config.nWinLotteryLevel2,
      g_Config.nWinLotteryLevel3,
      g_Config.nWinLotteryLevel4,
      g_Config.nWinLotteryLevel5,
      g_Config.nWinLotteryLevel6]), c_Green, t_Hint);
end;
//调整指定人物的幸运值

procedure TPlayObject.CmdLuckPoint(sCmd: string; nPermission: Integer;
  sHumanName, sCtr, sPoint: string);
var
  PlayObject: TPlayObject;
  cMethod: Char;
  nPoint: Integer;
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandLuckPointHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  if sCtr = '' then begin
    SysMsg(Format_ToStr(g_sGameCommandLuckPointMsg, [sHumanName, PlayObject.m_nBodyLuckLevel, PlayObject.m_dBodyLuck, PlayObject.m_nLuck]), c_Green, t_Hint);
    Exit;
  end;

  nPoint := Str_ToInt(sPoint, 0);
  cMethod := sCtr[1]; //20080811 增加
  case cMethod of
    '=': PlayObject.m_nLuck := nPoint;
    '-': begin
        if PlayObject.m_nLuck >= nPoint then begin
          Dec(PlayObject.m_nLuck, nPoint);
        end else begin
          PlayObject.m_nLuck := 0;
        end;
      end;
    '+': Inc(PlayObject.m_nLuck, nPoint);
  end;
end;
//GM命令:制造物品 物品名 数量 神技代码(1-7) 几鉴(0-3) 普通属性
{神技代码范围为1-7，分别是
1-重生技能
2-八卦护身神技
3-麻痹技能
4-魔道麻痹技能
5-战意麻痹技能
6-探测技能
7-传送技能

普通属性:
11..20   攻击上限
21..30   魔法上限
31..40   道术上限
41..50   魔防上限
51..60   物防上限
61..70   主属性
71..80   内力恢复
81..90   聚魔等级
91..100  强身等级
101..110 吸血上限
111..120 内伤等级
121..130 暴击等级
131..140 防爆
141..150 准确
151..160 敏捷}

procedure TPlayObject.CmdMakeItem(Cmd: pTGameCmd; sItemName: string; nCount: Integer; sUnKnow: string; nKamPoCount: Integer; sVaUnKnow: string);
var
  I: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  TempList: TStringList;
  nKnow1, nKnow2, nKnow3, nKnow4, KnowCount: Byte; //神技
  nVaKnow1, nVaKnow2, nVaKnow3, nVaKnow4, VaKnowCount: Byte; //普通属性
  sStr: string;
  boVaKnow: Boolean;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      Exit;
    end;
    if (sItemName = '') then begin
      if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGamecommandMakeHelpMsg]), c_Red, t_Hint);
      Exit;
    end;
    if (nCount <= 0) then nCount := 1;
    if (nCount > 10) then nCount := 10;
    if (nKamPoCount < 0) then nKamPoCount := 0;
    if nKamPoCount > 3 then nKamPoCount := 3;
    if (m_btPermission < Cmd.nPermissionMax) then begin
      if g_CastleManager.InCastleWarArea(Self) <> nil then begin //攻城区域，禁止使用此功能
        SysMsg(g_sGamecommandMakeInCastleWarRange, c_Red, t_Hint);
        Exit;
      end;
      if not InSafeZone then begin
        SysMsg(g_sGamecommandMakeInSafeZoneRange, c_Red, t_Hint);
        Exit;
      end;
      nCount := 1;
    end;
    if not CanMakeItem(sItemName) then begin
      SysMsg(g_sGamecommandMakeItemNameOrPerMissionNot, c_Red, t_Hint);
      Exit;
    end;
    if sUnKnow <> '' then begin
      if Pos('|', sUnKnow) > 0 then begin //处理神技
        TempList := TStringList.Create;
        try
          ExtractStrings(['|'], [], PChar(Trim(sUnKnow)), TempList);
          if TempList.Count > 0 then begin
            for I := 0 to TempList.Count - 1 do begin
              if I > 3 then Break; //不超过四个神技
              sStr := TempList.Strings[I];
              case I of
                0: nKnow1 := Str_ToInt(sStr, 0);
                1: nKnow2 := Str_ToInt(sStr, 0);
                2: nKnow3 := Str_ToInt(sStr, 0);
                3: nKnow4 := Str_ToInt(sStr, 0);
              end;
            end;
          end;
        finally
          TempList.Free;
        end;
      end else nKnow1 := Str_ToInt(sUnKnow, 0);
    end;
    boVaKnow := False;
    if sVaUnKnow <> '' then begin
      if Pos('|', sVaUnKnow) > 0 then begin //处理普通属性
        boVaKnow := True;
        TempList := TStringList.Create;
        try
          ExtractStrings(['|'], [], PChar(Trim(sVaUnKnow)), TempList);
          if TempList.Count > 0 then begin
            for I := 0 to TempList.Count - 1 do begin
              if I > 3 then Break; //不超过四个普通属性
              sStr := TempList.Strings[I];
              case I of
                0: nVaKnow1 := Str_ToInt(sStr, 0);
                1: nVaKnow2 := Str_ToInt(sStr, 0);
                2: nVaKnow3 := Str_ToInt(sStr, 0);
                3: nVaKnow4 := Str_ToInt(sStr, 0);
              end;
            end;
          end;
        finally
          TempList.Free;
        end;
      end else begin
        nVaKnow1 := Str_ToInt(sVaUnKnow, 0);
        if nVaKnow1 in [11..160] then boVaKnow := True;
      end;
    end;
    for I := 0 to nCount - 1 do begin
      if m_ItemList.Count >= MAXBAGITEM then Exit;
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if (StdItem.Price >= 15000) and not g_Config.boTestServer and (m_btPermission < 5) then begin
          Dispose(UserItem);
          Break; //20100913 增加
        end else begin
          if (Random(g_Config.nMakeRandomAddValue) = 0) and (StdItem.StdMode <> 17) and (StdItem.StdMode <> 18) then UserEngine.RandomUpgradeItem(UserItem);
        end;

        if m_btPermission >= Cmd.nPermissionMax then begin
          UserItem.MakeIndex := GetItemNumberEx(); //制造的物品另行取得物品ID
        end;
        if StdItem.StdMode = 17 then begin //叠加物品 20110128
          UserItem.Dura := nCount;
          if UserItem.Dura > UserItem.DuraMax then UserItem.Dura := UserItem.DuraMax;
          if not AutoItemMerger(UserItem) then begin //自动合并物品
            m_ItemList.Add(UserItem);
            SendAddItem(UserItem);
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('5' + #9 + m_sMapName + #9 +
                IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + m_sCharName);
          end;
          if (m_btPermission >= 6) then
            MainOutMessage('[制造物品] ' + m_sCharName + ' ' + sItemName + '(' + IntToStr(UserItem.MakeIndex) + ')');
          Break;
        end else begin
          KnowCount := 0;
          VaKnowCount := 0;
          if UserItem.btAppraisalLevel in [1, 11, 21, 31, 41, 51] then begin
            case nKnow1 of
              1..7: begin
                  if (UserItem.btUnKnowValue[6] <> nKnow1) and (UserItem.btUnKnowValue[7] <> nKnow1) and
                    (UserItem.btUnKnowValue[8] <> nKnow1) and (UserItem.btUnKnowValue[9] <> nKnow1) then begin //判断属性是否重复
                    UserItem.btUnKnowValue[6] := nKnow1;
                    Inc(KnowCount);
                  end;
                end;
              11..160: begin //20110713 神秘属性有普通属性
                  UserItem.btUnKnowValue[6] := nKnow1;
                  Inc(KnowCount);
                end;
            end; //case
            case nKnow2 of
              1..7: begin
                  if (UserItem.btUnKnowValue[6] <> nKnow2) and (UserItem.btUnKnowValue[7] <> nKnow2) and
                    (UserItem.btUnKnowValue[8] <> nKnow2) and (UserItem.btUnKnowValue[9] <> nKnow2) then begin //判断属性是否重复
                    UserItem.btUnKnowValue[7] := nKnow2;
                    Inc(KnowCount);
                  end;
                end;
              11..160: begin //20110713 神秘属性有普通属性
                  UserItem.btUnKnowValue[7] := nKnow2;
                  Inc(KnowCount);
                end;
            end; //Case
            case nKnow3 of
              1..7: begin
                  if (UserItem.btUnKnowValue[6] <> nKnow3) and (UserItem.btUnKnowValue[7] <> nKnow3) and
                    (UserItem.btUnKnowValue[8] <> nKnow3) and (UserItem.btUnKnowValue[9] <> nKnow3) then begin //判断属性是否重复
                    UserItem.btUnKnowValue[8] := nKnow3;
                    Inc(KnowCount);
                  end;
                end;
              11..160: begin //20110713 神秘属性有普通属性
                  UserItem.btUnKnowValue[8] := nKnow3;
                  Inc(KnowCount);
                end;
            end; //Case
            case nKnow4 of
              1..7: begin
                  if (UserItem.btUnKnowValue[6] <> nKnow4) and (UserItem.btUnKnowValue[7] <> nKnow4) and
                    (UserItem.btUnKnowValue[8] <> nKnow4) and (UserItem.btUnKnowValue[9] <> nKnow4) then begin //判断属性是否重复
                    UserItem.btUnKnowValue[9] := nKnow4;
                    Inc(KnowCount);
                  end;
                end;
              11..160: begin //20110713 神秘属性有普通属性
                  UserItem.btUnKnowValue[9] := nKnow4;
                  Inc(KnowCount);
                end;
            end; //Case
            if (KnowCount > 0) and (KnowCount < 5) then UserItem.btUnKnowValueCount := KnowCount;
            if nVaKnow1 in [11..160] then begin
              UserItem.btAppraisalValue[2] := nVaKnow1;
              Inc(VaKnowCount);
            end;
            if (nVaKnow1 in [11..160]) and (nVaKnow2 in [11..160]) then begin
              UserItem.btAppraisalValue[3] := nVaKnow2;
              Inc(VaKnowCount);
            end;
            if (nVaKnow1 in [11..160]) and (nVaKnow2 in [11..160])
              and (nVaKnow3 in [11..160]) then begin
              UserItem.btAppraisalValue[4] := nVaKnow3;
              Inc(VaKnowCount);
            end;
            if (KnowCount = 0) and (nVaKnow4 in [11..160]) then begin
              if (nVaKnow1 in [11..160]) and (nVaKnow2 in [11..160])
                and (nVaKnow3 in [11..160]) then begin
                UserItem.btAppraisalValue[5] := nVaKnow4;
                Inc(VaKnowCount);
                if VaKnowCount > 3 then VaKnowCount := 3;
              end;
            end;
            if not boVaKnow then Inc(UserItem.btAppraisalLevel, nKamPoCount)
            else Inc(UserItem.btAppraisalLevel, VaKnowCount);
          end;
          m_ItemList.Add(UserItem);
          SendAddItem(UserItem);
          if {g_Config.boShowMakeItemMsg and}(m_btPermission >= 6) then
            MainOutMessage('[制造物品] ' + m_sCharName + ' ' + sItemName + '(' + IntToStr(UserItem.MakeIndex) + ')');
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('5' + #9 + m_sMapName + #9 +
              IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 +
              '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
              '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
              '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
              '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
              '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
              IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
              IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
              IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
              IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + m_sCharName);
        end;
      end else begin //004CD114
        Dispose(UserItem);
        SysMsg(Format_ToStr(g_sGamecommandMakeItemNameNotFound, [sItemName]), c_Red, t_Hint);
        Break;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TPlayObject.CmdMakeItem %p', [g_sExceptionVer, ExceptAddr]));
  end;
end;

procedure TPlayObject.CmdMapMove(Cmd: pTGameCmd; sMapName: string);
var
  Envir: TEnvirnoment;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMapName = '') or ((sMapName <> '') and (sMapName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandMoveHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  Envir := g_MapManager.FindMap(sMapName);
  if (Envir = nil) then begin
    SysMsg(Format_ToStr(g_sTheMapNotFound, [sMapName]) { + ' 此地图号不存在！！！'}, c_Red, t_Hint);
    Exit;
  end;
  if (m_btPermission >= Cmd.nPermissionMax) or CanMoveMap(sMapName) then begin
    SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
    MapRandomMove(sMapName, 0);
  end else begin
    SysMsg(Format_ToStr(g_sTheMapDisableMove, [sMapName, Envir.sMapDesc]) {'地图 ' + sParam1 + ' 不允许传送！！！'}, c_Red, t_Hint);
  end;
end;
//准确移动

procedure TPlayObject.CmdPositionMove(Cmd: pTGameCmd; sMapName, sX, sY: string);
var
  Envir: TEnvirnoment;
  nX, nY: Integer;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      Exit;
    end;
    if (sMapName = '') or (sX = '') or (sY = '') or ((sMapName <> '') and (sMapName[1] = '?')) then begin
      if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandPositionMoveHelpMsg]), c_Red, t_Hint);
      Exit;
    end;
    if (m_btPermission >= Cmd.nPermissionMax) or CanMoveMap(sMapName) then begin
      Envir := g_MapManager.FindMap(sMapName);
      if Envir <> nil then begin
        nX := Str_ToInt(sX, 0);
        nY := Str_ToInt(sY, 0);
        if Envir.CanWalk(nX, nY, True) then begin
          SpaceMove(sMapName, nX, nY, 0);
        end else begin
          SysMsg(Format_ToStr(g_sGameCommandPositionMoveCanotMoveToMap, [sMapName, sX, sY]), c_Green, t_Hint);
        end;
      end;
    end else begin
      SysMsg(Format_ToStr(g_sTheMapDisableMove, [sMapName, Envir.sMapDesc]), c_Red, t_Hint);
    end;
  except
      MainOutMessage(Format('{%s} TPlayObject.CmdPositionMove %p', [g_sExceptionVer, ExceptAddr]));

  end;
end;

procedure TPlayObject.CmdMapMoveHuman(Cmd: pTGameCmd; sSrcMap, sDenMap: string);
var
  SrcEnvir, DenEnvir: TEnvirnoment;
  HumanList: TList;
  I: Integer;
  MoveHuman: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sDenMap = '') or (sSrcMap = '') or ((sSrcMap <> '') and (sSrcMap[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandMapMoveHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  SrcEnvir := g_MapManager.FindMap(sSrcMap);
  DenEnvir := g_MapManager.FindMap(sDenMap);
  if (SrcEnvir = nil) then begin
    SysMsg(Format_ToStr(g_sGameCommandMapMoveMapNotFound, [sSrcMap]), c_Red, t_Hint);
    Exit;
  end;
  if (DenEnvir = nil) then begin
    SysMsg(Format_ToStr(g_sGameCommandMapMoveMapNotFound, [sDenMap]), c_Red, t_Hint);
    Exit;
  end;
  HumanList := TList.Create;
  try
    UserEngine.GetMapRageHuman(SrcEnvir, SrcEnvir.m_nWidth div 2, SrcEnvir.m_nHeight div 2, 1000, HumanList);
    if HumanList.Count > 0 then begin //20091113 增加
      for I := 0 to HumanList.Count - 1 do begin
        MoveHuman := TPlayObject(HumanList.Items[I]);
        if MoveHuman <> Self then MoveHuman.MapRandomMove(sDenMap, 0);
      end;
    end;
  finally
    HumanList.Free;
  end;
end;

procedure TPlayObject.CmdUserCmd(sLable: string);
begin
  if (g_FunctionNPC <> nil) and (sLable <> '') then g_FunctionNPC.GotoLable(Self, sLable, False, False);
end;
//自定义命令 20080729

function TPlayObject.PlayObjectUserCmd(sLable, sParam: string): Boolean;
var
  I, nCode: Integer;
begin
  Result := False;
  try
    if (g_UserCmdList = nil) or (g_UserCmdList.Count <= 0) then Exit;
    for I := 0 to g_UserCmdList.Count - 1 do begin
      if CompareText(sLable, g_UserCmdList.Strings[I]) = 0 then begin
        if g_FunctionNPC = nil then break;
        m_nScriptGotoCount := 0; //20080927 初始化跳转次数
        nCode := Integer(g_UserCmdList.Objects[I]);
        sLable := '@UserCmd' + IntToStr(nCode);
        if (nCode > 99) or (nCode < 0) then nCode := 0;
        m_sString[nCode] := sParam;
        m_nInteger[nCode] := Str_ToInt(sParam, 0);
        CmdUserCmd(sLable); //执行QF触发
        Result := True;
        break;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TPlayObject.PlayObjectUserCmd %p', [g_sExceptionVer , ExceptAddr]));
  end;
end;

procedure TPlayObject.CmdMemberFunction(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    SysMsg('打开会员功能窗口.', c_Red, t_Hint);
    Exit;
  end;
  if g_ManageNPC <> nil then begin
    g_ManageNPC.GotoLable(Self, '@Member', False, False);
  end;
end;

procedure TPlayObject.CmdMemberFunctionEx(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    SysMsg('打开会员功能窗口.', c_Red, t_Hint);
    Exit;
  end;
  if g_FunctionNPC <> nil then begin
    g_FunctionNPC.GotoLable(Self, '@Member', False, False);
  end;
end;

procedure TPlayObject.CmdMission(Cmd: pTGameCmd; sX, sY: string);
var
  nX, nY: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sX = '') or (sY = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' X  Y', c_Red, t_Hint);
    Exit;
  end;
  nX := Str_ToInt(sX, 0);
  nY := Str_ToInt(sY, 0);
  g_boMission := True;
  g_sMissionMap := m_sMapName;
  g_nMissionX := nX;
  g_nMissionY := nY;
  SysMsg('怪物集中目标已设定为: ' + m_sMapName + '(' + IntToStr(g_nMissionX) + ':' + IntToStr(g_nMissionY) + ')', c_Green, t_Hint);
end;
//GM命令刷怪

procedure TPlayObject.CmdMob(Cmd: pTGameCmd; sMonName: string; nCount, nLevel, nMonTpye: Integer); //004CC7F4
var
  I: Integer;
  nX, nY: Integer;
  Monster: TBaseObject;
  BoIsNGMon, boIsHeroPulsExpMon: Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMonName = '') or ((sMonName <> '') and (sMonName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandMobHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  if nCount <= 0 then nCount := 1;
  if not (nLevel in [0..10]) then nLevel := 0;
  BoIsNGMon := False;
  boIsHeroPulsExpMon := False;
  case nMonTpye of
    1: BoIsNGMon := True; //内功怪
    2: boIsHeroPulsExpMon := True; //英雄经络怪
  end;
  nCount := _MIN(64, nCount);
  GetFrontPosition(nX, nY);
  for I := 0 to nCount - 1 do begin
    Monster := UserEngine.RegenMonsterByName(m_PEnvir.sMapName, nX, nY, sMonName);
    if Monster <> nil then begin
      Monster.m_boIsNGMonster := BoIsNGMon; //内功怪
      Monster.m_boIsHeroPulsExpMon := boIsHeroPulsExpMon; //英雄经络怪
      Monster.m_btSlaveMakeLevel := nLevel;
      Monster.m_btSlaveExpLevel := nLevel;
      Monster.RecalcAbilitys;
      Monster.RefNameColor;
    end else begin
      SysMsg(g_sGameCommandMobMsg, c_Red, t_Hint);
      Break;
    end;
  end;
end;

procedure TPlayObject.CmdMobCount(Cmd: pTGameCmd; sMapName: string);
var
  Envir: TEnvirnoment;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMapName = '') or ((sMapName <> '') and (sMapName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandMobCountHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  Envir := g_MapManager.FindMap(sMapName);
  if Envir = nil then begin
    SysMsg(g_sGameCommandMobCountMapNotFound, c_Red, t_Hint);
    Exit;
  end;
  SysMsg(Format_ToStr(g_sGameCommandMobCountMonsterCount, [UserEngine.GetMapMonster(Envir, nil)]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdHumanCount(Cmd: pTGameCmd; sMapName: string);
var
  Envir: TEnvirnoment;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMapName = '') or ((sMapName <> '') and (sMapName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandHumanCountHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  Envir := g_MapManager.FindMap(sMapName);
  if Envir = nil then begin
    SysMsg(g_sGameCommandMobCountMapNotFound, c_Red, t_Hint);
    Exit;
  end;
  SysMsg(Format_ToStr(g_sGameCommandMobCountMonsterCount, [UserEngine.GetMapHuman(sMapName)]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdMobFireBurn(Cmd: pTGameCmd; sMAP, sX, sY, sType,
  sTime, sPoint: string);
var
  nX, nY, nType, nTime, nPoint: Integer;
  FireBurnEvent: TFireBurnEvent;
  Envir: TEnvirnoment;
  OldEnvir: TEnvirnoment;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMAP = '') or ((sMAP <> '') and (sMAP[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandMobFireBurnHelpMsg, [Cmd.sCmd, sMAP, sX, sY, sType, sTime, sPoint]), c_Red, t_Hint);
    Exit;
  end;

  nX := Str_ToInt(sX, -1);
  nY := Str_ToInt(sY, -1);
  nType := Str_ToInt(sType, -1);
  nTime := Str_ToInt(sTime, -1);
  nPoint := Str_ToInt(sPoint, -1);
  if nPoint < 0 then nPoint := 1;

  if (sMAP = '') or (nX < 0) or (nY < 0) or (nType < 0) or (nTime < 0) or (nPoint < 0) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandMobFireBurnHelpMsg, [Cmd.sCmd, sMAP, sX, sY, sType, sTime, sPoint]), c_Red, t_Hint);
    Exit;
  end;
  Envir := g_MapManager.FindMap(sMAP);
  if Envir <> nil then begin
    OldEnvir := m_PEnvir;
    m_PEnvir := Envir;
    FireBurnEvent := TFireBurnEvent.Create(Self, nX, nY, nType, nTime * 1000, nPoint);
    g_EventManager.AddEvent(FireBurnEvent);
    m_PEnvir := OldEnvir;
    Exit;
  end;
  SysMsg(Format_ToStr(g_sGameCommandMobFireBurnMapNotFountMsg, [Cmd.sCmd, sMAP]), c_Red, t_Hint);
end;

procedure TPlayObject.CmdMobLevel(Cmd: pTGameCmd; Param: string); //004CFD5C
var
  I: Integer;
  BaseObjectList: TList;
  BaseObject: TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((Param <> '') and (Param[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    Exit;
  end;

  BaseObjectList := TList.Create;
  try
    m_PEnvir.GetRangeBaseObject(m_nCurrX, m_nCurrY, 2, True, BaseObjectList);
    if BaseObjectList.Count > 0 then begin //20091113 增加
      for I := 0 to BaseObjectList.Count - 1 do begin
        BaseObject := TBaseObject(BaseObjectList.Items[I]);
        SysMsg(BaseObject.GeTBaseObjectInfo(), c_Green, t_Hint);
      end;
    end;
  finally
    BaseObjectList.Free;
  end;
end;
//增加一个NPC

procedure TPlayObject.CmdMobNpc(sCmd: string; nPermission: Integer; sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7: string);
var
  nAppr: Integer;
  boIsCastle: Boolean;
  Merchant: TMerchant;
  nX, nY, n10: Integer;
  Envir: TEnvirnoment;
  sMapName: string;
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sParam1 = '') or (sParam2 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandMobNpcHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  nAppr := Str_ToInt(sParam3, 0);
  boIsCastle := (Str_ToInt(sParam4, 0) = 1);
  if sParam1 = '' then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + sCmd + ' NPC名称 脚本文件名 外形(数字) 属沙城(0,1) 地图 X Y', c_Red, t_Hint);
    Exit;
  end;
  Merchant := TMerchant.Create;
  Merchant.m_sCharName := sParam1;

  n10 := GetValNameNo(sParam5); //支持NPC地图支持A变量 20110924
  if (n10 > 699) then begin
    case n10 of
      700..799: sMapName := g_Config.GlobalAVal[n10 - 700]; //A变量1..99
      1200..2099: sMapName := g_Config.GlobalAVal[n10 - 1100]; //A变量(100-999)
    else sMapName := sParam5;
    end;
    if sMapName = '' then sMapName := sParam5;
  end else sMapName := sParam5;

  Envir := g_MapManager.FindMap({sParam5}sMapName); //查找地图场景
  if Envir <> nil then begin
    Merchant.m_sMapName := sParam5;
    Merchant.m_PEnvir := Envir;
    Merchant.m_nCurrX := Str_ToInt(sParam6, 0);
    Merchant.m_nCurrY := Str_ToInt(sParam7, 0);
  end else begin
    Merchant.m_sMapName := m_sMapName;
    Merchant.m_PEnvir := m_PEnvir;
    GetFrontPosition(nX, nY);
    Merchant.m_nCurrX := nX;
    Merchant.m_nCurrY := nY;
  end;
  Merchant.m_wAppr := nAppr;
  Merchant.m_nFlag := 0;
  Merchant.m_boCastle := boIsCastle;
  Merchant.m_sScript := sParam2;
  Merchant.Initialize();
  Merchant.ClearScript; //20100103 增加
  Merchant.LoadNpcScript; //20100103 增加
  UserEngine.AddMerchant(Merchant);
end;
//20081001 修改

procedure TPlayObject.CmdMobPlace(Cmd: pTGameCmd; sX, sY, sMonName, sCount, sNGMon: string);
var
  I: Integer;
  nCount, nX, nY: Integer;
  MEnvir: TEnvirnoment;
  mon: TBaseObject;
  boIsNGMon, boIsHeroPulsMon, boShowMsg: Boolean;
  nCode: Byte; //20090128
begin
  nCode := 0;
  try
    if (m_btPermission < Cmd.nPermissionMin) then begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      Exit;
    end;
    nCount := _MIN(500, Str_ToInt(sCount, 0));
    nX := Str_ToInt(sX, 0);
    nY := Str_ToInt(sY, 0);
    case Str_ToInt(sNGMon, 0) of
      1: boIsNGMon := True; //内功怪
      2: boIsHeroPulsMon := True; //英雄经络经验怪
    end;
    if (nX <= 0) or (nY <= 0) or (sMonName = '') or (nCount <= 0) then begin
      if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' X  Y 怪物名称 怪物数量 怪类型(0普通怪/1内功怪/2英雄经络经验怪)', c_Red, t_Hint);
      Exit;
    end;
    nCode := 1;
    MEnvir := g_MapManager.FindMap(g_sMissionMap);
    if not g_boMission or (MEnvir = nil) then begin
      SysMsg('还没有设定怪物集中点！', c_Red, t_Hint);
      SysMsg('请先用命令' + g_GameCommand.Mission.sCmd + '设置怪物的集中点。', c_Red, t_Hint);
      Exit;
    end;
    nCode := 2;
    if nCount <= 0 then nCount := 1; //20091113 增加
    boShowMsg := False;
    for I := 0 to nCount - 1 do begin
      nCode := 3;
      mon := UserEngine.RegenMonsterByName(g_sMissionMap, nX, nY, sMonName);
      nCode := 4;
      if mon <> nil then begin
        if mon.m_btRaceServer <> 136 then boShowMsg := True;
        nCode := 5;
        mon.m_boIsNGMonster := boIsNGMon; //20081001
        mon.m_boIsHeroPulsExpMon := boIsHeroPulsMon;
        mon.m_boMission := True;
        mon.m_nMissionX := g_nMissionX;
        mon.m_nMissionY := g_nMissionY;
      end else Break;
    end;
    nCode := 6;
    if boShowMsg then SysMsg(IntToStr(nCount) + ' 只 ' + sMonName + ' 已正在往地图 ' + g_sMissionMap + ' ' + IntToStr(g_nMissionX) + ':' + IntToStr(g_nMissionY) + ' 集中。', c_Green, t_Hint); //20080305
  except
    MainOutMessage(Format('{%s} TPlayObject.CmdMobPlace Code:%d.%p', [g_sExceptionVer, nCode, ExceptAddr]));
  end;
end;

procedure TPlayObject.CmdNpcScript(sCmd: string; nPermission: Integer; sParam1, sParam2, sParam3: string);
var
  BaseObject: TBaseObject;
  nNPCType: Integer;
  I: Integer;
  sScriptFileName: string;
  Merchant: TMerchant;
  NormNpc: TNormNpc;
  LoadList: TStringList;
  sScriptLine: string;
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sParam1 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandNpcScriptHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  nNPCType := -1;
  BaseObject := GetPoseCreate();
  if BaseObject <> nil then begin
    if UserEngine.m_MerchantList.Count > 0 then begin //20091113 增加
      for I := 0 to UserEngine.m_MerchantList.Count - 1 do begin
        if TBaseObject(UserEngine.m_MerchantList.Items[I]) = BaseObject then begin
          nNPCType := 0;
          Break;
        end;
      end; //for
    end;
    if UserEngine.QuestNPCList.Count > 0 then begin //20091113 增加
      for I := 0 to UserEngine.QuestNPCList.Count - 1 do begin
        if TBaseObject(UserEngine.QuestNPCList.Items[I]) = BaseObject then begin
          nNPCType := 1;
          Break;
        end;
      end; //for
    end;
  end;
  if nNPCType < 0 then begin
    SysMsg('命令使用方法不正确，必须与NPC面对面，才能使用此命令！', c_Red, t_Hint);
    Exit;
  end;

  if sParam1 = '' then begin
    if nNPCType = 0 then begin
      Merchant := TMerchant(BaseObject);
      sScriptFileName := g_Config.sEnvirDir + sMarket_Def + Merchant.m_sScript + '-' + Merchant.m_sMapName + '.txt';
    end;
    if nNPCType = 1 then begin
      NormNpc := TNormNpc(BaseObject);
      sScriptFileName := g_Config.sEnvirDir + sNpc_def + NormNpc.m_sCharName + '-' + NormNpc.m_sMapName + '.txt';
    end;
    if FileExists(sScriptFileName) then begin
      LoadList := TStringList.Create;
      try
        LoadList.LoadFromFile(sScriptFileName);
      except
        SysMsg('读取脚本文件错误: ' + sScriptFileName, c_Red, t_Hint);
      end;
      if LoadList.Count > 0 then begin //20091113 增加
        for I := 0 to LoadList.Count - 1 do begin
          sScriptLine := Trim(LoadList.Strings[I]);
          sScriptLine := ReplaceChar(sScriptLine, ' ', ',');
          SysMsg(IntToStr(I) + ',' + sScriptLine, c_Blue, t_Hint);
        end;
      end;
      LoadList.Free;
    end;
  end;
end;

{procedure TPlayObject.CmdOPDeleteSkill(sHumanName, sSkillName: string);//20080812 注释
begin
  if (m_btPermission < 6) then Exit;
end;

procedure TPlayObject.CmdOPTraining(sHumanName, sSkillName: string;
  nLevel: Integer);
begin
  if (m_btPermission < 6) then Exit;
end; }
//查人物的PK值

procedure TPlayObject.CmdPKpoint(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandPKPointHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  SysMsg(Format_ToStr(g_sGameCommandPKPointMsg, [sHumanName, PlayObject.m_nPkPoint]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdPrvMsg(sCmd: string; nPermission: Integer;
  sHumanName: string);
var
  I: Integer;
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandPrvMsgHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  for I := m_BlockWhisperList.Count - 1 downto 0 do begin
    if m_BlockWhisperList.Count <= 0 then Break;
    if CompareText(m_BlockWhisperList.Strings[I], sHumanName) = 0 then begin
      m_BlockWhisperList.Delete(I);
      SysMsg(Format_ToStr(g_sGameCommandPrvMsgUnLimitMsg, [sHumanName]), c_Green, t_Hint);
      Exit;
    end;
  end;
  m_BlockWhisperList.Add(sHumanName);
  SysMsg(Format_ToStr(g_sGameCommandPrvMsgLimitMsg, [sHumanName]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdReAlive(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandReAliveHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  if CompareText(sHumanName, 'Self') = 0 then sHumanName := m_sCharName; //20080822 增加
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject.ReAlive;
  PlayObject.m_WAbil.HP := PlayObject.m_WAbil.MaxHP;
  PlayObject.SendMsg(PlayObject, RM_ABILITY, 0, 0, 0, 0, '');

  SysMsg(Format_ToStr(g_sGameCommandReAliveMsg {'%s 已获重生.'}, [sHumanName]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdRecallHuman(Cmd: pTGameCmd; sHumanName: string); //004CE250
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandRecallHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  RecallHuman(sHumanName);
end;

procedure TPlayObject.CmdRecallMob(Cmd: pTGameCmd; sMonName: string; nCount, nLevel, nAutoChangeColor, nFixColor, nType: Integer); //004CC8C4
var
  I: Integer;
  n10, n14: Integer;
  mon: TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMonName = '') or ((sMonName <> '') and (sMonName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandRecallMobHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  if nLevel >= 10 then nLevel := 0;
  if nCount <= 0 then nCount := 1;
  for I := 0 to nCount - 1 do begin
    if m_SlaveList.Count >= 20 then Break;
    if nType = 1 then begin
      n10 := m_nCurrX;
      n14 := m_nCurrY;
    end else GetFrontPosition(n10, n14);
    mon := UserEngine.RegenMonsterByName(m_PEnvir.sMapName, n10, n14, sMonName);
    if mon <> nil then begin
      mon.m_Master := Self;
      mon.m_dwMasterRoyaltyTick := {GetTickCount +} 86400000 {24 * 60 * 60 * 1000};
      if g_Config.boMasterTimeRoyalty then
        mon.m_dwMasterRoyaltyTick := _MIN(g_Config.dwMasterTimeRoyaltyTime* (60 * 1000), mon.m_dwMasterRoyaltyTick);
      Mon.m_dwMasterRoyaltyTime := GetTickCount; //20080813 增加
      mon.m_btSlaveMakeLevel := 3;
      mon.m_btSlaveExpLevel := nLevel;
      if nAutoChangeColor = 1 then begin
        mon.m_boAutoChangeColor := True;
      end else
        if nFixColor > 0 then begin
          mon.m_boFixColor := True;
          mon.m_nFixColorIdx := nFixColor - 1;
        end;

      mon.RecalcAbilitys();
      mon.RefNameColor();
      m_SlaveList.Add(mon);
    end;
  end;
end;
//------------------------------------------------------------------------------
//召唤宝宝，宝宝等级直接为1级

procedure TPlayObject.CmdRECALLMOBEX(Cmd: pTGameCmd; sMonName: string; nNameColor, nX, nY: Integer; sMap: string);
var
  mon: TBaseObject;
  sMapName, sFileName: string;
  IniFile: TIniFile;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMonName = '') or ((sMonName <> '') and (sMonName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandRecallMobExHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  if nX < 0 then nX := 0;
  if nY < 0 then nY := 0;
  if nNameColor < 0 then nNameColor := 0;
  if nNameColor > 255 then nNameColor := 255;
  if sMap <> '' then sMapName := sMap
  else sMapName := m_PEnvir.sMapName;
  mon := UserEngine.RegenMonsterByName(sMapName, nX, nY, sMonName);
  if mon <> nil then begin
    mon.m_Master := Self;
    mon.m_dwMasterRoyaltyTick := 86400000 {24 * 60 * 60 * 1000}; //叛变时间
    if g_Config.boMasterTimeRoyalty then
      mon.m_dwMasterRoyaltyTick := _MIN(g_Config.dwMasterTimeRoyaltyTime* (60 * 1000), mon.m_dwMasterRoyaltyTick);
    Mon.m_dwMasterRoyaltyTime := GetTickCount;
    mon.m_btSlaveMakeLevel := 3;
    mon.m_btSlaveExpLevel := 1;
    mon.m_btNameColor := nNameColor;
    mon.m_boSetNameColor := True;
    if mon.m_btRaceServer = 158 then begin
      TPetsMon(mon).m_sMasterName := m_sCharName; //宠物怪
      if m_nPetsMonHappiness = 0 then
        m_nPetsMonHappiness := TPetsMon(mon).m_nHappiness //快乐度
      else TPetsMon(mon).m_nHappiness := m_nPetsMonHappiness;
      m_sPetsMonName := Mon.m_sCharName; //宠物名
      sFileName := Format('%sPetsMon\%d', [g_Config.sEnvirDir, g_Config.GlobalVal[High(g_Config.GlobalVal)]]);
      if not DirectoryExists(sFileName) then ForceDirectories(sFileName); //目录不存在,则创建
      sFileName := Format('%sPetsMon\%d\PetsMon.txt', [g_Config.sEnvirDir, g_Config.GlobalVal[High(g_Config.GlobalVal)]]);
      IniFile := TIniFile.Create(sFileName);
      try
        IniFile.WriteString(m_sCharName, '宠物', m_sPetsMonName);
        IniFile.WriteInteger(m_sCharName, '快乐度', m_nPetsMonHappiness);
        IniFile.WriteString(m_sCharName, '配置', Format('%s %d %d %d', [sMapName, nX, nY, mon.m_btNameColor]));
      finally
        IniFile.Free;
      end;
    end;
    mon.RecalcAbilitys();
    mon.RefNameColor();
    m_SlaveList.Add(mon);
  end;
end;
//------------------------------------------------------------------------------
//20080403 给指定纯度的矿石
//命令格式:GIVEMINE 矿名称 数量 纯度
//如纯度不填,则随机给纯度

procedure TPlayObject.CmdGIVEMINE(Cmd: pTGameCmd; sMINEName: string; nMineCount, nDura: Integer);
var
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  I: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMINEName = '') or ((sMINEName <> '') and (sMINEName[1] = '?')) or (nMineCount <= 0) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandGIVEMINEHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  if nDura <= 0 then nDura := Random(18) + 3; //如纯度不填,则随机给纯度
  if nMineCount <= 0 then nMineCount := 1; //20091113 增加
  for I := 0 to nMineCount - 1 do begin
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(sMineName, UserItem) then begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if (StdItem <> nil) and (StdItem.StdMode = 43) and IsAddWeightAvailable(StdItem.Weight * nMineCount) then begin
          UserItem.Dura := nDura * 1000;
          if UserItem.Dura > UserItem.DuraMax then UserItem.Dura := UserItem.DuraMax;
          m_ItemList.Add(UserItem);
          SendAddItem(UserItem);
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('5' + #9 +
              m_sMapName + #9 +
              IntToStr(m_nCurrX) + #9 +
              IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 +
              StdItem.Name + #9 +
              IntToStr(UserItem.MakeIndex) + #9 +
              IntToStr(UserItem.Dura) + '/' + IntToStr(UserItem.DuraMax) + #9 + m_sCharName);
      end else begin//修复内存泄露 By TasNat at: 2012-06-01 12:21:19
        Dispose(UserItem);
        Break;
      end;
    end else begin
      Dispose(UserItem);
      Break;
    end;
  end;
end;
//------------------------------------------------------------------------------
//MOVEMOBTO 怪物名称 原地图 原X 原Y 新地图 新X 新Y    20080123
//将指定坐标的怪物移动到新坐标，名称为ALL则移动该坐标所有怪物

procedure TPlayObject.CmdMOVEMOBTO(Cmd: pTGameCmd; sMonName, OleMap, NewMap: string; nX, nY, OnX, OnY: Integer);
var
  boMoveAll: Boolean;
  SrcEnvir, DenEnvir: TEnvirnoment;
  MonList: TList;
  MoveMon: TBaseObject;
  I: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMonName = '') or (OleMap = '') or (NewMap = '') or ((sMonName <> '') and (sMonName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandMOVEMOBTOHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  boMoveAll := False;
  if sMonName = 'ALL' then boMoveAll := True;
  if nX < 0 then nX := 0;
  if nY < 0 then nY := 0;
  if OnX < 0 then OnX := 0;
  if OnY < 0 then OnY := 0;

  SrcEnvir := g_MapManager.FindMap(OleMap); //原地图
  DenEnvir := g_MapManager.FindMap(NewMap); //新地图
  if (SrcEnvir = nil) or (DenEnvir = nil) then Exit;

  MonList := TList.Create;
  try
    if not boMoveAll then begin //指定名称的怪移动
      UserEngine.GetMapRangeMonster(SrcEnvir, OnX, OnY, 10, MonList); //查指定XY范围内的怪
      if MonList.Count > 0 then begin //20080629
        for I := 0 to MonList.Count - 1 do begin
          MoveMon := TBaseObject(MonList.Items[I]);
          if MoveMon <> Self then begin
            if CompareText(MoveMon.m_sCharName, sMonName) = 0 then //是否是指定名称的怪
              MoveMon.SpaceMove(NewMap, nX, nY, 0);
          end;
        end; //for
      end;
    end else begin //所有怪移动
      UserEngine.GetMapRangeMonster(SrcEnvir, OnX, OnY, 1000, MonList); //查指定XY范围内的怪
      if MonList.Count > 0 then begin //20091113 增加
        for I := 0 to MonList.Count - 1 do begin
          MoveMon := TBaseObject(MonList.Items[I]);
          if MoveMon <> Self then
            MoveMon.SpaceMove(NewMap, nX, nY, 0);
        end; //for
      end;
    end;
  finally
    MonList.Free;
  end;
end;
//------------------------------------------------------------------------------
//CLEARITEMMAP 地图 X Y 范围 物品名称
//(清除地图物品，ALL则清除所有)

procedure TPlayObject.CmdCLEARITEMMAP(Cmd: pTGameCmd; sMap, sItemName: string; nX, nY, nRange: Integer);
var
  I, nXX, nYY: Integer;
  boClearAll: Boolean;
  Envir: TEnvirnoment;
  MapItem: PTMapItem;
  ItemList: TList;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end; //200911113 修改
  if (sMap = '') or (sItemName = '') or (nX <= 0) or (nY <= 0) or (nRange <= 0) or ((sItemName <> '') and (sItemName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandCLEARITEMMAPHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  boClearAll := False;
  if sItemName = 'ALL' then boClearAll := True;
  Envir := g_MapManager.FindMap(sMap); //查找地图
  if Envir <> nil then begin
    ItemList := TList.Create;
    Envir.GetMapItem(nX, nY, nRange, ItemList); //取地图上指定范围的物品
    if not boClearAll then begin ///清除指定物品
      if ItemList.Count > 0 then begin //20080629
        for I := 0 to ItemList.Count - 1 do begin
          MapItem := pTMapItem(ItemList.Items[I]);
          if (CompareText(MapItem.name, sItemName) = 0) then begin
            for nXX := nX - nRange to nX + nRange do begin
              for nYY := nY - nRange to nY + nRange do begin
                Envir.DeleteFromMap(nXX, nYY, OS_ITEMOBJECT, TObject(MapItem));
                if TObject(MapItem) = nil then break;
              end;
            end;
          end;
        end; //for
      end;
    end else begin //清除全部物品
      if ItemList.Count > 0 then begin //20080629
        for I := 0 to ItemList.Count - 1 do begin
          MapItem := pTMapItem(ItemList.Items[I]);
          for nXX := nX - nRange to nX + nRange do begin
            for nYY := nY - nRange to nY + nRange do begin
              Envir.DeleteFromMap(nXX, nYY, OS_ITEMOBJECT, TObject(MapItem));
              if TObject(MapItem) = nil then break;
            end;
          end;
        end; //for
      end;
    end;
    ItemList.Free;
  end;
end;
//------------------------------------------------------------------------------

procedure TPlayObject.CmdReconnection(sCmd, sIPaddr, sPort: string);
//004CE380
begin
  if (m_btPermission < 10) then Exit;
  if (sIPaddr <> '') and (sIPaddr[1] = '?') then begin
    SysMsg('此命令用于改变客户端连接网关的IP及端口。', c_Blue, t_Hint);
    Exit;
  end;

  if (sIPaddr = '') or (sPort = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + sCmd + ' IP地址 端口', c_Red, t_Hint);
    Exit;
  end;
  if (sIPaddr <> '') and (sPort <> '') then begin
    SendMsg(Self, RM_RECONNECTION, 0, 0, 0, 0, sIPaddr + '/' + sPort);
  end;
end;

procedure TPlayObject.CmdRefineWeapon(Cmd: pTGameCmd; nDc, nMc, nSc, nHit: Integer); //004CD1C4
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (nDc + nMc + nSc) > 10 then Exit;
  if m_UseItems[U_WEAPON].wIndex <= 0 then Exit;
  m_UseItems[U_WEAPON].btValue[0] := nDc;
  m_UseItems[U_WEAPON].btValue[1] := nMc;
  m_UseItems[U_WEAPON].btValue[2] := nSc;
  m_UseItems[U_WEAPON].btValue[5] := nHit;
  SendUpdateItem(@m_UseItems[U_WEAPON]);
  RecalcAbilitys();
  CompareSuitItem(False); //200080729 套装
  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
  SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
  MainOutMessage('[武器调整]' + m_sCharName + ' DC:' + IntToStr(nDc) + ' MC' + IntToStr(nMc) + ' SC' + IntToStr(nSc) + ' HIT:' + IntToStr(nHit));
end;

procedure TPlayObject.CmdReGotoHuman(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandReGotoHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  SpaceMove(PlayObject.m_PEnvir.sMapName, PlayObject.m_nCurrX, PlayObject.m_nCurrY, 0);
end;

procedure TPlayObject.CmdReloadAbuse(sCmd: string; nPermission: Integer;
  sParam1: string);
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
end;

procedure TPlayObject.CmdReLoadAdmin(sCmd: string);
begin
  if (m_btPermission < 6) then Exit;
  FrmDB.LoadAdminList();
  //UserEngine.SendServerGroupMsg(213, nServerIndex, ''); //20101022 注释
  SysMsg('管理员列表重新加载成功...', c_Green, t_Hint);
end;
//重新加载指定行会

procedure TPlayObject.CmdReloadGuild(sCmd: string; nPermission: Integer; sParam1: string);
var
  Guild: TGUild;
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sParam1 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandReloadGuildHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  if nServerIndex <> 0 then begin
    SysMsg(g_sGameCommandReloadGuildOnMasterserver, c_Red, t_Hint);
    Exit;
  end;
  Guild := g_GuildManager.FindGuild(sParam1);
  if Guild = nil then begin
    SysMsg(Format_ToStr(g_sGameCommandReloadGuildNotFoundGuildMsg, [sParam1]), c_Red, t_Hint);
    Exit;
  end;
  Guild.LoadGuild();
  SysMsg(Format_ToStr(g_sGameCommandReloadGuildSuccessMsg, [sParam1]), c_Red, t_Hint);
  //UserEngine.SendServerGroupMsg(SS_207, nServerIndex, sParam1);//20101022 注释
end;

//重读公告

procedure TPlayObject.CmdReloadLineNotice(sCmd: string;
  nPermission: Integer; sParam1: string);
begin
  if (m_btPermission < nPermission) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  if LoadLineNotice(g_Config.sNoticeDir + 'LineNotice.txt') then begin
    SysMsg(g_sGameCommandReloadLineNoticeSuccessMsg, c_Green, t_Hint);
  end else begin
    SysMsg(g_sGameCommandReloadLineNoticeFailMsg, c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdReloadManage(Cmd: pTGameCmd; sParam: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam <> '') and (sParam[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  if sParam = '' then begin
    if g_ManageNPC <> nil then begin
      g_ManageNPC.ClearScript();
      g_ManageNPC.LoadNpcScript();
      SysMsg('重新加载登录脚本完成...', c_Green, t_Hint);
    end else begin
      SysMsg('重新加载登录脚本失败...', c_Green, t_Hint);
    end;
  end else begin
    if g_FunctionNPC <> nil then begin
      g_FunctionNPC.ClearScript();
      g_FunctionNPC.LoadNpcScript();
      SysMsg('重新加载功能脚本完成...', c_Green, t_Hint);
    end else begin
      SysMsg('重新加载功能脚本失败...', c_Green, t_Hint);
    end;
  end;
end;

procedure TPlayObject.CmdReloadRobot;
begin
  RobotManage.RELOADROBOT();
  SysMsg('重新加载机器人配置完成...', c_Green, t_Hint);
end;

procedure TPlayObject.CmdReloadRobotManage;
begin
  if (m_btPermission < 6) then Exit;
  if g_RobotNPC <> nil then begin
    g_RobotNPC.ClearScript();
    g_RobotNPC.LoadNpcScript();
    SysMsg('重新加载机器人专用脚本完成...', c_Green, t_Hint);
  end else begin
    SysMsg('重新加载机器人专用脚本失败...', c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdReloadMonItems;
var
  I: Integer;
  Monster: pTMonInfo;
begin
  if (m_btPermission < 6) then Exit;
  try
    if UserEngine.MonsterList.Count > 0 then begin
      for I := 0 to UserEngine.MonsterList.Count - 1 do begin
        Monster := UserEngine.MonsterList.Items[I];
        FrmDB.LoadMonitems(Monster.sName, Monster.ItemList);
      end;
    end;
    SysMsg('怪物爆物品列表重加载完成...', c_Green, t_Hint);
  except
    SysMsg('怪物爆物品列表重加载失败！', c_Green, t_Hint);
  end;
end;
//重新加载NPC
//命令格式: ReloadNpc NPC名称(All) 地图 X Y

procedure TPlayObject.CmdReloadNpc(sCmd: string; sParam, sParam2, sParam3, sParam4: string);
var
  I, nX, nY: Integer;
  TmpList: TList;
  Merchant: TMerchant;
  NPC: TNormNpc;
  Envir: TEnvirnoment;
begin
  if (m_btPermission < 6) then Exit;
  if ((sParam <> '') and (sParam[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [sCmd, 'NPC名称(ALL) 地图 X Y']), c_Red, t_Hint);
    Exit;
  end;
  if CompareText('all', sParam) = 0 then begin //重新加载全部NPC
    FrmDB.ReLoadMerchants();
    //UserEngine.ReloadMerchantList();//20100408 注释, FrmDB.ReLoadMerchants实现加载脚本，此过程可不使用
    SysMsg('交易NPC重新加载完成！', c_Red, t_Hint);
    UserEngine.ReloadNpcList();
    SysMsg('管理NPC重新加载完成！', c_Red, t_Hint);
    Exit;
  end;
  TmpList := TList.Create;
  try
    if (sParam <> '') and (sParam2 <> '') and (sParam3 <> '') and (sParam4 <> '') then begin
      Envir := g_MapManager.FindMap(sParam2); //查找地图场景
      if Envir <> nil then begin
        nX := Str_ToInt(sParam3, 0);
        nY := Str_ToInt(sParam4, 0);
        if UserEngine.GetMerchantList(Envir, nX, nY, 1, TmpList) > 0 then begin
          if TmpList.Count > 0 then begin //20091113 增加
            for I := 0 to TmpList.Count - 1 do begin
              Merchant := TMerchant(TmpList.Items[I]);
              if (CompareText(Merchant.m_sCharName, sParam) = 0) then begin
                Merchant.ClearScript;
                Merchant.LoadNpcScript;
                SysMsg(Merchant.m_sCharName + '重新加载成功...', c_Green, t_Hint);
                Break;
              end;
            end; // for
          end;
        end else begin
          TmpList.Clear;
          if UserEngine.GetNpcList(Envir, nX, nY, 1, TmpList) > 0 then begin
            if TmpList.Count > 0 then begin //20091113 增加
              for I := 0 to TmpList.Count - 1 do begin
                NPC := TNormNpc(TmpList.Items[I]);
                if (CompareText(NPC.m_sCharName, sParam) = 0) then begin
                  NPC.ClearScript;
                  NPC.LoadNpcScript;
                  SysMsg(NPC.m_sCharName + '重新加载成功...', c_Green, t_Hint);
                  Break;
                end;
              end; // for
            end;
          end else begin
            SysMsg('附近未发现任何管理NPC！', c_Red, t_Hint);
          end;
        end;
      end else SysMsg('地图不存在！', c_Red, t_Hint);
    end else begin
      if UserEngine.GetMerchantList(m_PEnvir, m_nCurrX, m_nCurrY, 9, TmpList) > 0 then begin
        if TmpList.Count > 0 then begin //20091113 增加
          for I := 0 to TmpList.Count - 1 do begin
            Merchant := TMerchant(TmpList.Items[I]);
            Merchant.ClearScript;
            Merchant.LoadNpcScript;
            SysMsg(Merchant.m_sCharName + '重新加载成功...', c_Green, t_Hint);
          end; // for
        end;
      end else begin
        SysMsg('附近未发现任何交易NPC！', c_Red, t_Hint);
      end;
      TmpList.Clear;
      if UserEngine.GetNpcList(m_PEnvir, m_nCurrX, m_nCurrY, 9, TmpList) > 0 then begin
        if TmpList.Count > 0 then begin //20091113 增加
          for I := 0 to TmpList.Count - 1 do begin
            NPC := TNormNpc(TmpList.Items[I]);
            NPC.ClearScript;
            NPC.LoadNpcScript;
            SysMsg(NPC.m_sCharName + '重新加载成功...', c_Green, t_Hint);
          end; // for
        end;
      end else begin
        SysMsg('附近未发现任何管理NPC！', c_Red, t_Hint);
      end;
    end;
  finally
    TmpList.Free;
  end;
end;

procedure TPlayObject.CmdSearchHuman(sCmd, sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if m_boProbeNecklace or (m_btPermission >= 6) then begin
    if (sHumanName = '') then begin
      if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + sCmd + ' 人物名称', c_Red, t_Hint);
      Exit;
    end;
    if ((GetTickCount - m_dwProbeTick) > 10000) or (m_btPermission >= 3) then begin
      m_dwProbeTick := GetTickCount();
      PlayObject := UserEngine.GetPlayObject(sHumanName);
      if PlayObject <> nil then begin
        SysMsg(sHumanName + ' 现在位于 ' + PlayObject.m_PEnvir.sMapDesc + ' ' + IntToStr(PlayObject.m_nCurrX) + ':' + IntToStr(PlayObject.m_nCurrY), c_Blue, t_Hint);
      end else begin
        SysMsg(sHumanName + ' 现在不在线，或位于其它服务器上！', c_Red, t_Hint);
      end;
    end else begin
      SysMsg(IntToStr((GetTickCount - m_dwProbeTick) div 1000 - 10) + ' 秒之后才可以再使用此功能！', c_Red, t_Hint);
    end;
  end else begin
    SysMsg('您现在还无法使用此功能！', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdShowSbkGold(Cmd: pTGameCmd; sCASTLENAME, sCtr, sGold: string);
var
  I: Integer;
  Ctr: Char;
  nGold: Integer;
  Castle: TUserCastle;
  List: TStringList;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sCASTLENAME <> '') and (sCASTLENAME[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  if sCASTLENAME = '' then begin
    List := TStringList.Create;
    try
      g_CastleManager.GetCastleGoldInfo(List);
      if List.Count > 0 then begin //20091113 增加
        for I := 0 to List.Count - 1 do SysMsg(List.Strings[I], c_Green, t_Hint);
      end;
    finally
      List.Free;
    end;
    Exit;
  end;
  Castle := g_CastleManager.Find(sCASTLENAME);
  if Castle = nil then begin
    SysMsg(Format_ToStr(g_sGameCommandSbkGoldCastleNotFoundMsg, [sCASTLENAME]), c_Red, t_Hint);
    Exit;
  end;

  Ctr := sCtr[1];
  nGold := Str_ToInt(sGold, -1);
  if not (Ctr in ['=', '-', '+']) or (nGold < 0) or (nGold > 100000000) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandSbkGoldHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  case Ctr of
    '=': Castle.m_nTotalGold := nGold;
    '-': Dec(Castle.m_nTotalGold);
    '+': Inc(Castle.m_nTotalGold, nGold);
  end;
  if Castle.m_nTotalGold < 0 then Castle.m_nTotalGold := 0;
end;

procedure TPlayObject.CmdShowUseItemInfo(Cmd: pTGameCmd;
  sHumanName: string);
var
  I: Integer;
  PlayObject: TPlayObject;
  UserItem: pTUserItem;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandShowUseItemInfoHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  for I := Low(PlayObject.m_UseItems) to High(PlayObject.m_UseItems) do begin
    UserItem := @PlayObject.m_UseItems[I];
    if UserItem.wIndex = 0 then Continue;
    SysMsg(Format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]',
      [GetUseItemName(I),
      UserEngine.GetStdItemName(UserItem.wIndex),
        UserItem.wIndex,
        UserItem.MakeIndex,
        UserItem.Dura,
        UserItem.DuraMax]),
        c_Blue, t_Hint);
  end;
end;
//参数：人物名称 物品类型 绑定方法

procedure TPlayObject.CmdBindUseItem(Cmd: pTGameCmd; sHumanName, sItem, sType: string);
var
  I: Integer;
  PlayObject: TPlayObject;
  UserItem: pTUserItem;
  nItem, nBind: Integer;
  ItemBind: pTItemBind;
  nItemIdx, nMakeIdex: Integer;
  sBindName: string;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  nBind := -1;
  nItem := GetUseItemIdx(sItem);
  if CompareText(sType, '帐号') = 0 then nBind := 0;
  if CompareText(sType, '人物') = 0 then nBind := 1;
  if CompareText(sType, 'IP') = 0 then nBind := 2;
  if CompareText(sType, '死亡') = 0 then nBind := 3; //死亡不爆出 20081127

  if (nItem < 0) or (nBind < 0) or (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandBindUseItemHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  UserItem := @PlayObject.m_UseItems[nItem];
  if UserItem.wIndex = 0 then begin
    SysMsg(Format_ToStr(g_sGameCommandBindUseItemNoItemMsg, [sHumanName, sItem]), c_Red, t_Hint);
    Exit;
  end;
  nItemIdx := UserItem.wIndex;
  nMakeIdex := UserItem.MakeIndex;
  case nBind of
    0: begin
        sBindName := PlayObject.m_sUserID;
        g_ItemBindAccount.Lock;
        try
          if g_ItemBindAccount.Count > 0 then begin //20091113 增加
            for I := 0 to g_ItemBindAccount.Count - 1 do begin
              ItemBind := g_ItemBindAccount.Items[I];
              if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then begin
                SysMsg(Format_ToStr(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]), c_Red, t_Hint);
                Exit;
              end;
            end; //for
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindAccount.Insert(0, ItemBind);
        finally
          g_ItemBindAccount.UnLock;
        end;
        SaveItemBindAccount();
        SysMsg(Format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
          [GetUseItemName(nItem), UserEngine.GetStdItemName(UserItem.wIndex),
          UserItem.wIndex, UserItem.MakeIndex, UserItem.Dura, UserItem.DuraMax, sBindName]), c_Blue, t_Hint);
        PlayObject.SysMsg(Format('您的%s[%s]已经绑定到%s[%s]上了。', [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex), sType, sBindName]), c_Blue, t_Hint);
      end;
    1: begin
        sBindName := PlayObject.m_sCharName;
        g_ItemBindCharName.Lock;
        try
          if g_ItemBindCharName.Count > 0 then begin //20091113 增加
            for I := 0 to g_ItemBindCharName.Count - 1 do begin
              ItemBind := g_ItemBindCharName.Items[I];
              if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then begin
                SysMsg(Format_ToStr(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]), c_Red, t_Hint);
                Exit;
              end;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindCharName.Insert(0, ItemBind);
        finally
          g_ItemBindCharName.UnLock;
        end;
        SaveItemBindCharName();
        SysMsg(Format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
          [GetUseItemName(nItem), UserEngine.GetStdItemName(UserItem.wIndex),
          UserItem.wIndex, UserItem.MakeIndex, UserItem.Dura,
            UserItem.DuraMax, sBindName]), c_Blue, t_Hint);
        PlayObject.SysMsg(Format('您的%s[%s]已经绑定到%s[%s]上了。',
          [GetUseItemName(nItem), UserEngine.GetStdItemName(UserItem.wIndex),
          sType, sBindName]), c_Blue, t_Hint);
      end;
    2: begin
        sBindName := PlayObject.m_sIPaddr;
        g_ItemBindIPaddr.Lock;
        try
          if g_ItemBindIPaddr.Count > 0 then begin //20080629
            for I := 0 to g_ItemBindIPaddr.Count - 1 do begin
              ItemBind := g_ItemBindIPaddr.Items[I];
              if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then begin
                SysMsg(Format_ToStr(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]), c_Red, t_Hint);
                Exit;
              end;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindIPaddr.Insert(0, ItemBind);
        finally
          g_ItemBindIPaddr.UnLock;
        end;
        SaveItemBindIPaddr();
        SysMsg(Format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
          [GetUseItemName(nItem), UserEngine.GetStdItemName(UserItem.wIndex),
          UserItem.wIndex, UserItem.MakeIndex, UserItem.Dura,
            UserItem.DuraMax, sBindName]), c_Blue, t_Hint);
        PlayObject.SysMsg(Format('您的%s[%s]已经绑定到%s[%s]上了。', [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex), sType, sBindName]), c_Blue, t_Hint);
      end;
    3: begin //人物装备死亡不爆绑定 20081127
        sBindName := PlayObject.m_sCharName;
        g_ItemBindDieNoDropName.Lock;
        try
          if g_ItemBindDieNoDropName.Count > 0 then begin //20091113 增加
            for I := 0 to g_ItemBindDieNoDropName.Count - 1 do begin
              ItemBind := g_ItemBindDieNoDropName.Items[I];
              if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.sBindName = sBindName) then begin
                SysMsg(Format_ToStr(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]), c_Red, t_Hint);
                Exit;
              end;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := 0;
          ItemBind.sBindName := sBindName;
          g_ItemBindDieNoDropName.Insert(0, ItemBind);
        finally
          g_ItemBindDieNoDropName.UnLock;
        end;
        SaveItemBindDieNoDropName(); //保存人物装备死亡不爆列表 20081127
        SysMsg(Format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，死亡不爆绑定到%s成功。',
          [GetUseItemName(nItem), UserEngine.GetStdItemName(UserItem.wIndex),
          UserItem.wIndex, UserItem.MakeIndex, UserItem.Dura,
            UserItem.DuraMax, sBindName]), c_Blue, t_Hint);
        PlayObject.SysMsg(Format('您的%s[%s]已经绑定到%s[%s]上了。',
          [GetUseItemName(nItem), UserEngine.GetStdItemName(UserItem.wIndex),
          sType, sBindName]), c_Blue, t_Hint);
      end;
  end;
end;
//解物品绑定

procedure TPlayObject.CmdUnBindUseItem(Cmd: pTGameCmd; sHumanName, sItem,
  sType: string);
var
  I: Integer;
  PlayObject: TPlayObject;
  UserItem: pTUserItem;
  nItem, nBind: Integer;
  ItemBind: pTItemBind;
  nItemIdx, nMakeIdex: Integer;
  sBindName: string;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  nBind := -1;
  nItem := GetUseItemIdx(sItem);
  if CompareText(sType, '帐号') = 0 then nBind := 0;
  if CompareText(sType, '人物') = 0 then nBind := 1;
  if CompareText(sType, 'IP') = 0 then nBind := 2;
  if CompareText(sType, '死亡') = 0 then nBind := 3; //死亡不爆出 20081127

  if (nItem < 0) or (nBind < 0) or (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandBindUseItemHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  UserItem := @PlayObject.m_UseItems[nItem];
  if UserItem.wIndex = 0 then begin
    SysMsg(Format_ToStr(g_sGameCommandBindUseItemNoItemMsg, [sHumanName, sItem]), c_Red, t_Hint);
    Exit;
  end;
  nItemIdx := UserItem.wIndex;
  nMakeIdex := UserItem.MakeIndex;
  case nBind of //
    0: begin
        sBindName := PlayObject.m_sUserID;
        g_ItemBindAccount.Lock;
        try
          if g_ItemBindAccount.Count > 0 then begin //20080629
            for I := 0 to g_ItemBindAccount.Count - 1 do begin
              ItemBind := g_ItemBindAccount.Items[I];
              if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then begin
                SysMsg(Format_ToStr(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]), c_Red, t_Hint);
                Exit;
              end;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindAccount.Insert(0, ItemBind);
        finally
          g_ItemBindAccount.UnLock;
        end;
        SaveItemBindAccount();
        SysMsg(Format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex,
            UserItem.MakeIndex,
            UserItem.Dura,
            UserItem.DuraMax,
            sBindName]),
            c_Blue, t_Hint);
        PlayObject.SysMsg(Format('您的%s[%s]已经绑定到%s[%s]上了。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            sType,
            sBindName
            ]), c_Blue, t_Hint);
      end;
    1: begin
        sBindName := PlayObject.m_sCharName;
        g_ItemBindCharName.Lock;
        try
          if g_ItemBindCharName.Count > 0 then begin //20080629
            for I := 0 to g_ItemBindCharName.Count - 1 do begin
              ItemBind := g_ItemBindCharName.Items[I];
              if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then begin
                SysMsg(Format_ToStr(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]), c_Red, t_Hint);
                Exit;
              end;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindCharName.Insert(0, ItemBind);
        finally
          g_ItemBindCharName.UnLock;
        end;
        SaveItemBindCharName();
        SysMsg(Format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex,
            UserItem.MakeIndex,
            UserItem.Dura,
            UserItem.DuraMax,
            sBindName]),
            c_Blue, t_Hint);
        PlayObject.SysMsg(Format('您的%s[%s]已经绑定到%s[%s]上了。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            sType,
            sBindName
            ]), c_Blue, t_Hint);
      end;
    2: begin
        sBindName := PlayObject.m_sIPaddr;
        g_ItemBindIPaddr.Lock;
        try
          if g_ItemBindIPaddr.Count > 0 then begin //20080629
            for I := 0 to g_ItemBindIPaddr.Count - 1 do begin
              ItemBind := g_ItemBindIPaddr.Items[I];
              if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then begin
                SysMsg(Format_ToStr(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]), c_Red, t_Hint);
                Exit;
              end;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindIPaddr.Insert(0, ItemBind);
        finally
          g_ItemBindIPaddr.UnLock;
        end;
        SaveItemBindIPaddr();
        SysMsg(Format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex,
            UserItem.MakeIndex,
            UserItem.Dura,
            UserItem.DuraMax,
            sBindName]),
            c_Blue, t_Hint);
        PlayObject.SysMsg(Format('您的%s[%s]已经绑定到%s[%s]上了。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            sType,
            sBindName
            ]), c_Blue, t_Hint);
      end;
    3: begin //人物装备死亡不爆绑定 20081127
        sBindName := PlayObject.m_sCharName;
        g_ItemBindDieNoDropName.Lock;
        try
          if g_ItemBindDieNoDropName.Count > 0 then begin
            for I := 0 to g_ItemBindDieNoDropName.Count - 1 do begin
              ItemBind := g_ItemBindDieNoDropName.Items[I];
              if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.sBindName = sBindName) then begin
                SysMsg(Format_ToStr(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]), c_Red, t_Hint);
                Exit;
              end;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := 0;
          ItemBind.sBindName := sBindName;
          g_ItemBindDieNoDropName.Insert(0, ItemBind);
        finally
          g_ItemBindDieNoDropName.UnLock;
        end;
        SaveItemBindDieNoDropName(); //保存人物装备死亡不爆列表 20081127
        SysMsg(Format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
          [GetUseItemName(nItem), UserEngine.GetStdItemName(UserItem.wIndex),
          UserItem.wIndex, UserItem.MakeIndex, UserItem.Dura, UserItem.DuraMax,
            sBindName]), c_Blue, t_Hint);
        PlayObject.SysMsg(Format('您的%s[%s]已经绑定到%s[%s]上了。', [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex), sType, sBindName]), c_Blue, t_Hint);
      end;
  end;
end;

procedure TPlayObject.CmdShutup(Cmd: pTGameCmd; sHumanName, sTime: string);
var
  dwTime: LongWord;
  nIndex: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sTime = '') or (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandShutupHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  dwTime := Str_ToInt(sTime, 5);
  g_DenySayMsgList.Lock;
  try
    nIndex := g_DenySayMsgList.GetIndex(sHumanName);
    if nIndex >= 0 then begin
      g_DenySayMsgList.Objects[nIndex] := TObject(GetTickCount + dwTime * 60000 {60 * 1000});
    end else begin
      g_DenySayMsgList.AddRecord(sHumanName, GetTickCount + dwTime * 60000 {60 * 1000});
    end;
  finally
    g_DenySayMsgList.UnLock;
  end;
  SysMsg(Format_ToStr(g_sGameCommandShutupHumanMsg, [sHumanName, dwTime]), c_Red, t_Hint);
end;

procedure TPlayObject.CmdShutupList(Cmd: pTGameCmd; sParam1: string);
var
  I: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    Exit;
  end;

  if (m_btPermission < 6) then Exit;
  g_DenySayMsgList.Lock;
  try
    if g_DenySayMsgList.Count <= 0 then begin
      SysMsg(g_sGameCommandShutupListIsNullMsg, c_Green, t_Hint);
      Exit;
    end;
    for I := 0 to g_DenySayMsgList.Count - 1 do begin
      SysMsg(g_DenySayMsgList.Strings[I] + ' ' + IntToStr((LongWord(g_DenySayMsgList.Objects[I]) - GetTickCount) div 60000), c_Green, t_Hint);
    end;
  finally
    g_DenySayMsgList.UnLock;
  end;
end;

procedure TPlayObject.CmdShutupRelease(Cmd: pTGameCmd; sHumanName: string; boAll: Boolean);
var
  I: Integer;
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandShutupReleaseHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  g_DenySayMsgList.Lock;
  try
    I := g_DenySayMsgList.GetIndex(sHumanName);
    if I >= 0 then begin
      g_DenySayMsgList.Delete(I);
      PlayObject := UserEngine.GetPlayObject(sHumanName);
      if PlayObject <> nil then begin
        PlayObject.SysMsg(g_sGameCommandShutupReleaseCanSendMsg, c_Red, t_Hint);
      end;
      {if boAll then begin
        UserEngine.SendServerGroupMsg(SS_210, nServerIndex, sHumanName); //20101022 注释
      end; }
      SysMsg(Format_ToStr(g_sGameCommandShutupReleaseHumanCanSendMsg, [sHumanName]), c_Green, t_Hint);
    end;
  finally
    g_DenySayMsgList.UnLock;
  end;
end;
//调整身上装备附加属性 参数16为吸伤属性  @SUPERMAKE
//17-附加鉴定属性(只要可鉴定的物品即可上属性,神技重复则不上属性)

procedure TPlayObject.CmdSmakeItem(Cmd: pTGameCmd; nWhere, nValueType, nValue: Integer);
var
  sShowMsg: string;
  StdItem: pTStdItem;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;

  if (nWhere in [0..14]) and (nValueType in [0..17]) and (nValue in [0..255]) then begin //20080417 支持斗笠,0..12改0..13
    if m_UseItems[nWhere].wIndex > 0 then begin
      StdItem := UserEngine.GetStdItem(m_UseItems[nWhere].wIndex);
      if StdItem = nil then Exit;

      m_UseItems[nWhere].btValue[9] := _MIN(255, m_UseItems[nWhere].btValue[9] + 1); //累积升级次数 20080816
      if (nValueType = 16) and ((StdItem.Shape = 188) or (StdItem.Shape = 203)) then begin //吸伤属性 20080324
        if nWhere <> U_WEAPON then begin //武器位不能有吸伤属性 20101007
          m_UseItems[nWhere].btValue[20] := nValue; //吸伤属性
          if m_UseItems[nWhere].btValue[20] > 100 then m_UseItems[nWhere].btValue[20] := 100;
        end;
      end else
        if (nValueType > 13) and (nValueType < 16) then begin
          nValue := _MIN(65, nValue);
          if nValueType = 14 then m_UseItems[nWhere].Dura := nValue * 1000;
          if nValueType = 15 then m_UseItems[nWhere].DuraMax := nValue * 1000;
        end else begin
          case nValueType of
            17: begin //附加鉴定属性 20110724
                if (m_UseItems[nWhere].btAppraisalLevel in [1..3, 11..13, 21..23, 31..33, 41..43, 51..53]) then begin //可鉴定物品
                  case nValue of
                    1..7, 255: begin
                        if (m_UseItems[nWhere].btUnKnowValue[6] <> nValue) and
                          (m_UseItems[nWhere].btUnKnowValue[7] <> nValue) and
                          (m_UseItems[nWhere].btUnKnowValue[8] <> nValue) and
                          (m_UseItems[nWhere].btUnKnowValue[9] <> nValue) and
                          (m_UseItems[nWhere].btUnKnowValueCount < 4) then begin //判断属性是否重复
                          if m_UseItems[nWhere].btUnKnowValue[6] = 0 then begin
                            m_UseItems[nWhere].btUnKnowValue[6] := nValue;
                            Inc(m_UseItems[nWhere].btUnKnowValueCount);
                            Inc(m_UseItems[nWhere].btAppraisalLevel);
                          end else
                            if m_UseItems[nWhere].btUnKnowValue[7] = 0 then begin
                              m_UseItems[nWhere].btUnKnowValue[7] := nValue;
                              Inc(m_UseItems[nWhere].btUnKnowValueCount);
                              Inc(m_UseItems[nWhere].btAppraisalLevel);
                            end else
                              if m_UseItems[nWhere].btUnKnowValue[8] = 0 then begin
                                m_UseItems[nWhere].btUnKnowValue[8] := nValue;
                                Inc(m_UseItems[nWhere].btUnKnowValueCount);
                                Inc(m_UseItems[nWhere].btAppraisalLevel);
                              end else
                                if m_UseItems[nWhere].btUnKnowValue[9] = 0 then begin
                                  m_UseItems[nWhere].btUnKnowValue[9] := nValue;
                                  Inc(m_UseItems[nWhere].btUnKnowValueCount);
                                  Inc(m_UseItems[nWhere].btAppraisalLevel);
                                end;
                        end;
                      end;
                    11..230: begin
                        if (m_UseItems[nWhere].btAppraisalValue[2] = 0) then begin
                          m_UseItems[nWhere].btAppraisalValue[2] := nValue;
                          Inc(m_UseItems[nWhere].btAppraisalLevel);
                        end else
                          if (m_UseItems[nWhere].btAppraisalValue[3] = 0) then begin
                            m_UseItems[nWhere].btAppraisalValue[3] := nValue;
                            Inc(m_UseItems[nWhere].btAppraisalLevel);
                          end else
                            if (m_UseItems[nWhere].btAppraisalValue[4] = 0) then begin
                              m_UseItems[nWhere].btAppraisalValue[4] := nValue;
                              Inc(m_UseItems[nWhere].btAppraisalLevel);
                            end else
                              if (m_UseItems[nWhere].btAppraisalValue[5] = 0) then begin
                                m_UseItems[nWhere].btAppraisalValue[5] := nValue;
                                Inc(m_UseItems[nWhere].btAppraisalLevel);
                              end;
                      end;
                  end;
                end;
              end;
          else m_UseItems[nWhere].btValue[nValueType] := nValue;
          end;
        end;
      RecalcAbilitys();
      CompareSuitItem(False); //200080729 套装
      SendUpdateItem(@m_UseItems[nWhere]);
      if g_Config.boShowMakeItemMsg then begin //20080927 修改
        sShowMsg := IntToStr(m_UseItems[nWhere].wIndex) + '-' + IntToStr(m_UseItems[nWhere].MakeIndex) + ' ' +
          IntToStr(m_UseItems[nWhere].Dura) + '/' + IntToStr(m_UseItems[nWhere].DuraMax) + ' ' +
          IntToStr(m_UseItems[nWhere].btValue[0]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[1]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[2]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[3]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[4]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[5]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[6]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[7]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[8]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[9]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[10]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[11]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[12]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[13]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[20]);
        MainOutMessage('[物品调整] ' + m_sCharName + '(' + StdItem.Name + ' -> ' + sShowMsg + ')');
      end;
    end else begin
      SysMsg(g_sGamecommandSuperMakeHelpMsg, c_Red, t_Hint);
    end;
  end;
end;

procedure TPlayObject.CmdSpirtStart(sCmd, sParam1: string);
var
  nTime: Integer;
  dwTime: LongWord;
begin
  if (m_btPermission < 6) then Exit;
  if (sParam1 <> '') and (sParam1[1] = '?') then begin
    SysMsg('此命令用于开始祈祷生效宝宝叛变。', c_Red, t_Hint);
    Exit;
  end;
  nTime := Str_ToInt(sParam1, -1);
  if nTime > 0 then begin
    dwTime := LongWord(nTime) * 1000;
  end else begin
    dwTime := g_Config.dwSpiritMutinyTime;
  end;
  g_dwSpiritMutinyTick := GetTickCount + dwTime;
  SysMsg('祈祷叛变已开始。持续时长 ' + IntToStr(dwTime div 1000) + ' 秒。', c_Green, t_Hint);
end;

procedure TPlayObject.CmdSpirtStop(sCmd, sParam1: string);
begin
  if (m_btPermission < 6) then Exit;
  if {(sParam1 <> '') and}(sParam1[1] = '?') then begin
    SysMsg('此命令用于停止祈祷生效导致宝宝叛变。', c_Red, t_Hint);
    Exit;
  end;
  g_dwSpiritMutinyTick := 0;
  SysMsg('祈祷叛变已停止。', c_Green, t_Hint);
end;

procedure TPlayObject.CmdStartQuest(Cmd: pTGameCmd; sQuestName: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sQuestName = '') then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + Cmd.sCmd + ' 问答名称', c_Red, t_Hint);
    Exit;
  end;
  UserEngine.SendQuestMsg(sQuestName);
end;

procedure TPlayObject.CmdSuperTing(Cmd: pTGameCmd; sHumanName, sRange: string);
var
  I: Integer;
  PlayObject: TPlayObject;
  MoveHuman: TPlayObject;
  nRange: Integer;
  HumanList: TList;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sRange = '') or (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandSuperTingHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  nRange := _MAX(10, Str_ToInt(sRange, 2));
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    HumanList := TList.Create;
    try
      UserEngine.GetMapRageHuman(PlayObject.m_PEnvir, PlayObject.m_nCurrX, PlayObject.m_nCurrY, nRange, HumanList);
      if HumanList.Count > 0 then begin //20080629
        for I := 0 to HumanList.Count - 1 do begin
          MoveHuman := TPlayObject(HumanList.Items[I]);
          if MoveHuman <> Self then
            MoveHuman.MapRandomMove(MoveHuman.m_sHomeMap, 0);
        end; //for
      end;
    finally
      HumanList.Free;
    end;
  end else begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdTakeOffHorse(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    if g_Config.boGMShowFailMsg then begin
      SysMsg('下马命令，在骑马状态输入此命令下马。', c_Red, t_Hint);
      SysMsg(Format('命令格式: @%s', [sCmd]), c_Red, t_Hint);
    end;
    Exit;
  end;
  if not m_boOnHorse then Exit;
  m_boOnHorse := False;
  FeatureChanged();
end;

procedure TPlayObject.CmdTakeOnHorse(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    if g_Config.boGMShowFailMsg then begin
      SysMsg('上马命令，在戴好马牌后输入此命令就可以骑上马。', c_Red, t_Hint);
      SysMsg(Format('命令格式: @%s', [sCmd]), c_Red, t_Hint);
    end;
    Exit;
  end;
  if m_boShop then begin
    SysMsg('请先取消摆摊状态。', c_Red, t_Hint);
    exit;
  end;
  if m_boOnHorse then Exit;
  if (m_btHorseType = 0) then begin
    SysMsg('骑马必须先戴上马牌！', c_Red, t_Hint);
    Exit;
  end;
  m_boOnHorse := True;
  FeatureChanged();
end;

procedure TPlayObject.CmdTestFire(sCmd: string; nRange, nType, nTime, nPoint: Integer);
var
  nX, nY: Integer;
  FireBurnEvent: TFireBurnEvent;
  nMinX, nMaxX, nMinY, nMaxY: Integer;
begin
  nMinX := m_nCurrX - nRange;
  nMaxX := m_nCurrX + nRange;
  nMinY := m_nCurrY - nRange;
  nMaxY := m_nCurrY + nRange;
  for nX := nMinX to nMaxX do begin
    for nY := nMinY to nMaxY do begin
      if ((nX < nMaxX) and (nY = nMinY)) or
        ((nY < nMaxY) and (nX = nMinX)) or
        (nX = nMaxX) or (nY = nMaxY) then begin
        FireBurnEvent := TFireBurnEvent.Create(Self, nX, nY, nType, nTime * 1000, nPoint);
        g_EventManager.AddEvent(FireBurnEvent);
      end;
    end;
  end;
end;

procedure TPlayObject.CmdTestGetBagItems(Cmd: pTGameCmd; sParam: string);
var
  btDc, btSc, btMc, btDura: Byte;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sParam <> '') and (sParam[1] = '?') then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandTestGetBagItemsHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  btDc := 0;
  btSc := 0;
  btMc := 0;
  btDura := 0;
  GetBagUseItems(btDc, btSc, btMc, btDura);
  SysMsg(Format('DC:%d SC:%d MC:%d DURA:%d', [btDc, btSc, btMc, btDura]), c_Blue, t_Hint);
end;

procedure TPlayObject.CmdTestSpeedMode(Cmd: pTGameCmd);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  m_boTestSpeedMode := not m_boTestSpeedMode;
  if m_boTestSpeedMode then begin
    SysMsg('开启速度测试模式', c_Red, t_Hint);
  end else begin
    SysMsg('关闭速度测试模式', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdTestStatus(sCmd: string; nType, nTime: Integer);
begin
  if (m_btPermission < 6) then Exit;
  if (not (nType in [Low(TStatusTime)..High(TStatusTime)])) or (nTime < 0) then begin
    if g_Config.boGMShowFailMsg then SysMsg('命令格式: @' + sCmd + ' 类型(0..11) 时长', c_Red, t_Hint);
    Exit;
  end;
  m_wStatusTimeArr[nType] := nTime;
  m_dwStatusArrTick[nType] := GetTickCount();
  m_nCharStatus := GetCharStatus();
  StatusChanged('');
  SysMsg(Format('状态编号:%d 时间长度: %d 秒', [nType, nTime]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdTing(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandTingHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then begin
    PlayObject.MapRandomMove(m_sHomeMap, 0);
  end else begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

{procedure TPlayObject.CmdTraining(sSkillName: string; nLevel: Integer); //004CC414
begin
  if (m_btPermission < 6) then Exit;
end; }

procedure TPlayObject.CmdUserMoveXY(sCmd, sX, sY: string);
var
  nX, nY: Integer;
  StdItem: pTStdItem;
begin
  if m_boTeleport then begin //传送戒指
    nX := Str_ToInt(sX, -1);
    nY := Str_ToInt(sY, -1);
    if not m_PEnvir.m_boNOPOSITIONMOVE then begin
      if m_PEnvir.CanWalkOfItem(nX, nY, g_Config.boUserMoveCanDupObj, g_Config.boUserMoveCanOnItem) then begin
        if (GetTickCount - m_dwTeleportTick) > g_Config.dwUserMoveTime * 1000 then begin
          m_dwTeleportTick := GetTickCount();
          if (m_UseItems[U_BUJUK].wIndex > 0) and (m_UseItems[U_BUJUK].Dura > 0) then begin //增加传送符功能
            StdItem := UserEngine.GetStdItem(m_UseItems[U_BUJUK].wIndex);
            if (StdItem.StdMode = 25) and (StdItem.Shape = 6) then begin //传送符
              if m_UseItems[U_BUJUK].Dura > 100 then begin
                Dec(m_UseItems[U_BUJUK].Dura, 100);
              end else begin
                SendDelItems(@m_UseItems[U_BUJUK]);
                m_UseItems[U_BUJUK].wIndex := 0;
                m_UseItems[U_BUJUK].Dura := 0;
                RecalcAbilitys(); //20100223 增加，修正物品持久完后，还可以使用功能
                CompareSuitItem(False); //20100223 增加
              end;
              SendMsg(Self, RM_DURACHANGE, U_BUJUK, m_UseItems[U_BUJUK].Dura, m_UseItems[U_BUJUK].DuraMax, 0, '');
              SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
              if (nX < 0) or (nY < 0) then begin
                RandomMove;
              end else begin
                SpaceMove(m_sMapName, nX, nY, 0);
              end;
              Exit;
            end;
          end;
          SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
          if (nX < 0) or (nY < 0) then begin
            RandomMove;
          end else begin
            SpaceMove(m_sMapName, nX, nY, 0);
          end;
        end else begin
          SysMsg(IntToStr(g_Config.dwUserMoveTime - (GetTickCount - m_dwTeleportTick) div 1000) + '秒之后才可以再使用此功能！', c_Red, t_Hint);
        end;
      end else begin
        SysMsg(Format_ToStr(g_sGameCommandPositionMoveCanotMoveToMap, [m_sMapName, sX, sY]), c_Green, t_Hint);
      end;
    end else begin
      SysMsg('此地图禁止使用此命令！', c_Red, t_Hint);
    end;
  end else begin
    SysMsg('您现在还无法使用此功能！', c_Red, t_Hint);
  end;
end;
{//未使用 20080823
procedure TPlayObject.CmdViewDiary(sCmd: string; nFlag: Integer);
begin

end;}

procedure TPlayObject.CmdViewWhisper(Cmd: pTGameCmd; sCharName, sParam2: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sCharName = '') or ((sCharName <> '') and (sCharName[1] = '?')) then begin
    if g_Config.boGMShowFailMsg then SysMsg(Format_ToStr(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandViewWhisperHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sCharName);
  if PlayObject <> nil then begin
    if PlayObject.m_GetWhisperHuman = Self then begin
      PlayObject.m_GetWhisperHuman := nil;
      SysMsg(Format_ToStr(g_sGameCommandViewWhisperMsg1, [sCharName]), c_Green, t_Hint);
    end else begin
      PlayObject.m_GetWhisperHuman := Self;
      SysMsg(Format_ToStr(g_sGameCommandViewWhisperMsg2, [sCharName]), c_Green, t_Hint);
    end;
  end else begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sCharName]), c_Red, t_Hint);
  end;
end;

constructor TPlayObject.Create;
begin
  inherited;
  m_M2AutoCreate := False; //20090318 M2直接挂假人
  m_btRaceServer := RC_PLAYOBJECT;
  m_boEmergencyClose := False;
  m_boSwitchData := False;
  m_boReconnection := False;
  m_boKickFlag := False;
  m_boSoftClose := False;
  m_boReadyRun := False;
  m_dwSaveRcdTick := GetTickCount();
  m_boWantRefMsg := True;
  m_boRcdSaveding := False; //是否正在保存数据 20090106
  m_boRcdSaved := False;
  m_boDieInFight3Zone := False;
  m_Script := nil;
  m_boTimeRecall := False;
  m_sMoveMap := '';
  m_nMoveX := 0;
  m_nMoveY := 0;
  m_sLastMapName := ''; //人物死亡地图
  m_nLastCurrX := 0; //人物死亡地图所在座标X
  m_nLastCurrY := 0; //人物死亡地图所在座标Y

  m_boBuyShopItem := False; //正在购买商铺物品中 20090114
  m_boDealing := False;
  m_DealCreat := nil;

  m_GroupOwner := nil;
  m_GroupMembers := TStringList.Create;
  m_boHearWhisper := True;
  m_boBanShout := True;
  m_boBanGmMsg := True; //允许接收所有喊话 20080211
  m_boBanGuildChat := True;
  m_boAllowDeal := True;
  m_boAllowGroupReCall := False;
  m_BlockWhisperList := TStringList.Create;
  m_wGroupRcallTime := 0;
  m_dwGroupRcallTick := GetTickCount();

  m_SellOffItemList := TList.Create; //元宝寄售物品列表 20080316
  m_dwCheckItmeDayTick := GetTickCount(); //处理物品时间的间隔
{$IF M2Version <> 2}
  m_MyDivision := nil; //我的师门
  m_nApplyDivisionPage := 0; //申请入门派当前页数
  m_boHeartActive := False; //心法增加属性
  m_MagicSkill_105 := nil; //龙卫心法
  m_MagicSkill_106 := nil; //传承心法
  m_MagicSkill_107 := nil; //纵横剑术
  m_MagicSkill_108 := nil; //冰霜雪雨
  m_MagicSkill_109 := nil; //裂神符
  m_MagicSkill_113 := nil; //天雷乱舞
  m_SkillHit_113 := 0; //天雷攻击次数(吟唱状态)
  m_SkillHit_X := 0;
  m_SkillHit_Y := 0;
  dw_SkillHitTick := GetTickCount();
  m_sHeartName := ''; //心法名称
  m_nHeartType := 0; //心法类型
  m_Contribution := 0; //贡献值
  mHeartSkillTick := GetTickCount();

  m_RefineItemList := TList.Create; //淬练物品列表 20080502
  FillChar(m_wHumTitles, SizeOf(THumTitles), #0); //人物称号
  m_boCanTitle := False; //是否有称号(取值时，判断，以不必每个人都再次处理)
  m_boUseTitle := False; //当前是否使用称号(用于发群体消息时，判断使用)
  m_boUseIitleIdx := 0; //当前使用称号的图片索引(用于发群体消息时，判断使用)
  m_sUseIitleName := '';
  m_dwUseTitleTick := GetTickCount(); //处理称号时间的间隔
  m_boFengHaoPower := False; //封号增加攻击倍率
  m_nFengHaoMinPowerRate := 0; //封号最低攻击倍率
  m_nFengHaoMaxPowerRate := 0; //封号最高攻击倍率
  m_nDieCount := 0; //一天死亡次数(包括英雄),超过3次则攻击倍率恢复正常
  m_GroupOwnerExp := False; //组队队长,经验翻倍
  m_boShowFengHao := False; //是否显示称号
  m_boFengHaoMagicEffect := False; //魔法粉红效果(传奇之星)
  m_ComradeList := TStringList.Create; //龙卫列表
  m_HuhuaList := TStringList.Create; //护花使者列表
  m_boFengHaoHuhua := False; //护花使者称号
  m_sHuhuaName := ''; //对应的传奇之星名字
  m_boFengHaoDominate := False; //主宰称号
  m_boFengHaoComrade := False; //主宰龙卫
  m_sDominateName := ''; //对应的主宰名字
  m_boCallFengHaoPlay := False; //是否正在召唤或传送人员
  m_boSendDominateMapName := False; //是否发送过地图列表
  m_boOpenDominateToken := False; //是否打开主宰令牌
  m_boFengHaoAgree := False; //是否发送过确认信息
  m_nFenghaotype := 0; //确认后触发类型标识,QF段 @FENGHAOAGREE+类型
  m_sFenghaoName := ''; //发送确认人名
{$IFEND}
  m_DealItemList := TList.Create;
  m_nDealGolds := 0;
  m_dwStorageType := 0; //打开的仓库类型 1-移动仓库 2-无限仓库 20090901
  m_StorageItemList := TList.Create;
  m_boAllowGroup := False;
  m_boAllowGuild := False;
  m_dwShoutMsgTick := 0;

  m_dwRunTick := GetTickCount();
  m_nRunTime := 250;
  m_dwSearchTime := 1000;
  m_dwSearchTick := GetTickCount();
  m_nViewRange := 12;
  m_boNewHuman := False;
  m_boLoginNoticeOK := False;
  bo6AB := False;
  m_boExpire := False;
  m_boSendNotice := False;
  m_dwCheckDupObjTick := GetTickCount();
  dwTick578 := GetTickCount();
  m_boInSafeArea := False;
  m_dwMagicAttackTick := GetTickCount();
  m_dwMagicAttackInterval := 0;
  m_dwAttackTick := GetTickCount();
  m_dwMoveTick := GetTickCount();
  m_dwTurnTick := GetTickCount();
  m_dwActionTick := GetTickCount();
  m_dwAttackCount := 0;
  m_dwAttackCountA := 0;
  m_dwMagicAttackCount := 0;
  m_dwMoveCount := 0;
  m_dwMoveCountA := 0;
  m_nOverSpeedCount := 0;

  //m_sOldSayMsg := '';//未使用 20080329
  m_dwSayMsgTick := GetTickCount();
  m_boDisableSayMsg := False;
  m_dwDisableSayMsgTick := GetTickCount();
  m_dLogonTime := Now();
  m_dwLogonTick := GetTickCount();
  m_boSwitchData := False;
  m_boSwitchDataSended := False;
  m_nWriteChgDataErrCount := 0;
  m_dwShowLineNoticeTick := GetTickCount();
  m_nShowLineNoticeIdx := 0;
  m_nShowHangAutoMsgIdx := 0; //挂机自动回复信息的ID
  m_nSoftVersionDateEx := 0;
  m_CanJmpScriptLableList := TStringList.Create;
  m_nKillMonExpRate := 100;
  m_nOldKillMonExpRate := m_nKillMonExpRate; //20080607
  m_nItmeIncMonExpRate := 0; //使用套装增加的经验 20080607
  m_dwRateTick := GetTickCount();
  m_nPowerRate := 100;
  m_boSetStoragePwd := False;
  m_boReConfigPwd := False;
  m_boCheckOldPwd := False;
  m_boUnLockPwd := False;
  m_boUnLockStoragePwd := False;
  m_boPasswordLocked := False; //锁仓库
  m_btPwdFailCount := 0;
  m_sTempPwd := '';
  m_sStoragePwd := ''; ;
  m_boFilterSendMsg := False;
  m_boCanDeal := True;
  m_boCanDrop := True;
  m_boCanGetBackItem := True;
  m_boCanWalk := True;
  m_boCanRun := True;
  m_boCanHit := True;
  m_boCanSpell := True;
  m_boCanUseItem := True;
  m_nMemberType := 0;
  m_nMemberLevel := 0;

  m_nGameGold := 0;
  m_nGameDiaMond := 0; //20071226 金刚石
  m_nGameGird := 0; //20071226 灵符

  m_nDecGameGird := 0; //一次减灵符数 20100818
  m_nDecGameGirdCount := 0; //减灵符次数 20100818
  m_nDecGameGirdCount_95 := 0; //主体修炼神冲穴次数
  m_nDecGameGirdCount_Hero95 := 0; //英雄修炼神冲穴次数

  m_boDecGameGold := False;
  m_nDecGameGold := 1;
  m_dwDecGameGoldTick := GetTickCount();
  m_dwDecGameGoldTime := 60000 {60 * 1000};

  m_boIncGameGold := False;
  m_nIncGameGold := 1;
  m_dwIncGameGoldTick := GetTickCount();
  m_dwIncGameGoldTime := 60000 {60 * 1000};

  m_nGamePoint := 0;
  m_dwIncGamePointTick := GetTickCount();
  m_dwDecGamePointTick := GetTickCount(); //20080413

  m_nPayMentPoint := 0;
  m_dwPayMentPointTick := GetTickCount(); //秒卡点间隔

  m_DearHuman := nil;
  m_MasterHuman := nil;
  m_MasterList := TList.Create;
  m_boSendMsgFlag := False;
  m_boChangeItemNameFlag := False;

  m_boCanMasterRecall := False;
  m_boCanDearRecall := False;
  m_dwDearRecallTick := GetTickCount();
  m_dwMasterRecallTick := GetTickCount();
  m_btReColorIdx := 0;
  m_GetWhisperHuman := nil;
  m_boOnHorse := False;
  m_wContribution := 0;
  m_sRankLevelName := g_sRankLevelName;
  m_boFixedHideMode := True;
  //m_nStep := 0;
  FillChar(m_nMval, SizeOf(m_nMval), #0);
  m_nClientFlagMode := -1;
  m_dwAutoGetExpTick := GetTickCount;
  m_nAutoGetExpPoint := 0;
  m_AutoGetExpEnvir := nil;
  //m_dwHitIntervalTime := g_Config.dwHitIntervalTime; //攻击间隔  20080826 未使用
  m_dwMagicHitIntervalTime := g_Config.dwMagicHitIntervalTime; //魔法间隔
  m_dwRunIntervalTime := g_Config.dwRunIntervalTime; //跑间隔
  m_dwWalkIntervalTime := g_Config.dwWalkIntervalTime; //走路间隔
  m_dwTurnIntervalTime := g_Config.dwTurnIntervalTime; //换方向间隔
  m_dwActionIntervalTime := g_Config.dwActionIntervalTime; //组合操作间隔
  m_dwRunLongHitIntervalTime := g_Config.dwRunLongHitIntervalTime; //组合操作间隔
  m_dwRunHitIntervalTime := g_Config.dwRunHitIntervalTime; //组合操作间隔
  m_dwWalkHitIntervalTime := g_Config.dwWalkHitIntervalTime; //组合操作间隔
  m_dwRunMagicIntervalTime := g_Config.dwRunMagicIntervalTime; //跑位魔法间隔
  m_DynamicVarList := TList.Create;
  m_boTestSpeedMode := False;
  m_boLockLogon := True;
  m_boLockLogoned := False;

  m_boRemoteMsg := False; //是否允许接受消息

  m_boNotOnlineAddExp := False; //是否是离线挂机人物
  m_boStartAutoAddExpPoint := False; //是否开始增加经验
  m_dwStartNotOnlineAddExpTime := 0; //离线挂机开始时间
  m_dwNotOnlineAddExpTime := 0; //离线挂机时长
  m_nNotOnlineAddExpPoint := 0; //离线挂机每分钟增加经验值
  m_dwAutoAddExpPointTick := GetTickCount;
  m_dwAutoAddExpPointTimeTick := GetTickCount;
  m_sAutoSendMsg := sAutoSendMsg; //自动回复信息
  m_boKickAutoAddExpUser := False;
  m_boTimeGoto := False;
  m_dwTimeGotoTick := GetTickCount;
  m_sTimeGotoLable := '';
  m_TimeGotoNPC := nil;
  m_nBigStoragePage := 0; //无限仓库的当前页数
  m_nDealGoldPose := 0;
  m_boPlayOffLine := True; //是否允许下线触发
  m_dwDedingUseTick := 0;
  m_nCopyHumanLevel := 0;
  m_boAllowReAlive := False; //是否允许复活
  //m_nShowMessagePosition := 0;//未使用 20080329

  m_boRunPlayRobotManage := True; //是否运行个人机器人
  m_PlayRobotManage := TPlayRobotManage.Create; //人物个人机器人
  m_PlayRobotManage.PlayObject := Self;

  FillChar(m_nInteger, SizeOf(m_nInteger), #0);
  FillChar(m_sString, SizeOf(m_sString), #0);

  m_boMarryMsg := False; //是否允许求婚
  m_boReadMasterMsg := False; //允许收徒弟 20090209
  m_wMasterCount := 0; //徒弟数
  m_PlayOrderList := TStringList.Create; //人物排行
  m_nSelPlayOrderType := 0; //选择排行类型
  m_nPlayOrderPage := 0; //选择人物排行页数
  m_boGetMyLevelOrder := False;

  m_nPetsMonHappLogPage := 0; //宠物快乐度日志当前页数
  m_nPetsMonHappiness := 0; //宠物快乐度
  m_sPetsMonName := '';

  m_BigStorageItemList := nil; //无限仓库

  m_btHearMsgFColor := $00; //喊话字体颜色
  m_btWhisperMsgFColor := $FC; //私聊字体颜色

  m_MyHero := nil; //我的英雄
  m_boHasHero := False;
  m_boHasHeroTwo := False;
  m_sHeroCharName := '';
  m_sTempHeroCharName := ''; //20080524
  m_boWaitHeroDate := False;
  m_boCallHero := True; //是否可以召唤英雄 20080124
  n_HeroSave := 0; //是否保存英雄 20080513
  m_boPlayDrink := False; //是否请过酒 T-请过酒 20080515
  n_DrinkValue[0] := 0; //喝酒的醉酒值 0-NPC 1-玩家 20080517
  n_DrinkValue[1] := 0;
  n_DrinkCount := 0; //喝酒的次数(斗酒一次最高6次) 20080517
  m_boMakeWine := False; //是否酿酒 20080620
  m_MakeWineTime := 0; //酿酒的时间,即还有多长时间可以取回酒 20080620
  n_MakeWineItmeType := 0; //酿酒后,应该可以得到酒的类型 2008020
  n_MakeWineQuality := 0; //酿酒后,应该可以得到酒的品质 20080620
  n_MakeWineAlcohol := 0; //酿酒后,应该可以得到酒的酒精度 20080620
  n_MakeWineType := 0; //酿酒的类型 1-普通酒 2-药酒  20080620
  m_dwAddAlcoholTick := GetTickCount; //增加酒量进度的间隔  20080623
  m_dwDecWineDrinkValueTick := GetTickCount; //减少醉酒度的间隔  20080623
  n_DrinkWineQuality := 0; //饮酒时酒的品质 20080623
  n_DrinkWineAlcohol := 0; //饮酒时酒的度数 20080624
  n_DrinkWineDrunk := False; //喝酒醉了 20080623
  n_InFountainTime := 0; //站在泉水眼的时间 20080624
  dw_UseMedicineTime := 0; //使用药酒时间,计算长时间没使用药酒 20080623
  m_ClearGamePointDate := 0; //初始游戏点的日期
{$IF M2Version = 1}
  dw_UseMedicineTime1 := g_Config.nDesAlcoholTick; //计算长时间没喝酒
  m_boOpenupSkill95 := False; //打通斗转99级
  m_JingYuanValue := 0; //当前精元值(24时初始)
  m_dwIncJingYuanValueTime := g_Config.nIncJingYuanValueTime; //增加精元值时间(在线30分钟增加100)
  m_InitialJingYuanDate := 0; //初始精元值的日期
  m_boLianQiConditions := False; //是否可以炼气
  m_dwIncTransferTick := GetTickCount; //斗转值恢复间隔
{$IFEND}
  n_MedicineLevel := 0; //药力值等级 20080623
  m_GiveGuildFountationDate := 0; //取行会泉水日期
  bo_NPCMove := False; //是否点击,让NPC走动 20080704

  n_LevelOrder := 0; //玩家当前等级排名 20080214
  m_Boxs := TList.Create; //随机选取的宝箱物品 20080116

  m_boOpenBox := False; //是否宝箱在打开 20080407
  n_OpenBoxTpye := 0; //打开宝箱的类型 0-不可填充 1-可填充
  m_OpenBoxMakeID := 0; //打开箱子时，没钥匙时，记录ID
  m_boCanRotation := False; //是否可以转动宝箱
  n_KeyAnicount := 0; //钥匙标实
  n_OpenBoxCount := 0; //转动宝箱的次数
  m_boGivePlayItme := False; //给玩家物品
  m_boNoCanRotation := False; //用于标识提示用户无同类宝箱

  n_9YearBoxsID := 0;
  n_9YearUpdateCount := 0; //更换物品次数
  m_boFree9YearsBox := False; //是否取得免费奖励20格箱子
  m_boOpenNew9YearBox := False; //是否打开新的9周年箱(用于20格箱子后，“开启新天赐”时使用)

  m_sScriptLable := ''; //20080521 从父类移动人物类中
  FillChar(m_dwUserTick, SizeOf(m_dwUserTick), #0); //20080521 从父类移动人物类中
  m_dwSayMyInfoTick := GetTickCount - 6900000;

  m_nMasterNo := 0; //徒弟排名 20080530
  m_MasterNoList := TStringList.Create; //徒弟排名列表 20080530
  m_OnTimerList := TList.Create; //个人定时器 20100617

  m_boChallengeing := False; //是否在挑战中 20080705
  m_ChallengeCreat := nil; //挑战对像 20080705
  m_ChallengeItemList := TList.Create; //挑战物品列表 20080705
  m_nChallengeGolds := 0; //挑战的金币数量 20080705
  m_nChallengeGAMEDIAMOND := 0; //挑战的金刚石 20080705

  m_boAddToMaped := False; //地图是否计数 20080830
  m_boCanQueryBag := False; //是否可以刷新包裹 20080907
  m_boCanQueryShopItme := False; //是否可以刷新商铺 20080907
  m_boHeroLogOut := False; //英雄退出 20080909
{$IF M2Version <> 2}
  m_dwLatest101Tick := GetTickCount(); //神龙附体间隔
  m_boCanUerSkill101 := False; //神龙附体可用
  m_dwUseSkillTime := GetTickCount(); //神龙附体持续时间
  m_dwLatest102Tick := GetTickCount(); //唯我独尊间隔
  m_dwUseSkill102Time := GetTickCount(); //唯我独尊持续时间
  m_dwLatest69Tick := GetTickCount(); //倚天辟地间隔 20091026
  m_boTrainingNG := False; //是否学习过内功 20081002
  m_NGLevel := 1; //内功等级 20081002
  m_ExpSkill69 := 0; //内功心法当前经验 20080930
  m_MaxExpSkill69 := 0; //内功心法升级经验 20080930
  m_Skill69NH := 0; //当前内力值 20080930
  m_Skill69MaxNH := 0; //最大内力值 20080930
  m_dwIncNHTick := GetTickCount; //增加内力值计时 20081002
  FillChar(m_SpiritMedia, SizeOf(TUserItem), 0); //灵媒装备栏
  m_nJewelX := -1; //宝物X坐标
  m_nJewelY := -1; //宝物Y坐标
  m_boGiveJewelIteming := False; //正在操作给挖宝给物品处理
  m_nSetupMaxLeveltoHPMP := 0;
  m_dwIncEnergyValueTime := g_Config.nEnergyValueTime; //增加精力值时间(在线1小时增加10点精力值)
  m_nEnergyValue := 0; //精力值(制造神秘卷轴)
  m_nLuckyValue := 0; //幸运值(制造神秘卷轴)
  m_nProficiency := 0; //熟练度(制造神秘卷轴)
  m_nIncNHRecover := 0; //内力恢复%(增加) 20090330
  m_nIncNHPoint := 0; //内力恢复速度(点数) 20090712
  m_Magic100Skill := nil; //神秘解读
  m_Magic103Skill := nil; //召唤巨魔
  m_MagicSkill_200 := nil; //怒之攻杀
  m_MagicSkill_201 := nil; //静之攻杀
  m_MagicSkill_202 := nil; //怒之半月
  m_MagicSkill_203 := nil; //静之半月
  m_MagicSkill_204 := nil; //怒之烈火
  m_MagicSkill_205 := nil; //静之烈火
  m_MagicSkill_206 := nil; //怒之逐日
  m_MagicSkill_207 := nil; //静之逐日
  m_MagicSkill_208 := nil; //怒之火球
  m_MagicSkill_209 := nil; //静之火球
  m_MagicSkill_210 := nil; //怒之大火球
  m_MagicSkill_211 := nil; //静之大火球
  m_MagicSkill_212 := nil; //怒之火墙
  m_MagicSkill_213 := nil; //静之火墙
  m_MagicSkill_214 := nil; //怒之地狱火
  m_MagicSkill_215 := nil; //静之地狱火
  m_MagicSkill_216 := nil; //怒之疾光电影
  m_MagicSkill_217 := nil; //静之疾光电影
  m_MagicSkill_218 := nil; //怒之爆裂火焰
  m_MagicSkill_219 := nil; //静之爆裂火焰
  m_MagicSkill_220 := nil; //怒之冰咆哮
  m_MagicSkill_221 := nil; //静之冰咆哮
  m_MagicSkill_222 := nil; //怒之雷电
  m_MagicSkill_223 := nil; //静之雷电
  m_MagicSkill_224 := nil; //怒之地狱雷光
  m_MagicSkill_225 := nil; //静之地狱雷光
  m_MagicSkill_226 := nil; //怒之寒冰掌
  m_MagicSkill_227 := nil; //静之寒冰掌
  m_MagicSkill_228 := nil; //怒之灭天火
  m_MagicSkill_229 := nil; //静之灭天火
  m_MagicSkill_230 := nil; //怒之火符
  m_MagicSkill_231 := nil; //静之火符
  m_MagicSkill_232 := nil; //怒之噬血
  m_MagicSkill_233 := nil; //静之噬血
  m_MagicSkill_234 := nil; //怒之流星火雨
  m_MagicSkill_235 := nil; //静之流星火雨
  m_MagicSkill_236 := nil; //怒之内功剑法
  m_MagicSkill_237 := nil; //静之内功剑法
  m_MagicSkill_238 := nil; //静之开天斩
{$IFEND}
{$IF M2Version = 1}
  m_Magic95Skill := nil; //斗转星移
  m_MagicSkill_239 := nil; //怒之施毒术
  m_MagicSkill_240 := nil; //静之施毒术
  m_MagicSkill_241 := nil; //怒之月灵
  m_MagicSkill_242 := nil; //静之月灵
  m_Magic76Skill := nil; //三绝杀
  m_Magic79Skill := nil; //追心刺
  m_Magic82Skill := nil; //断岳斩
  m_Magic85Skill := nil; //横扫千军
  FillChar(m_wHumanPulseArr, SizeOf(THumanPulseInfo), #0); //人物脉穴 20090618
  m_boUseBatter := False; //使用连击 20090630
  m_nUseBatterTime := GetTickCount(); //发连击消息间隔 20090630
  m_nBatterMagIdx1 := 0; //连击技能ID1 20090701
  m_nBatterMagIdx2 := 0; //连击技能ID2 20090701
  m_nBatterMagIdx3 := 0; //连击技能ID3 20090701
  m_nBatterMagIdx4 := 0; //连击技能ID4 20100719
  m_boTrainBatterSkill := False; //是否学习过连击技能 20090702
  m_boSendCanBatterMsg := False; //发送可使用连击消息 20090702

  m_boUser4BatterSkill := False; //使用第四格连击 20100720
  m_SetBatterKey := 0; //第一个连击技能格
  m_SetBatterKey1 := 0; //第二个连击技能格
  m_SetBatterKey2 := 0; //第三个连击技能格
  m_SetBatterKey3 := 0; //第四个连击技能格 20100719
  m_nUseBatterTick := GetTickCount(); //发送可使用连击消息 计时 20090728
  m_boWarUseBatter := False;
  m_dwLatestWarUseBatterTick := GetTickCount(); //战士连击的间隔
{$IFEND}
  FillChar(m_TagMapInfos, SizeOf(m_TagMapInfos), #0); //人物记路标石 20081019
  m_GetExp := 0; //人物取得的经验,$GetExp变量使用
  m_BuyShopPrice := 0; //每次商铺花的元宝数量，$BuyShop变量使用 20090106
  m_UseGameGird := 0; //每次使用灵符数，$USEGAMEGIRD变量使用 20090108
  m_sMapQFStr := ''; //SENDTIMEMSG命令设置的触发段 20090124
  m_sMapQFStr1 := ''; //SENDMSGWINDOWS命令设置的触发段 20090124
  m_sMessageBoxStr1 := ''; //MESSAGEBOX命令设置触发段1 20090816
  m_sMessageBoxStr2 := ''; //MESSAGEBOX命令设置触发段2 20090816
  m_boForMapShowHint := False; //换地图是否还显示倒计时信息 20090128
  m_boShowExpCrystal := False; //是否显示天地结晶图标 20090131
  m_CrystalLevel := 0; //天地结晶等级 20090131
  m_CrystalExp := 0; //天地结晶当前经验 20090131
  m_CrystalMaxExp := 0; //天地结晶升级经验 20090131
  m_CrystalNGExp := 0; //天地结晶当前内功经验 20090131
  m_CrystalNGMaxExp := 0; //天地结晶内功升级经验 20090131
  m_boGetExpCrystalExp := False; //是否可以提取经验 20090201
  m_nGetCrystalExp := 0; //可提取天地结晶经验 20090201
  m_nGetCrystalNGExp := 0; //天可提取地结晶内功经验 20090201

  m_boShowCattleGas := False; //是否显示气牛管图标 20090518
  m_CattleGasLevel := 0; //牛气等级 20090518
  m_CattleGasExp := 0; //当前牛气值 20090518
  m_CattleGasMaxExp := 0; //牛气值升级经验 20090518
  m_CattleGasHint := True; //提示牛气管将满 20090519
  m_CattleGasOpenBox := False; //是开启牛气箱子 20090524

  m_boRobotObject := False; //20090129
  m_sMapName136 := ''; //魔王岭地图名称 20090204
  m_boHighLevelKillMonFixExp := False; //高等级杀怪经验不变 20090213
  m_dwHighLevelKillMonFixExpTime := 0; //高等级杀怪经验不变的使用时间(秒) 20090213
  m_dwUseItmeChangMsgFColorTime := 0; //使用物品改变说话颜色的使用时间(秒) 玄绿,玄紫,玄褐 20090221
  m_dwUseItmeChangMsgFColorType := 0; //使用物品改变说话颜色的类型 1-玄绿 2-玄紫 3-玄褐 200902
  m_btReLevel := 0; //转生等级 20090403
  m_nIncDragonRate := 0; //合击伤害(增加) 20090330
  m_nIncDragon := 0; //增加合击威力点数
{$IF M2Version <> 2}
  m_boArmsCritPoint := 0; //武器暴击等级 20100709
  m_nHeapStruckDamage := 0; //受有武器暴击等级的人物累积攻击点 20100709
{$IFEND}
  //m_ShowThunderAndLavaTick := GetTickCount();//处理雷电，岩浆的间隔 20090505
  m_boMergerIteming := False; //是否正在合并物品 20090616
  m_boMergerKimNeedle := False; //是否正在锻练金针 20090616

  m_PulseAddAC := 0; //命令增加 防御上限
  m_PulseAddAC1 := 0; //命令增加 防御下限
  m_PulseAddMAC := 0; //命令增加 魔御上限
  m_PulseAddMAC1 := 0; //命令增加 魔御上限

  m_boSendCanBatterTick := False;
  m_nWinNGExp := 0; //累计内功经验，内功珠使用 20090814
  m_boNPCCanGoto := False; //@@InPutString @@InPutInteger 跳转标识 20090818
  m_nSendMsgCount := 0;

  m_boCallDeputyHero := False; //是否召唤副将英雄
  m_sDeputyHeroName := ''; //卧龙英雄名字
  m_btDeputyHeroJob := 0; //所选副将职业 0-战 1-法 2-道 3-刺客
  m_nHeroLevel1 := 0; //主将英雄等级
  m_nHeroLevel2 := 0; //副将英雄等级
  m_nHeroNGLevel1 := 0; //主将英雄内功等级
  m_nHeroNGLevel2 := 0; //副将英雄内功等级
  m_nMainExp := 0; //主将累计经验(当副将等级低于主将3级时使用)
  m_nMainNGExp := 0; //主将累计内功经验(当副将等级低于主将3级时使用)
  m_boShowHeroLevel := True; //副将英雄等级受限提示(默认开启)
  m_boHeroAutoPractice := False; //副将英雄是否自动修炼
  m_nHeroAutoPracticePlace := 0; //自动修炼修炼场所 0-封魔谷(经验内功经验) 1-雷炎洞穴(大量经验) 2-雪域地图(大量内功经验)
  m_nHeroAutoPracticeStrength := 0; //自动修炼修炼强度(自动修炼收费) 0-低强度 1-中强度 2-高强度
  m_HeroAutoPracticeTime := 0; //自动修炼累计时长
  m_boMainHeroDie := False; //主将死亡
  m_boHeroDieTreatment := False; //英雄死亡处理中
  m_boButching := False;

  m_ShopItemList := TList.Create; //个人商店列表
  FillChar(ClientSuitAbility, SizeOf(ClientSuitAbility), #0); //套装最高主属性
end;
//元宝寄售取消出售 20080316

procedure TPlayObject.SellOffCancel;
begin
  SendMsg(Self, RM_SELLOFFCANCEL, 0, 0, 0, 0, '');
  GetBackSellOffItems();
end;
//交易取消

procedure TPlayObject.DealCancel;
begin
  if not m_boDealing then Exit;
  m_boDealing := False;
  SendDefMessage(SM_DEALCANCEL, 0, 0, 0, 0, '');
  if m_DealCreat <> nil then begin
    m_DealCreat.DealCancel;
  end;
  m_DealCreat := nil;
  GetBackDealItems();
  SysMsg(g_sDealActionCancelMsg {'交易取消'}, c_Green, t_Hint);
  m_DealLastTick := GetTickCount();
end;

procedure TPlayObject.DealCancelA;
begin
  m_Abil.HP := m_WAbil.HP;
  DealCancel();
end;

function TPlayObject.DecGold(nGold: Integer): Boolean;
begin
  Result := False;
  if m_nGold >= nGold then begin
    Dec(m_nGold, nGold);
    Result := True;
  end;
end;

procedure TPlayObject.DecGameGold(nGameGold: Integer);
begin
  if m_nGameGold >= nGameGold then begin
    Dec(m_nGameGold, nGameGold);
  end else m_nGameGold := 0;
end;
//减游戏点

procedure TPlayObject.DecGamePoint(nGamePoint: Integer);
begin
  if m_nGamePoint >= nGamePoint then begin
    Dec(m_nGamePoint, nGamePoint);
  end else m_nGamePoint := 0;
end;

destructor TPlayObject.Destroy;
var
  I: Integer;
begin
  if m_SellOffItemList <> nil then begin
    if m_SellOffItemList.Count > 0 then begin
      for I := 0 to m_SellOffItemList.Count - 1 do begin //元宝寄售物品列表 20080316
        if pTUserItem(m_SellOffItemList.Items[I]) <> nil then
          Dispose(pTUserItem(m_SellOffItemList.Items[I]));
      end;
    end;
    FreeAndNil(m_SellOffItemList);
  end;
{$IF M2Version <> 2}
  if m_RefineItemList <> nil then begin
    if m_RefineItemList.Count > 0 then begin
      for I := 0 to m_RefineItemList.Count - 1 do begin //淬练物品列表 20080502
        if pTUserItem(m_RefineItemList.Items[I]) <> nil then
          Dispose(pTUserItem(m_RefineItemList.Items[I]));
      end;
    end;
    FreeAndNil(m_RefineItemList);
  end;
  if m_ComradeList <> nil then m_ComradeList.Free; //龙卫列表
  if m_HuhuaList <> nil then m_HuhuaList.Free; //护花使者列表
{$IFEND}
  if m_DealItemList <> nil then begin
    if m_DealItemList.Count > 0 then begin
      for I := 0 to m_DealItemList.Count - 1 do begin
        if pTUserItem(m_DealItemList.Items[I]) <> nil then
          Dispose(pTUserItem(m_DealItemList.Items[I]));
      end;
    end;
    FreeAndNil(m_DealItemList);
  end;

  if m_ChallengeItemList <> nil then begin //挑战物品列表 20080705
    if m_ChallengeItemList.Count > 0 then begin
      for I := 0 to m_ChallengeItemList.Count - 1 do begin
        if pTUserItem(m_ChallengeItemList.Items[I]) <> nil then
          Dispose(pTUserItem(m_ChallengeItemList.Items[I]));
      end;
    end;
    FreeAndNil(m_ChallengeItemList);
  end;

  if m_StorageItemList <> nil then begin
    if m_StorageItemList.Count > 0 then begin
      for I := 0 to m_StorageItemList.Count - 1 do begin
        if pTUserItem(m_StorageItemList.Items[I]) <> nil then
          Dispose(pTUserItem(m_StorageItemList.Items[I]));
      end;
    end;
    FreeAndNil(m_StorageItemList);
  end;

  if m_GroupMembers <> nil then FreeAndNil(m_GroupMembers);
  if m_BlockWhisperList <> nil then FreeAndNil(m_BlockWhisperList);
  if m_MasterList <> nil then FreeAndNil(m_MasterList);
  if m_Boxs <> nil then begin
    if m_Boxs.Count > 0 then begin //20090705 增加
      for I := 0 to m_Boxs.Count - 1 do begin
        if pTBoxsInfo(m_Boxs.Items[I]) <> nil then Dispose(pTBoxsInfo(m_Boxs.Items[I]));
      end;
    end;
    FreeAndNil(m_Boxs); //随机选取宝箱的物品 20080116
  end;

  if m_DynamicVarList <> nil then begin
    if m_DynamicVarList.Count > 0 then begin
      for I := 0 to m_DynamicVarList.Count - 1 do begin
        if pTDynamicVar(m_DynamicVarList.Items[I]) <> nil then
          Dispose(pTDynamicVar(m_DynamicVarList.Items[I]));
      end;
    end;
    FreeAndNil(m_DynamicVarList);
  end;

  if m_CanJmpScriptLableList <> nil then FreeAndNil(m_CanJmpScriptLableList);
  if m_PlayRobotManage <> nil then m_PlayRobotManage.Free;
  if m_PlayOrderList <> nil then m_PlayOrderList.Free;

  if m_MasterNoList <> nil then begin
    if m_MasterNoList.Count > 0 then begin
      for I := 0 to m_MasterNoList.Count - 1 do begin //20080530
        if PTMasterList(m_MasterNoList.Objects[I]) <> nil then
          Dispose(PTMasterList(m_MasterNoList.Objects[I]));
      end;
    end;
    m_MasterNoList.Free; //徒弟排名列表 20080530
  end;

  if m_OnTimerList.Count > 0 then begin //个人定时器 20100617
    for I := 0 to m_OnTimerList.Count - 1 do begin
      Dispose(pTOnTimer(m_OnTimerList.Items[I]));
    end;
  end;
  m_OnTimerList.Free;

  if m_ShopItemList.Count > 0 then begin
    for I := 0 to m_ShopItemList.Count - 1 do begin
      Dispose(pTUserShopItem(m_ShopItemList.Items[i]));
    end;
  end;
  m_ShopItemList.Free;
  inherited;
end;

procedure TPlayObject.Disappear;
begin
  if m_boReadyRun then DisappearA;
  if m_boTransparent and m_boHideMode then m_wStatusTimeArr[STATE_TRANSPARENT] := 0;

  if m_GroupOwner <> nil then begin
    m_GroupOwner.DelMember(Self);
  end;
  if m_MyGuild <> nil then begin
    TGUild(m_MyGuild).DelHumanObj(Self);
  end;
  LogonTimcCost(); //记录角色登陆的日志(如充值模式，通知LoginSrv修改玩家时间)
  inherited Disappear;
end;
//人物掉落装备物品 20080227

procedure TPlayObject.DropUseItems(BaseObject: TBaseObject; nBurstRate: Byte);
var
  I, K, J, nRate: Integer;
  StdItem: pTStdItem;
  DelList: TStringList;
  SelectItemList: TStringList;
  nCode: Byte;
resourcestring
  sExceptionMsg = '{%s} TPlayObject::DropUseItems Code:%d.%p';
begin
  nCode := 0;
  DelList := nil;
  m_boCanQueryBag := True; //掉落装备物品时,不能刷新包裹 20080917
  try
    try
      if m_PEnvir.m_boNODROPITEM then Exit; //地图禁止死亡掉物品则退出 20080503
      nCode := 1;
      if m_boAngryRing or m_boNoDropUseItem then Exit;
      nCode := 2;
      for I := Low(THumanUseItems) to High(THumanUseItems) do begin //检查物品消失
        nCode := 3;
        StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
        nCode := 4;
        if StdItem <> nil then begin
          nCode := 5;
          if CheckItemValue(@m_UseItems[I], 5) then Continue; //20080314 禁止爆出
          if PlugOfCheckCanItem(6, StdItem.Name, False, 0, 0) then Continue; //禁止物品规则(永不爆出) 20080729
          if CheckItemBindDieNoDrop(@m_UseItems[I]) then Continue; //人物装备绑定死亡不爆 20081127
          if ((StdItem.StdMode = 2) and (StdItem.Reserved = 56)) or (StdItem.Shape = 193) then Continue; //泉水罐 不处理 20091009  20100324虎威系统不处理
          nCode := 7;
          if StdItem.Reserved and 8 <> 0 then begin
            nCode := 8;
            if DelList = nil then DelList := TStringList.Create;
            nCode := 9;
            //DelList.AddObject('', TObject(m_UseItems[I].MakeIndex));//20080803 替换
            if m_UseItems[I].wIndex > 0 then //20080817 增加
              DelList.AddObject({UserEngine.GetStdItemName(m_UseItems[I].wIndex)}StdItem.Name, TObject(m_UseItems[I].MakeIndex));
            nCode := 18;
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('16' + #9 +
                m_sMapName + '(' + IntToStr(m_btRaceServer) + ')' + #9 +
                IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                m_sCharName + #9 + StdItem.Name + #9 +
                IntToStr(m_UseItems[I].MakeIndex) + #9 +
                '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                IntToStr(m_UseItems[I].btValue[0]) + '/' + IntToStr(m_UseItems[I].btValue[1]) + '/' + IntToStr(m_UseItems[I].btValue[2]) + '/' +
                IntToStr(m_UseItems[I].btValue[3]) + '/' + IntToStr(m_UseItems[I].btValue[4]) + '/' + IntToStr(m_UseItems[I].btValue[5]) + '/' +
                IntToStr(m_UseItems[I].btValue[6]) + '/' + IntToStr(m_UseItems[I].btValue[7]) + '/' + IntToStr(m_UseItems[I].btValue[8]) + '/' +
                IntToStr(m_UseItems[I].btValue[14]) + #9 + '0');
            nCode := 19;
            if (StdItem.Shape > 125) and (StdItem.Shape < 130) {in [126..129]} then begin //祈祷装备,被怪(不是宝宝)打死,装备才消失,其它打死不消失 20080403
              nCode := 20;
              if m_LastHiter <> nil then begin //20080727 增加
                nCode := 21;
                if (m_LastHiter.m_btRaceServer <> RC_PLAYOBJECT) and (m_LastHiter.m_Master = nil) then
                  m_UseItems[I].wIndex := 0
                else Continue;
              end;
            end else m_UseItems[I].wIndex := 0;
          end;
        end;
      end;
      nCode := 10;
      if not m_boAI then begin
        if PKLevel > 2 then nRate := g_Config.nDieRedDropUseItemRate {15}
        else nRate := g_Config.nDieDropUseItemRate {30};
      end else begin
        nRate := m_nDropUseItemRate;
      end;
      if m_nUnBurstRate > 0 then nRate := _MIN(High(Byte), nRate + m_nUnBurstRate); //防爆点
      if nBurstRate > 0 then nRate := _MAX(0, nRate - nBurstRate); //20091129
      nCode := 11;
      for I := Low(THumanUseItems) to High(THumanUseItems) do begin //9格装备+4格装备
        if (m_UseItems[I].AddValue[0] = 1) and (GetHoursCount(m_UseItems[I].MaxDate, Now) <= 0) then begin //删除到期装备
          m_UseItems[I].wIndex := 0;
          Continue;
        end;
        nCode := 12;
        if Random(nRate) <> 0 then Continue;
        if nBurstRate > 0 then begin //当有爆率装备时,一次只爆一次,物品位置随机 20100302
          SelectItemList := TStringList.Create;
          try
            for K := Low(THumanUseItems) to High(THumanUseItems) do begin //9格装备+4格装备
              if (m_UseItems[K].wIndex <= 0) or (m_UseItems[K].MakeIndex <= 0) then Continue;
              if InDisableTakeOffList(m_UseItems[K].wIndex) then Continue; //检查是否在禁止取下列表,如果在列表中则不掉此物品
              if CheckItemValue(@m_UseItems[K], 5) then Continue; //20080314 禁止爆出
              StdItem := UserEngine.GetStdItem(m_UseItems[K].wIndex);
              nCode := 13;
              if StdItem <> nil then
                if PlugOfCheckCanItem(6, StdItem.Name, False, 0, 0) then Continue; //禁止物品规则(永不爆出) 20080729
              if CheckItemBindDieNoDrop(@m_UseItems[K]) then Continue; //人物装备绑定死亡不爆 20081127
              SelectItemList.Add(IntToStr(K));
            end;
            nCode := 15;
            if SelectItemList.Count > 0 then begin
              J := Str_ToInt(SelectItemList.Strings[Random(SelectItemList.Count)], 0);
              if DropItemDown(@m_UseItems[J], 3, True, True, BaseObject, Self) then begin //爆出装备
                if DelList = nil then DelList := TStringList.Create;
                DelList.AddObject(UserEngine.GetStdItemName(m_UseItems[J].wIndex), TObject(m_UseItems[J].MakeIndex));
                nCode := 16;
                m_UseItems[J].wIndex := 0; //20090523
                m_UseItems[J].MakeIndex := 0; //20090523
                Break; //当有爆率装备时，一次只爆一次 20100121
              end;
            end else Break;
          finally
            SelectItemList.Free;
          end;
        end else begin
          StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
          nCode := 13;
          if InDisableTakeOffList(m_UseItems[I].wIndex) then Continue; //检查是否在禁止取下列表,如果在列表中则不掉此物品
          if CheckItemValue(@m_UseItems[I], 5) then Continue; //20080314 禁止爆出
          if StdItem <> nil then
            if PlugOfCheckCanItem(6, StdItem.Name, False, 0, 0) then Continue; //禁止物品规则(永不爆出) 20080729
          if CheckItemBindDieNoDrop(@m_UseItems[I]) then Continue; //人物装备绑定死亡不爆 20081127

          nCode := 15;
          if DropItemDown(@m_UseItems[I], 3, True, True, BaseObject, Self) then begin //爆出装备
            if DelList = nil then DelList := TStringList.Create;
            DelList.AddObject(UserEngine.GetStdItemName(m_UseItems[I].wIndex), TObject(m_UseItems[I].MakeIndex));
            nCode := 16;
            m_UseItems[I].wIndex := 0; //20090523
            m_UseItems[I].MakeIndex := 0; //20090523
          end;
        end;
      end; //for
      if DelList <> nil then begin
        SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
      end;
    except
      MainOutMessage(Format(sExceptionMsg, [g_sExceptionVer, nCode, ExceptAddr]));
    end;
  finally
    m_boCanQueryBag := False; //掉落装备物品时,不能刷新包裹 20080917
  end;
end;
//nCode 1-内功怪

procedure TPlayObject.GainExp(dwExp: LongWord; nCode: Byte);
var
  I, n, sumlv, nExp, nHighLevel, nLowLevel: Integer;
  PlayObject: TPlayObject;
  nCheckCode: Integer;
resourcestring
  sExceptionMsg = '{%s} TPlayObject::GainExp Code:%d.%p';
const
  bonus: array[0..GROUPMAX] of real = (1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2, 2.1, 2.2);
begin
  nCheckCode := 0;
  if self = nil then Exit; //20080803 增加
  try
    nHighLevel := 0;
    nLowLevel := High(Word);
    if dwExp > 0 then begin
      nCheckCode := 15;
      if (m_GroupOwner <> nil) then begin //20090101
        nCheckCode := 9;
        if (m_GroupOwner.m_GroupMembers <> nil) then begin //20090101
          nCheckCode := 10;
          if (m_GroupOwner.m_GroupMembers.Count > 0) then begin
            sumlv := 0;
            n := 0;
            nCheckCode := 1;
            for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
              PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[I]);
              if PlayObject <> nil then begin
                if not PlayObject.m_boDeath and (m_PEnvir = PlayObject.m_PEnvir) and (abs(m_nCurrX - PlayObject.m_nCurrX) <= 12) and (abs(m_nCurrX - PlayObject.m_nCurrX) <= 12) then begin
                  sumlv := sumlv + PlayObject.m_Abil.Level;
                  if PlayObject.m_Abil.Level > nHighLevel then nHighLevel := PlayObject.m_Abil.Level;
                  if PlayObject.m_Abil.Level < nLowLevel then nLowLevel := PlayObject.m_Abil.Level;
                  Inc(n);
                end;
              end;
            end; //for

            nCheckCode := 2;
            if (sumlv > 0) and (n > 1) then begin
              if n in [0..GROUPMAX] then dwExp := Round(dwExp * bonus[n]);
{$IF M2Version <> 2}
              if m_GroupOwner.m_GroupOwnerExp then dwExp := dwExp * 2; //热血使者称号,为队长时,经验翻倍
{$IFEND}
              nCheckCode := 3;
              if m_GroupOwner.m_GroupMembers.Count > 0 then begin //20080629
                for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
                  PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[I]);
                  if PlayObject <> nil then begin
                    if not PlayObject.m_boDeath and (m_PEnvir = PlayObject.m_PEnvir) and (abs(m_nCurrX - PlayObject.m_nCurrX) <= 12) and (abs(m_nCurrX - PlayObject.m_nCurrX) <= 12) then begin
                      if (g_Config.boHighLevelKillMonFixExp or m_boHighLevelKillMonFixExp) and g_Config.boHighLevelGroupFixExp then begin //02/08 增加，在高等级经验不变时，把组队的经验平均分配  20090215
                        nCheckCode := 4;
                        PlayObject.WinExp(Round(dwExp / n));
{$IF M2Version <> 2}
                        nCheckCode := 5;
                        if nCode = 1 then PlayObject.GetNGExp(Round(dwExp / n), 0); //取得内力经验 20081224
{$IFEND}
                      end else
                        if g_Config.boHighLevelGroupFixExp then begin
                          nCheckCode := 6;
                          PlayObject.WinExp(Round(dwExp / sumlv * PlayObject.m_Abil.Level));
{$IF M2Version <> 2}
                          nCheckCode := 7;
                          if nCode = 1 then PlayObject.GetNGExp(Round(dwExp / sumlv * PlayObject.m_Abil.Level), 0); //取得内力经验 20081224
{$IFEND}
                        end else
                          if m_Abil.Level > (nLowLevel + 10) then begin //大号杀怪组里人经验不变
                            PlayObject.WinExp(Round(dwExp / sumlv * PlayObject.m_Abil.Level));
{$IF M2Version <> 2}
                            if nCode = 1 then PlayObject.GetNGExp(Round(dwExp / sumlv * PlayObject.m_Abil.Level), 0); //取得内力经验 20081224
{$IFEND}
                          end else
                            if m_Abil.Level <= (nLowLevel + 10) then begin
                              if PlayObject.m_Abil.Level > (nLowLevel + 10) then begin //小号杀怪经验组里人大号经验改变
                                nExp := Round(dwExp / PlayObject.m_Abil.Level);
                                if nExp <= 0 then nExp := 1;
                                PlayObject.WinExp(nExp);
{$IF M2Version <> 2}
                                if nCode = 1 then PlayObject.GetNGExp(nExp, 0); //取得内力经验 20081224
{$IFEND}
                              end else begin
                                PlayObject.WinExp(Round(dwExp / sumlv * PlayObject.m_Abil.Level)); //小号杀怪经验组里人小号经验不变
{$IF M2Version <> 2}
                                if nCode = 1 then PlayObject.GetNGExp(Round(dwExp / sumlv * PlayObject.m_Abil.Level), 0); //取得内力经验 20081224
{$IFEND}
                              end;
                            end;
                    end;
                  end;
                end; //for
              end;
            end else begin
              nCheckCode := 11;
              WinExp(dwExp);
{$IF M2Version <> 2}
              if nCode = 1 then GetNGExp(dwExp, 0); //取得内力经验 20081224
{$IFEND}
            end;
          end else begin
            nCheckCode := 12;
            WinExp(dwExp);
{$IF M2Version <> 2}
            if nCode = 1 then GetNGExp(dwExp, 0); //取得内力经验 20081224
{$IFEND}
          end;
        end else begin
          nCheckCode := 13;
          WinExp(dwExp);
{$IF M2Version <> 2}
          if nCode = 1 then GetNGExp(dwExp, 0); //取得内力经验
{$IFEND}
        end;
      end else begin
        nCheckCode := 14;
        WinExp(dwExp);
{$IF M2Version <> 2}
        if nCode = 1 then GetNGExp(dwExp, 0); //取得内力经验
{$IFEND}
      end;
    end;
  except
    MainOutMessage(Format(sExceptionMsg, [g_sExceptionVer, nCheckCode, ExceptAddr]));
  end;
end;

procedure TPlayObject.GameTimeChanged;
begin
  if m_nBright <> g_nGameTime then begin
    m_nBright := g_nGameTime;
    SendMsg(Self, RM_DAYCHANGING, 0, 0, 0, 0, '');
  end;
end;

//取备份元宝寄售列表物品 20081015 修改

procedure TPlayObject.GetBackSellOffItems();
var
  I: Integer;
begin
  if m_SellOffItemList.Count > 0 then begin
    for I := m_SellOffItemList.Count - 1 downto 0 do begin
      m_ItemList.Add(m_SellOffItemList.Items[I]);
      m_SellOffItemList.Delete(I);
    end;
  end;
  m_boSellOffOK := False; //确认元宝寄售标志 20080316
end;

procedure TPlayObject.GetBackDealItems;
var
  I: Integer;
begin
  if m_DealItemList.Count > 0 then begin
    for I := 0 to m_DealItemList.Count - 1 do begin
      m_ItemList.Add(m_DealItemList.Items[I]);
    end;
  end;
  m_DealItemList.Clear;
  Inc(m_nGold, m_nDealGolds);
  m_nDealGolds := 0;
  m_boDealOK := False;
end;

procedure TPlayObject.GetBagUseItems(var btDc, btSc, btMc, btDura: Byte);
var
  I, II: Integer;
  DuraList: TList;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  StdItem80: TStdItem;
  DelItemList: TStringList;
  nDc, nSc, nMc, nDcMin, nDcMax, nScMin, nScMax, nMcMin, nMcMax, nDura, nItemCount: Integer;
begin
  nDcMin := 0;
  nDcMax := 0;
  nScMin := 0;
  nScMax := 0;
  nMcMin := 0;
  nMcMax := 0;
  nDura := 0;
  nItemCount := 0;
  DelItemList := nil;
  DuraList := TList.Create;
  for I := m_ItemList.Count - 1 downto 0 do begin
    if m_ItemList.Count <= 0 then Break;
    UserItem := m_ItemList.Items[I];
    if UserItem = nil then Continue;
    if UserEngine.GetStdItemName(UserItem.wIndex) = g_Config.sBlackStone then begin
      DuraList.Add(Pointer(Round(UserItem.Dura / 1.0E3)));
      if DelItemList = nil then DelItemList := TStringList.Create;
      DelItemList.AddObject(g_Config.sBlackStone, TObject(UserItem.MakeIndex));
      Dispose(UserItem);
      m_ItemList.Delete(I);
    end else begin
      if IsUpgradeWaponUseItem(UserItem.wIndex) then begin
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem <> nil then begin
          StdItem80 := StdItem^;
          ItemUnit.GetItemAddValue(UserItem, StdItem80);
          nDc := 0;
          nSc := 0;
          nMc := 0;
          case StdItem80.StdMode of
            19, 20, 21, 28: begin //项链
                nDc := HiWord(StdItem80.DC) + LoWord(StdItem80.DC);
                nSc := HiWord(StdItem80.SC) + LoWord(StdItem80.SC);
                nMc := HiWord(StdItem80.MC) + LoWord(StdItem80.MC);
              end;
            22, 23, 27: begin //戒指 20100513
                nDc := HiWord(StdItem80.DC) + LoWord(StdItem80.DC);
                nSc := HiWord(StdItem80.SC) + LoWord(StdItem80.SC);
                nMc := HiWord(StdItem80.MC) + LoWord(StdItem80.MC);
              end;
            24, 26: begin
                nDc := HiWord(StdItem80.DC) + LoWord(StdItem80.DC) + 1;
                nSc := HiWord(StdItem80.SC) + LoWord(StdItem80.SC) + 1;
                nMc := HiWord(StdItem80.MC) + LoWord(StdItem80.MC) + 1;
              end;
          end;
          if nDcMin < nDc then begin
            nDcMax := nDcMin;
            nDcMin := nDc;
          end else begin
            if nDcMax < nDc then nDcMax := nDc;
          end;
          if nScMin < nSc then begin
            nScMax := nScMin;
            nScMin := nSc;
          end else begin
            if nScMax < nSc then nScMax := nSc;
          end;
          if nMcMin < nMc then begin
            nMcMax := nMcMin;
            nMcMin := nMc;
          end else begin
            if nMcMax < nMc then nMcMax := nMc;
          end;
          if DelItemList = nil then DelItemList := TStringList.Create;
          DelItemList.AddObject(StdItem.Name, TObject(UserItem.MakeIndex));
          //004A06DB
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('26' + #9 + m_sMapName + #9 +
              IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 +
              '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
              '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
              '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
              '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
              '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
              IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
              IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
              IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
              IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + '0');
          Dispose(UserItem);
          m_ItemList.Delete(I);
        end;
      end;
    end;
  end; // for

  if DuraList.Count > 0 then begin //20080628
    for I := 0 to DuraList.Count - 1 do begin
      if DuraList.Count <= 0 then Break;
      for II := DuraList.Count - 1 downto I + 1 do begin
        if Integer(DuraList.Items[II]) > Integer(DuraList.Items[II - 1]) then
          DuraList.Exchange(II, II - 1);
      end; // for
    end; // for

    for I := 0 to DuraList.Count - 1 do begin
      nDura := nDura + Integer(DuraList.Items[I]);
      Inc(nItemCount);
      if nItemCount >= 5 then Break;
    end;
  end;
  btDura := Round(_MIN(5, nItemCount) + _MIN(5, nItemCount) * ((nDura / nItemCount) / 5.0));
  btDc := nDcMin div 5 + nDcMax div 3;
  btSc := nScMin div 5 + nScMax div 3;
  btMc := nMcMin div 5 + nMcMax div 3;
  if DelItemList <> nil then
    SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelItemList), 0, 0, '');
  if DuraList <> nil then DuraList.Free;
end;

function TPlayObject.GeTBaseObjectInfo: string;
begin
  Result := m_sCharName +
    ' 标识:' + IntToHex(Integer(Self), 2) +
    ' 权限等级: ' + IntToStr(m_btPermission) +
    ' 管理模式: ' + BoolToCStr(m_boAdminMode) +
    ' 隐身模式: ' + BoolToCStr(m_boObMode) +
    ' 无敌模式: ' + BoolToCStr(m_boSuperMan) +
    ' 地图:' + m_sMapName + '(' + m_PEnvir.sMapDesc + ')' +
    ' 座标:' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) +
    ' 等级:' + IntToStr(m_Abil.Level) +
    ' 转生等级:' + IntToStr(m_btReLevel) +
    ' 经验:' + IntToStr(m_Abil.nExp) +
    ' 生命值: ' + IntToStr(m_WAbil.HP) + '-' + IntToStr(m_WAbil.MaxHP) +
    ' 魔法值: ' + IntToStr(m_WAbil.MP) + '-' + IntToStr(m_WAbil.MaxMP) +
    ' 攻击力: ' + IntToStr(LoWord(m_WAbil.DC)) + '-' + IntToStr(HiWord(m_WAbil.DC)) +
    ' 魔法力: ' + IntToStr(LoWord(m_WAbil.MC)) + '-' + IntToStr(HiWord(m_WAbil.MC)) +
    ' 道术: ' + IntToStr(LoWord(m_WAbil.SC)) + '-' + IntToStr(HiWord(m_WAbil.SC)) +
    ' 防御力: ' + IntToStr(LoWord(m_WAbil.AC)) + '-' + IntToStr(HiWord(m_WAbil.AC)) +
    ' 魔防力: ' + IntToStr(LoWord(m_WAbil.MAC)) + '-' + IntToStr(HiWord(m_WAbil.MAC)) +
    ' 准确:' + IntToStr(m_btHitPoint) +
    ' 敏捷:' + IntToStr(m_btSpeedPoint) +
    ' 速度:' + IntToStr(m_nHitSpeed) +
    ' 仓库密码:' + m_sStoragePwd +
    ' 登录IP:' + m_sIPaddr + '(' + '$'+IntToHex(m_dwHCode, 8) + ':' + m_sIPLocal {GetIPLocal(m_sIPaddr)} + ')' + // Mac问题
    ' 登录帐号:' + m_sUserID +
    ' 登录时间:' + DateTimeToStr(m_dLogonTime) +
    ' 在线时长(分钟):' + IntToStr((GetTickCount - m_dwLogonTick) div 60000) +
    ' 登录模式:' + IntToStr(m_nPayMent) +
    ' ' + g_Config.sGameGoldName + ':' + IntToStr(m_nGameGold) +
    ' ' + g_Config.sGameDiaMond + ':' + IntToStr(m_nGameDiaMond) + //20071226 金刚石
    ' ' + g_Config.sGameGird + ':' + IntToStr(m_nGameGird) + //20071226 灵符
    ' ' + g_Config.sGamePointName + ':' + IntToStr(m_nGamePoint) +
    ' ' + g_Config.sPayMentPointName + ':' + IntToStr(m_nPayMentPoint) +
    ' 会员类型:' + IntToStr(m_nMemberType) +
    ' 会员等级:' + IntToStr(m_nMemberLevel) +
    ' 经验倍数:' + CurrToStr(m_nKillMonExpRate / 100) +
    ' 攻击倍数:' + CurrToStr(m_nPowerRate / 100) +
    ' 声望值:' + IntToStr(m_btCreditPoint);
end;

function TPlayObject.GetDigUpMsgCount: Integer;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  Result := 0;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    if m_MsgList.Count > 0 then begin //20080629
      for I := 0 to m_MsgList.Count - 1 do begin
        SendMessage := m_MsgList.Items[I];
        if SendMessage <> nil then begin
          if (SendMessage.wIdent = CM_BUTCH) then begin
            Inc(Result);
          end;
        end;
      end; //for
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

//使用照明物品(蜡烛减持久)

procedure TBaseObject.UseLamp;
var
  nOldDura: Integer;
  nDura: Integer;
  PlayObject: TPlayObject;
  StdItem: pTStdItem;
resourcestring
  sExceptionMsg = '{%s} TBaseObject::UseLamp %p';
begin
  try //20090710 增加
    if (m_UseItems[U_RIGHTHAND].wIndex > 0) and (not m_boDeath) then begin
      StdItem := UserEngine.GetStdItem(m_UseItems[U_RIGHTHAND].wIndex);
      if (StdItem = nil) or (StdItem.Source <> 0) then Exit;

      nOldDura := Round(m_UseItems[U_RIGHTHAND].Dura / 1000);
      if g_Config.boDecLampDura then begin
        nDura := m_UseItems[U_RIGHTHAND].Dura - 1;
      end else begin
        nDura := m_UseItems[U_RIGHTHAND].Dura;
      end;
      if nDura <= 0 then begin
        if g_Config.boItmeAutoOver then begin//修复蜡烛类0持久消失 By TasNat at: 2012-05-28 16:48:43
        
        m_UseItems[U_RIGHTHAND].Dura := 0;
        if m_btRaceServer = RC_PLAYOBJECT then begin
          PlayObject := TPlayObject(Self);
          PlayObject.SendDelItems(@m_UseItems[U_RIGHTHAND]);
        end;
        m_UseItems[U_RIGHTHAND].wIndex := 0;
        m_nLight := 0;
        SendRefMsg(RM_CHANGELIGHT, 0, 0, 0, 0, '');
        SendMsg(Self, RM_LAMPCHANGEDURA, 0, m_UseItems[U_RIGHTHAND].Dura, 0, 0, '');
        RecalcAbilitys();
        CompareSuitItem(False); //200080729 套装
        end;
      end else m_UseItems[U_RIGHTHAND].Dura := nDura;
      if nOldDura <> Round(nDura / 1000) then begin
        SendMsg(Self, RM_LAMPCHANGEDURA, 0, m_UseItems[U_RIGHTHAND].Dura, 0, 0, '');
      end;
    end;
  except
    MainOutMessage(Format(sExceptionMsg, [g_sExceptionVer, ExceptAddr]));
  end;
end;

//取对面的角色

function TBaseObject.GetPoseCreate: TBaseObject;
var
  nX, nY: Integer;
begin
  Result := nil;
  if GetFrontPosition(nX, nY) then begin
    Result := m_PEnvir.GetMovingObject(nX, nY, True);
  end;
end;

//客户端查询包裹物品

procedure TPlayObject.ClientQueryBagItems();
var
  I: Integer;
  Item: pTStdItem;
  sSENDMSG: string;
  ClientItem: TClientItem;
  EffecItem: pTEffecItem;
  OClientItem: TOClientItem;
  StdItem: TStdItem;
  UserItem: pTUserItem;
  sUserItemName: string;
begin
  if m_boCanQueryBag or (GetTickCount - m_dwClientQueryBagItemsTick < 3*1000) then begin
    SysMsg('你现在不能刷新包裹...', c_Red, t_Hint);
    Exit; //是否可以刷新包裹 20080907
  end;
  m_dwClientQueryBagItemsTick := GetTickCount;
  m_boCanQueryBag := True;
  try
    if m_nSoftVersionDateEx = 0 then begin
      sSENDMSG := '';
      if m_ItemList.Count > 0 then begin //20080628
        for I := 0 to m_ItemList.Count - 1 do begin
          UserItem := m_ItemList.Items[I];
          if UserItem <> nil then begin //20090115
            if CheckIsOKItem(UserItem) then begin //检查变态物品 20090704
              UserItem.wIndex := 0;
              UserItem.MakeIndex := 0;
              Continue;
            end;
            Item := UserEngine.GetStdItem(UserItem.wIndex);
            if Item <> nil then begin
              StdItem := Item^;
              ItemUnit.GetItemAddValue(UserItem, StdItem);
              //      Move(StdItem,ClientItem.S,SizeOf(TStdItem));
              CopyStdItemToOStdItem(@StdItem, @OClientItem.s);

              //发送聚灵珠的经验 20090502
              if (StdItem.StdMode = 51) and (StdItem.Shape = 0) and (UserItem.btValue[12] <> 2) and (UserItem.btValue[20] = 1) then begin
                if m_nWinExp >= 10000 then begin
                  Inc(UserItem.Dura);
                  dec(m_nWinExp, 10000);
                  if UserItem.Dura > UserItem.DuraMax then UserItem.Dura := UserItem.DuraMax;
                end;
                if (UserItem.Dura > 0) then begin
                  SendMsg(self, RM_EXPTIMEITEMS, 0, UserItem.MakeIndex, (n_UsesItemTick div 3600), 0, ''); //发送聚灵珠剩于时间 20080307
                end;
              end;
              //取自定义物品名称
              sUserItemName := '';
              if UserItem.btValue[13] = 1 then
                sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
              if sUserItemName <> '' then OClientItem.s.Name := sUserItemName;

              OClientItem.Dura := UserItem.Dura;
              OClientItem.DuraMax := UserItem.DuraMax;
              OClientItem.MakeIndex := UserItem.MakeIndex;
              if StdItem.StdMode = 50 then begin
                OClientItem.s.Name := OClientItem.s.Name + ' #' + IntToStr(UserItem.Dura);
              end;
              sSENDMSG := sSENDMSG + EncodeBuffer(@OClientItem, SizeOf(TOClientItem)) + '/';
            end;
          end;
        end;
      end;
      if sSENDMSG <> '' then begin
        m_DefMsg := MakeDefaultMsg(SM_BAGITEMS, Integer(Self), 0, 0, m_ItemList.Count, 0);
        SendSocket(@m_DefMsg, sSENDMSG);
      end;
    end else begin
      sSENDMSG := '';
      if m_ItemList.Count > 0 then begin //20080628
        for I := 0 to m_ItemList.Count - 1 do begin
          UserItem := m_ItemList.Items[I];
          if UserItem <> nil then begin //20090115
            if CheckIsOKItem(UserItem) then begin //检查变态物品 20090704
              UserItem.wIndex := 0;
              UserItem.MakeIndex := 0;
              Continue;
            end;
            if (UserItem.AddValue[0] = 1) and (GetHoursCount(UserItem.MaxDate, Now) <= 0) then begin //删除到期装备 20110911
              UserItem.wIndex := 0;
              UserItem.MakeIndex := 0;
              Continue;
            end;
            if (UserItem.AddValue[0] = 2) and (GetHoursCount(UserItem.MaxDate, Now) <= 0) then begin //绑定到期，物品为正常状态 20110911
              UserItem.AddValue[0] := 0;
            end;
            Item := UserEngine.GetStdItem(UserItem.wIndex);
            if Item <> nil then begin
              FillChar(ClientItem, SizeOf(ClientItem), #0);
              StdItem := Item^;
              ItemUnit.GetItemAddValue(UserItem, StdItem);
              Move(StdItem, ClientItem.s, SizeOf(TStdItem));
              //取特效配置
              {By TasNat at: 2012-11-22 11:09:37
              EffecItem := GetEffecItemList(StdItem.Name); //取物品特效
              if EffecItem <> nil then begin
                Move(EffecItem^, ClientItem.ClientEffec, SizeOf(TEffecItem));
              end;}

              //发送聚灵珠的经验 20090502
              if (StdItem.StdMode = 51) and (StdItem.Shape = 0) and (UserItem.btValue[12] <> 2) and (UserItem.btValue[20] = 1) then begin
                if m_nWinExp >= 10000 then begin
                  Inc(UserItem.Dura);
                  dec(m_nWinExp, 10000);
                  if UserItem.Dura > UserItem.DuraMax then UserItem.Dura := UserItem.DuraMax;
                end;
                if (UserItem.Dura > 0) then begin
                  SendMsg(self, RM_EXPTIMEITEMS, 0, UserItem.MakeIndex, (n_UsesItemTick div 3600), 0, ''); //发送聚灵珠剩于时间 20080307
                end;
              end;

              //取自定义物品名称
              sUserItemName := '';
              if UserItem.btValue[13] = 1 then
                sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
              if (UserItem.btValue[12] = 1) and (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) then ClientItem.s.Reserved1 := 1 //物品发光 20080223
              else ClientItem.s.Reserved1 := 0;
              if sUserItemName <> '' then ClientItem.s.Name := sUserItemName;

              case StdItem.StdMode of //20090816
{$IF M2Version <> 2}
                5, 6: begin
                    ClientItem.s.NeedIdentify := _MIN(High(Byte), UserItem.btValue[11] + UserItem.btValue[20]); //武器暴击等级 20100708
                    if CheckItemSpiritMedia(UserItem) then begin
                      ClientItem.Aura := UserItem.btValue[12];
                      ClientItem.MaxAura := g_Config.nMaxAuraValue;
                    end;
                  end;
                10, 11, 15, 16, 19..24, 26..30, 52, 54, 55, 62, 64: begin
                    if CheckItemSpiritMedia(UserItem) then begin
                      ClientItem.Aura := UserItem.btValue[11];
                      ClientItem.MaxAura := g_Config.nMaxAuraValue;
                    end;
                  end;
                44: begin
                    if StdItem.Shape = 255 then ClientItem.s.NeedIdentify := UserItem.btValue[0];
                    if StdItem.Shape = 253 then begin //除魔灵媒
                      ClientItem.Aura := UserItem.btValue[11];
                      ClientItem.MaxAura := g_Config.nMaxAuraValue;
                    end;
                  end;
{$IFEND}
                8: if UserItem.btValue[0] <> 0 then ClientItem.s.AC := UserItem.btValue[0]; //材料的品质
                17: if StdItem.Weight > 0 then ClientItem.s.Weight := UserItem.Dura; //拆加物品的重量 20090816
                60: begin
                    if (StdItem.shape <> 0) then begin //酒类,除烧酒外 20080622
                      if UserItem.btValue[0] <> 0 then ClientItem.s.AC := UserItem.btValue[0]; //酒的品质
                      if UserItem.btValue[1] <> 0 then ClientItem.s.MAC := UserItem.btValue[1]; //酒的酒精度
                      if UserItem.btValue[3] > 0 then ClientItem.s.NeedLevel := UserItem.btValue[3] //酒的等级 20091117
                      else ClientItem.s.NeedLevel := 0;
                    end;
                  end;
              end;

              ClientItem.Dura := UserItem.Dura;
              ClientItem.DuraMax := UserItem.DuraMax;
              ClientItem.MakeIndex := UserItem.MakeIndex;
              Move(UserItem.btValue, ClientItem.btValue, SizeOf(ClientItem.btValue)); //20100822
              //Modified By TasNat at: 2012-04-12 09:28:18
              ClientItem.btAppraisalLevel :=   UserItem.btAppraisalLevel;
              ClientItem.btUnKnowValueCount := UserItem.btUnKnowValueCount;
              Move(UserItem.btAppraisalValue, ClientItem.btAppraisalValue, SizeOf(ClientItem.btAppraisalValue));

              Move(UserItem.btUnKnowValue, ClientItem.btUnKnowValue, SizeOf(ClientItem.btUnKnowValue)); //20100822
              ClientItem.BindValue := UserItem.AddValue[0]; //20110622
              ClientItem.MaxDate := UserItem.MaxDate; //20110622
              if ClientItem.BindValue = 0 then begin //禁止交易,扔物品,显示绑定 20110626
                if (CheckItemValue(UserItem, 1) and CheckItemValue(UserItem, 0)) or
                  (GetCheckItemList(0, StdItem.Name) and GetCheckItemList(1, StdItem.Name)) then
                  ClientItem.BindValue := 3;
              end;
              sSENDMSG := sSENDMSG + EncodeBuffer(@ClientItem, SizeOf(ClientItem)) + '/';
            end;
          end;
        end;
      end;
      if sSENDMSG <> '' then begin
        m_DefMsg := MakeDefaultMsg(SM_BAGITEMS, Integer(Self), 0, 0, m_ItemList.Count, 0);
        SendSocket(@m_DefMsg, sSENDMSG);
      end;
    end;
  finally
    m_boCanQueryBag := False;
  end;
end;
(* //未使用 20080907
procedure TPlayObject.ClientQueryUserSet(ProcessMsg: pTProcessMessage);
//var
//  sPassword: string;
begin
  {sPassword := Md5.EncryptString(ProcessMsg.sMsg);
  if sPassword <> DecodeString('NbA_VsaSTRucMbAjUl') then begin
    MainOutMessage('Fail');
    exit;
  end;
  m_nClientFlagMode := ProcessMsg.wParam;
  MainOutMessage(format('OK:%d', [m_nClientFlagMode]));}
  //'JackyWangFang'
  //'8988e0804091579a2fd8a0db75e9c17a';
  //'NbA_VsaSTRucMbAjUl'
end;  *)
//取玩家的等级排名 20080214

function TPlayObject.GetUserLevelOrder: Integer;
  function GetSelfHumMsg(HumSort: THumSort): Integer;
  var
    i: integer;
  begin
    Result := 0;
    if HumSort.nMaxIdx > 0 then begin
      for I := 0 to HumSort.nMaxIdx - 1 do begin
        if I >= MAXORDERSCOUNT then break; //20101009 增加
        if CompareText(HumSort.List[I].sChrName, m_sCharName) = 0 then begin
          Result := HumSort.List[I].nIndex;
          break;
        end;
      end;
    end;
  end;
//var
//  nIndex: Integer;
begin
  Result := 0;
  EnterCriticalSection(HumanSortCriticalSection);
  try
    try
      Result := GetSelfHumMsg(g_TaxisAllList);
    except
      Result := 0;
    end;
  finally
    LeaveCriticalSection(HumanSortCriticalSection);
  end;
end;
//获取人物等级排行  NPC内置排行榜

procedure TPlayObject.UserLevelOrder(BaseObject: TObject);
  function Add_space(Str: string; Size: Integer): string;
  begin
    Result := Str;
    if Length(Str) >= Size then Exit;
    while Length(Result) < Size do Result := Result + ' ';
  end;
var
  nIndex, nLevel: Integer;
  nPage: Integer;
  sIndex: string;
  sCharName: string;
  sLevel: string;
//  PlayObjectList: TStringList;
  boFound: Boolean;
  n01: Integer;
  n02: Integer;
  s01: string;
  Merchant: TMerchant;
  procedure GetSelfHumMsg(HumSort: THumSort);
  var
    i: integer;
  begin
    for I := 0 to HumSort.nMaxIdx - 1 do begin
      if CompareText(HumSort.List[I].sChrName, m_sCharName) = 0 then begin
        nIndex := HumSort.List[I].nIndex;
        nLevel := HumSort.List[I].wLevel;
        sCharName := HumSort.List[I].sChrName;
        break;
      end;
    end;
  end;
const
  sFirstStr1 = '序位                  角色名                      等级\';
  sFirstStr2 = '序位                  角色名                出师徒弟数\';
  sNotFoundStr = '您没有上榜或不在该榜！\';
begin
  EnterCriticalSection(HumanSortCriticalSection);
  try
    m_PlayOrderList.Clear;
    if m_nSelPlayOrderType = 4 then begin
      m_PlayOrderList.Add(sFirstStr2);
    end else begin
      m_PlayOrderList.Add(sFirstStr1);
    end;

    nPage := m_nPlayOrderPage;
    if m_boGetMyLevelOrder then begin //我的排行
      nIndex := 0;
      nLevel := 0;
      sCharName := '';
      m_boGetMyLevelOrder := False;
      boFound := False;
      case m_nSelPlayOrderType of
        0: begin
            GetSelfHumMsg(g_TaxisAllList);
            if (nIndex <> 0) and (sCharName <> '') and (nLevel > 0) then begin
              sIndex := IntToStr(nIndex);
              sLevel := IntToStr(nLevel);
              sIndex := Add_space(sIndex, 4 + 18);
              sCharName := Add_space(sCharName, 14 + 14);
              m_PlayOrderList.Add(sIndex + sCharName + sLevel + '\');
              boFound := True;
            end;
          end;
        1: begin
            GetSelfHumMsg(g_TaxisWarrList);
            if (nIndex <> 0) and (sCharName <> '') and (nLevel > 0) then begin
              sIndex := IntToStr(nIndex);
              sLevel := IntToStr(nLevel);
              sIndex := Add_space(sIndex, 4 + 18);
              sCharName := Add_space(sCharName, 14 + 14);
              m_PlayOrderList.Add(sIndex + sCharName + sLevel + '\');
              boFound := True;
            end;
          end;
        2: begin
            GetSelfHumMsg(g_TaxisWaidList);
            if (nIndex <> 0) and (sCharName <> '') and (nLevel > 0) then begin
              sIndex := IntToStr(nIndex);
              sLevel := IntToStr(nLevel);
              sIndex := Add_space(sIndex, 4 + 18);
              sCharName := Add_space(sCharName, 14 + 14);
              m_PlayOrderList.Add(sIndex + sCharName + sLevel + '\');
              boFound := True;
            end;
          end;
        3: begin
            GetSelfHumMsg(g_TaxisTaosList);
            if (nIndex <> 0) and (sCharName <> '') and (nLevel > 0) then begin
              sIndex := IntToStr(nIndex);
              sLevel := IntToStr(nLevel);
              sIndex := Add_space(sIndex, 4 + 18);
              sCharName := Add_space(sCharName, 14 + 14);
              m_PlayOrderList.Add(sIndex + sCharName + sLevel + '\');
              boFound := True;
            end;
          end;
        4: begin
            GetSelfHumMsg(g_MasterList);
            if (nIndex <> 0) and (sCharName <> '') and (nLevel > 0) then begin
              sIndex := IntToStr(nIndex);
              sLevel := IntToStr(nLevel);
              sIndex := Add_space(sIndex, 4 + 18);
              sCharName := Add_space(sCharName, 14 + 14);
              m_PlayOrderList.Add(sIndex + sCharName + sLevel + '\');
              boFound := True;
            end;
          end;
      end;
      if not boFound then begin
        m_PlayOrderList.Clear;
        m_PlayOrderList.Add(sNotFoundStr);
      end;
    end else begin
      n01 := 0;
      if nPage > 0 then begin
        case m_nSelPlayOrderType of
          0: begin
              for nIndex := nPage * 7 to g_TaxisAllList.nMaxIdx - 1 do begin
                if (n01 >= 7) or (g_TaxisAllList.nMaxIdx <= 0) then Break;
                sIndex := IntToStr(g_TaxisAllList.List[nIndex].nIndex);
                sLevel := IntToStr(g_TaxisAllList.List[nIndex].wLevel);
                sIndex := Add_space(sIndex, 4 + 18);
                sCharName := Add_space(g_TaxisAllList.List[nIndex].sChrName, 14 + 14);
                m_PlayOrderList.Add(sIndex + sCharName + sLevel + '\');
                Inc(n01);
              end;
            end;
          1: begin
              for nIndex := nPage * 7 to g_TaxisWarrList.nMaxIdx - 1 do begin
                if (n01 >= 7) or (g_TaxisWarrList.nMaxIdx <= 0) then Break;
                sIndex := IntToStr(g_TaxisWarrList.List[nIndex].nIndex);
                sLevel := IntToStr(g_TaxisWarrList.List[nIndex].wLevel);
                sIndex := Add_space(sIndex, 4 + 18);
                sCharName := Add_space(g_TaxisWarrList.List[nIndex].sChrName, 14 + 14);
                m_PlayOrderList.Add(sIndex + sCharName + sLevel + '\');
                Inc(n01);
              end;
            end;
          2: begin
              for nIndex := nPage * 7 to g_TaxisWaidList.nMaxIdx - 1 do begin
                if (n01 >= 7) or (g_TaxisWaidList.nMaxIdx <= 0) then Break;
                sIndex := IntToStr(g_TaxisWaidList.List[nIndex].nIndex);
                sLevel := IntToStr(g_TaxisWaidList.List[nIndex].wLevel);
                sIndex := Add_space(sIndex, 4 + 18);
                sCharName := Add_space(g_TaxisWaidList.List[nIndex].sChrName, 14 + 14);
                m_PlayOrderList.Add(sIndex + sCharName + sLevel + '\');
                Inc(n01);
              end;
            end;
          3: begin
              for nIndex := nPage * 7 to g_TaxisTaosList.nMaxIdx - 1 do begin
                if (n01 >= 7) or (g_TaxisTaosList.nMaxIdx <= 0) then Break;
                sIndex := IntToStr(g_TaxisTaosList.List[nIndex].nIndex);
                sLevel := IntToStr(g_TaxisTaosList.List[nIndex].wLevel);
                sIndex := Add_space(sIndex, 4 + 18);
                sCharName := Add_space(g_TaxisTaosList.List[nIndex].sChrName, 14 + 14);
                m_PlayOrderList.Add(sIndex + sCharName + sLevel + '\');
                Inc(n01);
              end;
            end;
          4: begin
              for nIndex := nPage * 7 to g_MasterList.nMaxIdx - 1 do begin
                if (n01 >= 7) or (g_MasterList.nMaxIdx <= 0) then Break;
                sIndex := IntToStr(g_MasterList.List[nIndex].nIndex);
                sLevel := IntToStr(g_MasterList.List[nIndex].wLevel);
                sIndex := Add_space(sIndex, 4 + 18);
                sCharName := Add_space(g_MasterList.List[nIndex].sChrName, 14 + 14);
                m_PlayOrderList.Add(sIndex + sCharName + sLevel + '\');
                Inc(n01);
              end;
            end;
        end;
      end else begin
        case m_nSelPlayOrderType of
          0: begin
              for nIndex := 0 to g_TaxisAllList.nMaxIdx - 1 do begin
                if (n01 >= 7) or (g_TaxisAllList.nMaxIdx <= 0) then Break;
                sIndex := IntToStr(g_TaxisAllList.List[nIndex].nIndex);
                sLevel := IntToStr(g_TaxisAllList.List[nIndex].wLevel);
                sIndex := Add_space(sIndex, 4 + 18);
                sCharName := Add_space(g_TaxisAllList.List[nIndex].sChrName, 14 + 14);
                m_PlayOrderList.Add(sIndex + sCharName + sLevel + '\');
                Inc(n01);
              end;
            end;
          1: begin
              for nIndex := 0 to g_TaxisWarrList.nMaxIdx - 1 do begin
                if (n01 >= 7) or (g_TaxisWarrList.nMaxIdx <= 0) then Break;
                sIndex := IntToStr(g_TaxisWarrList.List[nIndex].nIndex);
                sLevel := IntToStr(g_TaxisWarrList.List[nIndex].wLevel);
                sIndex := Add_space(sIndex, 4 + 18);
                sCharName := Add_space(g_TaxisWarrList.List[nIndex].sChrName, 14 + 14);
                m_PlayOrderList.Add(sIndex + sCharName + sLevel + '\');
                Inc(n01);
              end;
            end;
          2: begin
              for nIndex := 0 to g_TaxisWaidList.nMaxIdx - 1 do begin
                if (n01 >= 7) or (g_TaxisWaidList.nMaxIdx <= 0) then Break;
                sIndex := IntToStr(g_TaxisWaidList.List[nIndex].nIndex);
                sLevel := IntToStr(g_TaxisWaidList.List[nIndex].wLevel);
                sIndex := Add_space(sIndex, 4 + 18);
                sCharName := Add_space(g_TaxisWaidList.List[nIndex].sChrName, 14 + 14);
                m_PlayOrderList.Add(sIndex + sCharName + sLevel + '\');
                Inc(n01);
              end;
            end;
          3: begin
              for nIndex := 0 to g_TaxisTaosList.nMaxIdx - 1 do begin
                if (n01 >= 7) or (g_TaxisTaosList.nMaxIdx <= 0) then Break;
                sIndex := IntToStr(g_TaxisTaosList.List[nIndex].nIndex);
                sLevel := IntToStr(g_TaxisTaosList.List[nIndex].wLevel);
                sIndex := Add_space(sIndex, 4 + 18);
                sCharName := Add_space(g_TaxisTaosList.List[nIndex].sChrName, 14 + 14);
                m_PlayOrderList.Add(sIndex + sCharName + sLevel + '\');
                Inc(n01);
              end;
            end;
          4: begin
              for nIndex := 0 to g_MasterList.nMaxIdx - 1 do begin
                if (n01 >= 7) or (g_MasterList.nMaxIdx <= 0) then Break;
                sIndex := IntToStr(g_MasterList.List[nIndex].nIndex);
                sLevel := IntToStr(g_MasterList.List[nIndex].wLevel);
                sIndex := Add_space(sIndex, 4 + 18);
                sCharName := Add_space(g_MasterList.List[nIndex].sChrName, 14 + 14);
                m_PlayOrderList.Add(sIndex + sCharName + sLevel + '\');
                Inc(n01);
              end;
            end;
        end;
      end;
    end;
    if m_PlayOrderList.Count > 0 then begin
      n02 := 8 - m_PlayOrderList.Count;
      if n02 > 0 then begin
        for nIndex := 1 to n02 do begin
          s01 := m_PlayOrderList.Strings[m_PlayOrderList.Count - 1];
          m_PlayOrderList.Strings[m_PlayOrderList.Count - 1] := s01 + ' \';
        end;
      end;
    end;
    Merchant := UserEngine.FindMerchant(BaseObject);
    if Merchant <> nil then Merchant.GotoLable(Self, '@LevelOrder', False, False);
  finally
    LeaveCriticalSection(HumanSortCriticalSection);
  end;
end;
//客户端查看别人的装备

procedure TPlayObject.ClientQueryUserState(BaseObject: TBaseObject; nX, nY: Integer);
var
  I: Integer;
  UserState: TUserStateInfo;
  OUserState: TOUserStateInfo;
  StdItem: pTStdItem;
  StdItem24: TStdItem;
  ClientItem: TClientItem;
  EffecItem: pTEffecItem;
  OClientItem: TOClientItem;
  sUserItemName: string;
  UserItem: pTUserItem;
  boCopyHum: Byte; //是否是分身 20080413
  nCode: byte; //20090108
{$IF M2Version <> 2}
  K, L, nHours: Integer;
  HumTitle: pTHumTitleDB;
{$IFEND}
begin
  nCode := 0;
  try
    if BaseObject <> nil then begin //20090104
      if not BaseObject.m_boGhost then begin //20090104
        boCopyHum := 0;
        nCode := 1;
        if (m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0) then begin
          if not CretInNearXY(BaseObject, nX, nY) then Exit;
          FillChar(OUserState, SizeOf(TOUserStateInfo), #0);
          BaseObject.GetFeature(OUserState.feature);
          OUserState.UserName := BaseObject.m_sCharName;
          OUserState.NAMECOLOR := GetCharColor(BaseObject);
          nCode := 2;
          if BaseObject.m_btRaceServer = RC_PLAYMOSTER then begin
            if BaseObject.m_Master <> nil then begin
              if BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin //人物的分身
                OUserState.GuildName := BaseObject.m_Master.m_sCharName; //20080410 人形显示主人名字
                boCopyHum := 1;
              end else
                if BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT then begin //英雄的分身
                  if BaseObject.m_Master.m_Master <> nil then begin //20090205
                    OUserState.GuildName := BaseObject.m_Master.m_Master.m_sCharName; //20080414 显示英雄主人名字
                    boCopyHum := 2;
                  end;
                end;
            end else OUserState.UserName := FilterShowName(OUserState.UserName); //人形怪过滤有数字的名称 20090104
          end;
          nCode := 3;
          if BaseObject.m_btRaceServer = RC_HEROOBJECT then begin //如果是英雄 那么就把行会名为主人名 20080229
            if BaseObject.m_Master <> nil then begin //20090205
              OUserState.GuildName := BaseObject.m_Master.m_sCharName;
              boCopyHum := 3;
            end;
          end else begin
            if BaseObject.m_MyGuild <> nil then begin
              OUserState.GuildName := TGUild(BaseObject.m_MyGuild).sGuildName;
            end;
            OUserState.GuildRankName := BaseObject.m_sGuildRankName;
          end;
          nCode := 4;
          if g_Config.boUnKnowHum and BaseObject.IsUsesZhuLi then begin
            OUserState.UserName := '神秘人'; //带上斗笠即显示神秘人 20080424
            OUserState.GuildRankName := '';
            OUserState.GuildName := '';
            boCopyHum := 0;
          end;
          nCode := 5;
          for I := Low(THumItems) to High(THumItems) do begin
            UserItem := @BaseObject.m_UseItems[I];
            if UserItem <> nil then begin //20090205
              if UserItem.wIndex > 0 then begin
                StdItem := UserEngine.GetStdItem(BaseObject.m_UseItems[I].wIndex);
                if StdItem = nil then Continue;
                StdItem24 := StdItem^;
                ItemUnit.GetItemAddValue(@BaseObject.m_UseItems[I], StdItem24);
                //Move(StdItem24,ClientItem.S,SizeOf(TStdItem));
                CopyStdItemToOStdItem(@StdItem24, @OClientItem.s);

                //取自定义物品名称
                sUserItemName := '';
                if UserItem.btValue[13] = 1 then
                  sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
                if sUserItemName <> '' then
                  OClientItem.s.Name := sUserItemName;

                OClientItem.MakeIndex := BaseObject.m_UseItems[I].MakeIndex;
                OClientItem.Dura := BaseObject.m_UseItems[I].Dura;
                OClientItem.DuraMax := BaseObject.m_UseItems[I].DuraMax;
                OUserState.UseItems[I] := OClientItem;
              end;
            end;
          end;
          nCode := 6;
          if ((BaseObject.m_btRaceServer = RC_HEROOBJECT) and (boCopyHum <> 0)) or ((BaseObject.m_btRaceServer = RC_PLAYMOSTER) and (boCopyHum = 2)) then
            m_DefMsg := MakeDefaultMsg(SM_SENDUSERSTATE, 1, 0, 0, 0, 0)
          else
            if (boCopyHum = 1) and (BaseObject.m_btRaceServer = RC_PLAYMOSTER) then //20080413 人形客户显示名字+的分身
              m_DefMsg := MakeDefaultMsg(SM_SENDUSERSTATE, 2, 0, 0, 0, 0)
            else
              m_DefMsg := MakeDefaultMsg(SM_SENDUSERSTATE, 0, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, EncodeBuffer(@OUserState, SizeOf(TOUserStateInfo)));
        end else begin
          nCode := 7;
          if not CretInNearXY(BaseObject, nX, nY) then Exit;
          FillChar(UserState, SizeOf(TUserStateInfo), #0);

          BaseObject.GetFeature(UserState.feature);
          UserState.UserName := BaseObject.m_sCharName;
          UserState.NAMECOLOR := GetCharColor(BaseObject);
          UserState.btJob := BaseObject.m_btJob; //角色职业 20110113
          nCode := 80;
          if BaseObject.m_btRaceServer = RC_PLAYMOSTER then begin
            nCode := 81;
            if BaseObject.m_Master <> nil then begin
              nCode := 82;
              if BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin //人物的分身
                nCode := 83;
                UserState.GuildName := BaseObject.m_Master.m_sCharName; //20080410 人形显示主人名字
                boCopyHum := 1;
              end else
                if BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT then begin //英雄的分身
                  nCode := 84;
                  if BaseObject.m_Master.m_Master <> nil then begin //20090205
                    nCode := 85;
                    UserState.GuildName := BaseObject.m_Master.m_Master.m_sCharName; //20080414 显示英雄主人名字
                    boCopyHum := 2;
                  end;
                end;
            end else UserState.UserName := FilterShowName(UserState.UserName); //人形怪过滤有数字的名称 20090104
          end;
          nCode := 9;
          if BaseObject.m_btRaceServer = RC_HEROOBJECT then begin //如果是英雄 那么就把行会名为主人名  20080229
            if BaseObject.m_Master <> nil then begin //20090205
              if g_Config.boUnKnowHum and BaseObject.m_Master.IsUsesZhuLi then //主人为神秘人时 20080806
                UserState.GuildName := '神秘人'
              else UserState.GuildName := BaseObject.m_Master.m_sCharName;
              boCopyHum := 3;
            end;
          end else begin
            if BaseObject.m_MyGuild <> nil then begin
              UserState.GuildName := TGUild(BaseObject.m_MyGuild).sGuildName;
            end;
            UserState.GuildRankName := BaseObject.m_sGuildRankName;
          end;
          nCode := 10;
          if g_Config.boUnKnowHum and BaseObject.IsUsesZhuLi then begin
            UserState.UserName := '神秘人'; //带上斗笠即显示神秘人 20080424
            UserState.GuildRankName := '';
            UserState.GuildName := '';
            boCopyHum := 0;
          end;
          nCode := 11;
          for I := Low(THumanUseItems) to High(THumanUseItems) do begin //9格装备+4格装备
            UserItem := @BaseObject.m_UseItems[I];
            if UserItem <> nil then begin
              if UserItem.wIndex > 0 then begin
                if (UserItem.AddValue[0] = 1) and (GetHoursCount(UserItem.MaxDate, Now) <= 0) then Continue; //删除到期装备
                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                nCode := 12;
                if StdItem = nil then Continue;
                FillChar(ClientItem, SizeOf(ClientItem), #0);
                StdItem24 := StdItem^;
                ItemUnit.GetItemAddValue(@BaseObject.m_UseItems[I], StdItem24);
                Move(StdItem24, ClientItem.s, SizeOf(TStdItem));
                //取特效配置
                { By TasNat at: 2012-11-22 11:10:21
                EffecItem := GetEffecItemList(StdItem.Name); //取物品特效
                if EffecItem <> nil then begin
                  Move(EffecItem^, ClientItem.ClientEffec, SizeOf(TEffecItem));
                end;  }
                nCode := 13;
                //取自定义物品名称
                sUserItemName := '';
                if UserItem.btValue[13] = 1 then
                  sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
                if (UserItem.btValue[12] = 1) and (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) then ClientItem.s.Reserved1 := 1 //物品发光 20080223
                else ClientItem.s.Reserved1 := 0;
{$IF M2Version <> 2}
                if (StdItem.StdMode = 5) or (StdItem.StdMode = 6) then begin //武器暴击等级 20100708
                  ClientItem.s.NeedIdentify := _MIN(High(Byte), UserItem.btValue[11] + UserItem.btValue[20]);
                  if CheckItemSpiritMedia(UserItem) then begin
                    ClientItem.Aura := UserItem.btValue[12];
                    ClientItem.MaxAura := g_Config.nMaxAuraValue;
                  end;
                end else begin
                  if CheckItemSpiritMedia(UserItem) or ((StdItem.StdMode = 44) and (StdItem.shape = 253)) then begin
                    ClientItem.Aura := UserItem.btValue[11];
                    ClientItem.MaxAura := g_Config.nMaxAuraValue;
                  end;
                end;
                if (StdItem.StdMode = 44) and (StdItem.shape = 255) then begin //神秘卷轴
                  ClientItem.s.NeedIdentify := UserItem.btValue[0];
                end;
{$IFEND}
                if sUserItemName <> '' then ClientItem.s.Name := sUserItemName;
                nCode := 14;
                ClientItem.MakeIndex := BaseObject.m_UseItems[I].MakeIndex;
                ClientItem.Dura := BaseObject.m_UseItems[I].Dura;
                ClientItem.DuraMax := BaseObject.m_UseItems[I].DuraMax;
                //Modified By TasNat at: 2012-04-12 09:28:18
                ClientItem.btAppraisalLevel :=   BaseObject.m_UseItems[I].btAppraisalLevel;
                ClientItem.btUnKnowValueCount := BaseObject.m_UseItems[I].btUnKnowValueCount;
                Move(BaseObject.m_UseItems[I].btAppraisalValue, ClientItem.btAppraisalValue, SizeOf(ClientItem.btAppraisalValue));

                Move(BaseObject.m_UseItems[I].btUnKnowValue, ClientItem.btUnKnowValue, SizeOf(ClientItem.btUnKnowValue)); //20100822
                ClientItem.BindValue := BaseObject.m_UseItems[I].AddValue[0]; //20110622
                ClientItem.MaxDate := BaseObject.m_UseItems[I].MaxDate; //20110622
                if ClientItem.BindValue = 0 then begin //禁止交易,扔物品,显示绑定 20110626
                  if (CheckItemValue(@BaseObject.m_UseItems[I], 1) and
                    CheckItemValue(@BaseObject.m_UseItems[I], 0)) or
                    (GetCheckItemList(0, StdItem.Name) and GetCheckItemList(1, StdItem.Name)) then
                    ClientItem.BindValue := 3;
                end;
                UserState.UseItems[I] := ClientItem;
              end;
            end;
          end;
          case BaseObject.m_btRaceServer of //套装属性值 20110711
            RC_PLAYOBJECT: UserState.SuitAbility := TPlayObject(BaseObject).ClientSuitAbility;
            RC_HEROOBJECT: UserState.SuitAbility := THeroObject(BaseObject).ClientSuitAbility;
          end;
{$IF M2Version <> 2}
          L := 0;
          case BaseObject.m_btRaceServer of //发送称号数据
            RC_PLAYOBJECT: begin
                with TPlayObject(BaseObject) do begin
                  if m_Magic103Skill <> nil then UserState.nCallTrollLevel := m_Magic103Skill.btLevel; //召唤巨魔等级
                  if m_boCanTitle then begin
                    K := 0;
                    FillChar(UserState.wHumTitles, SizeOf(TClientHumTitles), #0);
                    for I := Low(THumTitles) to High(THumTitles) do begin
                      if (m_wHumTitles[I].wIndex > 0) and (m_wHumTitles[I].MakeIndex > 0) then begin
                        HumTitle := UserEngine.GetHumTitle(m_wHumTitles[I].wIndex);
                        if HumTitle <> nil then begin
                          if HumTitle.StdMode = 1 then begin
                            Inc(L);
                            UserState.wHumTitles.ClientHumTitles[K].MakeIndex := m_wHumTitles[I].MakeIndex;
                            UserState.wHumTitles.ClientHumTitles[K].StdMode := HumTitle.StdMode; //分类
                            UserState.wHumTitles.ClientHumTitles[K].AniCount := HumTitle.AniCount; //特效ID
                            UserState.wHumTitles.ClientHumTitles[K].sTitleName := HumTitle.sTitleName; //称号名
                            UserState.wHumTitles.ClientHumTitles[K].Looks := HumTitle.Looks;
                            UserState.wHumTitles.ClientHumTitles[K].wDC := HiWord(HumTitle.DC); //攻击上限
                            UserState.wHumTitles.ClientHumTitles[K].wMC := HiWord(HumTitle.MC); //魔法上限
                            UserState.wHumTitles.ClientHumTitles[K].wSC := HiWord(HumTitle.SC); //道术上限
                            UserState.wHumTitles.ClientHumTitles[K].wHP := LoWord(HumTitle.AC); //生命上限
                            UserState.wHumTitles.ClientHumTitles[K].nHours := 65535; //剩余小时(65535) 表示永久
                            if m_wHumTitles[I].boUseTitle then begin
                              UserState.wHumTitles.nUseTitleIndex := L;
                            end;
                            case HumTitle.AniCount of
                              1: UserState.wHumTitles.ClientHumTitles[K].wDura := m_wHumTitles[I].wDura; //千里传音次数(水晶之星)
                              5: UserState.wHumTitles.ClientHumTitles[K].wDura := _MAX(0, 3 - m_nDieCount); //随机攻击倍数(巅峰勇士类)
                            end;
                            Inc(K);
                          end else begin
                            nHours := GetHoursCount(m_wHumTitles[I].ApplyDate, Now());
                            if nHours > 0 then begin
                              Inc(L);
                              case HumTitle.AniCount of
                                1: begin //水晶之星
                                    UserState.wHumTitles.ClientHumTitles[K].MakeIndex := m_wHumTitles[I].MakeIndex;
                                    UserState.wHumTitles.ClientHumTitles[K].StdMode := HumTitle.StdMode; //分类
                                    UserState.wHumTitles.ClientHumTitles[K].AniCount := HumTitle.AniCount; //特效ID
                                    UserState.wHumTitles.ClientHumTitles[K].sTitleName := HumTitle.sTitleName; //称号名
                                    UserState.wHumTitles.ClientHumTitles[K].Looks := HumTitle.Looks;
                                    UserState.wHumTitles.ClientHumTitles[K].wDC := HiWord(HumTitle.DC); //攻击上限
                                    UserState.wHumTitles.ClientHumTitles[K].wMC := HiWord(HumTitle.MC); //魔法上限
                                    UserState.wHumTitles.ClientHumTitles[K].wSC := HiWord(HumTitle.SC); //道术上限
                                    UserState.wHumTitles.ClientHumTitles[K].wHP := LoWord(HumTitle.AC); //生命上限
                                    UserState.wHumTitles.ClientHumTitles[K].nHours := nHours; //剩余小时(65535) 表示永久
                                    if m_wHumTitles[I].boUseTitle then begin
                                      UserState.wHumTitles.nUseTitleIndex := L;
                                    end;
                                    UserState.wHumTitles.ClientHumTitles[K].wDura := m_wHumTitles[I].wDura; //千里传音次数
                                  end;
                                5: begin
                                    if m_nDieCount > 2 then Continue; //继续
                                    UserState.wHumTitles.ClientHumTitles[K].MakeIndex := m_wHumTitles[I].MakeIndex;
                                    UserState.wHumTitles.ClientHumTitles[K].StdMode := HumTitle.StdMode; //分类
                                    UserState.wHumTitles.ClientHumTitles[K].AniCount := HumTitle.AniCount; //特效ID
                                    UserState.wHumTitles.ClientHumTitles[K].sTitleName := HumTitle.sTitleName; //称号名
                                    UserState.wHumTitles.ClientHumTitles[K].Looks := HumTitle.Looks;
                                    UserState.wHumTitles.ClientHumTitles[K].wDC := HiWord(HumTitle.DC); //攻击上限
                                    UserState.wHumTitles.ClientHumTitles[K].wMC := HiWord(HumTitle.MC); //魔法上限
                                    UserState.wHumTitles.ClientHumTitles[K].wSC := HiWord(HumTitle.SC); //道术上限
                                    UserState.wHumTitles.ClientHumTitles[K].wHP := LoWord(HumTitle.AC); //生命上限
                                    UserState.wHumTitles.ClientHumTitles[K].nHours := nHours; //剩余小时(65535) 表示永久
                                    if m_wHumTitles[I].boUseTitle then begin
                                      UserState.wHumTitles.nUseTitleIndex := L;
                                    end;
                                    UserState.wHumTitles.ClientHumTitles[K].wDura := _MAX(0, 3 - m_nDieCount); //随机攻击倍数(巅峰勇士类)
                                  end;
                              else begin
                                  UserState.wHumTitles.ClientHumTitles[K].MakeIndex := m_wHumTitles[I].MakeIndex;
                                  UserState.wHumTitles.ClientHumTitles[K].StdMode := HumTitle.StdMode; //分类
                                  UserState.wHumTitles.ClientHumTitles[K].AniCount := HumTitle.AniCount; //特效ID
                                  UserState.wHumTitles.ClientHumTitles[K].sTitleName := HumTitle.sTitleName; //称号名
                                  UserState.wHumTitles.ClientHumTitles[K].Looks := HumTitle.Looks;
                                  UserState.wHumTitles.ClientHumTitles[K].wDC := HiWord(HumTitle.DC); //攻击上限
                                  UserState.wHumTitles.ClientHumTitles[K].wMC := HiWord(HumTitle.MC); //魔法上限
                                  UserState.wHumTitles.ClientHumTitles[K].wSC := HiWord(HumTitle.SC); //道术上限
                                  UserState.wHumTitles.ClientHumTitles[K].wHP := LoWord(HumTitle.AC); //生命上限
                                  UserState.wHumTitles.ClientHumTitles[K].nHours := nHours; //剩余小时(65535) 表示永久
                                  if m_wHumTitles[I].boUseTitle then begin
                                    UserState.wHumTitles.nUseTitleIndex := L;
                                  end;
                                end;
                              end;
                              Inc(K);
                            end;
                          end;
                        end;
                      end;
                    end;
                  end;
                end;
              end;
            RC_PLAYMOSTER: begin
                if BaseObject.m_Master <> nil then begin
                  if (BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT) and (not BaseObject.m_Master.m_boGhost) then begin //人物的分身
                    with TPlayObject(BaseObject.m_Master) do begin
                      if m_Magic103Skill <> nil then UserState.nCallTrollLevel := m_Magic103Skill.btLevel;
                      if m_boCanTitle then begin
                        K := 0;
                        FillChar(UserState.wHumTitles, SizeOf(TClientHumTitles), #0);
                        for I := Low(THumTitles) to High(THumTitles) do begin
                          if (m_wHumTitles[I].wIndex > 0) and (m_wHumTitles[I].MakeIndex > 0) then begin
                            HumTitle := UserEngine.GetHumTitle(m_wHumTitles[I].wIndex);
                            if HumTitle <> nil then begin
                              if HumTitle.StdMode = 1 then begin
                                Inc(L);
                                UserState.wHumTitles.ClientHumTitles[K].MakeIndex := m_wHumTitles[I].MakeIndex;
                                UserState.wHumTitles.ClientHumTitles[K].StdMode := HumTitle.StdMode; //分类
                                UserState.wHumTitles.ClientHumTitles[K].AniCount := HumTitle.AniCount; //特效ID
                                UserState.wHumTitles.ClientHumTitles[K].sTitleName := HumTitle.sTitleName; //称号名
                                UserState.wHumTitles.ClientHumTitles[K].Looks := HumTitle.Looks;
                                UserState.wHumTitles.ClientHumTitles[K].wDC := HiWord(HumTitle.DC); //攻击上限
                                UserState.wHumTitles.ClientHumTitles[K].wMC := HiWord(HumTitle.MC); //魔法上限
                                UserState.wHumTitles.ClientHumTitles[K].wSC := HiWord(HumTitle.SC); //道术上限
                                UserState.wHumTitles.ClientHumTitles[K].wHP := LoWord(HumTitle.AC); //生命上限
                                UserState.wHumTitles.ClientHumTitles[K].nHours := 65535; //剩余小时(65535) 表示永久
                                if m_wHumTitles[I].boUseTitle then begin
                                  UserState.wHumTitles.nUseTitleIndex := L;
                                end;
                                case HumTitle.AniCount of
                                  1: UserState.wHumTitles.ClientHumTitles[K].wDura := m_wHumTitles[I].wDura; //千里传音次数
                                  5: UserState.wHumTitles.ClientHumTitles[K].wDura := _MAX(0, 3 - m_nDieCount); //随机攻击倍数(巅峰勇士类)
                                end;
                                Inc(K);
                              end else begin
                                nHours := GetHoursCount(m_wHumTitles[I].ApplyDate, Now());
                                if nHours > 0 then begin
                                  Inc(L);
                                  case HumTitle.AniCount of
                                    1: begin
                                        UserState.wHumTitles.ClientHumTitles[K].MakeIndex := m_wHumTitles[I].MakeIndex;
                                        UserState.wHumTitles.ClientHumTitles[K].StdMode := HumTitle.StdMode; //分类
                                        UserState.wHumTitles.ClientHumTitles[K].AniCount := HumTitle.AniCount; //特效ID
                                        UserState.wHumTitles.ClientHumTitles[K].sTitleName := HumTitle.sTitleName; //称号名
                                        UserState.wHumTitles.ClientHumTitles[K].Looks := HumTitle.Looks;
                                        UserState.wHumTitles.ClientHumTitles[K].wDC := HiWord(HumTitle.DC); //攻击上限
                                        UserState.wHumTitles.ClientHumTitles[K].wMC := HiWord(HumTitle.MC); //魔法上限
                                        UserState.wHumTitles.ClientHumTitles[K].wSC := HiWord(HumTitle.SC); //道术上限
                                        UserState.wHumTitles.ClientHumTitles[K].wHP := LoWord(HumTitle.AC); //生命上限
                                        UserState.wHumTitles.ClientHumTitles[K].nHours := nHours; //剩余小时(65535) 表示永久
                                        if m_wHumTitles[I].boUseTitle then begin
                                          UserState.wHumTitles.nUseTitleIndex := L;
                                        end;
                                        UserState.wHumTitles.ClientHumTitles[K].wDura := m_wHumTitles[I].wDura; //千里传音次数
                                      end;
                                    5: begin
                                        if m_nDieCount > 2 then Continue; //继续
                                        UserState.wHumTitles.ClientHumTitles[K].MakeIndex := m_wHumTitles[I].MakeIndex;
                                        UserState.wHumTitles.ClientHumTitles[K].StdMode := HumTitle.StdMode; //分类
                                        UserState.wHumTitles.ClientHumTitles[K].AniCount := HumTitle.AniCount; //特效ID
                                        UserState.wHumTitles.ClientHumTitles[K].sTitleName := HumTitle.sTitleName; //称号名
                                        UserState.wHumTitles.ClientHumTitles[K].Looks := HumTitle.Looks;
                                        UserState.wHumTitles.ClientHumTitles[K].wDC := HiWord(HumTitle.DC); //攻击上限
                                        UserState.wHumTitles.ClientHumTitles[K].wMC := HiWord(HumTitle.MC); //魔法上限
                                        UserState.wHumTitles.ClientHumTitles[K].wSC := HiWord(HumTitle.SC); //道术上限
                                        UserState.wHumTitles.ClientHumTitles[K].wHP := LoWord(HumTitle.AC); //生命上限
                                        UserState.wHumTitles.ClientHumTitles[K].nHours := nHours; //剩余小时(65535) 表示永久
                                        if m_wHumTitles[I].boUseTitle then begin
                                          UserState.wHumTitles.nUseTitleIndex := L;
                                        end;
                                        UserState.wHumTitles.ClientHumTitles[K].wDura := _MAX(0, 3 - m_nDieCount); //随机攻击倍数(巅峰勇士类)
                                      end;
                                  else begin
                                      UserState.wHumTitles.ClientHumTitles[K].MakeIndex := m_wHumTitles[I].MakeIndex;
                                      UserState.wHumTitles.ClientHumTitles[K].StdMode := HumTitle.StdMode; //分类
                                      UserState.wHumTitles.ClientHumTitles[K].AniCount := HumTitle.AniCount; //特效ID
                                      UserState.wHumTitles.ClientHumTitles[K].sTitleName := HumTitle.sTitleName; //称号名
                                      UserState.wHumTitles.ClientHumTitles[K].Looks := HumTitle.Looks;
                                      UserState.wHumTitles.ClientHumTitles[K].wDC := HiWord(HumTitle.DC); //攻击上限
                                      UserState.wHumTitles.ClientHumTitles[K].wMC := HiWord(HumTitle.MC); //魔法上限
                                      UserState.wHumTitles.ClientHumTitles[K].wSC := HiWord(HumTitle.SC); //道术上限
                                      UserState.wHumTitles.ClientHumTitles[K].wHP := LoWord(HumTitle.AC); //生命上限
                                      UserState.wHumTitles.ClientHumTitles[K].nHours := nHours; //剩余小时(65535) 表示永久
                                      if m_wHumTitles[I].boUseTitle then begin
                                        UserState.wHumTitles.nUseTitleIndex := L;
                                      end;
                                    end;
                                  end;
                                  Inc(K);
                                end;
                              end;
                            end;
                          end;
                        end;
                      end;
                    end;
                  end;
                end;
              end;
          end;
{$IFEND}
          nCode := 15;
          if ((BaseObject.m_btRaceServer = RC_HEROOBJECT) and (boCopyHum <> 0)) or
            ((BaseObject.m_btRaceServer = RC_PLAYMOSTER) and (boCopyHum = 2)) then //英雄,英雄的分身 20080414
            m_DefMsg := MakeDefaultMsg(SM_SENDUSERSTATE, 1, 0, 0, 0, 0)
          else
            if (boCopyHum = 1) and (BaseObject.m_btRaceServer = RC_PLAYMOSTER) then //人形客户显示名字+的分身
              m_DefMsg := MakeDefaultMsg(SM_SENDUSERSTATE, 2, 0, 0, 0, 0)
            else
              if (BaseObject.m_btRaceServer = RC_PLAYMOSTER) then
                m_DefMsg := MakeDefaultMsg(SM_SENDUSERSTATE, 3, 0, 0, 0, 0)
              else
                m_DefMsg := MakeDefaultMsg(SM_SENDUSERSTATE, 0, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, EncodeBuffer(@UserState, SizeOf(TUserStateInfo)));
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TPlayObject.ClientQueryUserState Code:%d.%p', [g_sExceptionVer, nCode, ExceptAddr]));
  end;
end;

//修复封发包跳转Label造成不能玩色子. By TasNat at: 2012-06-23 16:08:29
procedure TPlayObject.ClientMerchantDlgSelectPLAYDICELabel(nParam1: Integer);
var
  NPC: TNormNpc;
  I : Integer;
  sMsg : string;
begin
  if m_boDeath or m_boGhost then Exit;
  NPC := UserEngine.FindMerchant(TObject(nParam1));
  if NPC = nil then NPC := UserEngine.FindNPC(TObject(nParam1));
  if NPC = nil then Exit;
  if ((NPC.m_PEnvir = m_PEnvir) and (abs(NPC.m_nCurrX - m_nCurrX) < 15) and
    (abs(NPC.m_nCurrY - m_nCurrY) < 15)) or (NPC.m_boIsHide) then begin
    UpdateSendMsgCount(); //更新角色的动态密钥(防WPE)
    //修复色子不跳转By TasNat at:2012-12-09 11:32:38
    NPC.UserSelect(Self, Trim(m_sPlayDiceLabel));

  end;
end;

//NPC对话框返回

procedure TPlayObject.ClientMerchantDlgSelect(nParam1: Integer; sMsg: string; wMsgLen : Word);
var
  NPC: TNormNpc;
  I : Integer;
  Buf : array [1..1024] of Char;
begin
  if m_boDeath or m_boGhost then Exit;
  NPC := UserEngine.FindMerchant(TObject(nParam1));
  DecodeBuffer(sMsg, @Buf, wMsgLen);
  SetLength(sMsg, wMsgLen);
  Move(Buf, sMsg[1], wMsgLen);
  for I := 1 to Length(sMsg) do

    sMsg[I] := Char(Byte(sMsg[I]) xor (nParam1 mod I + 2));
  if NPC = nil then NPC := UserEngine.FindNPC(TObject(nParam1));
  if NPC = nil then Exit;
  if ((NPC.m_PEnvir = m_PEnvir) and (abs(NPC.m_nCurrX - m_nCurrX) < 15) and
    (abs(NPC.m_nCurrY - m_nCurrY) < 15)) or (NPC.m_boIsHide) then begin
    UpdateSendMsgCount(); //更新角色的动态密钥(防WPE)
    if (pos('@@InPutString', sMsg) <> 0) or (pos('@@InPutInteger', sMsg) <> 0) or (NPC = g_FunctionNPC) then begin
      if m_boNPCCanGoto then begin
        m_boNPCCanGoto := False;
        NPC.UserSelect(Self, Trim(sMsg));
      end;
    end else begin
      NPC.UserSelect(Self, Trim(sMsg));
    end;
  end;
end;
//出售物品，把物品放到交易框中，取物品价格

procedure TPlayObject.ClientMerchantQuerySellPrice(nParam1, nMakeIndex: Integer;
  sMsg: string);
var
  I: Integer;
  UserItem: pTUserItem;
  UserItem18: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
begin
  UserItem18 := nil;
  if m_ItemList.Count > 0 then begin //20080628
    for I := 0 to m_ItemList.Count - 1 do begin
      UserItem := m_ItemList.Items[I];
      if UserItem = nil then Continue;
      if UserItem.MakeIndex = nMakeIndex then begin
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
        if CompareText(sUserItemName, sMsg) = 0 then begin
          UserItem18 := UserItem;
          Break;
        end;
      end;
    end;
  end;
  if UserItem18 = nil then Exit;
  Merchant := UserEngine.FindMerchant(TObject(nParam1));
  if Merchant = nil then Exit;
  if ((Merchant.m_PEnvir = m_PEnvir) and
    (Merchant.m_boSell) and
    (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
    (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientQuerySellPrice(Self, UserItem18);
end;
{//接收客户端拍卖的物品数据,并写入列表 20080316          //20080416 去掉拍卖功能
procedure TPlayObject.ClientUserSellOffItem(nParam1, nMakeIndex: Integer; sMsg: string); //拍卖
var
  I: Integer;
  UserItem: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
  sSellGold: string;
  SellOffInfo: pTSellOffInfo;
begin
  for I := m_ItemList.Count - 1 downto 0 do begin
    if m_ItemList.Count <= 0 then Break;
    UserItem := m_ItemList.Items[I];
    if (UserItem <> nil) and (UserItem.MakeIndex = nMakeIndex) then begin
      //取自定义物品名称
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
      sMsg := GetValidStr3(sMsg, sSellGold, ['/']);
      if CompareText(sUserItemName, sMsg) = 0 then begin
        Merchant := UserEngine.FindMerchant(TObject(nParam1));
        if (Merchant <> nil) and
          (Merchant.m_boSellOff) and
          ((Merchant.m_PEnvir = m_PEnvir) and
          (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
          (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then begin
          New(SellOffInfo);
          SellOffInfo^.sCharName := m_sCharName;
          SellOffInfo^.dSellDateTime := Now;
          SellOffInfo^.nSellGold := Str_ToInt(sSellGold, 0);
          FillChar(SellOffInfo^.UseItems, SizeOf(TUserItem), #0);
          SellOffInfo^.UseItems := UserItem^;
          SellOffInfo^.n := Integer(Self); //nParam1;
          SellOffInfo^.n1 := -1;
          if Merchant.ClientSellOffItem(Self, SellOffInfo, sUserItemName) then begin
            if UserItem.btValue[13] = 1 then begin
              ItemUnit.DelCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
              UserItem.btValue[13] := 0;
            end;
            Dispose(UserItem); //物品加到NPC物品列表中了
            m_ItemList.Delete(I);
            WeightChanged();
          end;
        end;
        Break;
      end;
    end;
  end;
end;  }
{ //20080416 去掉拍卖功能
procedure TPlayObject.ClientUserBuySellOffItem(nIdent, nParam1, nInt, nZz: Integer; sMsg: string); //购买寄售物品
var
  Merchant: TMerchant;
begin
  try
    if m_boDealing then Exit;
    Merchant := UserEngine.FindMerchant(TObject(nParam1));
    if (Merchant = nil) or
      (not Merchant.m_boBuyOff) or
      (Merchant.m_PEnvir <> m_PEnvir) or
      (abs(Merchant.m_nCurrX - m_nCurrX) > 15) or
      (abs(Merchant.m_nCurrY - m_nCurrY) > 15) then Exit;
    if nIdent = CM_SENDBUYSELLOFFITEM then begin //购买寄售物品
      Merchant.ClientBuySellOffItem(Self, sMsg, nInt);
    end;
    if nIdent = CM_SENDQUERYSELLOFFITEM then begin //发送查询寄售物品列表
      Merchant.ClientGetDetailSellGoodsList(Self, sMsg, nZz);
    end;
  except
    on E: Exception do begin
      MainOutMessage('TPlayObject.ClientUserBuySellOffItem wIdent = ' + IntToStr(nIdent));
      //MainOutMessage(E.Message);
    end;
  end;
end;}
//客户端卖物品(出售物品)

procedure TPlayObject.ClientUserSellItem(nParam1, nMakeIndex: Integer; sMsg: string);
var
  I: Integer;
  UserItem: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
  StdItem: pTStdItem;
begin
  m_boCanQueryBag := True; //出售物品时,不能刷新包裹 20080917
  try
    for I := m_ItemList.Count - 1 downto 0 do begin
      if m_ItemList.Count <= 0 then Break; //20080917
      UserItem := m_ItemList.Items[I];
      if (UserItem <> nil) then begin
        if (UserItem.MakeIndex = nMakeIndex) then begin
          //取自定义物品名称
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sUserItemName = '' then
            sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
          if CompareText(sUserItemName, sMsg) = 0 then begin
            if CheckItemValue(UserItem, 4) or PlugOfCheckCanItem(1, sUserItemName, True, 0, 0) then begin //禁止物品规则(禁止交易) 20080913
              SendMsg(Self, RM_USERSELLITEM_FAIL, 0, 0, 0, 0, ''); //出售失败消息
              Break; //20080314 禁止出售
            end;

            Merchant := UserEngine.FindMerchant(TObject(nParam1));
            if (Merchant <> nil) then begin //20090203 修改
              if (Merchant.m_boSell) and
                ((Merchant.m_PEnvir = m_PEnvir) and
                (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
                (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then begin
                if Merchant.ClientSellItem(Self, UserItem) then begin
                  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                  if (StdItem <> nil) then begin
                    if (StdItem.StdMode = 51) and (UserItem.Dura > 0) and (UserItem.btValue[20] = 1) then begin
                      case StdItem.Shape of
                        0: begin //是聚灵珠 20080501
                            m_DealCreat.n_UsesItemTick := 0; //时间初始
                            UserItem.btValue[12] := 2; //不能聚集的标识
                          end;
                        1: begin
                            UserItem.btValue[12] := 2; //不能聚集的标识
                          end;
                      end;
                    end;
                  end;
                  if UserItem.btValue[13] = 1 then begin
                    ItemUnit.DelCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
                    UserItem.btValue[13] := 0;
                  end;
                  //Dispose(UserItem); //物品加到NPC物品列表中了
                  m_ItemList.Delete(I);
                  WeightChanged();
                end;
              end;
            end;
            Break;
          end;
        end;
      end;
    end; // for
  finally
    m_boCanQueryBag := False; //出售物品时,不能刷新包裹 20080917
  end;
end;
//客户端购买物品

procedure TPlayObject.ClientUserBuyItem(nIdent, nParam1, nInt, nZz: Integer; sMsg: string);
var
  Merchant: TMerchant;
begin
  try
    if m_boDealing then Exit;
    Merchant := UserEngine.FindMerchant(TObject(nParam1));
    if (Merchant = nil) or (not Merchant.m_boBuy) or
      (Merchant.m_PEnvir <> m_PEnvir) or
      (abs(Merchant.m_nCurrX - m_nCurrX) > 14) or
      (abs(Merchant.m_nCurrY - m_nCurrY) > 14) then Exit;

    if nIdent = CM_USERBUYITEM then begin //卖入物品 1014
      Merchant.ClientBuyItem(Self, sMsg, nInt);
    end;
    if nIdent = CM_USERGETDETAILITEM then begin //1015
      Merchant.ClientGetDetailGoodsList(Self, sMsg, nZz);
    end;
  except
    on E: Exception do begin
      MainOutMessage(Format('{%s} TPlayObject.ClientUserBuyItem wIdent:%d.%p', [g_sExceptionVer, nIdent, ExceptAddr]));
    end;
  end;
end;

function TPlayObject.ClientDropGold(nGold: Integer): Boolean;
begin
  Result := False;
  if g_Config.boInSafeDisableDrop and InSafeZone then begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropInSafeZoneMsg);
    Exit;
  end;

  if g_Config.boControlDropItem and (nGold < g_Config.nCanDropGold) then begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropGoldMsg);
    Exit;
  end;

  if not m_boCanDrop then begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropItemMsg);
    Exit;
  end;
  if nGold >= m_nGold then Exit;
  Dec(m_nGold, nGold);
  if not DropGoldDown(nGold, False, nil, Self) then Inc(m_nGold, nGold);
  GoldChanged();
  Result := True;
end;
//玩家扔物品

function TPlayObject.ClientDropItem(sItemName: string; nItemIdx: Integer): Boolean;
var
  I, wIndex, MakeIndex: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  sUserItemName: string;
  nCode: Byte; //20080908
begin
  Result := False;
  nCode := 0;
  m_boCanQueryBag := True; //扔物品时,不能刷新包裹 20080917
  try
    try
      {if not m_boClientFlag then begin//20110303注释
        if m_nStep = 8 then Inc(m_nStep)
        else m_nStep := 0;
      end;}
      nCode := 1;
      if g_Config.boInSafeDisableDrop and InSafeZone then begin
        SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropInSafeZoneMsg);
        Exit;
      end;
      nCode := 2;
      if not m_boCanDrop then begin
        SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropItemMsg);
        Exit;
      end;
      if m_boShop then begin //开启个人商店时不能扔物品 20100704
        SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropItemMsg);
        Exit;
      end;
      if Pos(' ', sItemName) > 0 then begin //折分物品名称(信件物品的名称后面加了使用次数)
        GetValidStr3(sItemName, sItemName, [' ']);
      end;
      nCode := 3;
      if (GetTickCount - m_DealLastTick) > 3000 then begin
        for I := m_ItemList.Count - 1 downto 0 do begin
          if m_ItemList.Count <= 0 then Break;
          UserItem := m_ItemList.Items[I];
          if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then begin
            if (UserItem.AddValue[0] = 1) and (GetHoursCount(UserItem.MaxDate, Now) <= 0) then begin //删除到期装备
              m_ItemList.Delete(I);
              Dispose(UserItem);
              Result := True;
              Break;
            end;
            if (UserItem.AddValue[0] in [2, 3]) then Break; //绑定物品不能扔 20110528
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if StdItem = nil then Continue;
            //sItem:=UserEngine.GetStdItemName(UserItem.wIndex);
            //取自定义物品名称
            sUserItemName := '';
            if UserItem.btValue[13] = 1 then
              sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
            if sUserItemName = '' then
              sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

            if CompareText(sUserItemName, sItemName) = 0 then begin
              nCode := 4;
              if CheckItemValue(UserItem, 0) then Break; //检查物品是否禁止扔 20080314
              nCode := 5;
              if PlugOfCheckCanItem(0, StdItem.Name, False, 0, 0) then Break; //禁止物品规则(管理插件功能) 20080729
              nCode := 6;
              if g_Config.boStartMapEvent then begin
                if m_btRaceServer = RC_PLAYOBJECT then StartMapEventOfDropItem(sUserItemName); //地图触发,扔物品事件
              end;
              if (StdItem.StdMode = 51) and (UserItem.Dura > 0) and (UserItem.btValue[20] = 1) then begin
                case StdItem.Shape of
                  0: begin //是聚灵珠 20080501
                      n_UsesItemTick := 0; //时间初始
                      UserItem.btValue[12] := 2; //不能聚集的标识
                    end;
                  1, 2: UserItem.btValue[12] := 2; //内功珠不能聚集的标识
                end;
              end;
              nCode := 7;
              wIndex := UserItem.wIndex; //20080901
              MakeIndex := UserItem.MakeIndex; //20080901
              nCode := 8;
              if g_Config.boControlDropItem and (StdItem.Price < g_Config.nCanDropPrice) then begin
                nCode := 9;
                Dispose(UserItem);
                m_ItemList.Delete(I);
                nCode := 10;
                ClearCopyItem(0, wIndex, MakeIndex); //20080901 清理复制品
                Result := True;
                Break;
              end;
              nCode := 11;
              if DropItemDown(UserItem, 3, False, False, nil, Self) then begin
                nCode := 12;
                if UserItem <> nil then Dispose(UserItem); //20080915 修改
                nCode := 15;
                m_ItemList.Delete(I);
                nCode := 13;
                ClearCopyItem(0, wIndex, MakeIndex); //20080901 清理复制品
                Result := True;
                Break;
              end;
            end;
          end;
        end;
        nCode := 14;
        if Result then WeightChanged();
      end; //if (GetTickCount - m_DealLastTick) > 3000 then begin
    except   
      MainOutMessage(Format('{%s} TPlayObject.ClientDropItem Code:%d.%p', [g_sExceptionVer, nCode, ExceptAddr]));
    end;
  finally
    m_boCanQueryBag := False; //扔物品时,不能刷新包裹 20080917
  end;
end;

procedure TPlayObject.GoldChange(sChrName: string; nGold: Integer);
var
  s10, s14: string;
begin
  if nGold > 0 then begin
    s10 := '14';
    s14 := '增加完成';
  end else begin
    s10 := '13';
    s14 := '以删减';
  end;
  SysMsg(sChrName + ' 的金币 ' + IntToStr(nGold) + ' 金币' + s14, c_Green, t_Hint);
  if g_boGameLogGold then
    AddGameDataLog(s10 + #9 +
      m_sMapName + #9 +
      IntToStr(m_nCurrX) + #9 +
      IntToStr(m_nCurrY) + #9 +
      m_sCharName + #9 +
      sSTRING_GOLDNAME + #9 +
      IntToStr(nGold) + #9 +
      '1' + #9 +
      sChrName);
end;

procedure TPlayObject.ClearStatusTime;
begin
  FillChar(m_wStatusTimeArr, SizeOf(TStatusTime), #0);
end;
//发送地图音乐背景数据

procedure TPlayObject.SendMapDescription;
var
  nMUSICID: Integer;
  sMUSINAME: string;
begin
  nMUSICID := -1;
{$IF HEROVERSION = 1}
  if m_PEnvir.m_boMUSIC then begin
    nMUSICID := m_PEnvir.m_nMUSICID;
    sMUSINAME := m_PEnvir.m_sMUSICName;
  end;
  if nMUSICID >= 0 then begin
    SendDefMessage(SM_MAPDESCRIPTION, nMUSICID, 0, 0, 0, m_PEnvir.sMapDesc);
  end else begin
    SendDefMessage(SM_MAPDESCRIPTION, -1, 0, 0, 0, m_PEnvir.sMapDesc + #13 + sMUSINAME);
  end;
{$ELSE}
  if m_PEnvir.m_boMUSIC then nMUSICID := m_PEnvir.m_nMUSICID;
  SendDefMessage(SM_MAPDESCRIPTION, nMUSICID, 0, 0, 0, m_PEnvir.sMapDesc);
{$IFEND}
end;
//发送游戏公告

procedure TPlayObject.SendNotice;
var
  LoadList: TStringList;
  I: Integer;
  sNoticeMsg: string;
begin
  LoadList := TStringList.Create;
  try
    try
      LoadList.AddStrings(NoticeList);
    except
      MainOutMessage('读取文本内容错误,文件名为: Notice.txt');
    end;
    sNoticeMsg := '';
    if LoadList.Count > 0 then begin //20080629
      for I := 0 to LoadList.Count - 1 do begin
        sNoticeMsg := sNoticeMsg + LoadList.Strings[I] + #$20#$1B;
      end;
    end;
  finally
    LoadList.Free;
  end;
  m_nSendMsgCount := m_nRandomKey;
  //SendDefMessage1(SM_SENDNOTICE, 2000, 10001, 10002, 10003, 10004, sNoticeMsg);
  //SendDefMessage1(SM_SENDNOTICE, 2000, Random(255) + 10000, Random(255) + 10000, Random(255) + 10000, m_nRandomKey, sNoticeMsg); //20090922 修改，加入动态密钥
  {$I VM_Start.inc}//虚拟机标识
  m_DefMsg := MakeDefaultMsg(SM_SENDNOTICE, $250, Random(255) + m_nRandomKey - Random(455), Random(255) + m_nRandomKey - Random(355), Random(255) + m_nRandomKey - Random(355), m_nRandomKey);
  with m_DefMsg do
    nSessionID := nSessionID xor ((Param shl (Tag mod 8 + 1)) and (Series shl (Tag mod 6 + 1)));
  {$I VM_End.inc}//虚拟机标识
  SendSocket(@m_DefMsg, EncodeString(sNoticeMsg))
end;

//人物登录游戏

procedure TPlayObject.UserLogon;
var
  I, II, n18, nDate: Integer;
  UserItem: pTUserItem;
  UserItem1: pTUserItem;
  StdItem: pTStdItem;
  s14: string;
  sItem: string;
  sIPaddr: string;
  nCode: Integer;
  n_mLevelOrder: Word;
  TempList: TStringList;
  mon: TBaseObject;
resourcestring
  sExceptionMsg = '{%s} TPlayObject::UserLogon Name:%s Code:%d.%p';
  sCheckIPaddrFail = '登录IP地址不匹配！';
begin
  sIPaddr := '';
  nCode := 0;
  try
    if g_Config.boTestServer then begin
      nCode := 1;
      if m_Abil.Level < g_Config.nTestLevel then m_Abil.Level := g_Config.nTestLevel;
      if m_nGold < g_Config.nTestGold then m_nGold := g_Config.nTestGold;
    end;
    nCode := 2;
    if g_Config.boTestServer or (g_Config.boServiceMode) then m_nPayMent := 3;
    m_dwMapMoveTick := GetTickCount();
    m_dLogonTime := Now();
    m_dwLogonTick := GetTickCount();
    nCode := 3;
    if (not m_boAI) and (not m_boNotOnlineAddExp) then begin
      Initialize(); //初始化 20110401挂机人物不初始化,防止与上次HP不一致BUG
      mon := UserEngine.GetPetsMonObject(m_sCharName); //是否有放养宠物 20110612
      if mon <> nil then begin
        mon.m_Master := Self;
        mon.m_dwMasterRoyaltyTick := 86400000; //叛变时间
        Mon.m_dwMasterRoyaltyTime := GetTickCount;
        m_SlaveList.Add(mon);
        m_nPetsMonHappiness := TPetsMon(mon).m_nHappiness;
        m_sPetsMonName := mon.m_sCharName;
      end;
    end;
    if (not m_boAI) and (m_ClearGamePointDate < Int(Date)) and g_Config.boClearGamePoint then begin //初始游戏点的日期
      m_ClearGamePointDate := LDOM(Date);
      m_nGamePoint := 0;
    end;
    nCode := 4;
    SendMsg(Self, RM_LOGON, 0, 0, 0, 0, '');
    try//防止异常不发送人物属性数据By TasNat at:2012-12-15 12:48:21
    nCode := 5;
    if m_Abil.Level <= 7 then begin
      if GetRangeHumanCount >= 80 then begin
        MapRandomMove(m_PEnvir.sMapName, 0);
      end;
    end;
    if m_boDieInFight3Zone then MapRandomMove(m_PEnvir.sMapName, 0);
    nCode := 6;
    if UserEngine.GetHumPermission(m_sCharName, sIPaddr, m_btPermission) then begin //取人物权限值
{$IF VEROWNER = WL}
      if not CompareIPaddr(m_sIPaddr, sIPaddr) then begin
        SysMsg(sCheckIPaddrFail, c_Red, t_Hint);
        m_boEmergencyClose := True;
        m_boPlayOffLine := False;
      end;
{$IFEND}
    end;
    nCode := 7;
    GetStartPoint();
    nCode := 8;
    if m_MagicList.Count > 0 then begin
      for I := 0 to m_MagicList.Count - 1 do begin //判断心灵启示等级,是否可以启用
        if m_MagicList.Count <= 0 then Break;
        if pTUserMagic(m_MagicList.Items[I]) <> nil then begin
          if sub_4C713C(pTUserMagic(m_MagicList.Items[I])) then Break;
        end;
      end;
    end;
    nCode := 9;
    //给新人增加新人物品
    if m_boNewHuman then begin
      if g_Config.sCandle <> '' then begin
        New(UserItem);
        if UserEngine.CopyToUserItemFromName(g_Config.sCandle, UserItem) then begin
          m_ItemList.Add(UserItem);
        end else Dispose(UserItem);
      end;
      if g_Config.sBasicDrug <> '' then begin //20110313 修改
        TempList := TStringList.Create;
        try
          ExtractStrings(['|', '\', '/', ','], [], PChar(g_Config.sBasicDrug), TempList);
          if TempList.Count > 0 then begin
            for I := 0 to TempList.Count - 1 do begin
              New(UserItem);
              if UserEngine.CopyToUserItemFromName(TempList.Strings[I], UserItem) then begin
                m_ItemList.Add(UserItem);
              end else Dispose(UserItem);
            end;
          end;
        finally
          TempList.Free;
        end;
      end;
      if g_Config.sWoodenSword <> '' then begin
        New(UserItem);
        if UserEngine.CopyToUserItemFromName(g_Config.sWoodenSword, UserItem) then begin
          m_ItemList.Add(UserItem);
        end else Dispose(UserItem);
      end;
      New(UserItem);
      if m_btGender = 0 then
        sItem := g_Config.sClothsMan
      else sItem := g_Config.sClothsWoman;

      if UserEngine.CopyToUserItemFromName(sItem, UserItem) then begin
        m_ItemList.Add(UserItem);
      end else Dispose(UserItem);
    end;
    nCode := 10;
    if not m_boAI then begin
      //检查背包中的物品是否合法
      for I := m_ItemList.Count - 1 downto 0 do begin
        nCode := 101;
        if m_ItemList.Count <= 0 then Break;
        nCode := 102;
        UserItem := m_ItemList.Items[I];
        nCode := 103;
        if UserItem <> nil then begin
          nCode := 1031;
          if (UserItem.AddValue[0] = 1) and (GetHoursCount(UserItem.MaxDate, Now) <= 0) then begin //删除到期装备
            nCode := 1032;
            m_ItemList.Delete(I);
            nCode := 1033;
            Dispose(UserItem);
            nCode := 1034;
            Continue;
          end;
          nCode := 104;
          if (UserItem.AddValue[0] = 2) and (GetHoursCount(UserItem.MaxDate, Now) <= 0) then begin //绑定到期，物品为正常状态
            UserItem.AddValue[0] := 0;
          end;
          nCode := 105;
          if CheckIsOKItem(UserItem) then begin //检查变态物品
            nCode := 1051;
            MainOutMessage('[登录清包裹非法物品](' + m_sCharName + ')' + UserEngine.GetStdItemName(UserItem.wIndex) + '(' + IntToStr(UserItem.MakeIndex) + ')' +
              IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
              IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
              IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
              IntToStr(UserItem.btValue[14])); //20081219 记录清除非法物品信息
            nCode := 1052;
            Dispose(pTUserItem(m_ItemList.Items[I]));
            nCode := 1053;
            m_ItemList.Delete(I);
            nCode := 1054;
            Continue;
          end;
          //检查背包中是否有复制品
          nCode := 106;
          s14 := UserEngine.GetStdItemName(UserItem.wIndex);
          for II := I - 1 downto 0 do begin
            UserItem1 := m_ItemList.Items[II];
            if (UserEngine.GetStdItemName(UserItem1.wIndex) = s14) and
              (UserItem.MakeIndex = UserItem1.MakeIndex) then begin
              MainOutMessage(Format('[登录清包裹复制品](%s)%s(%d)', [m_sCharName, s14, UserItem1.MakeIndex])); //20081219 记录清除复制品信息
              m_ItemList.Delete(II);
              Dispose(UserItem1); //20100913 增加
              Break;
            end;
          end;
          nCode := 107;
        end;
      end;
    end;
    nCode := 11;
    //检查人物身上的物品是否符合使用规则
    if g_Config.boCheckUserItemPlace then begin
      for I := Low(THumanUseItems) to High(THumanUseItems) do begin //9格装备+4格装备
        if m_UseItems[I].wIndex > 0 then begin
          if (m_UseItems[I].AddValue[0] = 1) and (GetHoursCount(m_UseItems[I].MaxDate, Now) <= 0) then begin //删除到期装备
            m_UseItems[I].wIndex := 0;
            Continue;
          end;
          StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
          if StdItem <> nil then begin
            if (StdItem.StdMode = 7) and (StdItem.Shape = 5) then Continue; //天龙印类物品不检测 20110507
            if CheckIsOKItem(@m_UseItems[I]) then begin //检查变态物品 20081006
              m_UseItems[I].wIndex := 0;
              Continue;
            end;
{$IF M2Version <> 2} //临时处理，过两版后去掉 20100901
            if (m_UseItems[I].btAppraisalLevel = 0) and (g_Config.boUseCanKamPo) then begin
              if StdItem.StdMode in [5, 6, 10, 11, 15, 16, 19..24, 26..30, 52, 54, 55, 62, 64] then m_UseItems[I].btAppraisalLevel := 1;
            end;
{$IFEND}
{$IF M2var = 1}
            if m_UseItems[I].AddValue[2] <> 255 then begin //临时处理14-19属性值，过N版后去掉 20110528
              m_UseItems[I].AddValue[2] := m_UseItems[I].btValue[14];
              m_UseItems[I].btValue[14] := 0;
              SetItemState(@m_UseItems[I], 0, m_UseItems[I].AddValue[2]);
              SetItemState(@m_UseItems[I], 1, m_UseItems[I].btValue[15]);
              SetItemState(@m_UseItems[I], 2, m_UseItems[I].btValue[16]);
              SetItemState(@m_UseItems[I], 3, m_UseItems[I].btValue[17]);
              SetItemState(@m_UseItems[I], 4, m_UseItems[I].btValue[18]);
              SetItemState(@m_UseItems[I], 5, m_UseItems[I].btValue[19]);
              m_UseItems[I].btValue[15] := 0;
              m_UseItems[I].btValue[16] := 0;
              m_UseItems[I].btValue[17] := 0;
              m_UseItems[I].btValue[18] := 0;
              m_UseItems[I].btValue[19] := 0;
              m_UseItems[I].AddValue[2] := 255;
            end;
{$IFEND}
            if not CheckUserItems(I, StdItem) then begin
              New(UserItem);
              FillChar(UserItem^, SizeOf(TUserItem), #0); //20080820 增加
              UserItem^ := m_UseItems[I];
              if not AddItemToBag(UserItem) then begin
                m_ItemList.Insert(0, UserItem);
              end;
              m_UseItems[I].wIndex := 0;
            end;

            if g_Config.boItmeAutoOver and (m_UseItems[I].wIndex > 0) and
              (m_UseItems[I].Dura <= 0) then begin //持久0物品不消失 20110410
              if StdItem.NeedIdentify = 1 then //物品消失记录日志
                AddGameDataLog('6' + #9 + m_sMapName + #9 +
                  IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                  m_sCharName + #9 + StdItem.Name + #9 +
                  IntToStr(m_UseItems[I].MakeIndex) + #9 +
                  '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                  '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                  '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                  '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                  '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                  IntToStr(m_UseItems[I].btValue[0]) + '/' + IntToStr(m_UseItems[I].btValue[1]) + '/' + IntToStr(m_UseItems[I].btValue[2]) + '/' +
                  IntToStr(m_UseItems[I].btValue[3]) + '/' + IntToStr(m_UseItems[I].btValue[4]) + '/' + IntToStr(m_UseItems[I].btValue[5]) + '/' +
                  IntToStr(m_UseItems[I].btValue[6]) + '/' + IntToStr(m_UseItems[I].btValue[7]) + '/' + IntToStr(m_UseItems[I].btValue[8]) + '/' +
                  IntToStr(m_UseItems[I].btValue[14]) + #9 + '持久耗尽');
              m_UseItems[I].wIndex := 0;
            end;
          end else m_UseItems[I].wIndex := 0;
        end;
      end;
    end;
    nCode := 12;
    {//检查背包中是否有复制品
    for I := m_ItemList.Count - 1 downto 0 do begin
      if m_ItemList.Count <= 0 then Break;
      UserItem := m_ItemList.Items[I];
      if UserItem <> nil then begin//20090213
        s14 := UserEngine.GetStdItemName(UserItem.wIndex);
        for II := I - 1 downto 0 do begin
          UserItem1 := m_ItemList.Items[II];
          if (UserEngine.GetStdItemName(UserItem1.wIndex) = s14) and
            (UserItem.MakeIndex = UserItem1.MakeIndex) then begin
            MainOutMessage(Format('[登录清包裹复制品](%s)%s(%d)',[m_sCharName, s14, UserItem1.MakeIndex]));//20081219 记录清除复制品信息
            m_ItemList.Delete(II);
            Dispose(UserItem1);//20100913 增加
            Break;
          end;
        end;
      end;
    end;    }
    nCode := 13;
    if not m_boAI then begin
      for I := Low(m_dwStatusArrTick) to High(m_dwStatusArrTick) do begin
        if m_wStatusTimeArr[I] > 0 then m_dwStatusArrTick[I] := GetTickCount();
      end;
      if m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP] > 0 then m_boAbilMagBubbleDefence := True; //使用魔法盾, 20090815
    end;
    if m_Abil.Level > g_Config.nLimitExpLevel then m_Abil.Level := g_Config.nLimitExpLevel; //20110113
    nCode := 14;
    m_nCharStatus := GetCharStatus();
{$IF M2Version <> 2}
    SendHumTitles(1); //发送称号数据
{$IFEND}
    RecalcLevelAbilitys(); //重新计算角色的等级各属性
    RecalcAbilitys(); //刷新能力
  
    CompareSuitItem(True); //套装与身上装备对比 20080712
    if btB2 = 0 then begin
      m_nPkPoint := 0;
      Inc(btB2);
    end;
    nCode := 16;
    if (m_nGold > g_Config.nHumanMaxGold * 2) and (g_Config.nHumanMaxGold > 0) then m_nGold := g_Config.nHumanMaxGold * 2;
    if not bo6AB then begin
      if (m_nSoftVersionDate < g_Config.nSoftVersionDate) then begin //对比客户端版本号 20080302
        nCode := 17;
        SysMsg(sClientSoftVersionError, c_Red, t_Hint);
        SysMsg(sDownLoadNewClientSoft, c_Red, t_Hint);
        SysMsg(sForceDisConnect, c_Red, t_Hint);
        m_boEmergencyClose := True;
        m_boPlayOffLine := False;
        Exit;
      end;
      if (m_nSoftVersionDateEx = 0) then begin
        if (not g_Config.boCanOldClientLogon) then begin //如果不允许普通客户端登录,则退出
          nCode := 18;
          SysMsg(sClientSoftVersionError, c_Red, t_Hint);
          SysMsg(sDownLoadNewClientSoft, c_Red, t_Hint);
          SysMsg(sForceDisConnect, c_Red, t_Hint);
          m_boEmergencyClose := True;
          m_boPlayOffLine := False;
          Exit;
        end;
        if g_Config.boOldClientShowHiLevel then begin
          nCode := 19;
          SysMsg(sClientSoftVersionTooOld, c_Blue, t_Hint);
          SysMsg(sDownLoadAndUseNewClient, c_Red, t_Hint);
        end;
      end;
      nCode := 20;
      case m_btAttatckMode of
        HAM_ALL: begin //20080331 加入聊天框中提示
            SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfAll); //[攻击模式: 全体攻击]
            SysMsg(sAttackModeOfAll, c_Green, t_Hint); //[攻击模式: 全体攻击]
          end;
        HAM_PEACE: begin
            SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfPeaceful); //[攻击模式: 和平攻击]
            SysMsg(sAttackModeOfPeaceful, c_Green, t_Hint); //[攻击模式: 和平攻击]
          end;
        HAM_DEAR: begin
            SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfDear); //[攻击模式: 夫妻攻击]
            SysMsg(sAttackModeOfDear, c_Green, t_Hint); //[攻击模式: 夫妻攻击]
          end;
        HAM_MASTER: begin
            SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfMaster); //[攻击模式: 师徒攻击]
            SysMsg(sAttackModeOfMaster, c_Green, t_Hint); //[攻击模式: 师徒攻击]
          end;
        HAM_GROUP: begin
            SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfGroup); //[攻击模式: 编组攻击]
            SysMsg(sAttackModeOfGroup, c_Green, t_Hint); //[攻击模式: 编组攻击]
          end;
        HAM_GUILD: begin
            SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfGuild); //[攻击模式: 行会攻击]
            SysMsg(sAttackModeOfGuild, c_Green, t_Hint); //[攻击模式: 行会攻击]
          end;
        HAM_PKATTACK: begin
            SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfRedWhite); //[攻击模式: 红名攻击]
            SysMsg(sAttackModeOfRedWhite, c_Green, t_Hint); //[攻击模式: 红名攻击]
          end;
{$IF M2Version <> 2}
        HAM_DIVISION: begin
            SendMsg(Self, RM_CHANGEATTATCKMODE, 0, 0, 0, 0, sAttackModeOfDivision); //[攻击模式: 师门攻击]
            SysMsg(sAttackModeOfDivision, c_Green, t_Hint); //[攻击模式: 师门攻击]
          end;
{$IFEND}
      end;
      SysMsg(sStartChangeAttackModeHelp, c_Green, t_Hint); //使用组合快捷键 CTRL-H 更改攻击...
      nCode := 21;
      if m_dwKillMonExpRateTime > 0 then begin //双倍经验时间内,进入游戏提示 20080615
        SysMsg(Format_ToStr({g_sChangeKillMonExpRateMsg}'您目前剩余%g倍经验时间%u秒', [m_nKillMonExpRate / 100, m_dwKillMonExpRateTime]), {c_Green} c_Blue, t_Hint); //20101022 修改
      end;
      if m_dwHighLevelKillMonFixExpTime > 0 then begin //高等级杀怪经验不变的使用时间(秒) 进入游戏提示 20090213
        SysMsg(Format_ToStr(g_sHighLevelKillMonFixExpMsg, [m_dwHighLevelKillMonFixExpTime]), c_Green, t_Hint);
      end;
      nCode := 22;
      if g_Config.boTestServer then begin
        if g_ManageNPC <> nil then begin //20110113 修改sStartNoticeMsg支持人物变量
          s14 := g_ManageNPC.GetLineVariableText(self, sStartNoticeMsg); //通过QM，使用公告支持变量
          SysMsg(s14, c_Green, t_Hint); //欢迎进入本服务器进行游戏...
        end else SysMsg(sStartNoticeMsg, c_Green, t_Hint); //欢迎进入本服务器进行游戏...
      end;
      if UserEngine.PlayObjectCount > g_Config.nTestUserLimit then begin
        if m_btPermission < 2 then begin
          nCode := 23;
          SysMsg(sOnlineUserFull, c_Red, t_Hint);
          SysMsg(sForceDisConnect, c_Red, t_Hint);
          m_boEmergencyClose := True;
          m_boPlayOffLine := False;
        end;
      end;
    end;
    nCode := 24;
    m_nBright := g_nGameTime;
    m_Abil.nMaxExp := GetLevelExp(m_Abil.Level); //jacky 2004/09/15 登录重新取得升级所需经验值
    except//防止异常导致不发送以下信息By TasNat at:2012-12-15 12:47:17
    end;
    nCode := 25;
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
    SendMsg(Self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    SendMsg(Self, RM_DAYCHANGING, 0, 0, 0, 0, ''); //发送白天或晚上的状态
    SendMsg(Self, RM_SENDUSEITEMS, 0, 0, 0, 0, ''); //发送装备物品
    SendMsg(Self, RM_SENDMYMAGIC, 0, 0, 0, 0, ''); //发送使用的魔法
{$IF M2Version <> 2}
    SendMsg(Self, RM_SENDHUMTITLES, 0, 0, 0, 0, ''); //发送称号数据
    SendMsg(Self, RM_SENDUSESPIRITITEMS, 0, 0, 0, 0, ''); //发送灵媒装备物品 20100827
{$IFEND}
{$IF HEROVERSION = 1}
    nCode := 26;
    if m_MyHero <> nil then begin //发送英雄信息 人物是离线挂机状态
      case THeroObject(m_MyHero).n_HeroTpye of //20091102
        0: SendDelayMsg(Self, RM_RECALLHERO, 0, Integer(m_MyHero), 0, 0, '白', 1000);
        1: SendDelayMsg(Self, RM_RECALLHERO, 0, Integer(m_MyHero), 0, 0, '卧', 1000);
        2: SendDelayMsg(Self, RM_RECALLHERO, 0, Integer(m_MyHero), 0, 0, '主', 1000);
        3: SendDelayMsg(Self, RM_RECALLHERO, 0, Integer(m_MyHero), 0, 0, '副', 1000);
      end;
      nCode := 100;
      case THeroObject(m_MyHero).m_btStatus of
        1: THeroObject(m_MyHero).SysMsg(g_sHeroFollow, c_Green, t_Hint); //20080316
        0: THeroObject(m_MyHero).SysMsg(g_sHeroAttack, c_Green, t_Hint); //20080316
        2: THeroObject(m_MyHero).SysMsg(g_sHeroRest, c_Green, t_Hint); //20080316
      end;
      nCode := 101;
      THeroObject(m_MyHero).SysMsg(g_sHeroLoginMsg, c_Green, t_Hint);
      nCode := 102;
      if THeroObject(m_MyHero).WearFirDragon then begin //没有火龙之心则不发送
        if THeroObject(m_MyHero).m_nFirDragonPoint > g_Config.nMaxFirDragonPoint then THeroObject(m_MyHero).m_nFirDragonPoint := g_Config.nMaxFirDragonPoint; //20080528 防止怒气调整后超过
        nCode := 103;
        THeroObject(m_MyHero).SendMsg(m_MyHero, RM_FIRDRAGONPOINT, g_Config.nMaxFirDragonPoint, THeroObject(m_MyHero).m_nFirDragonPoint, 0, 0, ''); //发送英雄怒气值
      end;
    end;
{$IFEND}
    nCode := 27;
    //  FeatureChanged(); //增加，广播人物骑马信息
    m_MyGuild := g_GuildManager.MemberOfGuild(m_sCharName);
    if m_MyGuild <> nil then begin
      m_sGuildRankName := TGUild(m_MyGuild).GetRankName(Self, m_nGuildRankNo);
      if TGUild(m_MyGuild).GuildWarList.Count > 0 then begin //20080629
        for I := 0 to TGUild(m_MyGuild).GuildWarList.Count - 1 do begin
          SysMsg(TGUild(m_MyGuild).GuildWarList.Strings[I] + ' 行会正在和你的行会进行行会战争！', c_Green, t_Hint);
        end;
      end;
    end;
    nCode := 28;
    RefShowName();
    if (m_nPayMent = 1) then begin
      if not bo6AB then SysMsg(sYouNowIsTryPlayMode, c_Red, t_Hint);
      nCode := 29;
      m_nGoldMax := g_Config.nHumanTryModeMaxGold;
      if m_Abil.Level > g_Config.nTryModeLevel then begin
        SysMsg('测试状态可以使用到第 ' + IntToStr(g_Config.nTryModeLevel) + ' 级。', c_Red, t_Hint);
        //SysMsg('链接中断，请到以下地址获得相关信息。(http://www.3KM2.com)', c_Red, t_Hint);
        m_boEmergencyClose := True;
        m_boPlayOffLine := False;
      end;
    end;
    nCode := 30;
    if (m_nPayMent = 3) and (not bo6AB) then SysMsg(g_sNowIsFreePlayMode {'当前服务器运行于测试模式.'}, c_Green, t_Hint);
    if g_Config.boVentureServer then SysMsg('当前服务器运行于 不刷怪模式.', c_Green, t_Hint);
    if (not m_boUseThrusting) then begin
      if (m_Magic89Skill <> nil) then begin
        m_boUseThrusting := True;
        if not m_boAI then SendSocket(nil, '+LNG4');
      end else
        if (m_MagicErgumSkill <> nil) then begin
          m_boUseThrusting := True;
          if not m_boAI then SendSocket(nil, '+LNG');
        end;
    end;
    nCode := 31;
    if m_PEnvir.m_boNORECONNECT then MapRandomMove(m_PEnvir.sNoReconnectMap, 0);
    nCode := 32;
    if CheckDenyLogon() then begin //如果人物在禁止登录列表里则直接掉线而不执行下面内容
      m_boEmergencyClose := True; //2006-11-18 修正禁止人物登陆不下线的问题
      m_boPlayOffLine := False;
      Exit;
    end;
    {==============================人物超过限制踢下线===========================}
{$IF UserMode1 <> 0}
    nCode := 33;
    if (UserEngine.PlayObjectCount > UserEngine.m_nLimitUserCount) or
      (UserEngine.m_nLimitNumber <> UserEngine.m_nLimitUserCount) then begin
      m_boPlayOffLine := False;
      m_boEmergencyClose := True;
      Exit;
    end;
{$IF UserMode1 = 2}
{$I Encode_Start.inc} //代码加密标识
    nCode := 44;
    case WLRegGetStatus(n18) of
      wlIsRegistered: ;
    else begin
        nCode := 45;
        if (UserEngine.m_nLimitNumber <> pMaxPlayCount^) or (UserEngine.m_nLimitUserCount <> pMaxPlayCount^)
          or (UserEngine.m_nLimitNumber <> UserEngine.m_nLimitUserCount) or (pMaxPlayCount^ <> 10) then begin
          m_boPlayOffLine := False;
          m_boEmergencyClose := True;
          Exit;
        end;
      end;
    end; //case
{$I Encode_End.inc}
{$IFEND}
{$IFEND}
    {==============================================================================}
    nCode := 34;
    if g_ManageNPC <> nil then g_ManageNPC.GotoLable(Self, '@Login', False, False);
{$IF M2Version <> 2}
    if m_boTrainingNG then begin //学过内功
      m_MaxExpSkill69 := GetSkill69Exp(m_NGLevel, m_Skill69MaxNH); //登录重新取内功心法升级经验 20081002
      SendMsg(Self, RM_MAGIC69SKILLNH, 0, m_Skill69NH, m_Skill69MaxNH, 0, ''); //内力值让别人看到 20081002
      SendMsg(Self, RM_MAGIC69SKILLEXP, 0, 0, 0, m_NGLevel, EncodeString(Inttostr(m_ExpSkill69) + '/' + Inttostr(m_MaxExpSkill69)));
{$IF M2Version = 1}
      SendUserPulseArr; //登陆时发送脉穴数据
      if m_boUser4BatterSkill then SendMsg(self, RM_OPEN4BATTERSKILL, 0, 0, 0, 0, ''); //开启第四连击技能 20100720
      nDate := Strtoint(FormatDatetime('YYYYMMDD', Date)); //当前的日期
      if (m_InitialJingYuanDate <> nDate) then begin //初始精元值的日期
        m_InitialJingYuanDate := nDate;
        m_JingYuanValue := _MIN(g_Config.nJingYuanValue, m_NGLevel * 10);
      end;
{$IFEND}
      SendNGResume(1); //发送内功减免，伤害，恢复速度数据 20090812
    end;
    if m_MyDivision <> nil then begin //刷新师门数据
      TDivision(m_MyDivision).RefMemberName(m_sCharName);
    end;
    DoSendHeartInfo(); //发送心法相关数据
{$IFEND}
    nCode := 35;
    m_boFixedHideMode := False; //01/21 增加
    // PlayObject.Create 过程里被置为True，在执行完登录脚本后再置False
    if m_sDearName <> '' then CheckMarry(); //处理离婚
    CheckMaster(False);
    nCode := 36;
    m_boFilterSendMsg := GetDisableSendMsgList(m_sCharName); //是否禁止发言
    nCode := 37;
    //密码保护系统
    if g_Config.boPasswordLockSystem then begin
      if UserEngine.QueryNameInFreeList(m_sCharName) then begin //查询人物姓名是否在释放列表中，并检查是否解过锁 在则不再需要输入密码 20090211
        m_boUnLockPwd := False;
        m_boPasswordLocked := False;
      end else begin
        if m_boPasswordLocked then begin
          m_boCanGetBackItem := not g_Config.boLockGetBackItemAction;
        end;
        nCode := 38;
        if g_Config.boLockHumanLogin and m_boLockLogon and m_boPasswordLocked then begin
          m_boCanDeal := not g_Config.boLockDealAction;
          m_boCanDrop := not g_Config.boLockDropAction;
          m_boCanUseItem := not g_Config.boLockUserItemAction;
          m_boCanWalk := not g_Config.boLockWalkAction;
          m_boCanRun := not g_Config.boLockRunAction;
          m_boCanHit := not g_Config.boLockHitAction;
          m_boCanSpell := not g_Config.boLockSpellAction;
          m_boCallHero := not g_Config.boLockCallHeroAction; //是否锁定召唤英雄操作
          m_boCanSendMsg := not g_Config.boLockSendMsgAction;
          m_boObMode := g_Config.boLockInObModeAction;
          //m_boAdminMode := g_Config.boLockInObModeAction;
{$IF VEROWNER = WL}
          SysMsg(g_sActionIsLockedMsg + ' 开锁命令: @' + g_GameCommand.LOCKLOGON.sCmd, c_Red, t_Hint);
          SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sActionIsLockedMsg + '\ \'
            + '密码命令: @' + g_GameCommand.PASSWORDLOCK.sCmd);
        end;
        if not m_boPasswordLocked then begin
          SysMsg(Format_ToStr(g_sPasswordNotSetMsg, [g_GameCommand.PASSWORDLOCK.sCmd]), c_Red, t_Hint);
        end;
        if not m_boLockLogon and m_boPasswordLocked then begin
          SysMsg(Format_ToStr(g_sNotPasswordProtectMode, [g_GameCommand.LOCKLOGON.sCmd]), c_Red, t_Hint);
        end;
{$ELSE}
        nCode := 39;
        SysMsg(g_sActionIsLockedMsg + ' 开锁命令: @' + g_GameCommand.UnLock.sCmd, c_Red, t_Hint);
        SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sActionIsLockedMsg + '\ \'
          + '开锁命令: @' + g_GameCommand.UnLock.sCmd + '\'
          + '加锁命令: @' + g_GameCommand.Lock.sCmd + '\'
          + '设置密码命令: @' + g_GameCommand.SETPASSWORD.sCmd + '\'
          + '修改密码命令: @' + g_GameCommand.CHGPASSWORD.sCmd);
      end;
{$IFEND}
    end;
  end;
  nCode := 40;
  //重置泡点方面计时
  m_dwIncGamePointTick := GetTickCount();
  m_dwIncGameGoldTick := GetTickCount();
  m_dwAutoGetExpTick := GetTickCount();
  nCode := 31;
  if not m_boAI then GetSellOffGlod; //检查是否有元宝寄售交易结束还没得到元宝 20080318
  if m_boShop then SendMsg(Self, RM_SELFSHOPLIST, 0, 0, 0, 0, ''); //登陆发送个人商店列表数据 20100701
  nCode := 32;
  if (m_btMagBubbleDefenceLevel = 4) and (m_dwStatusArrTick[STATE_BUBBLEDEFENCEUP] > 0) then StatusChanged('444'); //20080811 4级盾,发个消息给客户端显示特有的效果;
  if (not m_boNotOnlineAddExp) and (not m_boAI) then begin //20101025 排名下降
    n_mLevelOrder := GetUserLevelOrder; //获取人物等级排名
    if (n_mLevelOrder > 0) and (n_mLevelOrder < 2001) and (n_LevelOrder <> n_mLevelOrder) and (n_LevelOrder <> 0) then begin
      if (n_mLevelOrder > n_LevelOrder) then begin //排名下降
        if sHumLevelOrderDropMsg <> '' then
          SysMsg(Format_ToStr(sHumLevelOrderDropMsg, [n_mLevelOrder, (n_mLevelOrder - n_LevelOrder)]), c_Blue, t_Hint); //人物排行下降进行提示
      end;
      n_LevelOrder := n_mLevelOrder;
    end;
    if n_LevelOrder = 0 then n_LevelOrder := n_mLevelOrder;
  end;
{$IF HEROVERSION = 1}
  if m_boHeroAutoPractice then SysMsg('您的副将英雄已自动开始继续修炼!', c_Blue, t_Hint);
{$IFEND}
{$IF M2Version <> 2}
  nCode := 41;
  if m_PEnvir.m_boCRIT and (sMapIncCritMsg <> '') then SysMsg(Format_ToStr(sMapIncCritMsg, [m_PEnvir.m_nCRIT]), c_Blue, t_Hint); //进入暴击等级地图提示
  if m_PEnvir.m_boPeak then begin
    if m_PEnvir.m_nPeakMaxRate > 100 then SysMsg(sMapPaekMsg1, c_Blue, t_Hint)
    else SysMsg(sMapPaekMsg, c_Blue, t_Hint);
  end;
  nCode := 43;
  //检查称号回收 20110406
  if m_boFengHaoHuhua then CheckFangHaoMarry(0);
  if m_boFengHaoComrade then CheckFangHaoMarry(1);
{$IFEND}
  except
    MainOutMessage(Format(sExceptionMsg, [g_sExceptionVer, m_sCharName, nCode, ExceptAddr]));
  end;
end;

procedure TPlayObject.SendGoldInfo(boSendName: Boolean);
var
  sMsg, sMsg1: string;
begin
  if boSendName then begin //是否发送名字
    sMsg := g_Config.sGameGoldName + #13 + g_Config.sGamePointName + #13 + g_Config.sGameDiaMond + #13 + g_Config.sGameGird{$IF M2Version <> 2} + #13 + g_Config.sNGStrongItem{$IFEND};
    if g_Config.sDiyMedicine <> '' then sMsg1 := g_Config.sDiyMedicine; //内挂自定义药品名
  end;
  if g_Config.boClearGamePoint then
    SendDefMessage1(SM_GAMEGOLDNAME, m_nGameGold {游戏币}, LoWord(m_ClearGamePointDate), HiWord(m_ClearGamePointDate), 0, m_nGamePoint {游戏点}, sMsg) //20090524 修改
  else SendDefMessage1(SM_GAMEGOLDNAME, m_nGameGold {游戏币}, 0, 0, 0, m_nGamePoint {游戏点}, sMsg);
  SendDefMessage1(SM_GAMEGOLDNAME1, m_nGameDiaMond {金刚石}, LoWord(m_btCreditPoint), HiWord(m_btCreditPoint {声望}), 0, m_nGameGird {灵符}, sMsg1); //20110918 修改
end;
//发送荣誉值 20080511

procedure TPlayObject.SendGloryInfo;
begin
  SendDefMessage(SM_GLORY, m_btGameGlory {荣誉值}, 0, 0, 0, '');
end;

//发送物品效果数据By TasNat at:2012-12-10 10:39:10
procedure TPlayObject.SendEffecItems;
var
  I : Integer;
  sAItemData : string;
  EffecItem: pTEffecItem;
begin
  m_DefMsg := MakeDefaultMsg(SM_AddEffecItemList, 0, 0, 0, 0, 0);
  for I := m_nItemEffProcessPosition to _MIN(m_nItemEffProcessPosition + 30,g_EffecItemtList.Count - 1) do begin
    EffecItem := pTEffecItem(g_EffecItemtList.Objects[I]);
    if EffecItem <> nil then begin
      sAItemData := EncodeBuffer(PChar(EffecItem), SizeOf(TEffecItem));
      SendSocket(@m_DefMsg, sAItemData);
    end;
  end;
  m_nItemEffProcessPosition := I;
  if m_nItemEffProcessPosition < g_EffecItemtList.Count-1 then
    SendDelayMsg(Self, RM_SendItemEffs, 0, 0, 0, 0, '', 1000);
    //SendMsg(Self, RM_SendItemEffs, 0, 0, 0, 0, '');
end;

//发送登录

procedure TPlayObject.SendLogon;
var
  MessageBodyWL: TMessageBodyWL;
  feature: TFeatures;
begin
  m_DefMsg := MakeDefaultMsg(SM_LOGON, Integer(Self), m_nCurrX, m_nCurrY, MakeWord(m_btDirection, m_nLight), m_btDeputyHeroJob);
  MessageBodyWL.lParam1 := 0;
  GetFeature(feature); //人物着装
  MessageBodyWL.feature {lParam1} := feature;
  //MessageBodyWL.lParam1 := GetFeatureToLong();//人物着装
  MessageBodyWL.lParam2 := m_nCharStatus; //人物状态
  m_boAllowGroup := False; //20080803 关闭组队状态
  {if m_boAllowGroup then MessageBodyWL.lTag1 := MakeLong(MakeWord(1, 0), GetFeatureEx)//20080615 注释  实现上线自动关组
  else }MessageBodyWL.lTag1 := 0;
  MessageBodyWL.lTag2 := 0;
  m_nItemEffProcessPosition := 0;
  SendDelayMsg(Self, RM_SendItemEffs, 0, 0, 0, 0, '', 1000);


  SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)));
  //nRecog := GetFeatureToLong();
  SendDefMessage(SM_FEATURECHANGED, Integer(Self), {LoWord(nRecog)} 0, {HiWord(nRecog)} 0, GetFeatureEx, EncodeBuffer(@feature, SizeOf(feature)));


end;

//发送服务器配置文件(客户端相关)

procedure TPlayObject.SendServerConfig;
var
  nRecog, nParam: Integer;
  nRunHuman, nRunMon, nRunNpc, nWarRunAll: Integer;
  ClientConf: TClientConf;
  sMsg: string;
begin
  if m_nSoftVersionDateEx = 0 then Exit;
  nRunHuman := 0;
  nRunMon := 0;
  nRunNpc := 0;
  nWarRunAll := 0;
  if g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)
    or (g_Config.boSafeAreaLimited and InSafeZone) then begin
    nRunHuman := 1;
    nRunMon := 1;
    nRunNpc := 1;
    nWarRunAll := 1;
  end else begin
    if g_Config.boRUNHUMAN or m_PEnvir.m_boRUNHUMAN then nRunHuman := 1;
    if g_Config.boRUNMON or m_PEnvir.m_boRUNMON then nRunMon := 1;
    if g_Config.boRunNpc then nRunNpc := 1;
    if g_Config.boWarDisHumRun then nWarRunAll := 1;
  end;
  ClientConf := g_ClientConf;
  ClientConf.boRUNHUMAN := nRunHuman = 1;
  ClientConf.boRUNMON := nRunMon = 1;
  ClientConf.boRunNpc := nRunNpc = 1;
  ClientConf.boWarRunAll := nWarRunAll = 1;
  ClientConf.wSpellTime := g_Config.dwMagicHitIntervalTime + 300;
  ClientConf.wHitIime := g_Config.dwHitIntervalTime + 500;
  ClientConf.boSkill31Effect := g_Config.boSkill31Effect; //魔法盾效果 T-特色效果 F-盛大效果 20080808
  ClientConf.boCanShop := g_Config.g_boCanShop; //开启商铺 20100630
  ClientConf.boShopUseGold := g_Config.g_boShopUseGold; //商铺使用金币交易 20100630
  ClientConf.boUsePlayShop := g_Config.boOpenSelfShop; //是否开放个人商店 20100706
  ClientConf.boNoUseProtection := g_Config.boNoCanUseProtection; //内挂禁用主体保护
  ClientConf.boNoUseHeroProtection := g_Config.boNoCanUseHeroProtection; //内挂禁用英雄保护
  ClientConf.boNoCanUseComparThrust := g_Config.boNoCanUseComparThrust; //内挂隔位刺杀是否可用
  ClientConf.boUseCanDivision := g_Config.boUseCanDivision; // 传递 开放师门系统 变量
  ClientConf.boShowMoveHP := g_Config.boShowMoveHP; // 传递 开放师门系统 变量
  {$IF M2Version = 2}
  ClientConf.boShowNewItem := g_Config.boShowNewItem; //1.76是否显示四格By TasNat at: 2012-10-20 10:13:42
  {$ifend}
  {$IF M2Version = 0}
  ClientConf.boUses176StateWin := g_Config.boUses176StateWin; //使用老的F10 界面By TasNat at: 2012-10-29 13:07:58
  {$ifend}
  ClientConf.dwMaxLevel := g_Config.nLimitExpLevel;
  sMsg := EncodeBuffer(@ClientConf, SizeOf(ClientConf));
  nRecog := MakeLong(MakeWord(nRunHuman, nRunMon), MakeWord(nRunNpc, nWarRunAll));
  nParam := MakeWord(ClientConf.btDieColor, {$IF M2Version <> 2}BoolToInt(g_Config.boUseFengHaoAbil){$ELSE}0{$IFEND});
  SendDefMessage(SM_SERVERCONFIG, nRecog, nParam, BoolToInt(g_Config.boUseCanHero), {$IF M2Version <> 2}BoolToInt(g_Config.boUseCanKamPo){$ELSE}0{$IFEND}, sMsg);
end;

//发送解包内容

procedure TPlayObject.SendUnBind;
var
  I: Integer;
  UnbindInfo: TUnbindInfo;
  sMsg: string;
  msg: TDefaultMessage;
begin
  sMsg := '';
  if g_UnbindList.Count > 0 then begin //20080629
    for I := 0 to g_UnbindList.Count - 1 do begin
      UnbindInfo.sItemName := g_UnbindList.Strings[I];
      UnbindInfo.nUnbindCode := Integer(g_UnbindList.Objects[I]);
      sMsg := sMsg + EncodeBuffer(@UnbindInfo, SizeOf(TUnbindInfo)) + '/';
    end;
  end;
  if sMsg <> '' then begin
    msg := MakeDefaultMsg(SM_SERVERUNBIND, 0, 0, 0, 0, 0);
    SendSocket(@msg, sMsg);
  end;
end;

procedure TPlayObject.SendServerStatus;
begin
  if m_btPermission < 10 then Exit;
  SysMsg(IntToStr(CalcFileCRC(Application.ExeName)), c_Red, t_Hint);
end;
//检查角色的座标是否在指定误差范围以内
//TargeTBaseObject 为要检查的角色，nX,nY 为比较的座标
//检查角色是否在指定座标的1x1 范围以内，如果在则返回True 否则返回 False

function TBaseObject.CretInNearXY(TargeTBaseObject: TBaseObject; nX, nY: Integer): Boolean;
var
  I: Integer;
  nCX, nCY: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
begin
  Result := False;
  if m_PEnvir = nil then begin
    MainOutMessage('CretInNearXY nil PEnvir');
    Exit;
  end;

  for nCX := nX - 1 to nX + 1 do begin
    for nCY := nY - 1 to nY + 1 do begin
      if m_PEnvir.GetMapCellInfo(nCX, nCY, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
        if MapCellInfo.ObjList.Count > 0 then begin //20080629
          for I := 0 to MapCellInfo.ObjList.Count - 1 do begin
            OSObject := pTOSObject(MapCellInfo.ObjList.Items[I]);
            if OSObject <> nil then begin
              if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                BaseObject := TBaseObject(OSObject.CellObj);
                if BaseObject <> nil then begin
                  if not BaseObject.m_boGhost and (BaseObject = TargeTBaseObject) then begin
                    Result := True;
                    Exit;
                  end;
                end;
              end;
            end;
          end; //for
        end;
      end;
    end;
  end;
end;

function TBaseObject.CretInNearXY(TargeTBaseObject: TBaseObject; nX, nY: Integer; nRange: Integer): Boolean;
var
  I: Integer;
  nCX, nCY: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
begin
  Result := False;
  if m_PEnvir = nil then begin
    MainOutMessage('CretInNearXY nil PEnvir');
    Exit;
  end;
  for nCX := nX - nRange to nX + nRange do begin
    for nCY := nY - nRange to nY + nRange do begin
      if m_PEnvir.GetMapCellInfo(nCX, nCY, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
        if MapCellInfo.ObjList.Count > 0 then begin //20080629
          for I := 0 to MapCellInfo.ObjList.Count - 1 do begin
            OSObject := pTOSObject(MapCellInfo.ObjList.Items[I]);
            if OSObject <> nil then begin
              if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                BaseObject := TBaseObject(OSObject.CellObj);
                if BaseObject <> nil then begin
                  if not BaseObject.m_boGhost and (BaseObject = TargeTBaseObject) then begin
                    Result := True;
                    Exit;
                  end;
                end;
              end;
            end;
          end; //for
        end;
      end;
    end;
  end;
end;
//清除下属 20080124 除英雄66,135怪外

procedure TBaseObject.KillSlave;
var
  I: Integer;
  Slave: TBaseObject;
begin
  if m_SlaveList.Count > 0 then begin
    for I := 0 to m_SlaveList.Count - 1 do begin
      Slave := TBaseObject(m_SlaveList.Items[I]);
      if Slave <> nil then begin
        case Slave.m_btRaceServer of
          11..65, 67..99, 101..107, 110..111, 115..120, 136, 150: begin
              Slave.m_WAbil.HP := 0;
              Slave.MakeGhost;
            end;
        end;
      end;
    end;
  end;
end;

//检查物品附加属性是否正常 20081006

function TBaseObject.CheckIsOKItem(UserItem: pTUserItem): Boolean;
begin
  Result := False;
  if UserItem <> nil then begin
    if {(UserItem.btValue[15] > 1) or (UserItem.btValue[16] > 1) or
       (UserItem.btValue[17] > 1) or (UserItem.btValue[18] > 1) or
       (UserItem.btValue[19] > 1) or}(UserItem.MakeIndex < 0) or
      (UserEngine.GetStdItemName(UserItem.wIndex) = '') then Result := True;
  end;
end;

//盛大吸伤装备,减少受伤值  20080223     U_RINGR//右戒指  U_RINGL//左戒指   衣服武器不能吸伤 20080315

function TBaseObject.ItemStruckDamage(nDamage: Integer): Integer;
var
  I, nCount: Integer;
  StdItem: pTStdItem;
begin
  Result := 0;
  if nDamage > 0 then begin //20091127 增加
    nCount := 0; //吸伤装备带在身,减少受伤值的百分比
    if ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and (not m_boGhost) and (not m_boDeath) then begin //20090628 增加
      try
        for I := Low(THumanUseItems) to High(THumanUseItems) do begin //9格装备+4格装备
          if m_UseItems[I].wIndex > 0 then begin
            StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
            if StdItem <> nil then begin
              case StdItem.StdMode of
                15, 16, 19..24, 26, 27, 28, 29, 30, 52, 54, 55, 62, 64: begin //头盔,项链,戒指,手镯,鞋子,腰带,勋章 20100628 增加29分类(敏捷幸运型项链)
                    if (StdItem.Shape = 188) or (StdItem.Shape = 203) then begin
                      nCount := nCount + StdItem.Source + m_UseItems[I].btValue[20];
                      if nCount >= 100 then Break; //20090712
                    end;
                  end;
              end;
            end; //if pSItem <> nil then begin
          end; //if UseItems[i].wIndex > 0 then begin
        end; // for i:=Low(UseItems) to High(UseItems) do begin
{$IF M2Version = 1}
        if (m_btRaceServer = RC_PLAYOBJECT) and (m_btJob > 0) then begin //道法连击时的吸伤百分率 20090628
          if (m_nDecDamageRate > 0) and (TPlayObject(self).m_boUseBatter) then nCount := nCount + m_nDecDamageRate;
        end;
{$IFEND}
        if nCount > 100 then nCount := 100;
      except
        MainOutMessage(Format('{%s} TBaseObject.ItemStruckDamage %p', [g_sExceptionVer, ExceptAddr]));
      end;
    end;
    Result := Round(nDamage * ((100 - nCount) / 100)) - m_nDecDamage; //20090626 吸伤百分率,修改 div换成/
    if Result < 0 then Result := 0; //20090808
  end;
end;
//------------------------------------------------------------------------------
//套装与身上装备对比 20080226  boHint-是否进入触发段
//五星套装属性：攻魔道上限+10，魔防物防上限+5，强身等级+20

procedure TBaseObject.CompareSuitItem(boHint: boolean);
{  function IsChar(str:string):integer;//判断有几个'|'号
  var I:integer;
  begin
    Result:= 0;
    if length(str) <=0 then Exit;
      for I:=1 to length(str) do
        if (str[I] = '|') then Inc(Result);
  end; }
var
  SuitItem: pTSuitItem;
  I, K, J, nCount, nEXPRATE: Integer;
  nMaxHP, nMaxMP : Integer;
  //Str, Str1: String;
  StdItem: pTStdItem;
  boSuitItem: Boolean;
  Temp: TstringList;
  nCode, nCallTrollLevel: Byte;
begin
  nCode := 0;
  //if m_wStatusArrValue[2] <= 0 then   
  if g_Config.boDecSuitItemMode then //无极真气不考虑套装效果 Move By TasNat at: 2012-03-06 16:25:13
    m_TrueSC := m_WAbil.SC;
  try //20090413 增加
    if ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and (not m_boGhost) and (not m_boDeath) then begin //20081231 英雄和人才进行套装配对
      boSuitItem := False;
      nMaxHP := 0;
      nMaxMP := 0;
      nEXPRATE := 0;
{$IF M2Version <> 2}
      if (m_btRaceServer = RC_PLAYOBJECT) then begin //召唤巨魔
        if TPlayObject(Self).m_Magic103Skill <> nil then begin
          nCallTrollLevel := TPlayObject(Self).m_Magic103Skill.btLevel;
        end;
      end else nCallTrollLevel := 0;
{$IFEND}
      if (m_btRaceServer = RC_PLAYOBJECT) then
        FillChar(TPlayObject(self).ClientSuitAbility, 3 {SizeOf(TClientSuitAbility)}, #0) //套装最高主属性
      else if (m_btRaceServer = RC_HEROOBJECT) then
        FillChar(THeroObject(self).ClientSuitAbility, 3 {SizeOf(TClientSuitAbility)}, #0);
      if g_SuitItemList.count > 0 then begin //20080629
        nCode := 1;
        for I := 0 to g_SuitItemList.count - 1 do begin
          SuitItem := pTSuitItem(g_SuitItemList.Items[I]);
          nCode := 2;
          if SuitItem <> nil then begin
            if (SuitItem.nJob <> m_btJob) and (SuitItem.nJob <> 3) then Continue; //继续(职业不同并不是设置3时不进行)
            nCount := 0;
            //Str1:= SuitItem.Name;
            nCode := 3;
            Temp := TstringList.Create;
            try
              {for K:= 0 to IsChar(Str1) do begin
                str1:=GetValidStr3(Str1,str,['|']);
                if str <> '' then Temp.Add(str);
              end;       }
              nCode := 4;
              ExtractStrings(['|'], [], PChar(SuitItem.Name), Temp); //20110711 修改
              if Temp.Count > 0 then begin
                for J := Low(THumanUseItems) to High(THumanUseItems) do begin //9格装备+4格装备
                  if m_UseItems[J].wIndex > 0 then begin
                    if m_UseItems[J].Dura <= 0 then Continue; //20110117 持久为0则不检查
                    StdItem := UserEngine.GetStdItem(m_UseItems[J].wIndex);
                    if StdItem <> nil then begin
                      K := Temp.IndexOf(StdItem.Name); //20100408 替换
                      if K > -1 then begin
                        Inc(nCount);
                        Temp.Delete(K);
                      end;
                    end;
                    nCode := 11;
                    if (nCount = SuitItem.ItemCount) and (nCount > 0) then begin //数量一样 20090413 修改
                      if not SuitItem.boNewHPMPAdd then begin
                        nMaxHP := _MIN(High(nMaxHP), nMaxHP + (SuitItem.MaxHP * 100)); //HP上限增加比率 20081018
                        nMaxMP := _MIN(High(nMaxMP), nMaxMP + (SuitItem.MaxMP * 100)); //MP上限增加比率 20081018
                      end else begin
                        nMaxHP := _MIN(High(nMaxHP), nMaxHP + Round(m_WAbil.MaxHP * (SuitItem.MaxHP / 100)));//HP上限增加比率 20081018
                        nMaxMP := _MIN(High(nMaxMP), nMaxMP + Round(m_WAbil.MaxMP * (SuitItem.MaxMP / 100)));//MP上限增加比率 20081018
                      end;
                      nCode := 12;
                      m_WAbil.AC := MakeLong(LoWord(SuitItem.MaxAC) + LoWord(m_WAbil.AC), SuitItem.AC + HiWord(m_WAbil.AC)); //防御
                      m_WAbil.MAC := MakeLong(LoWord(SuitItem.MaxMAC) + LoWord(m_WAbil.MAC), SuitItem.MAC + HiWord(m_WAbil.MAC)); //魔防
                      m_WAbil.DC := MakeLong(LoWord(SuitItem.MaxDC) + LoWord(m_WAbil.DC), SuitItem.DC + HiWord(m_WAbil.DC)); //攻击力
                      m_WAbil.MC := MakeLong(LoWord(SuitItem.MaxMC) + LoWord(m_WAbil.MC), SuitItem.MC + HiWord(m_WAbil.MC)); //魔法
                      m_WAbil.SC := MakeLong(LoWord(SuitItem.MaxSC) + LoWord(m_WAbil.SC), SuitItem.SC + HiWord(m_WAbil.SC)); //道术
                      nCode := 13;
                      m_btHitPoint := _MIN(High(Byte), m_btHitPoint + SuitItem.HitPoint); //准确 20090904
                      m_btSpeedPoint := _MIN(High(Byte), m_btSpeedPoint + SuitItem.SpeedPoint); //敏捷 20090904

                      Inc(m_nHealthRecover, SuitItem.HealthRecover); //体力恢复
                      Inc(m_nSpellRecover, SuitItem.SpellRecover); //魔法恢复
                      Inc(m_nLuck, SuitItem.RiskRate); //人物的幸运值
                      nCode := 14;
                      m_nAntiMagic := _MIN(High(ShortInt), m_nAntiMagic + SuitItem.nAntiMagic); //魔法躲避  20090904
                      m_btAntiPoison := _MIN(High(Byte), m_btAntiPoison + SuitItem.nAntiPoison); //中毒躲避 20090904

                      Inc(m_nPoisonRecover, SuitItem.nPoisonRecover); //中毒恢复
                      Inc(m_nHongMoSuite, SuitItem.btReserved); //吸血(虹吸) 20080824
                      
                      nCode := 15;
                      if SuitItem.nPowerRate > 0 then
                        m_WAbil.DC := MakeLong(Round(LoWord(m_WAbil.DC) * (SuitItem.nPowerRate / 10)), Round(HiWord(m_WAbil.DC) * (SuitItem.nPowerRate / 10))); //攻击倍数 20090208
                      nCode := 16;
                      if SuitItem.nMagicRate > 0 then
                        m_WAbil.MC := MakeLong(Round(LoWord(m_WAbil.MC) * (SuitItem.nMagicRate / 10)), Round(HiWord(m_WAbil.MC) * (SuitItem.nMagicRate / 10))); //魔法倍数
                      nCode := 17;
                      if SuitItem.nSCRate > 0 then
                        m_WAbil.SC := MakeLong(Round(LoWord(m_WAbil.SC) * (SuitItem.nSCRate / 10)), Round(HiWord(m_WAbil.SC) * (SuitItem.nSCRate / 10))); //道术倍数
                      nCode := 18;
                      if SuitItem.nACRate > 0 then
                        m_WAbil.AC := MakeLong(Round(LoWord(m_WAbil.AC) * (SuitItem.nACRate / 10)), Round(HiWord(m_WAbil.AC) * (SuitItem.nACRate / 10))); //防御倍数
                      nCode := 19;
                      if SuitItem.nMACRate > 0 then
                        m_WAbil.MAC := MakeLong(Round(LoWord(m_WAbil.MAC) * (SuitItem.nMACRate / 10)), Round(HiWord(m_WAbil.MAC) * (SuitItem.nMACRate / 10))); //魔御倍数
                      nCode := 20;
                      case m_btRaceServer of
                        RC_PLAYOBJECT: begin          
                            if (SuitItem.nEXPRATE > 0) then begin
                              if SuitItem.nEXPRATE > nEXPRATE then nEXPRATE := SuitItem.nEXPRATE; //20090620 取最大的经验倍数
                            end;
                            if (SuitItem.nIncDragonRate > 0) then begin //合击伤害(增加) 20090330
                              TPlayObject(self).m_nIncDragonRate := _MIN(255, TPlayObject(self).m_nIncDragonRate + SuitItem.nIncDragonRate);
                            end;
                            if (SuitItem.nIncDragon > 0) then begin //合击伤害点数
                              TPlayObject(self).m_nIncDragon := _MIN(65535, TPlayObject(self).m_nIncDragon + SuitItem.nIncDragon);
                              //if SuitItem.nIncDragon > TPlayObject(self).ClientSuitAbility.nIncDragon then begin
                                //修复合击威力不叠加 By TasNat at: 2012-04-07 11:29:36
                                TPlayObject(self).ClientSuitAbility.nIncDragon := _MIN(65535, TPlayObject(self).ClientSuitAbility.nIncDragon + SuitItem.nIncDragon); //套装最高主属性
                              //end;
                            end;
{$IF M2Version <> 2}
                            if (SuitItem.nIncNHRate > 0) then begin //内力恢复(增加) 20090330
                              TPlayObject(self).m_nIncNHRecover := _MIN(100, TPlayObject(self).m_nIncNHRecover + SuitItem.nIncNHRate);
                            end;
{$IFEND}
                            if (SuitItem.nCallTrollLevel > 0) and (SuitItem.nCallTrollLevel > nCallTrollLevel) then begin //召唤巨魔等级(传奇套装)
                              nCallTrollLevel := _MIN(4, SuitItem.nCallTrollLevel);
                            end;
                            if SuitItem.nMasterAbility > 0 then begin //主属性 20110711
                              case m_btJob of //按职业增加属性
                                0: m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_WAbil.DC) + SuitItem.nMasterAbility); //战
                                1: m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC), HiWord(m_WAbil.MC) + SuitItem.nMasterAbility); //法
                                2: m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), HiWord(m_WAbil.SC) + SuitItem.nMasterAbility); //道
                              end;
                              //if SuitItem.nMasterAbility > TPlayObject(self).ClientSuitAbility.nMasterAbility then begin
                                //修复套装主属性不叠加
                                TPlayObject(self).ClientSuitAbility.nMasterAbility := _MIN(65535, TPlayObject(self).ClientSuitAbility.nMasterAbility + SuitItem.nMasterAbility); //套装最高主属性
                              //end;
                            end;
                            TPlayObject(self).ClientSuitAbility.nGongJiXiXue := _MIN(500, TPlayObject(self).ClientSuitAbility.nGongJiXiXue +  SuitItem.nVampirePoint);
                          end;
                        RC_HEROOBJECT: begin
                            if (SuitItem.nEXPRATE > 0) then begin
                              if SuitItem.nEXPRATE > nEXPRATE then nEXPRATE := SuitItem.nEXPRATE; //20090620 取最大的经验倍数
                            end;
                            if (SuitItem.nIncDragonRate > 0) then begin //合击伤害(增加) 20090330
                              THeroObject(self).m_nIncDragonRate := _MIN(255, THeroObject(self).m_nIncDragonRate + SuitItem.nIncDragonRate);
                            end;
                            if (SuitItem.nIncDragon > 0) then begin //合击伤害点数
                              THeroObject(self).m_nIncDragon := _MIN(65535, THeroObject(self).m_nIncDragon + SuitItem.nIncDragon);
                              //if SuitItem.nIncDragon > THeroObject(self).ClientSuitAbility.nIncDragon then begin
                                THeroObject(self).ClientSuitAbility.nIncDragon := _MIN(65535, THeroObject(self).ClientSuitAbility.nIncDragon + SuitItem.nIncDragon); //套装最高主属性
                              //end;
                            end;
{$IF M2Version <> 2}
                            if (SuitItem.nIncNHRate > 0) then begin //内力恢复(增加) 20090330
                              THeroObject(self).m_nIncNHRecover := _MIN(100, THeroObject(self).m_nIncNHRecover + SuitItem.nIncNHRate);
                            end;
{$IFEND}
                            if SuitItem.nMasterAbility > 0 then begin //主属性 20110711
                              case m_btJob of //按职业增加属性
                                0: m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_WAbil.DC) + SuitItem.nMasterAbility); //战
                                1: m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC), HiWord(m_WAbil.MC) + SuitItem.nMasterAbility); //法
                                2: m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), HiWord(m_WAbil.SC) + SuitItem.nMasterAbility); //道
                              end;
                              //if SuitItem.nMasterAbility > THeroObject(self).ClientSuitAbility.nMasterAbility then begin
                                THeroObject(self).ClientSuitAbility.nMasterAbility := _MIN(65535, THeroObject(self).ClientSuitAbility.nMasterAbility + SuitItem.nMasterAbility); //套装最高主属性
                              //end;
                            end;
                            THeroObject(self).ClientSuitAbility.nGongJiXiXue := _MIN(500, THeroObject(self).ClientSuitAbility.nGongJiXiXue +  SuitItem.nVampirePoint);
                          end;
                      end;
                      nCode := 6;
                      if SuitItem.boTeleport then m_boTeleport := True; //传送 20080824
                      if SuitItem.boParalysis then m_boParalysis := True; //麻痹
                      if SuitItem.boRevival then m_boRevival := True; //复活
                      if SuitItem.boMagicShield then m_boMagicShield := True; //护身
                      if SuitItem.boUnParalysis then m_boUnParalysis := True; //防麻痹
                      if SuitItem.boUnRevival then m_boUnRevival := True; //复活
                      if SuitItem.boUnMagicShield then m_boUnMagicShield := True; //防护身
                      if SuitItem.boParalysis1 then m_boParalysis1 := True;
                      if SuitItem.boParalysis2 then m_boParalysis2 := True;
                      if SuitItem.boParalysis3 then m_boParalysis3 := True;
{$IF M2Version <> 2}
                      nCode := 8;
                      if (SuitItem.btReserved1 > 0) then m_nDecTargetNHPoint := _MIN(High(Byte), m_nDecTargetNHPoint + SuitItem.btReserved1); //目标减内力值
{$IFEND}
                      nCode := 9;
                      if (SuitItem.nUnBurstRate > 0) then m_nUnBurstRate := _MIN(High(Byte), m_nUnBurstRate + SuitItem.nUnBurstRate); //防爆
                      if (SuitItem.nVampirePoint > 0) then m_nVampirePoint := _MIN(High(Byte), m_nVampirePoint + SuitItem.nVampirePoint); //吸血点数(虎威装备)

                      nCode := 10;
                      if (g_FunctionNPC <> nil) and boHint then begin
                        if m_btRaceServer = RC_PLAYOBJECT then begin
                          g_FunctionNPC.GotoLable(TPlayObject(Self), '@SuitItem' + inttostr(I), False, False); //套装触发 20080712
                        end else
                          if (m_btRaceServer = RC_HEROOBJECT) and (m_Master <> nil) then begin
                            g_FunctionNPC.GotoLable(TPlayObject(m_Master), '@SuitItem' + inttostr(I), False, False); //套装触发 20080712
                          end;
                      end;
                      boSuitItem := True;
                      Break;
                    end;
                  end;
                end;
              end;
            finally
              Temp.Free;
            end;
          end;
        end; //for
        nCode := 22;
        if nMaxHP > 0 then begin
          if m_WAbil.MaxHP > (High(Integer) - nMaxHP) then begin //20101001 修改
            m_WAbil.MaxHP := High(Integer);
          end else m_WAbil.MaxHP := m_WAbil.MaxHP + nMaxHP;
        end;
        if nMaxMP > 0 then begin
          if m_WAbil.MaxMP > (High(Integer) - nMaxMP) then begin //20101001 修改
            m_WAbil.MaxMP := High(Integer);
          end else m_WAbil.MaxMP := m_WAbil.MaxMP + nMaxMP;
        end;
        nCode := 23;
{$IF M2Version <> 2}
        if (m_btRaceServer = RC_PLAYOBJECT) then begin //召唤巨魔
          if TPlayObject(Self).m_Magic103Skill <> nil then begin
            TPlayObject(Self).m_Magic103Skill.btLevel := nCallTrollLevel;
            SendMsg(self, RM_MAGIC_LVEXP, TPlayObject(Self).m_Magic103Skill.MagicInfo.wMagicId, 0, TPlayObject(Self).m_Magic103Skill.btLevel, 0, '');
          end;
        end;
{$IFEND}
      end;
      nCode := 21;
      if not boSuitItem then begin //不带上套装,则恢复原来的经验倍数
        case m_btRaceServer of
          RC_PLAYOBJECT: begin
              TPlayObject(self).m_nKillMonExpRate := TPlayObject(self).m_nOldKillMonExpRate; //20080522
              TPlayObject(self).m_nItmeIncMonExpRate := 0; //使用套装增加的经验 20080607
            end;
          RC_HEROOBJECT: THeroObject(self).m_nKillMonExpRate := THeroObject(self).m_nOldKillMonExpRate; //20080522
        end;
      end else begin
        if nEXPRATE > 0 then begin //20090620 修改
          case m_btRaceServer of
            RC_PLAYOBJECT: begin
                TPlayObject(self).m_nItmeIncMonExpRate := (nEXPRATE - 1) * TPlayObject(self).m_nOldKillMonExpRate; //使用套装增加的经验
                TPlayObject(self).m_nKillMonExpRate := nEXPRATE * TPlayObject(self).m_nOldKillMonExpRate; //经验倍数
              end;
            RC_HEROOBJECT: THeroObject(self).m_nKillMonExpRate := nEXPRATE * THeroObject(self).m_nOldKillMonExpRate; //经验倍数
          end;
        end;
      end;
      if m_wStatusTimeArr[POISON_LOCK1] > 0 then begin //敌对目标的防御和魔防减到0(唯我独尊)
        m_WAbil.AC := 0;
        m_WAbil.MAC := 0;
      end; 
      if not g_Config.boDecSuitItemMode then //无极真气考虑套装效果 Move By TasNat at: 2012-03-06 16:25:13
        m_TrueSC := m_WAbil.SC;
{$IF M2Version = 1}
      case m_btRaceServer of
        RC_PLAYOBJECT: with TPlayObject(self) do begin
            if g_Config.boDecMag105SC and (m_boHeartActive) then //无极真气不考虑心法效果 By TasNat at: 2012-03-06 16:25:13
              m_TrueSC := MakeLong({_MAX(}LoWord(m_TrueSC){ - LoWord(m_dwHeartAddPower), 0)}, _MAX(0, HiWord(m_TrueSC) - m_dwHeartAddPower));

            if (m_Magic95Skill <> nil) and m_boTrainingNG then begin //学过斗转星移,则计算转值上限
              
              m_WAbil.MaxTransferValue := TPlayObject(self).GetSkill_95Value(HiWord(m_WAbil.AC), HiWord(m_WAbil.MAC), TPlayObject(self).m_Magic95Skill.btLevel);
              if m_WAbil.TransferValue > m_WAbil.MaxTransferValue then m_WAbil.TransferValue := m_WAbil.MaxTransferValue;
            end;
          end;
        RC_HEROOBJECT: begin
            if (THeroObject(self).m_Magic95Skill <> nil) and THeroObject(self).m_boTrainingNG then begin //学过斗转星移,则计算转值上限
              m_WAbil.MaxTransferValue := THeroObject(self).GetSkill_95Value(HiWord(m_WAbil.AC), HiWord(m_WAbil.MAC), THeroObject(self).m_Magic95Skill.btLevel);
              if m_WAbil.TransferValue > m_WAbil.MaxTransferValue then m_WAbil.TransferValue := m_WAbil.MaxTransferValue;
            end;
          end;
      end;
{$IFEND}
    //限制不能大于上限 By TasNat at: 2012-03-06 13:06:54
      m_WAbil.HP := _Min(m_WAbil.MaxHP, m_WAbil.HP);
      m_WAbil.MP := _Min(m_WAbil.MaxMP, m_WAbil.MP);
    end;
  except
    MainOutMessage(Format('{%s} TBaseObject.CompareSuitItem Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

//------------------------------------------------------------------------------
//判断绑定物品的属性

function TBaseObject.CheckItemValue(UserItem: pTUserItem; nType: Integer): Boolean;
begin
  Result := False;
  if UserItem <> nil then begin
    if ((128 shr nType) and (UserItem.btValue[14])) <> 0 then Result := True;
    {case nType of
      0: if UserItem.btValue[14] = 1 then Result := True;//禁止扔
      1: if UserItem.btValue[15] = 1 then Result := True;//禁止交易
      2: if UserItem.btValue[16] = 1 then Result := True;//禁止存
      3: if UserItem.btValue[17] = 1 then Result := True;//禁止修
      4: if UserItem.btValue[18] = 1 then Result := True;//禁止出售
      5: if UserItem.btValue[19] = 1 then Result := True;//禁止爆出
    end;}
  end;
end;
//设置物品绑定状态(禁止扔、交易、存、修、出售、爆出) 20110528

procedure TBaseObject.SetItemState(Useritem: pTUserItem; nValType: Integer; nRate: Integer);
var
  bt15: Byte;
begin
  try
    bt15 := UserItem.btValue[14];
    if nRate = 1 then UserItem.btValue[14] := (128 shr nValType) or (bt15)
    else UserItem.btValue[14] := (not (128 shr nValType)) and (bt15);
  except
    MainOutMessage(Format('{%s} TBaseObject.SetItemState', [g_sExceptionVer]));
  end;
end;
//------------------------------------------------------------------------------
{$IF M2Version <> 2}
//取当前称号名

procedure TPlayObject.GetUseHumTitles();
var
  I: integer;
  HumTitle: pTHumTitleDB;
begin
  try
    for I := Low(THumTitles) to High(THumTitles) do begin
      if (m_wHumTitles[I].wIndex > 0) and (m_wHumTitles[I].MakeIndex > 0) then begin
        HumTitle := UserEngine.GetHumTitle(m_wHumTitles[I].wIndex);
        if HumTitle <> nil then begin
          if m_wHumTitles[I].boUseTitle then begin
            m_boUseTitle := True; //当前是否使用称号
            m_boUseIitleIdx := HumTitle.Looks; //当前使用称号的图片索引
            m_sUseIitleName := HumTitle.sTitleName;
            Break;
          end;
        end;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TPlayObject.GetUseHumTitles', [g_sExceptionVer]));
  end;
end;

//发送称号数据 nType=1 登陆时

procedure TPlayObject.SendHumTitles(nType: Byte);
var
  I, K, L, nHours, nIdx: Integer;
  HumTitle: pTHumTitleDB;
  ClientHumTitle: TClientHumTitles;
  sFileName: string;
  PoseHuman1: TPlayObject;
  LoadList: TStringList;
  boRef: Boolean;
begin
  try
    case nType of
      0: begin
          boRef := False;
          m_boUseTitle := False; //当前是否使用称号
          m_boUseIitleIdx := 0; //当前使用称号的图片索引
          m_sUseIitleName := '';
          K := 0;
          L := 0;
          FillChar(ClientHumTitle, SizeOf(TClientHumTitles), #0);
          for I := Low(THumTitles) to High(THumTitles) do begin
            if (m_wHumTitles[I].wIndex > 0) and (m_wHumTitles[I].MakeIndex > 0) then begin
              HumTitle := UserEngine.GetHumTitle(m_wHumTitles[I].wIndex);
              if HumTitle <> nil then begin
                case HumTitle.StdMode of
                  1: begin //永久称号
                      Inc(L);
                      ClientHumTitle.ClientHumTitles[K].MakeIndex := m_wHumTitles[I].MakeIndex;
                      ClientHumTitle.ClientHumTitles[K].StdMode := HumTitle.StdMode; //分类
                      ClientHumTitle.ClientHumTitles[K].AniCount := HumTitle.AniCount; //特效ID
                      ClientHumTitle.ClientHumTitles[K].sTitleName := HumTitle.sTitleName; //称号名
                      ClientHumTitle.ClientHumTitles[K].Looks := HumTitle.Looks;
                      ClientHumTitle.ClientHumTitles[K].wDC := HiWord(HumTitle.DC); //攻击上限
                      ClientHumTitle.ClientHumTitles[K].wMC := HiWord(HumTitle.MC); //魔法上限
                      ClientHumTitle.ClientHumTitles[K].wSC := HiWord(HumTitle.SC); //道术上限
                      ClientHumTitle.ClientHumTitles[K].wHP := LoWord(HumTitle.AC); //生命上限
                      ClientHumTitle.ClientHumTitles[K].nHours := 65535; //剩余小时(65535) 表示永久
                      if m_wHumTitles[I].boUseTitle then begin
                        ClientHumTitle.nUseTitleIndex := L;
                        m_boUseTitle := True; //当前是否使用称号
                        m_boUseIitleIdx := HumTitle.Looks; //当前使用称号的图片索引
                        m_sUseIitleName := HumTitle.sTitleName;
                      end;
                      case HumTitle.AniCount of
                        1: ClientHumTitle.ClientHumTitles[K].wDura := m_wHumTitles[I].wDura; //千里传音次数(水晶之星－－需保存)
                        5: ClientHumTitle.ClientHumTitles[K].wDura := _MAX(0, 3 - m_nDieCount); //随机攻击倍数(巅峰勇士类)
                      end;
                      Inc(K);
                    end;
                else begin //限时称号处理时间
                    nHours := GetHoursCount(m_wHumTitles[I].ApplyDate, Now());
                    if nHours > 0 then begin
                      case HumTitle.AniCount of
                        1: begin
                            Inc(L);
                            ClientHumTitle.ClientHumTitles[K].MakeIndex := m_wHumTitles[I].MakeIndex;
                            ClientHumTitle.ClientHumTitles[K].StdMode := HumTitle.StdMode; //分类
                            ClientHumTitle.ClientHumTitles[K].AniCount := HumTitle.AniCount; //特效ID
                            ClientHumTitle.ClientHumTitles[K].sTitleName := HumTitle.sTitleName; //称号名
                            ClientHumTitle.ClientHumTitles[K].Looks := HumTitle.Looks;
                            ClientHumTitle.ClientHumTitles[K].wDC := HiWord(HumTitle.DC); //攻击上限
                            ClientHumTitle.ClientHumTitles[K].wMC := HiWord(HumTitle.MC); //魔法上限
                            ClientHumTitle.ClientHumTitles[K].wSC := HiWord(HumTitle.SC); //道术上限
                            ClientHumTitle.ClientHumTitles[K].wHP := LoWord(HumTitle.AC); //生命上限
                            ClientHumTitle.ClientHumTitles[K].nHours := nHours; //剩余小时(65535) 表示永久
                            if m_wHumTitles[I].boUseTitle then begin
                              ClientHumTitle.nUseTitleIndex := L;
                              m_boUseTitle := True; //当前是否使用称号
                              m_boUseIitleIdx := HumTitle.Looks; //当前使用称号的图片索引
                              m_sUseIitleName := HumTitle.sTitleName;
                            end;
                            ClientHumTitle.ClientHumTitles[K].wDura := m_wHumTitles[I].wDura; //千里传音次数(水晶之星－－需保存)
                          end;
                        5: begin
                            if m_nDieCount < 3 then begin
                              Inc(L);
                              ClientHumTitle.ClientHumTitles[K].wDura := _MAX(0, 3 - m_nDieCount); //随机攻击倍数(巅峰勇士类)
                              ClientHumTitle.ClientHumTitles[K].MakeIndex := m_wHumTitles[I].MakeIndex;
                              ClientHumTitle.ClientHumTitles[K].StdMode := HumTitle.StdMode; //分类
                              ClientHumTitle.ClientHumTitles[K].AniCount := HumTitle.AniCount; //特效ID
                              ClientHumTitle.ClientHumTitles[K].sTitleName := HumTitle.sTitleName; //称号名
                              ClientHumTitle.ClientHumTitles[K].Looks := HumTitle.Looks;
                              ClientHumTitle.ClientHumTitles[K].wDC := HiWord(HumTitle.DC); //攻击上限
                              ClientHumTitle.ClientHumTitles[K].wMC := HiWord(HumTitle.MC); //魔法上限
                              ClientHumTitle.ClientHumTitles[K].wSC := HiWord(HumTitle.SC); //道术上限
                              ClientHumTitle.ClientHumTitles[K].wHP := LoWord(HumTitle.AC); //生命上限
                              ClientHumTitle.ClientHumTitles[K].nHours := nHours; //剩余小时(65535) 表示永久
                              if m_wHumTitles[I].boUseTitle then begin
                                ClientHumTitle.nUseTitleIndex := L;
                                m_boUseTitle := True; //当前是否使用称号
                                m_boUseIitleIdx := HumTitle.Looks; //当前使用称号的图片索引
                                m_sUseIitleName := HumTitle.sTitleName;
                              end;
                            end else begin
                              m_wHumTitles[I].MakeIndex := 0;
                              m_wHumTitles[I].wIndex := 0;
                              if m_wHumTitles[I].boUseTitle then begin //20110313
                                m_boUseTitle := False; //当前是否使用称号
                                m_boUseIitleIdx := 0; //当前使用称号的图片索引
                                m_sUseIitleName := '';
                                RefShowName();
                              end;
                              m_wHumTitles[I].boUseTitle := False;
                              m_wHumTitles[I].wDura := 0;
                              m_wHumTitles[I].wMaxDura := 0;
                              m_wHumTitles[I].sChrName := ''; //需处理认命类称号
                              SysMsg(Format('您失去了称号：%s', [HumTitle.sTitleName]), c_Green, t_Hint);
                              boRef := True;
                              if g_FunctionNPC <> nil then begin
                                g_FunctionNPC.GotoLable(Self, '@FengHaoFunc' + IntToStr(HumTitle.idx), False, False);
                              end;
                              Continue; //继续
                            end;
                          end;
                      else begin
                          Inc(L);
                          ClientHumTitle.ClientHumTitles[K].MakeIndex := m_wHumTitles[I].MakeIndex;
                          ClientHumTitle.ClientHumTitles[K].StdMode := HumTitle.StdMode; //分类
                          ClientHumTitle.ClientHumTitles[K].AniCount := HumTitle.AniCount; //特效ID
                          ClientHumTitle.ClientHumTitles[K].sTitleName := HumTitle.sTitleName; //称号名
                          ClientHumTitle.ClientHumTitles[K].Looks := HumTitle.Looks;
                          ClientHumTitle.ClientHumTitles[K].wDC := HiWord(HumTitle.DC); //攻击上限
                          ClientHumTitle.ClientHumTitles[K].wMC := HiWord(HumTitle.MC); //魔法上限
                          ClientHumTitle.ClientHumTitles[K].wSC := HiWord(HumTitle.SC); //道术上限
                          ClientHumTitle.ClientHumTitles[K].wHP := LoWord(HumTitle.AC); //生命上限
                          ClientHumTitle.ClientHumTitles[K].nHours := nHours; //剩余小时(65535) 表示永久
                          if m_wHumTitles[I].boUseTitle then begin
                            ClientHumTitle.nUseTitleIndex := L;
                            m_boUseTitle := True; //当前是否使用称号
                            m_boUseIitleIdx := HumTitle.Looks; //当前使用称号的图片索引
                            m_sUseIitleName := HumTitle.sTitleName;
                          end;
                        end;
                      end;
                      Inc(K);
                    end else begin //称号到期时的处理
                      m_wHumTitles[I].MakeIndex := 0;
                      m_wHumTitles[I].wIndex := 0;
                      if m_wHumTitles[I].boUseTitle then begin //20110313
                        m_boUseTitle := False; //当前是否使用称号
                        m_boUseIitleIdx := 0; //当前使用称号的图片索引
                        m_sUseIitleName := '';
                        RefShowName();
                      end;
                      m_wHumTitles[I].boUseTitle := False;
                      m_wHumTitles[I].wDura := 0;
                      m_wHumTitles[I].wMaxDura := 0;
                      case HumTitle.AniCount of
                        2: begin //主宰龙卫
                            if m_wHumTitles[I].sChrName <> '' then begin
                              PoseHuman1 := UserEngine.GetPlayObject(m_wHumTitles[I].sChrName); //检查是否在线
                              if PoseHuman1 <> nil then begin
                                nIdx := PoseHuman1.m_ComradeList.IndexOf(m_sCharName);
                                if nIdx > -1 then begin
                                  PoseHuman1.m_ComradeList.Delete(nIdx);
                                  PoseHuman1.SaveFengHaoList(g_Config.sEnvirDir + 'UserData\FengHao\Comrade', PoseHuman1.m_ComradeList);
                                end;
                              end else begin
                                sFileName := g_Config.sEnvirDir + 'UserData\FengHao\Comrade\' + m_wHumTitles[I].sChrName + '.txt';
                                if FileExists(sFileName) then begin
                                  try
                                    LoadList := TStringList.Create;
                                    LoadList.LoadFromFile(sFileName);
                                    nIdx := LoadList.IndexOf(m_sCharName);
                                    if nIdx > -1 then begin
                                      LoadList.Delete(nIdx);
                                      LoadList.SaveToFile(sFileName);
                                    end;
                                  finally
                                    LoadList.Free;
                                  end;
                                end;
                              end;
                            end;
                          end;
                        3: begin //护花使者
                            if m_wHumTitles[I].sChrName <> '' then begin
                              PoseHuman1 := UserEngine.GetPlayObject(m_wHumTitles[I].sChrName); //检查是否在线
                              if PoseHuman1 <> nil then begin
                                nIdx := PoseHuman1.m_HuhuaList.IndexOf(m_sCharName);
                                if nIdx > -1 then begin
                                  PoseHuman1.m_HuhuaList.Delete(nIdx);
                                  PoseHuman1.SaveFengHaoList(g_Config.sEnvirDir + 'UserData\FengHao\HuHua', PoseHuman1.m_HuhuaList);
                                end;
                              end else begin
                                sFileName := g_Config.sEnvirDir + 'UserData\FengHao\HuHua\' + m_wHumTitles[I].sChrName + '.txt';
                                if FileExists(sFileName) then begin
                                  try
                                    LoadList := TStringList.Create;
                                    LoadList.LoadFromFile(sFileName);
                                    nIdx := LoadList.IndexOf(m_sCharName);
                                    if nIdx > -1 then begin
                                      LoadList.Delete(nIdx);
                                      LoadList.SaveToFile(sFileName);
                                    end;
                                  finally
                                    LoadList.Free;
                                  end;
                                end;
                              end;
                            end;
                          end;
                        7: begin //传奇之星，清空列表
                            m_HuhuaList.Clear;
                            sFileName := g_Config.sEnvirDir + 'UserData\FengHao\HuHua';
                            if not DirectoryExists(sFileName) then ForceDirectories(sFileName); //目录不存在,则创建
                            sFileName := sFileName + '\' + m_sCharName + '.txt';
                            if FileExists(sFileName) then DeleteFile(sFileName);
                          end;
                        9: begin //玛法主宰者
                            m_ComradeList.Clear;
                            sFileName := g_Config.sEnvirDir + 'UserData\FengHao\Comrade';
                            if not DirectoryExists(sFileName) then ForceDirectories(sFileName); //目录不存在,则创建
                            sFileName := sFileName + '\' + m_sCharName + '.txt';
                            if FileExists(sFileName) then DeleteFile(sFileName);
                          end;
                      end;
                      m_wHumTitles[I].sChrName := ''; //需处理认命类称号
                      SysMsg(Format('您失去了称号：%s', [HumTitle.sTitleName]), c_Green, t_Hint);
                      boRef := True;
                      if g_FunctionNPC <> nil then begin
                        g_FunctionNPC.GotoLable(Self, '@FengHaoFunc' + IntToStr(HumTitle.idx), False, False);
                      end;
                    end;
                  end;
                end;
              end;
            end;
          end;
          m_DefMsg := MakeDefaultMsg(SM_SENDHUMTITLES, 0, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, EncodeBuffer(@ClientHumTitle, SizeOf(TClientHumTitles)));
          if K <= 0 then m_boCanTitle := False; //是否有称号
          if boRef then begin
            RecalcAbilitys();
            CompareSuitItem(False); //套装
            SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
          end;
        end; //0
      1: begin
          m_boCanTitle := False; //是否有称号
          m_boUseTitle := False; //当前是否使用称号
          m_boUseIitleIdx := 0; //当前使用称号的图片索引
          m_sUseIitleName := '';
          for I := Low(THumTitles) to High(THumTitles) do begin
            if (m_wHumTitles[I].wIndex > 0) and (m_wHumTitles[I].MakeIndex > 0) then begin
              HumTitle := UserEngine.GetHumTitle(m_wHumTitles[I].wIndex);
              if HumTitle <> nil then begin
                case HumTitle.StdMode of
                  1: begin //永久称号
                      m_boCanTitle := True; //是否有称号
                      if m_wHumTitles[I].boUseTitle then begin
                        m_boUseTitle := True;
                        m_boUseIitleIdx := HumTitle.Looks; //当前使用称号的图片索引
                        m_sUseIitleName := HumTitle.sTitleName;
                        Exit;
                      end;
                    end;
                else begin //限时称号处理时间
                    nHours := GetHoursCount(m_wHumTitles[I].ApplyDate, Now());
                    if nHours > 0 then begin
                      m_boCanTitle := True; //是否有称号
                      if m_wHumTitles[I].boUseTitle then begin
                        m_boUseTitle := True;
                        m_boUseIitleIdx := HumTitle.Looks; //当前使用称号的图片索引
                        m_sUseIitleName := HumTitle.sTitleName;
                      //Exit;
                      end;
                      case HumTitle.AniCount of
                        7: begin //传奇之星
                            GetFengHaoList(g_Config.sEnvirDir + 'UserData\FengHao\HuHua', m_HuhuaList); //魔法粉红效果(传奇之星)
                          end;
                        9: begin //玛法主宰者
                            GetFengHaoList(g_Config.sEnvirDir + 'UserData\FengHao\Comrade', m_ComradeList); //玛法主宰者
                          end;
                      end;
                    end else begin //称号到期时的处理
                      m_wHumTitles[I].MakeIndex := 0;
                      m_wHumTitles[I].wIndex := 0;
                      m_wHumTitles[I].boUseTitle := False;
                      m_wHumTitles[I].wDura := 0;
                      m_wHumTitles[I].wMaxDura := 0;
                      case HumTitle.AniCount of
                        2: begin //主宰龙卫
                            if m_wHumTitles[I].sChrName <> '' then begin
                              PoseHuman1 := UserEngine.GetPlayObject(m_wHumTitles[I].sChrName); //检查是否在线
                              if PoseHuman1 <> nil then begin
                                nIdx := PoseHuman1.m_ComradeList.IndexOf(m_sCharName);
                                if nIdx > -1 then begin
                                  PoseHuman1.m_ComradeList.Delete(nIdx);
                                  PoseHuman1.SaveFengHaoList(g_Config.sEnvirDir + 'UserData\FengHao\Comrade', PoseHuman1.m_ComradeList);
                                end;
                              end else begin
                                sFileName := g_Config.sEnvirDir + 'UserData\FengHao\Comrade\' + m_wHumTitles[I].sChrName + '.txt';
                                if FileExists(sFileName) then begin
                                  try
                                    LoadList := TStringList.Create;
                                    LoadList.LoadFromFile(sFileName);
                                    nIdx := LoadList.IndexOf(m_sCharName);
                                    if nIdx > -1 then begin
                                      LoadList.Delete(nIdx);
                                      LoadList.SaveToFile(sFileName);
                                    end;
                                  finally
                                    LoadList.Free;
                                  end;
                                end;
                              end;
                            end;
                          end;
                        3: begin //护花使者
                            if m_wHumTitles[I].sChrName <> '' then begin
                              PoseHuman1 := UserEngine.GetPlayObject(m_wHumTitles[I].sChrName); //检查是否在线
                              if PoseHuman1 <> nil then begin
                                nIdx := PoseHuman1.m_HuhuaList.IndexOf(m_sCharName);
                                if nIdx > -1 then begin
                                  PoseHuman1.m_HuhuaList.Delete(nIdx);
                                  PoseHuman1.SaveFengHaoList(g_Config.sEnvirDir + 'UserData\FengHao\HuHua', PoseHuman1.m_HuhuaList);
                                end;
                              end else begin
                                sFileName := g_Config.sEnvirDir + 'UserData\FengHao\HuHua\' + m_wHumTitles[I].sChrName + '.txt';
                                if FileExists(sFileName) then begin
                                  try
                                    LoadList := TStringList.Create;
                                    LoadList.LoadFromFile(sFileName);
                                    nIdx := LoadList.IndexOf(m_sCharName);
                                    if nIdx > -1 then begin
                                      LoadList.Delete(nIdx);
                                      LoadList.SaveToFile(sFileName);
                                    end;
                                  finally
                                    LoadList.Free;
                                  end;
                                end;
                              end;
                            end;
                          end;
                        7: begin //传奇之星，清空列表
                            m_HuhuaList.Clear;
                            sFileName := g_Config.sEnvirDir + 'UserData\FengHao\HuHua';
                            if not DirectoryExists(sFileName) then ForceDirectories(sFileName); //目录不存在,则创建
                            sFileName := sFileName + '\' + m_sCharName + '.txt';
                            if FileExists(sFileName) then DeleteFile(sFileName);
                          end;
                        9: begin //玛法主宰者
                            m_ComradeList.Clear;
                            sFileName := g_Config.sEnvirDir + 'UserData\FengHao\Comrade';
                            if not DirectoryExists(sFileName) then ForceDirectories(sFileName); //目录不存在,则创建
                            sFileName := sFileName + '\' + m_sCharName + '.txt';
                            if FileExists(sFileName) then DeleteFile(sFileName);
                          end;
                      end;
                      m_wHumTitles[I].sChrName := ''; //需处理认命类称号
                      SysMsg(Format('您失去了称号：%s', [HumTitle.sTitleName]), c_Green, t_Hint);
                      if g_FunctionNPC <> nil then begin
                        g_FunctionNPC.GotoLable(Self, '@FengHaoFunc' + IntToStr(HumTitle.idx), False, False);
                      end;
                    end;
                  end;
                end;
              end;
            end;
          end;
        end; //1
    end;
  except
      MainOutMessage(Format('{%s} TPlayObject.SendHumTitles', [g_sExceptionVer]));
  end;
end;
{$IFEND}

//发送装备物品 客户端显示的物品再这个发送出去  SendUseItems

procedure TPlayObject.SendUseitems;
var
  I: Integer;
  Item: pTStdItem;
  sSENDMSG: string;
  ClientItem: TClientItem;
  EffecItem: pTEffecItem;
  OClientItem: TOClientItem;
  StdItem: TStdItem;
  sUserItemName: string;
begin
  if m_boNotOnlineAddExp or m_boAI then Exit; //20110316 增加
  if (m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0) then begin
    sSENDMSG := '';
    for I := Low(THumItems) to High(THumItems) do begin
      if m_UseItems[I].wIndex > 0 then begin
        Item := UserEngine.GetStdItem(m_UseItems[I].wIndex);
        if Item <> nil then begin
          StdItem := Item^;
          ItemUnit.GetItemAddValue(@m_UseItems[I], StdItem);
          CopyStdItemToOStdItem(@StdItem, @OClientItem.s);

          //取自定义物品名称
          sUserItemName := '';
          if m_UseItems[I].btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(m_UseItems[I].MakeIndex, m_UseItems[I].wIndex);
          if sUserItemName <> '' then
            OClientItem.s.Name := sUserItemName;

          OClientItem.Dura := m_UseItems[I].Dura;
          OClientItem.DuraMax := m_UseItems[I].DuraMax;
          OClientItem.MakeIndex := m_UseItems[I].MakeIndex;
          sSENDMSG := sSENDMSG + IntToStr(I) + '/' + EncodeBuffer(@OClientItem, SizeOf(TOClientItem)) + '/';
        end;
      end;
    end;
    if sSENDMSG <> '' then begin
      m_DefMsg := MakeDefaultMsg(SM_SENDUSEITEMS, 0, 0, 0, 0, 0);
      SendSocket(@m_DefMsg, sSENDMSG);
    end;
  end else begin
    sSENDMSG := '';
    for I := Low(THumanUseItems) to High(THumanUseItems) do begin //9格装备+4格装备
      if m_UseItems[I].wIndex > 0 then begin
        Item := UserEngine.GetStdItem(m_UseItems[I].wIndex);
        if Item <> nil then begin
          FillChar(ClientItem, SizeOf(ClientItem), #0);
          StdItem := Item^;
          ItemUnit.GetItemAddValue(@m_UseItems[I], StdItem);
          Move(StdItem, ClientItem.s, SizeOf(TStdItem));
          //取特效配置
          {By TasNat at: 2012-11-22 11:11:11
          EffecItem := GetEffecItemList(StdItem.Name); //取物品特效
          if EffecItem <> nil then begin
            Move(EffecItem^, ClientItem.ClientEffec, SizeOf(TEffecItem));
          end;}

          //取自定义物品名称
          sUserItemName := '';
          if m_UseItems[I].btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(m_UseItems[I].MakeIndex, m_UseItems[I].wIndex);
          if sUserItemName <> '' then ClientItem.s.Name := sUserItemName;
          if (m_UseItems[I].btValue[12] = 1) and (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) then ClientItem.s.Reserved1 := 1 //物品发光 20080224
          else ClientItem.s.Reserved1 := 0;
{$IF M2Version <> 2}
          if (StdItem.StdMode = 5) or (StdItem.StdMode = 6) then begin //武器暴击等级 20100708
            ClientItem.s.NeedIdentify := _MIN(High(Byte), m_UseItems[I].btValue[11] + m_UseItems[I].btValue[20]);
            if CheckItemSpiritMedia(m_UseItems[I]) then begin
              ClientItem.Aura := m_UseItems[I].btValue[12];
              ClientItem.MaxAura := g_Config.nMaxAuraValue;
            end;
          end else begin
            if CheckItemSpiritMedia(m_UseItems[I]) then begin
              ClientItem.Aura := m_UseItems[I].btValue[11];
              ClientItem.MaxAura := g_Config.nMaxAuraValue;
            end;
          end;
{$IFEND}
          ClientItem.Dura := m_UseItems[I].Dura;
          ClientItem.DuraMax := m_UseItems[I].DuraMax;
          ClientItem.MakeIndex := m_UseItems[I].MakeIndex;
          Move(m_UseItems[I].btValue, ClientItem.btValue, SizeOf(ClientItem.btValue)); // add by liuzhigang on 2011.12.20
          //Modified By TasNat at: 2012-04-12 09:28:18
          ClientItem.btAppraisalLevel :=   m_UseItems[I].btAppraisalLevel;
          ClientItem.btUnKnowValueCount := m_UseItems[I].btUnKnowValueCount;
          Move(m_UseItems[I].btAppraisalValue, ClientItem.btAppraisalValue, SizeOf(m_UseItems[I].btAppraisalValue));

          Move(m_UseItems[I].btUnKnowValue, ClientItem.btUnKnowValue, SizeOf(ClientItem.btUnKnowValue)); //20100822
          ClientItem.BindValue := m_UseItems[I].AddValue[0]; //20110622
          ClientItem.MaxDate := m_UseItems[I].MaxDate; //20110622
          if ClientItem.BindValue = 0 then begin //禁止交易,扔物品,显示绑定 20110626
            if (CheckItemValue(@m_UseItems[I], 1) and CheckItemValue(@m_UseItems[I], 0)) or
              (GetCheckItemList(0, StdItem.Name) and GetCheckItemList(1, StdItem.Name)) then
              ClientItem.BindValue := 3;
          end;
          sSENDMSG := sSENDMSG + IntToStr(I) + '/' + EncodeBuffer(@ClientItem, SizeOf(ClientItem)) + '/';
        end;
      end;
    end;
    if sSENDMSG <> '' then begin
      m_DefMsg := MakeDefaultMsg(SM_SENDUSEITEMS, 0, 0, 0, 0, 0);
      SendSocket(@m_DefMsg, sSENDMSG);
    end;
  end;
end;
//发送使用的魔法

procedure TPlayObject.SendUseMagic;
var
  I: Integer;
  sSENDMSG: string;
  UserMagic: pTUserMagic;
  ClientMagic: TClientMagic;
begin
  if m_boNotOnlineAddExp or m_boAI then Exit;
  sSENDMSG := '';
  if m_MagicList.Count > 0 then begin //20080629
    for I := 0 to m_MagicList.Count - 1 do begin
      UserMagic := m_MagicList.Items[I];
      if UserMagic <> nil then begin
        ClientMagic.Key := Chr(UserMagic.btKey);
        ClientMagic.Level := UserMagic.btLevel;
        ClientMagic.CurTrain := UserMagic.nTranPoint;
        ClientMagic.Def := UserMagic.MagicInfo^;
        ClientMagic.btLevelEx := UserMagic.btLevelEx;
        case ClientMagic.Def.wMagicId of
          SKILL_68: ClientMagic.Def.MaxTrain[0] := GetSkill68Exp(UserMagic.btLevel); //酒气护体
{$IF M2Version <> 2}
{$IF M2Version = 1}
          SKILL_95: ClientMagic.Def.MaxTrain[0] := GetSkill95Exp(UserMagic.btLevel); //斗转星移
{$IFEND}
          SKILL_105: begin //龙卫心法
              ClientMagic.Def.sMagicName := m_sHeartName; //自定义技能名称
              ClientMagic.Def.btDefMaxPower := m_nHeartType; //心法类型
              if UserMagic.btLevel > 0 then
                ClientMagic.Def.MaxTrain[0] := ClientMagic.Def.MaxTrain[0] + UserMagic.btLevel * (ClientMagic.Def.MaxTrain[2] - ClientMagic.Def.MaxTrain[1]);
            end;
          SKILL_106: begin //传承龙卫心法
              ClientMagic.Def.sMagicName := m_sHeartName; //自定义技能名称
              ClientMagic.Def.btDefMaxPower := m_nHeartType; //心法类型
              if UserMagic.btLevel > 0 then
                ClientMagic.Def.MaxTrain[0] := ClientMagic.Def.MaxTrain[0] + UserMagic.btLevel * (ClientMagic.Def.MaxTrain[2] - ClientMagic.Def.MaxTrain[1]);
            end;
          SKILL_107, SKILL_108, SKILL_109: begin //被动龙卫技能
              if UserMagic.btLevel > 0 then
                ClientMagic.Def.MaxTrain[0] := ClientMagic.Def.MaxTrain[0] + UserMagic.btLevel * (ClientMagic.Def.MaxTrain[2] - ClientMagic.Def.MaxTrain[1]);
            end;
          SKILL_200: begin //怒之攻杀强化
              if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
                ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_200NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_200NGStrong[1]);
                ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_200NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_200NGStrong[3]);
              end else begin
                ClientMagic.Def.wPower := 0;
                ClientMagic.Def.wMaxPower := 0;
              end;
            end;
          Skill_202: begin //怒之半月强化
              if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
                ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_202NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_202NGStrong[1]);
                ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_202NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_202NGStrong[3]);
              end else begin
                ClientMagic.Def.wPower := 0;
                ClientMagic.Def.wMaxPower := 0;
              end;
            end;
          Skill_236: begin //怒之内功剑法强化
              if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
                ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_236NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_236NGStrong[1]);
                ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_236NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_236NGStrong[3]);
              end else begin
                ClientMagic.Def.wPower := 0;
                ClientMagic.Def.wMaxPower := 0;
              end;
            end;
          Skill_204: begin //怒之烈火强化
              if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
                ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_204NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_204NGStrong[1]);
                ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_204NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_204NGStrong[3]);
              end else begin
                ClientMagic.Def.wPower := 0;
                ClientMagic.Def.wMaxPower := 0;
              end;
            end;
          Skill_206: begin //怒之逐日强化
              if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
                ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_206NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_206NGStrong[1]);
                ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_206NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_206NGStrong[3]);
              end else begin
                ClientMagic.Def.wPower := 0;
                ClientMagic.Def.wMaxPower := 0;
              end;
            end;
          Skill_239: begin //怒之施毒术强化
              if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
                ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_239NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_239NGStrong[1]);
                ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_239NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_239NGStrong[3]);
              end else begin
                ClientMagic.Def.wPower := 0;
                ClientMagic.Def.wMaxPower := 0;
              end;
            end;
          Skill_230: begin //怒之火符强化
              if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
                ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_230NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_230NGStrong[1]);
                ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_230NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_230NGStrong[3]);
              end else begin
                ClientMagic.Def.wPower := 0;
                ClientMagic.Def.wMaxPower := 0;
              end;
            end;
          Skill_232: begin //怒之噬血强化
              if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
                ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_232NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_232NGStrong[1]);
                ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_232NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_232NGStrong[3]);
              end else begin
                ClientMagic.Def.wPower := 0;
                ClientMagic.Def.wMaxPower := 0;
              end;
            end;
          Skill_241: begin //怒之月灵强化
              if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
                ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_241NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_241NGStrong[1]);
                ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_241NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_241NGStrong[3]);
              end else begin
                ClientMagic.Def.wPower := 0;
                ClientMagic.Def.wMaxPower := 0;
              end;
            end;
          Skill_228: begin //怒之灭天火强化
              if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
                ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_228NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_228NGStrong[1]);
                ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_228NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_228NGStrong[3]);
              end else begin
                ClientMagic.Def.wPower := 0;
                ClientMagic.Def.wMaxPower := 0;
              end;
            end;
          Skill_234: begin //怒之流星火雨强化
              if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
                ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_234NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_234NGStrong[1]);
                ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_234NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_234NGStrong[3]);
              end else begin
                ClientMagic.Def.wPower := 0;
                ClientMagic.Def.wMaxPower := 0;
              end;
            end;
          Skill_208: begin //怒之火球强化
              if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
                ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_208NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_208NGStrong[1]);
                ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_208NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_208NGStrong[3]);
              end else begin
                ClientMagic.Def.wPower := 0;
                ClientMagic.Def.wMaxPower := 0;
              end;
            end;
          Skill_214: begin //怒之地狱火强化
              if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
                ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_214NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_214NGStrong[1]);
                ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_214NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_214NGStrong[3]);
              end else begin
                ClientMagic.Def.wPower := 0;
                ClientMagic.Def.wMaxPower := 0;
              end;
            end;
          Skill_218: begin //怒之爆裂火焰强化
              if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
                ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_218NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_218NGStrong[1]);
                ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_218NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_218NGStrong[3]);
              end else begin
                ClientMagic.Def.wPower := 0;
                ClientMagic.Def.wMaxPower := 0;
              end;
            end;
          Skill_222: begin //怒之雷电强化
              if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
                ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_222NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_222NGStrong[1]);
                ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_222NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_222NGStrong[3]);
              end else begin
                ClientMagic.Def.wPower := 0;
                ClientMagic.Def.wMaxPower := 0;
              end;
            end;
          Skill_210: begin //怒之大火球强化
              if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
                ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_210NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_210NGStrong[1]);
                ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_210NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_210NGStrong[3]);
              end else begin
                ClientMagic.Def.wPower := 0;
                ClientMagic.Def.wMaxPower := 0;
              end;
            end;
          Skill_212: begin //怒之火墙强化
              if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
                ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_212NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_212NGStrong[1]);
                ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_212NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_212NGStrong[3]);
              end else begin
                ClientMagic.Def.wPower := 0;
                ClientMagic.Def.wMaxPower := 0;
              end;
            end;
          Skill_216: begin //怒之疾光电影强化
              if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
                ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_216NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_216NGStrong[1]);
                ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_216NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_216NGStrong[3]);
              end else begin
                ClientMagic.Def.wPower := 0;
                ClientMagic.Def.wMaxPower := 0;
              end;
            end;
          Skill_224: begin //怒之地狱雷光强化
              if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
                ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_224NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_224NGStrong[1]);
                ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_224NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_224NGStrong[3]);
              end else begin
                ClientMagic.Def.wPower := 0;
                ClientMagic.Def.wMaxPower := 0;
              end;
            end;
          Skill_226: begin //怒之寒冰掌强化
              if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
                ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_226NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_226NGStrong[1]);
                ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_226NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_226NGStrong[3]);
              end else begin
                ClientMagic.Def.wPower := 0;
                ClientMagic.Def.wMaxPower := 0;
              end;
            end;
          Skill_220: begin //怒之冰咆哮强化
              if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
                ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_220NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_220NGStrong[1]);
                ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_220NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_220NGStrong[3]);
              end else begin
                ClientMagic.Def.wPower := 0;
                ClientMagic.Def.wMaxPower := 0;
              end;
            end;
{$IFEND}
          SKILL_99: ClientMagic.Def.MaxTrain[0] := 300 + (UserMagic.btLevel * 200); //强身术的升级经验通过算法取出
          SKILL_100: ClientMagic.Def.MaxTrain[0] := 500 + (UserMagic.btLevel * 700); //神秘解读
          SKILL_71, SKILL_104: ClientMagic.Def.MaxTrain[0] := GetUpKill71Count(UserMagic.btLevel); //召唤圣兽,召唤火灵
        end;
        sSENDMSG := sSENDMSG + EncodeBuffer(@ClientMagic, SizeOf(TClientMagic)) + '/';
      end;
    end; //for
  end;
  if sSENDMSG <> '' then begin
{$IF M2Version = 1}
    m_DefMsg := MakeDefaultMsg(SM_SENDMYMAGIC, m_SetBatterKey, m_SetBatterKey1, m_SetBatterKey2, m_MagicList.Count, m_SetBatterKey3); //第四个连击技能格 20100719
{$ELSE}
    m_DefMsg := MakeDefaultMsg(SM_SENDMYMAGIC, 0, 0, 0, m_MagicList.Count, 0);
{$IFEND}
    SendSocket(@m_DefMsg, sSENDMSG);
  end;
end;
//客户端改变方向

function TPlayObject.ClientChangeDir(wIdent: Word; nX, nY, nDir: Integer; var dwDelayTime: LongWord): Boolean; //4CAEB8
var
  dwCheckTime: LongWord;
begin
  Result := False;
  if (nDir > 7) or (nDir < 0) then Exit; //20101123 判断方向是否大于7
  if m_boDeath or (m_wStatusTimeArr[POISON_STONE {5}] <> 0) or
    (m_wStatusTimeArr[POISON_DONTMOVE] <> 0) or (m_wStatusTimeArr[POISON_LOCKSPELL {7}] <> 0)
    or (m_wStatusArrValue[23] <> 0) then Exit; //防麻
  if not CheckActionStatus(wIdent, dwDelayTime) then begin
    m_boFilterAction := False;
    Exit;
  end;
  m_boFilterAction := True;
  dwCheckTime := GetTickCount - m_dwTurnTick;
  if dwCheckTime < g_Config.dwTurnIntervalTime then begin
    dwDelayTime := g_Config.dwTurnIntervalTime - dwCheckTime;
    {
    if dwCheckTime <= g_Config.dwTurnIntervalTime div 2 then begin
      SysMsg('ClientChangeDir ' + IntToStr(dwCheckTime);
      m_boEmergencyClose:=True;
      Result:=True;
    end;
    }
    Exit;
  end;

  if (nX = m_nCurrX) and (nY = m_nCurrY) then begin
    m_btDirection := nDir;
    if Walk(RM_TURN) then begin
      m_dwTurnTick := GetTickCount();
      Result := True;
    end;
  end;
end;
//客户端蹲下的动作

function TPlayObject.ClientSitDownHit(nX, nY, nDir: Integer; var dwDelayTime: LongWord): Boolean; //004CC248
var
  dwCheckTime: LongWord;
begin
  Result := False;
  if m_boDeath or (m_wStatusTimeArr[POISON_STONE {5}] <> 0) or
    (m_wStatusTimeArr[POISON_LOCKSPELL {7}] <> 0) or (m_wStatusArrValue[23] <> 0) then Exit; //防麻

  dwCheckTime := GetTickCount - m_dwTurnTick;

  if dwCheckTime < g_Config.dwTurnIntervalTime then begin
    dwDelayTime := g_Config.dwTurnIntervalTime - dwCheckTime;
    Exit;
  end;
  m_dwTurnTick := GetTickCount;
  Result := True;
end;
//开门,人物走到地图的某个过门点时

procedure TPlayObject.ClientOpenDoor(nX, nY: Integer);
var
  Door: pTDoorInfo;
  Castle: TUserCastle;
begin
  Door := m_PEnvir.GetDoor(nX, nY);
  if Door = nil then Exit;
  Castle := g_CastleManager.IsCastleEnvir(m_PEnvir);
  if (Castle = nil) or
    (Castle.m_DoorStatus <> Door.Status) or
    (m_btRaceServer <> RC_PLAYOBJECT) or
    Castle.CheckInPalace(m_nCurrX, m_nCurrY, Self) then begin
    UserEngine.OpenDoor(m_PEnvir, nX, nY);
  end;
  {
  if (UserCastle.m_MapCastle <> m_PEnvir) or
     (UserCastle.m_DoorStatus <> Door.Status) or
     (m_btRaceServer <> RC_PLAYOBJECT) or
     UserCastle.CheckInPalace(m_nCurrX,m_nCurrY,Self) then begin

    UserEngine.OpenDoor(m_PEnvir,nX,nY);
  end;
  }
end;

//nSortType 0-人物榜 1-英雄榜 2-师徒榜 3-装备榜 nType 1-等级榜 2-战士榜 3-法师榜 4-道士榜
//(装备榜)nType 1-武器榜 2-戒指榜 3-衣甲榜 4-靴子榜 5-头盔榜 6-腰带榜 7-项链榜 8-勋章榜 9-护腕榜 10-斗笠面巾榜

procedure TPlayObject.ClientGetUserOrder(nSortType, nType, nPage: Integer); //用户排行
var
  nIndex: Integer;
  n01, nPageCount, nBeginPage: Integer;
  sSendText: string;
  nCode: Byte;
{$IF M2Version <> 2}
  ItemLevelSort: pTItemLevelSort;
{$IFEND}
  function GetPageCount(): Integer; //取总页数
  var nCount: Integer;
  begin
    Result := 0;
    case nSortType of
      0: begin
          case nType of
            1: nCount := g_TaxisAllList.nMaxIdx;
            2: nCount := g_TaxisWarrList.nMaxIdx;
            3: nCount := g_TaxisWaidList.nMaxIdx;
            4: nCount := g_TaxisTaosList.nMaxIdx;
          end;
        end;
      1: begin
          if g_Config.boUseCanHero then begin //开放英雄系统 20100529
{$IF HEROVERSION = 1}
            case nType of
              1: nCount := g_HeroAllList.nMaxIdx;
              2: nCount := g_HeroWarrList.nMaxIdx;
              3: nCount := g_HeroWaidList.nMaxIdx;
              4: nCount := g_HeroTaosList.nMaxIdx;
            end;
{$IFEND}
          end;
        end;
      2: begin
          nCount := g_MasterList.nMaxIdx;
        end;
{$IF M2Version <> 2}
      3: begin //装备榜
          if g_Config.boUseCanKamPo then begin
            case nType of
              1: nCount := g_ArmsSortList.Count;
              2: nCount := g_RingSortList.Count;
              3: nCount := g_DreSortList.Count;
              4: nCount := g_ShoesSortList.Count;
              5: nCount := g_HelmeSortList.Count;
              6: nCount := g_BootsSortList.Count;
              7: nCount := g_NecklaceSortList.Count;
              8: nCount := g_MedalSortList.Count;
              9: nCount := g_BraceletSortList.Count;
              10: nCount := g_ZhuLiSortList.Count;
            end;
          end;
        end;
{$IFEND}
    end;
    if nCount > 0 then begin
      Result := nCount div 10;
      if nCount mod 10 > 0 then Inc(Result);
    end;
  end;
  procedure GetSelfHumMsg(HumSort: THumSort);
  var
    i: integer;
  begin
    for I := 0 to HumSort.nMaxIdx - 1 do begin
      if CompareText(HumSort.List[I].sChrName, m_sCharName) = 0 then begin
        sSendText := EncodeBuffer(@HumSort.List[I], SizeOf(TUserLevelSort));
        break;
      end;
    end;
  end;
  procedure GetHeroHumMsg(HumSort: THeroSort);
  var
    i: integer;
  begin
    for I := 0 to HumSort.nMaxIdx - 1 do begin
      if CompareText(HumSort.List[I].sChrName, m_sCharName) = 0 then begin
        sSendText := EncodeBuffer(@HumSort.List[I], SizeOf(THeroLevelSort));
        break;
      end;
    end;
  end;

begin
  EnterCriticalSection(HumanSortCriticalSection);
  try
    nCode := 0;
    try
      nPageCount := GetPageCount();
      nCode := 1;
      if nPageCount > 0 then begin
        n01 := 0;
        sSendText := '';
        nBeginPage := nPage;
        if nPage >= nPageCount then nBeginPage := nPageCount - 1;
        if nBeginPage < 0 then nBeginPage := 0;
        if nPage < 0 then begin //我的排行
          case nSortType of
            0: begin //人物榜
                case nType of
                  1: GetSelfHumMsg(g_TaxisAllList);
                  2: GetSelfHumMsg(g_TaxisWarrList);
                  3: GetSelfHumMsg(g_TaxisWaidList);
                  4: GetSelfHumMsg(g_TaxisTaosList);
                end;
              end;
            1: begin //英雄榜
{$IF HEROVERSION = 1}
                case nType of
                  1: GetHeroHumMsg(g_HeroAllList);
                  2: GetHeroHumMsg(g_HeroWarrList);
                  3: GetHeroHumMsg(g_HeroWaidList);
                  4: GetHeroHumMsg(g_HeroTaosList);
                end;
{$IFEND}
              end;
            2: begin //师徒榜
                GetSelfHumMsg(g_MasterList);
              end;
          end;
        end else begin
          nCode := 8;
          case nSortType of
            0: begin //人物榜
                case nType of
                  1: begin
                      for nIndex := nBeginPage * 10 to g_TaxisAllList.nMaxIdx - 1 do begin
                        if (n01 >= 10) or (g_TaxisAllList.nMaxIdx <= 0) then Break;
                        if g_TaxisAllList.List[nIndex].sChrName <> '' then begin
                          sSendText := sSendText + EncodeBuffer(@g_TaxisAllList.List[nIndex], SizeOf(TUserLevelSort)) + '/';
                        end;
                        Inc(n01);
                      end;
                    end;
                  2: begin
                      for nIndex := nBeginPage * 10 to g_TaxisWarrList.nMaxIdx - 1 do begin
                        if (n01 >= 10) or (g_TaxisWarrList.nMaxIdx <= 0) then Break;
                        if g_TaxisWarrList.List[nIndex].sChrName <> '' then begin
                          sSendText := sSendText + EncodeBuffer(@g_TaxisWarrList.List[nIndex], SizeOf(TUserLevelSort)) + '/';
                        end;
                        Inc(n01);
                      end;
                    end;
                  3: begin
                      for nIndex := nBeginPage * 10 to g_TaxisWaidList.nMaxIdx - 1 do begin
                        if (n01 >= 10) or (g_TaxisWaidList.nMaxIdx <= 0) then Break;
                        if g_TaxisWaidList.List[nIndex].sChrName <> '' then begin
                          sSendText := sSendText + EncodeBuffer(@g_TaxisWaidList.List[nIndex], SizeOf(TUserLevelSort)) + '/';
                        end;
                        Inc(n01);
                      end;
                    end;
                  4: begin
                      for nIndex := nBeginPage * 10 to g_TaxisTaosList.nMaxIdx - 1 do begin
                        if (n01 >= 10) or (g_TaxisTaosList.nMaxIdx <= 0) then Break;
                        if g_TaxisTaosList.List[nIndex].sChrName <> '' then begin
                          sSendText := sSendText + EncodeBuffer(@g_TaxisTaosList.List[nIndex], SizeOf(TUserLevelSort)) + '/';
                        end;
                        Inc(n01);
                      end;
                    end;
                end;
              end;
            1: begin //英雄榜
{$IF HEROVERSION = 1}
                case nType of
                  1: begin
                      for nIndex := nBeginPage * 10 to g_HeroAllList.nMaxIdx - 1 do begin
                        if (n01 >= 10) or (g_HeroAllList.nMaxIdx <= 0) then Break;
                        if g_HeroAllList.List[nIndex].sChrName <> '' then begin
                          sSendText := sSendText + EncodeBuffer(@g_HeroAllList.List[nIndex], SizeOf(THeroLevelSort)) + '/';
                        end;
                        Inc(n01);
                      end;
                    end;
                  2: begin
                      for nIndex := nBeginPage * 10 to g_HeroWarrList.nMaxIdx - 1 do begin
                        if (n01 >= 10) or (g_HeroWarrList.nMaxIdx <= 0) then Break;
                        if g_HeroWarrList.List[nIndex].sChrName <> '' then begin
                          sSendText := sSendText + EncodeBuffer(@g_HeroWarrList.List[nIndex], SizeOf(THeroLevelSort)) + '/';
                        end;
                        Inc(n01);
                      end;
                    end;
                  3: begin
                      for nIndex := nBeginPage * 10 to g_HeroWaidList.nMaxIdx - 1 do begin
                        if (n01 >= 10) or (g_HeroWaidList.nMaxIdx <= 0) then Break;
                        if g_HeroWaidList.List[nIndex].sChrName <> '' then begin
                          sSendText := sSendText + EncodeBuffer(@g_HeroWaidList.List[nIndex], SizeOf(THeroLevelSort)) + '/';
                        end;
                        Inc(n01);
                      end;
                    end;
                  4: begin
                      for nIndex := nBeginPage * 10 to g_HeroTaosList.nMaxIdx - 1 do begin
                        if (n01 >= 10) or (g_HeroTaosList.nMaxIdx <= 0) then Break;
                        if g_HeroTaosList.List[nIndex].sChrName <> '' then begin
                          sSendText := sSendText + EncodeBuffer(@g_HeroTaosList.List[nIndex], SizeOf(THeroLevelSort)) + '/';
                        end;
                        Inc(n01);
                      end;
                    end;
                end;
{$IFEND}
              end;
            2: begin //师徒榜
                for nIndex := nBeginPage * 10 to g_MasterList.nMaxIdx - 1 do begin
                  if (n01 >= 10) or (g_MasterList.nMaxIdx <= 0) then Break;
                  if g_MasterList.List[nIndex].sChrName <> '' then begin
                    sSendText := sSendText + EncodeBuffer(@g_MasterList.List[nIndex], SizeOf(TUserLevelSort)) + '/';
                  end;
                  Inc(n01);
                end;
              end;
{$IF M2Version <> 2}
            3: begin //装备榜
                if g_Config.boUseCanKamPo then begin
                  case nType of
                    1: begin //武器榜
                        for nIndex := nBeginPage * 10 to g_ArmsSortList.Count - 1 do begin
                          if (n01 >= 10) or (g_ArmsSortList.Count <= 0) or (nIndex >= MAXITEMORDERSCOUNT) then Break;
                          ItemLevelSort := pTItemLevelSort(g_ArmsSortList.Items[nIndex]);
                          if ItemLevelSort <> nil then begin
                            ItemLevelSort.nIndex := nIndex + 1;
                            sSendText := sSendText + EncodeBuffer(@ItemLevelSort^, SizeOf(TItemLevelSort)) + '/';
                          end;
                          Inc(n01);
                        end;
                      end;
                    2: begin //戒指榜
                        for nIndex := nBeginPage * 10 to g_RingSortList.Count - 1 do begin
                          if (n01 >= 10) or (g_RingSortList.Count <= 0) or (nIndex >= MAXITEMORDERSCOUNT) then Break;
                          ItemLevelSort := pTItemLevelSort(g_RingSortList.Items[nIndex]);
                          if ItemLevelSort <> nil then begin
                            ItemLevelSort.nIndex := nIndex + 1;
                            sSendText := sSendText + EncodeBuffer(@ItemLevelSort^, SizeOf(TItemLevelSort)) + '/';
                          end;
                          Inc(n01);
                        end;
                      end;
                    3: begin //衣甲榜
                        for nIndex := nBeginPage * 10 to g_DreSortList.Count - 1 do begin
                          if (n01 >= 10) or (g_DreSortList.Count <= 0) or (nIndex >= MAXITEMORDERSCOUNT) then Break;
                          ItemLevelSort := pTItemLevelSort(g_DreSortList.Items[nIndex]);
                          if ItemLevelSort <> nil then begin
                            ItemLevelSort.nIndex := nIndex + 1;
                            sSendText := sSendText + EncodeBuffer(@ItemLevelSort^, SizeOf(TItemLevelSort)) + '/';
                          end;
                          Inc(n01);
                        end;
                      end;
                    4: begin //靴子榜
                        for nIndex := nBeginPage * 10 to g_ShoesSortList.Count - 1 do begin
                          if (n01 >= 10) or (g_ShoesSortList.Count <= 0) or (nIndex >= MAXITEMORDERSCOUNT) then Break;
                          ItemLevelSort := pTItemLevelSort(g_ShoesSortList.Items[nIndex]);
                          if ItemLevelSort <> nil then begin
                            ItemLevelSort.nIndex := nIndex + 1;
                            sSendText := sSendText + EncodeBuffer(@ItemLevelSort^, SizeOf(TItemLevelSort)) + '/';
                          end;
                          Inc(n01);
                        end;
                      end;
                    5: begin //头盔榜
                        for nIndex := nBeginPage * 10 to g_HelmeSortList.Count - 1 do begin
                          if (n01 >= 10) or (g_HelmeSortList.Count <= 0) or (nIndex >= MAXITEMORDERSCOUNT) then Break;
                          ItemLevelSort := pTItemLevelSort(g_HelmeSortList.Items[nIndex]);
                          if ItemLevelSort <> nil then begin
                            ItemLevelSort.nIndex := nIndex + 1;
                            sSendText := sSendText + EncodeBuffer(@ItemLevelSort^, SizeOf(TItemLevelSort)) + '/';
                          end;
                          Inc(n01);
                        end;
                      end;
                    6: begin //腰带榜
                        for nIndex := nBeginPage * 10 to g_BootsSortList.Count - 1 do begin
                          if (n01 >= 10) or (g_BootsSortList.Count <= 0) or (nIndex >= MAXITEMORDERSCOUNT) then Break;
                          ItemLevelSort := pTItemLevelSort(g_BootsSortList.Items[nIndex]);
                          if ItemLevelSort <> nil then begin
                            ItemLevelSort.nIndex := nIndex + 1;
                            sSendText := sSendText + EncodeBuffer(@ItemLevelSort^, SizeOf(TItemLevelSort)) + '/';
                          end;
                          Inc(n01);
                        end;
                      end;
                    7: begin //项链榜
                        for nIndex := nBeginPage * 10 to g_NecklaceSortList.Count - 1 do begin
                          if (n01 >= 10) or (g_NecklaceSortList.Count <= 0) or (nIndex >= MAXITEMORDERSCOUNT) then Break;
                          ItemLevelSort := pTItemLevelSort(g_NecklaceSortList.Items[nIndex]);
                          if ItemLevelSort <> nil then begin
                            ItemLevelSort.nIndex := nIndex + 1;
                            sSendText := sSendText + EncodeBuffer(@ItemLevelSort^, SizeOf(TItemLevelSort)) + '/';
                          end;
                          Inc(n01);
                        end;
                      end;
                    8: begin //勋章榜
                        for nIndex := nBeginPage * 10 to g_MedalSortList.Count - 1 do begin
                          if (n01 >= 10) or (g_MedalSortList.Count <= 0) or (nIndex >= MAXITEMORDERSCOUNT) then Break;
                          ItemLevelSort := pTItemLevelSort(g_MedalSortList.Items[nIndex]);
                          if ItemLevelSort <> nil then begin
                            ItemLevelSort.nIndex := nIndex + 1;
                            sSendText := sSendText + EncodeBuffer(@ItemLevelSort^, SizeOf(TItemLevelSort)) + '/';
                          end;
                          Inc(n01);
                        end;
                      end;
                    9: begin //护腕榜
                        for nIndex := nBeginPage * 10 to g_BraceletSortList.Count - 1 do begin
                          if (n01 >= 10) or (g_BraceletSortList.Count <= 0) or (nIndex >= MAXITEMORDERSCOUNT) then Break;
                          ItemLevelSort := pTItemLevelSort(g_BraceletSortList.Items[nIndex]);
                          if ItemLevelSort <> nil then begin
                            ItemLevelSort.nIndex := nIndex + 1;
                            sSendText := sSendText + EncodeBuffer(@ItemLevelSort^, SizeOf(TItemLevelSort)) + '/';
                          end;
                          Inc(n01);
                        end;
                      end;
                    10: begin //斗笠面巾榜
                        for nIndex := nBeginPage * 10 to g_ZhuLiSortList.Count - 1 do begin
                          if (n01 >= 10) or (g_ZhuLiSortList.Count <= 0) or (nIndex >= MAXITEMORDERSCOUNT) then Break;
                          ItemLevelSort := pTItemLevelSort(g_ZhuLiSortList.Items[nIndex]);
                          if ItemLevelSort <> nil then begin
                            ItemLevelSort.nIndex := nIndex + 1;
                            sSendText := sSendText + EncodeBuffer(@ItemLevelSort^, SizeOf(TItemLevelSort)) + '/';
                          end;
                          Inc(n01);
                        end;
                      end;
                  end;
                end;
              end;
{$IFEND}
          end;
        end;
        nCode := 12;
        if nPage >= 0 then begin
          nCode := 13;
          if sSendText <> '' then begin {客户端对应Param   Recog     Tag     Series }
            SendMsg(Self, RM_QUERYUSERLEVELSORT, nPage, nSortType, nType, nPageCount, sSendText);
          end;
        end else begin
          nCode := 14;
          if sSendText <> '' then begin
            SendMsg(Self, RM_QUERYUSERLEVELSORT, nPage, nSortType, nType, 0, sSendText);
          end else begin
            SendMsg(Self, RM_QUERYUSERLEVELSORT, nPage, -1, nType, 0, '');
          end;
        end;
      end;
    except
      MainOutMessage(Format('{%s} TPlayObject.ClientGetUserOrder Code:%d', [g_sExceptionVer, nCode]));
    end;
  finally
    LeaveCriticalSection(HumanSortCriticalSection);
  end;
end;


{$IF HEROVERSION = 1}
//创建英雄

function TPlayObject.MakeHero(PlayObject: TPlayObject; HumanRcd: THumDataInfo; NewHeroDataInfo: TNewHeroDataInfo; nType: Byte): TBaseObject;
 { function GetGotoXY(nDir: Integer; var nX, nY: Integer): Boolean;//20090116 取能走的坐标
  var
    n01: Byte;
    nTargetX, nTargetY: Integer;
  begin
    Result := False;
    n01 := 0;
    nTargetX:= nX;
    nTargetY:= nY;
    while True do begin
      case nDir of
        DR_UP: begin//北
            if m_PEnvir.CanWalk(nTargetX, nTargetY, False) then begin
              Result := True;
              Break;
            end else begin
              if n01 >= 3 then Break;
              Dec(nTargetY, 2);
              Inc(n01);
              Continue;
            end;
          end;
        DR_UPRIGHT: begin//东北
            if m_PEnvir.CanWalk(nTargetX, nTargetY, False) then begin
              Result := True;
              Break;
            end else begin
              if n01 >= 3 then Break;
              Inc(nTargetX, 2);
              Dec(nTargetY, 2);
              Inc(n01);
              Continue;
            end;
          end;
        DR_RIGHT: begin//东
            if m_PEnvir.CanWalk(nTargetX, nTargetY, False) then begin
              Result := True;
              Break;
            end else begin
              if n01 >= 3 then Break;
              Inc(nTargetX, 2);
              Inc(n01);
              Continue;
            end;
          end;
        DR_DOWNRIGHT: begin//东南
            if m_PEnvir.CanWalk(nTargetX, nTargetY, False) then begin
              Result := True;
              Break;
            end else begin
              if n01 >= 3 then Break;
              Inc(nTargetX, 2);
              Inc(nTargetY, 2);
              Inc(n01);
              Continue;
            end;
          end;
        DR_DOWN: begin//南
            if m_PEnvir.CanWalk(nTargetX, nTargetY, False) then begin
              Result := True;
              Break;
            end else begin
              if n01 >= 3 then Break;
              Inc(nTargetY, 1);
              Inc(n01);
              Continue;
            end;
          end;
        DR_DOWNLEFT: begin//西南
            if m_PEnvir.CanWalk(nTargetX, nTargetY,False) then begin
              Result := True;
              Break;
            end else begin
              if n01 >= 3 then Break;
              Dec(nTargetX, 2);
              Inc(nTargetY, 2);
              Inc(n01);
              Continue;
            end;
          end;
        DR_LEFT: begin//西
            if m_PEnvir.CanWalk(nTargetX, nTargetY, False) then begin
              Result := True;
              Break;
            end else begin
              if n01 >= 3 then Break;
              Dec(nTargetX, 2);
              Inc(n01);
              Continue;
            end;
          end;
        DR_UPLEFT: begin//西北向
            if m_PEnvir.CanWalk(nTargetX, nTargetY, False) then begin
              Result := True;
              Break;
            end else begin
              if n01 >= 3 then Break;
              Dec(nTargetX, 2);
              Dec(nTargetY, 2);
              Inc(n01);
              Continue;
            end;
          end;
        else Break;
      end;
    end;
    nX := nTargetX;
    nY := nTargetY;
  end;}
  function GetLeftPosition(nDir: Byte; var nX, nY: Integer): Boolean; //20090525
  var
    Envir: TEnvirnoment;
  begin
    Envir := m_PEnvir;
    nX := m_nCurrX;
    nY := m_nCurrY;
    case nDir of
      DR_UP {0}: if nX > 0 then Dec(nX);
      DR_DOWN {4}: if nX < (Envir.m_nWidth - 1) then Inc(nX);
      DR_LEFT {6}: if nY > 0 then Dec(nY);
      DR_RIGHT {2}: if nY < (Envir.m_nHeight - 1) then Inc(nY);

      DR_UPLEFT {西北向}: begin
          if (nX > 0) and (nY > 0) then begin
            Dec(nX);
            Dec(nY);
          end;
        end;
      DR_UPRIGHT {东北向}: begin
          if (nX > 0) and (nY < (Envir.m_nHeight - 1)) then begin
            Inc(nX);
            Dec(nY);
          end;
        end;
      DR_DOWNLEFT {西南向}: begin
          if (nX < (Envir.m_nWidth - 1)) and (nY > 0) then begin
            Dec(nX);
            Inc(nY);
          end
        end;
      DR_DOWNRIGHT {东南向}: begin
          if (nX < (Envir.m_nWidth - 1)) and (nY < (Envir.m_nHeight - 1)) then begin
            Inc(nX);
            Inc(nY);
          end;
        end;
    end;
    Result := True;
  end;
var
  nX, nY, n1C, n10: Integer;
  MonObj: TBaseObject;
  nCode: Byte; //20090108
begin
  Result := nil;
  nCode := 0;
  n1C := 0;
  try
    if not m_boAI then begin
      //主人英雄名与英雄名字不一致
      if (CompareText(PlayObject.m_sHeroCharName, HumanRcd.Data.sChrName) <> 0) and
         (CompareText(PlayObject.m_sDeputyHeroName, HumanRcd.Data.sChrName) <> 0) then begin
        MainOutMessage('{提示} 召唤英雄失败：人物[' + PlayObject.m_sCharName + ']的英雄名(' + PlayObject.m_sHeroCharName + ')与英雄名字(' + HumanRcd.Data.sChrName + ')不一致,账号：' + PlayObject.m_sUserID);
        Exit;
      end;
      nCode := 1;
      if (CompareText(PlayObject.m_sCharName, HumanRcd.Data.sMasterName) <> 0) then begin //检查与主人名是否一致 20090526
        if (CompareText(PlayObject.m_sUserID, HumanRcd.Data.sAccount) = 0) and
          ((CompareText(PlayObject.m_sHeroCharName, HumanRcd.Data.sChrName) = 0) or
          (CompareText(PlayObject.m_sDeputyHeroName, HumanRcd.Data.sChrName) = 0)) then begin //账号一致，则自动修正 20090620
          HumanRcd.Data.sMasterName := PlayObject.m_sCharName;
        end else begin
          MainOutMessage('{提示} 召唤英雄失败：英雄(' + PlayObject.m_sHeroCharName + ')的主人名字(' + HumanRcd.Data.sMasterName + ')与人物[' + PlayObject.m_sCharName + ']不一致,账号：' + PlayObject.m_sUserID);
          Exit;
        end;
      end;
      if (CompareText(PlayObject.m_sUserID, HumanRcd.Data.sAccount) <> 0) then begin //20100122 增加，检查账号是否一致
        if (CompareText(PlayObject.m_sCharName, HumanRcd.Data.sMasterName) = 0) then begin
          HumanRcd.Data.sAccount := PlayObject.m_sUserID;
        end else Exit;
      end;
      if (not HumanRcd.Header.boIsHero) or (HumanRcd.Header.boDeleted) then Exit; //20080907
    end;
    GetFrontPosition(nX, nY);
    nCode := 2;
    while (True) do begin
      try
        if not m_PEnvir.CanWalk(nX, nY, False) then begin //20090116 如果坐标无法走，则取主人的方向，计算可以走到的坐标上
          //GetFrontPosition(nX, nY);//20090525 注释
          n10 := (m_btDirection + n1C) mod 8;
          GetLeftPosition(n10, nX, nY); //20090525 增加
          //GetGotoXY(n10, nX, nY);//20090525 注释
        end else Break;
        Inc(n1C);
        if n1C >= 8 then Break;
      except
        Break;
      end;
    end;
    nCode := 21;
    MonObj := UserEngine.RegenMyHero(PlayObject, nX, nY, HumanRcd, NewHeroDataInfo, nType);
    nCode := 22;
    if MonObj <> nil then begin
      nCode := 3;
      MonObj.m_Master := Self;
      MonObj.m_dwMasterRoyaltyTick := {GetTickCount +} 1000000 {1000 * 1000};
      MonObj.m_dwMasterRoyaltyTime := GetTickCount; //20080813 增加
      MonObj.m_btSlaveMakeLevel := Self.m_Abil.Level;
      MonObj.m_btSlaveExpLevel := Self.m_Abil.nMaxExp;
      nCode := 4;
      //if MonObj.m_Abil.Level > g_Config.nLimitExpLevelHero then MonObj.m_Abil.Level := g_Config.nLimitExpLevelHero;//20100202 防止超过限制等级
      MonObj.RecalcAbilitys;
      nCode := 5;
      MonObj.CompareSuitItem(False); //200080729 套装
      if MonObj.m_WAbil.HP <= 0 then MonObj.m_WAbil.HP := (MonObj.m_WAbil.MaxHP div 15) + 2; //20080509 增加
      nCode := 6;
      MonObj.RefNameColor; //刷新名字颜色
      nCode := 7;
      if MonObj.m_Master <> nil then begin //修正面对墙壁，障碍物，召唤英雄时，英雄会离主人很远，如超过4格，则飞到主人身旁 20090115
        nCode := 8;
        if (abs(MonObj.m_nCurrX - MonObj.m_Master.m_nCurrX) > 4) or (abs(MonObj.m_nCurrY - MonObj.m_Master.m_nCurrY) > 4) then begin
          nCode := 9;
          MonObj.SpaceMove(MonObj.m_Master.m_PEnvir.sMapName, MonObj.m_Master.m_nCurrX, MonObj.m_Master.m_nCurrY, 1);
        end;
      end;
    end;
    Result := MonObj;
  except
    MainOutMessage(Format('{%s} TPlayObject.MakeHero Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

//召唤英雄

procedure TPlayObject.ClientRecallHero();
var
  UserOpenInfo: pTUserOpenInfo;
begin
  if m_boWaitHeroDate or m_boDeath or m_boGhost then Exit;//20081022 死亡不能再召唤英雄
  if not m_boCallHero then Exit;//不能召唤英雄 20080124
  if m_boShop then begin//开启个人商店时不能召唤英雄 20100704
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropItemMsg);
    Exit;
  end;
  if m_MyHero <> nil then begin
    if m_MyHero.m_boDeath or m_MyHero.m_boGhost then m_MyHero := nil;
  end;
  m_boHeroLogOut:= False;//英雄退出 20080909
  m_boCallDeputyHero:= False;
  if m_MyHero <> nil then begin
    case THeroObject(m_MyHero).n_HeroTpye of //20091102
      0: SendUpdateMsg(Self, RM_RECALLHERO, 0, Integer(m_MyHero), 0, 0, '白');
      1: SendUpdateMsg(Self, RM_RECALLHERO, 0, Integer(m_MyHero), 0, 0, '卧');
      2: SendUpdateMsg(Self, RM_RECALLHERO, 0, Integer(m_MyHero), 0, 0, '主');
      3: SendUpdateMsg(Self, RM_RECALLHERO, 0, Integer(m_MyHero), 0, 0, '副');
    end;
    Exit;
  end;
  if n_HeroSave <> 1 then begin//是否存英雄,1-存英雄
    if ((not m_boHasHero) or (not m_boHasHeroTwo)) and (m_sHeroCharName = '') then begin
      //SysMsg(g_sNotHero{您还没有创建英雄！！！}, c_Red, t_Hint);//20090413 注释
    end else begin
      if (GetTickCount() - m_nRecallHeroTime) >= g_Config.nRecallHeroTime then begin  //召唤英雄间隔 20071201
        m_nRecallHeroTime:=GetTickCount();//召唤英雄间隔 20071201
        if not m_boAI then begin
          FrontEngine.AddToLoadHeroRcdList(m_sHeroCharName, '', Self, 0, False, 0);
        end else begin
          New(UserOpenInfo);
          UserOpenInfo.sChrName := m_sHeroCharName;
          UserOpenInfo.LoadUser.PlayObject := Self;
          UserOpenInfo.LoadUser.btLoadDBType := 5;
          UserOpenInfo.LoadUser.boIsHero:= True;
          UserEngine.AddUserOpenInfo(UserOpenInfo);
          m_boWaitHeroDate := True;
        end;
      end else if (g_Config.nRecallHeroTime-(GetTickCount() - m_nRecallHeroTime))div 1000 > 0 then SysMsg(Format_ToStr(g_sRecallHeroHint, [(g_Config.nRecallHeroTime-(GetTickCount() - m_nRecallHeroTime))div 1000]), c_Red, t_Hint); //召唤英雄间隔 20071201
    end;
  end else begin
    if m_sHeroCharName <> '' then begin
      if (GetTickCount() - m_nRecallHeroTime) >= g_Config.nRecallHeroTime  then begin  //召唤英雄间隔 20071201
        m_nRecallHeroTime:=GetTickCount();//召唤英雄间隔 20071201
        if not m_boAI then begin
          FrontEngine.AddToLoadHeroRcdList(m_sHeroCharName, '', Self, 0, False, 0);
        end else begin
          New(UserOpenInfo);
          UserOpenInfo.sChrName := m_sHeroCharName;
          UserOpenInfo.LoadUser.PlayObject := Self;
          UserOpenInfo.LoadUser.btLoadDBType := 5;
          UserOpenInfo.LoadUser.boIsHero:= True;
          UserEngine.AddUserOpenInfo(UserOpenInfo);
          m_boWaitHeroDate := True;
        end;
      end else if (g_Config.nRecallHeroTime-(GetTickCount() - m_nRecallHeroTime))div 1000 > 0 then SysMsg(Format_ToStr(g_sRecallHeroHint, [(g_Config.nRecallHeroTime-(GetTickCount() - m_nRecallHeroTime))div 1000]), c_Red, t_Hint); //召唤英雄间隔 20071201
    end;
  end;
end;
//召唤副将英雄

procedure TPlayObject.ClientRecallDeputyHero();
begin
  if m_boWaitHeroDate or m_boDeath or m_boGhost or (not m_boCallHero) or
    ((not m_boHasHero) and (not m_boHasHeroTwo)) then Exit; //死亡不能再召唤英雄
  if m_sDeputyHeroName <> '' then begin
    if m_MyHero <> nil then Exit;
    if (GetTickCount() - m_nRecallDeputyHeroTime) >= g_Config.nRecallDeputyHeroTime then begin
      m_nRecallDeputyHeroTime := GetTickCount();
      m_boHeroLogOut := False; //英雄退出
      m_boCallDeputyHero := True; //召唤副将英雄
      FrontEngine.AddToLoadHeroRcdList(m_sDeputyHeroName, '', Self, 0, m_boCallDeputyHero, m_btDeputyHeroJob);
    end else SysMsg(Format_ToStr(g_sRecallHeroHint, [(g_Config.nRecallDeputyHeroTime - (GetTickCount() - m_nRecallDeputyHeroTime)) div 1000]), c_Red, t_Hint);
  end;
end;
//英雄退出

procedure TPlayObject.ClientHeroLogOut(nCode: Byte);
var
  FlowerEvent: TFlowerEvent;
  nCheckCode: Byte; //20090212
begin
  nCheckCode := 0;
  try
    if m_boWaitHeroDate or m_boHeroLogOut then Exit; //20090109 增加 m_boHeroLogOut
    if m_MyHero <> nil then begin
      nCheckCode := 1;
      if m_MyHero.m_TargetCret <> nil then begin //英雄攻击目标为英雄时,收回英雄,目标英雄则需要攻击主人
        nCheckCode := 2;
        if (m_MyHero.m_TargetCret.m_btRaceServer = RC_HEROOBJECT) or (m_MyHero.m_TargetCret.m_btRaceServer = RC_PLAYOBJECT) then begin //20100116 修改
          nCheckCode := 3;
          m_MyHero.m_TargetCret.SetLastHiter(self);
        end;
      end;
      nCheckCode := 7;
      m_boHeroLogOut := True; //英雄退出 20080909
      THeroObject(m_MyHero).boCallLogOut := True; //英雄正常退出
      THeroObject(m_MyHero).m_boDeath := True; //20081020
      nCheckCode := 8;
      FlowerEvent := TFlowerEvent.Create(m_MyHero.m_PEnvir, m_MyHero.m_nCurrX, m_MyHero.m_nCurrY, SM_HEROLOGOUT, 2500); //英雄退出动画显示 20080629
      FlowerEvent.m_dwRunTick := 1; //20090109 加速效果显示
      g_EventManager.AddEvent(FlowerEvent);
      nCheckCode := 9;
      UserEngine.SaveHeroRcd(Self); //保存英雄数据
      nCheckCode := 10;
      SendDelayMsg(m_MyHero, RM_MAKEGHOSTHERO, 0, 0, 0, 0, '', 1000);
      nCheckCode := 11;
      SendUpdateMsg(m_MyHero, RM_DESTROYHERO, 0, Integer(m_MyHero), 0, 0, ''); //英雄销毁,左上角图标隐藏
      if nCode = 0 then SysMsg(g_sHeroClose {神奇的力量散去，你的英雄开始沉睡。}, c_Green, t_Hint); //20080426
{$IF M2Version <> 2}
      if (m_nDecGameGirdCount > 0) and (THeroObject(m_MyHero).m_Magic99Skill <> nil) then
        SysMsg(Format('您召回了英雄，灵符自动修炼白日门强身术暂停，还剩余：%d次', [m_nDecGameGirdCount]), c_Blue, t_Hint);
{$IFEND}
      if m_sDeputyHeroName <> '' then begin
        if m_boCallDeputyHero then begin //副将英雄收回
          m_boCallDeputyHero := False;
          m_nRecallDeputyHeroTime := GetTickCount();
        end else m_nRecallHeroTime := GetTickCount(); //召唤主将英雄间隔
      end else m_nRecallHeroTime := GetTickCount(); //召唤英雄间隔
    end;
  except
    MainOutMessage(Format('{%s} TPlayObject.ClientHeroLogOut Code:%d', [g_sExceptionVer, nCheckCode]));
  end;
end;
//客户端改变英雄状态

procedure TPlayObject.ClientChgHeroStatus();
begin
  if m_boWaitHeroDate then Exit;
  if THeroObject(m_MyHero) <> nil then begin
    if THeroObject(m_MyHero).m_boProtectStatus then THeroObject(m_MyHero).m_boProtectStatus := False; //守护时,一改变状态,则停止守护 20080913
    if THeroObject(m_MyHero).m_btStatus >= 2 then THeroObject(m_MyHero).m_btStatus := 0
    else Inc(THeroObject(m_MyHero).m_btStatus);
    case THeroObject(m_MyHero).m_btStatus of
      1: begin
          if THeroObject(m_MyHero).m_TargetCret <> nil then THeroObject(m_MyHero).m_TargetCret := nil; //20080604
          THeroObject(m_MyHero).SysMsg(g_sHeroFollow, C_HeroHint, t_Hint); //20080316
        end;
      0: begin
          THeroObject(m_MyHero).SysMsg(g_sHeroAttack, C_HeroHint, t_Hint); //20080316
        end;
      2: begin
          if THeroObject(m_MyHero).m_TargetCret <> nil then THeroObject(m_MyHero).m_TargetCret := nil; //20080604
          THeroObject(m_MyHero).SysMsg(g_sHeroRest, C_HeroHint, t_Hint); //20080316
        end;
    end;
  end;
end;
//英雄守护

procedure TPlayObject.ClientHeroProtect(nX, nY: Integer);
begin
  if m_boWaitHeroDate then Exit;
  if THeroObject(m_MyHero) <> nil then begin
    if (g_Config.boNoSafeProtect and InSafeZone) or (g_Config.boNoSafeProtect and InSafeZone(m_PEnvir, nX, nY)) then begin //20080603 增加英雄安全区内不能守护 20090602
      SysMsg('(英雄) 不能在安全区内守护！', c_Red, t_Hint);
      Exit;
    end;
    if m_PEnvir.m_boNOHEROPROTECT then begin
      SysMsg('(英雄) 地图禁止守护！', c_Red, t_Hint);
      Exit; //地图禁止守护 20080629
    end;
    if not m_PEnvir.CanWalk(nX, nY, False) then begin //20090602 增加
      SysMsg('(英雄) 守护位置不可到达！', c_Red, t_Hint);
      Exit;
    end;
    if g_Config.nHeroProtectLevel > THeroObject(m_MyHero).m_Abil.Level then begin
      SysMsg(Format('(英雄) 等级未达到%d级,不能守护！', [g_Config.nHeroProtectLevel]), c_Red, t_Hint);
      Exit;
    end;
    THeroObject(m_MyHero).m_boProtectStatus := not THeroObject(m_MyHero).m_boProtectStatus;
    if THeroObject(m_MyHero).m_boProtectStatus then begin
      THeroObject(m_MyHero).m_boProtectOK := False; //20080603
      THeroObject(m_MyHero).m_nProtectTargetX := nX;
      THeroObject(m_MyHero).m_nProtectTargetY := nY;
      THeroObject(m_MyHero).m_dwHitTick := GetTickCount(); //20090427 初始攻击计时，防止切换后，英雄攻击加速
      THeroObject(m_MyHero).SysMsg(Format_ToStr(g_sHeroProtect {'英雄:开始守护(%d/%d)'}, [nX, nY]), BB_Fuchsia, t_Hint) //20080316
    end else begin
      THeroObject(m_MyHero).m_boProtectOK := False; //20080603
      THeroObject(m_MyHero).m_nProtectTargetX := -1;
      THeroObject(m_MyHero).m_nProtectTargetY := -1;
      THeroObject(m_MyHero).m_dwHitTick := GetTickCount(); //20090427 初时攻击计时，防止切换后，英雄攻击加速
      THeroObject(m_MyHero).SysMsg(Format_ToStr(g_sHeroNotProtect {'英雄:停止守护(%d/%d)'}, [nX, nY]), BB_Fuchsia, t_Hint); //20080316
    end;
  end;
end;
//锁定攻击目标

procedure TPlayObject.ClientHeroAttack(BaseObject: TBaseObject; nX, nY: Integer);
var
  nOldX, nOldY: Integer;
  nCode: Byte; //20100109
begin
  nCode := 0;
  try
    if GetTickCount - m_TargetTime > 1500 then begin //20080615 锁定目标间隔
      if m_boWaitHeroDate then Exit;
      nCode := 1;
      if THeroObject(m_MyHero) <> nil then begin
        nCode := 2;
        if CretInNearXY(BaseObject, nX, nY) and (not THeroObject(m_MyHero).m_boDeath) then begin //20081020 修改
          if (BaseObject <> Self) and (BaseObject <> m_MyHero) and (not BaseObject.m_boDeath) then begin //20080415 加入,怪死后不能再锁定
            if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC) then begin
              if (BaseObject.m_btRaceServer <> 110) and (BaseObject.m_btRaceServer <> 111) then begin
                //if (BaseObject.m_btRaceServer = RC_PLAYMOSTER) and (BaseObject.m_Master <> nil) then Exit;//分身不能锁定 20090904
                nCode := 3;
                if IsProperTarget(BaseObject) then begin
                  m_TargetTime := GetTickCount(); //20080615 锁定目标间隔
                  //自动切换英雄状态 20080129
                  if THeroObject(m_MyHero).m_boProtectStatus then THeroObject(m_MyHero).m_boProtectStatus := False; //守护时,锁定则停止守护 20081020
                  if (not m_PEnvir.m_boMISSION) and (THeroObject(m_MyHero).m_btStatus <> 0) then begin
                    THeroObject(m_MyHero).m_btStatus := 0;
                    THeroObject(m_MyHero).SysMsg(g_sHeroAttack {(英雄)状态：攻击}, C_HeroHint, t_Hint);
                  end;
                  if (not THeroObject(m_MyHero).m_boDeath) then begin //在同个地图时才传送到主人身边 20090808
                    if (m_PEnvir <> THeroObject(m_MyHero).m_PEnvir) or
                      ((abs(THeroObject(m_MyHero).m_nCurrX - m_nCurrX) > 15) or (abs(THeroObject(m_MyHero).m_nCurrY - m_nCurrY) > 15)) then begin
                      GetBackPosition(nOldX, nOldY);
                      THeroObject(m_MyHero).SpaceMove(m_PEnvir.sMapName, nOldX, nOldY, 1);
                    end;
                  end;
                  nCode := 4;
                  if g_Config.boUnKnowHum and BaseObject.IsUsesZhuLi then //20080424 带上斗笠,不显示人的真正名字
                    SysMsg('攻击目标: 神秘人', c_Red, t_Hint)
                  else begin
                    if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
                      SysMsg(Format('攻击目标: %s', [BaseObject.m_sCharName]), c_Red, t_Hint); //20080522
                    end else
                      if (BaseObject.m_btRaceServer = RC_HEROOBJECT) and (BaseObject.m_Master <> nil) then
                        SysMsg(Format('攻击目标: %s 的英雄: %s', [BaseObject.m_Master.m_sCharName, BaseObject.m_sCharName]), c_Red, t_Hint) //20110530 修改
                      else SysMsg(Format('攻击目标: %s', [FilterShowName(BaseObject.m_sCharName)]), c_Red, t_Hint); //20080421
                  end;
                  nCode := 5;
                  THeroObject(m_MyHero).m_boTarget := True;
                  THeroObject(m_MyHero).SetTargetXY(BaseObject.m_nCurrX, BaseObject.m_nCurrY);
                  THeroObject(m_MyHero).SetTargetCreat(BaseObject); //20080327
                  SetTargetCreat(BaseObject);
                  nCode := 6;
                  if (THeroObject(m_MyHero).m_btJob = 0) then begin //20080716
                    if (abs(m_MyHero.m_nCurrX - THeroObject(m_MyHero).m_nTargetX) > 1) or (abs(m_MyHero.m_nCurrY - THeroObject(m_MyHero).m_nTargetY) > 1) then begin
                      if THeroObject(m_MyHero).IsAllowUseMagic(12) or THeroObject(m_MyHero).IsAllowUseMagic(SKILL_89) then begin
                        THeroObject(m_MyHero).GetGotoXY(THeroObject(m_MyHero).m_TargetCret, 2); //20090213 修改
                        THeroObject(m_MyHero).RunToTargetXY(THeroObject(m_MyHero).m_nTargetX, THeroObject(m_MyHero).m_nTargetY);
                      end else THeroObject(m_MyHero).RunToTargetXY(THeroObject(m_MyHero).m_nTargetX, THeroObject(m_MyHero).m_nTargetY);
                    end;
                  {end else begin//20110425 注释
                    if (abs(m_MyHero.m_nCurrX - THeroObject(m_MyHero).m_nTargetX) > 3) or (abs(m_MyHero.m_nCurrY - THeroObject(m_MyHero).m_nTargetY) > 3) then begin
                      THeroObject(m_MyHero).GetGotoXY(THeroObject(m_MyHero).m_TargetCret,3);//道法只走向目标3格范围
                      THeroObject(m_MyHero).RunToTargetXY(THeroObject(m_MyHero).m_nTargetX, THeroObject(m_MyHero).m_nTargetY);
                    end; }
                  end;
                  nCode := 7;
                  if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or
                    (BaseObject.m_btRaceServer = RC_HEROOBJECT) then begin
                    BaseObject.SetPKFlag(self); //设置主人灰名 20081020
                    BaseObject.SetPKFlag(m_MyHero); //设置英雄灰名 20081020
                  end;
                  nCode := 8;
                  if THeroObject(m_MyHero).m_boDecDragonPoint then ClientHeroUseSpell; //减怒气时,直接放合击 20080726
                  Exit;
                end;
              end;
            end;
          end;
        end;
        nCode := 9;
        THeroObject(m_MyHero).m_TargetCret := nil;
        THeroObject(m_MyHero).m_boTarget := False;
      end;
    end;
  except
    MainOutMessage(Format('{%s} TPlayObject.ClientHeroAttack Code:%d', [g_sExceptionVer, nCode]));
  end;
end;
//客户端评定主将英雄

procedure TPlayObject.ClientAssessmentMainHero(sHeroName {英雄名}: string; nHeroLevel1 {英雄等级1}, nHeroLevel2 {英雄等级2}: Word);
var
  sHeroName1, sHeroName2: string;
begin
  try
    if m_boHasHero and m_boHasHeroTwo and (m_sHeroCharName = '') and (m_sDeputyHeroName = '') and (n_HeroSave = 1) and (sHeroName <> '') then begin
      if (nHeroLevel1 > 0) and (nHeroLevel2 > 0) then begin
        sHeroName2 := GetValidStr3(sHeroName, sHeroName1, ['/', #9]);
        if (nHeroLevel1 = nHeroLevel2) or (sHeroName1 = '') or (sHeroName2 = '') then begin //等级一样，不能评定
          SendDefMessage(SM_ASSESSMENTHERO_FAIL, 0, 0, 0, 0, ''); //评定失败
          Exit;
        end;
        if nHeroLevel1 > nHeroLevel2 then begin
          m_sHeroCharName := sHeroName1; //主将英雄名字
          m_sDeputyHeroName := sHeroName2; //副将英雄名字
        end else begin
          m_sHeroCharName := sHeroName2; //主将英雄名字
          m_sDeputyHeroName := sHeroName1; //副将英雄名字
        end;
        if m_sDeputyHeroName <> '' then begin //评定成功
          n_HeroSave := 2;
          m_HeroAutoPracticeTime := 0; //自动修炼累计时长
          SendDefMessage(SM_ASSESSMENTHERO_OK, 0, 0, 0, m_btDeputyHeroJob, ''); //评定成功
          Inc(m_nSendMsgCount, 3);
        end;
      end else SendDefMessage(SM_ASSESSMENTHERO_FAIL, 0, 0, 0, 0, ''); //评定失败
    end;
  except
    MainOutMessage(Format('{%s} TPlayObject.ClientAssessmentMainHero', [g_sExceptionVer]));
  end;
end;
//英雄自我修炼

procedure TPlayObject.ClientHeroAutoPractice(nPlace {场所}, nStrength {强度}: Byte);
begin
  if m_boWaitHeroDate then Exit;
  if m_boHasHero and m_boHasHeroTwo and (m_sDeputyHeroName <> '') and m_boCallDeputyHero
    and (not m_MyHero.m_boDeath) and (not m_MyHero.m_boGhost) and (not m_boDeath)
    and (not m_boGhost) and (not m_boHeroAutoPractice) and (nPlace < 3) and (nStrength < 3) then begin
    m_boHeroAutoPractice := True; //副将英雄是否自动修炼
    m_nHeroAutoPracticePlace := nPlace; //自动修炼修炼场所
    m_nHeroAutoPracticeStrength := nStrength; //自动修炼修炼强度
    SendDefMessage(SM_HEROAUTOPRACTICE_OK, 0, 0, 0, 0, '');
    SysMsg('英雄放养开始，如您再召唤出您的副将英雄后将自动停止！', c_Blue, t_Hint);
    ClientHeroLogOut(1); //英雄退出
  end;
end;
//开始合击(去掉英雄守护不能合击 20080602)

procedure TPlayObject.ClientHeroUseSpell;
var
  TogetherMagic: pTUserMagic;
begin
  try
    if m_boWaitHeroDate then Exit;
    if (not m_MyHero.m_boDeath) and (not m_MyHero.m_boGhost) and (not m_boDeath) and (not m_boGhost) then begin
      if (THeroObject(m_MyHero).m_btStatus <> 2) and (m_MyHero.m_PEnvir = m_PEnvir) and
        (abs(m_MyHero.m_nCurrX - m_nCurrX) <= 13) and (abs(m_MyHero.m_nCurrY - m_nCurrY) <= 13)
        and (THeroObject(m_MyHero).WearFirDragon) then begin //20080707 戴火龙之心才能放合击
{$IF M2Version = 1}
        if m_boUseBatter then begin //合击打断连击
          m_nUseBatterTick := GetTickCount(); //使用连击的计时
          m_nUseBatterTime := 0;
          m_nBatterMagIdx1 := 0; //连击技能ID1 20090701
          m_nBatterMagIdx2 := 0; //连击技能ID2 20090701
          m_nBatterMagIdx3 := 0; //连击技能ID3 20090701
          m_nBatterMagIdx4 := 0; //连击技能ID4 20100719
          if (m_btJob = 0) then begin
            SendSocket(nil, '+UBAT');
            m_boUseBatter := False;
            m_boWarUseBatter := False;
            m_dwLatestWarUseBatterTick := GetTickCount();
          end;
        end;
        if THeroObject(m_MyHero).m_boUseBatter then THeroObject(m_MyHero).HeroBatterStop; //英雄连击停止 20091116 修改
{$IFEND}
        if THeroObject(m_MyHero).m_boTarget then begin //锁定目标
          if (m_MyHero.m_TargetCret <> nil) and (abs(m_MyHero.m_TargetCret.m_nCurrX - m_nCurrX) <= 13) and (abs(m_MyHero.m_TargetCret.m_nCurrY - m_nCurrY) <= 13) then begin
            if (THeroObject(m_MyHero).m_nFirDragonPoint >= g_Config.nMaxFirDragonPoint) or (THeroObject(m_MyHero).m_boDecDragonPoint) then begin //气槽满
              TogetherMagic := THeroObject(m_MyHero).FindTogetherMagic;
              if TogetherMagic <> nil then begin
                case TogetherMagic.wMagIdx of
                  SKILL_60: begin //破魂斩 20080419
                      if (m_MyHero.m_TargetCret <> nil) then begin
                        SetTargetCreat(m_MyHero.m_TargetCret); //20081207 修改
                      end;
                      if (((m_wStatusTimeArr[POISON_STONE] <> 0) or (THeroObject(m_MyHero).m_wStatusTimeArr[POISON_STONE] <> 0))
                        and (not g_ClientConf.boParalyCanSpell)) or (m_wStatusTimeArr[POISON_LOCKSPELL {7}] <> 0) or (m_wStatusArrValue[23] <> 0)
                        or (m_MyHero.m_wStatusTimeArr[POISON_LOCKSPELL {7}] <> 0) or (m_MyHero.m_wStatusArrValue[23] <> 0) then begin //20080913 麻痹不能合击
                        THeroObject(m_MyHero).m_boDecDragonPoint := True; //开始减怒气
                        Exit;
                      end;
                      //20090105修改，直线才放破魂斩
                      if not ((((abs(m_TargetCret.m_nCurrX - m_MyHero.m_nCurrX) = 1) and (abs(m_TargetCret.m_nCurrY - m_MyHero.m_nCurrY) = 0)) or
                        ((abs(m_TargetCret.m_nCurrX - m_MyHero.m_nCurrX) = 1) and (abs(m_TargetCret.m_nCurrY - m_MyHero.m_nCurrY) = 1)) or
                        ((abs(m_TargetCret.m_nCurrX - m_MyHero.m_nCurrX) = 2) and (abs(m_TargetCret.m_nCurrY - m_MyHero.m_nCurrY) = 2)) or
                        ((abs(m_TargetCret.m_nCurrX - m_MyHero.m_nCurrX) = 2) and (abs(m_TargetCret.m_nCurrY - m_MyHero.m_nCurrY) = 0)) or
                        ((abs(m_TargetCret.m_nCurrX - m_MyHero.m_nCurrX) = 0) and (abs(m_TargetCret.m_nCurrY - m_MyHero.m_nCurrY) = 1)) or
                        ((abs(m_TargetCret.m_nCurrX - m_MyHero.m_nCurrX) = 0) and (abs(m_TargetCret.m_nCurrY - m_MyHero.m_nCurrY) = 2)) or

                        ((TogetherMagic.btLevel = 4) and (abs(m_TargetCret.m_nCurrX - m_MyHero.m_nCurrX) = 3) and (abs(m_TargetCret.m_nCurrY - m_MyHero.m_nCurrY) = 3)) or //20100719 四级破魂斩3格可放
                        ((TogetherMagic.btLevel = 4) and (abs(m_TargetCret.m_nCurrX - m_MyHero.m_nCurrX) = 3) and (abs(m_TargetCret.m_nCurrY - m_MyHero.m_nCurrY) = 0)) or
                        ((TogetherMagic.btLevel = 4) and (abs(m_TargetCret.m_nCurrX - m_MyHero.m_nCurrX) = 0) and (abs(m_TargetCret.m_nCurrY - m_MyHero.m_nCurrY) = 3))
                        )) then begin
                        THeroObject(m_MyHero).m_boDecDragonPoint := True; //20080418 开始减怒气
                        THeroObject(m_MyHero).GotoTargetXY(m_MyHero.m_TargetCret.m_nCurrX, m_MyHero.m_TargetCret.m_nCurrY, 1); //英雄走向目标 20080419
                        Exit;
                      end else
                        if not ((((abs(m_TargetCret.m_nCurrX - m_nCurrX) = 1) and (abs(m_TargetCret.m_nCurrY - m_nCurrY) = 0)) or
                          ((abs(m_TargetCret.m_nCurrX - m_nCurrX) = 1) and (abs(m_TargetCret.m_nCurrY - m_nCurrY) = 1)) or
                          ((abs(m_TargetCret.m_nCurrX - m_nCurrX) = 2) and (abs(m_TargetCret.m_nCurrY - m_nCurrY) = 2)) or
                          ((abs(m_TargetCret.m_nCurrX - m_nCurrX) = 2) and (abs(m_TargetCret.m_nCurrY - m_nCurrY) = 0)) or
                          ((abs(m_TargetCret.m_nCurrX - m_nCurrX) = 0) and (abs(m_TargetCret.m_nCurrY - m_nCurrY) = 1)) or
                          ((abs(m_TargetCret.m_nCurrX - m_nCurrX) = 0) and (abs(m_TargetCret.m_nCurrY - m_nCurrY) = 2)) or

                          ((TogetherMagic.btLevel = 4) and (abs(m_TargetCret.m_nCurrX - m_nCurrX) = 3) and (abs(m_TargetCret.m_nCurrY - m_nCurrY) = 3)) or //20100719 四级破魂斩3格可放
                          ((TogetherMagic.btLevel = 4) and (abs(m_TargetCret.m_nCurrX - m_nCurrX) = 3) and (abs(m_TargetCret.m_nCurrY - m_nCurrY) = 0)) or
                          ((TogetherMagic.btLevel = 4) and (abs(m_TargetCret.m_nCurrX - m_nCurrX) = 0) and (abs(m_TargetCret.m_nCurrY - m_nCurrY) = 3))
                          )) then begin
                          THeroObject(m_MyHero).m_boDecDragonPoint := True; //20080418 开始减怒气
                          Exit;
                        end;
                    end;
                  SKILL_61, SKILL_62: begin //劈星斩,雷霆一击(近攻合击,战要近目标) 20080415
                      if (m_MyHero.m_TargetCret <> nil) then begin
                        SetTargetCreat(m_MyHero.m_TargetCret); //20081207 修改
                      end;
                      if (((m_wStatusTimeArr[POISON_STONE] <> 0) or (m_MyHero.m_wStatusTimeArr[POISON_STONE] <> 0))
                        and (not g_ClientConf.boParalyCanSpell)) or (m_wStatusTimeArr[POISON_LOCKSPELL {7}] <> 0) or (m_wStatusArrValue[23] <> 0)
                        or (m_MyHero.m_wStatusTimeArr[POISON_LOCKSPELL {7}] <> 0) or (m_MyHero.m_wStatusArrValue[23] <> 0) then begin //20080913 麻痹不能合击
                        THeroObject(m_MyHero).m_boDecDragonPoint := True; //开始减怒气
                        Exit;
                      end;
                      if (m_btJob = 0) and ((abs(m_MyHero.m_TargetCret.m_nCurrX - m_nCurrX) > 2) or (abs(m_MyHero.m_TargetCret.m_nCurrY - m_nCurrY) > 2)) then begin
                        THeroObject(m_MyHero).m_boDecDragonPoint := True; //20080418 开始减怒气
                        Exit;
                      end else
                        if (THeroObject(m_MyHero).m_btJob = 0) and ((abs(m_MyHero.m_TargetCret.m_nCurrX - m_MyHero.m_nCurrX) > 2) or (abs(m_MyHero.m_TargetCret.m_nCurrY - m_MyHero.m_nCurrY) > 2)) then begin
                          THeroObject(m_MyHero).m_boDecDragonPoint := True; //20080418 开始减怒气
                          THeroObject(m_MyHero).GotoTargetXY(m_MyHero.m_TargetCret.m_nCurrX, m_MyHero.m_TargetCret.m_nCurrY, 1); //英雄走向目标 20080419
                          Exit;
                        end;
                    end;
                  SKILL_63, SKILL_64, SKILL_65: begin
                      if (((m_wStatusTimeArr[POISON_STONE] <> 0) or (m_MyHero.m_wStatusTimeArr[POISON_STONE] <> 0))
                        and (not g_ClientConf.boParalyCanSpell)) or (m_wStatusTimeArr[POISON_LOCKSPELL {7}] <> 0) or (m_wStatusArrValue[23] <> 0)
                        or (m_MyHero.m_wStatusTimeArr[POISON_LOCKSPELL {7}] <> 0) or (m_MyHero.m_wStatusArrValue[23] <> 0) then begin //20080913 麻痹不能合击
                        THeroObject(m_MyHero).m_boDecDragonPoint := True; //开始减怒气
                        Exit;
                      end;
                    end;
                end;
                THeroObject(m_MyHero).m_boStartUseSpell := True;
                THeroObject(m_MyHero).m_boDecDragonPoint := False; //20080418 停止减怒气
                THeroObject(m_MyHero).m_nFirDragonPoint := 0; //清空怒气值
                THeroObject(m_MyHero).m_dwStartUseSpellTick := GetTickCount();

                THeroObject(m_MyHero).m_dwHitTick := GetTickCount(); //20081221 直接进入魔法过程,以加速合击速度
                if THeroObject(m_MyHero).ClientSpellXY(TogetherMagic, m_MyHero.m_TargetCret.m_nCurrX, m_MyHero.m_TargetCret.m_nCurrY, m_MyHero.m_TargetCret) then begin
                  THeroObject(m_MyHero).m_boStartUseSpell := False;
                end;
              end;
            end;
          end;
        end else begin //没有锁定目标,则攻击当前目标,
          if m_TargetCret <> nil then begin
            m_MyHero.m_TargetCret := m_TargetCret; // 20071227 释放合击时,如果英雄目标为空,则默认攻击主人的目标
          end else
            if (m_MyHero.m_TargetCret <> nil) then begin
              SetTargetCreat(m_MyHero.m_TargetCret); //20081207 修改
            end;
          //if (m_TargetCret = nil) and (m_MyHero.m_TargetCret <> nil) then m_TargetCret:= m_MyHero.m_TargetCret;
          if (m_MyHero.m_TargetCret <> nil) and (abs(m_MyHero.m_TargetCret.m_nCurrX - m_nCurrX) <= 13) and (abs(m_MyHero.m_TargetCret.m_nCurrY - m_nCurrY) <= 13) then begin
            if (THeroObject(m_MyHero).m_nFirDragonPoint >= g_Config.nMaxFirDragonPoint) or (THeroObject(m_MyHero).m_boDecDragonPoint) then begin
              TogetherMagic := THeroObject(m_MyHero).FindTogetherMagic;
              if TogetherMagic <> nil then begin
                case TogetherMagic.wMagIdx of
                  SKILL_60: begin //破魂斩 20080419
                      if m_TargetCret <> nil then begin
                        if m_MyHero <> m_TargetCret then m_MyHero.SetTargetCreat(m_TargetCret) //20090311 修改
                        else Exit;
                      end else
                        if (m_MyHero.m_TargetCret <> nil) then begin
                          SetTargetCreat(m_MyHero.m_TargetCret); //20081207 修改
                        end;
                      if (((m_wStatusTimeArr[POISON_STONE] <> 0) or (m_MyHero.m_wStatusTimeArr[POISON_STONE] <> 0))
                        and (not g_ClientConf.boParalyCanSpell)) or (m_wStatusTimeArr[POISON_LOCKSPELL {7}] <> 0) or (m_wStatusArrValue[23] <> 0)
                        or (m_MyHero.m_wStatusTimeArr[POISON_LOCKSPELL {7}] <> 0) or (m_MyHero.m_wStatusArrValue[23] <> 0) then begin //20080913 麻痹不能合击
                        THeroObject(m_MyHero).m_boDecDragonPoint := True; //开始减怒气
                        Exit;
                      end;
                      //20090105修改，直线才放破魂斩
                      if not ((((abs(m_TargetCret.m_nCurrX - m_MyHero.m_nCurrX) = 2) and (abs(m_TargetCret.m_nCurrY - m_MyHero.m_nCurrY) = 0)) or
                        ((abs(m_TargetCret.m_nCurrX - m_MyHero.m_nCurrX) = 1) and (abs(m_TargetCret.m_nCurrY - m_MyHero.m_nCurrY) = 0)) or
                        ((abs(m_TargetCret.m_nCurrX - m_MyHero.m_nCurrX) = 1) and (abs(m_TargetCret.m_nCurrY - m_MyHero.m_nCurrY) = 1)) or
                        ((abs(m_TargetCret.m_nCurrX - m_MyHero.m_nCurrX) = 2) and (abs(m_TargetCret.m_nCurrY - m_MyHero.m_nCurrY) = 2)) or
                        ((abs(m_TargetCret.m_nCurrX - m_MyHero.m_nCurrX) = 0) and (abs(m_TargetCret.m_nCurrY - m_MyHero.m_nCurrY) = 1)) or
                        ((abs(m_TargetCret.m_nCurrX - m_MyHero.m_nCurrX) = 0) and (abs(m_TargetCret.m_nCurrY - m_MyHero.m_nCurrY) = 2)))) then begin
                        THeroObject(m_MyHero).m_boDecDragonPoint := True; //20080418 开始减怒气
                        THeroObject(m_MyHero).GotoTargetXY(m_MyHero.m_TargetCret.m_nCurrX, m_MyHero.m_TargetCret.m_nCurrY, 1); //英雄走向目标 20080419
                        Exit;
                      end else
                        if not ((((abs(m_TargetCret.m_nCurrX - m_nCurrX) = 2) and (abs(m_TargetCret.m_nCurrY - m_nCurrY) = 0)) or
                          ((abs(m_TargetCret.m_nCurrX - m_nCurrX) = 1) and (abs(m_TargetCret.m_nCurrY - m_nCurrY) = 0)) or
                          ((abs(m_TargetCret.m_nCurrX - m_nCurrX) = 1) and (abs(m_TargetCret.m_nCurrY - m_nCurrY) = 1)) or
                          ((abs(m_TargetCret.m_nCurrX - m_nCurrX) = 2) and (abs(m_TargetCret.m_nCurrY - m_nCurrY) = 2)) or
                          ((abs(m_TargetCret.m_nCurrX - m_nCurrX) = 0) and (abs(m_TargetCret.m_nCurrY - m_nCurrY) = 1)) or
                          ((abs(m_TargetCret.m_nCurrX - m_nCurrX) = 0) and (abs(m_TargetCret.m_nCurrY - m_nCurrY) = 2)))) then begin
                          THeroObject(m_MyHero).m_boDecDragonPoint := True; //20080418 开始减怒气
                          Exit;
                        end;
                    end;
                  SKILL_61, SKILL_62: begin //劈星斩,雷霆一击(近攻合击,战要近目标) 20080415
                      if m_TargetCret <> nil then begin
                        if m_MyHero <> m_TargetCret then m_MyHero.SetTargetCreat(m_TargetCret) //20090311 修改
                        else Exit;
                      end else
                        if (m_MyHero.m_TargetCret <> nil) then begin
                          SetTargetCreat(m_MyHero.m_TargetCret); //20081207 修改
                        end;
                      if (((m_wStatusTimeArr[POISON_STONE] <> 0) or (m_MyHero.m_wStatusTimeArr[POISON_STONE] <> 0))
                        and (not g_ClientConf.boParalyCanSpell)) or (m_wStatusTimeArr[POISON_LOCKSPELL {7}] <> 0) or (m_wStatusArrValue[23] <> 0)
                        or (m_MyHero.m_wStatusTimeArr[POISON_LOCKSPELL {7}] <> 0) or (m_MyHero.m_wStatusArrValue[23] <> 0) then begin //20080913 麻痹不能合击
                        THeroObject(m_MyHero).m_boDecDragonPoint := True; //开始减怒气
                        Exit;
                      end;
                      if (m_btJob = 0) and ((abs(m_TargetCret.m_nCurrX - m_nCurrX) > 1) or (abs(m_TargetCret.m_nCurrY - m_nCurrY) > 1)) then begin
                        THeroObject(m_MyHero).m_boDecDragonPoint := True; //20080418 开始减怒气
                        Exit;
                      end else
                        if (THeroObject(m_MyHero).m_btJob = 0) and ((abs(m_TargetCret.m_nCurrX - m_MyHero.m_nCurrX) > 2) or (abs(m_TargetCret.m_nCurrY - m_MyHero.m_nCurrY) > 2)) then begin
                          THeroObject(m_MyHero).m_boDecDragonPoint := True; //20080418 开始减怒气
                          THeroObject(m_MyHero).GotoTargetXY(m_MyHero.m_TargetCret.m_nCurrX, m_MyHero.m_TargetCret.m_nCurrY, 1); //英雄走向目标 20080419
                          Exit;
                        end;
                    end;
                  SKILL_63, SKILL_64, SKILL_65: begin
                      if (((m_wStatusTimeArr[POISON_STONE] <> 0) or (m_MyHero.m_wStatusTimeArr[POISON_STONE] <> 0))
                        and (not g_ClientConf.boParalyCanSpell)) or (m_wStatusTimeArr[POISON_LOCKSPELL {7}] <> 0) or (m_wStatusArrValue[23] <> 0)
                        or (m_MyHero.m_wStatusTimeArr[POISON_LOCKSPELL {7}] <> 0) or (m_MyHero.m_wStatusArrValue[23] <> 0) then begin //20080913 麻痹不能合击
                        THeroObject(m_MyHero).m_boDecDragonPoint := True; //开始减怒气
                        Exit;
                      end;
                    end;
                end;
                THeroObject(m_MyHero).m_boStartUseSpell := True;
                THeroObject(m_MyHero).m_boDecDragonPoint := False; //20080418 停止减怒气
                THeroObject(m_MyHero).m_nFirDragonPoint := 0; //清空怒气值
                THeroObject(m_MyHero).m_dwStartUseSpellTick := GetTickCount();

                THeroObject(m_MyHero).m_dwHitTick := GetTickCount(); //20081221 直接进入魔法过程,以加速合击速度
                if THeroObject(m_MyHero).ClientSpellXY(TogetherMagic, m_MyHero.m_TargetCret.m_nCurrX, m_MyHero.m_TargetCret.m_nCurrY, m_MyHero.m_TargetCret) then begin
                  THeroObject(m_MyHero).m_boStartUseSpell := False;
                end;
              end;
            end; //20080803 怒气值满时,才可以减怒气
          end else if (THeroObject(m_MyHero).m_nFirDragonPoint >= g_Config.nMaxFirDragonPoint) then THeroObject(m_MyHero).m_boDecDragonPoint := True; //没有目标也,开始减怒气  20080525
        end;
      end;
    end;
  except
  end;
end;

//从装备栏取装备放到包裹里

procedure TPlayObject.ClientTakeOnItemsFormBag(nIndex: Integer; btWhere: Byte; nItemIdx: Integer; sItemName: string);
var
  I, n14, n18: Integer;
  UserItem, TakeOffItem: pTUserItem;
  StdItem, StdItem20: pTStdItem;
  StdItem58: TStdItem;
  sUserItemName: string;
  feature: TFeatures;
label FailExit;
begin
  StdItem := nil;
  UserItem := nil;
  n14 := -1;
  n18 := -1; //20080522
  if (m_MyHero = nil) or m_boWaitHeroDate then begin
    goto FailExit;
  end;

  case nIndex of
    CM_HEROTAKEONITEMFORMMASTERBAG: begin
        if m_ItemList.Count > 0 then begin //20080628
          for I := 0 to m_ItemList.Count - 1 do begin
            UserItem := m_ItemList.Items[I];
            if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then begin
            //取自定义物品名称
              sUserItemName := '';
              if UserItem.btValue[13] = 1 then
                sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
              if sUserItemName = '' then
                sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem <> nil then begin
                if CompareText(sUserItemName, sItemName) = 0 then begin
                  n14 := I;
                  Break;
                end;
              end;
            end;
            UserItem := nil;
          end;
          n18 := 0;
          if (StdItem <> nil) and (UserItem <> nil) then begin
            if CheckUserItems(btWhere, StdItem) then begin
              StdItem58 := StdItem^;
              ItemUnit.GetItemAddValue(UserItem, StdItem58);
              if THeroObject(m_MyHero).CheckTakeOnItems(btWhere, StdItem58) then begin
                TakeOffItem := nil;
                if btWhere in [0..14] then begin //20080417 支持斗笠,0..12改0..13
                  if THeroObject(m_MyHero).m_UseItems[btWhere].wIndex > 0 then begin
                    StdItem20 := UserEngine.GetStdItem(THeroObject(m_MyHero).m_UseItems[btWhere].wIndex);
                    if (StdItem20 <> nil) and
                      (StdItem20.StdMode in [15, 19..24, 26..29]) then begin //20100513 20100628 增加29分类(敏捷幸运型项链)
                      if (not m_boUserUnLockDurg) and (THeroObject(m_MyHero).m_UseItems[btWhere].btValue[7] <> 0) then begin
                        THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                        n18 := -4;
                        goto FailExit;
                      end;
                    end;
                    if not m_boUserUnLockDurg and ((StdItem20.Reserved and 2) <> 0)
                      and (StdItem20.Shape <> 188) and (StdItem20.Shape <> 193) and
                      (StdItem20.Shape <> 203) then begin //吸伤物品不考虑 20090407
                      THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                      n18 := -4;
                      goto FailExit;
                    end;
                    if ((StdItem20.Reserved and 4) <> 0) and (StdItem20.Shape <> 188) and
                      (StdItem20.Shape <> 193) and (StdItem20.Shape <> 203) then begin //吸伤物品不考虑 20090407
                      THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                      n18 := -4;
                      goto FailExit;
                    end;
                    if InDisableTakeOffList(THeroObject(m_MyHero).m_UseItems[btWhere].wIndex) then begin
                      THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                      goto FailExit;
                    end;
                    New(TakeOffItem);
                    TakeOffItem^ := THeroObject(m_MyHero).m_UseItems[btWhere];
                  end; //if m_UseItems[btWhere].wIndex > 0 then begin

                  if (StdItem.StdMode in [15, 19, 20, 21, 22, 23, 24, 26, 27, 28, 29]) and //20100513  20100628 增加29分类(敏捷幸运型项链)
                    (UserItem.btValue[8] <> 0) then
                    UserItem.btValue[8] := 0;

                  THeroObject(m_MyHero).m_UseItems[btWhere] := UserItem^;
                  DelBagItem(n14);
                  if TakeOffItem <> nil then begin
                    if AddItemToBag(TakeOffItem) then begin
                      SendAddItem(TakeOffItem);
                    end else begin//修复内存泄露 By TasNat at: 2012-06-01 12:26:49
                      Dispose(TakeOffItem);
                    end;
                  end;
                  THeroObject(m_MyHero).RecalcAbilitys();
                  m_MyHero.CompareSuitItem(False); //200080729 套装
                  THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROABILITY, 0, 0, 0, 0, '');
                  THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROSUBABILITY, 0, 0, 0, 0, '');
                  THeroObject(m_MyHero).WeightChanged();
                  m_MyHero.GetFeature(feature);
                  THeroObject(m_MyHero).SendDefMessage(SM_HEROTAKEON_OK, {m_MyHero.GetFeatureToLong} 0, m_MyHero.GetFeatureEx, 0, 0, EncodeBuffer(@feature, SizeOf(feature))); //20110917 修改
                  THeroObject(m_MyHero).FeatureChanged();
                  n18 := 1;
                end;
              end else n18 := -1;
            end else n18 := -1;
          end;
        end;
      end;
    CM_TAKEONITEMFORMHEROBAG: begin //客户端没发来这消息？20090501
        if THeroObject(m_MyHero).m_ItemList.Count > 0 then begin //20080628
          for I := 0 to THeroObject(m_MyHero).m_ItemList.Count - 1 do begin
            UserItem := THeroObject(m_MyHero).m_ItemList.Items[I];
            if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then begin
            //取自定义物品名称
              sUserItemName := '';
              if UserItem.btValue[13] = 1 then
                sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
              if sUserItemName = '' then
                sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem <> nil then begin
                if CompareText(sUserItemName, sItemName) = 0 then begin
                  n14 := I;
                  Break;
                end;
              end;
            end;
            UserItem := nil;
          end;
          n18 := 0;
          if (StdItem <> nil) and (UserItem <> nil) then begin
            if CheckUserItems(btWhere, StdItem) then begin
              StdItem58 := StdItem^;
              ItemUnit.GetItemAddValue(UserItem, StdItem58);
              if CheckTakeOnItems(btWhere, StdItem58) then begin
                TakeOffItem := nil;
                if btWhere in [0..14] then begin //20080417 支持斗笠,0..12改0..13
                  if m_UseItems[btWhere].wIndex > 0 then begin
                    StdItem20 := UserEngine.GetStdItem(m_UseItems[btWhere].wIndex);
                    if (StdItem20 <> nil) and
                      (StdItem20.StdMode in [15, 19, 20, 21, 22, 23, 24, 26, 27, 28, 29]) then begin //20100513 20100628 增加29分类(敏捷幸运型项链)
                      if (not m_boUserUnLockDurg) and (THeroObject(m_MyHero).m_UseItems[btWhere].btValue[7] <> 0) then begin
                        SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                        n18 := -4;
                        goto FailExit;
                      end;
                    end;
                    if not m_boUserUnLockDurg and ((StdItem20.Reserved and 2) <> 0) and
                      (StdItem20.Shape <> 188) and (StdItem20.Shape <> 193) and (StdItem20.Shape <> 203) then begin //吸伤物品不考虑 20090407
                      SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                      n18 := -4;
                      goto FailExit;
                    end;
                    if ((StdItem20.Reserved and 4) <> 0) and (StdItem20.Shape <> 188) and
                      (StdItem20.Shape <> 193) and (StdItem20.Shape <> 203) then begin //吸伤物品不考虑 20090407
                      SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                      n18 := -4;
                      goto FailExit;
                    end;
                    if InDisableTakeOffList(THeroObject(m_MyHero).m_UseItems[btWhere].wIndex) then begin
                      SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                      goto FailExit;
                    end;
                    New(TakeOffItem);
                    TakeOffItem^ := m_UseItems[btWhere];
                  end; //004DAEC7 if m_UseItems[btWhere].wIndex > 0 then begin

                  if (StdItem.StdMode in [15, 19, 20, 21, 22, 23, 24, 26, 27, 28, 29]) and //20100513 20100628 增加29分类(敏捷幸运型项链)
                    (UserItem.btValue[8] <> 0) then
                    UserItem.btValue[8] := 0;

                  m_UseItems[btWhere] := UserItem^;
                  THeroObject(m_MyHero).DelBagItem(n14);

                  if TakeOffItem <> nil then begin
                    if THeroObject(m_MyHero).AddItemToBag(TakeOffItem) then begin
                      THeroObject(m_MyHero).SendAddItem(TakeOffItem);
                    end else //修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                      Dispose(TakeOffItem);
                  end;
                  RecalcAbilitys();
                  CompareSuitItem(False); //200080729 套装
                  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                  SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
                  GetFeature(feature);
                  SendDefMessage(SM_TAKEON_OK, {GetFeatureToLong} 0, GetFeatureEx, 0, 0, EncodeBuffer(@feature, SizeOf(feature)));
                  FeatureChanged();
                  n18 := 1;
                end;
              end else n18 := -1;
            end else n18 := -1;
          end;
        end;
      end;
  end;

  FailExit:
  case nIndex of
    CM_HEROTAKEONITEMFORMMASTERBAG: begin
        if n18 <= 0 then
          SendDefMessage(SM_TAKEON_FAIL, n18, 0, 0, 0, '');
      end;
    CM_TAKEONITEMFORMHEROBAG: begin
        if n18 <= 0 then
          SendDefMessage(SM_HEROTAKEON_FAIL, n18, 0, 0, 0, '');
      end;
  end;
end;
//英雄穿上装备

procedure TPlayObject.ClientHeroTakeOnItems(btWhere: Byte; nItemIdx: Integer; sItemName: string);
var
  I, n14, n18: Integer;
  UserItem, TakeOffItem: pTUserItem;
  StdItem, StdItem20: pTStdItem;
  StdItem58: TStdItem;
  sUserItemName: string;
  //sCheckItemName: string;
  Slave: TBaseObject; //20080806
  feature: TFeatures;
label FailExit;
begin
  StdItem := nil;
  UserItem := nil;
  n14 := -1;
  n18 := -1; //20080522
  if (m_MyHero = nil) or m_boWaitHeroDate then begin
    goto FailExit;
  end;
  if m_MyHero.m_boGhost or m_MyHero.m_boDeath then begin //20090413 增加
    goto FailExit;
  end;
  if THeroObject(m_MyHero).m_ItemList.Count > 0 then begin //20080628
    for I := 0 to THeroObject(m_MyHero).m_ItemList.Count - 1 do begin
      UserItem := THeroObject(m_MyHero).m_ItemList.Items[I];
      if (UserItem <> nil) then begin //20090413 修改
        if (UserItem.MakeIndex = nItemIdx) then begin
          //取自定义物品名称
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sUserItemName = '' then sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem <> nil then begin
            if CompareText(sUserItemName, sItemName) = 0 then begin
              n14 := I;
              Break;
            end;
          end;
        end;
      end;
      UserItem := nil;
    end;
  end;
  n18 := 0;
  if (StdItem <> nil) and (UserItem <> nil) then begin
    if (UserItem.AddValue[0] = 2) and (GetHoursCount(UserItem.MaxDate, Now) > 0) then begin //绑定期物品
      n18 := -1;
      goto FailExit;
    end;
    if CheckIsOKItem(UserItem) then begin //检查变态物品 20081007
      n18 := -1;
      goto FailExit;
    end;
    if (btWhere = 13) and (StdItem.StdMode = 16) and (StdItem.AniCount = 1) then begin //如果没有设置人物可带,则不能带上斗笠  20090331
      n18 := -1;
      goto FailExit;
    end;
    if PlugOfCheckCanItem(8, sUserItemName, False, 0, 0) then begin //禁止物品规则(禁止英雄使用) 20080729
      n18 := -1;
      goto FailExit;
    end;

    if CheckUserItems(btWhere, StdItem) then begin
      StdItem58 := StdItem^;
      ItemUnit.GetItemAddValue(UserItem, StdItem58);
      if THeroObject(m_MyHero).CheckTakeOnItems(btWhere, StdItem58) then begin
        TakeOffItem := nil;
        if btWhere in [0..14] then begin //20080417 支持斗笠,0..12改0..13
          if THeroObject(m_MyHero).m_UseItems[btWhere].wIndex > 0 then begin
            StdItem20 := UserEngine.GetStdItem(THeroObject(m_MyHero).m_UseItems[btWhere].wIndex);
            if (StdItem20 <> nil) then begin //20090413
              case StdItem20.StdMode of
                15, 16, 19..24, 26, 27, 28, 29: begin //20100513 20100628 增加29分类(敏捷幸运型项链)
                    if (not m_boUserUnLockDurg) and (THeroObject(m_MyHero).m_UseItems[btWhere].btValue[7] <> 0) then begin
                      THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                      n18 := -4;
                      goto FailExit;
                    end;
                  end;
              end;

              if not m_boUserUnLockDurg and ((StdItem20.Reserved and 2) <> 0) and
                (StdItem20.Shape <> 188) and (StdItem20.Shape <> 193) and (StdItem20.Shape <> 203) then begin //吸伤物品不考虑 20090407
                THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                n18 := -4;
                goto FailExit;
              end;
              if ((StdItem20.Reserved and 4) <> 0) and (StdItem20.Shape <> 188) and
                (StdItem20.Shape <> 193) and (StdItem20.Shape <> 203) then begin //吸伤物品不考虑 20090407
                THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                n18 := -4;
                goto FailExit;
              end;
            end;
            if InDisableTakeOffList(THeroObject(m_MyHero).m_UseItems[btWhere].wIndex) then begin
              THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
              goto FailExit;
            end;
            New(TakeOffItem);
            TakeOffItem^ := THeroObject(m_MyHero).m_UseItems[btWhere];
          end; //004DAEC7 if m_UseItems[btWhere].wIndex > 0 then begin

          if UserItem.btValue[8] <> 0 then begin //20080229
            case StdItem.StdMode of
              15, 16, 19..24, 26, 27, 28, 29: UserItem.btValue[8] := 0; //20100513 修改 20100628 增加29分类(敏捷幸运型项链)
            end;
          end;

          THeroObject(m_MyHero).m_UseItems[btWhere] := UserItem^;
          THeroObject(m_MyHero).SendDelItems(UserItem);
          THeroObject(m_MyHero).DelBagItem(n14);

          if TakeOffItem <> nil then begin
            if THeroObject(m_MyHero).AddItemToBag(TakeOffItem) then begin
              THeroObject(m_MyHero).SendAddItem(TakeOffItem);
              //增加穿戴触发 By TasNat at: 2012-03-17 09:47:26
            m_sString[0] := UserEngine.GetStdItemName(TakeOffItem.wIndex);
            m_nInteger[0] := 1;
            CmdUserCmd('@TakeOff' + IntToStr(btWhere));
            end else Dispose(TakeOffItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43

          end;

          if btWhere = U_BUJUK then begin
            if THeroObject(m_MyHero).WearFirDragon then begin //没火龙之心,不显示怒气值  20091106 修改
              THeroObject(m_MyHero).SendMsg({self}m_MyHero, RM_FIRDRAGONPOINT, 0, 0, 0, 0, ''); //发送英雄怒气值  20090109 修改
            end;
          end;

          THeroObject(m_MyHero).RecalcAbilitys();
          m_MyHero.CompareSuitItem(True); //套装与身上装备对比 20080712
{$IF M2Version <> 2}
          THeroObject(m_MyHero).SendNGResume(); //发送内功减免，伤害，恢复速度数据 20090812
{$IFEND}
          THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROABILITY, 0, 0, 0, 0, '');
          THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROSUBABILITY, 0, 0, 0, 0, '');
          m_MyHero.GetFeature(feature);
          THeroObject(m_MyHero).SendDefMessage(SM_HEROTAKEON_OK, {m_MyHero.GetFeatureToLong} 0, m_MyHero.GetFeatureEx, 0, 0, EncodeBuffer(@feature, SizeOf(feature))); //20110917 修改
          THeroObject(m_MyHero).FeatureChanged();
          if StdItem^.Shape in [118] then SendToAllClientHumProps(False, 0, 1);

          if StdItem.StdMode = 16 then begin
            THeroObject(m_MyHero).RefShowName(); //20080424 如果是斗笠则更新名字
            if m_MyHero.m_SlaveList.Count > 0 then begin //20080806 宝宝也更新名字
              for I := 0 to m_MyHero.m_SlaveList.Count - 1 do begin
                Slave := TBaseObject(m_MyHero.m_SlaveList.Items[I]);
                if (Slave <> nil) then begin
                  if (not Slave.m_boDeath) then Slave.RefShowName();
                end;
              end;
            end;
          end;
          n18 := 1;
          //增加穿戴触发 By TasNat at: 2012-03-17 09:47:26
          m_sString[0] := sItemName;
          m_nInteger[0] := 1;
          CmdUserCmd('@TakeOn' + IntToStr(btWhere));
        end;
      end else n18 := -2;
    end else n18 := -1;
  end;
  FailExit:
  if n18 <= 0 then SendDefMessage(SM_HEROTAKEON_FAIL, n18, 0, 0, 0, '');
end;
//英雄脱下装备

procedure TPlayObject.ClientHeroTakeOffItems(btWhere: Byte; nItemIdx: Integer; sItemName: string);
var
  n10, I: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  sUserItemName: string;
  Slave: TBaseObject; //20080806
  feature: TFeatures;
label FailExit;
begin
  n10 := 0;
  if (m_MyHero = nil) or m_boWaitHeroDate then begin
    goto FailExit;
  end;
  if not m_boDealing and (btWhere < 15) then begin //20080417 支持斗笠
    if THeroObject(m_MyHero).m_UseItems[btWhere].wIndex > 0 then begin
      if THeroObject(m_MyHero).m_UseItems[btWhere].MakeIndex = nItemIdx then begin
        StdItem := UserEngine.GetStdItem(THeroObject(m_MyHero).m_UseItems[btWhere].wIndex);
        if (StdItem <> nil) and
          (StdItem.StdMode in [15, 16, 19, 20, 21, 22, 23, 24, 26, 27, 28, 29]) then begin //20100513  20100628 增加29分类(敏捷幸运型项链)
          if (not m_boUserUnLockDurg) and (THeroObject(m_MyHero).m_UseItems[btWhere].btValue[7] <> 0) then begin
            THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
            n10 := -4;
            goto FailExit;
          end;
        end;
        if not m_boUserUnLockDurg and ((StdItem.Reserved and 2) <> 0) and
          (StdItem.Shape <> 188) and (StdItem.Shape <> 193) and (StdItem.Shape <> 203) then begin //吸伤物品不考虑 20090407
          THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
          n10 := -4;
          goto FailExit;
        end;
        if ((StdItem.Reserved and 4) <> 0) and (StdItem.Shape <> 188) and
          (StdItem.Shape <> 193) and (StdItem.Shape <> 203) then begin //吸伤物品不考虑 20090407
          THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
          n10 := -4;
          goto FailExit;
        end;
        if InDisableTakeOffList(THeroObject(m_MyHero).m_UseItems[btWhere].wIndex) then begin
          THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
          goto FailExit;
        end;
        //取自定义物品名称
        sUserItemName := '';
        if THeroObject(m_MyHero).m_UseItems[btWhere].btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(THeroObject(m_MyHero).m_UseItems[btWhere].MakeIndex, THeroObject(m_MyHero).m_UseItems[btWhere].wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(THeroObject(m_MyHero).m_UseItems[btWhere].wIndex);

        if CompareText(sUserItemName, sItemName) = 0 then begin
          New(UserItem);
          FillChar(UserItem^, SizeOf(TUserItem), #0); //20080820 增加
          //FillChar(UserItem^.btValue, SizeOf(UserItem^.btValue), 0);//20080820 增加
          UserItem^ := THeroObject(m_MyHero).m_UseItems[btWhere];
          if THeroObject(m_MyHero).AddItemToBag(UserItem) then begin
            THeroObject(m_MyHero).m_UseItems[btWhere].wIndex := 0;
            THeroObject(m_MyHero).SendAddItem(UserItem);
            THeroObject(m_MyHero).RecalcAbilitys();
            m_MyHero.CompareSuitItem(False); //套装与身上装备对比 20080712
{$IF M2Version <> 2}
            THeroObject(m_MyHero).SendNGResume(); //发送内功减免，伤害，恢复速度数据 20090812
{$IFEND}
            THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROABILITY, 0, 0, 0, 0, '');
            THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROSUBABILITY, 0, 0, 0, 0, '');
            m_MyHero.GetFeature(feature);
            THeroObject(m_MyHero).SendDefMessage(SM_HEROTAKEOFF_OK, {m_MyHero.GetFeatureToLong} 0, m_MyHero.GetFeatureEx, 0, 0, EncodeBuffer(@feature, SizeOf(feature))); //20110917 修改
            THeroObject(m_MyHero).FeatureChanged();
            //增加穿戴触发 By TasNat at: 2012-03-17 09:47:26
            m_sString[0] := sItemName;
            m_nInteger[0] := 1;
            CmdUserCmd('@TakeOff' + IntToStr(btWhere));
            if StdItem^.Shape in [118] then SendToAllClientHumProps(False, 0, 0);
            if StdItem.StdMode = 16 then begin
              THeroObject(m_MyHero).RefShowName(); //20080424 如果是斗笠则更新名字
              if m_MyHero.m_SlaveList.Count > 0 then begin //20080806 宝宝也更新名字
                for I := 0 to m_MyHero.m_SlaveList.Count - 1 do begin
                  Slave := TBaseObject(m_MyHero.m_SlaveList.Items[I]);
                  if (Slave <> nil) and (not Slave.m_boDeath) then begin
                    Slave.RefShowName();
                  end;
                end;
              end;
            end;
          end else begin
            Dispose(UserItem);
            n10 := -3;
          end;
        end;
      end;
    end else n10 := -2;
  end else n10 := -1;
  FailExit:
  if n10 <= 0 then
    SendDefMessage(SM_HEROTAKEOFF_FAIL, n10, 0, 0, 0, '');
end;

(*procedure TPlayObject.ClientHeroTakeOffItemsToBag(nIndex: Integer; btWhere: Byte; nItemIdx: Integer; sItemName: string);
var
  n10: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  sUserItemName: string;
  feature: TFeatures;
label FailExit;
begin
  n10 := 0;
  if (m_MyHero = nil) or m_boWaitHeroDate then begin
    goto FailExit;
  end;
  case nIndex of
    CM_TAKEOFFITEMHEROBAG: begin //装备脱下到英雄包裹
        if not m_boDealing and (btWhere < 13) then begin
          if m_UseItems[btWhere].wIndex > 0 then begin
            if m_UseItems[btWhere].MakeIndex = nItemIdx then begin
              StdItem := UserEngine.GetStdItem(m_UseItems[btWhere].wIndex);
              if (StdItem <> nil) and
                (StdItem.StdMode in [15,16, 19, 20, 21, 22, 23, 24, 26, 27, 28, 29]) then begin//20100513 20100628 增加29分类(敏捷幸运型项链)
                if (not m_boUserUnLockDurg) and (THeroObject(m_MyHero).m_UseItems[btWhere].btValue[7] <> 0) then begin
                  SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                  n10 := -4;
                  goto FailExit;
                end;
              end;
              if not m_boUserUnLockDurg and ((StdItem.Reserved and 2) <> 0) and
                (StdItem.Shape <> 188) and (StdItem.Shape <> 193) and (StdItem.Shape <> 203) then begin//吸伤物品不考虑 20090407
                SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                n10 := -4;
                goto FailExit;
              end;
              if ((StdItem.Reserved and 4) <> 0) and (StdItem.Shape <> 188) and
                (StdItem.Shape <> 193) and (StdItem.Shape <> 203) then begin//吸伤物品不考虑 20090407
                SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                n10 := -4;
                goto FailExit;
              end;
              if InDisableTakeOffList(m_UseItems[btWhere].wIndex) then begin
                SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                goto FailExit;
              end;
              //取自定义物品名称
              sUserItemName := '';
              if m_UseItems[btWhere].btValue[13] = 1 then
                sUserItemName := ItemUnit.GetCustomItemName(m_UseItems[btWhere].MakeIndex, m_UseItems[btWhere].wIndex);
              if sUserItemName = '' then
                sUserItemName := UserEngine.GetStdItemName(m_UseItems[btWhere].wIndex);

              if CompareText(sUserItemName, sItemName) = 0 then begin
                New(UserItem);
                FillChar(UserItem^, SizeOf(TUserItem), #0);//20080820 增加
                UserItem^ := m_UseItems[btWhere];
                if THeroObject(m_MyHero).AddItemToBag(UserItem) then begin
                  THeroObject(m_MyHero).SendAddItem(UserItem);
                  m_UseItems[btWhere].wIndex := 0;
                  RecalcAbilitys();
                  CompareSuitItem(False);//200080729 套装
                  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                  SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
                  feature := GetFeatureToLong;
                  SendDefMessage(SM_TAKEOFFTOHEROBAG_OK, {GetFeatureToLong}0, GetFeatureEx, 0, 0, EncodeBuffer(@feature, SizeOf(feature)));
                  FeatureChanged();
                  n10 := 1;
                end else begin
                  Dispose(UserItem);
                  n10 := -3;
                end;
              end;
            end;
          end else n10 := -2;
        end else n10 := -1;
      end;

    CM_TAKEOFFITEMTOMASTERBAG: begin //装备脱下到主人包裹
        if not m_boDealing and (btWhere < 13) then begin
          if THeroObject(m_MyHero).m_UseItems[btWhere].wIndex > 0 then begin
            if THeroObject(m_MyHero).m_UseItems[btWhere].MakeIndex = nItemIdx then begin
              StdItem := UserEngine.GetStdItem(THeroObject(m_MyHero).m_UseItems[btWhere].wIndex);
              if (StdItem <> nil) and
                (StdItem.StdMode in [15,16, 19, 20, 21, 22, 23, 24, 26, 27, 28, 29]) then begin//20100513  20100628 增加29分类(敏捷幸运型项链)
                if (not m_boUserUnLockDurg) and (THeroObject(m_MyHero).m_UseItems[btWhere].btValue[7] <> 0) then begin
                  THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                  n10 := -4;
                  goto FailExit;
                end;
              end;
              if not m_boUserUnLockDurg and ((StdItem.Reserved and 2) <> 0) and
                (StdItem.Shape <> 188) and (StdItem.Shape <> 193) and (StdItem.Shape <> 203) then begin//吸伤物品不考虑 20090407
                THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                n10 := -4;
                goto FailExit;
              end;
              if ((StdItem.Reserved and 4) <> 0) and (StdItem.Shape <> 188) and
                (StdItem.Shape <> 193) and (StdItem.Shape <> 203) then begin//吸伤物品不考虑 20090407
                THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                n10 := -4;
                goto FailExit;
              end;
              if InDisableTakeOffList(THeroObject(m_MyHero).m_UseItems[btWhere].wIndex) then begin
                THeroObject(m_MyHero).SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                goto FailExit;
              end;
              //取自定义物品名称
              sUserItemName := '';
              if THeroObject(m_MyHero).m_UseItems[btWhere].btValue[13] = 1 then
                sUserItemName := ItemUnit.GetCustomItemName(THeroObject(m_MyHero).m_UseItems[btWhere].MakeIndex, THeroObject(m_MyHero).m_UseItems[btWhere].wIndex);
              if sUserItemName = '' then
                sUserItemName := UserEngine.GetStdItemName(THeroObject(m_MyHero).m_UseItems[btWhere].wIndex);

              if CompareText(sUserItemName, sItemName) = 0 then begin
                New(UserItem);
                FillChar(UserItem^, SizeOf(TUserItem), #0);//20080820 增加
                //FillChar(UserItem^.btValue, SizeOf(UserItem^.btValue), 0);//20080820 增加
                UserItem^ := THeroObject(m_MyHero).m_UseItems[btWhere];
                if AddItemToBag(UserItem) then begin
                  SendAddItem(UserItem);
                  WeightChanged();
                  THeroObject(m_MyHero).m_UseItems[btWhere].wIndex := 0;
                  THeroObject(m_MyHero).RecalcAbilitys();
                  m_MyHero.CompareSuitItem(False);//200080729 套装
                  THeroObject(m_MyHero).WeightChanged();
                  THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROABILITY, 0, 0, 0, 0, '');
                  THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROSUBABILITY, 0, 0, 0, 0, '');
                  feature := m_MyHero.GetFeatureToLong;
                  THeroObject(m_MyHero).SendDefMessage(SM_TAKEOFFTOMASTERBAG_OK, {m_MyHero.GetFeatureToLong}0, m_MyHero.GetFeatureEx, 0, 0, EncodeBuffer(@feature, SizeOf(feature))); //20110917 修改
                  THeroObject(m_MyHero).FeatureChanged();
                  n10 := 1;
                end else begin
                  Dispose(UserItem);
                  n10 := -3;
                end;
              end;
            end;
          end else n10 := -2;
        end else n10 := -1;
      end;
  end;
  FailExit:
  case nIndex of
    CM_TAKEOFFITEMHEROBAG: begin //装备脱下到英雄包裹
        if n10 <= 0 then
          SendDefMessage(SM_TAKEOFFTOHEROBAG_FAIL, n10, 0, 0, 0, '');
      end;
    CM_TAKEOFFITEMTOMASTERBAG: begin //装备脱下到主人包裹
        if n10 <= 0 then
          SendDefMessage(SM_TAKEOFFTOMASTERBAG_FAIL, n10, 0, 0, 0, '');
      end;
  end;
end; *)
//包裹到包裹

procedure TPlayObject.ClientBagToBag(nIndex: Integer; nItemIdx: Integer; sItemName: string);
var
  I, n10: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  sUserItemName: string;
label FailExit;
begin
  n10 := 0;
  if (m_MyHero = nil) or m_boWaitHeroDate or m_boHeroLogOut then begin
    goto FailExit;
  end;

  case nIndex of
    CM_SENDITEMTOHEROBAG: begin //主人包裹到英雄包裹
        for I := m_ItemList.Count - 1 downto 0 do begin
          if m_ItemList.Count <= 0 then Break; //20080917
          if m_boShop then begin //开启个人商店时不能从主体包裹把物品转移到英雄包裹里 20100704
            goto FailExit;
            Break;
          end;
          UserItem := pTUserItem(m_ItemList.Items[I]);
          if UserItem <> nil then begin //20090310
            if UserItem.MakeIndex = nItemIdx then begin
              if PlugOfCheckCanItem(8, sItemName, False, 0, 0) then begin //禁止物品规则,禁止英雄使用(管理插件功能) 20080929
                goto FailExit;
                Break;
              end;
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem = nil then begin
                goto FailExit;
                Break;
              end;
              if (StdItem.StdMode = 44) and (StdItem.Shape = 253) then begin //除魔灵媒不能放到英雄包裹中 20100827
                goto FailExit;
                Break;
              end;
              //取自定义物品名称
              sUserItemName := '';
              if UserItem.btValue[13] = 1 then
                sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
              if sUserItemName = '' then
                sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
              if (CompareText(sUserItemName, sItemName) = 0) and ((CompareText(m_sHeroCharName, m_MyHero.m_sCharName) = 0) or (CompareText(m_sDeputyHeroName, m_MyHero.m_sCharName) = 0)) then begin //20080902
                THeroObject(m_MyHero).ClearCopyItem(UserItem.wIndex, UserItem.MakeIndex); //20080901 先清理英雄包裹复制品
                if m_boHeroLogOut then begin //英雄退出,则失败 20080909
                  goto FailExit;
                  Break;
                end;
                if THeroObject(m_MyHero).AddItemToBag(UserItem) then begin
                  m_ItemList.Delete(I);
                  THeroObject(m_MyHero).SendAddItem(UserItem);
                  //发送聚灵珠的经验 20090502
                  if (StdItem.StdMode = 51) and (StdItem.Shape = 0) and (UserItem.btValue[12] <> 2) and (UserItem.btValue[20] = 1) then begin
                    if (UserItem.Dura > 0) then begin
                      SendMsg(self, RM_EXPTIMEITEMS, 0, UserItem.MakeIndex, (n_UsesItemTick div 3600), 0, ''); //发送聚灵珠剩于时间 20080307
                    end;
                  end;
                  THeroObject(m_MyHero).SendDefMessage(SM_SENDITEMTOHEROBAG_OK, 0, 0, 0, 0, '');
                  WeightChanged; //负重改变 20080228
                  THeroObject(m_MyHero).WeightChanged; //负重改变 20080228
                  n10 := 1;
                end else begin
                  n10 := -3;
                end;
                Break;
              end;
            end;
          end;
        end;
      end;
    CM_SENDITEMTOMASTERBAG: begin //英雄包裹到主人包裹
        for I := m_MyHero.m_ItemList.Count - 1 downto 0 do begin
          if m_MyHero.m_ItemList.Count <= 0 then Break; //20080917
          UserItem := pTUserItem(m_MyHero.m_ItemList.Items[I]);
          if UserItem <> nil then begin //20090310
            if UserItem.MakeIndex = nItemIdx then begin
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem = nil then begin
                goto FailExit;
                Break;
              end;
            //取自定义物品名称
              sUserItemName := '';
              if UserItem.btValue[13] = 1 then
                sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
              if sUserItemName = '' then
                sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
              if (CompareText(sUserItemName, sItemName) = 0) and ((CompareText(m_sHeroCharName, m_MyHero.m_sCharName) = 0) or (CompareText(m_sDeputyHeroName, m_MyHero.m_sCharName) = 0)) then begin //20080902
                ClearCopyItem(0, UserItem.wIndex, UserItem.MakeIndex); //20080828 增加
                if m_boHeroLogOut then begin //英雄退出,则失败 20080909
                  goto FailExit;
                  Break;
                end;
                if AddItemToBag(UserItem) then begin
                  m_MyHero.m_ItemList.Delete(I);
                  SendAddItem(UserItem);
                //发送聚灵珠的经验 20090502
                  if (StdItem.StdMode = 51) and (StdItem.Shape = 0) and (UserItem.btValue[12] <> 2) and (UserItem.btValue[20] = 1) then begin
                    if (UserItem.Dura > 0) then begin
                      SendMsg(self, RM_EXPTIMEITEMS, 0, UserItem.MakeIndex, (n_UsesItemTick div 3600), 0, ''); //发送聚灵珠剩于时间 20080307
                    end;
                  end;
                  SendDefMessage(SM_SENDITEMTOMASTERBAG_OK, 0, 0, 0, 0, '');
                  WeightChanged; //负重改变 20080228
                  THeroObject(m_MyHero).WeightChanged; //负重改变 20080228
                  n10 := 1;
                end else begin
                  n10 := -3;
                end;
                Break;
              end;
            end;
          end;
        end;
      end;
  end; //case
  FailExit:
  case nIndex of
    CM_SENDITEMTOHEROBAG: begin //主人包裹到英雄包裹
        if n10 <= 0 then SendDefMessage(SM_SENDITEMTOHEROBAG_FAIL, n10, 0, 0, 0, '');
      end;
    CM_SENDITEMTOMASTERBAG: begin //英雄包裹到主人包裹
        if n10 <= 0 then SendDefMessage(SM_SENDITEMTOMASTERBAG_FAIL, n10, 0, 0, 0, '');
      end;
  end;
end;
//英雄使用物品

procedure TPlayObject.ClientHeroUseItems(nItemIdx: Integer; sItemName: string; nType: Byte);
begin
  if m_boWaitHeroDate then Exit;
  if THeroObject(m_MyHero) <> nil then begin
    THeroObject(m_MyHero).ClientHeroUseItems(nItemIdx, sItemName, True, nType);
  end;
end;

(*procedure TPlayObject.ClientGetUserOrder(nSortType, nType, nPage: Integer); //用户排行
  function GetSortStringList: TStringList;
  begin
    Result := nil;
    case nSortType of
      0: begin
          case nType of
            1: Result := UserEngine.m_PlayObjectLevelList;
            2: Result := UserEngine.m_WarrorObjectLevelList;
            3: Result := UserEngine.m_WizardObjectLevelList;
            4: Result := UserEngine.m_TaoistObjectLevelList;
          end;
        end;
      1: begin
          if g_Config.boUseCanHero then begin//开放英雄系统 20100529
            case nType of
              1: Result := UserEngine.m_HeroObjectLevelList;
              2: Result := UserEngine.m_WarrorHeroObjectLevelList;
              3: Result := UserEngine.m_WizardHeroObjectLevelList;
              4: Result := UserEngine.m_TaoistHeroObjectLevelList;
            end;
          end;
        end;
      2: begin
          Result := UserEngine.m_PlayObjectMasterList;
        end;
    end;
  end;
  function GetPageCount(List: TStringList): Integer;
  begin
    Result := List.Count div 10;
    if List.Count mod 10 > 0 then Inc(Result);
  end;
var
  nIndex: Integer;
  StringList: TStringList;
  n01, nPageCount, nBeginPage: Integer;
  sSendText: string;

  UserLevelSort: pTUserLevelSort;
  HeroLevelSort: pTHeroLevelSort;
  UserMasterSort: pTUserMasterSort;

  nCode: Byte;
begin
  EnterCriticalSection(HumanSortCriticalSection);
  try
    nCode:= 0;
    Try
      StringList := GetSortStringList;
      nCode:= 1;
      if StringList <> nil then begin
        n01 := 0;
        sSendText := '';
        nPageCount := GetPageCount(StringList);
        nCode:= 2;
        nBeginPage := nPage;
        if nPage >= nPageCount then nBeginPage := nPageCount - 1;
        if nBeginPage < 0 then nBeginPage := 0;

        if nPage < 0 then begin //我的排行
          nIndex:= StringList.IndexOf(m_sCharName);
          if nIndex > -1 then begin
            case nSortType of
              0:begin
                UserLevelSort:= pTUserLevelSort(StringList.Objects[nIndex]);
                if UserLevelSort <> nil then begin
                  sSendText := EncodeBuffer(@UserLevelSort^, SizeOf(TUserLevelSort)) + '/';
                end;
              end;
              1:begin
                HeroLevelSort:= pTHeroLevelSort(StringList.Objects[nIndex]);
                if HeroLevelSort <> nil then begin
                  sSendText := EncodeBuffer(@HeroLevelSort^, SizeOf(THeroLevelSort)) + '/';
                end;
              end;
              2:begin
                UserMasterSort:= pTUserMasterSort(StringList.Objects[nIndex]);
                if UserMasterSort <> nil then begin
                  sSendText := EncodeBuffer(@UserMasterSort^, SizeOf(TUserMasterSort)) + '/';
                end;
              end;
            end;
          end;
        end else begin
          nCode:= 8;
          for nIndex := nBeginPage * 10 to StringList.Count - 1 do begin
            if n01 >= 10 then Break;
            case nSortType of
              0: begin
                  UserLevelSort:= pTUserLevelSort(StringList.Objects[nIndex]);
                  if UserLevelSort <> nil then begin
                    sSendText := sSendText + EncodeBuffer(@UserLevelSort^, SizeOf(TUserLevelSort)) + '/';
                  end;
                end;
              1: begin
                  HeroLevelSort := pTHeroLevelSort(StringList.Objects[nIndex]);
                  if HeroLevelSort <> nil then begin
                    sSendText := sSendText + EncodeBuffer(@HeroLevelSort^, SizeOf(THeroLevelSort)) + '/';
                  end;
                end;
              2: begin
                  UserMasterSort := pTUserMasterSort(StringList.Objects[nIndex]);
                  if UserMasterSort <> nil then begin
                    sSendText := sSendText + EncodeBuffer(@UserMasterSort^, SizeOf(TUserMasterSort)) + '/';
                  end;
                end;
            end;
            Inc(n01);
          end;
        end;
        nCode:= 12;
        if nPage >= 0 then begin
          nCode:= 13;
          if sSendText <> '' then begin{客户端对应Param   Recog     Tag     Series }
            SendMsg(Self, RM_QUERYUSERLEVELSORT, nPage, nSortType, nType, nPageCount, sSendText);
          end;
        end else begin
          nCode:= 14;
          if sSendText <> '' then begin
            SendMsg(Self, RM_QUERYUSERLEVELSORT, nPage, nSortType, nType, 0, sSendText);
          end else begin
            SendMsg(Self, RM_QUERYUSERLEVELSORT, nPage, -1, nType, 0, '');
          end;
        end;
      end;
    except
      MainOutMessage(Format('{%s} TPlayObject.ClientGetUserOrder Code:%d',[g_sExceptionVer, nCode]));
    end;
  finally
    LeaveCriticalSection(HumanSortCriticalSection);
  end;
end;                             *)
{$IFEND}


function TPlayObject.IsTakeItemForHuShengRing(BaseObject: TBaseObject): Byte;
var StdItem: pTStdItem;
  UserItem: TUserItem;
begin
  Result := 0;

    UserItem := BaseObject.m_UseItems[U_RINGL];
  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
  if (StdItem <> nil) and (StdItem^.Shape in [118]) then
  begin
    Result := 1;
    Exit;
  end;


    UserItem := TPlayObject(BaseObject).m_UseItems[U_RINGR];
  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
  if (StdItem <> nil) and (StdItem^.Shape in [118]) then
  begin
    Result := 1;
    Exit;
  end;
end;

procedure TPlayObject.SendToAllClientHumProps(bIsHum: Boolean; HumPropPos, Value: Byte);
var I, K: Integer;
  BaseObject: TPlayObject;
  SendObject: TBaseObject;
begin
  if bIsHum then SendObject := Self else SendObject := m_MyHero;
  Value := IsTakeItemForHuShengRing(SendObject);

  for I := 0 to UserEngine.m_PlayObjectList.Count - 1 do
  begin
    BaseObject := TPlayObject(UserEngine.m_PlayObjectList.Objects[I]);
    if BaseObject <> nil then
    begin
      if (not BaseObject.m_boNotOnlineAddExp) and not BaseObject.m_boDeath then // RM_MOVEMESSAGE
        BaseObject.SendMsg(SendObject, RM_HUMTAKEITEM, MakeWord(HumPropPos, Value), Integer(Self), 0, 0, '');
    end;
  end;
end;

//人物:把包裹物品穿到身上
//参数：位置  物品制造ID 物品名称

procedure TPlayObject.ClientTakeOnItems(btWhere: Byte; nItemIdx: Integer; sItemName: string);
var
  I, n14, n18: Integer;
  UserItem, TakeOffItem: pTUserItem;
  StdItem, StdItem20: pTStdItem;
  StdItem58: TStdItem;
  sUserItemName: string;
  Slave: TBaseObject; //20080806
  nCode: Byte; //20090807
  feature: TFeatures;

label FailExit;

begin
  nCode := 0;
  try
    StdItem := nil;
    UserItem := nil;
    n14 := -1;
    if m_ItemList.Count > 0 then begin //20080628
      for I := 0 to m_ItemList.Count - 1 do begin
        nCode := 1;
        UserItem := m_ItemList.Items[I];
        if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then begin
          nCode := 2;
          //取自定义物品名称
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sUserItemName = '' then sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
          nCode := 3;
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          nCode := 4;
          if StdItem <> nil then begin
            if CompareText(sUserItemName, sItemName) = 0 then begin
              n14 := I;
              Break;
            end;
          end;
        end;
        UserItem := nil;
      end;
    end;

    nCode := 5;
    n18 := 0;
    if (StdItem <> nil) and (UserItem <> nil) then begin
      if (UserItem.AddValue[0] = 2) and (GetHoursCount(UserItem.MaxDate, Now) > 0) then begin //绑定期物品
        n18 := -1;
        goto FailExit;
      end;
      nCode := 6;
      if CheckIsOKItem(UserItem) then begin //检查变态物品 20081007
        n18 := -1;
        goto FailExit;
      end;
      if (btWhere = 13) and (StdItem.StdMode = 16) and (StdItem.AniCount = 2) then begin //如果没有设置人物可带,则不能带上斗笠 20090331
        n18 := -1;
        goto FailExit;
      end;
      nCode := 7;
      if CheckUserItems(btWhere, StdItem) then begin
        StdItem58 := StdItem^;
        nCode := 8;
        ItemUnit.GetItemAddValue(UserItem, StdItem58);
        nCode := 9;
        if CheckTakeOnItems(btWhere, StdItem58) and CheckItemBindUse(UserItem) then begin
          TakeOffItem := nil;

          {$IF M2Version = 2}
          if (btWhere in [0..8]) or (g_Config.boShowNewItem and (btWhere in [0..14])) then
          {$Else}
          if btWhere in [0..14] then
          {$IFEND}
          begin //20080417 支持斗笠,0..12改0..13
            if m_UseItems[btWhere].wIndex > 0 then begin
              nCode := 10;
              StdItem20 := UserEngine.GetStdItem(m_UseItems[btWhere].wIndex);
              nCode := 11;
              if StdItem20 <> nil then begin //20080229
                case StdItem20.StdMode of
                  15, 16, 19..24, 26, 27, 28, 29: begin //20100513  20100628 增加29分类(敏捷幸运型项链)
                      if (not m_boUserUnLockDurg) and (m_UseItems[btWhere].btValue[7] <> 0) then begin
                        SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                        n18 := -4;
                        goto FailExit;
                      end;
                    end;
                end; //case
              end;

              if not m_boUserUnLockDurg and ((StdItem20.Reserved and 2) <> 0) and
                (StdItem20.Shape <> 188) and (StdItem20.Shape <> 193) and (StdItem20.Shape <> 203) then begin //吸伤物品不考虑 20090407
                SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                n18 := -4;
                goto FailExit;
              end;
              if ((StdItem20.Reserved and 4) <> 0) and (StdItem20.Shape <> 188) and
                (StdItem20.Shape <> 193) and (StdItem20.Shape <> 203) then begin //吸伤物品不考虑 20090407
                SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                n18 := -4;
                goto FailExit;
              end;
              nCode := 12;
              if InDisableTakeOffList(m_UseItems[btWhere].wIndex) then begin
                SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                goto FailExit;
              end;
              New(TakeOffItem);
              TakeOffItem^ := m_UseItems[btWhere];
            end; //004DAEC7 if m_UseItems[btWhere].wIndex > 0 then begin

            if UserItem.btValue[8] <> 0 then begin //20080229
              case StdItem.StdMode of
                15, 16, 19..24, 26, 27, 28, 29: UserItem.btValue[8] := 0; //20100513 20100628 增加29分类(敏捷幸运型项链)
              end;
            end;
            nCode := 13;
            m_UseItems[btWhere] := UserItem^;
            nCode := 14;
            SendDelItems(UserItem);
            DelBagItem(n14);
            if TakeOffItem <> nil then begin
              nCode := 15;

              if AddItemToBag(TakeOffItem) then begin
              nCode := 16;
              SendAddItem(TakeOffItem);
              //增加穿戴触发 By TasNat at: 2012-03-17 09:47:26
              m_sString[0] := UserEngine.GetStdItemName(TakeOffItem.wIndex);
              m_nInteger[0] := 0;
              CmdUserCmd('@TakeOff' + IntToStr(btWhere));
              end else Dispose(TakeOffItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
            end;
            nCode := 17;
            RecalcAbilitys();
            if btWhere <> U_BUJUK then //20080918 物品位,不进入触发,以避免施毒术时不停的触发
              CompareSuitItem(True) //套装与身上装备对比 20080918
            else CompareSuitItem(False);
{$IF M2Version <> 2}
            SendNGResume(0); //发送内功减免，伤害，恢复速度数据 20090812
{$IFEND}
            SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
            SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
            GetFeature(feature);
            SendDefMessage(SM_TAKEON_OK, {GetFeatureToLong} 0, GetFeatureEx, 0, 0, EncodeBuffer(@feature, SizeOf(feature)));
            nCode := 18;
            FeatureChanged();
            if StdItem^.Shape in [118] then SendToAllClientHumProps(True, 0, 1);

            nCode := 19;
            if StdItem.StdMode = 16 then begin
              RefShowName(); //20080424 如果是斗笠则更新名字
              if m_SlaveList.Count > 0 then begin //20080806 宝宝也更新名字
                for I := 0 to m_SlaveList.Count - 1 do begin
                  Slave := TBaseObject(m_SlaveList.Items[I]);
                  if (Slave <> nil) then begin
                    if (not Slave.m_boDeath) then Slave.RefShowName();
                  end;
                end;
              end;
            end;
            n18 := 1;
            //增加穿戴触发 By TasNat at: 2012-03-17 09:47:26
            m_sString[0] := sItemName;
            m_nInteger[0] := 0;
            CmdUserCmd('@TakeOn' + IntToStr(btWhere));
          end;
        end else n18 := -1;
      end else n18 := -1;
    end;
    FailExit:
    if n18 <= 0 then begin
      SendDefMessage(SM_TAKEON_FAIL, n18, 0, 0, 0, '');
    end;
  except
    MainOutMessage(Format('{%s} TPlayObject.ClientTakeOnItems Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

procedure TPlayObject.ClientTakeOffItems(btWhere: Byte; nItemIdx: Integer; sItemName: string);
var
  n10, I: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  sUserItemName: string;
  Slave: TBaseObject; //20080806             
  nCode: Byte;                               
  feature: TFeatures;                        
label FailExit;                              
begin                                        
  n10 := 0;
  nCode := 0;
  try
    {$IF M2Version <> 2}
    if not m_boDealing and (btWhere < 15) then
    {$ELSE}
    if not m_boDealing and (btWhere < 9) or (g_Config.boShowNewItem and (btWhere < 15)) then
    {$ifend}
    begin //btWhere < 13 扩展斗笠 btWhere < 14  20080417
      nCode := 1;
      if m_UseItems[btWhere].wIndex > 0 then begin
        if m_UseItems[btWhere].MakeIndex = nItemIdx then begin
          nCode := 2;
          StdItem := UserEngine.GetStdItem(m_UseItems[btWhere].wIndex);
          if (StdItem <> nil) and
            (StdItem.StdMode in [15, 16, 19, 20, 21, 22, 23, 24, 26, 27, 28, 29]) then begin //20100513 20100628 增加29分类(敏捷幸运型项链)
            if (not m_boUserUnLockDurg) and (m_UseItems[btWhere].btValue[7] <> 0) then begin
              SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
              n10 := -4;
              goto FailExit;
            end;
          end;
          nCode := 3;
          if not m_boUserUnLockDurg and ((StdItem.Reserved and 2) <> 0) and
            (StdItem.Shape <> 188) and (StdItem.Shape <> 193) and (StdItem.Shape <> 203) then begin //吸伤物品不考虑 20090407
            SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
            n10 := -4;
            goto FailExit;
          end;
          nCode := 4;
          if ((StdItem.Reserved and 4) <> 0) and (StdItem.Shape <> 188) and
            (StdItem.Shape <> 193) and (StdItem.Shape <> 203) then begin //吸伤物品不考虑 20090407
            SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
            n10 := -4;
            goto FailExit;
          end;
          nCode := 5;
          if InDisableTakeOffList(m_UseItems[btWhere].wIndex) then begin
            SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
            goto FailExit;
          end;

          nCode := 6;
          //取自定义物品名称
          sUserItemName := '';
          if m_UseItems[btWhere].btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(m_UseItems[btWhere].MakeIndex, m_UseItems[btWhere].wIndex);
          if sUserItemName = '' then
            sUserItemName := UserEngine.GetStdItemName(m_UseItems[btWhere].wIndex);
          nCode := 7;
          if CompareText(sUserItemName, sItemName) = 0 then begin
            New(UserItem);
            FillChar(UserItem^, SizeOf(TUserItem), #0); //20080820 增加
            nCode := 8;
            UserItem^ := m_UseItems[btWhere];
            nCode := 9;
            if AddItemToBag(UserItem) then begin
              m_UseItems[btWhere].wIndex := 0;
              nCode := 10;
              SendAddItem(UserItem);
              RecalcAbilitys();
              CompareSuitItem(False); //套装与身上装备对比 20080729
              nCode := 11;
{$IF M2Version <> 2}
              SendNGResume(0); //发送内功减免，伤害，恢复速度数据 20090812
{$IFEND}
              nCode := 12;
              SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
              SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
              nCode := 13;
              GetFeature(feature);
              SendDefMessage(SM_TAKEOFF_OK, {GetFeatureToLong} 0, GetFeatureEx, 0, 0, EncodeBuffer(@feature, SizeOf(feature)));
              FeatureChanged();
              //增加拿下身上装备触发 By TasNat at: 2012-03-17 09:47:26
              m_sString[0] := sItemName;
              CmdUserCmd('@TakeOff' + IntToStr(btWhere));

              if StdItem^.Shape in [118] then SendToAllClientHumProps(True, 0, 0);

              nCode := 14;
              if StdItem.StdMode = 16 then begin
                RefShowName(); //20080424 如果是斗笠则更新名字
                nCode := 15;
                if m_SlaveList.Count > 0 then begin //20080806 宝宝也更新名字
                  for I := m_SlaveList.Count - 1 downto 0 do begin
                    if m_SlaveList.Count <= 0 then Break;
                    nCode := 16;
                    Slave := TBaseObject(m_SlaveList.Items[I]);
                    if (Slave <> nil) then begin
                      if (not Slave.m_boDeath) then Slave.RefShowName();
                    end;
                  end;
                end;
              end;
            end else begin
              nCode := 17;
              Dispose(UserItem);
              n10 := -3;
            end;
          end;
        end;
      end else n10 := -2;
    end else n10 := -1;
    FailExit:
    if n10 <= 0 then
      SendDefMessage(SM_TAKEOFF_FAIL, n10, 0, 0, 0, '');
  except
    MainOutMessage(format('{%s} TPlayObject.ClientTakeOffItems Code:%d', [g_sExceptionVer, nCode]));
  end;
end;
//召唤强化卷,把招出的宝宝变成7级  20080221

function TPlayObject.CallMobeItem(): Boolean;
var
  I: Integer;
  Slave: TBaseObject;
begin
  Result := False;
  if m_SlaveList.Count = 0 then begin
    SysMsg('您没有召唤宝宝,不能使用此物品!', c_Red, t_Hint);
    Exit;
  end;
  if m_SlaveList.Count > 0 then begin //20080629
    for I := 0 to m_SlaveList.Count - 1 do begin
      Slave := TBaseObject(m_SlaveList.Items[I]);
      if (Slave.m_btRaceServer = RC_PLAYMOSTER) or (Slave.m_btRaceServer in [99, 132, 133, 154, 158]) then Continue; //召唤巨魔,圣兽,火灵,宠物,分身不能调级
      if Slave.m_btSlaveExpLevel < 7 then begin //20080323
        Slave.m_btSlaveExpLevel := 7;
        Slave.RecalcAbilitys; //20080328 改变等级,刷新属性
        Slave.RefNameColor; //20080408
        Slave.SendRefMsg(RM_MYSHOW, ET_OBJECTLEVELUP, 0, 0, 0, ''); //宝宝升级动画  20080328
        Result := True;
        SysMsg('在神秘的力量影响下，您的宠物:' + FilterShowName(Slave.m_sCharName) + ' 成长为7级', BB_Fuchsia, t_Hint); //20090402 增加FilterShowName()
        Break;
      end;
    end;
  end;
end;

//全部修复,需要的持久值 20080325

function TPlayObject.RepairAllItemDura: Integer;
var
  nWhere: Integer;
//  sCheckItemName: string;
  StdItem: pTStdItem;
begin
  Result := 0;
  for nWhere := Low(THumanUseItems) to High(THumanUseItems) do begin //9格装备+4格装备
    if m_UseItems[nWhere].wIndex > 0 then begin
      StdItem := UserEngine.GetStdItem(m_UseItems[nWhere].wIndex);
      if StdItem <> nil then begin
        if ((m_UseItems[nWhere].DuraMax div 1000) > (m_UseItems[nWhere].Dura div 1000)) and
          (StdItem.StdMode <> 7) and (StdItem.StdMode <> 25) and (StdItem.StdMode <> 43) and
          (StdItem.AniCount <> 21) then begin
          if CheckItemValue(@m_UseItems[nWhere], 3) then Continue //20080314 禁止修
          else
          {if Assigned(zPlugOfEngine.CheckCanRepairItem) then begin
            sCheckItemName := StdItem.Name;
            if not zPlugOfEngine.CheckCanRepairItem(m_Master, PChar(sCheckItemName)) then Continue;//检查是否是不能修复的物品
          end;}
            if PlugOfCheckCanItem(3, StdItem.Name, False, 0, 0) then Continue; //禁止物品规则(管理插件功能) 20080729

          Inc(Result, (m_UseItems[nWhere].DuraMax - m_UseItems[nWhere].Dura));
        end;
      end;
    end;
  end;
end;

//全部修复

procedure TPlayObject.RepairAllItem(DureCount: Integer; boDec: Boolean);
var
  nWhere, RepCount: Integer;
//  sCheckItemName: string;
  StdItem: pTStdItem;
begin
  for nWhere := Low(THumanUseItems) to High(THumanUseItems) do begin //9格装备+4格装备
    if m_UseItems[nWhere].wIndex > 0 then begin
      StdItem := UserEngine.GetStdItem(m_UseItems[nWhere].wIndex);
      if StdItem <> nil then begin
        if ((m_UseItems[nWhere].DuraMax div 1000) > (m_UseItems[nWhere].Dura div 1000)) and (StdItem.StdMode <> 7) and (StdItem.StdMode <> 25) and (StdItem.StdMode <> 43) and (StdItem.AniCount <> 21) then begin
          if CheckItemValue(@m_UseItems[nWhere], 3) then Continue //20080314 禁止修
          else
          {if Assigned(zPlugOfEngine.CheckCanRepairItem) then begin
            sCheckItemName := StdItem.Name;
            if not zPlugOfEngine.CheckCanRepairItem(m_Master, PChar(sCheckItemName)) then Continue;//检查是否是不能修复的物品
          end;}
            if PlugOfCheckCanItem(3, StdItem.Name, False, 0, 0) then Continue; //禁止物品规则(管理插件功能) 20080729

          if not boDec then begin //修复点够,则直接修复不计算
            if (m_UseItems[nWhere].DuraMax div 1000) - (m_UseItems[nWhere].Dura div 1000) > 0 then
              SysMsg(StdItem.Name + '修补成功。', c_Green, t_Hint);
            m_UseItems[nWhere].Dura := m_UseItems[nWhere].DuraMax;
            SendMsg(Self, RM_DURACHANGE, nWhere, m_UseItems[nWhere].Dura, m_UseItems[nWhere].DuraMax, 0, ''); //20071229
          end else begin
            RepCount := (m_UseItems[nWhere].DuraMax div 1000) - (m_UseItems[nWhere].Dura div 1000);
            if DureCount >= RepCount then begin
              Dec(DureCount, RepCount);
              if (m_UseItems[nWhere].DuraMax div 1000) - (m_UseItems[nWhere].Dura div 1000) > 0 then
                SysMsg(StdItem.Name + '修补成功。', c_Green, t_Hint); //20071229
              m_UseItems[nWhere].Dura := m_UseItems[nWhere].DuraMax;
              SendMsg(Self, RM_DURACHANGE, nWhere, m_UseItems[nWhere].Dura, m_UseItems[nWhere].DuraMax, 0, ''); //20071229
            end else
              if DureCount > 0 then begin
                DureCount := 0;
                m_UseItems[nWhere].Dura := m_UseItems[nWhere].Dura + DureCount * 1000;
                SendMsg(Self, RM_DURACHANGE, nWhere, m_UseItems[nWhere].Dura, m_UseItems[nWhere].DuraMax, 0, ''); //20071229
                Break;
              end;
          end;
        end;
      end;
    end;
  end;
end;
//随机移动

procedure TPlayObject.RandomMove();
var
  nX, nY: Integer;
begin
  if m_PEnvir = nil then Exit;
  nX := Random(m_PEnvir.m_nWidth);
  nY := Random(m_PEnvir.m_nHeight);
  SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
  SpaceMove(m_sMapName, nX, nY, 0);
end;
//客户端使用物品

procedure TPlayObject.ClientUseItems(nItemIdx, nX, nY: Integer; sItemName: string);
  function GetUnbindItemName(nShape: Integer): string;
  var
    I: Integer;
  begin
    Result := '';
    if g_UnbindList.Count > 0 then begin //20080629
      for I := 0 to g_UnbindList.Count - 1 do begin
        if Integer(g_UnbindList.Objects[I]) = nShape then begin
          Result := g_UnbindList.Strings[I];
          Break;
        end;
      end;
    end;
  end;
  function GetUnBindItems(sItemName: string; nCount: Integer): Boolean;
  var
    I: Integer;
    UserItem: pTUserItem;
  begin
    Result := False;
    if nCount <= 0 then nCount := 1; //20080629
    for I := 0 to nCount - 1 do begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
        m_ItemList.Add(UserItem);
        if m_btRaceServer = RC_PLAYOBJECT then SendAddItem(UserItem);
        Result := True;
      end else begin
        Dispose(UserItem);
        Break;
      end;
    end;
  end;
  function FoundUserItem(Item: pTUserItem): Boolean;
  var
    I: Integer;
    UserItem: pTUserItem;
  begin
    Result := False;
    if m_ItemList.Count > 0 then begin //20080628
      for I := 0 to m_ItemList.Count - 1 do begin
        UserItem := m_ItemList.Items[I];
        if UserItem = Item then begin
          Result := True;
          Break;
        end;
      end;
    end;
  end;
var
  I, ItemCount: Integer;
  boEatOK: Boolean;
  boSendUpDate: Boolean;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  UserItem34: TUserItem;
  sMapName: string;
  nCurrX, nCurrY: Integer;
  nCode, btTmp: Byte;
  dwExp, nMaxExp: uInt64;
  Castle: TUserCastle;
begin
  nCode := 0;
  m_boCanQueryBag := True; //使用物品时,不能刷新包裹 20080917
  try
    try
      boEatOK := False;
      boSendUpDate := False;
      StdItem := nil;
      if m_boCanUseItem then begin //能使用物品
        if not m_boDeath then begin
          for I := m_ItemList.Count - 1 downto 0 do begin
            if m_ItemList.Count <= 0 then Break;
            UserItem := m_ItemList.Items[I];
            if UserItem = nil then Continue;
            if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then begin
              UserItem34 := UserItem^;
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem <> nil then begin
                if not m_PEnvir.AllowStdItems(UserItem.wIndex) then begin //检查地图是否禁用此物品
                  SysMsg(Format_ToStr(g_sCanotMapUseItemMsg, [StdItem.Name]), c_Red, t_Hint);
                  Break;
                end;
                case StdItem.StdMode of
                  {0: begin
                      if EatItems(StdItem, nX) then begin
                        nCode:= 1;
                        if UserItem <> nil then begin
                          if StdItem.Reserved = 255 then begin//药品计次  20100927
                            if UserItem.Dura > 0 then begin
                              Dec(UserItem.Dura);
                              boEatOK := True;
                            end;
                            if UserItem.Dura > 0 then begin
                              boSendUpDate := True;
                              boEatOK := False;
                            end else begin
                              m_ItemList.Delete(I);
                              DisPoseAndNil(UserItem);
                              boEatOK := True;
                            end;
                          end else begin
                            m_ItemList.Delete(I);
                            DisPoseAndNil(UserItem);
                            boEatOK := True;
                          end;
                        end;
                      end;
                   end;}
                  0, 1, 3: begin //药
                      if EatItems(StdItem, nX) then begin
                        nCode := 1;
                        if UserItem <> nil then begin
                          m_ItemList.Delete(I);
                          //DisPoseAndNil(UserItem);
                          DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                          UserItem:= nil;
                        end;
                        boEatOK := True;
                      end;
                      Break;
                    end;
                  2: begin
                      if StdItem.AniCount = 21 then begin //祝福罐 类型的物品  20080315
                        if StdItem.Reserved <> 56 then begin
                          if UserItem.Dura > 0 then begin
                            if (m_ItemList.Count {-} + 1) <= MAXBAGITEM then begin //20090313 修改
                              if UserItem.Dura >= 1000 then begin //修改为1000,20071229
                                Dec(UserItem.Dura, 1000);
                                Dec(UserItem.DuraMax, 1000); //20080324 减少存物品数量
                                if UserItem.DuraMax <= 0 then begin //不能存取物品,则删除物品
                                  if UserItem <> nil then begin
                                    m_ItemList.Delete(I);
                                    //DisPoseAndNil(UserItem);
                                    DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                                    UserItem:= nil;
                                    boEatOK := True;
                                  end;
                                end;
                              end else begin
                                UserItem.Dura := 0;
                                UserItem.DuraMax := 0; //20080324 减少存物品数量
                                if UserItem.DuraMax <= 0 then begin //能存取物品,则删除物品
                                  if UserItem <> nil then begin
                                    m_ItemList.Delete(I);
                                    //DisPoseAndNil(UserItem);
                                    DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                                    UserItem:= nil;
                                    boEatOK := True;
                                  end;
                                end;
                              end;
                               //需要修改UnbindList.txt,加入 3 祝福油  20071229  3---为 祝福罐的外观值
                              GetUnBindItems(GetUnbindItemName(StdItem.Shape), 1); //给一个祝福油  20080310
                            end;
                          end;
                        end else begin //泉水罐
                          if (UserItem.Dura >= 1000) and (StdItem.Reserved = 56) then begin //20090313 修改
                            if (m_ItemList.Count {-} + 1) <= MAXBAGITEM then begin //20090313 修改
                              if UserItem.Dura >= 1000 then begin
                                Dec(UserItem.Dura, 1000);
                              end else begin
                                UserItem.Dura := 0;
                              end;
                              //需要修改UnbindList.txt,加入 1 泉水   1---为 泉水的外观值
                              GetUnBindItems(GetUnbindItemName(StdItem.Shape), 1); //给一个泉水
                            end;
                          end;
                        end;
                        boSendUpDate := True;
                      end else

                        case StdItem.Shape of
                          0: begin //计次物品
                              nCode := 3;
                              if (StdItem.Source <> 0) and (StdItem.Reserved <> 0) then begin //捆绳类物品 20081217
                                if UserItem <> nil then begin
                                  if UserItem.Dura > 0 then begin
                                    if CheckStdmodeFunItem(StdItem) then begin
                                      if UserItem.Dura >= 1000 then begin
                                        Dec(UserItem.Dura, 1000);
                                        boEatOK := True;
                                        nCode := 31;
                                        if UserItem.Dura > 0 then begin
                                          boSendUpDate := True;
                                          boEatOK := False;
                                        end else begin
                                          if UserItem <> nil then begin
                                            UserItem.wIndex := 0;
                                            nCode := 32;
                                            m_ItemList.Delete(I);
                                            nCode := 33;
                                            //DisPoseAndNil(UserItem);
                                            DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                                            UserItem:= nil;
                                          end;
                                        end;
                                      end else begin
                                        UserItem.Dura := 0;
                                        if UserItem <> nil then begin
                                          UserItem.wIndex := 0;
                                          nCode := 34;
                                          m_ItemList.Delete(I);
                                          nCode := 35;
                                          //DisPoseAndNil(UserItem);
                                          DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                                          UserItem:= nil;
                                        end;
                                      end;
                                      nCode := 36;
                                      UseStdmodeFunItem(StdItem);
                                    end;
                                  end else UserItem.wIndex := 0;
                                end;
                              end else begin //其它计次物品
                                if UserItem <> nil then begin //20081009 修改
                                  if UserItem.Dura > 0 then begin
                                    if UserItem.Dura >= 1000 then begin
                                      Dec(UserItem.Dura, 1000);
                                      boEatOK := True;
                                      nCode := 37;
                                      if UserItem.Dura > 0 then begin
                                        boSendUpDate := True;
                                        boEatOK := False;
                                      end else begin
                                        if UserItem <> nil then begin
                                          UserItem.wIndex := 0;
                                          nCode := 38;
                                          m_ItemList.Delete(I);
                                          nCode := 39;
                                          //DisPoseAndNil(UserItem);
                                          DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                                          UserItem:= nil;
                                        end;
                                      end;
                                    end else begin
                                      UserItem.Dura := 0;
                                      if UserItem <> nil then begin
                                        UserItem.wIndex := 0;
                                        nCode := 201;
                                        m_ItemList.Delete(I);
                                        nCode := 202;
                                        //DisPoseAndNil(UserItem);
                                        DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                                        UserItem:= nil;
                                      end;
                                    end;
                                    nCode := 203;
                                    UseStdmodeFunItem(StdItem);
                                  end else UserItem.wIndex := 0;
                                end;
                              end;
                            end; //0
                          1: begin //召唤强化卷 20080221
                              nCode := 4;
                              if UserItem.Dura > 0 then begin
                                if UserItem.Dura >= 1000 then begin
                                  if CallMobeItem() then begin //召唤强化卷,把招出的宝宝变成7级  20080221
                                    Dec(UserItem.Dura, 1000);
                                    boEatOK := True;
                                  end;
                                end else begin
                                  UserItem.Dura := 0;
                                  UserItem.wIndex := 0;
                                end;
                              end;
                              if UserItem.Dura > 0 then begin
                                boSendUpDate := True;
                                boEatOK := False;
                              end else begin
                                if UserItem <> nil then begin
                                  m_ItemList.Delete(I);
                                  //DisPoseAndNil(UserItem);
                                  DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                                  UserItem:= nil;
                                end;
                              end;
                            end;
                          2: begin //随机传送石
                              nCode := 6;
                              if not m_PEnvir.m_boNORANDOMMOVE then begin //地图没有禁止随机传送时才能使用 20080831
                                if UserItem.Dura > 0 then begin
                                  if UserItem.Dura >= 1000 then begin
                                    Dec(UserItem.Dura, 1000);
                                  end else begin
                                    UserItem.Dura := 0;
                                    UserItem.wIndex := 0; //20081014
                                  end;
                                  boEatOK := True;
                                  RandomMove();
                                end;
                                if UserItem.Dura > 0 then begin
                                  boSendUpDate := True;
                                  boEatOK := False;
                                end else begin
                                  if UserItem <> nil then begin
                                    m_ItemList.Delete(I);
                                    //DisPoseAndNil(UserItem);
                                    DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                                    UserItem:= nil;
                                  end;
                                end;
                              end;
                            end;
                          3: begin
                              case StdItem.AniCount of
                                15, 16, 17: begin //双倍卷轴 双倍秘籍 双倍宝典 20071230---使用时,必进入这里,是脚本触发 ActionOfKillMonExpRate
                                    nCode := 7;
                                    if UserItem.Dura > 0 then begin
                                      if UserItem.Dura >= 1000 {100} then begin
                                        Dec(UserItem.Dura, 1000 {100});
                                      end else begin
                                        UserItem.Dura := 0;
                                        UserItem.wIndex := 0; //20081014
                                      end;
                                      m_nKillMonExpRate := m_nKillMonExpRate * 2; //调整杀怪经验为双倍数
                                      m_nOldKillMonExpRate := m_nKillMonExpRate; //20080607
                                      m_dwKillMonExpRateTime := m_dwKillMonExpRateTime + 180; //经验倍数时间(秒)
                                      if m_MyHero <> nil then begin //英雄也同时双倍经验  20080406
                                        if m_MyHero.m_PEnvir = m_PEnvir then begin //英雄与主人同在个地图才执行 20090506
                                          THeroObject(m_MyHero).m_nKillMonExpRate := THeroObject(m_MyHero).m_nKillMonExpRate * 2;
                                          THeroObject(m_MyHero).m_nOldKillMonExpRate := THeroObject(m_MyHero).m_nKillMonExpRate; //20080607
                                        end;
                                      end;
                                      boEatOK := True;
                                      sMapName := AnsiReplaceText(g_sChangeKillMonExpRateMsg, '%g', FloatToStr(m_nKillMonExpRate / 100));
                                      sMapName := AnsiReplaceText(sMapName, '%n', IntToStr(Round(m_dwKillMonExpRateTime / 3600))); //时
                                      sMapName := AnsiReplaceText(sMapName, '%u', IntToStr(m_dwKillMonExpRateTime)); //秒
                                      SysMsg(sMapName, c_Blue, t_Hint); //20110113 修改
                                      //SysMsg(Format_ToStr(g_sChangeKillMonExpRateMsg, [m_nKillMonExpRate / 100, m_dwKillMonExpRateTime]), {c_Green}c_Blue, t_Hint);//20101022 修改
                                    end;
                                    if UserItem.Dura > 0 then begin
                                      boSendUpDate := True;
                                      boEatOK := False;
                                    end else begin
                                      if UserItem <> nil then begin
                                        m_ItemList.Delete(I);
                                        //DisPoseAndNil(UserItem);
                                        DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                                        UserItem:= nil;
                                      end;
                                    end;
                                  end;
                              end; //case
                            end; //3
                          4: begin //沙巴克随机石,攻城期使用，不受地图限制随机 20110515
                              if UserItem.Dura > 0 then begin
                                Castle := g_CastleManager.InCastleWarArea(Self);
                                if (Castle <> nil) and Castle.m_boUnderWar then begin
                                  if UserItem.Dura >= 1000 then begin
                                    Dec(UserItem.Dura, 1000);
                                  end else begin
                                    UserItem.Dura := 0;
                                    UserItem.wIndex := 0;
                                  end;
                                  boEatOK := True;
                                  RandomMove();
                                end else SysMsg('非攻城时间、非攻城区域无法使用！', c_Red, t_Hint);
                              end;
                              if UserItem.Dura > 0 then begin
                                boSendUpDate := True;
                                boEatOK := False;
                              end else begin
                                if UserItem <> nil then begin
                                  m_ItemList.Delete(I);
                                  //DisPoseAndNil(UserItem);
                                  DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                                  UserItem:= nil;
                                end;
                              end;
                            end; //4
                          5: begin //朱火鼎
                              if UserItem <> nil then begin
                                if m_PEnvir.GetXYObjCount(m_nCurrX, m_nCurrY) <= 1 then begin
                              //GetFrontPosition(nCurrX, nCurrY);
                              //if m_PEnvir.CanWalk(nCurrX, nCurrY, False) then begin
                                  if UserItem.Dura > 0 then begin
                                    if UserItem.Dura >= 1000 then begin
                                      Dec(UserItem.Dura, 1000);
                                      boEatOK := True;
                                      nCode := 37;
                                      if UserItem.Dura > 0 then begin
                                        boSendUpDate := True;
                                        boEatOK := False;
                                      end else begin
                                        if UserItem <> nil then begin
                                          UserItem.wIndex := 0;
                                          nCode := 38;
                                          m_ItemList.Delete(I);
                                          nCode := 39;
                                          //DisPoseAndNil(UserItem);
                                          DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                                          UserItem:= nil;
                                        end;
                                      end;
                                    end else begin
                                      UserItem.Dura := 0;
                                      if UserItem <> nil then begin
                                        UserItem.wIndex := 0;
                                        nCode := 201;
                                        m_ItemList.Delete(I);
                                        nCode := 202;
                                        //DisPoseAndNil(UserItem);
                                        DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                                        UserItem:= nil;
                                      end;
                                    end;
                                    nCode := 203;
                                    UseStdmodeFunItem(StdItem);
                                  end;
                                end;
                              end else UserItem.wIndex := 0;
                            end; //5
                          9: begin //修复神水
                              nCode := 5;
                              ItemCount := RepairAllItemDura;
                              if (UserItem.Dura > 0) and (ItemCount > 0) then begin
                                if UserItem.Dura >= (ItemCount div 10) then begin //20080325
                                  Dec(UserItem.Dura, (ItemCount div 10)); //20080325
                                  RepairAllItem(ItemCount div 1000, False); //全部修复
                                  if UserItem.Dura < 100 then UserItem.Dura := 0;
                                end else begin
                                  UserItem.Dura := 0;
                                  RepairAllItem(ItemCount div 1000, True);
                                end;
                              end;
                              boEatOK := False;
                              if UserItem.Dura > 0 then begin
                                boSendUpDate := True;
                              end else begin
                                if UserItem <> nil then begin
                                  m_ItemList.Delete(I);
                                  //DisPoseAndNil(UserItem);
                                  DisPose(UserItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                                  UserItem:= nil;
                                end;
                                boEatOK := True;
                              end;
                            end;
{$IF M2Version <> 2}
                          253: begin //护花使者令
                              if m_boFengHaoMagicEffect then begin
                                SendFengHaoList(0, False);
                              end else SysMsg('非常抱歉，您没有获得相应的称号，无法使用！', c_Red, t_Hint);
                            end;
                          254: begin //主宰令牌
                              if m_boFengHaoDominate then begin
                                if not m_boOpenDominateToken then SendFengHaoList(1, False);
                              end else SysMsg('非常抱歉，您没有获得相应的称号，无法使用！', c_Red, t_Hint);
                            end;
                          255: begin //灵气神水
                              if (m_SpiritMedia.wIndex > 0) then begin
                                ItemCount := RepairSpiritMediaDura;
                                if (UserItem.Dura > 0) and (ItemCount > 0) then begin
                                  if UserItem.Dura >= (ItemCount * 100) then begin
                                    Dec(UserItem.Dura, (ItemCount * 100));
                                    RepairSpiritMediaItem(ItemCount); //修复
                                    if UserItem.Dura < 100 then UserItem.Dura := 0;
                                  end else begin
                                    RepairSpiritMediaItem(UserItem.Dura div 100);
                                    UserItem.Dura := 0;
                                  end;
                                end;
                                boEatOK := False;
                                if UserItem.Dura > 0 then begin
                                  boSendUpDate := True;
                                end else begin
                                  if UserItem <> nil then begin
                                    m_ItemList.Delete(I);
                                    Dispose(UserItem); //By TasNat
                                  end;
                                  boEatOK := True;
                                end;
                              end else SysMsg('您没有佩戴灵媒', c_Green, t_Hint); //提示
                            end;
{$IFEND}
                        end;
                    end;
                  4: begin //书
                      nCode := 8;
                      if ReadBook(StdItem) then begin
                        if UserItem <> nil then begin
                          m_ItemList.Delete(I);
                          Dispose(UserItem); //By TasNat
                        end;
                        boEatOK := True;
                      end;
                    end;
                  {7: begin //使用次数 20100903 注释
                      nCode:= 9;
                      case StdItem.Shape of
                        0: begin
                            if UserItem.Dura > 0 then begin
                              if UserItem.Dura >= 1000 then begin
                                Dec(UserItem.Dura, 1000);
                              end else begin
                                UserItem.Dura := 0;
                                UserItem.wIndex:= 0;//20081014
                              end;
                              boEatOK := True;
                            end;
                            if UserItem.Dura > 0 then begin
                              boSendUpDate := True;
                              boEatOK := False;
                            end else begin
                              if UserItem <> nil then begin
                                m_ItemList.Delete(I);
                                FreeMemAndNil(UserItem); //By TasNat
                              end;
                            end;
                          end;
                      end;
                    end; }
                  17: begin //叠加物品
                      if StdItem.Shape = 237 then begin //叠加类药品 20110526
                        if UserItem.Dura > 0 then begin
                          if EatItems(StdItem, nX) then begin
                            Dec(UserItem.Dura);
                            if UserItem.Dura > 0 then begin
                              boSendUpDate := True;
                              boEatOK := False;
                            end else begin
                              if UserItem <> nil then begin
                                m_ItemList.Delete(I);
                                Dispose(UserItem); //By TasNat
                              end;
                              boEatOK := True;
                            end;
                          end;
                        end;
                      end else begin
                        if UserItem.Dura > 1 then begin
                          boSendUpDate := True;
                          ClientItemSplit(UserItem.MakeIndex, 1);
                        end;
                      end;
                    end;
                  31: begin //解包物品
                      nCode := 10;
                      case StdItem.AniCount of
                        0..3: begin
                            if (m_ItemList.Count + 6 - 1) <= MAXBAGITEM then begin
                              if UserItem <> nil then begin
                                m_ItemList.Delete(I);
                                Dispose(UserItem); //By TasNat
                              end;
                              GetUnBindItems(GetUnbindItemName(StdItem.Shape), 6);
                              boEatOK := True;
                            end;
                          end;
                        4..255: begin
                            case StdItem.Shape of
                              0: begin
                                  if FoundUserItem(UserItem) then begin //20080819 先查找物品，删除物品后再触发
                                    if UserItem <> nil then begin
                                      m_ItemList.Delete(I);
                                      Dispose(UserItem); //By TasNat
                                      UseStdmodeFunItem(StdItem); //使用物品触发脚本段
                                    end;
                                    boEatOK := True;
                                  end;
                                end;
                              1: begin
                                  if ItemDblClick(StdItem.Name, UserItem.MakeIndex, sMapName, nCurrX, nCurrY) then begin
                                    if UserItem <> nil then begin
                                      m_ItemList.Delete(I);
                                      Dispose(UserItem); //By TasNat
                                    end;
                                    SpaceMove(sMapName, nCurrX, nCurrY, 0);
                                    boEatOK := True;
                                  end else begin
                                    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '当前地图坐标保存成功！\再次双击，将传送到\地图：' + m_sMapName + ' 坐标：' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY));
                                  end;
                                end;
                            end; //case StdItem.Shape of
                          end;
                      end;
                    end; //31
                  51: begin //聚集物品
                      nCode := 11;
                      case StdItem.Shape of
                        0: begin //聚灵珠
                            nCode := 110;
                            if UserItem.btValue[12] = 2 then begin //聚集满了经验，或是聚集时间到,才可使用
                              if ((m_Abil.Level >= StdItem.NeedLevel) and (StdItem.Need = 0)) or ((m_Abil.Level <= StdItem.NeedLevel) and (StdItem.Need = 1)) then begin //限制等级使用聚灵珠 20090705
                                dwExp := UserItem.Dura * 10000; //20080817 修改
                                nCode := 111;
                                if m_MyHero <> nil then begin
                                  if not m_MyHero.m_boGhost then begin //20110130
                                    if m_MyHero.m_Abil.Level < g_Config.nLimitExpLevelHero then begin //20110116 增加
                                      THeroObject(m_MyHero).GetExp(abs(Round((g_Config.nHeroNoKillMonExpRate / 100) * dwExp)), 0); //20081018 修改
                                      dwExp := abs(Round(((100 - g_Config.nHeroNoKillMonExpRate) / 100) * dwExp)); //20081018 修改
                                    end;
                                  end;
                                end;

                                if m_Abil.nExp >= dwExp then begin //20090102
                                  if (High(uInt64) - m_Abil.nExp) < LongWord(dwExp) then begin
                                    dwExp := High(uInt64) - m_Abil.nExp;
                                  end;
                                end else begin
                                  if (High(uInt64) - dwExp) < m_Abil.nExp then begin
                                    dwExp := High(uInt64) - dwExp;
                                  end;
                                end;
                                m_GetExp := dwExp; //人物取得的经验,$GetExp变量使用 20090102
                                nCode := 112;
                                if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(self, '@GetExp', False, False); //取经验触发 20090102
                                Inc(m_Abil.nExp, dwExp);
                                SendMsg(self, RM_WINEXP, 0, 0, 0, 0, EncodeExp(m_Abil.nExp, dwExp));
                                nCode := 113;
                                if (m_Abil.Level < MAXUPLEVEL) and
                                  (m_Abil.Level < g_Config.nLimitExpLevel) then begin //20110925 达到等级上限时不处理
                                  if g_Config.boContinuousUpLevel then begin //20100605
                                    btTmp := 0;
                                    while (m_Abil.nExp >= m_Abil.nMaxExp) do begin //20100408 循环处理升级
                                      if btTmp >= 8 then Break;
                                      Inc(btTmp);
                                      if m_Abil.nExp <= 0 then begin
                                        m_Abil.nExp := 0;
                                        Break;
                                      end;
                                  //if m_Abil.Exp >= m_Abil.MaxExp then begin//20080825
                                      Dec(m_Abil.nExp, m_Abil.nMaxExp);
                                      if (m_Abil.Level < MAXUPLEVEL) and (m_Abil.Level < g_Config.nLimitExpLevel) then begin
                                        Inc(m_Abil.Level); //增加限制等级
                                        if (m_sMasterName <> '') and not m_boMaster then begin //自动出师 20100408
                                          if m_Abil.Level >= g_Config.nMasterOKLevel then CheckMaster(True);
                                        end;
                                      end;
                                      if m_Abil.Level < g_Config.nLimitExpLevel then HasLevelUp(m_Abil.Level - 1); //增加限制等级
                                      if not m_boAI then begin
                                        AddGameDataLog('12' + #9 + m_sMapName + #9 + //人物升级记录日志
                                          IntToStr(m_nCurrX) + #9 +
                                          IntToStr(m_nCurrY) + #9 +
                                          m_sCharName + #9 + IntToStr(m_Abil.nExp) + '/' + IntToStr(m_Abil.nMaxExp) + #9 + IntToStr(m_Abil.Level) + #9 + '1' + #9 + '聚灵珠');
                                      end;
                                    end;
                                  end else begin
                                    nCode := 114;
                                    if m_Abil.nExp >= m_Abil.nMaxExp then begin
                                      Dec(m_Abil.nExp, m_Abil.nMaxExp);
                                      if (m_Abil.Level < MAXUPLEVEL) and (m_Abil.Level < g_Config.nLimitExpLevel) then begin
                                        Inc(m_Abil.Level); //增加限制等级
                                        if (m_sMasterName <> '') and not m_boMaster then begin //自动出师 20100408
                                          if m_Abil.Level >= g_Config.nMasterOKLevel then CheckMaster(True);
                                        end;
                                      end;
                                      if m_Abil.Level < g_Config.nLimitExpLevel then HasLevelUp(m_Abil.Level - 1); //增加限制等级
                                      if not m_boAI then begin
                                        AddGameDataLog('12' + #9 + m_sMapName + #9 + //人物升级记录日志
                                          IntToStr(m_nCurrX) + #9 +
                                          IntToStr(m_nCurrY) + #9 +
                                          m_sCharName + #9 + IntToStr(m_Abil.nExp) + '/' + IntToStr(m_Abil.nMaxExp) + #9 + IntToStr(m_Abil.Level) + #9 + '1' + #9 + '聚灵珠');
                                      end;
                                    end;
                                  end;
                                end;
                                nCode := 115;
                                try
                                if m_Magic68Skill <> nil then begin //学过酒气护体 20080825
                                  if m_Magic68Skill.btLevel < 100 then Inc(m_Magic68Skill.nTranPoint, dwExp);
                                  nMaxExp := GetSkill68Exp(m_Magic68Skill.btLevel);
                                  if m_Magic68Skill.nTranPoint >= nMaxExp then begin //超过升级经验,则升级技能
                                    Dec(m_Magic68Skill.nTranPoint, nMaxExp);
                                    if m_Magic68Skill.btLevel < 100 then Inc(m_Magic68Skill.btLevel);
                                  end;
                                  if m_Magic68Skill.btLevel < 101 then begin
                                    nMaxExp := GetSkill68Exp(m_Magic68Skill.btLevel);
                                    SendMsg(self, RM_MAGIC_LVEXP, m_Magic68Skill.MagicInfo.wMagicId, nMaxExp, m_Magic68Skill.btLevel, m_Magic68Skill.nTranPoint, '');
                                  end;
                                end;
                                except//屏蔽酒气护体导致的错误By TasNat at: 2012-11-10 12:47:18

                                end;
                                nCode := 117;
                                if UserItem <> nil then begin
                                  m_ItemList.Delete(I);
                                  Dispose(UserItem); //By TasNat
                                end;
                                boEatOK := True;
                              end else begin
                                if (StdItem.Need = 0) then SysMsg('等级需达到：' + IntToStr(StdItem.NeedLevel) + '级后才可以使用！', c_Red, t_Hint);
                                if (StdItem.Need = 1) then SysMsg('等级超过：' + IntToStr(StdItem.NeedLevel) + '级，不可使用！', c_Red, t_Hint);
                              end;
                            end;
                          end; //0
                        1: begin //内功珠
{$IF M2Version <> 2}
                            if UserItem.btValue[12] = 2 then begin //聚集满了经验,才可使用
                              if ((m_Abil.Level >= StdItem.NeedLevel) and (StdItem.Need = 0)) or ((m_Abil.Level <= StdItem.NeedLevel) and (StdItem.Need = 1)) then begin //限制等级使用
                                nCode := 118;
                                dwExp := UserItem.Dura * 1000;
                                GetNGExp(dwExp, 4);
                                nCode := 119;
                                if UserItem <> nil then begin
                                  m_ItemList.Delete(I);
                                  Dispose(UserItem); //By TasNat
                                end;
                                boEatOK := True;
                              end else begin
                                if (StdItem.Need = 0) then SysMsg('等级需达到：' + IntToStr(StdItem.NeedLevel) + '级后才可以使用！', c_Red, t_Hint);
                                if (StdItem.Need = 1) then SysMsg('等级超过：' + IntToStr(StdItem.NeedLevel) + '级，不可使用！', c_Red, t_Hint);
                              end;
                            end;
{$IFEND}
                          end; //1
                        2, 3: begin //英雄聚灵珠 主宰者灵珠
                            SysMsg('请放到英雄包裹使用！', c_Green, t_Hint);
                          end; //2
                      end; //Case
                    end; //51
                  60: begin //饮酒 20080622
                      nCode := 12;
                      if (StdItem.Shape <> 0) then begin //除烧酒外
                        if not n_DrinkWineDrunk then begin //没有喝醉
                          if m_Abil.MaxAlcohol >= StdItem.Need then begin //酒量值达到要求
                            if UserItem.Dura > 0 then begin
                              case StdItem.Anicount of //普通酒与药酒区别处理
                                1: begin //普通酒
                                    if UserItem.Dura >= 1000 then begin
                                      Dec(UserItem.Dura, 1000);
                                    end else begin
                                      UserItem.Dura := 0;
                                    end;
{$IF M2Version = 1}
                                    dw_UseMedicineTime1 := g_Config.nDesAlcoholTick;
{$IFEND}
                                    SendRefMsg(RM_MYSHOW, 7, 0, 0, 0, ''); //喝酒自身动画  20080623
                                    if m_Abil.WineDrinkValue = 0 then begin //如果醉酒度为0,则初始时间间隔
                                      m_dwDecWineDrinkValueTick := GetTickCount();
                                      m_dwAddAlcoholTick := GetTickCount();
                                    end;
                                    Inc(m_Abil.WineDrinkValue, (UserItem.btValue[1] * m_Abil.MaxAlcohol div 200)); //增加醉酒度 20080623
                                    n_DrinkWineAlcohol := UserItem.btValue[1]; //饮酒时酒的度数 20080624
                                    n_DrinkWineQuality := UserItem.btValue[0]; //饮酒时酒的品质 20080623
                                    if m_Abil.WineDrinkValue >= m_Abil.MaxAlcohol then begin //醉酒度超过上限,即喝醉了
                                      m_Abil.WineDrinkValue := m_Abil.MaxAlcohol;
                                      n_DrinkWineDrunk := True; //喝酒醉了 20080623
                                      SysMsg('自觉头晕不已,酒虽为情所系,奈何量去甚多,暂无余力再饮!', c_Red, t_Hint);
                                      SendRefMsg(RM_MYSHOW, 9, 0, 0, 0, ''); //喝醉自身动画  20080623
                                    end;
                                    if (not n_DrinkWineDrunk) and (n_DrinkWineQuality > 2) and (Random(4) = 0) then begin
                                      btTmp := Random(2);
                                  //普通酒,品质2以上,25%机率加临时属性 20080713
                                      case btTmp of
                                        0: begin
                                          DefenceUp(300); //增加防御力300秒
                                          if m_Abil.WineDrinkValue > Round(m_Abil.MaxAlcohol * 0.5) then
                                        SysMsg('防御能力大大增强。', c_Blue, t_Hint)

                                      else SysMsg('防御能力增强。', c_Blue, t_Hint);
                                        end;
                                        1: begin
                                          MagDefenceUp(300); //增加魔御300秒
                                          if m_Abil.WineDrinkValue > Round(m_Abil.MaxAlcohol * 0.5) then
                                        SysMsg('魔法防御能力大大增强。', c_Blue, t_Hint)
                                      else SysMsg('魔法防御能力增强。', c_Blue, t_Hint);
                                        end;
                                      end;

                                    end;
                                    RecalcAbilitys();
                                    CompareSuitItem(False); //套装与身上装备对比 20080729
                                    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                                    boEatOK := True;
                                  end;
                                2: begin //药酒
                                    if not m_boDrinkDrugHotels then begin //药酒不可同时使用
                                      if UserItem.Dura >= 1000 then begin
                                        Dec(UserItem.Dura, 1000);
                                      end else begin
                                        UserItem.Dura := 0;
                                      end;
{$IF M2Version = 1}
                                      dw_UseMedicineTime1 := g_Config.nDesAlcoholTick;
{$IFEND}
                                      SendRefMsg(RM_MYSHOW, 7, 0, 0, 0, ''); //喝酒自身动画  20080623
                                      if m_Abil.WineDrinkValue = 0 then begin //如果醉酒度为0,则初始时间间隔
                                        m_dwDecWineDrinkValueTick := GetTickCount();
                                        m_dwAddAlcoholTick := GetTickCount();
                                      end;
                                      Inc(m_Abil.WineDrinkValue, (UserItem.btValue[1] * m_Abil.MaxAlcohol div 200)); //增加醉酒度 20080623
                                      n_DrinkWineAlcohol := UserItem.btValue[1]; //饮酒时酒的度数 20080624
                                      n_DrinkWineQuality := UserItem.btValue[0]; //饮酒时酒的品质 20080623
                                      if m_Abil.WineDrinkValue >= m_Abil.MaxAlcohol then begin //醉酒度超过上限,即喝醉了
                                        m_Abil.WineDrinkValue := m_Abil.MaxAlcohol;
                                        n_DrinkWineDrunk := True; //喝酒醉了 20080623
                                        SysMsg('自觉头晕不已,酒虽为情所系,奈何量去甚多,暂无余力再饮!', c_Red, t_Hint);
                                        SendRefMsg(RM_MYSHOW, 9, 0, 0, 0, ''); //喝醉自身动画  20080623
                                      end;
                                      if not n_DrinkWineDrunk then begin
                                        if n_DrinkWineQuality > 4 then begin //品质为4以上,药酒增加临时属性 20080626
                                          m_boDrinkDrugHotels := True;
                                          case StdItem.Shape of
                                            8: begin //虎骨酒 增加攻击上限,魔法上限或道术上限4点,效果持续600秒
                                                case m_btJob of
                                                  0: begin
                                                      m_wStatusArrValue[0] := 4;
                                                      m_dwStatusArrTimeOutTick[0] := GetTickCount + 600000 {600 * 1000};
                                                      SysMsg('虎骨酒使攻击上限增加600秒', c_Green, t_Hint);
                                                      SysMsg('药酒的药性在身体内沉淀下来', c_Green, t_Hint);
                                                    end;
                                                  1: begin
                                                      m_wStatusArrValue[1] := 4;
                                                      m_dwStatusArrTimeOutTick[1] := GetTickCount + 600000 {600 * 1000};
                                                      SysMsg('虎骨酒使魔法上限增加600秒', c_Green, t_Hint);
                                                      SysMsg('药酒的药性在身体内沉淀下来', c_Green, t_Hint);
                                                    end;
                                                  2: begin
                                                      m_wStatusArrValue[14] := 4;
                                                      m_dwStatusArrTimeOutTick[14] := GetTickCount + 600000 {600 * 1000};
                                                      SysMsg('虎骨酒使道术上限增加600秒', c_Green, t_Hint);
                                                      SysMsg('药酒的药性在身体内沉淀下来', c_Green, t_Hint);
                                                    end;
                                              {3:begin//刺客
                                              end; }
                                                end;
                                              end;
                                            9: begin //金箔酒  增加生命值上限150点,效果持续600秒
                                                m_wStatusArrValue[4] := 150;
                                                m_dwStatusArrTimeOutTick[4] := GetTickCount + 600000 {600 * 1000};
                                                SysMsg('金箔酒使生命上限增加600秒', c_Green, t_Hint);
                                                SysMsg('药酒的药性在身体内沉淀下来', c_Green, t_Hint);
                                              end;
                                            10: begin //活脉酒  增加敏捷4点,效果持续600秒
                                                m_wStatusArrValue[11] := 4;
                                                m_dwStatusArrTimeOutTick[11] := GetTickCount + 600000 {600 * 1000};
                                                SysMsg('活脉酒使敏捷增加600秒', c_Green, t_Hint);
                                                SysMsg('药酒的药性在身体内沉淀下来', c_Green, t_Hint);
                                              end;
                                            11: begin //玄参酒  增加防御上限,魔法防御上限,效果持续600秒 20091209
                                                m_wStatusArrValue[12] := 5;
                                                m_dwStatusArrTimeOutTick[12] := GetTickCount + 600000;
                                                m_wStatusArrValue[13] := 5;
                                                m_dwStatusArrTimeOutTick[13] := GetTickCount + 600000;
                                                SysMsg('玄参酒使防御、魔法上限增加600秒', c_Green, t_Hint);
                                                SysMsg('药酒的药性在身体内沉淀下来', c_Green, t_Hint);
                                              end;
                                            12: begin //蛇胆酒  增加魔法值上限400点,效果持续600秒
                                                m_wStatusArrValue[5] := 400;
                                                m_dwStatusArrTimeOutTick[5] := GetTickCount + 600000;
                                                SysMsg('蛇胆酒使魔法上限增加600秒', c_Green, t_Hint);
                                                SysMsg('药酒的药性在身体内沉淀下来', c_Green, t_Hint);
                                              end;
                                            13: begin //醉八打,连击伤害增加20点,持续600秒
                                                m_wStatusArrValue[15] := 20;
                                                m_dwStatusArrTimeOutTick[15] := GetTickCount + 600000;
                                                SysMsg('醉八打使连击伤害增加600秒', c_Green, t_Hint);
                                                SysMsg('药酒的药性在身体内沉淀下来', c_Green, t_Hint);
                                              end;
                                            14: begin //何首养气酒,内力恢复速度增加10点,持续600秒
                                                m_wStatusArrValue[16] := 10;
                                                m_dwStatusArrTimeOutTick[16] := GetTickCount + 600000;
                                                SysMsg('何首养气酒使内力恢复速度增加600秒', c_Green, t_Hint);
                                                SysMsg('药酒的药性在身体内沉淀下来', c_Green, t_Hint);
                                              end;
{$IF M2Version <> 2}
                                            15: begin //何首凝神酒,内力瞬间恢复1000点,每10分钟只可饮用1瓶
                                                m_wStatusArrValue[17] := 1000;
                                                m_dwStatusArrTimeOutTick[17] := GetTickCount + 600000;
                                                m_Skill69NH := _MIN(m_Skill69MaxNH, m_Skill69NH + 1000); //
                                                SendRefMsg(RM_MAGIC69SKILLNH, 0, m_Skill69NH, m_Skill69MaxNH, 0, '');
                                                SysMsg('何首凝神酒使内力瞬间恢复1000点', c_Green, t_Hint);
                                                SysMsg('药酒的药性在身体内沉淀下来', c_Green, t_Hint);
                                              end;
{$IF M2Version = 1}
                                            16: begin //培元酒 10分钟内，斗转星移值增加200点
                                                m_wStatusArrValue[18] := 200;
                                                m_dwStatusArrTimeOutTick[18] := GetTickCount + 600000;
                                                SysMsg('培元酒使斗转星移上限值增加600秒', c_Green, t_Hint);
                                                SysMsg('药酒的药性在身体内沉淀下来', c_Green, t_Hint);
                                              end;
{$IFEND}
{$IFEND}
                                          end; //case
                                        end;
                                        dw_UseMedicineTime := g_Config.nDesMedicineTick; //始化使用药酒时间(12小时)
                                        Inc(m_Abil.MedicineValue, UserItem.btValue[2]); //增加药力值
                                        if m_Abil.MedicineValue >= m_Abil.MaxMedicineValue then begin //当前药力值达到当前等级上限时
                                          Dec(m_Abil.MedicineValue, m_Abil.MaxMedicineValue);
                                          case (n_MedicineLevel mod 6) of //增加永久属性
                                            0: begin //攻击/魔法/道术上限(看职业)
                                                case m_btJob of
                                                  0: m_Abil.DC := MakeLong(m_Abil.DC, m_Abil.DC + 1);
                                                  1: m_Abil.MC := MakeLong(m_Abil.MC, m_Abil.MC + 1);
                                                  2: m_Abil.SC := MakeLong(m_Abil.SC, m_Abil.SC + 1);
                                              //3:;//刺客
                                                end;
                                              end;
                                            1: m_Abil.MAC := MakeLong(m_Abil.MAC + 1, m_Abil.MAC); //加魔御下限
                                            2: m_Abil.AC := MakeLong(m_Abil.AC + 1, m_Abil.AC); //加防御下限
                                            3: begin //攻击/魔法/道术下限(看职业)
                                                case m_btJob of
                                                  0: m_Abil.DC := MakeLong(m_Abil.DC + 1, m_Abil.DC);
                                                  1: m_Abil.MC := MakeLong(m_Abil.MC + 1, m_Abil.MC);
                                                  2: m_Abil.SC := MakeLong(m_Abil.SC + 1, m_Abil.SC);
                                              //3:;//刺客
                                                end;
                                              end;
                                            4: m_Abil.MAC := MakeLong(m_Abil.MAC, m_Abil.MAC + 1); //魔御上限
                                            5: m_Abil.AC := MakeLong(m_Abil.AC, m_Abil.AC + 1); //防御上限
                                          end; //Case (n_MedicineLevel mod 6) of
                                          if n_MedicineLevel < MAXUPLEVEL then Inc(n_MedicineLevel); //增加等级
                                          m_Abil.MaxMedicineValue := GetMedicineExp(n_MedicineLevel); //取升级后的等级对应的药力值
                                          SysMsg('酒劲在周身弥漫，感觉身体状态有所改变', c_Green, t_Hint); //提示用户
                                        end;
                                      end;
                                      RecalcAbilitys();
                                      CompareSuitItem(False); //套装与身上装备对比 20080729
                                      SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                                      boEatOK := True;
{$IF M2Version <> 2}
                                      if m_wStatusArrValue[16] = 10 then SendNGResume(0); //发送内功减免，伤害，恢复速度数据
{$IFEND}
                                    end else SysMsg('刚刚喝下的药酒酒性还没有消除，不能喝其他的药酒。', c_Red, t_Hint); //提示用户
                                  end;
                              end;
                            end;
                            if UserItem.Dura > 0 then begin
                              boSendUpDate := True;
                              boEatOK := False;
                            end else begin
                              if UserItem <> nil then begin
                                UserItem.wIndex := 0; //20081014
                                m_ItemList.Delete(I);
                                Dispose(UserItem); //By TasNat
                              end;
                            end;
                          end else begin
                            SysMsg('酒量需达到' + inttostr(StdItem.Need) + '才能饮用!', c_Red, t_Hint); //提示用户
                          end;
                        end else begin
                          SysMsg('自觉头晕不已,酒虽为情所系,奈何量去甚多,暂无余力再饮!', c_Red, t_Hint);
                        end;
                      end; //if (StdItem.Shape <> 0)
                    end; //60
                end;
                Break;
              end;
            end;
          end; //for
        end; //
      end else begin
        SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotUseItemMsg);
      end;
      if boEatOK then begin
        nCode := 130;
        WeightChanged();
        nCode := 131;
        SendDefMessage(SM_EAT_OK, 0, 0, 0, 0, '');
        nCode := 132;
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog('11' + #9 + m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 + StdItem.Name + #9 +
            IntToStr(UserItem34.MakeIndex) + #9 +
            '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
            '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
            '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
            '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
            '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
            IntToStr(UserItem34.btValue[0]) + '/' + IntToStr(UserItem34.btValue[1]) + '/' + IntToStr(UserItem34.btValue[2]) + '/' +
            IntToStr(UserItem34.btValue[3]) + '/' + IntToStr(UserItem34.btValue[4]) + '/' + IntToStr(UserItem34.btValue[5]) + '/' +
            IntToStr(UserItem34.btValue[6]) + '/' + IntToStr(UserItem34.btValue[7]) + '/' + IntToStr(UserItem34.btValue[8]) + '/' +
            IntToStr(UserItem34.btValue[14]) + '[' + IntToStr(UserItem34.Dura) + '/' + inttostr(UserItem34.DuraMax) + ']' + #9 + IntToStr(m_btRaceServer));
      end else begin
        nCode := 14;
        SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
      end;
      if (UserItem <> nil) and boSendUpDate then SendUpdateItem(UserItem);
    except   
      MainOutMessage(Format('{%s} TPlayObject.ClientUseItems Code:%d', [g_sExceptionVer, nCode]));
    end;
  finally
    m_boCanQueryBag := False;
  end;
end;

function TPlayObject.ItemDblClick(sItemName: string; nMakeIndex: Integer; var sMapName: string; var nCurrX, nCurrY: Integer): Boolean;
var
  I: Integer;
  ItemEvent: pTItemEvent;
begin
  Result := False;
  sMapName := '';
  nCurrX := -1;
  nCurrY := -1;
  g_ItemDblClickList.Lock;
  try
    for I := g_ItemDblClickList.Count - 1 downto 0 do begin
      if g_ItemDblClickList.Count <= 0 then Break; //20080917
      ItemEvent := g_ItemDblClickList.Items[I];
      if ItemEvent.m_nMakeIndex = nMakeIndex then begin
        sMapName := ItemEvent.m_sMapName;
        nCurrX := ItemEvent.m_nCurrX;
        nCurrY := ItemEvent.m_nCurrY;
        g_ItemDblClickList.Delete(I);
        Dispose(ItemEvent);
        Result := True;
        Break;
      end;
    end; //for
    if not Result then begin
      New(ItemEvent);
      ItemEvent.m_sItemName := sItemName;
      ItemEvent.m_nMakeIndex := nMakeIndex;
      ItemEvent.m_sMapName := m_sMapName;
      ItemEvent.m_nCurrX := m_nCurrX;
      ItemEvent.m_nCurrY := m_nCurrY;
      g_ItemDblClickList.Add(ItemEvent);
    end;
  finally
    g_ItemDblClickList.UnLock;
  end;
  SaveItemDblClickList();
end;
//使用物品触发

function TPlayObject.UseStdmodeFunItem(StdItem: pTStdItem): Boolean;
begin
  Result := False;
  if g_FunctionNPC <> nil then begin
    g_FunctionNPC.GotoLable(Self, '@StdModeFunc' + IntToStr(StdItem.AniCount), False, False);
    Result := True;
  end;
end;
//检查包裹是否有指定物品，是否达到指定数 药绳捆使用 20081217

function TPlayObject.CheckStdmodeFunItem(StdItem: pTStdItem): Boolean;
var
  I, nCount: Integer;
  UserItem: pTUserItem;
  StdItem1: pTStdItem;
begin
  Result := False;
  try
    nCount := 0;
    if m_ItemList.Count > 0 then begin
      for I := 0 to m_ItemList.Count - 1 do begin
        UserItem := m_ItemList.Items[I];
        if UserItem <> nil then begin
          StdItem1 := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem1 <> nil then begin
            if (StdItem1.StdMode = 0) and (StdItem1.Source = StdItem.Source) then begin //是药品，并与捆绳对应
              Inc(nCount);
              if nCount >= StdItem.Reserved then begin
                Result := True;
                Break;
              end;
            end;
          end;
        end;
      end;
    end;
  except   
    MainOutMessage(Format('{%s} TPlayObject.CheckStdmodeFunItem', [g_sExceptionVer]));
  end;
end;

//人物死亡触发

function TPlayObject.DieFunc: Boolean;
begin
  Result := False;
  if g_FunctionNPC <> nil then begin
    g_FunctionNPC.GotoLable(Self, '@PlayDie', False, False);
    Result := True;
  end;
end;

//人物学技能触发 20080324

function TPlayObject.AddSkillFunc(MagicID: Integer): Boolean;
begin
  Result := False;
  if g_FunctionNPC <> nil then begin
    g_FunctionNPC.GotoLable(Self, '@HeroPlaySkill' + inttostr(MagicID), False, False);
    Result := True;
  end;
end;

//英雄学技能触发 20080324

function TPlayObject.HeroAddSkillFunc(MagicID: Integer): Boolean;
begin
  Result := False;
  if g_FunctionNPC <> nil then begin
    g_FunctionNPC.GotoLable(Self, '@PlaySkill' + inttostr(MagicID), False, False);
    Result := True;
  end;
end;

//宝宝杀死怪触发   20080126

function TPlayObject.KillMissionMob: Boolean;
begin
  Result := False;
  if g_FunctionNPC <> nil then begin
    g_FunctionNPC.GotoLable(Self, '@KillMissionMob', False, False);
    Result := True;
  end;
end;

//人物升级触发

function TPlayObject.LevelUpFunc: Boolean;
begin
  Result := False;
  if g_FunctionNPC <> nil then begin
    g_FunctionNPC.GotoLable(Self, '@PlayLevelUp', False, False);
    Result := True;
  end;
end;

//人物内级等级升级触发 20090509

function TPlayObject.NGLevelUpFunc: Boolean;
begin
  Result := False;
  if g_FunctionNPC <> nil then begin
    g_FunctionNPC.GotoLable(Self, '@PlayNGLevelUp', False, False);
    Result := True;
  end;
end;

//杀人触发

function TPlayObject.KillPlayFunc: Boolean;
begin
  Result := False;
  try
    if g_FunctionNPC <> nil then begin
      if m_PEnvir <> nil then begin //地图杀人触发
        if m_PEnvir.m_boKILLFUNC then g_FunctionNPC.GotoLable(Self, '@KillPlay' + Inttostr(m_PEnvir.m_nKILLFUNC), False, False);
      end;
      g_FunctionNPC.GotoLable(Self, '@KillPlay', False, False);
      Result := True;
    end;
  except   
    MainOutMessage(Format('{%s} TPlayObject.KillPlayFunc', [g_sExceptionVer]));
  end;
end;


//人物心法升级触发By TasNat at: 2012-10-17 10:43:43

function TPlayObject.HeartLevelUpFunc: Boolean;
begin
  Result := False;
  if g_FunctionNPC <> nil then begin
    g_FunctionNPC.GotoLable(Self, '@HeartLevelUp', False, False);
    Result := True;
  end;
end;
//20080120 客户端挖尸体东西

function TPlayObject.ClientGetButchItem(BaseObject: TBaseObject; nX, nY: Integer; btDir: Byte; var dwDelayTime: LongWord): Boolean; //004DB7E0
var
  n10, n14: Integer;
  //dwCheckTime: LongWord;
  Butch: Boolean;
  ButchChargeCount, I, K, ButchChargeClass: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  sCheckItemName: string;
  MonItem: pTMonItemInfo;
  nItemCount: Byte; //进入触发段前的包裹物品数量 20080925
  nLevel: Word; //进入触发段前的等级 20081018
  nExp: uInt64; //进入触发段前的经验 20081018
  nGameDiamond, nCreditPoint, nGameGird: Integer; //进入触发段前的金刚石,声望,灵符 20081018
  nCode: Byte; //异常提示
begin
  Result := False;
  if m_boButching then Exit;
  m_boButching := True;
  try
    Butch := False;
    if (BaseObject = nil) or (m_boGhost) or (m_boDeath) then Exit; //20080703 增加人死后不能挖人形物品
    if BaseObject.m_boGhost or BaseObject.m_boAI then Exit;
    if GetTickCount() - BaseObject.m_dwDeathTick > (g_Config.dwMakeGhostPlayMosterTime - 2000) then Exit; //如果快要清理尸体时，则不再进入 20081222
    if (abs(nX - m_nCurrX) > 2) or (abs(nY - m_nCurrY) > 2) or
      (not m_PEnvir.IsValidObject(nX, nY, 2, BaseObject)) or (not BaseObject.m_boDeath) then Exit; //20090217 两格内才能挖
    nCode := 36;
    dwDelayTime := 0;
    nItemCount := 0;
    nLevel := 0;
    nExp := 0;
    nGameDiamond := 0;
    nCreditPoint := 0;
    nGameGird := 0;
    ButchChargeCount := 0;
    try
      case BaseObject.m_btRaceServer of
        78: begin //不攻击怪 20090524
            ButchChargeClass := TNoAttackMon(BaseObject).m_nButchChargeClass;
            nCode := 42;
            if BaseObject.m_boDeath and (not BaseObject.m_boGhost) and (not BaseObject.m_boSkeleton) and (BaseObject.m_Master = nil) and (BaseObject.m_btSlaveMakeLevel = 0) then begin
              nCode := 43;
              ButchChargeCount := TNoAttackMon(BaseObject).m_nButchChargeCount;
              case ButchChargeClass of //挖取身上装备收费模式,并减少人物相应的数值
                0: begin //金币模式
                    if m_nGold >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的金币没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
                1: begin //元宝模式
                    if m_nGameGold >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的' + g_Config.sGameGoldName + '没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
                2: begin //金刚石模式
                    if m_nGAMEDIAMOND >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的' + g_Config.sGameDiaMond + '没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
                3: begin //灵符模式
                    if m_nGAMEGIRD >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的' + g_Config.sGameGird + '没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
              end; //Case
              nCode := 44;
              if not IsEnoughBag then SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
              if Butch and IsEnoughBag then begin //挖所需的条件达到
                case Random(3) of //随机处理挖
                  0: begin //挖取列表中的物品
                      nCode := 45;
                      if (BaseObject <> nil) then begin
                        if BaseObject.m_boGhost then Exit; //20081216
                        if BaseObject.m_boButchSkeleton then Exit; //正在被挖尸体 20090103
                        BaseObject.m_boButchSkeleton := True;
                        try
                          for I := TNoAttackMon(BaseObject).m_ButchItemList.count - 1 downto 0 do begin //20080916 修改
                            if BaseObject.m_boGhost then Exit; //20081216
                            if GetTickCount() - BaseObject.m_dwDeathTick > (g_Config.dwMakeGhostPlayMosterTime - 2000) then Exit; //如果快要清理尸体时，则不再进入 20081222
                            if TNoAttackMon(BaseObject).m_ButchItemList.Count <= 0 then Break; //20080916
                            MonItem := pTMonItemInfo(TNoAttackMon(BaseObject).m_ButchItemList.Items[I]);
                            if PlugOfCheckCanItem(12, MonItem.ItemName, False, 0, 0) then Continue; //检查是否禁止挖取物品 20090221
                            if CompareText(MonItem.ItemName, sSTRING_GOLDNAME) = 0 then begin //如果是金币
                              nCode := 46;
                              m_nGold := m_nGold + MonItem.Count;
                              if MonItem.Count > 0 then begin
                                if g_boGameLogGold then
                                  AddGameDataLog('37' + #9 + m_sMapName + #9 +
                                    IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +
                                    sSTRING_GOLDNAME + #9 + IntToStr(MonItem.Count) + #9 + '1' + #9 + BaseObject.m_sCharName);
                              end;
                              GoldChanged;
                              if BaseObject <> nil then TNoAttackMon(BaseObject).m_ButchItemList.Delete(I); //挖到后,删除对应的物品
                              case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                0: begin //金币模式
                                    if m_nGold >= ButchChargeCount then begin
                                      Dec(m_nGold, ButchChargeCount);
                                    end else m_nGold := 0;
                                    GoldChanged(); //20080414 更新玩家的金币
                                  end;
                                1: begin //元宝模式
                                    if m_nGameGold >= ButchChargeCount then begin
                                      Dec(m_nGameGold, ButchChargeCount);
                                    end else m_nGameGold := 0;
                                    GameGoldChanged; //更新元宝数量  20080414
                                  end;
                                2: begin //金刚石模式
                                    if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                      Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                    end else m_nGAMEDIAMOND := 0;
                                    GameGoldChanged(); //更新金刚石数量 20080414
                                  end;
                                3: begin //灵符模式
                                    if m_nGAMEGIRD >= ButchChargeCount then begin
                                      Dec(m_nGAMEGIRD, ButchChargeCount);
                                    end else m_nGAMEGIRD := 0;
                                    GameGoldChanged(); //更新灵符数量 20080414
                                    m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                    if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                      g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                    end;
                                  end;
                              end; //Case
                              SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //挖尸体得到物品显示
                              Break;
                            end else begin
                              New(UserItem);
                              if UserEngine.CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                                nCode := 47;
                                UserItem.Dura := Round((UserItem.DuraMax / 100) * (20 + Random(80)));
                                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                                if (StdItem.StdMode = 17) or (StdItem.StdMode = 18) then begin //叠加物品,与幸运符全为持久1 20090723
                                  UserItem.Dura := 1;
                                end else
                                  if Random(g_Config.nPlayMonRandomAddValue) = 0 then UserEngine.RandomUpgradeItem(UserItem);
                                nCode := 48;
                                if (UserItem <> nil) then begin
                                  nCode := 49;
                                  case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                    0: begin //金币模式
                                        if m_nGold >= ButchChargeCount then begin
                                          Dec(m_nGold, ButchChargeCount);
                                        end else m_nGold := 0;
                                        GoldChanged(); //20080414 更新玩家的金币
                                      end;
                                    1: begin //元宝模式
                                        if m_nGameGold >= ButchChargeCount then begin
                                          Dec(m_nGameGold, ButchChargeCount);
                                        end else m_nGameGold := 0;
                                        GameGoldChanged; //更新元宝数量  20080414
                                      end;
                                    2: begin //金刚石模式
                                        if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                          Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                        end else m_nGAMEDIAMOND := 0;
                                        GameGoldChanged(); //更新金刚石数量 20080414
                                      end;
                                    3: begin //灵符模式
                                        if m_nGAMEGIRD >= ButchChargeCount then begin
                                          Dec(m_nGAMEGIRD, ButchChargeCount);
                                        end else m_nGAMEGIRD := 0;
                                        GameGoldChanged(); //更新灵符数量 20080414
                                        m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                        if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                          g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                        end;
                                      end;
                                  end; //Case
                                  nCode := 50;
                                  if BaseObject <> nil then TNoAttackMon(BaseObject).m_ButchItemList.Delete(I); //挖到后,删除对应的物品
                                  SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //挖尸体得到物品显示 20080325
                                  sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                                  PlugOfCheckCanItem(7, sCheckItemName, False, 0, 0); //禁止物品规则(管理插件功能) 20080729

                                  if IsEnoughBag then begin //人物的包裹是否满了 20080414
                                    if IsAddWeightAvailable(StdItem.Weight) then begin //人物的负重没有超过
                                      if StdItem.NeedIdentify = 1 then
                                        AddGameDataLog('37' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                          IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 +
                                          IntToStr(UserItem.MakeIndex) + #9 +
                                          '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                                          IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                                          IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                                          IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                                          IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + BaseObject.m_sCharName);
                                      m_ItemList.Add(UserItem);
                                      nCode := 51;
                                      if m_btRaceServer = RC_PLAYOBJECT then begin
                                        nCode := 52;
                                        SendAddItem(UserItem);
                                       //SendUpdateItem(UserItem);//更新物品 20090524 注释
                                      end;
                                      Break; //一次只给玩家一件物品 20080121
                                    end else begin
                                      nCode := 130;
                                      DropItemDown(UserItem, 3, False, False, self, self); //20080610
                                      Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                                      SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                                      Break; //一次只给玩家一件物品 20080121
                                    end;
                                  end else begin
                                    nCode := 53;
                                    DropItemDown(UserItem, 3, False, False, self, self); //20080610
                                    Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                                    SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                                    Break; //一次只给玩家一件物品 20080121
                                  end;
                                end;
                              end else Dispose(UserItem); //if TNoAttackMon(MonItem.ItemName, UserItem) then begin
                            end;
                          end; //for I := TNoAttackMon(BaseObject).m_ItemList.count-1 downto 0 do begin
                        finally
                          BaseObject.m_boButchSkeleton := False;
                        end;
                      end;
                    end; //0
                  else begin //进入触发段
                      if (g_FunctionNPC <> nil) and TNoAttackMon(BaseObject).boIntoTrigger then begin //20080716
                        if g_FunctionNPC.m_boGotoCount < 80 then begin //防止Goto数量过多,引起M2挂死 20081004
                          nItemCount := m_ItemList.Count; //进入触发段前的包裹物品数量 20080925
                          nLevel := m_Abil.Level; //进入触发段前的等级 20081018
                          nExp := m_Abil.nExp; //进入触发段前的经验 20081018
                          nGameDiamond := m_nGAMEDIAMOND; //进入触发段前的金刚石 20081018
                          nCreditPoint := m_btCreditPoint; //进入触发段前的声望 20081018
                          nGameGird := m_nGameGird; //进入触发段前的灵符 20081018
                          g_FunctionNPC.GotoLable(Self, '@ButchCloneItem' + BaseObject.m_sCharName, False, False);
                          if (nItemCount < m_ItemList.Count) or ((nExp < m_Abil.nExp) and (nLevel = m_Abil.Level)) or
                            ((nExp > m_Abil.nExp) and (nLevel < m_Abil.Level)) or (nGameDiamond < m_nGAMEDIAMOND) or
                            (nCreditPoint < m_btCreditPoint) or (nGameGird < m_nGameGird) then begin
                            case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                              0: begin //金币模式
                                  if m_nGold >= ButchChargeCount then begin
                                    Dec(m_nGold, ButchChargeCount);
                                  end else m_nGold := 0;
                                  GoldChanged(); //20080414 更新玩家的金币
                                end;
                              1: begin //元宝模式
                                  if m_nGameGold >= ButchChargeCount then begin
                                    Dec(m_nGameGold, ButchChargeCount);
                                  end else m_nGameGold := 0;
                                  GameGoldChanged; //更新元宝数量  20080414
                                end;
                              2: begin //金刚石模式
                                  if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                    Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                  end else m_nGAMEDIAMOND := 0;
                                  GameGoldChanged(); //更新金刚石数量 20080414
                                end;
                              3: begin //灵符模式
                                  if m_nGAMEGIRD >= ButchChargeCount then begin
                                    Dec(m_nGAMEGIRD, ButchChargeCount);
                                  end else m_nGAMEGIRD := 0;
                                  GameGoldChanged(); //更新灵符数量 20080414
                                  m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                  if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                    g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                  end;
                                end;
                            end; //Case
                            SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //挖尸体得到物品显示 20080607
                          end; //if nItemCount < m_ItemList.Count then begin
                        end;
                      end;
                    end; //1
                end; //case Random(2)
              end; //if Butch then
            end; //if BaseObject.m_boDeath
          end; //78
        121: begin //巨镰蜘蛛 20080810
            ButchChargeClass := TGiantSickleSpiderATMonster(BaseObject).m_nButchChargeClass;
            nCode := 42;
            if BaseObject.m_boDeath and (not BaseObject.m_boGhost) and (not BaseObject.m_boSkeleton) and (BaseObject.m_Master = nil) and (BaseObject.m_btSlaveMakeLevel = 0) then begin
              nCode := 43;
              ButchChargeCount := TGiantSickleSpiderATMonster(BaseObject).m_nButchChargeCount;
              case ButchChargeClass of //挖取身上装备收费模式,并减少人物相应的数值
                0: begin //金币模式
                    if m_nGold >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的金币没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
                1: begin //元宝模式
                    if m_nGameGold >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的' + g_Config.sGameGoldName + '没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
                2: begin //金刚石模式
                    if m_nGAMEDIAMOND >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的' + g_Config.sGameDiaMond + '没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
                3: begin //灵符模式
                    if m_nGAMEGIRD >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的' + g_Config.sGameGird + '没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
              end; //Case
              nCode := 44;
              if not IsEnoughBag then SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint); //20090326
              if Butch and IsEnoughBag then begin //挖所需的条件达到
                case Random(3) of //随机处理挖
                  0: begin //挖取列表中的物品
                      nCode := 45;
                      if (BaseObject <> nil) then begin
                        if BaseObject.m_boGhost then Exit; //20081216
                        if BaseObject.m_boButchSkeleton then Exit; //正在被挖尸体 20090103
                        BaseObject.m_boButchSkeleton := True;
                        try
                          for I := TGiantSickleSpiderATMonster(BaseObject).m_ButchItemList.count - 1 downto 0 do begin //20080916 修改
                            if BaseObject.m_boGhost then Exit; //20081216
                            if GetTickCount() - BaseObject.m_dwDeathTick > (g_Config.dwMakeGhostPlayMosterTime - 2000) then Exit; //如果快要清理尸体时，则不再进入 20081222
                            if TGiantSickleSpiderATMonster(BaseObject).m_ButchItemList.Count <= 0 then Break; //20080916
                            MonItem := pTMonItemInfo(TGiantSickleSpiderATMonster(BaseObject).m_ButchItemList.Items[I]);
                            if PlugOfCheckCanItem(12, MonItem.ItemName, False, 0, 0) then Continue; //检查是否禁止挖取物品 20090221
                            if CompareText(MonItem.ItemName, sSTRING_GOLDNAME) = 0 then begin //如果是金币
                              nCode := 46;
                              m_nGold := m_nGold + MonItem.Count;
                              if MonItem.Count > 0 then begin
                                if g_boGameLogGold then
                                  AddGameDataLog('37' + #9 + m_sMapName + #9 +
                                    IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +
                                    sSTRING_GOLDNAME + #9 + IntToStr(MonItem.Count) + #9 + '1' + #9 + BaseObject.m_sCharName);
                              end;
                              GoldChanged;
                              if BaseObject <> nil then TGiantSickleSpiderATMonster(BaseObject).m_ButchItemList.Delete(I); //挖到后,删除对应的物品
                              case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                0: begin //金币模式
                                    if m_nGold >= ButchChargeCount then begin
                                      Dec(m_nGold, ButchChargeCount);
                                    end else m_nGold := 0;
                                    GoldChanged(); //20080414 更新玩家的金币
                                  end;
                                1: begin //元宝模式
                                    if m_nGameGold >= ButchChargeCount then begin
                                      Dec(m_nGameGold, ButchChargeCount);
                                    end else m_nGameGold := 0;
                                    GameGoldChanged; //更新元宝数量  20080414
                                  end;
                                2: begin //金刚石模式
                                    if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                      Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                    end else m_nGAMEDIAMOND := 0;
                                    GameGoldChanged(); //更新金刚石数量 20080414
                                  end;
                                3: begin //灵符模式
                                    if m_nGAMEGIRD >= ButchChargeCount then begin
                                      Dec(m_nGAMEGIRD, ButchChargeCount);
                                    end else m_nGAMEGIRD := 0;
                                    GameGoldChanged(); //更新灵符数量 20080414
                                    m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                    if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                      g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                    end;
                                  end;
                              end; //Case
                              SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //挖尸体得到物品显示
                              Break;
                            end else begin
                              New(UserItem);
                              if UserEngine.CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                                nCode := 47;
                                UserItem.Dura := Round((UserItem.DuraMax / 100) * (20 + Random(80)));
                                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                                if (StdItem.StdMode = 17) or (StdItem.StdMode = 18) then begin //叠加物品,与幸运符全为持久1 20090723
                                  UserItem.Dura := 1;
                                end else
                                  if Random(g_Config.nPlayMonRandomAddValue) = 0 then UserEngine.RandomUpgradeItem(UserItem);
                                nCode := 48;
                                if (UserItem <> nil) then begin
                                  nCode := 49;
                                  case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                    0: begin //金币模式
                                        if m_nGold >= ButchChargeCount then begin
                                          Dec(m_nGold, ButchChargeCount);
                                        end else m_nGold := 0;
                                        GoldChanged(); //20080414 更新玩家的金币
                                      end;
                                    1: begin //元宝模式
                                        if m_nGameGold >= ButchChargeCount then begin
                                          Dec(m_nGameGold, ButchChargeCount);
                                        end else m_nGameGold := 0;
                                        GameGoldChanged; //更新元宝数量  20080414
                                      end;
                                    2: begin //金刚石模式
                                        if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                          Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                        end else m_nGAMEDIAMOND := 0;
                                        GameGoldChanged(); //更新金刚石数量 20080414
                                      end;
                                    3: begin //灵符模式
                                        if m_nGAMEGIRD >= ButchChargeCount then begin
                                          Dec(m_nGAMEGIRD, ButchChargeCount);
                                        end else m_nGAMEGIRD := 0;
                                        GameGoldChanged(); //更新灵符数量 20080414
                                        m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                        if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                          g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                        end;
                                      end;
                                  end; //Case
                                  nCode := 50;
                                  if BaseObject <> nil then TGiantSickleSpiderATMonster(BaseObject).m_ButchItemList.Delete(I); //挖到后,删除对应的物品
                                  SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //挖尸体得到物品显示 20080325
                                  sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                                  PlugOfCheckCanItem(7, sCheckItemName, False, 0, 0); //禁止物品规则(管理插件功能) 20080729

                                  if IsEnoughBag then begin //人物的包裹是否满了 20080414
                                    if IsAddWeightAvailable(StdItem.Weight) then begin //人物的负重没有超过
                                      if StdItem.NeedIdentify = 1 then
                                        AddGameDataLog('37' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                          IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 +
                                          IntToStr(UserItem.MakeIndex) + #9 +
                                          '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                                          IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                                          IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                                          IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                                          IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + BaseObject.m_sCharName);
                                      m_ItemList.Add(UserItem);
                                      nCode := 51;
                                      if m_btRaceServer = RC_PLAYOBJECT then begin
                                        nCode := 52;
                                        SendAddItem(UserItem);
                                         //SendUpdateItem(UserItem);//更新物品 20090524 注释
                                      end;
                                      Break; //一次只给玩家一件物品 20080121
                                    end else begin
                                      nCode := 130;
                                      DropItemDown(UserItem, 3, False, False, self, self); //20080610
                                      Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                                      SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                                      Break; //一次只给玩家一件物品 20080121
                                    end;
                                  end else begin
                                    nCode := 53;
                                    DropItemDown(UserItem, 3, False, False, self, self); //20080610
                                    Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                                    SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                                    Break; //一次只给玩家一件物品 20080121
                                  end;
                                end;
                              end else Dispose(UserItem); //if CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                            end;
                          end; //for I := TGiantSickleSpiderATMonster(BaseObject).m_ItemList.count-1 downto 0 do begin
                        finally
                          BaseObject.m_boButchSkeleton := False;
                        end;
                      end;
                    end; //0
                  else begin //进入触发段
                      if (g_FunctionNPC <> nil) and TGiantSickleSpiderATMonster(BaseObject).boIntoTrigger then begin //20080716
                        if g_FunctionNPC.m_boGotoCount < 80 then begin //防止Goto数量过多,引起M2挂死 20081004
                          nItemCount := m_ItemList.Count; //进入触发段前的包裹物品数量 20080925
                          nLevel := m_Abil.Level; //进入触发段前的等级 20081018
                          nExp := m_Abil.nExp; //进入触发段前的经验 20081018
                          nGameDiamond := m_nGAMEDIAMOND; //进入触发段前的金刚石 20081018
                          nCreditPoint := m_btCreditPoint; //进入触发段前的声望 20081018
                          nGameGird := m_nGameGird; //进入触发段前的灵符 20081018
                          g_FunctionNPC.GotoLable(Self, '@ButchCloneItem' + BaseObject.m_sCharName, False, False);
                          if (nItemCount < m_ItemList.Count) or ((nExp < m_Abil.nExp) and (nLevel = m_Abil.Level)) or
                            ((nExp > m_Abil.nExp) and (nLevel < m_Abil.Level)) or (nGameDiamond < m_nGAMEDIAMOND) or
                            (nCreditPoint < m_btCreditPoint) or (nGameGird < m_nGameGird) then begin
                            case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                              0: begin //金币模式
                                  if m_nGold >= ButchChargeCount then begin
                                    Dec(m_nGold, ButchChargeCount);
                                  end else m_nGold := 0;
                                  GoldChanged(); //20080414 更新玩家的金币
                                end;
                              1: begin //元宝模式
                                  if m_nGameGold >= ButchChargeCount then begin
                                    Dec(m_nGameGold, ButchChargeCount);
                                  end else m_nGameGold := 0;
                                  GameGoldChanged; //更新元宝数量  20080414
                                end;
                              2: begin //金刚石模式
                                  if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                    Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                  end else m_nGAMEDIAMOND := 0;
                                  GameGoldChanged(); //更新金刚石数量 20080414
                                end;
                              3: begin //灵符模式
                                  if m_nGAMEGIRD >= ButchChargeCount then begin
                                    Dec(m_nGAMEGIRD, ButchChargeCount);
                                  end else m_nGAMEGIRD := 0;
                                  GameGoldChanged(); //更新灵符数量 20080414
                                  m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                  if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                    g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                  end;
                                end;
                            end; //Case
                            SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //挖尸体得到物品显示 20080607
                          end; //if nItemCount < m_ItemList.Count then begin
                        end;
                      end;
                    end; //1
                end; //case Random(2)
              end; //if Butch then
            end; //if BaseObject.m_boDeath
          end; //121
        122: begin //狂热火蜥蜴 20080810
            ButchChargeClass := TSalamanderATMonster(BaseObject).m_nButchChargeClass;
            nCode := 54;
            if BaseObject.m_boDeath and (not BaseObject.m_boGhost) and (not BaseObject.m_boSkeleton) and (BaseObject.m_Master = nil) and (BaseObject.m_btSlaveMakeLevel = 0) then begin
              nCode := 55;
              ButchChargeCount := TSalamanderATMonster(BaseObject).m_nButchChargeCount;
              case ButchChargeClass of //挖取身上装备收费模式,并减少人物相应的数值
                0: begin //金币模式
                    if m_nGold >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的金币没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
                1: begin //元宝模式
                    if m_nGameGold >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的' + g_Config.sGameGoldName + '没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
                2: begin //金刚石模式
                    if m_nGAMEDIAMOND >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的' + g_Config.sGameDiaMond + '没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
                3: begin //灵符模式
                    if m_nGAMEGIRD >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的' + g_Config.sGameGird + '没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
              end; //Case
              nCode := 56;
              if not IsEnoughBag then SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint); //20090326
              if Butch and IsEnoughBag then begin //挖所需的条件达到
                case Random(3) of //随机处理挖
                  0: begin //挖取列表中的物品
                      nCode := 57;
                      if (BaseObject <> nil) then begin
                        if BaseObject.m_boGhost then Exit; //20081216
                        if BaseObject.m_boButchSkeleton then Exit; //正在被挖尸体 20090103
                        BaseObject.m_boButchSkeleton := True;
                        try
                          for I := TSalamanderATMonster(BaseObject).m_ButchItemList.count - 1 downto 0 do begin //20080916 修改
                            if BaseObject.m_boGhost then Exit; //20081216
                            if GetTickCount() - BaseObject.m_dwDeathTick > (g_Config.dwMakeGhostPlayMosterTime - 2000) then Exit; //如果快要清理尸体时，则不再进入 20081222
                            if TSalamanderATMonster(BaseObject).m_ButchItemList.count <= 0 then Break; //20080916
                            MonItem := pTMonItemInfo(TSalamanderATMonster(BaseObject).m_ButchItemList.Items[I]);
                            if PlugOfCheckCanItem(12, MonItem.ItemName, False, 0, 0) then Continue; //检查是否禁止挖取物品 20090221
                            if CompareText(MonItem.ItemName, sSTRING_GOLDNAME) = 0 then begin //如果是金币
                              nCode := 58;
                              m_nGold := m_nGold + MonItem.Count;
                              if MonItem.Count > 0 then begin
                                if g_boGameLogGold then
                                  AddGameDataLog('37' + #9 + m_sMapName + #9 +
                                    IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +
                                    sSTRING_GOLDNAME + #9 + IntToStr(MonItem.Count) + #9 + '1' + #9 + BaseObject.m_sCharName);
                              end;
                              GoldChanged;
                              if BaseObject <> nil then TSalamanderATMonster(BaseObject).m_ButchItemList.Delete(I); //挖到后,删除对应的物品
                              case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                0: begin //金币模式
                                    if m_nGold >= ButchChargeCount then begin
                                      Dec(m_nGold, ButchChargeCount);
                                    end else m_nGold := 0;
                                    GoldChanged(); //20080414 更新玩家的金币
                                  end;
                                1: begin //元宝模式
                                    if m_nGameGold >= ButchChargeCount then begin
                                      Dec(m_nGameGold, ButchChargeCount);
                                    end else m_nGameGold := 0;
                                    GameGoldChanged; //更新元宝数量  20080414
                                  end;
                                2: begin //金刚石模式
                                    if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                      Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                    end else m_nGAMEDIAMOND := 0;
                                    GameGoldChanged(); //更新金刚石数量 20080414
                                  end;
                                3: begin //灵符模式
                                    if m_nGAMEGIRD >= ButchChargeCount then begin
                                      Dec(m_nGAMEGIRD, ButchChargeCount);
                                    end else m_nGAMEGIRD := 0;
                                    GameGoldChanged(); //更新灵符数量 20080414
                                    m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                    if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                      g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                    end;
                                  end;
                              end; //Case
                              SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //挖尸体得到物品显示
                              Break;
                            end else begin
                              New(UserItem);
                              if UserEngine.CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                                nCode := 59;
                                UserItem.Dura := Round((UserItem.DuraMax / 100) * (20 + Random(80)));
                                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                                if (StdItem.StdMode = 17) or (StdItem.StdMode = 18) then begin //叠加物品,与幸运符全为持久1 20090723
                                  UserItem.Dura := 1;
                                end else
                                  if Random(g_Config.nPlayMonRandomAddValue) = 0 then UserEngine.RandomUpgradeItem(UserItem);
                                nCode := 60;
                                if (UserItem <> nil) then begin
                                  nCode := 61;
                                  case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                    0: begin //金币模式
                                        if m_nGold >= ButchChargeCount then begin
                                          Dec(m_nGold, ButchChargeCount);
                                        end else m_nGold := 0;
                                        GoldChanged(); //20080414 更新玩家的金币
                                      end;
                                    1: begin //元宝模式
                                        if m_nGameGold >= ButchChargeCount then begin
                                          Dec(m_nGameGold, ButchChargeCount);
                                        end else m_nGameGold := 0;
                                        GameGoldChanged; //更新元宝数量  20080414
                                      end;
                                    2: begin //金刚石模式
                                        if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                          Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                        end else m_nGAMEDIAMOND := 0;
                                        GameGoldChanged(); //更新金刚石数量 20080414
                                      end;
                                    3: begin //灵符模式
                                        if m_nGAMEGIRD >= ButchChargeCount then begin
                                          Dec(m_nGAMEGIRD, ButchChargeCount);
                                        end else m_nGAMEGIRD := 0;
                                        GameGoldChanged(); //更新灵符数量 20080414
                                        m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                        if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                          g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                        end;
                                      end;
                                  end; //Case
                                  nCode := 62;
                                  if BaseObject <> nil then TSalamanderATMonster(BaseObject).m_ButchItemList.Delete(I); //挖到后,删除对应的物品
                                  SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //挖尸体得到物品显示 20080325
                                  sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                                  PlugOfCheckCanItem(7, sCheckItemName, False, 0, 0); //禁止物品规则(管理插件功能) 20080729

                                  if IsEnoughBag then begin //人物的包裹是否满了 20080414
                                    if IsAddWeightAvailable(StdItem.Weight) then begin //人物的负重没有超过
                                      if StdItem.NeedIdentify = 1 then
                                        AddGameDataLog('37' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                          IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 +
                                          IntToStr(UserItem.MakeIndex) + #9 +
                                          '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                                          IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                                          IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                                          IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                                          IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + BaseObject.m_sCharName);
                                      m_ItemList.Add(UserItem);
                                      nCode := 63;
                                      if m_btRaceServer = RC_PLAYOBJECT then begin
                                        nCode := 64;
                                        SendAddItem(UserItem);
                                         //SendUpdateItem(UserItem);//更新物品 20090524 注释
                                      end;
                                      Break; //一次只给玩家一件物品 20080121
                                    end else begin
                                      nCode := 140;
                                      DropItemDown(UserItem, 3, False, False, self, self); //20080610
                                      Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                                      SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                                      Break; //一次只给玩家一件物品 20080121
                                    end;
                                  end else begin
                                    nCode := 63;
                                    DropItemDown(UserItem, 3, False, False, self, self); //20080610
                                    Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                                    SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                                    Break; //一次只给玩家一件物品 20080121
                                  end;
                                end;
                              end else Dispose(UserItem); //if CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                            end;
                          end; //for I :=TSalamanderATMonster(BaseObject).m_ItemList.count-1 downto 0 do begin
                        finally
                          BaseObject.m_boButchSkeleton := False;
                        end;
                      end;
                    end; //0
                  else begin //进入触发段
                      if (g_FunctionNPC <> nil) and TSalamanderATMonster(BaseObject).boIntoTrigger then begin //20080716
                        if g_FunctionNPC.m_boGotoCount < 80 then begin //防止Goto数量过多,引起M2挂死 20081004
                          nItemCount := m_ItemList.Count; //进入触发段前的包裹物品数量 20080925
                          nLevel := m_Abil.Level; //进入触发段前的等级 20081018
                          nExp := m_Abil.nExp; //进入触发段前的经验 20081018
                          nGameDiamond := m_nGAMEDIAMOND; //进入触发段前的金刚石 20081018
                          nCreditPoint := m_btCreditPoint; //进入触发段前的声望 20081018
                          nGameGird := m_nGameGird; //进入触发段前的灵符 20081018
                          g_FunctionNPC.GotoLable(Self, '@ButchCloneItem' + BaseObject.m_sCharName, False, False);
                          if (nItemCount < m_ItemList.Count) or ((nExp < m_Abil.nExp) and (nLevel = m_Abil.Level)) or
                            ((nExp > m_Abil.nExp) and (nLevel < m_Abil.Level)) or (nGameDiamond < m_nGAMEDIAMOND) or
                            (nCreditPoint < m_btCreditPoint) or (nGameGird < m_nGameGird) then begin
                            case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                              0: begin //金币模式
                                  if m_nGold >= ButchChargeCount then begin
                                    Dec(m_nGold, ButchChargeCount);
                                  end else m_nGold := 0;
                                  GoldChanged(); //20080414 更新玩家的金币
                                end;
                              1: begin //元宝模式
                                  if m_nGameGold >= ButchChargeCount then begin
                                    Dec(m_nGameGold, ButchChargeCount);
                                  end else m_nGameGold := 0;
                                  GameGoldChanged; //更新元宝数量  20080414
                                end;
                              2: begin //金刚石模式
                                  if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                    Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                  end else m_nGAMEDIAMOND := 0;
                                  GameGoldChanged(); //更新金刚石数量 20080414
                                end;
                              3: begin //灵符模式
                                  if m_nGAMEGIRD >= ButchChargeCount then begin
                                    Dec(m_nGAMEGIRD, ButchChargeCount);
                                  end else m_nGAMEGIRD := 0;
                                  GameGoldChanged(); //更新灵符数量 20080414
                                  m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                  if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                    g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                  end;
                                end;
                            end; //Case
                            SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //挖尸体得到物品显示 20080607
                          end;
                        end;
                      end;
                    end; //1
                end; //case Random(2)
              end; //if Butch then
            end; //if BaseObject.m_boDeath
          end; //122
        123: begin //圣殿卫士 20080810
            ButchChargeClass := TTempleGuardian(BaseObject).m_nButchChargeClass;
            nCode := 66;
            if BaseObject.m_boDeath and (not BaseObject.m_boGhost) and (not BaseObject.m_boSkeleton) and (BaseObject.m_Master = nil) and (BaseObject.m_btSlaveMakeLevel = 0) then begin
              nCode := 67;
              ButchChargeCount := TTempleGuardian(BaseObject).m_nButchChargeCount;
              case ButchChargeClass of //挖取身上装备收费模式,并减少人物相应的数值
                0: begin //金币模式
                    if m_nGold >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的金币没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
                1: begin //元宝模式
                    if m_nGameGold >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的' + g_Config.sGameGoldName + '没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
                2: begin //金刚石模式
                    if m_nGAMEDIAMOND >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的' + g_Config.sGameDiaMond + '没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
                3: begin //灵符模式
                    if m_nGAMEGIRD >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的' + g_Config.sGameGird + '没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
              end; //Case
              nCode := 68;
              if not IsEnoughBag then SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint); //20090326
              if Butch and IsEnoughBag then begin //挖所需的条件达到
                case Random(3) of //随机处理挖
                  0: begin //挖取列表中的物品
                      nCode := 69;
                      if (BaseObject <> nil) then begin
                        if BaseObject.m_boGhost then Exit; //20081216
                        if BaseObject.m_boButchSkeleton then Exit; //正在被挖尸体 20090103
                        BaseObject.m_boButchSkeleton := True;
                        try
                          for I := TTempleGuardian(BaseObject).m_ButchItemList.count - 1 downto 0 do begin //20080916 修改
                            if BaseObject.m_boGhost then Exit; //20081216
                            if GetTickCount() - BaseObject.m_dwDeathTick > (g_Config.dwMakeGhostPlayMosterTime - 2000) then Exit; //如果快要清理尸体时，则不再进入 20081222
                            if TTempleGuardian(BaseObject).m_ButchItemList.count <= 0 then Break; //20080916
                            MonItem := pTMonItemInfo(TTempleGuardian(BaseObject).m_ButchItemList.Items[I]);
                            if PlugOfCheckCanItem(12, MonItem.ItemName, False, 0, 0) then Continue; //检查是否禁止挖取物品 20090221
                            if CompareText(MonItem.ItemName, sSTRING_GOLDNAME) = 0 then begin //如果是金币
                              nCode := 70;
                              m_nGold := m_nGold + MonItem.Count;
                              if MonItem.Count > 0 then begin
                                if g_boGameLogGold then
                                  AddGameDataLog('37' + #9 + m_sMapName + #9 +
                                    IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +
                                    sSTRING_GOLDNAME + #9 + IntToStr(MonItem.Count) + #9 + '1' + #9 + BaseObject.m_sCharName);
                              end;
                              GoldChanged;
                              if BaseObject <> nil then TTempleGuardian(BaseObject).m_ButchItemList.Delete(I); //挖到后,删除对应的物品
                              case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                0: begin //金币模式
                                    if m_nGold >= ButchChargeCount then begin
                                      Dec(m_nGold, ButchChargeCount);
                                    end else m_nGold := 0;
                                    GoldChanged(); //20080414 更新玩家的金币
                                  end;
                                1: begin //元宝模式
                                    if m_nGameGold >= ButchChargeCount then begin
                                      Dec(m_nGameGold, ButchChargeCount);
                                    end else m_nGameGold := 0;
                                    GameGoldChanged; //更新元宝数量  20080414
                                  end;
                                2: begin //金刚石模式
                                    if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                      Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                    end else m_nGAMEDIAMOND := 0;
                                    GameGoldChanged(); //更新金刚石数量 20080414
                                  end;
                                3: begin //灵符模式
                                    if m_nGAMEGIRD >= ButchChargeCount then begin
                                      Dec(m_nGAMEGIRD, ButchChargeCount);
                                    end else m_nGAMEGIRD := 0;
                                    GameGoldChanged(); //更新灵符数量 20080414
                                    m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                    if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                      g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                    end;
                                  end;
                              end; //Case
                              SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //挖尸体得到物品显示
                              Break;
                            end else begin
                              New(UserItem);
                              if UserEngine.CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                                nCode := 71;
                                UserItem.Dura := Round((UserItem.DuraMax / 100) * (20 + Random(80)));
                                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                                if (StdItem.StdMode = 17) or (StdItem.StdMode = 18) then begin //叠加物品,与幸运符全为持久1 20090723
                                  UserItem.Dura := 1;
                                end else
                                  if Random(g_Config.nPlayMonRandomAddValue) = 0 then UserEngine.RandomUpgradeItem(UserItem);
                                nCode := 72;
                                if (UserItem <> nil) then begin
                                  nCode := 73;
                                  case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                    0: begin //金币模式
                                        if m_nGold >= ButchChargeCount then begin
                                          Dec(m_nGold, ButchChargeCount);
                                        end else m_nGold := 0;
                                        GoldChanged(); //20080414 更新玩家的金币
                                      end;
                                    1: begin //元宝模式
                                        if m_nGameGold >= ButchChargeCount then begin
                                          Dec(m_nGameGold, ButchChargeCount);
                                        end else m_nGameGold := 0;
                                        GameGoldChanged; //更新元宝数量  20080414
                                      end;
                                    2: begin //金刚石模式
                                        if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                          Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                        end else m_nGAMEDIAMOND := 0;
                                        GameGoldChanged(); //更新金刚石数量 20080414
                                      end;
                                    3: begin //灵符模式
                                        if m_nGAMEGIRD >= ButchChargeCount then begin
                                          Dec(m_nGAMEGIRD, ButchChargeCount);
                                        end else m_nGAMEGIRD := 0;
                                        GameGoldChanged(); //更新灵符数量 20080414
                                        m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                        if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                          g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                        end;
                                      end;
                                  end; //Case
                                  nCode := 74;
                                  if BaseObject <> nil then TTempleGuardian(BaseObject).m_ButchItemList.Delete(I); //挖到后,删除对应的物品
                                  SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //挖尸体得到物品显示 20080325
                                  sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                                  PlugOfCheckCanItem(7, sCheckItemName, False, 0, 0); //禁止物品规则(管理插件功能) 20080729

                                  if IsEnoughBag then begin //人物的包裹是否满了 20080414
                                    if IsAddWeightAvailable(StdItem.Weight) then begin //人物的负重没有超过
                                      if StdItem.NeedIdentify = 1 then
                                        AddGameDataLog('37' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                          IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 +
                                          IntToStr(UserItem.MakeIndex) + #9 +
                                          '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                                          IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                                          IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                                          IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                                          IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + BaseObject.m_sCharName);
                                      m_ItemList.Add(UserItem);
                                      nCode := 75;
                                      if m_btRaceServer = RC_PLAYOBJECT then begin
                                        nCode := 76;
                                        SendAddItem(UserItem);
                                         //SendUpdateItem(UserItem);//更新物品 20090524 注释
                                      end;
                                      Break; //一次只给玩家一件物品 20080121
                                    end else begin
                                      nCode := 177;
                                      DropItemDown(UserItem, 3, False, False, self, self); //20080610
                                      Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                                      SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                                      Break; //一次只给玩家一件物品 20080121
                                    end;
                                  end else begin
                                    nCode := 77;
                                    DropItemDown(UserItem, 3, False, False, self, self); //20080610
                                    Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                                    SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                                    Break; //一次只给玩家一件物品 20080121
                                  end;
                                end;
                              end else Dispose(UserItem); //if CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                            end;
                          end; //for I := TTempleGuardian(BaseObject).m_ItemList.count-1 downto 0 do begin
                        finally
                          BaseObject.m_boButchSkeleton := False;
                        end;
                      end;
                    end; //0
                  else begin //进入触发段
                      if (g_FunctionNPC <> nil) and TTempleGuardian(BaseObject).boIntoTrigger then begin //20080716
                        if g_FunctionNPC.m_boGotoCount < 80 then begin //防止Goto数量过多,引起M2挂死 20081004
                          nItemCount := m_ItemList.Count; //进入触发段前的包裹物品数量 20080925
                          nLevel := m_Abil.Level; //进入触发段前的等级 20081018
                          nExp := m_Abil.nExp; //进入触发段前的经验 20081018
                          nGameDiamond := m_nGAMEDIAMOND; //进入触发段前的金刚石 20081018
                          nCreditPoint := m_btCreditPoint; //进入触发段前的声望 20081018
                          nGameGird := m_nGameGird; //进入触发段前的灵符 20081018
                          g_FunctionNPC.GotoLable(Self, '@ButchCloneItem' + BaseObject.m_sCharName, False, False);
                          if (nItemCount < m_ItemList.Count) or ((nExp < m_Abil.nExp) and (nLevel = m_Abil.Level)) or
                            ((nExp > m_Abil.nExp) and (nLevel < m_Abil.Level)) or (nGameDiamond < m_nGAMEDIAMOND) or
                            (nCreditPoint < m_btCreditPoint) or (nGameGird < m_nGameGird) then begin
                            case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                              0: begin //金币模式
                                  if m_nGold >= ButchChargeCount then begin
                                    Dec(m_nGold, ButchChargeCount);
                                  end else m_nGold := 0;
                                  GoldChanged(); //20080414 更新玩家的金币
                                end;
                              1: begin //元宝模式
                                  if m_nGameGold >= ButchChargeCount then begin
                                    Dec(m_nGameGold, ButchChargeCount);
                                  end else m_nGameGold := 0;
                                  GameGoldChanged; //更新元宝数量  20080414
                                end;
                              2: begin //金刚石模式
                                  if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                    Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                  end else m_nGAMEDIAMOND := 0;
                                  GameGoldChanged(); //更新金刚石数量 20080414
                                end;
                              3: begin //灵符模式
                                  if m_nGAMEGIRD >= ButchChargeCount then begin
                                    Dec(m_nGAMEGIRD, ButchChargeCount);
                                  end else m_nGAMEGIRD := 0;
                                  GameGoldChanged(); //更新灵符数量 20080414
                                  m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                  if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                    g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                  end;
                                end;
                            end; //Case
                            SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //挖尸体得到物品显示 20080607
                          end;
                        end;
                      end;
                    end; //1
                end; //case Random(2)
              end; //if Butch then
            end; //if BaseObject.m_boDeath
          end; //123
        124: begin //金杖蜘蛛 20080810
            ButchChargeClass := TheCrutchesSpider(BaseObject).m_nButchChargeClass;
            nCode := 78;
            if BaseObject.m_boDeath and (not BaseObject.m_boGhost) and (not BaseObject.m_boSkeleton) and (BaseObject.m_Master = nil) and (BaseObject.m_btSlaveMakeLevel = 0) then begin
              nCode := 79;
              ButchChargeCount := TheCrutchesSpider(BaseObject).m_nButchChargeCount;
              case ButchChargeClass of //挖取身上装备收费模式,并减少人物相应的数值
                0: begin //金币模式
                    if m_nGold >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的金币没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
                1: begin //元宝模式
                    if m_nGameGold >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的' + g_Config.sGameGoldName + '没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
                2: begin //金刚石模式
                    if m_nGAMEDIAMOND >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的' + g_Config.sGameDiaMond + '没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
                3: begin //灵符模式
                    if m_nGAMEGIRD >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的' + g_Config.sGameGird + '没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
              end; //Case
              nCode := 80;
              if not IsEnoughBag then SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint); //20090326
              if Butch and IsEnoughBag then begin //挖所需的条件达到
                case Random(3) of //随机处理挖
                  0: begin //挖取列表中的物品
                      nCode := 81;
                      if (BaseObject <> nil) then begin
                        if BaseObject.m_boGhost then Exit; //20081216
                        if BaseObject.m_boButchSkeleton then Exit; //正在被挖尸体 20090103
                        BaseObject.m_boButchSkeleton := True;
                        try
                          for I := TheCrutchesSpider(BaseObject).m_ButchItemList.count - 1 downto 0 do begin //20080916 修改
                            if BaseObject.m_boGhost then Exit; //20081216
                            if GetTickCount() - BaseObject.m_dwDeathTick > (g_Config.dwMakeGhostPlayMosterTime - 2000) then Exit; //如果快要清理尸体时，则不再进入 20081222
                            if TheCrutchesSpider(BaseObject).m_ButchItemList.count <= 0 then Break; //20080916
                            MonItem := pTMonItemInfo(TheCrutchesSpider(BaseObject).m_ButchItemList.Items[I]);
                            if PlugOfCheckCanItem(12, MonItem.ItemName, False, 0, 0) then Continue; //检查是否禁止挖取物品 20090221
                            if CompareText(MonItem.ItemName, sSTRING_GOLDNAME) = 0 then begin //如果是金币
                              nCode := 82;
                              m_nGold := m_nGold + MonItem.Count;
                              if MonItem.Count > 0 then begin
                                if g_boGameLogGold then
                                  AddGameDataLog('37' + #9 + m_sMapName + #9 +
                                    IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +
                                    sSTRING_GOLDNAME + #9 + IntToStr(MonItem.Count) + #9 + '1' + #9 + BaseObject.m_sCharName);
                              end;
                              GoldChanged;
                              if BaseObject <> nil then TheCrutchesSpider(BaseObject).m_ButchItemList.Delete(I); //挖到后,删除对应的物品
                              case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                0: begin //金币模式
                                    if m_nGold >= ButchChargeCount then begin
                                      Dec(m_nGold, ButchChargeCount);
                                    end else m_nGold := 0;
                                    GoldChanged(); //20080414 更新玩家的金币
                                  end;
                                1: begin //元宝模式
                                    if m_nGameGold >= ButchChargeCount then begin
                                      Dec(m_nGameGold, ButchChargeCount);
                                    end else m_nGameGold := 0;
                                    GameGoldChanged; //更新元宝数量  20080414
                                  end;
                                2: begin //金刚石模式
                                    if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                      Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                    end else m_nGAMEDIAMOND := 0;
                                    GameGoldChanged(); //更新金刚石数量 20080414
                                  end;
                                3: begin //灵符模式
                                    if m_nGAMEGIRD >= ButchChargeCount then begin
                                      Dec(m_nGAMEGIRD, ButchChargeCount);
                                    end else m_nGAMEGIRD := 0;
                                    GameGoldChanged(); //更新灵符数量 20080414
                                    m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                    if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                      g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                    end;
                                  end;
                              end; //Case
                              SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //挖尸体得到物品显示
                              Break;
                            end else begin
                              New(UserItem);
                              if UserEngine.CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                                nCode := 83;
                                UserItem.Dura := Round((UserItem.DuraMax / 100) * (20 + Random(80)));
                                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                                if (StdItem.StdMode = 17) or (StdItem.StdMode = 18) then begin //叠加物品,与幸运符全为持久1 20090723
                                  UserItem.Dura := 1;
                                end else
                                  if Random(g_Config.nPlayMonRandomAddValue) = 0 then UserEngine.RandomUpgradeItem(UserItem);
                                nCode := 84;
                                if (UserItem <> nil) then begin
                                  nCode := 85;
                                  case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                    0: begin //金币模式
                                        if m_nGold >= ButchChargeCount then begin
                                          Dec(m_nGold, ButchChargeCount);
                                        end else m_nGold := 0;
                                        GoldChanged(); //20080414 更新玩家的金币
                                      end;
                                    1: begin //元宝模式
                                        if m_nGameGold >= ButchChargeCount then begin
                                          Dec(m_nGameGold, ButchChargeCount);
                                        end else m_nGameGold := 0;
                                        GameGoldChanged; //更新元宝数量  20080414
                                      end;
                                    2: begin //金刚石模式
                                        if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                          Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                        end else m_nGAMEDIAMOND := 0;
                                        GameGoldChanged(); //更新金刚石数量 20080414
                                      end;
                                    3: begin //灵符模式
                                        if m_nGAMEGIRD >= ButchChargeCount then begin
                                          Dec(m_nGAMEGIRD, ButchChargeCount);
                                        end else m_nGAMEGIRD := 0;
                                        GameGoldChanged(); //更新灵符数量 20080414
                                        m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                        if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                          g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                        end;
                                      end;
                                  end; //Case
                                  nCode := 86;
                                  if BaseObject <> nil then TheCrutchesSpider(BaseObject).m_ButchItemList.Delete(I); //挖到后,删除对应的物品
                                  SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //挖尸体得到物品显示 20080325
                                  sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                                  PlugOfCheckCanItem(7, sCheckItemName, False, 0, 0); //禁止物品规则(管理插件功能) 20080729

                                  if IsEnoughBag then begin //人物的包裹是否满了 20080414
                                    if IsAddWeightAvailable(StdItem.Weight) then begin //人物的负重没有超过
                                      if StdItem.NeedIdentify = 1 then
                                        AddGameDataLog('37' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                          IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 +
                                          IntToStr(UserItem.MakeIndex) + #9 +
                                          '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                                          IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                                          IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                                          IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                                          IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + BaseObject.m_sCharName);
                                      m_ItemList.Add(UserItem);
                                      nCode := 87;
                                      if m_btRaceServer = RC_PLAYOBJECT then begin
                                        nCode := 88;
                                        SendAddItem(UserItem);
                                         //SendUpdateItem(UserItem);//更新物品 20090524 注释
                                      end;
                                      Break; //一次只给玩家一件物品 20080121
                                    end else begin
                                      nCode := 180;
                                      DropItemDown(UserItem, 3, False, False, self, self); //20080610
                                      Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                                      SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                                      Break; //一次只给玩家一件物品 20080121
                                    end;
                                  end else begin
                                    nCode := 89;
                                    DropItemDown(UserItem, 3, False, False, self, self); //20080610
                                    Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                                    SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                                    Break; //一次只给玩家一件物品 20080121
                                  end;
                                end;
                              end else Dispose(UserItem); //if CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                            end;
                          end; //for I := TheCrutchesSpider(BaseObject).m_ItemList.count-1 downto 0 do begin
                        finally
                          BaseObject.m_boButchSkeleton := False;
                        end;
                      end;
                    end; //0
                  else begin //进入触发段
                      if (g_FunctionNPC <> nil) and TheCrutchesSpider(BaseObject).boIntoTrigger then begin //20080716
                        if g_FunctionNPC.m_boGotoCount < 80 then begin //防止Goto数量过多,引起M2挂死 20081004
                          nItemCount := m_ItemList.Count; //进入触发段前的包裹物品数量 20080925
                          nLevel := m_Abil.Level; //进入触发段前的等级 20081018
                          nExp := m_Abil.nExp; //进入触发段前的经验 20081018
                          nGameDiamond := m_nGAMEDIAMOND; //进入触发段前的金刚石 20081018
                          nCreditPoint := m_btCreditPoint; //进入触发段前的声望 20081018
                          nGameGird := m_nGameGird; //进入触发段前的灵符 20081018
                          g_FunctionNPC.GotoLable(Self, '@ButchCloneItem' + BaseObject.m_sCharName, False, False);
                          if (nItemCount < m_ItemList.Count) or ((nExp < m_Abil.nExp) and (nLevel = m_Abil.Level)) or
                            ((nExp > m_Abil.nExp) and (nLevel < m_Abil.Level)) or (nGameDiamond < m_nGAMEDIAMOND) or
                            (nCreditPoint < m_btCreditPoint) or (nGameGird < m_nGameGird) then begin
                            case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                              0: begin //金币模式
                                  if m_nGold >= ButchChargeCount then begin
                                    Dec(m_nGold, ButchChargeCount);
                                  end else m_nGold := 0;
                                  GoldChanged(); //20080414 更新玩家的金币
                                end;
                              1: begin //元宝模式
                                  if m_nGameGold >= ButchChargeCount then begin
                                    Dec(m_nGameGold, ButchChargeCount);
                                  end else m_nGameGold := 0;
                                  GameGoldChanged; //更新元宝数量  20080414
                                end;
                              2: begin //金刚石模式
                                  if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                    Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                  end else m_nGAMEDIAMOND := 0;
                                  GameGoldChanged(); //更新金刚石数量 20080414
                                end;
                              3: begin //灵符模式
                                  if m_nGAMEGIRD >= ButchChargeCount then begin
                                    Dec(m_nGAMEGIRD, ButchChargeCount);
                                  end else m_nGAMEGIRD := 0;
                                  GameGoldChanged(); //更新灵符数量 20080414
                                  m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                  if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                    g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                  end;
                                end;
                            end; //Case
                            SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //挖尸体得到物品显示 20080607
                          end;
                        end;
                      end;
                    end; //1
                end; //case Random(2)
              end; //if Butch then
            end; //if BaseObject.m_boDeath
          end; //124
        125: begin //雷炎蛛王 20080811
            ButchChargeClass := TYanLeiWangSpider(BaseObject).m_nButchChargeClass;
            nCode := 90;
            if BaseObject.m_boDeath and (not BaseObject.m_boGhost) and (not BaseObject.m_boSkeleton) and (BaseObject.m_Master = nil) and (BaseObject.m_btSlaveMakeLevel = 0) then begin
              nCode := 91;
              ButchChargeCount := TYanLeiWangSpider(BaseObject).m_nButchChargeCount;
              case ButchChargeClass of //挖取身上装备收费模式,并减少人物相应的数值
                0: begin //金币模式
                    if m_nGold >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的金币没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
                1: begin //元宝模式
                    if m_nGameGold >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的' + g_Config.sGameGoldName + '没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
                2: begin //金刚石模式
                    if m_nGAMEDIAMOND >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的' + g_Config.sGameDiaMond + '没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
                3: begin //灵符模式
                    if m_nGAMEGIRD >= ButchChargeCount then begin
                      Butch := True;
                    end else SysMsg('您的' + g_Config.sGameGird + '没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                  end;
              end; //Case
              nCode := 80;
              if not IsEnoughBag then SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint); //20090326
              if Butch and IsEnoughBag then begin //挖所需的条件达到
                case Random(3) of //随机处理挖
                  0: begin //挖取列表中的物品
                      nCode := 92;
                      if (BaseObject <> nil) then begin
                        if BaseObject.m_boGhost then Exit; //20081216
                        if BaseObject.m_boButchSkeleton then Exit; //正在被挖尸体 20090103
                        BaseObject.m_boButchSkeleton := True;
                        try
                          for I := TYanLeiWangSpider(BaseObject).m_ButchItemList.count - 1 downto 0 do begin //20080916
                            if BaseObject.m_boGhost then Exit; //20081216
                            if GetTickCount() - BaseObject.m_dwDeathTick > (g_Config.dwMakeGhostPlayMosterTime - 2000) then Exit; //如果快要清理尸体时，则不再进入 20081222
                            if TYanLeiWangSpider(BaseObject).m_ButchItemList.count <= 0 then Break; //20080916
                            MonItem := pTMonItemInfo(TYanLeiWangSpider(BaseObject).m_ButchItemList.Items[I]);
                            if PlugOfCheckCanItem(12, MonItem.ItemName, False, 0, 0) then Continue; //检查是否禁止挖取物品 20090221
                            if CompareText(MonItem.ItemName, sSTRING_GOLDNAME) = 0 then begin //如果是金币
                              nCode := 94;
                              m_nGold := m_nGold + MonItem.Count;
                              if MonItem.Count > 0 then begin
                                if g_boGameLogGold then
                                  AddGameDataLog('37' + #9 + m_sMapName + #9 +
                                    IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +
                                    sSTRING_GOLDNAME + #9 + IntToStr(MonItem.Count) + #9 + '1' + #9 + BaseObject.m_sCharName);
                              end;
                              GoldChanged;
                              if BaseObject <> nil then TYanLeiWangSpider(BaseObject).m_ButchItemList.Delete(I); //挖到后,删除对应的物品
                              case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                0: begin //金币模式
                                    if m_nGold >= ButchChargeCount then begin
                                      Dec(m_nGold, ButchChargeCount);
                                    end else m_nGold := 0;
                                    GoldChanged(); //20080414 更新玩家的金币
                                  end;
                                1: begin //元宝模式
                                    if m_nGameGold >= ButchChargeCount then begin
                                      Dec(m_nGameGold, ButchChargeCount);
                                    end else m_nGameGold := 0;
                                    GameGoldChanged; //更新元宝数量  20080414
                                  end;
                                2: begin //金刚石模式
                                    if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                      Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                    end else m_nGAMEDIAMOND := 0;
                                    GameGoldChanged(); //更新金刚石数量 20080414
                                  end;
                                3: begin //灵符模式
                                    if m_nGAMEGIRD >= ButchChargeCount then begin
                                      Dec(m_nGAMEGIRD, ButchChargeCount);
                                    end else m_nGAMEGIRD := 0;
                                    GameGoldChanged(); //更新灵符数量 20080414
                                    m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                    if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                      g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                    end;
                                  end;
                              end; //Case
                              SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //挖尸体得到物品显示
                              Break;
                            end else begin
                              New(UserItem);
                              if UserEngine.CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                                nCode := 95;
                                UserItem.Dura := Round((UserItem.DuraMax / 100) * (20 + Random(80)));
                                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                                if (StdItem.StdMode = 17) or (StdItem.StdMode = 18) then begin //叠加物品,与幸运符全为持久1 20090723
                                  UserItem.Dura := 1;
                                end else
                                  if Random(g_Config.nPlayMonRandomAddValue) = 0 then UserEngine.RandomUpgradeItem(UserItem);
                                nCode := 96;
                                if (UserItem <> nil) then begin
                                  nCode := 97;
                                  case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                    0: begin //金币模式
                                        if m_nGold >= ButchChargeCount then begin
                                          Dec(m_nGold, ButchChargeCount);
                                        end else m_nGold := 0;
                                        GoldChanged(); //20080414 更新玩家的金币
                                      end;
                                    1: begin //元宝模式
                                        if m_nGameGold >= ButchChargeCount then begin
                                          Dec(m_nGameGold, ButchChargeCount);
                                        end else m_nGameGold := 0;
                                        GameGoldChanged; //更新元宝数量  20080414
                                      end;
                                    2: begin //金刚石模式
                                        if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                          Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                        end else m_nGAMEDIAMOND := 0;
                                        GameGoldChanged(); //更新金刚石数量 20080414
                                      end;
                                    3: begin //灵符模式
                                        if m_nGAMEGIRD >= ButchChargeCount then begin
                                          Dec(m_nGAMEGIRD, ButchChargeCount);
                                        end else m_nGAMEGIRD := 0;
                                        GameGoldChanged(); //更新灵符数量 20080414
                                        m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                        if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                          g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                        end;
                                      end;
                                  end; //Case
                                  nCode := 98;
                                  if BaseObject <> nil then TYanLeiWangSpider(BaseObject).m_ButchItemList.Delete(I); //挖到后,删除对应的物品
                                  SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //挖尸体得到物品显示 20080325
                                  sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                                  PlugOfCheckCanItem(7, sCheckItemName, False, 0, 0); //禁止物品规则(管理插件功能) 20080729

                                  if IsEnoughBag then begin //人物的包裹是否满了 20080414
                                    if IsAddWeightAvailable(StdItem.Weight) then begin //人物的负重没有超过
                                      if StdItem.NeedIdentify = 1 then
                                        AddGameDataLog('37' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                          IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 +
                                          IntToStr(UserItem.MakeIndex) + #9 +
                                          '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                                          IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                                          IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                                          IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                                          IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + BaseObject.m_sCharName);
                                      m_ItemList.Add(UserItem);
                                      nCode := 99;
                                      if m_btRaceServer = RC_PLAYOBJECT then begin
                                        nCode := 100;
                                        SendAddItem(UserItem);
                                         //SendUpdateItem(UserItem);//更新物品 20090524 注释
                                      end;
                                      Break; //一次只给玩家一件物品 20080121
                                    end else begin
                                      nCode := 110;
                                      DropItemDown(UserItem, 3, False, False, self, self); //20080610
                                      Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                                      SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                                      Break; //一次只给玩家一件物品 20080121
                                    end;
                                  end else begin
                                    nCode := 101;
                                    DropItemDown(UserItem, 3, False, False, self, self); //20080610
                                    Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                                    SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                                    Break; //一次只给玩家一件物品 20080121
                                  end;
                                end;
                              end else Dispose(UserItem); //if CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                            end;
                          end; //for I := TYanLeiWangSpider(BaseObject).m_ItemList.count-1 downto 0 do begin
                        finally
                          BaseObject.m_boButchSkeleton := False;
                        end;
                      end;
                    end; //0
                  else begin //进入触发段
                      if (g_FunctionNPC <> nil) and TYanLeiWangSpider(BaseObject).boIntoTrigger then begin //20080716
                        if g_FunctionNPC.m_boGotoCount < 80 then begin //防止Goto数量过多,引起M2挂死 20081004
                          nItemCount := m_ItemList.Count; //进入触发段前的包裹物品数量 20080925
                          nLevel := m_Abil.Level; //进入触发段前的等级 20081018
                          nExp := m_Abil.nExp; //进入触发段前的经验 20081018
                          nGameDiamond := m_nGAMEDIAMOND; //进入触发段前的金刚石 20081018
                          nCreditPoint := m_btCreditPoint; //进入触发段前的声望 20081018
                          nGameGird := m_nGameGird; //进入触发段前的灵符 20081018
                          g_FunctionNPC.GotoLable(Self, '@ButchCloneItem' + BaseObject.m_sCharName, False, False);
                          if (nItemCount < m_ItemList.Count) or ((nExp < m_Abil.nExp) and (nLevel = m_Abil.Level)) or
                            ((nExp > m_Abil.nExp) and (nLevel < m_Abil.Level)) or (nGameDiamond < m_nGAMEDIAMOND) or
                            (nCreditPoint < m_btCreditPoint) or (nGameGird < m_nGameGird) then begin
                            case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                              0: begin //金币模式
                                  if m_nGold >= ButchChargeCount then begin
                                    Dec(m_nGold, ButchChargeCount);
                                  end else m_nGold := 0;
                                  GoldChanged(); //20080414 更新玩家的金币
                                end;
                              1: begin //元宝模式
                                  if m_nGameGold >= ButchChargeCount then begin
                                    Dec(m_nGameGold, ButchChargeCount);
                                  end else m_nGameGold := 0;
                                  GameGoldChanged; //更新元宝数量  20080414
                                end;
                              2: begin //金刚石模式
                                  if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                    Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                  end else m_nGAMEDIAMOND := 0;
                                  GameGoldChanged(); //更新金刚石数量 20080414
                                end;
                              3: begin //灵符模式
                                  if m_nGAMEGIRD >= ButchChargeCount then begin
                                    Dec(m_nGAMEGIRD, ButchChargeCount);
                                  end else m_nGAMEGIRD := 0;
                                  GameGoldChanged(); //更新灵符数量 20080414
                                  m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                  if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                    g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                  end;
                                end;
                            end; //Case
                            SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //挖尸体得到物品显示 20080607
                          end;
                        end;
                      end;
                    end; //1
                end; //case Random(2)
              end; //if Butch then
            end; //if BaseObject.m_boDeath
          end; //125
        RC_PLAYMOSTER: begin //人形怪
            if (GetTickCount() - TPlayMonster(BaseObject).m_nButchItemTime > 300) then begin //人形怪 20090318
              nCode := 1;
              Butch := False;
              TPlayMonster(BaseObject).m_nButchItemTime := GetTickCount();
              ButchChargeClass := TPlayMonster(BaseObject).m_nButchChargeClass;
              nCode := 2;
          //如果目标是人形怪,已死亡且尸体存在,并且没有主人 20080605
              if BaseObject.m_boDeath and (not BaseObject.m_boGhost) and (not BaseObject.m_boSkeleton) and (BaseObject.m_Master = nil) and (BaseObject.m_btSlaveMakeLevel = 0) then begin //20080614
                nCode := 3;
                ButchChargeCount := TPlayMonster(BaseObject).m_nButchChargeCount;
                case ButchChargeClass of //挖取身上装备收费模式,并减少人物相应的数值
                  0: begin //金币模式
                      if m_nGold >= ButchChargeCount then begin
                        Butch := True;
                      end else SysMsg('您的金币没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                    end;
                  1: begin //元宝模式
                      if m_nGameGold >= ButchChargeCount then begin
                        Butch := True;
                      end else SysMsg('您的' + g_Config.sGameGoldName + '没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                    end;
                  2: begin //金刚石模式
                      if m_nGAMEDIAMOND >= ButchChargeCount then begin
                        Butch := True;
                      end else SysMsg('您的' + g_Config.sGameDiaMond + '没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                    end;
                  3: begin //灵符模式
                      if m_nGAMEGIRD >= ButchChargeCount then begin
                        Butch := True;
                      end else SysMsg('您的' + g_Config.sGameGird + '没有达到' + IntToStr(ButchChargeCount) + ',将挖取不到任何物品!', c_Red, t_Hint);
                    end;
                end; //Case
                nCode := 4;
                if not IsEnoughBag then SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint); //20090326
                if Butch and IsEnoughBag then begin //挖所需的条件达到
                  case Random(10) of //随机处理挖
                    0, 4, 7: begin //挖取列表中的物品
                        nCode := 5;
                        if (BaseObject <> nil) then begin
                          nCode := 51;
                          if BaseObject.m_boGhost or (TPlayMonster(BaseObject).m_ButchItemList = nil) then Exit; //20090103
                          nCode := 52;
                          if BaseObject.m_boButchSkeleton then Exit; //正在被挖尸体 20090103
                          BaseObject.m_boButchSkeleton := True;
                          try
                            for I := TPlayMonster(BaseObject).m_ButchItemList.count - 1 downto 0 do begin //20080916
                              nCode := 53;
                              if BaseObject.m_boGhost then Exit; //20081216
                              if GetTickCount() - BaseObject.m_dwDeathTick > (g_Config.dwMakeGhostPlayMosterTime - 2000) then Exit; //如果快要清理尸体时，则不再进入 20081222
                              nCode := 54;
                              if TPlayMonster(BaseObject).m_ButchItemList.count <= 0 then Break; //20080916
                              nCode := 55;
                              MonItem := pTMonItemInfo(TPlayMonster(BaseObject).m_ButchItemList.Items[I]);
                              if PlugOfCheckCanItem(12, MonItem.ItemName, False, 0, 0) then Continue; //检查是否禁止挖取物品 20090221
                              nCode := 103;
                          //if Random(MonItem.MaxPoint) > MonItem.SelPoint then Continue;//不在机率内,则继续  20080711
                              if CompareText(MonItem.ItemName, sSTRING_GOLDNAME) = 0 then begin //如果是金币
                                m_nGold := m_nGold + MonItem.Count;
                                if MonItem.Count > 0 then begin
                                  if g_boGameLogGold then
                                    AddGameDataLog('37' + #9 + m_sMapName + #9 +
                                      IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +
                                      sSTRING_GOLDNAME + #9 + IntToStr(MonItem.Count) + #9 + '1' + #9 + BaseObject.m_sCharName);
                                end;
                                GoldChanged;
                                TPlayMonster(BaseObject).m_ButchItemList.Delete(I); //挖到后,删除对应的物品
                                case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                  0: begin //金币模式
                                      if m_nGold >= ButchChargeCount then begin
                                        Dec(m_nGold, ButchChargeCount);
                                      end else m_nGold := 0;
                                      GoldChanged(); //20080414 更新玩家的金币
                                    end;
                                  1: begin //元宝模式
                                      if m_nGameGold >= ButchChargeCount then begin
                                        Dec(m_nGameGold, ButchChargeCount);
                                      end else m_nGameGold := 0;
                                      GameGoldChanged; //更新元宝数量  20080414
                                    end;
                                  2: begin //金刚石模式
                                      if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                        Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                      end else m_nGAMEDIAMOND := 0;
                                      GameGoldChanged(); //更新金刚石数量 20080414
                                    end;
                                  3: begin //灵符模式
                                      if m_nGAMEGIRD >= ButchChargeCount then begin
                                        Dec(m_nGAMEGIRD, ButchChargeCount);
                                      end else m_nGAMEGIRD := 0;
                                      GameGoldChanged(); //更新灵符数量 20080414
                                      m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                      if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                        g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                      end;
                                    end;
                                end; //Case
                                SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //挖尸体得到物品显示
                                Break;
                              end else begin
                                New(UserItem);
                                if UserEngine.CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                                  nCode := 7;
                                  UserItem.Dura := Round((UserItem.DuraMax / 100) * (20 + Random(80)));
                                  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                                  if (StdItem.StdMode = 17) or (StdItem.StdMode = 18) then begin //叠加物品,与幸运符全为持久1 20090723
                                    UserItem.Dura := 1;
                                  end else
                                    if Random(g_Config.nPlayMonRandomAddValue) = 0 then UserEngine.RandomUpgradeItem(UserItem);
                                  nCode := 8;
                                  if (UserItem <> nil) then begin
                                    nCode := 9;
                                    case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                      0: begin //金币模式
                                          if m_nGold >= ButchChargeCount then begin
                                            Dec(m_nGold, ButchChargeCount);
                                          end else m_nGold := 0;
                                          GoldChanged(); //20080414 更新玩家的金币
                                        end;
                                      1: begin //元宝模式
                                          if m_nGameGold >= ButchChargeCount then begin
                                            Dec(m_nGameGold, ButchChargeCount);
                                          end else m_nGameGold := 0;
                                          GameGoldChanged; //更新元宝数量  20080414
                                        end;
                                      2: begin //金刚石模式
                                          if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                            Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                          end else m_nGAMEDIAMOND := 0;
                                          GameGoldChanged(); //更新金刚石数量 20080414
                                        end;
                                      3: begin //灵符模式
                                          if m_nGAMEGIRD >= ButchChargeCount then begin
                                            Dec(m_nGAMEGIRD, ButchChargeCount);
                                          end else m_nGAMEGIRD := 0;
                                          GameGoldChanged(); //更新灵符数量 20080414
                                          m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                          if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                            g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                          end;
                                        end;
                                    end; //Case
                                    nCode := 10;
                                    if BaseObject <> nil then TPlayMonster(BaseObject).m_ButchItemList.Delete(I); //挖到后,删除对应的物品
                                    SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //人物挖尸体得到物品显示 20080325
                                    sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                                    PlugOfCheckCanItem(7, sCheckItemName, False, 0, 0); //禁止物品规则(管理插件功能) 20080729

                                    if IsEnoughBag then begin //人物的包裹是否满了 20080414
                                      if IsAddWeightAvailable(StdItem.Weight) then begin //人物的负重没有超过
                                        if StdItem.NeedIdentify = 1 then
                                          AddGameDataLog('37' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                            IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 +
                                            IntToStr(UserItem.MakeIndex) + #9 +
                                            '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                                            '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                                            '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                                            '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                                            '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                                            IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                                            IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                                            IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                                            IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + BaseObject.m_sCharName);
                                        m_ItemList.Add(UserItem);
                                        nCode := 11;
                                        if m_btRaceServer = RC_PLAYOBJECT then begin
                                          nCode := 12;
                                          SendAddItem(UserItem);
                                         //SendUpdateItem(UserItem);//更新物品 20090524 注释
                                        end;
                                        Break; //一次只给玩家一件物品 20080121
                                      end else begin
                                      nCode := 133;
                                      DropItemDown(UserItem, 3, False, False, self, self); //20080610
                                      Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                                      SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                                      Break; //一次只给玩家一件物品 20080121
                                      end;
                                    end;
                                  end else begin
                                    nCode := 13;
                                    DropItemDown(UserItem, 3, False, False, self, self); //20080610
                                    Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                                    SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                                    Break; //一次只给玩家一件物品 20080121
                                  end;
                                end else Dispose(UserItem); //if CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                              end;
                            end; //for I := TPlayMonster(BaseObject).m_ItemList.count-1 downto 0 do begin
                          finally
                            BaseObject.m_boButchSkeleton := False;
                          end;
                        end;
                      end; //0
                    1, 5, 8: begin //挖身上装备
                        nCode := 15;
                        if (BaseObject <> nil) then begin
                          if TPlayMonster(BaseObject).m_boButchUseItem then begin //可以挖身上装备
                            if BaseObject.m_boGhost then Exit; //20081216
                            if BaseObject.m_boButchSkeleton then Exit; //正在被挖尸体 20090103
                            BaseObject.m_boButchSkeleton := True;
                            try
                              Randomize; //播下随机种子
                              for I := Low(THumanUseItems) to High(THumanUseItems) do begin //9格装备+4格装备
                                if BaseObject.m_boGhost then Exit; //20081216
                                if GetTickCount() - BaseObject.m_dwDeathTick > (g_Config.dwMakeGhostPlayMosterTime - 2000) then Exit; //如果快要清理尸体时，则不再进入 20081222
                                if Random(TPlayMonster(BaseObject).m_nButchRate) <> 0 then Continue; //挖取身上装备机率0为百分百，数字越大，机率越小
                                if (TPlayMonster(BaseObject).m_UseItems[K].AddValue[0] = 1) and
                                  (GetHoursCount(TPlayMonster(BaseObject).m_UseItems[K].MaxDate, Now) <= 0) then Continue; //删除到期装备
                                if (TPlayMonster(BaseObject).m_UseItems[K].AddValue[0] in [2, 3]) then Continue; //绑定物品不能挖 20110528
                                K := Random(14); //20080527 修正不能挖到斗笠位物品
                                if InDisableTakeOffList(TPlayMonster(BaseObject).m_UseItems[K].wIndex) or (TPlayMonster(BaseObject).m_UseItems[K].wIndex = 0) then Continue; //检查是否在禁止取下列表,如果在列表中则不掉此物品
                                StdItem := UserEngine.GetStdItem(TPlayMonster(BaseObject).m_UseItems[K].wIndex);
                                nCode := 17;
                                if (StdItem <> nil) then begin
                                  if PlugOfCheckCanItem(12, StdItem.Name, False, 0, 0) then Continue; //检查是否禁止挖取物品 20090221
                                  case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                    0: begin //金币模式
                                        if m_nGold >= ButchChargeCount then begin
                                          Dec(m_nGold, ButchChargeCount);
                                        end else m_nGold := 0;
                                        GoldChanged(); //20080414 更新玩家的金币
                                      end;
                                    1: begin //元宝模式
                                        if m_nGameGold >= ButchChargeCount then begin
                                          Dec(m_nGameGold, ButchChargeCount);
                                        end else m_nGameGold := 0;
                                        GameGoldChanged; //更新元宝数量  20080414
                                      end;
                                    2: begin //金刚石模式
                                        if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                          Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                        end else m_nGAMEDIAMOND := 0;
                                        GameGoldChanged(); //更新金刚石数量 20080414
                                      end;
                                    3: begin //灵符模式
                                        if m_nGAMEGIRD >= ButchChargeCount then begin
                                          Dec(m_nGAMEGIRD, ButchChargeCount);
                                        end else m_nGAMEGIRD := 0;
                                        GameGoldChanged(); //更新灵符数量 20080414
                                        m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                        if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                          g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                        end;
                                      end;
                                  end; //Case
                              //if Random(TPlayMonster(BaseObject).m_nButchUserItemRate{StdItem.Stock}) = 0 then begin //20080610 增加
                                  
                                //FillChar(UserItem^.btValue, SizeOf(UserItem^.btValue), 0);//20080820 增加
                                  if TPlayMonster(BaseObject).m_UseItems[K].wIndex <> 0 then begin
                                     New(UserItem);
                                    FillChar(UserItem^, SizeOf(TUserItem), #0); //20080820 增加
                                    UserItem^ := TPlayMonster(BaseObject).m_UseItems[K]; //20080727 修改,
                                //if UserEngine.CopyToUserItemFromName(StdItem.Name, UserItem) then begin
                                    //if Random(g_Config.nPlayMonRandomAddValue) = 0 then UserEngine.RandomUpgradeItem(UserItem);//人形支持极品装备 20080724
                                    SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //人物挖尸体得到物品显示 20080325
                                    TPlayMonster(BaseObject).m_UseItems[K].wIndex := 0;
                                    sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                                    nCode := 22;
                                    PlugOfCheckCanItem(7, sCheckItemName, False, 0, 0); //禁止物品规则(管理插件功能) 20080729

                                    if IsEnoughBag and IsAddWeightAvailable(StdItem.Weight) then begin //物品是数据库里的物品,并人物的负重没有超过
                                      if StdItem.NeedIdentify = 1 then
                                        AddGameDataLog('37' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                          IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 +
                                          IntToStr(UserItem.MakeIndex) + #9 +
                                          '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                                          '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                                          IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                                          IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                                          IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                                          IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + BaseObject.m_sCharName);

                                      m_ItemList.Add(UserItem);
                                      if m_btRaceServer = RC_PLAYOBJECT then begin
                                        SendAddItem(UserItem);
                                        //SendUpdateItem(UserItem);//更新物品 20090524 注释
                                      end;
                                      Break;
                                    end else begin
                                      nCode := 14;
                                      DropItemDown(UserItem, 3, False, False, self, self); //20080610
                                      Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                                      SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                                      Break; //一次只给玩家一件物品 20080121
                                    end;
                                  end// else Dispose(UserItem);
                              //end;
                                end; //if (StdItem <> nil) then begin
                              end; //for I := Low(THumanUseItems) to High(THumanUseItems) do begin
                            finally
                              BaseObject.m_boButchSkeleton := False;
                            end;
                          end else begin //if TPlayMonster(BaseObject).m_boButchUseItem then begin//可以挖身上装备
                            nCode := 23;
                            if (BaseObject <> nil) then begin //20080628
                              if BaseObject.m_boGhost then Exit; //20081216
                              nCode := 235;
                              if BaseObject.m_boButchSkeleton then Exit; //正在被挖尸体 20090103
                              nCode := 236;
                              BaseObject.m_boButchSkeleton := True;
                              try
                                for I := TPlayMonster(BaseObject).m_ButchItemList.count - 1 downto 0 do begin //20080916
                                  nCode := 233;
                                  if BaseObject.m_boGhost then Exit; //20081216
                                  nCode := 234;
                                  if GetTickCount() - BaseObject.m_dwDeathTick > (g_Config.dwMakeGhostPlayMosterTime - 2000) then Exit; //如果快要清理尸体时，则不再进入 20081222
                                  nCode := 24;
                                  if TPlayMonster(BaseObject).m_ButchItemList.count <= 0 then Break; //20080916
                                  MonItem := pTMonItemInfo(TPlayMonster(BaseObject).m_ButchItemList.Items[I]);
                                  if PlugOfCheckCanItem(12, MonItem.ItemName, False, 0, 0) then Continue; //检查是否禁止挖取物品 20090221
                              //if Random(MonItem.MaxPoint) > MonItem.SelPoint then Continue;//不在机率内,则继续 20080711
                                  if MonItem <> nil then //20080722 增加
                                    if CompareText(MonItem.ItemName, sSTRING_GOLDNAME) = 0 then begin //如果是金币
                                      nCode := 25;
                                      m_nGold := m_nGold + MonItem.Count;
                                      GoldChanged;
                                      if MonItem.Count > 0 then begin
                                        if g_boGameLogGold then
                                          AddGameDataLog('37' + #9 + m_sMapName + #9 +
                                            IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +
                                            sSTRING_GOLDNAME + #9 + IntToStr(MonItem.Count) + #9 + '1' + #9 + BaseObject.m_sCharName);
                                      end;
                                      if BaseObject <> nil then TPlayMonster(BaseObject).m_ButchItemList.Delete(I); //挖到后,删除对应的物品
                                      case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                        0: begin //金币模式
                                            if m_nGold >= ButchChargeCount then begin
                                              Dec(m_nGold, ButchChargeCount);
                                            end else m_nGold := 0;
                                            GoldChanged(); //20080414 更新玩家的金币
                                          end;
                                        1: begin //元宝模式
                                            if m_nGameGold >= ButchChargeCount then begin
                                              Dec(m_nGameGold, ButchChargeCount);
                                            end else m_nGameGold := 0;
                                            GameGoldChanged; //更新元宝数量  20080414
                                          end;
                                        2: begin //金刚石模式
                                            if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                              Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                            end else m_nGAMEDIAMOND := 0;
                                            GameGoldChanged(); //更新金刚石数量 20080414
                                          end;
                                        3: begin //灵符模式
                                            if m_nGAMEGIRD >= ButchChargeCount then begin
                                              Dec(m_nGAMEGIRD, ButchChargeCount);
                                            end else m_nGAMEGIRD := 0;
                                            GameGoldChanged(); //更新灵符数量 20080414
                                            m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                            if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                              g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                            end;
                                          end;
                                      end; //Case
                                      SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //挖尸体得到物品显示
                                      Break;
                                    end else begin
                                      New(UserItem);
                                      nCode := 26;
                                      if UserEngine.CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                                        UserItem.Dura := Round((UserItem.DuraMax / 100) * (20 + Random(80)));
                                        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                                        if (StdItem.StdMode = 17) or (StdItem.StdMode = 18) then begin //叠加物品,与幸运符全为持久1 20090723
                                          UserItem.Dura := 1;
                                        end else
                                          if Random(g_Config.nPlayMonRandomAddValue) = 0 then UserEngine.RandomUpgradeItem(UserItem);
                                        if (UserItem <> nil) then begin
                                          case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                            0: begin //金币模式
                                                if m_nGold >= ButchChargeCount then begin
                                                  Dec(m_nGold, ButchChargeCount);
                                                end else m_nGold := 0;
                                                GoldChanged(); //20080414 更新玩家的金币
                                              end;
                                            1: begin //元宝模式
                                                if m_nGameGold >= ButchChargeCount then begin
                                                  Dec(m_nGameGold, ButchChargeCount);
                                                end else m_nGameGold := 0;
                                                GameGoldChanged; //更新元宝数量  20080414
                                              end;
                                            2: begin //金刚石模式
                                                if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                                  Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                                end else m_nGAMEDIAMOND := 0;
                                                GameGoldChanged(); //更新金刚石数量 20080414
                                              end;
                                            3: begin //灵符模式
                                                if m_nGAMEGIRD >= ButchChargeCount then begin
                                                  Dec(m_nGAMEGIRD, ButchChargeCount);
                                                end else m_nGAMEGIRD := 0;
                                                GameGoldChanged(); //更新灵符数量 20080414
                                                m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                                if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                                  g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                                end;
                                              end;
                                          end; //Case
                                          nCode := 28;
                                          if BaseObject <> nil then TPlayMonster(BaseObject).m_ButchItemList.Delete(I); //挖到后,删除对应的物品
                                          SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //人物挖尸体得到物品显示 20080325
                                          sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                                          nCode := 129;
                                          PlugOfCheckCanItem(7, sCheckItemName, False, 0, 0); //禁止物品规则(管理插件功能) 20080729

                                          if IsEnoughBag and IsAddWeightAvailable(StdItem.Weight) then begin //人物的包裹是否满了 20080414
                                            //if  then begin //人物的负重没有超过
                                              if StdItem.NeedIdentify = 1 then
                                                AddGameDataLog('37' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                                  IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 +
                                                  IntToStr(UserItem.MakeIndex) + #9 +
                                                  '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                                                  '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                                                  '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                                                  '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                                                  '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                                                  IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                                                  IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                                                  IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                                                  IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + BaseObject.m_sCharName);

                                              m_ItemList.Add(UserItem);
                                              nCode := 30;
                                              if m_btRaceServer = RC_PLAYOBJECT then begin
                                                SendAddItem(UserItem);
                                             //SendUpdateItem(UserItem);//更新物品 20090524 注释
                                              end;
                                              Break; //一次只给玩家一件物品 20080121
                                            //end;
                                          end else begin
                                            nCode := 31;
                                            DropItemDown(UserItem, 3, False, False, self, self); //20080610
                                            Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                                            SysMsg(sButchEnoughBagHintMsg {'您的包裹已没有办法装下任何物品!'}, c_Red, t_Hint);
                                            Break; //一次只给玩家一件物品 20080121
                                          end;
                                        end;
                                      end else Dispose(UserItem); //if CopyToUserItemFromName(MonItem.ItemName, UserItem) then begin
                                    end;
                                end; //for I := TPlayMonster(BaseObject).m_ItemList.count-1 downto 0 do begin
                              finally
                                BaseObject.m_boButchSkeleton := False;
                              end;
                            end;
                          end;
                        end;
                      end; //1
                    2, 3, 6, 9: begin
                        if (BaseObject <> nil) and (g_FunctionNPC <> nil) and TPlayMonster(BaseObject).boIntoTrigger then begin //20080716
                          nCode := 35;
                          if g_FunctionNPC.m_boGotoCount < 80 then begin
                            nItemCount := m_ItemList.Count; //进入触发段前的包裹物品数量 20080925
                            nLevel := m_Abil.Level; //进入触发段前的等级 20081018
                            nExp := m_Abil.nExp; //进入触发段前的经验 20081018
                            nGameDiamond := m_nGAMEDIAMOND; //进入触发段前的金刚石 20081018
                            nCreditPoint := m_btCreditPoint; //进入触发段前的声望 20081018
                            nGameGird := m_nGameGird; //进入触发段前的灵符 20081018
                            g_FunctionNPC.GotoLable(Self, '@ButchCloneItem' + BaseObject.m_sCharName, False, False);
                            if (nItemCount < m_ItemList.Count) or ((nExp < m_Abil.nExp) and (nLevel = m_Abil.Level)) or
                              ((nExp > m_Abil.nExp) and (nLevel < m_Abil.Level)) or (nGameDiamond < m_nGAMEDIAMOND) or
                              (nCreditPoint < m_btCreditPoint) or (nGameGird < m_nGameGird) then begin
                              case ButchChargeClass of //挖取到物品后减所需的条件的数量 20080503
                                0: begin //金币模式
                                    if m_nGold >= ButchChargeCount then begin
                                      Dec(m_nGold, ButchChargeCount);
                                    end else m_nGold := 0;
                                    GoldChanged(); //20080414 更新玩家的金币
                                  end;
                                1: begin //元宝模式
                                    if m_nGameGold >= ButchChargeCount then begin
                                      Dec(m_nGameGold, ButchChargeCount);
                                    end else m_nGameGold := 0;
                                    GameGoldChanged; //更新元宝数量  20080414
                                  end;
                                2: begin //金刚石模式
                                    if m_nGAMEDIAMOND >= ButchChargeCount then begin
                                      Dec(m_nGAMEDIAMOND, ButchChargeCount);
                                    end else m_nGAMEDIAMOND := 0;
                                    GameGoldChanged(); //更新金刚石数量 20080414
                                  end;
                                3: begin //灵符模式
                                    if m_nGAMEGIRD >= ButchChargeCount then begin
                                      Dec(m_nGAMEGIRD, ButchChargeCount);
                                    end else m_nGAMEGIRD := 0;
                                    GameGoldChanged(); //更新灵符数量 20080414
                                    m_UseGameGird := ButchChargeCount; //20090108 灵符使用计数
                                    if g_FunctionNPC <> nil then begin //灵符使用触发 20090108
                                      g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                                    end;
                                  end;
                              end; //Case
                              SendRefMsg(RM_MYSHOW, ET_OBJECTBUTCHMON, 0, 0, 0, ''); //人物挖尸体得到物品显示 20080607
                            end;
                          end;
                        end;
                      end; //2
                  end; //case Random(2) of
                end; //if Butch then
              end;
            end;
          end; //RC_PLAYMOSTER
      else begin //其它
          nCode := 37;
          if (abs(nX - m_nCurrX) <= 2) and (abs(nY - m_nCurrY) <= 2) then begin
            nCode := 38;
            if m_PEnvir.IsValidObject(nX, nY, 2, BaseObject) then begin
              nCode := 39;
              if BaseObject.m_boDeath and (not BaseObject.m_boSkeleton) and (BaseObject.m_boAnimal) then begin
                n10 := Random(16) + 5;
                n14 := Random(201) + 100;
                Dec(BaseObject.m_nBodyLeathery, n10);
                Dec(BaseObject.m_nMeatQuality, n14);
                nCode := 40;
                if BaseObject.m_nMeatQuality < 0 then BaseObject.m_nMeatQuality := 0;
                nCode := 41;
                if BaseObject.m_nBodyLeathery <= 0 then begin
                  if (BaseObject.m_btRaceServer >= RC_ANIMAL) and (BaseObject.m_btRaceServer < RC_MONSTER) then begin
                    BaseObject.m_boSkeleton := True;
                    ApplyMeatQuality(); //设置肉的品质
                    BaseObject.SendRefMsg(RM_SKELETON, BaseObject.m_btDirection, BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0, ''); //彻底死了,不再有动作
                  end;
                  if not TakeBagItems(BaseObject) then SysMsg(sYouFoundNothing {未发现任何物品！！！}, c_Red, t_Hint);
                  BaseObject.m_nBodyLeathery := 50;
                end;
                m_dwDeathTick := GetTickCount();
              end;
            end;
            m_btDirection := btDir;
          end;
          nCode := 42;
        end;
      end; //case
      if (abs(nX - m_nCurrX) <= 2) and (abs(nY - m_nCurrY) <= 2) then begin //20110422 防止，边跑边挖
        SendRefMsg(RM_BUTCH, m_btDirection, m_nCurrX, m_nCurrY, 0, ''); //让别人看到挖的动作 20080930
      end;
    except
      on E: Exception do begin
        if BaseObject <> nil then begin //20090213 增加
          BaseObject.MakeGhost();
        end;
      //MainOutMessage('{异常} TPlayObject.ClientGetButchItem Code:'+inttostr(nCode));//20090424 注释
      end;
    end;
  finally
    m_boButching := False;
  end;
end;
//客户端改变魔法快捷键

procedure TPlayObject.ClientChangeMagicKey(nSkillIdx, nKey: Integer; sMsg: string);
var
  I: Integer;
  UserMagic: pTUserMagic;
  Str, Str1, Str2: string;
begin
  if m_boDeath or m_boGhost or (nSkillIdx = SKill_106) then Exit; //20091124 增加
{$IF M2Version = 1}
  if sMsg <> '' then begin //修改连击快捷键设置
    sMsg := GetValidStr3(sMsg, Str, ['/']);
    sMsg := GetValidStr3(sMsg, Str1, ['/']);
    sMsg := GetValidStr3(sMsg, Str2, ['/']);
    m_SetBatterKey := Str_ToInt(Str, 0); //第一个连击技能格 20090702
    m_SetBatterKey1 := Str_ToInt(Str1, 0); //第二个连击技能格 20090702
    m_SetBatterKey2 := Str_ToInt(Str2, 0); //第三个连击技能格 20090702
    m_SetBatterKey3 := Str_ToInt(sMsg, 0); //第四个连击技能格 20100719
    if not m_boUser4BatterSkill then m_SetBatterKey3 := 0; //未开启第四格连击 20100720
  end;
{$IFEND}
  if nSkillIdx >= 0 then begin
    if m_MagicList.Count > 0 then begin
      for I := 0 to m_MagicList.Count - 1 do begin
        UserMagic := m_MagicList.Items[I];
        if UserMagic <> nil then begin
          if UserMagic.MagicInfo.wMagicId = nSkillIdx then begin
            UserMagic.btKey := nKey;
            Break;
          end;
        end;
      end;
    end;
  end;
end;
//关闭组队

procedure TPlayObject.ClientGropuClose;
begin
  if m_GroupOwner = nil then begin
    m_boAllowGroup := False;
    Exit;
  end;
  {if m_GroupOwner <> Self then begin//不是组队队长
    m_GroupOwner.DelMember(Self);
    m_boAllowGroup := False;
  end else begin
    SysMsg('如果您想退出，使用编组功能（删除按钮）', c_Red, t_Hint);
  end; }
  m_GroupOwner.DelMember(Self); //20101105 增加
  m_boAllowGroup := False;
end;
//新建组队

procedure TPlayObject.ClientCreateGroup(sHumName: string);
var
  PlayObject: TPlayObject;
begin
  if m_boDeath or m_boGhost then Exit; //死亡后不能组队 20090111
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if m_GroupOwner <> nil then begin
    SendDefMessage(SM_CREATEGROUP_FAIL, -1, 0, 0, 0, '');
    Exit;
  end;
  if (PlayObject = nil) or (PlayObject = Self) or PlayObject.m_boDeath or PlayObject.m_boGhost then begin
    SendDefMessage(SM_CREATEGROUP_FAIL, -2, 0, 0, 0, '');
    Exit;
  end;
  if (PlayObject.m_GroupOwner <> nil) then begin
    SendDefMessage(SM_CREATEGROUP_FAIL, -3, 0, 0, 0, '');
    Exit;
  end;
  if (not PlayObject.m_boAllowGroup) then begin
    SendDefMessage(SM_CREATEGROUP_FAIL, -4, 0, 0, 0, '');
    Exit;
  end;
  m_GroupMembers.Clear;
  m_GroupMembers.AddObject(m_sCharName, Self);
  m_GroupMembers.AddObject(sHumName, PlayObject);
  JoinGroup(Self);
  PlayObject.JoinGroup(Self); //提示加入小组
  m_boAllowGroup := True;
  SendDefMessage(SM_CREATEGROUP_OK, 0, 0, 0, 0, '');
  SendGroupMembers(); ////发送组队数据
end;
//增加组队成员

procedure TPlayObject.ClientAddGroupMember(sHumName: string);
var
  PlayObject: TPlayObject;
begin
  if m_boDeath or m_boGhost then Exit; //死亡后不能增加组队成员 20090111
  PlayObject := UserEngine.GetPlayObject(sHumName);

  if m_GroupOwner <> Self then begin
    SendDefMessage(SM_GROUPADDMEM_FAIL, -1, 0, 0, 0, ''); //编组还未成立
    Exit;
  end;
  if m_GroupMembers.Count > g_Config.nGroupMembersMax then begin //超过成员上限
    SendDefMessage(SM_GROUPADDMEM_FAIL, -5, 0, 0, 0, ''); //您想邀请加入编组的人已经加入了其它组！
    Exit;
  end;
  if (PlayObject = nil) or (PlayObject = Self) or PlayObject.m_boDeath or PlayObject.m_boGhost then begin
    SendDefMessage(SM_GROUPADDMEM_FAIL, -2, 0, 0, 0, ''); //输入的人物名称不正确
    Exit;
  end;
  if (PlayObject.m_GroupOwner <> nil) then begin
    SendDefMessage(SM_GROUPADDMEM_FAIL, -3, 0, 0, 0, ''); //已经加入编组
    Exit;
  end;
  if (not PlayObject.m_boAllowGroup) then begin //对方不允许编组
    SendDefMessage(SM_GROUPADDMEM_FAIL, -4, 0, 0, 0, '');
    Exit;
  end;
  if IsGroupMember(PlayObject) then begin //检查是否是组队里成员 20090111
    SendDefMessage(SM_GROUPADDMEM_FAIL, -3, 0, 0, 0, ''); //已经加入编组
    Exit;
  end;
  m_GroupMembers.AddObject(sHumName, PlayObject);
  PlayObject.JoinGroup(Self);
  SendDefMessage(SM_GROUPADDMEM_OK, 0, 0, 0, 0, '');
  SendGroupMembers();
end;

procedure TPlayObject.ClientDelGroupMember(sHumName: string);
var
  PlayObject: TPlayObject;
begin
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if m_GroupOwner <> Self then begin
    SendDefMessage(SM_GROUPDELMEM_FAIL, -1, 0, 0, 0, '');
    Exit;
  end;
  if PlayObject = nil then begin
    SendDefMessage(SM_GROUPDELMEM_FAIL, -2, 0, 0, 0, '');
    Exit;
  end;
  if not IsGroupMember(PlayObject) then begin
    SendDefMessage(SM_GROUPDELMEM_FAIL, -3, 0, 0, 0, '');
    Exit;
  end;
  DelMember(PlayObject);
  SendDefMessage(SM_GROUPDELMEM_OK, 0, 0, 0, 0, sHumName);
end;
//判断对方是否面对面,是则可以交易,双方打开交易窗口

procedure TPlayObject.ClientDealTry(sHumName: string);
var
  BaseObject: TBaseObject;
  PlayObject: TPlayObject;
begin
  if g_Config.boDisableDeal then begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sDisableDealItemsMsg);
    Exit;
  end;
  if m_boDealing then Exit;
  if GetTickCount - m_DealLastTick < g_Config.dwTryDealTime {3000} then begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sPleaseTryDealLaterMsg);
    Exit;
  end;
  if not m_boCanDeal then begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotTryDealMsg);
    Exit;
  end;
  if m_boShop then begin //开启个人商店时不能扔物品 20100704
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropItemMsg);
    Exit;
  end;
  BaseObject := GetPoseCreate();
  if (BaseObject <> nil) and (BaseObject <> Self) and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
    PlayObject := TPlayObject(BaseObject);
    if (PlayObject <> nil) and (PlayObject.GetPoseCreate = Self) and (not PlayObject.m_boDealing) then begin
      if (PlayObject.m_boAllowDeal and PlayObject.m_boCanDeal) and (not PlayObject.m_boShop) then begin
        PlayObject.SysMsg(m_sCharName + g_sOpenedDealMsg, c_Green, t_Hint);
        SysMsg(PlayObject.m_sCharName + g_sOpenedDealMsg, c_Green, t_Hint);
        TPlayObject(Self).OpenDealDlg(PlayObject);
        PlayObject.OpenDealDlg(Self);
      end else begin
        SysMsg(g_sPoseDisableDealMsg {'对方禁止进入交易'}, c_Red, t_Hint);
      end;
    end else begin
      SendDefMessage(SM_DEALTRY_FAIL, 0, 0, 0, 0, '');
    end;
  end else begin
    SendDefMessage(SM_DEALTRY_FAIL, 0, 0, 0, 0, '');
  end;
end;
//-------------------------元宝寄售系统-----------------------------------------
//交易成功后修改数据标识 20080319

procedure TPlayObject.UpdateSellOffInfo(code: integer);
var
  I: Integer;
  DealOffInfo: pTDealOffInfo;
begin
  if bo_YBDEAL then begin //已开通元宝服务
    for I := sSellOffItemList.Count - 1 downto 0 do begin //20080916 修改
      if sSellOffItemList.Count <= 0 then break; //20080916
      DealOffInfo := pTDealOffInfo(sSellOffItemList.Items[I]);
      if (DealOffInfo <> nil) then begin
        if (DealOffInfo.N = 2) then begin
          case code of
            0: begin //出售者
                if DealOffInfo.sDealCharName = m_sCharName then begin
                  sSellOffItemList.Delete(I);
                  Dispose(DealOffInfo); //20081022
                  Break;
                end;
              end;
            1: begin //购买者
                if DealOffInfo.sBuyCharName = m_sCharName then begin
                  sSellOffItemList.Delete(I);
                  Dispose(DealOffInfo); //20081022
                  Break;
                end;
              end;
          end; //case
        end;
      end;
    end; //for
  end;
end;
//客户端增加寄售物品到出售框中   20080316

procedure TPlayObject.ClientAddSellOffItem(nItemIdx: Integer; sItemName: string);
var
  I: Integer;
  bo11: Boolean;
  UserItem: pTUserItem;
  sUserItemName: string;
begin
  m_boCanQueryBag := True; //增加寄售物品时,不能刷新包裹 20080917
  try
    if Pos(' ', sItemName) >= 0 then begin //折分物品名称(信件物品的名称后面加了使用次数)
      GetValidStr3(sItemName, sItemName, [' ']);
    end;
    if m_boShop then begin //开启个人商店时不能扔物品 20100704
      SendMsg(Self, RM_SellOffADDITEM_FAIL, 0, 0, 0, 0, '');
      Exit;
    end;
    bo11 := False;
    if not m_boSellOffOK then begin
      for I := m_ItemList.Count - 1 downto 0 do begin
        if m_ItemList.Count <= 0 then Break;
        UserItem := m_ItemList.Items[I];
        if UserItem = nil then Continue;
        if UserItem.MakeIndex = nItemIdx then begin
          if (UserItem.AddValue[0] in [1..3]) then Break; //限时物品,绑定物品不能交易
          //取自定义物品名称
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sUserItemName = '' then
            sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

          if (CompareText(sUserItemName, sItemName) = 0) and (m_SellOffItemList.Count < 9) then begin
            if CheckItemValue(UserItem, 1) then Break //20080314 禁止交易
            else if PlugOfCheckCanItem(1, sUserItemName, False, 0, 0) then Break; //禁止物品规则(管理插件功能) 20080729

            m_SellOffItemList.Add(UserItem);
            SendMsg(Self, RM_SELLOFFADDITEM_OK, 0, 0, 0, 0, ''); //放物品成功
            m_ItemList.Delete(I);
            bo11 := True;
            Break;
          end;
        end;
      end;
    end;
    if not bo11 then SendMsg(Self, RM_SellOffADDITEM_FAIL, 0, 0, 0, 0, '');
  finally
    m_boCanQueryBag := False; //增加寄售物品时,不能刷新包裹 20080917
  end;
end;

//客户端删除出售物品窗里的物品

procedure TPlayObject.ClientDelSellOffItem(nItemIdx: Integer; sItemName: string);
var
  I: Integer;
  bo11: Boolean;
  UserItem: pTUserItem;
  sUserItemName: string;
begin
  if Pos(' ', sItemName) >= 0 then begin //折分物品名称(信件物品的名称后面加了使用次数)
    GetValidStr3(sItemName, sItemName, [' ']);
  end;
  bo11 := False;
  if not m_boSellOffOK then begin
    for I := m_SellOffItemList.Count - 1 downto 0 do begin
      if m_SellOffItemList.Count <= 0 then Break;
      UserItem := m_SellOffItemList.Items[I];
      if UserItem = nil then Continue;
      if UserItem.MakeIndex = nItemIdx then begin
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

        if CompareText(sUserItemName, sItemName) = 0 then begin
          m_ItemList.Add(UserItem);

          SendMsg(Self, RM_SELLOFFDELITEM_OK, 0, 0, 0, 0, '');
          m_SellOffItemList.Delete(I);
          bo11 := True;
          Break;
        end;
      end;
    end; //for
  end;
  if not bo11 then SendMsg(Self, RM_SELLOFFDELITEM_FAIL, 0, 0, 0, 0, '');
end;

//出售人取消正在出售中的交易 20080316

procedure TPlayObject.ClientCancelSellOffIng();
var
  I, K: Integer;
  DealOffInfo: pTDealOffInfo;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  nCode: Byte;
begin
  nCode := 0;
  try
    if (sSellOffItemList = nil) or (sSellOffItemList.Count = 0) or (not IsEnoughBag) then Exit; //20080612
    for I := sSellOffItemList.Count - 1 downto 0 do begin
      if sSellOffItemList.Count <= 0 then Break; //20080916
      nCode := 1;
      DealOffInfo := pTDealOffInfo(sSellOffItemList.Items[I]);
      nCode := 2;
      if (DealOffInfo <> nil) then begin
        nCode := 12;
        if (CompareText(DealOffInfo.sDealCharName, m_sCharName) = 0) and ((DealOffInfo.N = 0) or (DealOffInfo.N = 3)) then begin
          DealOffInfo.N := 4; //20081022 正在操作中
          nCode := 3;
          for K := 0 to 9 do begin
            nCode := 4;
            StdItem := UserEngine.GetStdItem(DealOffInfo.UseItems[K].wIndex);
            if (StdItem <> nil) then begin
              nCode := 5;
              New(UserItem);
              FillChar(UserItem^, SizeOf(TUserItem), #0);
              UserItem^ := DealOffInfo.UseItems[K];
{$IF M2var = 1}
              if UserItem.AddValue[2] <> 255 then begin //临时处理14-19属性值，过N版后去掉 20110528
                UserItem.AddValue[2] := UserItem.btValue[14];
                UserItem.btValue[14] := 0;
                SetItemState(UserItem, 0, UserItem.AddValue[2]);
                SetItemState(UserItem, 1, UserItem.btValue[15]);
                SetItemState(UserItem, 2, UserItem.btValue[16]);
                SetItemState(UserItem, 3, UserItem.btValue[17]);
                SetItemState(UserItem, 4, UserItem.btValue[18]);
                SetItemState(UserItem, 5, UserItem.btValue[19]);
                UserItem.btValue[15] := 0;
                UserItem.btValue[16] := 0;
                UserItem.btValue[17] := 0;
                UserItem.btValue[18] := 0;
                UserItem.btValue[19] := 0;
                UserItem.AddValue[2] := 255;
              end;
{$IFEND}
              nCode := 6;
              if IsEnoughBag and  IsAddWeightAvailable(StdItem.Weight)then begin //人物的包裹是否满了 20080712
                //if IsAddWeightAvailable(StdItem.Weight) then begin //检查负重
                  nCode := 7;
                  if AddItemToBag(UserItem) then SendAddItem(UserItem); //20080322 修改
                //end;
              end else begin
                DropItemDown(UserItem, 3, False, False, self, self); //20080712
                Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
              end;
            end else
              if (DealOffInfo.UseItems[K].MakeIndex > 0) and (DealOffInfo.UseItems[K].wIndex = High(Word)) and //是金刚石
                (DealOffInfo.UseItems[K].Dura = High(Word)) and (DealOffInfo.UseItems[K].DuraMax = High(Word)) then begin
                nCode := 8;
                Inc(m_nGAMEDIAMOND, DealOffInfo.UseItems[K].MakeIndex); //增加金刚石
                nCode := 9;
                GameGoldChanged; //更新金刚石数量
              end;
          end; // for K:=0 to 9 do begin
          nCode := 10;
          sSellOffItemList.Delete(I);
          Dispose(DealOffInfo); //20081022 增加
          nCode := 11;
          SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '取消寄售成功！');
        end;
      end;
    end; //for
  except   
    MainOutMessage(Format('{%s} TPlayObject.ClientCancelSellOffIng Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

//购买人取消交易 20080316

procedure TPlayObject.ClientBuyCancelSellOff(DealCharName: string);
var
  I: Integer;
  DealOffInfo: pTDealOffInfo;
begin
  for I := sSellOffItemList.Count - 1 downto 0 do begin //20080916 修改
    if sSellOffItemList.Count <= 0 then Break; //20080916
    DealOffInfo := pTDealOffInfo(sSellOffItemList.Items[I]);
    if (DealOffInfo <> nil) then begin
      if (CompareText(DealOffInfo.sDealCharName, DealCharName) = 0) and
        (CompareText(DealOffInfo.sBuyCharName, m_sCharName) = 0) and (DealOffInfo.N = 0) then begin
        DealOffInfo.N := 3; //购买人取消标识
        //sSellOffItemList.Delete(I);//20081022
        //sSellOffItemList.Add(DealOffInfo);//20081022
        SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '取消交易成功！');
        Break;
      end;
    end;
  end;
end;

//购买寄售物品 20080318

procedure TPlayObject.ClientBuySellOffItme(DealCharName: string);
var
  I, K: Integer;
  DealOffInfo: pTDealOffInfo;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  PlayObject: TPlayObject;
  nCode: Byte;
begin
  nCode := 0;
  try
    for I := sSellOffItemList.Count - 1 downto 0 do begin //20080916 修改
      if sSellOffItemList.Count <= 0 then Break; //20080916
      nCode := 1;
      DealOffInfo := pTDealOffInfo(sSellOffItemList.Items[I]);
      if (DealOffInfo <> nil) then begin
        if (CompareText(DealOffInfo.sDealCharName, DealCharName) = 0) and
          (CompareText(DealOffInfo.sBuyCharName, m_sCharName) = 0) and (DealOffInfo.N = 0) then begin
          nCode := 2;
          DealOffInfo.N := 4; //20081022 正在操作中
          if m_nGameGold >= (DealOffInfo.nSellGold + g_Config.nDecUserGameGold) then begin //每次扣多少元宝(元宝寄售) 20080319
            Dec(m_nGameGold, DealOffInfo.nSellGold + g_Config.nDecUserGameGold); //扣出元宝
            if m_nGameGold < 0 then m_nGameGold := 0;
            GameGoldChanged; //更新元宝数量
            if g_boGameLogGameGold then //20100511 增加
              AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, m_sMapName,
                m_nCurrX, m_nCurrY, m_sCharName,
                  g_Config.sGameGoldName, m_nGameGold,
                  '购买寄售-(' + inttostr(DealOffInfo.nSellGold + g_Config.nDecUserGameGold) + ')', DealOffInfo.sDealCharName]));
            nCode := 3;
            //给出售人元宝
            PlayObject := UserEngine.GetPlayObject(DealOffInfo.sDealCharName);
            if PlayObject = nil then begin //出售人不在线
              DealOffInfo.N := 1; //物品已出售,出售人未得到元宝
            end else begin
              if PlayObject.m_boNotOnlineAddExp then begin //挂机 20081204
                DealOffInfo.N := 1; //物品已出售,出售人未得到元宝
              end else begin
                nCode := 10;
                UpdateSellOffInfo(1);
                DealOffInfo.N := 2; //交易结束
                if PlayObject.m_nGameGold <= (High(Integer) - DealOffInfo.nSellGold) then begin //20100806修改
                  Inc(PlayObject.m_nGameGold, DealOffInfo.nSellGold);
                end else begin
                  PlayObject.m_nGameGold := High(Integer);
                end;
                PlayObject.GameGoldChanged();
                nCode := 7;
                if sGetSellOffGlod <> '' then PlayObject.SysMsg(Format_ToStr(sGetSellOffGlod, [DealOffInfo.nSellGold]), c_Red, t_Hint);
                nCode := 8;
                if g_boGameLogGameGold then
                  AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, PlayObject.m_sMapName,
                    PlayObject.m_nCurrX, PlayObject.m_nCurrY, PlayObject.m_sCharName,
                      g_Config.sGameGoldName, PlayObject.m_nGameGold,
                      '寄售获得(' + inttostr(DealOffInfo.nSellGold) + ')', m_sCharName]));
              end;
            end;

            for K := 0 to 9 do begin
              StdItem := UserEngine.GetStdItem(DealOffInfo.UseItems[K].wIndex);
              if (StdItem <> nil) then begin
                nCode := 12;
                //if IsAddWeightAvailable(StdItem.Weight) then begin//检查负重 20080824
                New(UserItem);
                FillChar(UserItem^, SizeOf(TUserItem), #0); //20080820 增加
                UserItem^ := DealOffInfo.UseItems[K];
{$IF M2var = 1}
                if UserItem.AddValue[2] <> 255 then begin //临时处理14-19属性值，过N版后去掉 20110528
                  UserItem.AddValue[2] := UserItem.btValue[14];
                  UserItem.btValue[14] := 0;
                  SetItemState(UserItem, 0, UserItem.AddValue[2]);
                  SetItemState(UserItem, 1, UserItem.btValue[15]);
                  SetItemState(UserItem, 2, UserItem.btValue[16]);
                  SetItemState(UserItem, 3, UserItem.btValue[17]);
                  SetItemState(UserItem, 4, UserItem.btValue[18]);
                  SetItemState(UserItem, 5, UserItem.btValue[19]);
                  UserItem.btValue[15] := 0;
                  UserItem.btValue[16] := 0;
                  UserItem.btValue[17] := 0;
                  UserItem.btValue[18] := 0;
                  UserItem.btValue[19] := 0;
                  UserItem.AddValue[2] := 255;
                end;
{$IFEND}
                nCode := 13;
                if IsEnoughBag and AddItemToBag(UserItem)  then begin //检查人物的包裹是否满了 20080917
                  //if  then begin
                    nCode := 14;
                    SendAddItem(UserItem); //20080322 修改
                    if StdItem.NeedIdentify = 1 then
                      AddGameDataLog('33' + #9 + m_sMapName + '(*)' + #9 +
                        IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 + StdItem.Name + #9 +
                        IntToStr(UserItem.MakeIndex) + #9 +
                        '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                        '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                        '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                        '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                        '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                        IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                        IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                        IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                        IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + DealOffInfo.sDealCharName);
                  //end;
                end else begin //20080917 包裹没位了,则把物品扔出来
                  DropItemDown(UserItem, 3, False, False, self, self);
                  Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                end;
                //end;
              end else
                if (DealOffInfo.UseItems[K].MakeIndex > 0) and (DealOffInfo.UseItems[K].wIndex = High(Word)) and //是金刚石
                  (DealOffInfo.UseItems[K].Dura = High(Word)) and (DealOffInfo.UseItems[K].DuraMax = High(Word)) then begin
                  nCode := 15;
                  Inc(m_nGAMEDIAMOND, DealOffInfo.UseItems[K].MakeIndex); //增加金刚石
                  SysMsg(IntToStr(DealOffInfo.UseItems[K].MakeIndex) + ' 颗金刚石增加', c_Blue, t_Hint);
                end;
            end; // for K:=0 to 9 do begin
            nCode := 16;
            SendMsg(Self, RM_SELLOFFBUY_OK, 0, 0, 0, 0, ''); //购买成功
            SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '[成功] 系统已经成功接受您的申请');
            Break;
          end else begin //if  m_nGameGold >= DealOffInfo.nSellGold then begin
            DealOffInfo.N := 0; //20081204 购买不成功则改为原来的状态
            SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '[错误] 您的申请提交不成功');
            Break;
          end;
        end;
      end;
    end; //for
  except   
    MainOutMessage(Format('{%s} TPlayObject.ClientBuySellOffItme Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

//人物上线,检查是否有交易结束还没得到元宝 20080318

procedure TPlayObject.GetSellOffGlod;
var
  I: Integer;
  DealOffInfo: pTDealOffInfo;
  nCode: Byte;
begin
  nCode := 0;
  if m_boNotOnlineAddExp or (not bo_YBDEAL) then Exit; //挂机则退出 20081204 20090331
  try
    for I := sSellOffItemList.Count - 1 downto 0 do begin //20080916 修改
      nCode := 1;
      if sSellOffItemList.Count <= 0 then Break; //20080916
      nCode := 2;
      DealOffInfo := pTDealOffInfo(sSellOffItemList.Items[I]);
      nCode := 3;
      if (DealOffInfo <> nil) then begin
        if (CompareText(DealOffInfo.sDealCharName, m_sCharName) = 0) and (DealOffInfo.N = 1) then begin
          nCode := 4;
          UpdateSellOffInfo(0);
          nCode := 5;
          DealOffInfo.N := 2; //交易结束
           //sSellOffItemList.Delete(I);//20081022
           //sSellOffItemList.Add(DealOffInfo);//20081022
          nCode := 7;
          if m_nGameGold <= (High(Integer) - DealOffInfo.nSellGold) then begin //20100806修改
            Inc(m_nGameGold, DealOffInfo.nSellGold);
          end else begin
            m_nGameGold := High(Integer);
          end;

          GameGoldChanged();
          nCode := 8;
          if sGetSellOffGlod <> '' then SysMsg(Format_ToStr(sGetSellOffGlod, [DealOffInfo.nSellGold]), c_Red, t_Hint);
          nCode := 9;
          if g_boGameLogGameGold then
            AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD,
              m_sMapName, m_nCurrX, m_nCurrY, m_sCharName,
                g_Config.sGameGoldName, m_nGameGold,
                '寄售获得(' + inttostr(DealOffInfo.nSellGold) + ')', DealOffInfo.sBuyCharName]));
          Break;
        end;
      end;
    end; //for
  except   
    MainOutMessage(Format('{%s} TPlayObject.GetSellOffGlod Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

//客户端取消元宝寄售 20080316

procedure TPlayObject.ClientCancelSellOff;
begin
  SellOffCancel();
end;

//查询玩家交易记录  20080318

function TPlayObject.SelectSellDate: string;
var
  I: Integer;
  DealOffInfo: pTDealOffInfo;
begin
  Result := '您未开通元宝寄售服务,请先开通！\ \<返回/@main>';
  if bo_YBDEAL then begin //已开通元宝服务
    if sSellOffItemList.Count > 0 then begin //20080629
      for I := 0 to sSellOffItemList.Count - 1 do begin
        DealOffInfo := pTDealOffInfo(sSellOffItemList.Items[I]);
        if (DealOffInfo <> nil) then begin
          if (CompareText(DealOffInfo.sDealCharName, m_sCharName) = 0) and (DealOffInfo.N = 2) then begin
            Result := '最后一笔出售记录:\' + FormatdateTime('   yyyy年mm月dd日 hh时nn分', DealOffInfo.dSellDateTime) + ',\  您与'
              + DealOffInfo.sBuyCharName + '交易成功,获得了' + IntToStr(DealOffInfo.nSellGold) + '个' + g_Config.sGameGoldName + '。\ \<返回/@main>';
            Exit;
          end else
            if (CompareText(DealOffInfo.sBuyCharName, m_sCharName) = 0) and ((DealOffInfo.N = 1) or (DealOffInfo.N = 2)) then begin
              Result := '最后一笔购买记录:\' + FormatdateTime('   yyyy年mm月dd日 hh时nn分', DealOffInfo.dSellDateTime) + ',\  您与'
                + DealOffInfo.sDealCharName + '交易成功,支付了' + IntToStr(DealOffInfo.nSellGold) + '个' + g_Config.sGameGoldName + '。\ \<返回/@main>';
              Exit;
            end;
        end;
      end; //for
    end;
    Result := '您未进行任何寄售交易！\ \<返回/@main>';
  end;
end;

//查询玩家是否操作过寄售 20080317

function TPlayObject.SellOffInTime(nCode: Integer): Boolean;
var
  I: Integer;
  DealOffInfo: pTDealOffInfo;
begin
  Result := False;
  if sSellOffItemList.Count > 0 then begin //20080629
    for I := 0 to sSellOffItemList.Count - 1 do begin
      DealOffInfo := pTDealOffInfo(sSellOffItemList.Items[I]);
      if DealOffInfo <> nil then begin
        case nCode of
          0: begin //出售者
              if (CompareText(DealOffInfo.sDealCharName, m_sCharName) = 0) and ((DealOffInfo.N = 0) or (DealOffInfo.N = 3)) then begin
                Result := True;
                Break;
              end;
            end;
          1: begin //购买者
              if (CompareText(DealOffInfo.sBuyCharName, m_sCharName) = 0) and (DealOffInfo.N = 0) then begin
                Result := True;
                Break;
              end;
            end;
        end;
      end;
    end; //for
  end;
end;

//客户端元宝寄售结束 20080316  把临时列表数据写入元宝寄售列表中,并清空临时列表

procedure TPlayObject.ClientSellOffEnd(sBuyCharName: string; nSellGold, nGAMEDIAMOND, nCode: Integer);
var
  I, K: Integer;
  bo11: Boolean;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  DealOffInfo: pTDealOffInfo;
begin
  m_boSellOffOK := True;
  bo11 := False;
  if m_boSellOffOK and ((m_SellOffItemList.Count > 0) or (nGAMEDIAMOND > 0)) and (m_SellOffItemList.Count < 10)
    and (length(sBuyCharName) < ACTORNAMELEN + 1) and (nSellGold > 0) and (nSellGold < 100000000) and (CompareText(sBuyCharName, m_sCharName) <> 0) then begin //不能自己寄售给自己 20090204  支持8位元宝寄售20100402
    New(DealOffInfo);
    for K := 0 to 9 do begin
      with DealOffInfo.UseItems[K] do begin
        MakeIndex := 0;
        wIndex := 0;
        Dura := 0;
        DuraMax := 0;
        btValue[0] := 0;
        btValue[1] := 0;
        btValue[2] := 0;
        btValue[3] := 0;
        btValue[4] := 0;
        btValue[5] := 0;
        btValue[6] := 0;
        btValue[7] := 0;
        btValue[8] := 0;
        btValue[9] := 0;
        btValue[10] := 0;
        btValue[11] := 0;
        btValue[12] := 0;
        btValue[13] := 0;
        btValue[14] := 0;
        btValue[15] := 0;
        btValue[16] := 0;
        btValue[17] := 0;
        btValue[18] := 0;
        btValue[19] := 0;
        btValue[20] := 0;
      end;
    end;

    if m_SellOffItemList.Count > 0 then begin //20080629
      for I := 0 to m_SellOffItemList.Count - 1 do begin
        UserItem := m_SellOffItemList.Items[I];
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if (StdItem <> nil) and (StdItem.StdMode = 51) and (UserItem.Dura > 0) and (UserItem.btValue[20] = 1) then begin
          case StdItem.Shape of
            0: begin //是聚灵珠 20080501
                n_UsesItemTick := 0; //时间初始
                UserItem.btValue[12] := 2; //不能聚集的标识
              end;
            1, 2: UserItem.btValue[12] := 2; //内功珠不能聚集的标识
          end;
        end;
        if (UserItem <> nil) and (UserItem.MakeIndex > 0) then DealOffInfo.UseItems[I] := UserItem^;
      end; //for
    end;
    for K := 0 to 9 do begin
      StdItem := UserEngine.GetStdItem(DealOffInfo.UseItems[K].wIndex);
      if (StdItem = nil) and (nGAMEDIAMOND > 0) and (nGAMEDIAMOND < 10000) and (nCode = High(Word)) then begin //物品是金刚石
        if nGAMEDIAMOND > m_nGAMEDIAMOND then begin //金刚石数量大于玩家的数量时则反回失败
          SendMsg(Self, RM_SELLOFFEND_FAIL, 0, 0, 0, 0, '');
          SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '[错误] 你没有那么多' + g_Config.sGameDiaMond);
          GetBackSellOffItems(); //返回物品
          Exit;
        end;
        Dec(m_nGAMEDIAMOND, nGAMEDIAMOND);
        GameGoldChanged(); //更新金刚石数量
        DealOffInfo.UseItems[K].MakeIndex := nGAMEDIAMOND; //金刚石数量
        DealOffInfo.UseItems[K].wIndex := High(Word);
        DealOffInfo.UseItems[K].Dura := High(Word);
        DealOffInfo.UseItems[K].DuraMax := High(Word);
        Break;
      end;
    end;
    DealOffInfo.sDealCharName := m_sCharName; //寄售人
    DealOffInfo.sBuyCharName := Trim(sBuyCharName); //购买人
    DealOffInfo.nSellGold := nSellGold; //元宝数
    DealOffInfo.dSellDateTime := Now(); //操作时间
    DealOffInfo.N := 0; //标识
    sSellOffItemList.Add(DealOffInfo); //增加到元宝寄售列表中
    SendMsg(Self, RM_SELLOFFEND_OK, 0, 0, 0, 0, '');
    Dec(m_nGameGold, g_Config.nDecUserGameGold); //每次扣多少元宝(元宝寄售) 20080319
    if m_nGameGold < 0 then m_nGameGold := 0;
    SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '[成功] 系统已经成功接受您的申请');
    bo11 := True;
    m_boSellOffOK := False;
    m_SellOffItemList.Clear;
  end;
  if not bo11 then begin //失败则返回物品给玩家
    SendMsg(Self, RM_SELLOFFEND_FAIL, 0, 0, 0, 0, '');
    SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '[错误:] 寄售物品失败');
    GetBackSellOffItems();
  end;
end;
//------------------------------------------------------------------------------
//客户端增加交易物品到交易框中

procedure TPlayObject.ClientAddDealItem(nItemIdx: Integer; sItemName: string);
var
  I: Integer;
  bo11: Boolean;
  UserItem: pTUserItem;
  sUserItemName: string;
begin
  if (m_DealCreat = nil) or (not m_boDealing) then Exit;
  m_boCanQueryBag := True; //交易增加物品时,不能刷新包裹 20080917
  try
    if Pos(' ', sItemName) >= 0 then begin //折分物品名称(信件物品的名称后面加了使用次数)
      GetValidStr3(sItemName, sItemName, [' ']);
    end;
    bo11 := False;
    if not m_DealCreat.m_boDealOK then begin
      for I := m_ItemList.Count - 1 downto 0 do begin
        if m_ItemList.Count <= 0 then Break;
        UserItem := m_ItemList.Items[I];
        if UserItem = nil then Continue;
        if UserItem.MakeIndex = nItemIdx then begin
          if (UserItem.AddValue[0] in [1..3]) then Break; //限时物品,绑定物品不能交易
          //取自定义物品名称
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sUserItemName = '' then
            sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

          if (CompareText(sUserItemName, sItemName) = 0) and (m_DealItemList.Count < 12) then begin
            if CheckItemValue(UserItem, 1) then Break //20080314 禁止交易
            else if PlugOfCheckCanItem(1, sUserItemName, False, 0, 0) then Break; //禁止物品规则(管理插件功能) 20080729

            m_DealItemList.Add(UserItem);
            m_ItemList.Delete(I);
            TPlayObject(Self).SendAddDealItem(UserItem);
            bo11 := True;
            Break;
          end;
        end;
      end;
    end;
    if not bo11 then SendDefMessage(SM_DEALADDITEM_FAIL, 0, 0, 0, 0, '');
  finally
    m_boCanQueryBag := False; //交易增加物品时,不能刷新包裹 20080917
  end;
end;
//客户端删除交易物品

procedure TPlayObject.ClientDelDealItem(nItemIdx: Integer; sItemName: string);
var
  I: Integer;
  bo11: Boolean;
  UserItem: pTUserItem;
  sUserItemName: string;
begin
  if g_Config.boCanNotGetBackDeal then begin //禁止取回物品
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sDealItemsDenyGetBackMsg);
    SendDefMessage(SM_DEALDELITEM_FAIL, 0, 0, 0, 0, '');
    Exit;
  end;
  if (m_DealCreat = nil) or (not m_boDealing) then Exit;
  if Pos(' ', sItemName) >= 0 then begin //折分物品名称(信件物品的名称后面加了使用次数)
    GetValidStr3(sItemName, sItemName, [' ']);
  end;
  bo11 := False;
  if not m_DealCreat.m_boDealOK then begin
    for I := m_DealItemList.Count - 1 downto 0 do begin
      if m_DealItemList.Count <= 0 then Break;
      UserItem := m_DealItemList.Items[I];
      if UserItem = nil then Continue;
      if UserItem.MakeIndex = nItemIdx then begin
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

        if CompareText(sUserItemName, sItemName) = 0 then begin
          m_ItemList.Add(UserItem);
          m_DealItemList.Delete(I);
          TPlayObject(Self).SendDelDealItem(UserItem);
          bo11 := True;
          Break;
        end;
      end;
    end; //for
  end;
  if not bo11 then SendDefMessage(SM_DEALDELITEM_FAIL, 0, 0, 0, 0, '');
end;
//客户端取消交易

procedure TPlayObject.ClientCancelDeal;
begin
  DealCancel();
end;
//客户端把金币放到交易框中

procedure TPlayObject.ClientChangeDealGold(nGold: Integer);
var
  bo09: Boolean;
begin
  //禁止取回放入交易栏内的金币
  if (m_nDealGolds > 0) and g_Config.boCanNotGetBackDeal then begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sDealItemsDenyGetBackMsg);
    SendDefMessage(SM_DEALDELITEM_FAIL, 0, 0, 0, 0, '');
    Exit;
  end;
  if nGold < 0 then begin
    SendDefMessage(SM_DEALCHGGOLD_FAIL, m_nDealGolds, LoWord(m_nGold), HiWord(m_nGold), 0, '');
    Exit;
  end;
  bo09 := False;
  if (m_DealCreat <> nil) and (GetPoseCreate = m_DealCreat) then begin
    if not m_DealCreat.m_boDealOK then begin
      if (m_nGold + m_nDealGolds) >= nGold then begin
        m_nGold := (m_nGold + m_nDealGolds) - nGold;
        m_nDealGolds := nGold;
        SendDefMessage(SM_DEALCHGGOLD_OK, m_nDealGolds, LoWord(m_nGold), HiWord(m_nGold), 0, '');
        m_DealCreat.SendDefMessage(SM_DEALREMOTECHGGOLD, m_nDealGolds, 0, 0, 0, '');
        m_DealCreat.m_DealLastTick := GetTickCount();
        bo09 := True;
        m_DealLastTick := GetTickCount();
      end;
    end;
  end;
  if not bo09 then begin
    SendDefMessage(SM_DEALCHGGOLD_FAIL, m_nDealGolds, LoWord(m_nGold), HiWord(m_nGold), 0, '');
  end;
end;
//交易结束

procedure TPlayObject.ClientDealEnd;
var
  I: Integer;
  bo11: Boolean;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  PlayObject: TPlayObject;
begin
  m_boDealOK := True;
  if m_DealCreat = nil then Exit;
  if ((GetTickCount - m_DealLastTick) < g_Config.dwDealOKTime {1000}) or ((GetTickCount - m_DealCreat.m_DealLastTick) < g_Config.dwDealOKTime {1000}) then begin
    SysMsg(g_sDealOKTooFast, c_Red, t_Hint);
    DealCancel();
    Exit;
  end;
  if m_DealCreat.m_boDealOK then begin
    bo11 := True;
    if (MAXBAGITEM - m_ItemList.Count) < m_DealCreat.m_DealItemList.Count then begin
      bo11 := False;
      SysMsg(g_sYourBagSizeTooSmall, c_Red, t_Hint);
    end;
    if (m_nGoldMax - m_nGold) < m_DealCreat.m_nDealGolds then begin
      SysMsg(g_sYourGoldLargeThenLimit, c_Red, t_Hint);
      bo11 := False;
    end;
    if (MAXBAGITEM - m_DealCreat.m_ItemList.Count) < m_DealItemList.Count then begin
      SysMsg(g_sDealHumanBagSizeTooSmall, c_Red, t_Hint);
      bo11 := False;
    end;
    if (m_DealCreat.m_nGoldMax - m_DealCreat.m_nGold) < m_nDealGolds then begin
      SysMsg(g_sDealHumanGoldLargeThenLimit, c_Red, t_Hint);
      bo11 := False;
    end;
    if bo11 then begin
      if m_DealItemList.Count > 0 then begin //20080629
        for I := 0 to m_DealItemList.Count - 1 do begin
          UserItem := m_DealItemList.Items[I];
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) and (StdItem.StdMode = 51) and (UserItem.Dura > 0) and (UserItem.btValue[20] = 1) then begin
            case StdItem.Shape of
              0: begin //是聚灵珠 20080501
                  n_UsesItemTick := 0; //时间初始
                  UserItem.btValue[12] := 2; //不能聚集的标识
                end;
              1, 2: UserItem.btValue[12] := 2; //内功珠不能聚集的标识
            end;
          end;
          m_DealCreat.AddItemToBag(UserItem);
          m_DealCreat.SendAddItem(UserItem);
          if StdItem <> nil then begin
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('8' + #9 + m_sMapName + #9 +
                IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                m_sCharName + #9 + StdItem.Name + #9 +
                IntToStr(UserItem.MakeIndex) + #9 +
                '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + m_DealCreat.m_sCharName);
          end;
        end; //for
      end;
      if m_nDealGolds > 0 then begin
        Inc(m_DealCreat.m_nGold, m_nDealGolds);
        m_DealCreat.GoldChanged();
        if g_boGameLogGold then
          AddGameDataLog('8' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            sSTRING_GOLDNAME + #9 +
            IntToStr(m_nGold) + #9 +
            '1' + #9 +
            m_DealCreat.m_sCharName);
      end;
      if m_DealCreat.m_DealItemList.Count > 0 then begin //20080629
        for I := 0 to m_DealCreat.m_DealItemList.Count - 1 do begin
          UserItem := m_DealCreat.m_DealItemList.Items[I];
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) and (StdItem.StdMode = 51) and (UserItem.Dura > 0) and (UserItem.btValue[20] = 1) then begin
            case StdItem.Shape of
              0: begin //是聚灵珠 20080501
                  m_DealCreat.n_UsesItemTick := 0; //时间初始
                  UserItem.btValue[12] := 2; //不能聚集的标识
                end;
              1, 2: UserItem.btValue[12] := 2; //内功珠不能聚集的标识
            end;
          end;
          AddItemToBag(UserItem);
          TPlayObject(Self).SendAddItem(UserItem);
          if StdItem <> nil then begin
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('8' + #9 +
                m_DealCreat.m_sMapName + #9 +
                IntToStr(m_DealCreat.m_nCurrX) + #9 + IntToStr(m_DealCreat.m_nCurrY) + #9 +
                m_DealCreat.m_sCharName + #9 + StdItem.Name + #9 +
                IntToStr(UserItem.MakeIndex) + #9 +
                '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + m_sCharName);
          end;
        end; //for
      end;
      if m_DealCreat.m_nDealGolds > 0 then begin
        Inc(m_nGold, m_DealCreat.m_nDealGolds);
        GoldChanged();
        if g_boGameLogGold then
          AddGameDataLog('8' + #9 +
            m_DealCreat.m_sMapName + #9 +
            IntToStr(m_DealCreat.m_nCurrX) + #9 +
            IntToStr(m_DealCreat.m_nCurrY) + #9 +
            m_DealCreat.m_sCharName + #9 +
            sSTRING_GOLDNAME + #9 +
            IntToStr(m_DealCreat.m_nGold) + #9 +
            '1' + #9 + m_sCharName);
      end;
      PlayObject := TPlayObject(m_DealCreat);
      PlayObject.SendDefMessage(SM_DEALSUCCESS, 0, 0, 0, 0, '');
      PlayObject.SysMsg(g_sDealSuccessMsg {'交易成功...'}, c_Green, t_Hint);
      PlayObject.m_DealCreat := nil;
      PlayObject.m_boDealing := False;
      PlayObject.m_DealItemList.Clear;
      PlayObject.m_nDealGolds := 0;
      PlayObject.m_boDealOK := False; //Jacky 增加
      SendDefMessage(SM_DEALSUCCESS, 0, 0, 0, 0, '');
      SysMsg(g_sDealSuccessMsg {'交易成功...'}, c_Green, t_Hint);
      m_DealCreat := nil;
      m_boDealing := False;
      m_DealItemList.Clear;
      m_nDealGolds := 0;
      m_boDealOK := False; //Jacky 增加
    end else begin //004DE42F
      DealCancel();
    end;
  end else begin //004DE439
    SysMsg(g_sYouDealOKMsg {'你已经确认交易了'}, c_Green, t_Hint);
    m_DealCreat.SysMsg(g_sPoseDealOKMsg {'对方已经确认交易了'}, c_Green, t_Hint);
  end;
end;

procedure TPlayObject.ClientGetMinMap;
var
  nMinMap: Integer;
begin
  nMinMap := m_PEnvir.nMinMap;
  if nMinMap > 0 then begin
    SendDefMessage(SM_READMINIMAP_OK, 0, nMinMap, 0, 0, '');
  end else begin
    SendDefMessage(SM_READMINIMAP_FAIL, 0, 0, 0, 0, '');
  end;
end;
//客户端取制造的药品

procedure TPlayObject.ClientMakeDrugItem(NPC: TObject; nItemName: string);
var
  Merchant: TMerchant;
begin
  Merchant := UserEngine.FindMerchant(NPC);
  if (Merchant = nil) or (not Merchant.m_boMakeDrug) then Exit;
  if ((Merchant.m_PEnvir = m_PEnvir) and
    (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
    (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientMakeDrugItem(Self, nItemName);
end;
//客户端打开行会对话框

procedure TPlayObject.ClientOpenGuildDlg;
var
  I: Integer;
  SC: string;
begin
  if m_MyGuild <> nil then begin
    SC := TGUild(m_MyGuild).sGuildName + #13 + ' ' + #13;
    if m_nGuildRankNo = 1 then begin
      SC := SC + '1' + #13;
    end else begin
      SC := SC + '0' + #13;
    end;
    SC := SC + '<Notice>' + #13;
    if TGUild(m_MyGuild).NoticeList.Count > 0 then begin //20080629
      for I := 0 to TGUild(m_MyGuild).NoticeList.Count - 1 do begin //行会公告
        if Length(SC) > 5000 then Break;
        SC := SC + Trim(TGUild(m_MyGuild).NoticeList.Strings[I]) + #13; //增加Trim函数，防止客户端不停循环空格 20090302
      end; // for
    end;
    SC := SC + '<KillGuilds>' + #13;
    if TGUild(m_MyGuild).GuildWarList.Count > 0 then begin //20080629
      for I := 0 to TGUild(m_MyGuild).GuildWarList.Count - 1 do begin //敌对行会
        if Length(SC) > 5000 then Break;
        SC := SC + Trim(TGUild(m_MyGuild).GuildWarList.Strings[I]) + #13; //增加Trim函数，防止客户端不停循环空格 20090302
      end; // for
    end;
    SC := SC + '<AllyGuilds>' + #13;
    if TGUild(m_MyGuild).GuildAllList.Count > 0 then begin //20080629
      for I := 0 to TGUild(m_MyGuild).GuildAllList.Count - 1 do begin //联盟行会
        if Length(SC) > 5000 then Break;
        SC := SC + Trim(TGUild(m_MyGuild).GuildAllList.Strings[I]) + #13; //增加Trim函数，防止客户端不停循环空格 20090302
      end; // for
    end;
    m_DefMsg := MakeDefaultMsg(SM_OPENGUILDDLG, 0, 0, 0, 1, 0);
    SendSocket(@m_DefMsg, EncodeString(SC));
  end else begin
    SendDefMessage(SM_OPENGUILDDLG_FAIL, 0, 0, 0, 0, '');
  end;
end;

procedure TPlayObject.ClientGuildHome;
begin
  ClientOpenGuildDlg();
end;
//取行会成员列表

procedure TPlayObject.ClientGuildMemberList;
var
  GuildRank: pTGuildRank;
  I, II: Integer;
  sSENDMSG: string;
begin
  if m_MyGuild = nil then Exit;
  if TGUild(m_MyGuild).m_RankList.Count > 0 then begin //20080629
    for I := 0 to TGUild(m_MyGuild).m_RankList.Count - 1 do begin
      GuildRank := TGUild(m_MyGuild).m_RankList.Items[I];
      if GuildRank = nil then Continue;
      sSENDMSG := sSENDMSG + '#' + IntToStr(GuildRank.nRankNo) + '/*' + GuildRank.sRankName + '/';
      if GuildRank.MemberList.Count > 0 then begin //20080629
        for II := 0 to GuildRank.MemberList.Count - 1 do begin
          if Length(sSENDMSG) > 5000 then Break;
          sSENDMSG := sSENDMSG + GuildRank.MemberList.Strings[II] + '/';
        end;
      end;
    end;
  end;
  m_DefMsg := MakeDefaultMsg(SM_SENDGUILDMEMBERLIST, 0, 0, 0, 1, 0);
  SendSocket(@m_DefMsg, EncodeString(sSENDMSG));
end;
//客户端行会增加成员

procedure TPlayObject.ClientGuildAddMember(sHumName: string);
var
  nC: Integer;
  PlayObject: TPlayObject;
begin
  nC := 1; //'你没有权利使用这个命令。'
  if IsGuildMaster then begin
    PlayObject := UserEngine.GetPlayObject(sHumName);
    if (PlayObject <> nil) and (not PlayObject.m_boNotOnlineAddExp) then begin //2006-10-30增加检测不是离线挂机人物
      if (PlayObject.GetPoseCreate = Self) and (PlayObject.GetPoseCreate <> nil) then begin
        if PlayObject.m_boAllowGuild then begin
          if not TGUild(m_MyGuild).IsMember(sHumName) then begin
            if (PlayObject.m_MyGuild = nil) then begin
              if not TGUild(m_MyGuild).IsFull then begin //20110305 修改
                TGUild(m_MyGuild).AddMember(PlayObject);
                //UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGUild(m_MyGuild).sGuildName);//20101022 注释
                PlayObject.m_MyGuild := m_MyGuild;
                PlayObject.m_sGuildRankName := TGUild(m_MyGuild).GetRankName(PlayObject, PlayObject.m_nGuildRankNo);
                PlayObject.RefShowName();
                PlayObject.SysMsg('您已加入行会: ' + TGUild(m_MyGuild).sGuildName + ' 当前封号为: ' + PlayObject.m_sGuildRankName, c_Green, t_Hint);
                nC := 0;
              end else nC := 6;
            end else nC := 4; //'对方已经加入其他行会。'
          end else nC := 3; //'对方已经加入我们的行会。'
        end else begin //
          nC := 5; //'对方不允许加入行会。'
          PlayObject.SysMsg('您拒绝加入行会。 [允许命令为 @' + g_GameCommand.LETGUILD.sCmd + ']', c_Red, t_Hint);
        end;
      end else nC := 2; //'想加入行会的应该来面对行会掌门人'
    end else nC := 2;
  end;
  if nC = 0 then begin
    SendDefMessage(SM_GUILDADDMEMBER_OK, 0, 0, 0, 0, '');
  end else begin
    SendDefMessage(SM_GUILDADDMEMBER_FAIL, nC, 0, 0, 0, '');
  end;
end;
//客户端行会删除成员

procedure TPlayObject.ClientGuildDelMember(sHumName: string);
var
  nC: Integer;
  s14: string;
  PlayObject: TPlayObject;
begin
  nC := 1;
  if IsGuildMaster then begin
    if TGUild(m_MyGuild).IsMember(sHumName) then begin
      if m_sCharName <> sHumName then begin
        if TGUild(m_MyGuild).DelMember(sHumName) then begin
          PlayObject := UserEngine.GetPlayObject(sHumName);
          if PlayObject <> nil then begin
            PlayObject.m_MyGuild := nil;
            PlayObject.RefRankInfo(0, '');
            PlayObject.RefShowName(); //10/31
          end;
          //UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGUild(m_MyGuild).sGuildName);//20101022 注释
          nC := 0;
        end else nC := 4;
      end else begin
        nC := 3;
        s14 := TGUild(m_MyGuild).sGuildName;
        if TGUild(m_MyGuild).CancelGuld(sHumName) then begin
          g_GuildManager.DELGUILD(s14);
          //UserEngine.SendServerGroupMsg(SS_206, nServerIndex, s14);//20101022 注释
          m_MyGuild := nil;
          RefRankInfo(0, '');
          RefShowName(); //10/31
          SysMsg('行会' + s14 + '已被取消！', c_Red, t_Hint);
          nC := 0;
        end
      end;
    end else nC := 2;
  end;
  if nC = 0 then begin
    SendDefMessage(SM_GUILDDELMEMBER_OK, 0, 0, 0, 0, '');
  end else begin
    SendDefMessage(SM_GUILDDELMEMBER_FAIL, nC, 0, 0, 0, '');
  end;
end;
//客户端行会更新公告

procedure TPlayObject.ClientGuildUpdateNotice(sNotict: string);
var
  SC: string;
begin
  if Length(sNotict) > 4000 then sNotict := Copy(sNotict, 1, 4000); //20100913 限制行会公告长度
  if (m_MyGuild = nil) or (m_nGuildRankNo <> 1) then Exit;
  TGUild(m_MyGuild).NoticeList.Clear;
  while (sNotict <> '') do begin
    sNotict := GetValidStr3(sNotict, SC, [#$D]);
    TGUild(m_MyGuild).NoticeList.Add(SC);
  end; // while
  TGUild(m_MyGuild).SaveGuildInfoFile();
  //UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGUild(m_MyGuild).sGuildName);//20101022 注释
  ClientOpenGuildDlg();
end;
//修改行会成员封号,等级

procedure TPlayObject.ClientGuildUpdateRankInfo(sRankInfo: string);
var
  nC: Integer;
begin
  if (m_MyGuild = nil) or (m_nGuildRankNo <> 1) then Exit; //没有行会或不是行会老大则退出
  nC := TGUild(m_MyGuild).UpdateRank(sRankInfo);
  if nC = 0 then begin
    //UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGUild(m_MyGuild).sGuildName);//20101022 注释
    ClientGuildMemberList();
  end else begin
    if nC <= -2 then begin
      SendDefMessage(SM_GUILDRANKUPDATE_FAIL, nC, 0, 0, 0, '');
    end;
  end;
end;
//行会联盟

procedure TPlayObject.ClientGuildAlly;
var
  n8: Integer;
  nCode: Integer;
  BaseObjectC: TBaseObject;
resourcestring
  sExceptionMsg = '{%s} TPlayObject::ClientGuildAlly %d';
begin
  nCode := 1;
  try
    n8 := -1;
    BaseObjectC := GetPoseCreate();
    nCode := 2;
    if (BaseObjectC <> nil) then begin //20090213
      if (BaseObjectC.m_MyGuild <> nil) and (BaseObjectC.m_btRaceServer = RC_PLAYOBJECT) and
        (BaseObjectC.GetPoseCreate = Self) then begin
        if (TGUild(BaseObjectC.m_MyGuild) <> nil) and (TGUild(BaseObjectC.m_MyGuild).m_boEnableAuthAlly) then begin
          nCode := 3;
          if BaseObjectC.IsGuildMaster and IsGuildMaster then begin
            nCode := 4;
            if (TGUild(m_MyGuild) <> nil) and TGUild(m_MyGuild).IsNotWarGuild(TGUild(BaseObjectC.m_MyGuild)) and
              TGUild(BaseObjectC.m_MyGuild).IsNotWarGuild(TGUild(m_MyGuild)) then begin
              nCode := 6;
              TGUild(m_MyGuild).AllyGuild(TGUild(BaseObjectC.m_MyGuild));
              nCode := 7;
              TGUild(BaseObjectC.m_MyGuild).AllyGuild(TGUild(m_MyGuild));
              nCode := 8;
              TGUild(m_MyGuild).SendGuildMsg(TGUild(BaseObjectC.m_MyGuild).sGuildName + '行会已经和您的行会联盟成功。');
              nCode := 9;
              TGUild(BaseObjectC.m_MyGuild).SendGuildMsg(TGUild(m_MyGuild).sGuildName + '行会已经和您的行会联盟成功。');
              nCode := 10;
              TGUild(m_MyGuild).RefMemberName;
              nCode := 11;
              TGUild(BaseObjectC.m_MyGuild).RefMemberName;
              {nCode := 12;
              UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGUild(m_MyGuild).sGuildName); //20101022 注释
              nCode := 13;
              UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGUild(BaseObjectC.m_MyGuild).sGuildName);
              nCode := 14; }
              n8 := 0;
            end else n8 := -2;
          end else n8 := -3;
        end else n8 := -4;
      end;
    end;
    if n8 = 0 then begin
      SendDefMessage(SM_GUILDMAKEALLY_OK, 0, 0, 0, 0, '');
    end else begin
      SendDefMessage(SM_GUILDMAKEALLY_FAIL, n8, 0, 0, 0, '');
    end;
  except
    on E: Exception do begin
      MainOutMessage(Format(sExceptionMsg, [g_sExceptionVer, nCode]));
    end;
  end;
end;
//行会解除联盟

procedure TPlayObject.ClientGuildBreakAlly(sGuildName: string);
var
  n10: Integer;
  Guild: TGUild;
begin
//  n10 := -1;
  if not IsGuildMaster() then Exit;
  Guild := g_GuildManager.FindGuild(sGuildName);
  if (Guild <> nil) and (m_MyGuild <> nil) then begin
    if TGUild(m_MyGuild).IsAllyGuild(Guild) then begin
      TGUild(m_MyGuild).DelAllyGuild(Guild);
      Guild.DelAllyGuild(TGUild(m_MyGuild));
      TGUild(m_MyGuild).SendGuildMsg(Guild.sGuildName + ' 行会与您的行会解除联盟成功！');
      Guild.SendGuildMsg(TGUild(m_MyGuild).sGuildName + ' 行会解除了与您行会的联盟！');
      TGUild(m_MyGuild).RefMemberName();
      Guild.RefMemberName();
      //UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGUild(m_MyGuild).sGuildName); //20101022 注释
      //UserEngine.SendServerGroupMsg(SS_207, nServerIndex, Guild.sGuildName);//20101022 注释
      n10 := 0;
    end else n10 := -2;
  end else n10 := -3;
  if n10 = 0 then begin
    SendDefMessage(SM_GUILDBREAKALLY_OK, 0, 0, 0, 0, '');
  end else begin
    SendDefMessage(SM_GUILDMAKEALLY_FAIL, 0, 0, 0, 0, '');
  end;
end;

procedure TPlayObject.RecalcAdjusBonus();
  procedure AdjustAb(Abil: Word {Byte}; Val: Word; var lov, hiv: Word); //参数为BYTE时，出现越界 20081204
  var
    Lo, Hi: Byte;
    I: Integer;
  begin
    Lo := LoByte(Abil);
    Hi := HiByte(Abil);
    lov := 0; hiv := 0;
    for I := 1 to Val do begin
      if Lo + 1 < Hi then begin
        Inc(Lo);
        Inc(lov);
      end else begin
        Inc(Hi);
        Inc(hiv);
      end;
    end;
  end;
var
  BonusTick: pTNakedAbility;
  NakedAbil: pTNakedAbility;
  adc, amc, asc, aac, amac: Integer;
  ldc, lmc, lsc, lac, lmac, hdc, hmc, hsc, hac, hmac: Word;
begin
  try
    BonusTick := nil;
    NakedAbil := nil;
    case m_btJob of
      0: begin
          BonusTick := @g_Config.BonusAbilofWarr;
          NakedAbil := @g_Config.NakedAbilofWarr;
        end;
      1: begin
          BonusTick := @g_Config.BonusAbilofWizard;
          NakedAbil := @g_Config.NakedAbilofWizard;
        end;
      2: begin
          BonusTick := @g_Config.BonusAbilofTaos;
          NakedAbil := @g_Config.NakedAbilofTaos;
        end;
      {3: begin//刺客(暂时用战士参数)
          BonusTick := @g_Config.BonusAbilofWarr;
          NakedAbil := @g_Config.NakedAbilofWarr;
        end; }
    end;
    adc := m_BonusAbil.DC div BonusTick.DC;
    amc := m_BonusAbil.MC div BonusTick.MC;
    asc := m_BonusAbil.SC div BonusTick.SC;
    aac := m_BonusAbil.AC div BonusTick.AC;
    amac := m_BonusAbil.MAC div BonusTick.MAC;

    AdjustAb(NakedAbil.DC, adc, ldc, hdc);
    AdjustAb(NakedAbil.MC, amc, lmc, hmc);
    AdjustAb(NakedAbil.SC, asc, lsc, hsc);
    AdjustAb(NakedAbil.AC, aac, lac, hac);
    AdjustAb(NakedAbil.MAC, amac, lmac, hmac);
    //lac  := 0;  hac := aac;
    //lmac := 0;  hmac := amac;
    m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC) + ldc, HiWord(m_WAbil.DC) + hdc);
    m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC) + lmc, HiWord(m_WAbil.MC) + hmc);
    m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC) + lsc, HiWord(m_WAbil.SC) + hsc);
    m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC) + lac, HiWord(m_WAbil.AC) + hac);
    m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC) + lmac, HiWord(m_WAbil.MAC) + hmac);

    if m_WAbil.MaxHP + m_BonusAbil.HP div BonusTick.HP > High(Integer) then begin //20091026 修改
      m_WAbil.MaxHP := High(Integer);
    end else m_WAbil.MaxHP := m_WAbil.MaxHP + m_BonusAbil.HP div BonusTick.HP;
    if m_WAbil.MaxMP + m_BonusAbil.MP div BonusTick.MP > High(Integer) then begin //20091026 修改
      m_WAbil.MaxMP := High(Integer);
    end else m_WAbil.MaxMP := m_WAbil.MaxMP + m_BonusAbil.MP div BonusTick.MP;
    //m_WAbil.MaxHP := _MIN(High(Word), m_WAbil.MaxHP + m_BonusAbil.HP div BonusTick.HP);
    //m_WAbil.MaxMP := _MIN(High(Word), m_WAbil.MaxMP + m_BonusAbil.MP div BonusTick.MP);
    //m_btSpeedPoint:=m_btSpeedPoint + m_BonusAbil.Speed div BonusTick.Speed;
    //m_btHitPoint:=m_btHitPoint + m_BonusAbil.Hit div BonusTick.Hit;
  except   
    MainOutMessage(Format('{%s} TPlayObject.RecalcAdjusBonus', [g_sExceptionVer]));
  end;
end;
//接受客户端返回，设置奖励属性点

procedure TPlayObject.ClientAdjustBonus(nPoint: Integer; sMsg: string);
var
  BonusAbil: TNakedAbility;
  nTotleUsePoint: Integer;
begin
  FillChar(BonusAbil, SizeOf(TNakedAbility), #0);
  DecodeBuffer(sMsg, @BonusAbil, SizeOf({TNakedAbility}BonusAbil));
  nTotleUsePoint := BonusAbil.DC + BonusAbil.MC + BonusAbil.SC + BonusAbil.AC +
    BonusAbil.MAC + BonusAbil.HP + BonusAbil.MP + BonusAbil.Hit +
    BonusAbil.Speed + BonusAbil.X2;
  if ((nPoint + nTotleUsePoint) = m_nBonusPoint) and (m_nBonusPoint > 0) and (nPoint >= 0) and (m_nBonusPoint >= nPoint) then begin
    if nTotleUsePoint > 0 then begin
      m_nBonusPoint := nPoint;
      Inc(m_BonusAbil.DC, BonusAbil.DC);
      Inc(m_BonusAbil.MC, BonusAbil.MC);
      Inc(m_BonusAbil.SC, BonusAbil.SC);
      Inc(m_BonusAbil.AC, BonusAbil.AC);
      Inc(m_BonusAbil.MAC, BonusAbil.MAC);
      Inc(m_BonusAbil.HP, BonusAbil.HP);
      Inc(m_BonusAbil.MP, BonusAbil.MP);
      Inc(m_BonusAbil.Hit, BonusAbil.Hit);
      Inc(m_BonusAbil.Speed, BonusAbil.Speed);
      Inc(m_BonusAbil.X2, BonusAbil.X2);
      RecalcAbilitys();
      CompareSuitItem(False); //套装与身上装备对比 20080729
      SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
      SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
    end;
  end else begin
    SysMsg('非法数据调整！', c_Red, t_Hint);
  end;
end;

function TPlayObject.GetMyStatus: Integer;
begin
  Result := m_nHungerStatus div 1000;
  if Result > 4 then Result := 4;
end;
//发送升级后的属性奖励

procedure TPlayObject.SendAdjustBonus;
var
  sSENDMSG: string;
  //NakedAbil:TNakedAbility;
begin
  if m_boNotOnlineAddExp or m_boAI then Exit;
  m_DefMsg := MakeDefaultMsg(SM_ADJUST_BONUS, m_nBonusPoint, 0, 0, 0, 0);
  sSENDMSG := '';
  //NakedAbil:=m_BonusAbil;
  //FillChar(NakedAbil,SizeOf(TNakedAbility),#0);
  case m_btJob of //
    0: sSENDMSG := EncodeBuffer(@g_Config.BonusAbilofWarr, SizeOf(TNakedAbility)) + '/' +
      EncodeBuffer(@m_BonusAbil, SizeOf(TNakedAbility)) + '/' +
        EncodeBuffer(@g_Config.NakedAbilofWarr, SizeOf(TNakedAbility));
    1: sSENDMSG := EncodeBuffer(@g_Config.BonusAbilofWizard, SizeOf(TNakedAbility)) + '/' +
      EncodeBuffer(@m_BonusAbil, SizeOf(TNakedAbility)) + '/' +
        EncodeBuffer(@g_Config.NakedAbilofWizard, SizeOf(TNakedAbility));
    2: sSENDMSG := EncodeBuffer(@g_Config.BonusAbilofTaos, SizeOf(TNakedAbility)) + '/' +
      EncodeBuffer(@m_BonusAbil, SizeOf(TNakedAbility)) + '/' +
        EncodeBuffer(@g_Config.NakedAbilofTaos, SizeOf(TNakedAbility));
    {3: sSENDMSG := EncodeBuffer(@g_Config.BonusAbilofWarr, SizeOf(TNakedAbility)) + '/' + //刺客(暂时用战士参数)
      EncodeBuffer(@m_BonusAbil, SizeOf(TNakedAbility)) + '/' +
        EncodeBuffer(@g_Config.NakedAbilofWarr, SizeOf(TNakedAbility));}
  end; // case
  SendSocket(@m_DefMsg, sSENDMSG);
end;

function TBaseObject.GetAttackDir(BaseObject: TBaseObject; var btDir: Byte): Boolean;
begin
  Result := False;
  if (m_nCurrX - 1 <= BaseObject.m_nCurrX) and
    (m_nCurrX + 1 >= BaseObject.m_nCurrX) and
    (m_nCurrY - 1 <= BaseObject.m_nCurrY) and
    (m_nCurrY + 1 >= BaseObject.m_nCurrY) and
    ((m_nCurrX <> BaseObject.m_nCurrX) or
    (m_nCurrY <> BaseObject.m_nCurrY)) then begin
    Result := True;
    if ((m_nCurrX - 1) = BaseObject.m_nCurrX) and (m_nCurrY = BaseObject.m_nCurrY) then begin
      btDir := DR_LEFT;
      Exit;
    end;
    if ((m_nCurrX + 1) = BaseObject.m_nCurrX) and (m_nCurrY = BaseObject.m_nCurrY) then begin
      btDir := DR_RIGHT;
      Exit;
    end;
    if (m_nCurrX = BaseObject.m_nCurrX) and ((m_nCurrY - 1) = BaseObject.m_nCurrY) then begin
      btDir := DR_UP;
      Exit;
    end;
    if (m_nCurrX = BaseObject.m_nCurrX) and ((m_nCurrY + 1) = BaseObject.m_nCurrY) then begin
      btDir := DR_DOWN;
      Exit;
    end;
    if ((m_nCurrX - 1) = BaseObject.m_nCurrX) and ((m_nCurrY - 1) = BaseObject.m_nCurrY) then begin
      btDir := DR_UPLEFT;
      Exit;
    end;
    if ((m_nCurrX + 1) = BaseObject.m_nCurrX) and ((m_nCurrY - 1) = BaseObject.m_nCurrY) then begin
      btDir := DR_UPRIGHT;
      Exit;
    end;
    if ((m_nCurrX - 1) = BaseObject.m_nCurrX) and ((m_nCurrY + 1) = BaseObject.m_nCurrY) then begin
      btDir := DR_DOWNLEFT;
      Exit;
    end;
    if ((m_nCurrX + 1) = BaseObject.m_nCurrX) and ((m_nCurrY + 1) = BaseObject.m_nCurrY) then begin
      btDir := DR_DOWNRIGHT;
      Exit;
    end;
    btDir := 0;
  end;
end;

function TBaseObject.GetAttackDir(BaseObject: TBaseObject; nRange: Integer; var btDir: Byte): Boolean;
var
  nX, nY: Integer;
begin
  Result := False;
  btDir := GetNextDirection(m_nCurrX, m_nCurrY, BaseObject.m_nCurrX, BaseObject.m_nCurrY);
  if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, nRange, nX, nY) then begin
    Result := BaseObject = TBaseObject(m_PEnvir.GetMovingObject(nX, nY, True));
  end;
end;

function TBaseObject.TargetInSpitRange(BaseObject: TBaseObject; var btDir: Byte): Boolean; //004C3E68
var
  n14, n18: Integer;
begin
  Result := False;
  if (abs(BaseObject.m_nCurrX - m_nCurrX) <= 2) and (abs(BaseObject.m_nCurrY - m_nCurrY) <= 2) then begin
    n14 := BaseObject.m_nCurrX - m_nCurrX;
    n18 := BaseObject.m_nCurrY - m_nCurrY;
    if (abs(n14) <= 1) and (abs(n18) <= 1) then begin
      GetAttackDir(BaseObject, btDir);
      Result := True;
      Exit;
    end;
    Inc(n14, 2);
    Inc(n18, 2);
    if ((n14 >= 0) and (n14 <= 4)) and ((n18 >= 0) and (n18 <= 4)) then begin
      btDir := GetNextDirection(m_nCurrX, m_nCurrY, BaseObject.m_nCurrX, BaseObject.m_nCurrY);
      if g_Config.SpitMap[btDir, n18, n14] = 1 then
        Result := True;
    end;
  end;
end;
//刷新包裹重量

function TBaseObject.RecalcBagWeight: Integer;
var
  I: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  nCode: Byte;
begin
  Result := 0;
  nCode := 0;
  try
    if //m_boDeath or  修复死亡后 无限负重买东西的Bug By TasNat at: 2012-03-23 19:05:58
    m_boGhost then Exit;
    if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) then begin //20090518 增加
      if m_ItemList <> nil then begin
        if m_ItemList.Count > 0 then begin
          nCode := 1;
          for I := 0 to m_ItemList.Count - 1 do begin
            nCode := 2;
            UserItem := m_ItemList.Items[I];
            nCode := 3;
            if UserItem <> nil then begin
              nCode := 4;
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem <> nil then begin
                nCode := 5;
                if StdItem.StdMode = 17 then begin //叠加物品，按数量计算 20090816
                  if StdItem.Weight > 0 then Inc(Result, UserItem.Dura); //当DB设置大于0时才以数量累计重量
                end else Inc(Result, StdItem.Weight);
              end;
            end;
          end;
        end;
      end;
    end;
  except   
    MainOutMessage(Format('{%s} TBaseObject.RecalcBagWeight Name:%s Code:%d', [g_sExceptionVer, m_sCharName, nCode]));
  end;
end;
//重新计算攻击敏捷以及赋值魔法

procedure TBaseObject.RecalcHitSpeed;
var
  I: Integer;
  UserMagic: pTUserMagic;
  BonusTick: pTNakedAbility;
  nCode: byte;
begin
  nCode := 0;
  try
    BonusTick := nil;
    nCode := 255;
    case m_btJob of
      0: BonusTick := @g_Config.BonusAbilofWarr;
      1: BonusTick := @g_Config.BonusAbilofWizard;
      2: BonusTick := @g_Config.BonusAbilofTaos;
      //3: BonusTick := @g_Config.BonusAbilofWarr;//刺客(暂时用战士参数)
    end;
    nCode := 254;
    m_btHitPoint := DEFHIT + m_BonusAbil.Hit div BonusTick.Hit;
    nCode := 1;
    case m_btJob of
      TAOS: m_btSpeedPoint := DEFSPEED + m_BonusAbil.Speed div BonusTick.Speed + 3;
    else m_btSpeedPoint := DEFSPEED + m_BonusAbil.Speed div BonusTick.Speed;
    end;

    m_nHitPlus := 0;
    m_btHitPointSkill88 := 0;
    m_nHitDouble := 0;
    nCode := 2;
    m_MagicOneSwordSkill := nil;
    m_MagicPowerHitSkill := nil;
    m_MagicErgumSkill := nil;
    m_Magic89Skill := nil;
    m_MagicBanwolSkill := nil;
    m_Magic90Skill := nil;
    m_MagicFireSwordSkill := nil;
    m_MagicCrsSkill := nil;
    m_Magic41Skill := nil;
    m_Magic42Skill := nil;
    m_Magic43Skill := nil;

    m_Magic67Skill := nil; //先天元力 20080626
    m_Magic68Skill := nil; //酒气护体 20080625
    m_Magic71Skill := nil; //召唤圣兽
    m_Magic74Skill := nil; //逐日剑法 20080511
    m_Magic96Skill := nil; //血魄一击(战)
    m_Magic104Skill := nil; //召唤火灵
    nCode := 3;
    case m_btRaceServer of
      RC_PLAYOBJECT: begin
          with TPlayObject(self) do begin
{$IF M2Version <> 2}
            m_Magic100Skill := nil; //神秘解读
            m_Magic103Skill := nil; //召唤巨魔
            m_MagicSkill_105 := nil; //龙卫心法
            m_MagicSkill_106 := nil; //传承心法
            m_MagicSkill_107 := nil; //纵横剑术
            m_MagicSkill_108 := nil; //冰霜雪雨
            m_MagicSkill_109 := nil; //裂神符
            m_MagicSkill_113 := nil; //天雷乱舞
            m_MagicSkill_200 := nil; //怒之攻杀
            m_MagicSkill_201 := nil; //静之攻杀
            m_MagicSkill_202 := nil; //怒之半月
            m_MagicSkill_203 := nil; //静之半月
            m_MagicSkill_204 := nil; //怒之烈火
            m_MagicSkill_205 := nil; //静之烈火
            m_MagicSkill_206 := nil; //怒之逐日
            m_MagicSkill_207 := nil; //静之逐日
            m_MagicSkill_208 := nil; //怒之火球
            m_MagicSkill_209 := nil; //静之火球
            m_MagicSkill_210 := nil; //怒之大火球
            m_MagicSkill_211 := nil; //静之大火球
            m_MagicSkill_212 := nil; //怒之火墙
            m_MagicSkill_213 := nil; //静之火墙
            m_MagicSkill_214 := nil; //怒之地狱火
            m_MagicSkill_215 := nil; //静之地狱火
            m_MagicSkill_216 := nil; //怒之疾光电影
            m_MagicSkill_217 := nil; //静之疾光电影
            m_MagicSkill_218 := nil; //怒之爆裂火焰
            m_MagicSkill_219 := nil; //静之爆裂火焰
            m_MagicSkill_220 := nil; //怒之冰咆哮
            m_MagicSkill_221 := nil; //静之冰咆哮
            m_MagicSkill_222 := nil; //怒之雷电
            m_MagicSkill_223 := nil; //静之雷电
            m_MagicSkill_224 := nil; //怒之地狱雷光
            m_MagicSkill_225 := nil; //静之地狱雷光
            m_MagicSkill_226 := nil; //怒之寒冰掌
            m_MagicSkill_227 := nil; //静之寒冰掌
            m_MagicSkill_228 := nil; //怒之灭天火
            m_MagicSkill_229 := nil; //静之灭天火
            m_MagicSkill_230 := nil; //怒之火符
            m_MagicSkill_231 := nil; //静之火符
            m_MagicSkill_232 := nil; //怒之噬血
            m_MagicSkill_233 := nil; //静之噬血
            m_MagicSkill_234 := nil; //怒之流星火雨
            m_MagicSkill_235 := nil; //静之流星火雨
            m_MagicSkill_236 := nil; //怒之内功剑法
            m_MagicSkill_237 := nil; //静之内功剑法
            m_MagicSkill_238 := nil; //静之开天斩
{$IF M2Version = 1}
            m_Magic95Skill := nil; //斗转星移
            m_MagicSkill_239 := nil; //怒之施毒术
            m_MagicSkill_240 := nil; //静之施毒术
            m_MagicSkill_241 := nil; //怒之月灵
            m_MagicSkill_242 := nil; //静之月灵
            m_Magic76Skill := nil; //三绝杀
            m_Magic79Skill := nil; //追心刺
            m_Magic82Skill := nil; //断岳斩
            m_Magic85Skill := nil; //横扫千军
{$IFEND}
{$IFEND}
          end;
        end;
      RC_HEROOBJECT: begin
          with THEROOBJECT(self) do begin
            m_Magic46Skill := nil; //分身术 20081217
            m_Magic60Skill := nil; //破魂斩
{$IF M2Version <> 2}
            m_Magic102Skill := nil; //唯我独尊
            m_Magic99Skill := nil; //强身术 20100817
            m_MagicSkill_200 := nil; //怒之攻杀
            m_MagicSkill_201 := nil; //静之攻杀
            m_MagicSkill_202 := nil; //怒之半月
            m_MagicSkill_203 := nil; //静之半月
            m_MagicSkill_204 := nil; //怒之烈火
            m_MagicSkill_205 := nil; //静之烈火
            m_MagicSkill_206 := nil; //怒之逐日
            m_MagicSkill_207 := nil; //静之逐日
            m_MagicSkill_208 := nil; //怒之火球
            m_MagicSkill_209 := nil; //静之火球
            m_MagicSkill_210 := nil; //怒之大火球
            m_MagicSkill_211 := nil; //静之大火球
            m_MagicSkill_212 := nil; //怒之火墙
            m_MagicSkill_213 := nil; //静之火墙
            m_MagicSkill_214 := nil; //怒之地狱火
            m_MagicSkill_215 := nil; //静之地狱火
            m_MagicSkill_216 := nil; //怒之疾光电影
            m_MagicSkill_217 := nil; //静之疾光电影
            m_MagicSkill_218 := nil; //怒之爆裂火焰
            m_MagicSkill_219 := nil; //静之爆裂火焰
            m_MagicSkill_220 := nil; //怒之冰咆哮
            m_MagicSkill_221 := nil; //静之冰咆哮
            m_MagicSkill_222 := nil; //怒之雷电
            m_MagicSkill_223 := nil; //静之雷电
            m_MagicSkill_224 := nil; //怒之地狱雷光
            m_MagicSkill_225 := nil; //静之地狱雷光
            m_MagicSkill_226 := nil; //怒之寒冰掌
            m_MagicSkill_227 := nil; //静之寒冰掌
            m_MagicSkill_228 := nil; //怒之灭天火
            m_MagicSkill_229 := nil; //静之灭天火
            m_MagicSkill_230 := nil; //怒之火符
            m_MagicSkill_231 := nil; //静之火符
            m_MagicSkill_232 := nil; //怒之噬血
            m_MagicSkill_233 := nil; //静之噬血
            m_MagicSkill_234 := nil; //怒之流星火雨
            m_MagicSkill_235 := nil; //静之流星火雨
            m_MagicSkill_236 := nil; //怒之内功剑法
            m_MagicSkill_237 := nil; //静之内功剑法
            m_MagicSkill_238 := nil; //静之开天斩
{$IF M2Version = 1}
            m_Magic95Skill := nil; //斗转星移
            m_MagicSkill_239 := nil; //怒之施毒术
            m_MagicSkill_240 := nil; //静之施毒术
            m_MagicSkill_241 := nil; //怒之月灵
            m_MagicSkill_242 := nil; //静之月灵
            m_Magic76Skill := nil; //三绝杀
            m_Magic79Skill := nil; //追心刺
            m_Magic82Skill := nil; //断岳斩
            m_Magic85Skill := nil; //横扫千军
{$IFEND}
{$IFEND}
          end;
        end;
    end;
    nCode := 4;
    if m_MagicList.Count > 0 then begin //20080629
      for I := 0 to m_MagicList.Count - 1 do begin
        nCode := 5;
        UserMagic := m_MagicList.Items[I];
        nCode := 6;
        if UserMagic = nil then Continue;
        nCode := 7;
        case UserMagic.wMagIdx of
          SKILL_ONESWORD: begin //基本剑术
              m_MagicOneSwordSkill := UserMagic;
              if UserMagic.btLevel > 0 then begin
                m_btHitPoint := _MIN(High(Byte), m_btHitPoint + Round(9 / 3 * UserMagic.btLevel));
              end;
            end;
          SKILL_88: begin //四级基本剑术
              if UserMagic.btLevel > 0 then begin
                m_btHitPoint := _MIN(High(Byte), m_btHitPoint + Round(9 / 3 * UserMagic.btLevel));
              end;
              m_btHitPointSkill88 := 2;
            end;
          SKILL_YEDO: begin //攻杀剑法
              m_MagicPowerHitSkill := UserMagic;
              if UserMagic.btLevel > 0 then begin
                m_btHitPoint := _MIN(High(Byte), m_btHitPoint + Round(3 / 3 * UserMagic.btLevel));
              end;
              m_nHitPlus := DEFHIT + UserMagic.btLevel;
              m_btAttackSkillCount := 7 - UserMagic.btLevel;
              m_btAttackSkillPointCount := Random(m_btAttackSkillCount);
            end;
          SKILL_ERGUM: m_MagicErgumSkill := UserMagic; //刺杀剑法
          SKILL_89: m_Magic89Skill := UserMagic; //四级刺杀剑术
          SKILL_BANWOL: m_MagicBanwolSkill := UserMagic; //半月弯刀
          SKILL_90: m_Magic90Skill := UserMagic; //圆月弯刀(四级半月弯刀)
          SKILL_FIRESWORD: begin //烈火剑法
              m_MagicFireSwordSkill := UserMagic;
              m_nHitDouble := 4 + UserMagic.btLevel * 4;
            end;
          SKILL_74: m_Magic74Skill := UserMagic; //逐日剑法 20080511
          SKILL_96: m_Magic96Skill := UserMagic; //血魄一击(战)
          SKILL_ILKWANG: begin //精神力战法
              m_MagicOneSwordSkill := UserMagic;
              if UserMagic.btLevel > 0 then begin
                m_btHitPoint := _MIN(High(Byte), m_btHitPoint + Round(8 / 3 * UserMagic.btLevel));
              end;
            end;
          SKILL_40: m_MagicCrsSkill := UserMagic; //抱月弯刀
          SKILL_41: m_Magic41Skill := UserMagic; //狮子吼
          SKILL_42: m_Magic42Skill := UserMagic; //开天斩
          SKILL_43: m_Magic43Skill := UserMagic; //龙影剑法
          SKILL_46: begin //分身术 20081217
              if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_Magic46Skill := UserMagic;
            end;
          SKILL_67: begin //先天元力 20080626
              m_Magic67Skill := UserMagic;
              m_Magic67Skill.nTranPoint := m_Abil.MaxAlcohol;
            end;
          SKILL_68: begin //酒气护体 20080625
              m_Magic68Skill := UserMagic;
              if m_Magic68Skill <> nil then begin //20080702
                if m_Magic68Skill.btLevel = 0 then m_Magic68Skill.btLevel := 1;
              end;
            end;
          SKILL_71: begin //召唤圣兽
              if m_btRaceServer = RC_PLAYOBJECT then begin
                m_Magic71Skill := UserMagic;
                if m_Magic71Skill <> nil then begin
                  if m_Magic71Skill.btLevel > 99 then m_Magic71Skill.btLevel := 99; //限制等级99级
                end;
              end;
            end;
          SKILL_104: begin //召唤火灵
              m_Magic104Skill := UserMagic;
              if m_Magic104Skill.btLevel > 100 then m_Magic104Skill.btLevel := 100;
            end;
          SKILL_60: begin //破魂斩 20100719
              if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_Magic60Skill := UserMagic;
            end;
{$IF M2Version <> 2}
          SKILL_99: begin //强身术 20100817
              if m_btRaceServer = RC_HEROOBJECT then begin
                THEROOBJECT(self).m_Magic99Skill := UserMagic;
                if THEROOBJECT(self).m_Magic99Skill.btLevel > 99 then THEROOBJECT(self).m_Magic99Skill.btLevel := 99;
              end;
            end;
          SKILL_100: begin //神秘解读
              if m_btRaceServer = RC_PLAYOBJECT then begin
                TPlayObject(self).m_Magic100Skill := UserMagic;
                if TPlayObject(self).m_Magic100Skill.btLevel > 15 then TPlayObject(self).m_Magic100Skill.btLevel := 15;
              end;
            end;
          SKILL_102: begin //唯我独尊
              if m_btRaceServer = RC_HEROOBJECT then begin
                THEROOBJECT(self).m_Magic102Skill := UserMagic;
              end;
            end;
          SKILL_103: begin //召唤巨魔
              if m_btRaceServer = RC_PLAYOBJECT then begin
                TPlayObject(self).m_Magic103Skill := UserMagic;
                TPlayObject(self).m_Magic103Skill.btLevel := 0;
              end;
            end;
          SKILL_105: begin //龙卫心法
              if m_btRaceServer = RC_PLAYOBJECT then with TPlayObject(self) do begin
                m_MagicSkill_105 := UserMagic;
                if m_MagicSkill_105.btLevel > 100 then
                  m_MagicSkill_105.btLevel := 100;
              end;
            end;
          SKILL_106: begin //传承心法
              if m_btRaceServer = RC_PLAYOBJECT then begin
                TPlayObject(self).m_MagicSkill_106 := UserMagic;
                if (TPlayObject(self).m_MyDivision <> nil) then begin
                  if TPlayObject(self).m_MagicSkill_106.btLevel > TDivision(TPlayObject(self).m_MyDivision).nHeartLevel then
                    TPlayObject(self).m_MagicSkill_106.btLevel := TDivision(TPlayObject(self).m_MyDivision).nHeartLevel;
                end;
              end;
            end;
          SKILL_107: begin //纵横剑
              if m_btRaceServer = RC_PLAYOBJECT then
                TPlayObject(self).m_MagicSkill_107 := UserMagic;
            end;
          SKILL_108: begin //冰霜雪雨
              if m_btRaceServer = RC_PLAYOBJECT then
                TPlayObject(self).m_MagicSkill_108 := UserMagic;
            end;
          SKILL_109: begin //裂神符
              if m_btRaceServer = RC_PLAYOBJECT then
                TPlayObject(self).m_MagicSkill_109 := UserMagic;
            end;
          SKILL_113: begin //天雷乱舞
              if m_btRaceServer = RC_PLAYOBJECT then
                TPlayObject(self).m_MagicSkill_113 := UserMagic;
            end;
          SKILL_200: begin //怒之攻杀
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_200 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_200 := UserMagic;
            end;
          SKILL_201: begin //静之攻杀
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_201 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_201 := UserMagic;
            end;
          Skill_202: begin //怒之半月
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_202 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_202 := UserMagic;
            end;
          Skill_203: begin //静之半月
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_203 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_203 := UserMagic;
            end;
          Skill_204: begin //怒之烈火
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_204 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_204 := UserMagic;
            end;
          Skill_205: begin //静之烈火
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_205 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_205 := UserMagic;
            end;
          Skill_206: begin //怒之逐日
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_206 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_206 := UserMagic;
            end;
          Skill_207: begin //静之逐日
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_207 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_207 := UserMagic;
            end;
          Skill_208: begin //怒之火球
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_208 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_208 := UserMagic;
            end;
          Skill_209: begin //静之火球
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_209 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_209 := UserMagic;
            end;
          Skill_210: begin //怒之大火球
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_210 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_210 := UserMagic;
            end;
          Skill_211: begin //静之大火球
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_211 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_211 := UserMagic;
            end;
          Skill_212: begin //怒之火墙
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_212 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_212 := UserMagic;
            end;
          Skill_213: begin //静之火墙
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_213 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_213 := UserMagic;
            end;
          Skill_214: begin //怒之地狱火
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_214 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_214 := UserMagic;
            end;
          Skill_215: begin //静之地狱火
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_215 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_215 := UserMagic;
            end;
          Skill_216: begin //怒之疾光电影
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_216 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_216 := UserMagic;
            end;
          Skill_217: begin //静之疾光电影
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_217 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_217 := UserMagic;
            end;
          Skill_218: begin //怒之爆裂火焰
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_218 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_218 := UserMagic;
            end;
          Skill_219: begin //静之爆裂火焰
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_219 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_219 := UserMagic;
            end;
          Skill_220: begin //怒之冰咆哮
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_220 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_220 := UserMagic;
            end;
          Skill_221: begin //静之冰咆哮
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_221 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_221 := UserMagic;
            end;
          Skill_222: begin //怒之雷电
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_222 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_222 := UserMagic;
            end;
          Skill_223: begin //静之雷电
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_223 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_223 := UserMagic;
            end;
          Skill_224: begin //怒之地狱雷光
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_224 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_224 := UserMagic;
            end;
          Skill_225: begin //静之地狱雷光
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_225 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_225 := UserMagic;
            end;
          Skill_226: begin //怒之寒冰掌
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_226 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_226 := UserMagic;
            end;
          Skill_227: begin //静之寒冰掌
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_227 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_227 := UserMagic;
            end;
          Skill_228: begin //怒之灭天火
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_228 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_228 := UserMagic;
            end;
          Skill_229: begin //静之灭天火
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_229 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_229 := UserMagic;
            end;
          Skill_230: begin //怒之火符
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_230 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_230 := UserMagic;
            end;
          Skill_231: begin //静之火符
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_231 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_231 := UserMagic;
            end;
          Skill_232: begin //怒之噬血
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_232 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_232 := UserMagic;
            end;
          Skill_233: begin //静之噬血
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_233 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_233 := UserMagic;
            end;
          Skill_234: begin //怒之流星火雨
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_234 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_234 := UserMagic;
            end;
          Skill_235: begin //静之流星火雨
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_235 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_235 := UserMagic;
            end;
          Skill_236: begin //怒之内功剑法(战+物理攻击)
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_236 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_236 := UserMagic;
            end;
          Skill_237: begin //静之内功剑法
              if m_btRaceServer = RC_PLAYOBJECT then TPlayObject(self).m_MagicSkill_237 := UserMagic
              else
                if m_btRaceServer = RC_HEROOBJECT then THEROOBJECT(self).m_MagicSkill_237 := UserMagic;
            end;
          Skill_238: begin //静之开天斩
              case m_btRaceServer of
                RC_PLAYOBJECT: TPlayObject(self).m_MagicSkill_238 := UserMagic;
                RC_HEROOBJECT: THEROOBJECT(self).m_MagicSkill_238 := UserMagic;
              end;
            end;
{$IF M2Version = 1}
          SKILL_95: begin //斗转星移
              case m_btRaceServer of
                RC_PLAYOBJECT: begin
                    TPlayObject(self).m_Magic95Skill := UserMagic;
                    if TPlayObject(self).m_boOpenupSkill95 then begin
                      if TPlayObject(self).m_Magic95Skill.btLevel > 99 then TPlayObject(self).m_Magic95Skill.btLevel := 99;
                    end else
                      if TPlayObject(self).m_Magic95Skill.btLevel > 64 then TPlayObject(self).m_Magic95Skill.btLevel := 64; //斗转星移最高
                  end;
                RC_HEROOBJECT: begin
                    THEROOBJECT(self).m_Magic95Skill := UserMagic;
                    if THEROOBJECT(self).m_boOpenupSkill95 then begin
                      if THEROOBJECT(self).m_Magic95Skill.btLevel > 99 then THEROOBJECT(self).m_Magic95Skill.btLevel := 99;
                    end else
                      if THEROOBJECT(self).m_Magic95Skill.btLevel > 64 then THEROOBJECT(self).m_Magic95Skill.btLevel := 64; //斗转星移最高
                  end;
              end;
            end;
          Skill_239: begin //怒之施毒术
              case m_btRaceServer of
                RC_PLAYOBJECT: TPlayObject(self).m_MagicSkill_239 := UserMagic;
                RC_HEROOBJECT: THEROOBJECT(self).m_MagicSkill_239 := UserMagic;
              end;
            end;
          Skill_240: begin //静之施毒术
              case m_btRaceServer of
                RC_PLAYOBJECT: TPlayObject(self).m_MagicSkill_240 := UserMagic;
                RC_HEROOBJECT: THEROOBJECT(self).m_MagicSkill_240 := UserMagic;
              end;
            end;
          Skill_241: begin //怒之月灵
              case m_btRaceServer of
                RC_PLAYOBJECT: TPlayObject(self).m_MagicSkill_241 := UserMagic;
                RC_HEROOBJECT: THEROOBJECT(self).m_MagicSkill_241 := UserMagic;
              end;
            end;
          Skill_242: begin //静之月灵
              case m_btRaceServer of
                RC_PLAYOBJECT: TPlayObject(self).m_MagicSkill_242 := UserMagic;
                RC_HEROOBJECT: THEROOBJECT(self).m_MagicSkill_242 := UserMagic;
              end;
            end;
          SKILL_76: begin //三绝杀
              case m_btRaceServer of
                RC_PLAYOBJECT: begin
                    TPlayObject(self).m_Magic76Skill := UserMagic;
                    if TPlayObject(self).m_boTrainingNG then begin //学过内功
                    //更新暴击率
                      if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                        TPlayObject(self).m_wHumanPulseArr[0].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                    end;
                  end;
                RC_HEROOBJECT: begin
                    THEROOBJECT(self).m_Magic76Skill := UserMagic;
                    if THEROOBJECT(self).m_boTrainingNG then begin //学过内功
                    //更新暴击率
                      if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                        THEROOBJECT(self).m_wHumanPulseArr[0].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                    end;
                  end;
              end;
            end;
          SKILL_77, SKILL_78: begin //双龙破 虎啸诀(更新暴击率)
              case m_btRaceServer of
                RC_PLAYOBJECT: begin
                    if TPlayObject(self).m_boTrainingNG then begin //学过内功
                      if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                        TPlayObject(self).m_wHumanPulseArr[0].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                    end;
                  end;
                RC_HEROOBJECT: begin
                    if THEROOBJECT(self).m_boTrainingNG then begin //学过内功
                      if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                        THEROOBJECT(self).m_wHumanPulseArr[0].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                    end;
                  end;
              end;
            end;
          SKILL_79: begin //追心刺
              case m_btRaceServer of
                RC_PLAYOBJECT: begin
                    TPlayObject(self).m_Magic79Skill := UserMagic;
                    if TPlayObject(self).m_boTrainingNG then begin //学过内功
                    //更新暴击率
                      if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                        TPlayObject(self).m_wHumanPulseArr[1].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                    end;
                  end;
                RC_HEROOBJECT: begin
                    THEROOBJECT(self).m_Magic79Skill := UserMagic;
                    if THEROOBJECT(self).m_boTrainingNG then begin //学过内功
                    //更新暴击率
                      if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                        THEROOBJECT(self).m_wHumanPulseArr[1].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                    end;
                  end;
              end;
            end;
          SKILL_80, SKILL_81: begin //凤舞祭 八卦掌
              case m_btRaceServer of
                RC_PLAYOBJECT: begin
                    if TPlayObject(self).m_boTrainingNG then begin //学过内功
                      if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                        TPlayObject(self).m_wHumanPulseArr[1].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                    end;
                  end;
                RC_HEROOBJECT: begin
                    if THEROOBJECT(self).m_boTrainingNG then begin //学过内功
                      if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                        THEROOBJECT(self).m_wHumanPulseArr[1].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                    end;
                  end;
              end;
            end;
          SKILL_82: begin //断岳斩
              case m_btRaceServer of
                RC_PLAYOBJECT: begin
                    TPlayObject(self).m_Magic82Skill := UserMagic;
                    if TPlayObject(self).m_boTrainingNG then begin //学过内功
                    //更新暴击率
                      if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                        TPlayObject(self).m_wHumanPulseArr[2].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                    end;
                  end;
                RC_HEROOBJECT: begin
                    THEROOBJECT(self).m_Magic82Skill := UserMagic;
                    if THEROOBJECT(self).m_boTrainingNG then begin //学过内功
                    //更新暴击率
                      if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                        THEROOBJECT(self).m_wHumanPulseArr[2].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                    end;
                  end;
              end;
            end;
          SKILL_83, SKILL_84: begin //惊雷爆 三焰咒
              case m_btRaceServer of
                RC_PLAYOBJECT: begin
                    if TPlayObject(self).m_boTrainingNG then begin //学过内功
                      if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                        TPlayObject(self).m_wHumanPulseArr[2].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                    end;
                  end;
                RC_HEROOBJECT: begin
                    if THEROOBJECT(self).m_boTrainingNG then begin //学过内功
                      if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                        THEROOBJECT(self).m_wHumanPulseArr[2].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                    end;
                  end;
              end;
            end;
          SKILL_85: begin //横扫千军
              case m_btRaceServer of
                RC_PLAYOBJECT: begin
                    TPlayObject(self).m_Magic85Skill := UserMagic;
                    if TPlayObject(self).m_boTrainingNG then begin //学过内功
                    //更新暴击率
                      if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                        TPlayObject(self).m_wHumanPulseArr[3].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                    end;
                  end;
                RC_HEROOBJECT: begin
                    THEROOBJECT(self).m_Magic85Skill := UserMagic;
                    if THEROOBJECT(self).m_boTrainingNG then begin //学过内功
                    //更新暴击率
                      if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                        THEROOBJECT(self).m_wHumanPulseArr[3].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                    end;
                  end;
              end;
            end;
          SKILL_86, SKILL_87: begin //冰天雪地 万剑归宗
              case m_btRaceServer of
                RC_PLAYOBJECT: begin
                    if TPlayObject(self).m_boTrainingNG then begin //学过内功
                      if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                        TPlayObject(self).m_wHumanPulseArr[3].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                    end;
                  end;
                RC_HEROOBJECT: begin
                    if THEROOBJECT(self).m_boTrainingNG then begin //学过内功
                      if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                        THEROOBJECT(self).m_wHumanPulseArr[3].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                    end;
                  end;
              end;
            end;
{$IFEND}
{$IFEND}
        end;
      end; //for
    end;
  except   
    MainOutMessage(Format('{%s} TBaseObject.RecalcHitSpeed Code:%d', [g_sExceptionVer, nCode]));
  end;
end;
//物品增加技能(火焰戒指,治愈戒指)

procedure TBaseObject.AddItemSkill(nIndex: Integer);
var
  Magic: pTMagic;
  UserMagic: pTUserMagic;
begin
  Magic := nil;
  try
    case nIndex of
      1: Magic := UserEngine.FindMagic(g_Config.sFireBallSkill);
      2: Magic := UserEngine.FindMagic(g_Config.sHealSkill);
      3: Magic := UserEngine.FindMagic(g_Config.sMeteorSKill);
      4: Magic := UserEngine.FindMagic(g_Config.sHeavenSKill); //倚天辟地 20091009
      5: Magic := UserEngine.FindMagic(g_Config.sDragonSkill); //神龙附体 20100924
      6: if m_btRaceServer = RC_PLAYOBJECT then Magic := UserEngine.FindMagic(g_Config.sCallTrollSkill); //召唤巨魔
    end;
    if Magic <> nil then begin
      if not IsTrainingSkill(Magic.wMagicId) then begin
        New(UserMagic);
        UserMagic.MagicInfo := Magic;
        UserMagic.wMagIdx := Magic.wMagicId;
        UserMagic.btKey := 0;
        if nIndex <> 6 then UserMagic.btLevel := 1
        else UserMagic.btLevel := 0;
        UserMagic.nTranPoint := 0;
        UserMagic.btLevelEx := 0;
        m_MagicList.Add(UserMagic);
        case m_btRaceServer of
          RC_PLAYOBJECT: TPlayObject(Self).SendAddMagic(UserMagic);
          RC_HEROOBJECT: THeroObject(Self).SendAddMagic(UserMagic);
        end;
      end;
    end;
  except   
    MainOutMessage(format('{%s} TBaseObject.AddItemSkill ID:%d', [g_sExceptionVer, nIndex]));
  end;
end;

function TBaseObject.AddToMap: Boolean;
var
  Point: Pointer;
begin
  Result := False;
  Point := m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
  if Point <> nil then Result := True
  else Result := False;
  if not m_boFixedHideMode then
    SendRefMsg(RM_TURN, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
end;

procedure TBaseObject.AttackDir(TargeTBaseObject: TBaseObject; wHitMode: Word; nDir: Integer; btLevelEx: Byte);

  function GetMagicSpell(UserMagic: pTUserMagic): Integer;
  begin
    Result := Round(UserMagic.MagicInfo.wSpell / (UserMagic.MagicInfo.btTrainLv + 1) * (UserMagic.btLevel + 1));
  end;

  procedure CheckWeaponUpgradeStatus(UserItem: pTUserItem); //武器升级设置
  begin
    if (UserItem.btValue[0] + UserItem.btValue[1] + UserItem.btValue[2]) < g_Config.nUpgradeWeaponMaxPoint then begin
      case UserItem.btValue[10] of
        1: UserItem.wIndex := 0;
        10..12: begin
            UserItem.btValue[0] := UserItem.btValue[0] + UserItem.btValue[10] - 9;
            if UserItem.btValue[0] > g_Config.nUpgradeWeaponMaxPoint then UserItem.btValue[0] := g_Config.nUpgradeWeaponMaxPoint; //20080724 限制上限
          end;
        20..22: begin
            UserItem.btValue[1] := UserItem.btValue[1] + UserItem.btValue[10] - 19;
            if UserItem.btValue[1] > g_Config.nUpgradeWeaponMaxPoint then UserItem.btValue[1] := g_Config.nUpgradeWeaponMaxPoint; //20080724 限制上限
          end;
        30..32: begin
            UserItem.btValue[2] := UserItem.btValue[2] + UserItem.btValue[10] - 29;
            if UserItem.btValue[2] > g_Config.nUpgradeWeaponMaxPoint then UserItem.btValue[2] := g_Config.nUpgradeWeaponMaxPoint; //20080724 限制上限
          end;
      end;
    end else UserItem.wIndex := 0;
    UserItem.btValue[10] := 0;
  end;
  procedure CheckWeaponUpgrade(); //检查武器升级
  var
    UseItems: TUserItem;
    PlayObject: TPlayObject;
    StdItem: pTStdItem;
  begin
    if m_UseItems[U_WEAPON].btValue[10] > 0 then begin
      UseItems := m_UseItems[U_WEAPON];
      CheckWeaponUpgradeStatus(@m_UseItems[U_WEAPON]);
      if m_UseItems[U_WEAPON].wIndex = 0 then begin
        SysMsg(g_sTheWeaponBroke, c_Red, t_Hint);
        PlayObject := TPlayObject(Self);
        PlayObject.SendDelItems(@UseItems);
        //PlayObject.StatusChanged;
        SendRefMsg(RM_BREAKWEAPON, 0, 0, 0, 0, '');
        StdItem := UserEngine.GetStdItem(UseItems.wIndex);
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog('21' + #9 +
            m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UseItems.MakeIndex) + #9 +
            '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
            '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
            '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
            '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
            '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
            IntToStr(UseItems.btValue[0]) + '/' + IntToStr(UseItems.btValue[1]) + '/' + IntToStr(UseItems.btValue[2]) + '/' +
            IntToStr(UseItems.btValue[3]) + '/' + IntToStr(UseItems.btValue[4]) + '/' + IntToStr(UseItems.btValue[5]) + '/' +
            IntToStr(UseItems.btValue[6]) + '/' + IntToStr(UseItems.btValue[7]) + '/' + IntToStr(UseItems.btValue[8]) + '/' +
            IntToStr(UseItems.btValue[14]) + #9 + '0');
        FeatureChanged();
      end else begin
        SysMsg(sTheWeaponRefineSuccessfull {武器升级成功}, c_Green {c_Red}, t_Hint); //20090114 修改升级成功的颜色
        PlayObject := TPlayObject(Self);
        PlayObject.SendUpdateItem(@m_UseItems[U_WEAPON]);
        StdItem := UserEngine.GetStdItem(UseItems.wIndex);
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog('20' + #9 + m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UseItems.MakeIndex) + #9 +
            '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
            '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
            '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
            '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
            '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
            IntToStr(UseItems.btValue[0]) + '/' + IntToStr(UseItems.btValue[1]) + '/' + IntToStr(UseItems.btValue[2]) + '/' +
            IntToStr(UseItems.btValue[3]) + '/' + IntToStr(UseItems.btValue[4]) + '/' + IntToStr(UseItems.btValue[5]) + '/' +
            IntToStr(UseItems.btValue[6]) + '/' + IntToStr(UseItems.btValue[7]) + '/' + IntToStr(UseItems.btValue[8]) + '/' +
            IntToStr(UseItems.btValue[14]) + #9 + '0');
        RecalcAbilitys();
        CompareSuitItem(False); //套装与身上装备对比 20080729
        if m_btRaceServer = RC_PLAYOBJECT then begin //20090501 修改
          SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
        end else
          if m_btRaceServer = RC_HEROOBJECT then begin //20090501 修改
            THeroObject(self).SendMsg(self, RM_HEROABILITY, 0, 0, 0, 0, '');
          end;
        SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
      end;
    end;
  end;
var
  AttackTarget: TBaseObject;
  boPowerHit, boFireHit, bo42, bo43, bo74, bo96: Boolean;
  wIdent: Word;
  nCheckCode: Integer;
  nX, nY: Integer;
resourcestring
  sExceptionMsg = '{%s} TBaseObject::AttackDir Code: %d';
begin
  nCheckCode := 0;
  try
    if (wHitMode = 5) and (m_MagicBanwolSkill <> nil) then begin //半月减蓝
      if m_WAbil.MP > 0 then begin
        nCheckCode := 1;
        DamageSpell(m_MagicBanwolSkill.MagicInfo.btDefSpell + GetMagicSpell(m_MagicBanwolSkill));
        nCheckCode := 2;
        HealthSpellChanged();
        nCheckCode := 3;
      end else wHitMode := RM_HIT;
    end;
    if (wHitMode = 16) and (m_Magic90Skill <> nil) then begin //圆月弯刀(四级半月弯刀)减蓝
      if m_WAbil.MP > 0 then begin
        nCheckCode := 1;
        DamageSpell(m_Magic90Skill.MagicInfo.btDefSpell + GetMagicSpell(m_Magic90Skill));
        nCheckCode := 2;
        HealthSpellChanged();
        nCheckCode := 3;
      end else wHitMode := RM_HIT;
    end;
    if (wHitMode = 8) and (m_MagicCrsSkill <> nil) then begin //抱月弯刀减蓝 20090115
      if m_WAbil.MP > 0 then begin
        nCheckCode := 10;
        DamageSpell(m_MagicCrsSkill.MagicInfo.btDefSpell + GetMagicSpell(m_MagicCrsSkill));
        nCheckCode := 12;
        HealthSpellChanged();
        nCheckCode := 13;
      end else wHitMode := RM_HIT;
    end;
    nCheckCode := 4;
    m_btDirection := nDir;
    if TargeTBaseObject = nil then begin
      nCheckCode := 41;
      AttackTarget := GetPoseCreate();
      if (AttackTarget = nil) and (wHitMode = 17) then begin //血魄一击(战)取两格位置的目标 20100323
        if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, 2, nX, nY) then begin
          AttackTarget := m_PEnvir.GetMovingObject(nX, nY, True);
        end;
      end;
    end else AttackTarget := TargeTBaseObject;
    if (AttackTarget <> nil) and (m_UseItems[U_WEAPON].wIndex > 0) then begin
      nCheckCode := 42;
      if m_btRaceServer = RC_PLAYOBJECT then CheckWeaponUpgrade();
    end;
    nCheckCode := 5;

    boPowerHit := m_boPowerHit; //控制攻杀剑术 20071217

    if (m_MagicPowerHitSkill <> nil) and (wHitMode = 3) and (m_btRaceServer = RC_HEROOBJECT) then boPowerHit := True; //20071218

    boFireHit := m_boFireHitSkill;
    bo42 := m_bo42kill;
    bo43 := m_bo43kill;
    bo74 := m_boDailySkill;
    bo96 := m_boBloodSoulSkill;
{$IF M2Version <> 2}
    case m_btRaceServer of //20090904 修改
      RC_PLAYOBJECT: begin
          if TPlayObject(self).m_boTrainingNG then begin //20081003 学过内功心法,每攻击一次减一点内力值
            TPlayObject(self).m_Skill69NH := _MAX(0, TPlayObject(self).m_Skill69NH - g_Config.nHitStruckDecNH);
            TPlayObject(self).SendRefMsg(RM_MAGIC69SKILLNH, 0, TPlayObject(self).m_Skill69NH, TPlayObject(self).m_Skill69MaxNH, 0, '');
          end;
        end;
      RC_HEROOBJECT: begin
          if THeroObject(self).m_boTrainingNG then begin //20081003 英雄学过内功心法,每攻击一次减一点内力值
            THeroObject(self).m_Skill69NH := _MAX(0, THeroObject(self).m_Skill69NH - g_Config.nHitStruckDecNH);
            THeroObject(self).SendRefMsg(RM_MAGIC69SKILLNH, 0, THeroObject(self).m_Skill69NH, THeroObject(self).m_Skill69MaxNH, 0, '');
          end;
        end;
    end;
{$IFEND}
    if _Attack(wHitMode, AttackTarget) then begin //处理目标掉血以级技能升级点数
      if m_btRaceServer = RC_HEROOBJECT then begin //修正英雄锁定后,不打锁定怪
        nCheckCode := 6;
        if not THeroObject(self).m_boTarget then SetTargetCreat(AttackTarget);
      end else SetTargetCreat(AttackTarget);
      nCheckCode := 7;
    end;
    wIdent := RM_HIT;
    if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or
      (m_btRaceServer = RC_HEROOBJECT) then begin {增加分身魔法攻击}
      case wHitMode of
        0: wIdent := RM_HIT;
        1: wIdent := RM_HEAVYHIT;
        2: wIdent := RM_BIGHIT;
        3: if boPowerHit then wIdent := RM_SPELL2;
        4: if m_MagicErgumSkill <> nil then wIdent := RM_LONGHIT; //刺杀
        5: if m_MagicBanwolSkill <> nil then wIdent := RM_WIDEHIT; //半月
        7: if boFireHit and (m_MagicFireSwordSkill <> nil) then begin
            case m_btRaceServer of //20100221 修改
              RC_PLAYOBJECT: begin
                  if (m_MagicFireSwordSkill.btLevel = 4) then begin //四级烈火
                    wIdent := RM_4FIREHIT; //发送4级烈火剑术消息
                  end else wIdent := RM_FIREHIT; //发送烈火剑法消息
                end;
              RC_HEROOBJECT: begin
                  if (m_MagicFireSwordSkill.btLevel = 4) and (THeroObject(self).m_nLoyal >= g_Config.nGotoLV4) then begin //四级烈火
                    wIdent := RM_4FIREHIT; //发送4级烈火剑术消息
                  end else wIdent := RM_FIREHIT; //发送烈火剑法消息
                end;
              RC_PLAYMOSTER: wIdent := RM_FIREHIT;
            end;
          end;
        8: if m_MagicCrsSkill <> nil then wIdent := RM_CRSHIT;
        9: if bo42 and (m_Magic42Skill <> nil) then wIdent := RM_41; {开天斩}
        12: if bo43 and (m_Magic43Skill <> nil) then wIdent := RM_44; //龙影剑法 20080619 修改
        13: if bo74 and (m_Magic74Skill <> nil) then wIdent := RM_DAILY; //逐日剑法 20080511
        15: if m_Magic89Skill <> nil then wIdent := RM_LONGHIT4; //四级刺杀
        16: if m_Magic90Skill <> nil then wIdent := RM_WIDEHIT4; //圆月弯刀
        17: if bo96 and (m_Magic96Skill <> nil) then wIdent := RM_BLOODSOUL; //血魄一击(战)
        18: begin
{$IF M2Version <> 2}
            if (m_btRaceServer = RC_PLAYOBJECT) then begin
              if (TPlayObject(self).m_boHeartActive) and (TPlayObject(self).m_MagicSkill_107 <> nil) then wIdent := RM_HIT_107;
            end;
{$IFEND} //纵横剑术
          end;
      end;
    end;
    nCheckCode := 8;
    SendAttackMsg(wIdent, m_btDirection, btLevelEx {强化等级}, m_nCurrX, m_nCurrY);
  except
    on E: Exception do begin
      MainOutMessage(Format(sExceptionMsg, [g_sExceptionVer, nCheckCode]));
    end;
  end;
end;
//检查PK状态

procedure TBaseObject.CheckPKStatus;
begin
  if m_boPKFlag and ((GetTickCount - m_dwPKTick) > g_Config.dwPKFlagTime {60 * 1000}) then begin
    m_boPKFlag := False;
    RefNameColor();
  end;
end;
//魔法损害蓝值

procedure TBaseObject.DamageSpell(nSpellPoint: Integer);
begin
  if nSpellPoint > 0 then begin
    if (m_WAbil.MP - nSpellPoint) > 0 then
      Dec(m_WAbil.MP, nSpellPoint)
    else m_WAbil.MP := 0;
  end else begin
    if (m_WAbil.MP - nSpellPoint) < m_WAbil.MaxMP then
      Dec(m_WAbil.MP, nSpellPoint)
    else m_WAbil.MP := m_WAbil.MaxMP;
  end;
end;
//减PK值

procedure TBaseObject.DecPKPoint(nPoint: Integer);
var
  nC: Integer;
begin
  nC := PKLevel();
  Dec(m_nPkPoint, nPoint);
  if m_nPkPoint < 0 then m_nPkPoint := 0;
  if (PKLevel <> nC) and (nC > 0) and (nC <= 2) then begin
    RefNameColor();
  end;
end;

procedure TBaseObject.DelItemSkill(nIndex: Integer);
  procedure DELETESKILL(sSkillName: string);
  var
    I: Integer;
    UserMagic: pTUserMagic;
  begin
    for I := m_MagicList.Count - 1 downto 0 do begin //20080916 修改
      if m_MagicList.Count <= 0 then Break; //20080916
      UserMagic := m_MagicList.Items[I];
      if UserMagic <> nil then begin //20090129
        if UserMagic.MagicInfo.sMagicName = sSkillName then begin
          case m_btRaceServer of //20090910 修改
            RC_PLAYOBJECT: begin
                TPlayObject(Self).SendDelMagic(UserMagic);
                m_MagicList.Delete(I);
                //防止释放内存后的非法访问 By TasNat at: 2012-03-11 
                //m_MagicOfDelList.Add(UserMagic);
                Dispose(UserMagic);
                Break;
              end;
            RC_HEROOBJECT: begin
                THeroObject(Self).SendDelMagic(UserMagic);
                m_MagicList.Delete(I);
                //防止释放内存后的非法访问 By TasNat at: 2012-03-11 
                //m_MagicOfDelList.Add(UserMagic);
                Dispose(UserMagic);
                Break;
              end;
          end; //case
        end;
      end;
    end;
  end;
  procedure DELETESKILL1(nSkill: Integer);
  var
    I: Integer;
    UserMagic: pTUserMagic;
  begin
    for I := m_MagicList.Count - 1 downto 0 do begin
      if m_MagicList.Count <= 0 then Break;
      UserMagic := m_MagicList.Items[I];
      if UserMagic <> nil then begin
        if UserMagic.wMagIdx = nSkill then begin
          case m_btRaceServer of
            RC_PLAYOBJECT: begin
                TPlayObject(Self).SendDelMagic(UserMagic);
                m_MagicList.Delete(I);
                //防止释放内存后的非法访问 By TasNat at: 2012-03-11 
                //m_MagicOfDelList.Add(UserMagic);
                Dispose(UserMagic);
                Break;
              end;
            RC_HEROOBJECT: begin
                THeroObject(Self).SendDelMagic(UserMagic);
                m_MagicList.Delete(I);
                //防止释放内存后的非法访问 By TasNat at: 2012-03-11 
                //m_MagicOfDelList.Add(UserMagic);
                Dispose(UserMagic);
                Break;
              end;
          end; //case
        end;
      end;
    end;
  end;
begin
  if (m_btRaceServer <> RC_PLAYOBJECT) and (m_btRaceServer <> RC_HEROOBJECT) then Exit; //20090910 增加英雄
  case nIndex of
    1: if m_btJob <> 1 then DELETESKILL(g_Config.sFireBallSkill);
    2: if m_btJob <> 2 then DELETESKILL(g_Config.sHealSkill);
    3: {if m_btJob <> 1 then } DELETESKILL(g_Config.sMeteorSKill); //20091124 修改
    4: DELETESKILL(g_Config.sHeavenSKill); //倚天辟地
{$IF M2Version <> 2}
    5: begin
        DELETESKILL(g_Config.sDragonSkill); //神龙附体 20100924
        case m_btRaceServer of
          RC_PLAYOBJECT: TPLAYOBJECT(self).m_boCanUerSkill101 := False;
          RC_HEROOBJECT: THEROOBJECT(self).m_boCanUerSkill101 := False;
        end;
      end;
    7: DELETESKILL1(SKILL_106); //传承心法
{$IFEND}
    6: if m_btRaceServer = RC_PLAYOBJECT then DELETESKILL(g_Config.sCallTrollSkill); //召唤巨魔
  end;
end;
//删除组队成员

procedure TPlayObject.DelMember(PlayObject: TPlayObject);
var
  I: Integer;
  BaseObject: TPlayObject;
  boUpGroupOwner: Boolean;
begin
{  if m_GroupOwner <> PlayObject then begin
    for I := m_GroupMembers.Count - 1 downto 0 do begin
      if m_GroupMembers.Count <= 0 then Break;
      if (m_GroupMembers.Objects[I] <> nil) then begin//20090116 修改
        if (m_GroupMembers.Objects[I] = PlayObject) then begin
          PlayObject.LeaveGroup();
          m_GroupMembers.Delete(I);
          Break;
        end;
      end;
    end;//for
  end else begin//队长退出则解散组队
    for I := m_GroupMembers.Count - 1 downto 0 do begin
      if m_GroupMembers.Count <= 0 then Break;
      if TPlayObject(m_GroupMembers.Objects[I]) <> nil then begin
        TPlayObject(m_GroupMembers.Objects[I]).LeaveGroup;
        m_GroupMembers.Delete(I);
      end;
    end;
  end;
  if not CancelGroup then begin//判断人数,如果只有一人则解散组队
    SendDefMessage(SM_GROUPCANCEL, 0, 0, 0, 0, '');
  end else SendGroupMembers(); }

  if m_GroupOwner <> PlayObject then begin
    I := m_GroupMembers.IndexOf(PlayObject.m_sCharName);
    if I > -1 then begin
      PlayObject.LeaveGroup();
      m_GroupMembers.Delete(I);
    end;
    if not CancelGroup then begin //判断人数,如果只有一人则解散组队
      SendDefMessage(SM_GROUPCANCEL, 0, 0, 0, 0, '');
    end else SendGroupMembers();
  end else begin //队长退出则解散组队
    boUpGroupOwner := False;
    if m_GroupMembers.Count > 2 then begin
      I := m_GroupMembers.IndexOf(PlayObject.m_sCharName);
      if I > -1 then begin
        PlayObject.LeaveGroup();
        m_GroupMembers.Delete(I);

        for I := 0 to m_GroupMembers.Count - 1 do begin
          if m_GroupMembers.Count <= 0 then Break;
          BaseObject := nil;
          BaseObject := TPlayObject(m_GroupMembers.Objects[I]);
          if (BaseObject <> nil) then begin
            if (BaseObject.m_GroupOwner <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
              Break;
            end;
          end;
        end;

        if BaseObject <> nil then begin
          BaseObject.m_GroupMembers.Clear;
          BaseObject.m_GroupOwner := BaseObject;
          BaseObject.m_GroupMembers.AddObject(BaseObject.m_sCharName, BaseObject);
          for I := m_GroupMembers.Count - 1 downto 0 do begin
            if m_GroupMembers.Count <= 0 then Break;
            if (m_GroupMembers.Objects[I] <> nil) then begin
              if TPlayObject(m_GroupMembers.Objects[I]) <> BaseObject then begin
                TPlayObject(m_GroupMembers.Objects[I]).m_GroupOwner := BaseObject;
                BaseObject.m_GroupMembers.AddObject(TPlayObject(m_GroupMembers.Objects[I]).m_sCharName, m_GroupMembers.Objects[I]);
              end;
            end;
          end; //for
          if not BaseObject.CancelGroup then begin //判断人数,如果只有一人则解散组队
            boUpGroupOwner := False;
          end else begin
            boUpGroupOwner := True;
            m_GroupMembers.Clear;
            BaseObject.SendGroupMembers();
            BaseObject.SendGroupText(Format('%s 提升为小队队长!', [BaseObject.m_sCharName]));
          end;
        end;
      end;
    end;
    if not boUpGroupOwner then begin //未更换队长,则清掉成员
      for I := m_GroupMembers.Count - 1 downto 0 do begin
        if m_GroupMembers.Count <= 0 then Break;
        if TPlayObject(m_GroupMembers.Objects[I]) <> nil then begin
          TPlayObject(m_GroupMembers.Objects[I]).LeaveGroup;
          m_GroupMembers.Delete(I);
        end;
      end;
      if not CancelGroup then begin //判断人数,如果只有一人则解散组队
        SendDefMessage(SM_GROUPCANCEL, 0, 0, 0, 0, '');
      end else SendGroupMembers();
    end;
  end;
end;

procedure TBaseObject.DoDamageWeapon(nWeaponDamage: Integer);
var
  nDura, nDuraPoint: Integer;
  PlayObject: TPlayObject;
  StdItem: pTStdItem;
begin
  if m_UseItems[U_WEAPON].wIndex <= 0 then Exit;
  if (m_UseItems[U_WEAPON].Dura > 0) or g_Config.boItmeAutoOver then begin
    nDura := m_UseItems[U_WEAPON].Dura;
    nDuraPoint := Round(nDura / 1.03);
    Dec(nDura, nWeaponDamage);
    if nDura <= 0 then begin
      nDura := 0;
      m_UseItems[U_WEAPON].Dura := nDura;
      if g_Config.boItmeAutoOver then begin //20110117 持久0物品不消失
        if m_btRaceServer = RC_PLAYOBJECT then begin
          PlayObject := TPlayObject(Self);
          PlayObject.SendDelItems(@m_UseItems[U_WEAPON]);
          StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('3' + #9 + m_sMapName + #9 +
              IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 + StdItem.Name + #9 +
              IntToStr(m_UseItems[U_WEAPON].MakeIndex) + #9 +
              '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
              '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
              '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
              '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
              '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
              IntToStr(m_UseItems[U_WEAPON].btValue[0]) + '/' + IntToStr(m_UseItems[U_WEAPON].btValue[1]) + '/' + IntToStr(m_UseItems[U_WEAPON].btValue[2]) + '/' +
              IntToStr(m_UseItems[U_WEAPON].btValue[3]) + '/' + IntToStr(m_UseItems[U_WEAPON].btValue[4]) + '/' + IntToStr(m_UseItems[U_WEAPON].btValue[5]) + '/' +
              IntToStr(m_UseItems[U_WEAPON].btValue[6]) + '/' + IntToStr(m_UseItems[U_WEAPON].btValue[7]) + '/' + IntToStr(m_UseItems[U_WEAPON].btValue[8]) + '/' +
              IntToStr(m_UseItems[U_WEAPON].btValue[14]) + #9 + BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT));
        end;
        m_UseItems[U_WEAPON].wIndex := 0;
      end;
      SendMsg(Self, RM_DURACHANGE, U_WEAPON, nDura, m_UseItems[U_WEAPON].DuraMax, 0, '');
    end else begin
      m_UseItems[U_WEAPON].Dura := nDura;
    end;
    if (nDura / 1.03) <> nDuraPoint then begin
      SendMsg(Self, RM_DURACHANGE, U_WEAPON, m_UseItems[U_WEAPON].Dura, m_UseItems[U_WEAPON].DuraMax, 0, '');
    end;
  end;
end;

function TBaseObject.GetMaster(): TBaseObject;
var
  MasterObject: TBaseObject;
begin
  if m_btRaceServer <> RC_PLAYOBJECT then begin
    MasterObject := m_Master;
    if MasterObject <> nil then begin
      while True do begin
        if MasterObject.m_Master <> nil then begin
          MasterObject := MasterObject.m_Master;
        end else Break;
      end;
    end;
    Result := MasterObject;
  end else Result := nil;
end;

//取装备物品属性 20080325 20101025 修改

procedure TBaseObject.GetAccessory(Item: TUserItem; StdItem: pTStdItem; var AddAbility: TAddAbility);
var
  StdItemA: TStdItem;
begin
  StdItemA := StdItem^;
  ItemUnit.GetItemAddValue(@Item, StdItemA);
  case StdItem.StdMode of
    5, 6: begin //武器
        Inc(AddAbility.wHitPoint, HiWord(StdItemA.AC));
        if HiWord(StdItemA.MAC) > 10 then begin
          Inc(AddAbility.nHitSpeed, HiWord(StdItemA.MAC) - 10);
        end else begin
          Dec(AddAbility.nHitSpeed, HiWord(StdItemA.MAC));
        end;
        Inc(AddAbility.btLuck, LoWord(StdItemA.AC));
        Inc(AddAbility.btUnLuck, LoWord(StdItemA.MAC));
      end;
    7: begin
      if StdItem.Shape = 5 then begin //主宰印 By TasNat at: 2012-04-22 12:46:37
        AddAbility.wUnParalysisRate := _MIN(High(Byte), AddAbility.wUnParalysisRate + LoWord(StdItemA.AC));//麻痹抗性
        AddAbility.wSpeedPoint := _Min(High(Byte), AddAbility.wSpeedPoint + HiWord(StdItemA.AC)); //敏捷
        AddAbility.wVampirePoint := _MIN(High(Byte), AddAbility.wHitPoint + HiWord(StdItemA.MAC)); //准确
        AddAbility.wVampireRate := _MIN(High(Byte), AddAbility.wIncDragon + LoWord(StdItemA.MAC)); //合击威力点数
      end;
      //Inc(AddAbility.wSpellRecover, HiWord(StdItemA.MAC));
      //AddAbility.nHitSpeed := _MIN(High(Byte), AddAbility.nHitSpeed + LoWord(StdItemA.MAC));
    end;
    16: begin //斗笠
        if StdItemA.Source > 0 then AddAbility.btBurstRate := _MIN(High(Byte), AddAbility.btBurstRate + LoWord(StdItemA.Source)); //爆率 20091129
        AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItemA.AC), HiWord(AddAbility.wAC) + HiWord(StdItemA.AC));
        AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItemA.MAC), HiWord(AddAbility.wMAC) + HiWord(StdItemA.MAC));
      end;
    19: begin //项链+幸运
        if StdItemA.Source > 0 then AddAbility.btBurstRate := _MIN(High(Byte), AddAbility.btBurstRate + LoWord(StdItemA.Source)); //爆率 20091129
        Inc(AddAbility.wAntiMagic, HiWord(StdItemA.AC));
        Inc(AddAbility.btUnLuck, LoWord(StdItemA.MAC));
        Inc(AddAbility.btLuck, HiWord(StdItemA.MAC));
      end;
    20, 24, 27: begin //20100513  准确敏捷型戒指
        Inc(AddAbility.wHitPoint, HiWord(StdItemA.AC));
        Inc(AddAbility.wSpeedPoint, HiWord(StdItemA.MAC));
      end;
    21: begin //项链(体力魔法恢复型)
        Inc(AddAbility.wHealthRecover, HiWord(StdItemA.AC));
        Inc(AddAbility.wSpellRecover, HiWord(StdItemA.MAC));
        Inc(AddAbility.nHitSpeed, LoWord(StdItemA.AC));
        Dec(AddAbility.nHitSpeed, LoWord(StdItemA.MAC));
      end;
    23: begin //戒指
        Inc(AddAbility.wAntiPoison, HiWord(StdItemA.AC));
        Inc(AddAbility.wPoisonRecover, HiWord(StdItemA.MAC));
        Inc(AddAbility.nHitSpeed, LoWord(StdItemA.AC));
        Dec(AddAbility.nHitSpeed, LoWord(StdItemA.MAC));
      end;
    28: begin //项链(准确幸运型) 20100513
        Inc(AddAbility.wHitPoint, HiWord(StdItemA.AC)); //准确
        Inc(AddAbility.btUnLuck, LoWord(StdItemA.MAC));
        Inc(AddAbility.btLuck, HiWord(StdItemA.MAC));
      end;
    29: begin //20100628 增加29分类(敏捷幸运型项链)
        Inc(AddAbility.wSpeedPoint, HiWord(StdItemA.AC)); //敏捷
        Inc(AddAbility.btUnLuck, LoWord(StdItemA.MAC));
        Inc(AddAbility.btLuck, HiWord(StdItemA.MAC)); //幸运
      end;
    52: begin //靴子(特殊型)
        if not g_Config.boAddUserItemNewValue then begin
          Inc(AddAbility.wHitPoint, HiWord(StdItemA.AC));
          Inc(AddAbility.wSpeedPoint, HiWord(StdItemA.MAC));
        end else begin
          AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItemA.AC), HiWord(AddAbility.wAC) + HiWord(StdItemA.AC));
          AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItemA.MAC), HiWord(AddAbility.wMAC) + HiWord(StdItemA.MAC));
          AddAbility.wWearWeight := MakeLong(LoWord(AddAbility.wWearWeight) + LoWord(StdItemA.AniCount), HiWord(AddAbility.wWearWeight) + HiWord(StdItemA.AniCount)); //20080325 加负重
        end;
      end;
    53: begin //宝石(特殊)
        if not g_Config.boAddUserItemNewValue then begin //物品增加新属性
          Inc(AddAbility.wAntiMagic, HiWord(StdItemA.AC));
          Inc(AddAbility.btUnLuck, LoWord(StdItemA.MAC));
          Inc(AddAbility.btLuck, HiWord(StdItemA.MAC));
        end else begin
          AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItemA.AC), HiWord(AddAbility.wAC) + HiWord(StdItemA.AC));
          AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItemA.MAC), HiWord(AddAbility.wMAC) + HiWord(StdItemA.MAC));
        end;
      end;
    54: begin //腰带(特殊型)
        if not g_Config.boAddUserItemNewValue then begin
          Inc(AddAbility.wHealthRecover, HiWord(StdItemA.AC));
          Inc(AddAbility.wSpellRecover, HiWord(StdItemA.MAC));
          Inc(AddAbility.nHitSpeed, LoWord(StdItemA.AC));
          Dec(AddAbility.nHitSpeed, LoWord(StdItemA.MAC));
        end else begin
          AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItemA.AC), HiWord(AddAbility.wAC) + HiWord(StdItemA.AC));
          AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItemA.MAC), HiWord(AddAbility.wMAC) + HiWord(StdItemA.MAC));
          AddAbility.wWearWeight := MakeLong(LoWord(AddAbility.wWearWeight) + LoWord(StdItemA.AniCount), HiWord(AddAbility.wWearWeight) + HiWord(StdItemA.AniCount)); //20080325 加负重
        end;
      end;
    55: begin //军鼓之的
        AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItemA.AC), HiWord(AddAbility.wAC) + HiWord(StdItemA.AC));
        AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItemA.MAC), HiWord(AddAbility.wMAC) + HiWord(StdItemA.MAC));
        AddAbility.wWearWeight := MakeLong(LoWord(AddAbility.wWearWeight) + LoWord(StdItemA.AniCount), HiWord(AddAbility.wWearWeight) + HiWord(StdItemA.AniCount)); //20080325 加负重
      end;
  else begin
      AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItemA.AC), HiWord(AddAbility.wAC) + HiWord(StdItemA.AC));
      AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItemA.MAC), HiWord(AddAbility.wMAC) + HiWord(StdItemA.MAC));
    end;
  end;

  case StdItem.Need of //18需等级，19需攻击力，20需魔法，21需道术   金牛套装，可提高内力恢复速度% 20090712
    18..21: AddAbility.wIncNHRecover := _MIN(100, AddAbility.wIncNHRecover + StdItemA.Stock); //内力恢复速度%(金牛装备)
    22..25: AddAbility.wIncNHPoint := _MIN(High(Word), AddAbility.wIncNHPoint + StdItemA.Stock); //内力恢复点数
    26..29: AddAbility.wUnBurstRate := _MIN(High(Byte), AddAbility.wUnBurstRate + StdItemA.Stock); //防爆点数(天龙装备)
    30..33: begin
        AddAbility.wVampirePoint := _MIN(High(Byte), AddAbility.wVampirePoint + StdItemA.Stock); //吸血点数(虎威装备)
        AddAbility.wVampireRate := _MIN(High(Byte), AddAbility.wVampireRate + StdItemA.Reserved); //吸血机率(虎威装备)
      end;
    34..37: begin //必杀首饰
        if (StdItemA.Source > 0) and (StdItem.StdMode <> 16) and (StdItem.StdMode <> 19) then
          AddAbility.btBurstRate := _MIN(High(Byte), AddAbility.btBurstRate + LoWord(StdItemA.Source)); //目标爆率
        AddAbility.wDecTargetNHPoint := _MIN(High(Byte), AddAbility.wDecTargetNHPoint + StdItemA.Stock); //目标内力值减少点数(内伤装备) 20100513
      end;
    //45..48:if (StdItem.StdMode <> 7) or (StdItem.Shape <> 5) then //主宰印前面处理了不再处理 By TasNat at: 2012-04-22 13:25:06
    //AddAbility.wUnParalysisRate := _MIN(High(Byte), AddAbility.wUnParalysisRate + StdItemA.Stock); //防麻机率(辉煌衣服) 20100513
    65..68: AddAbility.btBurstRate := _MIN(High(Byte), AddAbility.btBurstRate + StdItemA.Stock); //目标爆率
    71..74: AddAbility.wParalysisAddRate := _MIN(High(Byte), AddAbility.wParalysisAddRate + StdItemA.Stock); //防麻机率(辉煌衣服) 20
    91..94: AddAbility.nHitSpeed := _MIN(High(Byte), AddAbility.nHitSpeed + StdItemA.Stock); //攻击速度(主宰印) By TasNat at: 2012-03-06 19:37:40
  end;

  AddAbility.wDC := MakeLong(LoWord(AddAbility.wDC) + LoWord(StdItemA.DC), HiWord(AddAbility.wDC) + HiWord(StdItemA.DC));
  AddAbility.wMC := MakeLong(LoWord(AddAbility.wMC) + LoWord(StdItemA.MC), HiWord(AddAbility.wMC) + HiWord(StdItemA.MC));
  AddAbility.wSC := MakeLong(LoWord(AddAbility.wSC) + LoWord(StdItemA.SC), HiWord(AddAbility.wSC) + HiWord(StdItemA.SC));
  if (StdItem.StdMode in [5,6]) then
    AddAbility.wParalysisAddRate := _MIN(High(Byte), AddAbility.wParalysisAddRate + StdItemA.nHP) //麻痹强化
  else
  AddAbility.wHP := AddAbility.wHP + StdItemA.nHP;
  AddAbility.wMP := AddAbility.wMP + StdItemA.nMP;
end;

{$IF M2Version <> 2}
//取鉴定的属性 20100825

procedure TBaseObject.GetAddUnKnowAbility(Item: TUserItem; var AddUnKnowAbility: TAddUnKnowAbility);
var
  I: Integer;
begin
  if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then begin //人物和英雄才执行 20101023增加人形

      if (Item.btUnKnowValueCount > 0) and (Item.btUnKnowValueCount < 5) then begin //有神性属性
        for I := Low(Item.btUnKnowValue) to High(Item.btUnKnowValue) do begin
          if (Item.btUnKnowValue[I] = 0) or (Item.btUnKnowValue[I] = 255) then Continue; //值为0或神性属性未解读(255) 则跳过
          case Item.btUnKnowValue[I] of
            1: AddUnKnowAbility.boRebirth := True; //重生技能
            2: AddUnKnowAbility.boMagicShield := True; //八卦护身技能
            3: AddUnKnowAbility.boParalysis := True; //麻痹技能
            4: AddUnKnowAbility.boParalysis2 := True; //魔道麻痹技能
            5: AddUnKnowAbility.boParalysis1 := True; //战意麻痹技能
            6: AddUnKnowAbility.boProbeNecklace := True; //探测技能
            7: AddUnKnowAbility.boTeleport := True; //传送技能
            8..10: ; //预留技能
            11..20: AddUnKnowAbility.wDC := _MIN(High(Word), AddUnKnowAbility.wDC + (Item.btUnKnowValue[I] - 10)); //攻击上限
            21..30: AddUnKnowAbility.wMC := _MIN(High(Word), AddUnKnowAbility.wMC + (Item.btUnKnowValue[I] - 20)); //魔法上限
            31..40: AddUnKnowAbility.wSC := _MIN(High(Word), AddUnKnowAbility.wSC + (Item.btUnKnowValue[I] - 30)); //道术上限
            41..50: AddUnKnowAbility.wMAC := _MIN(High(Word), AddUnKnowAbility.wMAC + (Item.btUnKnowValue[I] - 40)); //魔防上限(魔法防御上限)
            51..60: AddUnKnowAbility.wAC := _MIN(High(Word), AddUnKnowAbility.wAC + (Item.btUnKnowValue[I] - 50)); //物防上限(物理防御上限)
            61..70: AddUnKnowAbility.wMain := _MIN(High(Word), AddUnKnowAbility.wMain + (Item.btUnKnowValue[I] - 60)); //主属性
            71..80: AddUnKnowAbility.wIncNHPoint := _MIN(High(Word), AddUnKnowAbility.wIncNHPoint + (Item.btUnKnowValue[I] - 70)); //内力恢复(同灵虚，金牛)
            81..90: AddUnKnowAbility.wMagicShieldLevel := _MIN(High(Word), AddUnKnowAbility.wMagicShieldLevel + (Item.btUnKnowValue[I] - 80)); //聚魔等级(加蓝，职业不同加的魔法上限应该是不同)
            91..100: AddUnKnowAbility.wPhysicalLevel := _MIN(High(Word), AddUnKnowAbility.wPhysicalLevel + (Item.btUnKnowValue[I] - 90)); //强身等级(加血，职业不同加的血量不同 战+50 法+20 道+35)
            101..110: AddUnKnowAbility.wVampirePoint := _MIN(High(Byte), AddUnKnowAbility.wVampirePoint + (Item.btUnKnowValue[I] - 100)); //吸血上限(与虎威装备属性同)
            111..120: AddUnKnowAbility.wDecTargetNHLevel := _MIN(High(Byte), AddUnKnowAbility.wDecTargetNHLevel + (Item.btUnKnowValue[I] - 110)); //内伤等级
            121..130: AddUnKnowAbility.wCritLevel := _MIN(High(Byte), AddUnKnowAbility.wCritLevel + (Item.btUnKnowValue[I] - 120)); //暴击等级(可与赤炎石的暴击叠加)
            131..140: AddUnKnowAbility.wUnBurstRate := _MIN(High(Byte), AddUnKnowAbility.wUnBurstRate + (Item.btUnKnowValue[I] - 130)); //防爆
            141..150: AddUnKnowAbility.wHitPoint := _MIN(High(Byte), AddUnKnowAbility.wHitPoint + (Item.btUnKnowValue[I] - 140)); //准确
            151..160: AddUnKnowAbility.wSpeedPoint := _MIN(High(Byte), AddUnKnowAbility.wSpeedPoint + (Item.btUnKnowValue[I] - 150)); //敏捷
            161..180: AddUnKnowAbility.wUnParalysisRate := _MIN(High(Byte), AddUnKnowAbility.wUnParalysisRate + (Item.btUnKnowValue[I] - 160)); //麻痹抗性(1..20)
            181..230: AddUnKnowAbility.wIncDragonRate := _MIN(High(Word), AddUnKnowAbility.wIncDragonRate + (Item.btUnKnowValue[I] - 180)); //合击威力(1..50) (同金牛的合击伤害)
            231..250: ; //宝物灵媒 品质(11.4 * 值 上限228) 当前灵气值用btValue[11]保存，武器用btValue[12]
          end;
        end;
      end;
      //修复新鉴定属性不计算 By TasNat at: 2012-06-26 14:40:24
      if (Item.btAppraisalLevel > 1 {in [2..4, 12..14, 22..24, 32..34, 42..44, 52..54]}) then begin//鉴定过的,
        for I := 2 to 5 do begin
          if (Item.btAppraisalValue[I] = 0) then Continue; //值为0则跳过
          case Item.btAppraisalValue[I] of
            1: AddUnKnowAbility.boRebirth := True; //重生技能
            2: AddUnKnowAbility.boMagicShield := True; //八卦护身技能
            3: AddUnKnowAbility.boParalysis := True; //麻痹技能
            4: AddUnKnowAbility.boParalysis2 := True; //魔道麻痹技能
            5: AddUnKnowAbility.boParalysis1 := True; //战意麻痹技能
            6: AddUnKnowAbility.boProbeNecklace := True; //探测技能
            7: AddUnKnowAbility.boTeleport := True; //传送技能
            8..10: ; //预留技能
            11..20: AddUnKnowAbility.wDC := _MIN(High(Word), AddUnKnowAbility.wDC + (Item.btAppraisalValue[I] - 10)); //攻击上限
            21..30: AddUnKnowAbility.wMC := _MIN(High(Word), AddUnKnowAbility.wMC + (Item.btAppraisalValue[I] - 20)); //魔法上限
            31..40: AddUnKnowAbility.wSC := _MIN(High(Word), AddUnKnowAbility.wSC + (Item.btAppraisalValue[I] - 30)); //道术上限
            41..50: AddUnKnowAbility.wMAC := _MIN(High(Word), AddUnKnowAbility.wMAC + (Item.btAppraisalValue[I] - 40)); //魔防上限(魔法防御上限)
            51..60: AddUnKnowAbility.wAC := _MIN(High(Word), AddUnKnowAbility.wAC + (Item.btAppraisalValue[I] - 50)); //物防上限(物理防御上限)
            61..70: AddUnKnowAbility.wMain := _MIN(High(Word), AddUnKnowAbility.wMain + (Item.btAppraisalValue[I] - 60)); //主属性
            71..80: AddUnKnowAbility.wIncNHPoint := _MIN(High(Word), AddUnKnowAbility.wIncNHPoint + (Item.btAppraisalValue[I] - 70)); //内力恢复(同灵虚，金牛)
            81..90: AddUnKnowAbility.wMagicShieldLevel := _MIN(High(Word), AddUnKnowAbility.wMagicShieldLevel + (Item.btAppraisalValue[I] - 80)); //聚魔等级(加蓝，职业不同加的魔法上限应该是不同)
            91..100: AddUnKnowAbility.wPhysicalLevel := _MIN(High(Word), AddUnKnowAbility.wPhysicalLevel + (Item.btAppraisalValue[I] - 90)); //强身等级(加血，职业不同加的血量不同 战+50 法+20 道+35)
            101..110: AddUnKnowAbility.wVampirePoint := _MIN(High(Byte), AddUnKnowAbility.wVampirePoint + (Item.btAppraisalValue[I] - 100)); //吸血上限(与虎威装备属性同)
            111..120: AddUnKnowAbility.wDecTargetNHLevel := _MIN(High(Byte), AddUnKnowAbility.wDecTargetNHLevel + (Item.btAppraisalValue[I] - 110)); //内伤等级
            121..130: AddUnKnowAbility.wCritLevel := _MIN(High(Byte), AddUnKnowAbility.wCritLevel + (Item.btAppraisalValue[I] - 120)); //暴击等级(可与赤炎石的暴击叠加)
            131..140: AddUnKnowAbility.wUnBurstRate := _MIN(High(Byte), AddUnKnowAbility.wUnBurstRate + (Item.btAppraisalValue[I] - 130)); //防爆
            141..150: AddUnKnowAbility.wHitPoint := _MIN(High(Byte), AddUnKnowAbility.wHitPoint + (Item.btAppraisalValue[I] - 140)); //准确
            151..160: AddUnKnowAbility.wSpeedPoint := _MIN(High(Byte), AddUnKnowAbility.wSpeedPoint + (Item.btAppraisalValue[I] - 150)); //敏捷
            161..180: AddUnKnowAbility.wUnParalysisRate := _MIN(High(Byte), AddUnKnowAbility.wUnParalysisRate + (Item.btAppraisalValue[I] - 160)); //麻痹抗性(1..20)
            181..230: AddUnKnowAbility.wIncDragonRate := _MIN(High(Word), AddUnKnowAbility.wIncDragonRate + (Item.btAppraisalValue[I] - 180)); //合击威力(1..50) (同金牛的合击伤害)
            231..250: ; //宝物灵媒 品质(11.4 * 值 上限228) 当前灵气值用btValue[11]保存，武器用btValue[12]
          end;
        end;
      end;
  end;
end;
{$IFEND}

//取名字颜色值

function TBaseObject.GetCharColor(BaseObject: TBaseObject): Byte;
var
  n10: Integer;
  Castle: TUserCastle;
begin
  try
    if BaseObject = nil then Exit; //20090511 增加
    if not BaseObject.m_boGhost then begin //20090511 增加
      Result := BaseObject.GetNamecolor();
      case BaseObject.m_btRaceServer of //20090911 修改
        RC_PLAYOBJECT: begin //人物
            if BaseObject.PKLevel < 2 then begin
              if BaseObject.m_boPKFlag then Result := g_Config.btPKFlagNameColor; //$2F
              n10 := GetGuildRelation(Self, BaseObject);
              case n10 of
                1, 3: Result := g_Config.btAllyAndGuildNameColor; //$B4;
                2: Result := g_Config.btWarGuildNameColor; //$45;
              end;
              if BaseObject.m_PEnvir.m_boFight3Zone or BaseObject.m_PEnvir.m_boFight5Zone then begin
                if m_MyGuild = BaseObject.m_MyGuild then Result := g_Config.btAllyAndGuildNameColor //$B4
                else Result := g_Config.btWarGuildNameColor //$45;
              end;
            end;
            Castle := g_CastleManager.InCastleWarArea(BaseObject);
            if (Castle <> nil) and Castle.m_boUnderWar and m_boInFreePKArea and BaseObject.m_boInFreePKArea then begin
              Result := g_Config.btInFreePKAreaNameColor; //$DD;
              m_boGuildWarArea := True;
              if (m_MyGuild = nil) then Exit;
              if Castle.IsMasterGuild(TGUild(m_MyGuild)) then begin
                if (m_MyGuild = BaseObject.m_MyGuild) or
                  (TGUild(m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_MyGuild))) then begin
                  Result := g_Config.btAllyAndGuildNameColor;
                end else begin
                  if Castle.IsAttackGuild(TGUild(BaseObject.m_MyGuild)) then begin
                    Result := g_Config.btWarGuildNameColor;
                  end;
                end;
              end else begin
                if Castle.IsAttackGuild(TGUild(m_MyGuild)) then begin
                  if (m_MyGuild = BaseObject.m_MyGuild) or (TGUild(m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_MyGuild))) then begin
                    Result := g_Config.btAllyAndGuildNameColor;
                  end else begin
                    if Castle.IsMember(BaseObject) then Result := g_Config.btWarGuildNameColor;
                  end;
                end;
              end;
            end;
          end; //RC_PLAYOBJECT
        RC_HEROOBJECT: begin
            if BaseObject.PKLevel < 2 then begin
              if BaseObject.m_boPKFlag then Result := g_Config.btPKFlagNameColor;
              if BaseObject.m_Master <> nil then begin //20080806 增加
                n10 := GetGuildRelation(Self, BaseObject.m_Master);
                case n10 of
                  1, 3: Result := g_Config.btAllyAndGuildNameColor; //$B4;
                  2: Result := g_Config.btWarGuildNameColor; //$45;
                end;
                if BaseObject.m_PEnvir.m_boFight3Zone or BaseObject.m_PEnvir.m_boFight5Zone then begin
                  if m_MyGuild = BaseObject.m_Master.m_MyGuild then Result := g_Config.btAllyAndGuildNameColor //$B4
                  else Result := g_Config.btWarGuildNameColor //$45;
                end;
              end;
            end;
            //攻城区域,英雄也一样变名 20080720
            Castle := g_CastleManager.InCastleWarArea(BaseObject);
            if BaseObject.m_Master <> nil then begin //20080803 增加
              if (Castle <> nil) and Castle.m_boUnderWar and BaseObject.m_Master.m_boInFreePKArea then begin
                Result := g_Config.btInFreePKAreaNameColor; //$DD;
                m_boGuildWarArea := True;
                if (m_MyGuild = nil) then Exit;
                if Castle.IsMasterGuild(TGUild(m_MyGuild)) then begin
                  if (m_MyGuild = BaseObject.m_Master.m_MyGuild) or
                    (TGUild(m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_MyGuild))) then begin
                    Result := g_Config.btAllyAndGuildNameColor;
                  end else begin
                    if Castle.IsAttackGuild(TGUild(BaseObject.m_Master.m_MyGuild)) then begin
                      Result := g_Config.btWarGuildNameColor;
                    end;
                  end;
                end else begin
                  if Castle.IsAttackGuild(TGUild(m_MyGuild)) then begin
                    if (m_MyGuild = BaseObject.m_Master.m_MyGuild) or
                      (TGUild(m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_MyGuild))) then begin
                      Result := g_Config.btAllyAndGuildNameColor;
                    end else begin
                      if Castle.IsMember(BaseObject.m_Master) then Result := g_Config.btWarGuildNameColor;
                    end;
                  end;
                end;
              end;
            end;
          end; //RC_HEROOBJECT
        11, RC_NPC: begin //NPC名字颜色,大刀卫士名字和NPC一样 20110122
            Result := g_Config.btNPCNameColor;
            if BaseObject.m_boCrazyMode then Result := $F9; //疯狂模式(红名)
            if BaseObject.m_boHolySeize then Result := $7D; //不能走动模式(困魔咒)
          end; //RC_NPC
        132, 133: begin //圣兽名字颜色
            case BaseObject.m_btSlaveExpLevel of
              0..10: Result := g_Config.SlaveColor[0];
              11..21: Result := g_Config.SlaveColor[1];
              22..32: Result := g_Config.SlaveColor[2];
              33..43: Result := g_Config.SlaveColor[3];
              44..54: Result := g_Config.SlaveColor[4];
              55..65: Result := g_Config.SlaveColor[5];
              66..76: Result := g_Config.SlaveColor[6];
              77..87: Result := g_Config.SlaveColor[7];
              88..99: Result := g_Config.SlaveColor[8];
            end;
{$IF M2Version <> 2}
            if BaseObject.m_boIsNGMonster and (m_btRaceServer = RC_PLAYOBJECT) then begin //内功怪颜色
              if TPlayObject(self).m_boTrainingNG then Result := $F2; //学过内功
            end;
{$IFEND}
{$IF M2Version = 1}
            if BaseObject.m_boIsHeroPulsExpMon and (m_btRaceServer = RC_PLAYOBJECT) then begin //英雄经络经验怪,名字为绿色 20090911
              if (TPlayObject(self).m_MyHero <> nil) then begin
                if THeroObject(TPlayObject(self).m_MyHero).m_boOpenHumanPulseArr then Result := $DB;
              end;
            end;
{$IFEND}
            if BaseObject.m_boCrazyMode then Result := $F9; //疯狂模式(红名)
            if BaseObject.m_boHolySeize then Result := $7D; //不能走动模式
          end; //132,133
        154: begin //火灵
            case BaseObject.m_btSlaveExpLevel of
              0..10: Result := g_Config.SlaveColor[0];
              11..21: Result := g_Config.SlaveColor[1];
              22..32: Result := g_Config.SlaveColor[2];
              33..43: Result := g_Config.SlaveColor[3];
              44..54: Result := g_Config.SlaveColor[4];
              55..65: Result := g_Config.SlaveColor[5];
              66..76: Result := g_Config.SlaveColor[6];
              77..87: Result := g_Config.SlaveColor[7];
              88..100: Result := g_Config.SlaveColor[8];
            end;
{$IF M2Version <> 2}
            if BaseObject.m_boIsNGMonster and (m_btRaceServer = RC_PLAYOBJECT) then begin //内功怪颜色
              if TPlayObject(self).m_boTrainingNG then Result := $F2; //学过内功
            end;
{$IFEND}
{$IF M2Version = 1}
            if BaseObject.m_boIsHeroPulsExpMon and (m_btRaceServer = RC_PLAYOBJECT) then begin //英雄经络经验怪,名字为绿色 20090911
              if (TPlayObject(self).m_MyHero <> nil) then begin
                if THeroObject(TPlayObject(self).m_MyHero).m_boOpenHumanPulseArr then Result := $DB;
              end;
            end;
{$IFEND}
            if BaseObject.m_boCrazyMode then Result := $F9; //疯狂模式(红名)
            if BaseObject.m_boHolySeize then Result := $7D; //不能走动模
          end; //154
        RC_PLAYMOSTER: begin //分形怪，分身
            if (BaseObject.m_btSlaveExpLevel < SLAVEMAXLEVEL) and (not BaseObject.m_boSetNameColor) then begin //没有自定义名字颜色
              Result := g_Config.SlaveColor[BaseObject.m_btSlaveExpLevel];
              if (BaseObject.m_Master <> nil) then Result := BaseObject.m_btNameColor; //分身和主人名字颜色一样
            end;
            if (BaseObject.m_Master <> nil) then begin //人形灰名显示 20090103
              if (BaseObject.m_Master.m_boPKFlag) then Result := g_Config.btPKFlagNameColor;
              case BaseObject.m_Master.m_btRaceServer of //增加行会战，分身与主体一样颜色
                RC_PLAYOBJECT: begin
                    n10 := GetGuildRelation(Self, BaseObject.m_Master); //检查行会关系,盟友或敌对
                    case n10 of
                      1, 3: Result := g_Config.btAllyAndGuildNameColor; //$B4;
                      2: Result := g_Config.btWarGuildNameColor; //$45;
                    end;
                    if BaseObject.m_PEnvir.m_boFight3Zone or BaseObject.m_PEnvir.m_boFight5Zone then begin
                      if m_MyGuild = BaseObject.m_Master.m_MyGuild then Result := g_Config.btAllyAndGuildNameColor //$B4
                      else Result := g_Config.btWarGuildNameColor //$45;
                    end;
                  end;
                RC_HEROOBJECT: begin //20100418 英雄的分身行会战、攻城变色
                    if BaseObject.m_Master.m_Master <> nil then begin
                      n10 := GetGuildRelation(self, BaseObject.m_Master.m_Master); //检查行会关系,盟友或敌对
                      case n10 of
                        1, 3: Result := g_Config.btAllyAndGuildNameColor; //$B4;
                        2: Result := g_Config.btWarGuildNameColor; //$45;
                      end;
                      if BaseObject.m_PEnvir.m_boFight3Zone or BaseObject.m_PEnvir.m_boFight5Zone then begin
                        if m_MyGuild = BaseObject.m_Master.m_Master.m_MyGuild then Result := g_Config.btAllyAndGuildNameColor //$B4
                        else Result := g_Config.btWarGuildNameColor //$45;
                      end;

                      if BaseObject.m_Master.m_Master <> nil then begin //攻城区域,分身也一样变名
                        Castle := g_CastleManager.InCastleWarArea(BaseObject);
                        if (Castle <> nil) and Castle.m_boUnderWar and BaseObject.m_Master.m_Master.m_boInFreePKArea then begin
                          Result := g_Config.btInFreePKAreaNameColor; //$DD;
                          m_boGuildWarArea := True;
                          if (m_MyGuild <> nil) then begin
                            if Castle.IsMasterGuild(TGUild(m_MyGuild)) then begin
                              if (m_MyGuild = BaseObject.m_Master.m_Master.m_MyGuild) or
                                (TGUild(m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_Master.m_MyGuild))) then begin
                                Result := g_Config.btAllyAndGuildNameColor;
                              end else begin
                                if Castle.IsAttackGuild(TGUild(BaseObject.m_Master.m_Master.m_MyGuild)) then begin
                                  Result := g_Config.btWarGuildNameColor;
                                end;
                              end;
                            end else begin
                              if Castle.IsAttackGuild(TGUild(m_MyGuild)) then begin
                                if (m_MyGuild = BaseObject.m_Master.m_Master.m_MyGuild) or
                                  (TGUild(m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_Master.m_MyGuild))) then begin
                                  Result := g_Config.btAllyAndGuildNameColor;
                                end else begin
                                  if Castle.IsMember(BaseObject.m_Master.m_Master) then begin
                                    Result := g_Config.btWarGuildNameColor;
                                  end;
                                end;
                              end;
                            end;
                          end;
                        end;
                      end;
                    end;
                  end;
              end; //case
            end;
{$IF M2Version <> 2}
            if BaseObject.m_boIsNGMonster and (m_btRaceServer = RC_PLAYOBJECT) then begin //内功怪颜色
              if TPlayObject(self).m_boTrainingNG then Result := $F2; //学过内功
            end;
{$IFEND}
{$IF M2Version = 1}
            if BaseObject.m_boIsHeroPulsExpMon and (m_btRaceServer = RC_PLAYOBJECT) then begin //英雄经络经验怪,名字为绿色 20090911
              if (TPlayObject(self).m_MyHero <> nil) then begin
                if THeroObject(TPlayObject(self).m_MyHero).m_boOpenHumanPulseArr then Result := $DB;
              end;
            end;
{$IFEND}
            if BaseObject.m_boCrazyMode then Result := $F9; //疯狂模式(红名)
            if BaseObject.m_boHolySeize then Result := $7D; //不能走动模式
          end; //RC_PLAYMOSTER
      else begin //其它
          if (BaseObject.m_btSlaveExpLevel < SLAVEMAXLEVEL) and (not BaseObject.m_boSetNameColor) then begin //没有自定义名字颜色
            Result := g_Config.SlaveColor[BaseObject.m_btSlaveExpLevel];
          end;
{$IF M2Version <> 2}
          if BaseObject.m_boIsNGMonster and (m_btRaceServer = RC_PLAYOBJECT) then begin //内功怪颜色
            if TPlayObject(self).m_boTrainingNG then Result := $F2; //学过内功
          end;
{$IFEND}
{$IF M2Version = 1}
          if BaseObject.m_boIsHeroPulsExpMon and (m_btRaceServer = RC_PLAYOBJECT) then begin //英雄经络经验怪,名字为绿色 20090911
            if (TPlayObject(self).m_MyHero <> nil) then begin
              if THeroObject(TPlayObject(self).m_MyHero).m_boOpenHumanPulseArr then Result := $DB;
            end;
          end;
{$IFEND}
          if BaseObject.m_boCrazyMode then Result := $F9; //疯狂模式(红名)
          if BaseObject.m_boHolySeize then Result := $7D; //不能走动模式
        end;
      end; //case
    end;
  except
    //MainOutMessage('{异常} TBaseObject.GetCharColor Code:' + inttostr(nCode));
  end;
end;
//取等级所需经验值

function TBaseObject.GetLevelExp(nLevel: Integer): LongWord;
  function GetBaseExp(): Integer;
  var
    nInt64: Int64;
  begin
    nInt64 := (nLevel - 1000) * g_Config.nAddExp + g_Config.nBaseExp;
    if nInt64 > High(LongWord) then Result := High(LongWord) else Result := nInt64;
  end;
begin
  if nLevel <= MAXCHANGELEVEL {1000} then begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      Result := g_Config.dwNeedExps[nLevel];
    end else begin
      Result := g_Config.dwHeroNeedExps[nLevel]; //英雄经验
    end;
    Exit;
  end;
  if g_Config.boUseFixExp then begin
    if nLevel <= MAXLEVEL then begin
      Result := 2000000000 + nLevel * 1500;
    end else begin
      Result := High(LongWord); //g_Config.dwNeedExps[High(g_Config.dwNeedExps)];
    end;
  end else begin
    if nLevel <= MAXLEVEL then begin
      Result := GetBaseExp();
    end else begin
      Result := High(LongWord);
    end;
  end;
end;
//取等级所需药力值 20080624

function TBaseObject.GetMedicineExp(nLevel: Integer): Word;
begin
  if nLevel <= MAXCHANGELEVEL {1000} then begin
    Result := g_Config.dwMedicineNeedExps[nLevel];
    Exit;
  end;
  if nLevel <= MAXLEVEL then Result := High(Word);
end;

//酒气护体 取等级所需经验值 20080625

function TBaseObject.GetSkill68Exp(nLevel: Byte): LongWord;
begin
  Result := 0;
  if nLevel <= 0 then nLevel := 1; //20110525 修改
  if nLevel < 100 then begin
    Result := g_Config.dwSkill68NeedExps[nLevel];
  end else Result := g_Config.dwSkill68NeedExps[High(g_Config.dwSkill68NeedExps)];
end;

//内功心法 取等级所需经验值,内力值上限 20080930

function TBaseObject.GetSkill69Exp(nLevel: Word; var nMaxNH: Integer): LongWord;
var
  nMax: LongWord;
begin
  if nLevel <= g_Config.nLimitExpNGLevel then begin
    nMax := 0;
    if nLevel < High(Byte) then begin
      nMax := Round((2 + 2 * (nLevel - 1)) * (nLevel / 2) + g_Config.nSkill69NG {10});
      if m_btRaceServer = RC_PLAYOBJECT then begin //主体
        Result := 200 * nLevel * nLevel * nLevel + g_Config.nSkill69NGExp1 {13940} * nLevel * nLevel + g_Config.nSkill69NGExp {55330};
      end else begin
        Result := 200 * nLevel * nLevel * nLevel + g_Config.nHeroSkill69NGExp1 {14240} * nLevel * nLevel + g_Config.nHeroSkill69NGExp1 {14240} * nLevel + g_Config.nHeroSkill69NGExp {62400}; //英雄经验
      end;
    end else begin
      nMax := Round(65025 + (nLevel - 254) * 100 + g_Config.nSkill69NG {10});
      Result := 4250000000;
    end;
    if nMax > High(integer) then nMaxNH := High(integer)
    else nMaxNH := nMax;
  end;
end;
//取人物名字颜色

function TBaseObject.GetNamecolor(): Byte;
begin
  Result := m_btNameColor;
  if PKLevel = 1 then Result := g_Config.btPKLevel1NameColor; //$FB;
  if PKLevel >= 2 then Result := g_Config.btPKLevel2NameColor; //$F9;
end;
//查询在线人数即 who Total 命令返回

procedure TBaseObject.HearMsg(sMsg: string);
begin
  if sMsg <> '' then SendMsg(nil, RM_HEAR, 0, g_Config.btHearMsgFColor, g_Config.btHearMsgBColor, 0, sMsg);
end;
//是否在安全区

function TBaseObject.InSafeArea(): Boolean;
var
  I: Integer;
  SC: string;
  n14, n18: Integer;
  StartPoint: pTStartPoint;
begin
  Result := False;
  if m_PEnvir = nil then Exit;
  Result := m_PEnvir.m_boSAFE;
  if Result then Exit;
  try
    g_StartPointList.Lock;
    if g_StartPointList.Count > 0 then begin //20080629
      for I := 0 to g_StartPointList.Count - 1 do begin
        SC := g_StartPointList.Strings[I];
        if SC = m_PEnvir.sMapName then begin
          StartPoint := pTStartPoint(g_StartPointList.Objects[I]);
          if StartPoint <> nil then begin
            n14 := StartPoint.m_nCurrX;
            n18 := StartPoint.m_nCurrY; //20081006修改,使用安全区范围做判断
            if (abs(m_nCurrX - n14) <= {60} g_Config.nSafeZoneSize) and (abs(m_nCurrY - n18) <= {60} g_Config.nSafeZoneSize) then begin
              Result := True;
              Break;
            end;
          end;
        end;
      end; //for
    end;
  finally
    g_StartPointList.UnLock;
  end;
end;
//怪物刷新属性

procedure TBaseObject.MonsterRecalcAbilitys;
var
  n8: Integer;
begin
  m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_Abil.DC));
  n8 := 0;
  case m_btRaceServer of
    100, 113, 114: begin //骷髅，神圣
        m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), Round((m_btSlaveExpLevel * 0.1 + 0.3) * 3 * m_btSlaveExpLevel + HiWord(m_WAbil.DC)));
        n8 := n8 + Round((m_btSlaveExpLevel * 0.1 + 0.3) * m_Abil.MaxHP) * m_btSlaveExpLevel;
        n8 := n8 + m_Abil.MaxHP;
        if m_btSlaveExpLevel > 0 then m_WAbil.MaxHP := n8
        else m_WAbil.MaxHP := m_Abil.MaxHP;
      end;
    132, 133: begin //圣兽
        m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), Round((m_btSlaveExpLevel * 0.01 + 0.15) * m_btSlaveExpLevel + HiWord(m_WAbil.DC)));
        n8 := n8 + Round(m_Abil.MaxHP * 0.15) * m_btSlaveExpLevel; //每级提升HP的15%
        n8 := n8 + m_Abil.MaxHP;
        if m_btSlaveExpLevel > 0 then m_WAbil.MaxHP := n8
        else m_WAbil.MaxHP := m_Abil.MaxHP;
      end;
  else begin
      n8 := m_Abil.MaxHP;
      m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), Round(m_btSlaveExpLevel * 2 + HiWord(m_WAbil.DC)));
      n8 := n8 + Round(m_Abil.MaxHP * 0.15) * m_btSlaveExpLevel;
      m_WAbil.MaxHP := _MIN(Round(m_Abil.MaxHP + m_btSlaveExpLevel * 60), n8);
      {if m_Master <> nil then begin//宝宝增加属性By TasNat at: 2012-05-18 09:14:34
        m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC) + m_btSlaveExpLevel, Round(m_btSlaveExpLevel * 1.3 + HiWord(m_WAbil.AC)));
        m_nNextHitTime := _MAx(m_nNextHitTime, 3000 - m_btSlaveExpLevel * 600);
        m_nWalkSpeed := _MAx(m_nWalkSpeed, 1200 - m_btSlaveExpLevel * 250);
        m_dwWalkTick := GetTickCount + m_nNextHitTime;
      end;       }
    end;
  end;
  {if (m_btRaceServer = 100) or (m_btRaceServer = 113) or (m_btRaceServer = 114) then begin
    m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), Round((m_btSlaveExpLevel * 0.1 + 0.3) * 3.0 * m_btSlaveExpLevel + HiWord(m_WAbil.DC)));
    n8 := n8 + Round((m_btSlaveExpLevel * 0.1 + 0.3) * m_Abil.MaxHP) * m_btSlaveExpLevel;
    n8 := n8 + m_Abil.MaxHP;
    if m_btSlaveExpLevel > 0 then m_WAbil.MaxHP := n8
    else m_WAbil.MaxHP := m_Abil.MaxHP;
  end else begin
    n8 := m_Abil.MaxHP;
    m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), Round(m_btSlaveExpLevel * 2 + HiWord(m_WAbil.DC)));
    n8 := n8 + Round(m_Abil.MaxHP * 0.15) * m_btSlaveExpLevel;
    m_WAbil.MaxHP := _MIN(Round(m_Abil.MaxHP + m_btSlaveExpLevel * 60), n8);
  end;}
end;

procedure TPlayObject.ShowMapInfo(sMAP, sX, sY: string);
var
  Map: TEnvirnoment;
  nX, nY: Integer;
  MapCellInfo: pTMapCellinfo;
begin
  nX := Str_ToInt(sX, 0);
  nY := Str_ToInt(sY, 0);
  if (sMAP <> '') and (nX >= 0) and (nY >= 0) then begin
    Map := g_MapManager.FindMap(sMAP);
    if Map <> nil then begin
      if Map.GetMapCellInfo(nX, nY, MapCellInfo) then begin
        SysMsg('标志: ' + IntToStr(MapCellInfo.chFlag), c_Green, t_Hint);
        if MapCellInfo.ObjList <> nil then begin
          SysMsg('对象数: ' + IntToStr(MapCellInfo.ObjList.Count), c_Green, t_Hint);
        end;
      end else begin
        SysMsg('取地图单元信息失败: ' + sMAP, c_Red, t_Hint);
      end;
    end;
  end else begin
    SysMsg('请按正确格式输入: ' + g_GameCommand.MAPINFO.sCmd + ' 地图号 X Y', c_Green, t_Hint);
  end;
end;

procedure TBaseObject.SendFirstMsg(BaseObject: TBaseObject; wIdent, wParam: Word;
  lParam1, lParam2, lParam3: Integer; sMsg: string);
var
  SendMessage: pTSendMessage;
begin
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    if not m_boGhost then begin
      New(SendMessage);
      SendMessage.wIdent := wIdent;
      SendMessage.wParam := wParam;
      SendMessage.nParam1 := lParam1;
      SendMessage.nParam2 := lParam2;
      SendMessage.nParam3 := lParam3;
      SendMessage.dwDeliveryTime := 0;
      SendMessage.BaseObject := BaseObject;
      if sMsg <> '' then begin
        try
          GetMem(SendMessage.Buff, Length(sMsg) + 1);
          Move(sMsg[1], SendMessage.Buff^, Length(sMsg) + 1);
        except
          SendMessage.Buff := nil;
        end;
      end else begin
        SendMessage.Buff := nil;
      end;
      m_MsgList.Insert(0, SendMessage);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

procedure TBaseObject.SendMsg(BaseObject: TBaseObject; wIdent, wParam: Word; nParam1, nParam2, nParam3: Integer; sMsg: string);
var
  SendMessage: pTSendMessage;
  nCode: Byte;
  boSend: Boolean;
begin
  nCode := 0;
  try
    boSend := False;
    if m_boAI then begin
      case wIdent of
        RM_MAGSTRUCK,
          RM_MAGSTRUCK_MINE,
          RM_DELAYPUSHED,
          RM_10155,
          RM_POISON,
          RM_TRANSPARENT,
          RM_DOOPENHEALTH,
          RM_MAGHEALING,
          RM_DELAYMAGIC,
          RM_HEAR2,
          RM_SENDDELITEMLIST,
          RM_10401,
          RM_10101,
          RM_STRUCK,
          RM_STRUCK_MAG,

        RM_MAKEGHOSTHERO: boSend := True;
      end;

      if (not boSend) and m_boAI and (m_btRaceServer = RC_PLAYOBJECT) then begin
        case wIdent of
          RM_HEAR,
            RM_WHISPER,
            RM_CRY,
            RM_SYSMESSAGE,
            RM_MOVEMESSAGE1,
            RM_MOVEMESSAGE,
            RM_GROUPMESSAGE,
            RM_SYSMESSAGE2,
            RM_GUILDMESSAGE,
            RM_DIVISIONMESSAGE,
            RM_SYSMESSAGE3,
            RM_PLAYDRINKSAY,
            RM_MERCHANTSAY: boSend := True;
        end;
      end;
    end else boSend := True;

    if boSend then begin
      try
        EnterCriticalSection(ProcessMsgCriticalSection);
        nCode := 1;
        if not m_boGhost then begin
          New(SendMessage);
          SendMessage.wIdent := wIdent;
          SendMessage.wParam := wParam;
          SendMessage.nParam1 := nParam1;
          SendMessage.nParam2 := nParam2;
          SendMessage.nParam3 := nParam3;
          SendMessage.dwDeliveryTime := 0;
          SendMessage.BaseObject := BaseObject;
          SendMessage.boLateDelivery := False;
          if sMsg <> '' then begin
            try
              nCode := 5;
              GetMem(SendMessage.Buff, Length(sMsg) + 1);
              Move(sMsg[1], SendMessage.Buff^, Length(sMsg) + 1);
            except
              SendMessage.Buff := nil;
            end;
          end else begin
            SendMessage.Buff := nil;
          end;
          nCode := 17;
          m_MsgList.Add(SendMessage);
        end;
      finally
        LeaveCriticalSection(ProcessMsgCriticalSection);
      end;
    end;
  except   
    MainOutMessage(format('{%s} TBaseObject.SendMsg Code:%d', [g_sExceptionVer, nCode]));
  end;
end;
//------------------------------------------------------------------------------
//过程名：SendDelayMsg
//作用：延迟发送消息
//参数：dwDelay: LongWord  为延迟时间 单位：毫秒

procedure TBaseObject.SendDelayMsg(BaseObject: TBaseObject; wIdent,
  wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string;
  dwDelay: LongWord);
var
  SendMessage: pTSendMessage;
  boSend: Boolean;
begin
  boSend := False;
  if (m_boAI) then begin
    case wIdent of
      RM_MAGSTRUCK,
        RM_MAGSTRUCK_MINE,
        RM_DELAYPUSHED,
        RM_10155,
        RM_POISON,
        RM_TRANSPARENT,
        RM_DOOPENHEALTH,
        RM_MAGHEALING,
        RM_DELAYMAGIC,
        RM_HEAR2,
        RM_SENDDELITEMLIST,
        RM_10401,
        RM_10101,
        RM_STRUCK,
        RM_STRUCK_MAG,

      RM_MAKEGHOSTHERO: boSend := True;
    end;

    if (not boSend) and m_boAI and (m_btRaceServer = RC_PLAYOBJECT) then begin
      case wIdent of
        RM_HEAR,
          RM_WHISPER,
          RM_CRY,
          RM_SYSMESSAGE,
          RM_MOVEMESSAGE1,
          RM_MOVEMESSAGE,
          RM_GROUPMESSAGE,
          RM_SYSMESSAGE2,
          RM_GUILDMESSAGE,
          RM_DIVISIONMESSAGE,
          RM_SYSMESSAGE3,
          RM_PLAYDRINKSAY,
          RM_MERCHANTSAY: boSend := True;
      end;
    end;
  end else boSend := True;
  if boSend then begin
    try
      EnterCriticalSection(ProcessMsgCriticalSection);
      if not m_boGhost then begin
        New(SendMessage);
        SendMessage.wIdent := wIdent;
        SendMessage.wParam := wParam;
        SendMessage.nParam1 := lParam1;
        SendMessage.nParam2 := lParam2;
        SendMessage.nParam3 := lParam3;
        SendMessage.dwDeliveryTime := GetTickCount + dwDelay;
        SendMessage.BaseObject := BaseObject;
        SendMessage.boLateDelivery := True;
        if sMsg <> '' then begin
          try
            GetMem(SendMessage.Buff, Length(sMsg) + 1);
            Move(sMsg[1], SendMessage.Buff^, Length(sMsg) + 1);
          except
            SendMessage.Buff := nil;
          end;
        end else begin
          SendMessage.Buff := nil;
        end;
        m_MsgList.Add(SendMessage);
      end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
  end;
end;

procedure TBaseObject.SendUpdateDelayMsg(BaseObject: TBaseObject; wIdent,
  wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string;
  dwDelay: LongWord);
var
  SendMessage: pTSendMessage;
  I: Integer;
begin
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    I := 0;
    while (True) do begin
      if m_MsgList.Count <= I then Break;
      try //20091113 增加
        SendMessage := m_MsgList.Items[I];
        if SendMessage <> nil then begin //20091101 增加
          if (SendMessage.wIdent = wIdent) and (SendMessage.nParam1 = lParam1) then begin
            m_MsgList.Delete(I);
            if SendMessage.Buff <> nil then FreeMem(SendMessage.Buff);
            Dispose(SendMessage);
            Continue;
          end;
        end;
      except
      end;
      Inc(I);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
  SendDelayMsg(BaseObject, wIdent, wParam, lParam1, lParam2, lParam3, sMsg, dwDelay);
end;

procedure TBaseObject.SendUpdateMsg(BaseObject: TBaseObject; wIdent, wParam: Word;
  lParam1, lParam2, lParam3: Integer; sMsg: string);
var
  SendMessage: pTSendMessage;
  I: Integer;
begin
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    I := 0;
    while (True) do begin
      if m_MsgList.Count <= I then Break;
      try //20091113 增加
        SendMessage := m_MsgList.Items[I];
        if SendMessage <> nil then begin //20091101 增加
          if SendMessage.wIdent = wIdent then begin
            m_MsgList.Delete(I);
            if SendMessage.Buff <> nil then FreeMem(SendMessage.Buff);
            Dispose(SendMessage);
            Continue;
          end;
        end;
      except
      end;
      Inc(I);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
  SendMsg(BaseObject, wIdent, wParam, lParam1, lParam2, lParam3, sMsg);
end;

procedure TBaseObject.SendUpdateMsgB(BaseObject: TBaseObject; wIdent, wParam: Word;
  lParam1, lParam2, lParam3: Integer; sMsg: string);
var
  SendMessage: pTSendMessage;
  I: Integer;
begin
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    I := 0;
    while (True) do begin
      if m_MsgList.Count <= I then Break;
      try //20091113 增加
        SendMessage := m_MsgList.Items[I];
        if SendMessage <> nil then begin //20091101 增加
          if (SendMessage.wIdent = wIdent) and (TBaseObject(SendMessage.BaseObject) = BaseObject) then begin
            m_MsgList.Delete(I);
            if SendMessage.Buff <> nil then FreeMem(SendMessage.Buff);
            Dispose(SendMessage);
            Continue;
          end;
        end;
      except
      end;
      Inc(I);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
  SendMsg(BaseObject, wIdent, wParam, lParam1, lParam2, lParam3, sMsg);
end;

//20100203 增加,替换SendActionMsg

procedure TBaseObject.SendUpdateMsgA(BaseObject: TBaseObject; wIdent, wParam: Word;
  lParam1, lParam2, lParam3: Integer; sMsg: string);
var
  SendMessage: pTSendMessage;
  boFind: Boolean;
  I: Integer;
begin
  boFind := False;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    if m_MsgList.Count > 0 then begin
      for I := 0 to m_MsgList.Count - 1 do begin
        SendMessage := m_MsgList.Items[I];
        if SendMessage <> nil then begin
          if SendMessage.wIdent = wIdent then begin
            boFind := True;
            Break;
          end;
        end;
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
  if not boFind then SendMsg(BaseObject, wIdent, wParam, lParam1, lParam2, lParam3, sMsg);
end;
(*//20100203 注释
procedure TBaseObject.SendActionMsg(BaseObject: TBaseObject; wIdent, wParam: Word;
  lParam1, lParam2, lParam3: Integer; sMsg: string);
var
  SendMessage: pTSendMessage;
  I: Integer;
begin
  try//20091113 增加
    EnterCriticalSection(ProcessMsgCriticalSection);
    try
      I := 0;
        while (True) do begin
          if m_MsgList.Count <= I then Break;
          SendMessage := m_MsgList.Items[I];
          if SendMessage <> nil then begin//20091017 增加
            if (SendMessage.wIdent = CM_TURN) or
              (SendMessage.wIdent = CM_WALK) or
              (SendMessage.wIdent = CM_SITDOWN) or
              (SendMessage.wIdent = CM_HORSERUN) or
              (SendMessage.wIdent = CM_RUN) or
              (SendMessage.wIdent = CM_HIT) or
              (SendMessage.wIdent = CM_HEAVYHIT) or
              (SendMessage.wIdent = CM_BIGHIT) or
              (SendMessage.wIdent = CM_POWERHIT) or
              (SendMessage.wIdent = CM_LONGHIT) or
              (SendMessage.wIdent = CM_LONGHIT4) or//四级刺杀
              (SendMessage.wIdent = CM_WIDEHIT) or
              (SendMessage.wIdent = CM_WIDEHIT4) or//圆月弯刀
              (SendMessage.wIdent = CM_CRSHIT) or
              (SendMessage.wIdent = CM_DAILY) or //逐日剑法 20080511
              (SendMessage.wIdent = CM_FIREHIT) or{烈火}
              (SendMessage.wIdent = CM_4FIREHIT) {4级烈火 20080112} then begin
              m_MsgList.Delete(I);
              try//20091017 增加
                if SendMessage.Buff <> nil then FreeMem(SendMessage.Buff);
                Dispose(SendMessage);
              except   
              end;
              Continue;
            end;
          end;
          Inc(I);
        end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
    SendMsg(BaseObject, wIdent, wParam, lParam1, lParam2, lParam3, sMsg);
  except   
  end;
end;  *)

function TBaseObject.MessageCount(): Integer;
begin
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    Result := m_MsgList.Count;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TBaseObject.GetMessage(Msg: pTProcessMessage): Boolean;
var
  I: Integer;
  SendMessage: pTSendMessage;
  //nCode: Byte;
begin
  Result := False;
  //nCode:= 0;
  if (Msg = nil) then Exit; //20090313
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    try
      I := 0;
      Msg.wIdent := 0;
      //nCode:= 1;
      if m_MsgList <> nil then begin //20080912 增加
        while m_MsgList.Count > I do begin
          if m_MsgList.Count <= 0 then Break; //20090705 增加
          //nCode:= 2;
          try //20090510 修改
            SendMessage := m_MsgList.Items[I];
          except
            //Inc(I);
            m_MsgList.Delete(I); //20091102 替换Inc(I);
            Continue;
          end;
          //nCode:= 3;
          if SendMessage = nil then begin //20090313 修改
            //Inc(I);
            m_MsgList.Delete(I); //20091102 替换Inc(I);
            Continue;
          end;
          //nCode:= 5;
          if (SendMessage.dwDeliveryTime <> 0) and (GetTickCount < SendMessage.dwDeliveryTime) then begin //延时消息
            Inc(I);
            Continue;
          end;
          //nCode:= 10;
          m_MsgList.Delete(I);
          //nCode:= 11;
          Msg.wIdent := SendMessage.wIdent;
          Msg.wParam := SendMessage.wParam;
          Msg.nParam1 := SendMessage.nParam1;
          Msg.nParam2 := SendMessage.nParam2;
          Msg.nParam3 := SendMessage.nParam3;
          Msg.BaseObject := SendMessage.BaseObject;
          Msg.dwDeliveryTime := SendMessage.dwDeliveryTime;
          Msg.boLateDelivery := SendMessage.boLateDelivery;
          if SendMessage.Buff <> nil then begin
            //nCode:= 6;
            if Msg <> nil then Msg.sMsg := StrPas(SendMessage.Buff);
            //nCode:= 7;
            try //20100109 增加异常保护
              FreeMem(SendMessage.Buff);
            except
            end;
          end else begin
            if Msg <> nil then Msg.sMsg := '';
          end;
          //nCode:= 8;
          if SendMessage <> nil then Dispose(SendMessage); //20080908 修改
          Result := True;
          Break;
        end;
      end;
    except
      //MainOutMessage(Format('{异常} TBaseObject.GetMessage Code:%d',[nCode]));
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;
//检查同个方向内一定范围里的怪(龙影)  20080405

function TBaseObject.GetDirectionBaseObjects_42(btDir, nRage: Integer; rList: TList): Boolean;
var
  I, III: Integer;
  X, Y: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
resourcestring
  sExceptionMsg = '{%s} TBaseObject::GetDirectionBaseObjects_42';
begin
  Result := False;
  if rList = nil then Exit;
  if nRage <= 0 then nRage := 1; //20091113 增加
  try
    case btDir of
      DR_UP: begin //北--OK
          for y := m_nCurrY downto m_nCurrY - nRage do begin
            for X := m_nCurrX - 1 to m_nCurrX + 1 do begin
              if m_PEnvir.GetMapCellInfo(X, Y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
                if MapCellInfo.ObjList.Count > 0 then begin //20080629
                  for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                    OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                    if (OSObject <> nil) then begin
                      if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                        BaseObject := TBaseObject(OSObject.CellObj);
                        if (BaseObject <> nil) then begin
                          if (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                            rList.Add(BaseObject);
                          end;
                        end;
                      end;
                    end;
                  end; //for
                end;
              end;
            end; //X
          end; //Y
        end;
      DR_UPRIGHT: begin //东北--OK
          for I := 0 to nRage do begin
            x := m_nCurrX + I;
            y := m_nCurrY - I;
            for X := X - 1 to X + 1 do begin
              for Y := Y - 1 to Y + 1 do begin
                if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
                  if MapCellInfo.ObjList.Count > 0 then begin //20080629
                    for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                      OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                      if (OSObject <> nil) then begin
                        if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                          BaseObject := TBaseObject(OSObject.CellObj);
                          if (BaseObject <> nil) then begin
                            if (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                              rList.Add(BaseObject);
                            end;
                          end;
                        end;
                      end;
                    end; //for
                  end;
                end;
              end; //Y
            end; //X
          end;
        end;
      DR_RIGHT: begin //东--OK
          for X := m_nCurrX to m_nCurrX + nRage do begin
            for Y := m_nCurrY - 1 to m_nCurrY + 1 do begin
              if m_PEnvir.GetMapCellInfo(X, Y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
                if MapCellInfo.ObjList.Count > 0 then begin //20080629
                  for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                    OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                    if (OSObject <> nil) then begin
                      if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                        BaseObject := TBaseObject(OSObject.CellObj);
                        if (BaseObject <> nil) then begin
                          if (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                            rList.Add(BaseObject);
                          end;
                        end;
                      end;
                    end;
                  end; //for
                end;
              end;
            end; //Y
          end; //X
        end;
      DR_DOWNRIGHT: begin //东南
          for I := 0 to nRage do begin
            x := m_nCurrX + I;
            y := m_nCurrY + I;
            for X := X - 1 to X + 1 do begin
              for Y := Y - 1 to Y + 1 do begin
                if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
                  if MapCellInfo.ObjList.Count > 0 then begin //20080629
                    for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                      OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                      if (OSObject <> nil) then begin
                        if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                          BaseObject := TBaseObject(OSObject.CellObj);
                          if (BaseObject <> nil) then begin
                            if (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                              rList.Add(BaseObject);
                            end;
                          end;
                        end;
                      end;
                    end; //for
                  end;
                end;
              end; //Y
            end; //X
          end;
        end;
      DR_DOWN: begin //南--OK
          for y := m_nCurrY to m_nCurrY + nRage do begin
            for X := m_nCurrX - 1 to m_nCurrX + 1 do begin
              if m_PEnvir.GetMapCellInfo(X, Y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
                if MapCellInfo.ObjList.Count > 0 then begin //20091113 增加
                  for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                    OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                    if (OSObject <> nil) then begin
                      if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                        BaseObject := TBaseObject(OSObject.CellObj);
                        if (BaseObject <> nil) then begin
                          if (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                            rList.Add(BaseObject);
                          end;
                        end;
                      end;
                    end;
                  end;
                end;
              end;
            end; //X
          end; //Y
        end;
      DR_DOWNLEFT: begin //西南向--OK
          for I := 0 to nRage do begin
            x := m_nCurrX - I;
            y := m_nCurrY + I;
            for X := X - 1 to X + 1 do begin
              for Y := Y - 1 to Y + 1 do begin
                if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
                  if MapCellInfo.ObjList.Count > 0 then begin //20080629
                    for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                      OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                      if (OSObject <> nil) then begin
                        if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                          BaseObject := TBaseObject(OSObject.CellObj);
                          if (BaseObject <> nil) then begin
                            if (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                              rList.Add(BaseObject);
                            end;
                          end;
                        end;
                      end;
                    end; //for
                  end;
                end;
              end; //Y
            end; //X
          end;
        end;
      DR_LEFT: begin //西--OK
          for X := m_nCurrX downto m_nCurrX - nRage do begin
            for Y := m_nCurrY - 1 to m_nCurrY + 1 do begin
              if m_PEnvir.GetMapCellInfo(X, Y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
                if MapCellInfo.ObjList.Count > 0 then begin //20080629
                  for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                    OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                    if (OSObject <> nil) then begin
                      if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                        BaseObject := TBaseObject(OSObject.CellObj);
                        if (BaseObject <> nil) then begin
                          if (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                            rList.Add(BaseObject);
                          end;
                        end;
                      end;
                    end;
                  end; //for
                end;
              end;
            end; //Y
          end; //X
        end;
      DR_UPLEFT: begin //西北
          for I := 0 to nRage do begin
            x := m_nCurrX - I;
            y := m_nCurrY - I;
            for X := X - 1 to X + 1 do begin
              for Y := Y - 1 to Y + 1 do begin
                if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
                  if MapCellInfo.ObjList.Count > 0 then begin //20080629
                    for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                      OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                      if (OSObject <> nil) then begin
                        if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                          BaseObject := TBaseObject(OSObject.CellObj);
                          if (BaseObject <> nil) then begin
                            if (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                              rList.Add(BaseObject);
                            end;
                          end;
                        end;
                      end;
                    end; //for
                  end;
                end;
              end; //Y
            end; //X
          end;
        end;
    end;
  except   
    MainOutMessage(format(sExceptionMsg, [g_sExceptionVer]));
  end;
  Result := True;
end;

//取同方向的怪数 疾光电影使用判断怪的数量 20080421

function TBaseObject.GetDirBaseObjectsCount(btDir, nRage: Integer): Integer;
var
  I, III: Integer;
  X, Y: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
resourcestring
  sExceptionMsg = '{%s} TBaseObject::GetDirectionBaseObjects';
begin
  Result := 0;
  if nRage <= 0 then nRage := 1; //20091113 增加
  try
    case btDir of
      DR_UP: begin //北
          for y := m_nCurrY downto m_nCurrY - nRage {m_nCurrY to m_nCurrY + nRage} do begin //20080405
            if m_PEnvir.GetMapCellInfo(m_nCurrX, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin //20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) then begin
                    if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                      BaseObject := TBaseObject(OSObject.CellObj);
                      if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                        Inc(Result);
                      end;
                    end;
                  end;
                end; //for
              end;
            end;
          end;
        end;
      DR_UPRIGHT: begin //东北
          for I := 0 to nRage do begin
            x := m_nCurrX + I;
            y := m_nCurrY - {+} I; //20080404
            if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin //20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) then begin
                    if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                      BaseObject := TBaseObject(OSObject.CellObj);
                      if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                        Inc(Result);
                      end;
                    end;
                  end;
                end; //for
              end;
            end;
          end;
        end;
      DR_RIGHT: begin //东
          for x := m_nCurrX to m_nCurrX + nRage do begin
            if m_PEnvir.GetMapCellInfo(x, m_nCurrY, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin //20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) then begin
                    if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                      BaseObject := TBaseObject(OSObject.CellObj);
                      if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                        Inc(Result);
                      end;
                    end;
                  end;
                end; //for
              end;
            end;
          end;
        end;
      DR_DOWNRIGHT: begin //东南
          for I := 0 to nRage do begin
            x := m_nCurrX + I;
            y := m_nCurrY + {-} I; //20080404
            if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin //20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) then begin
                    if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                      BaseObject := TBaseObject(OSObject.CellObj);
                      if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                        Inc(Result);
                      end;
                    end;
                  end;
                end; //for
              end;
            end;
          end;
        end;
      DR_DOWN: begin //南
          for y := m_nCurrY to m_nCurrY + nRage {m_nCurrY downto m_nCurrY - nRage} do begin //20080405
            if m_PEnvir.GetMapCellInfo(m_nCurrX, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin //20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) then begin
                    if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                      BaseObject := TBaseObject(OSObject.CellObj);
                      if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                        Inc(Result);
                      end;
                    end;
                  end;
                end; //for
              end;
            end;
          end;
        end;
      DR_DOWNLEFT: begin //西南向
          for I := 0 to nRage do begin
            x := m_nCurrX - I;
            y := m_nCurrY + {-} I; //20080405
            if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin //20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) then begin
                    if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                      BaseObject := TBaseObject(OSObject.CellObj);
                      if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                        Inc(Result);
                      end;
                    end;
                  end;
                end; //for
              end;
            end;
          end;
        end;
      DR_LEFT: begin //西
          for x := m_nCurrX downto m_nCurrX - nRage do begin
            if m_PEnvir.GetMapCellInfo(x, m_nCurrY, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin //20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) then begin
                    if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                      BaseObject := TBaseObject(OSObject.CellObj);
                      if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                        Inc(Result);
                      end;
                    end;
                  end;
                end; //for
              end;
            end;
          end;
        end;
      DR_UPLEFT: begin //西北
          for I := 0 to nRage do begin
            x := m_nCurrX - I;
            y := m_nCurrY {+} - I; //20080404
            if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin //20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) then begin
                    if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                      BaseObject := TBaseObject(OSObject.CellObj);
                      if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                        Inc(Result);
                      end;
                    end;
                  end;
                end; //for
              end;
            end;
          end;
        end;
    end;
  except   
    MainOutMessage(format(sExceptionMsg, [g_sExceptionVer]));
  end;
end;

//检查同个方向内一定范围里的怪

function TBaseObject.GetDirectionBaseObjects(btDir, nRage: Integer; rList: TList): Boolean;
var
  I, III: Integer;
  X, Y: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
resourcestring
  sExceptionMsg = '{%s} TBaseObject::GetDirectionBaseObjects';
begin
  Result := False;
  if rList = nil then Exit;
  if nRage <= 0 then nRage := 1; //20091113 增加
  try
    case btDir of
      DR_UP: begin //北
          for y := m_nCurrY - 1 downto m_nCurrY - nRage do begin //20080405
            if m_PEnvir.GetMapCellInfo(m_nCurrX, Y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin //20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) then begin
                    if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                      BaseObject := TBaseObject(OSObject.CellObj);
                      if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                        rList.Add(BaseObject);
                      end;
                    end;
                  end;
                end; //for
              end;
            end;
          end;
        end;
      DR_UPRIGHT: begin //东北
          for I := 1 {0} to nRage do begin
            x := m_nCurrX + I;
            y := m_nCurrY - I; //20080404
            if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin //20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) then begin
                    if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510
                      BaseObject := TBaseObject(OSObject.CellObj);
                      if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                        rList.Add(BaseObject);
                      end;
                    end;
                  end;
                end; //for
              end;
            end;
          end;
        end;
      DR_RIGHT: begin //东
          for x := m_nCurrX + 1 to m_nCurrX + nRage do begin
            if m_PEnvir.GetMapCellInfo(x, m_nCurrY, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin //20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) then begin
                    if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                      BaseObject := TBaseObject(OSObject.CellObj);
                      if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                        rList.Add(BaseObject);
                      end;
                    end;
                  end;
                end; //for
              end;
            end;
          end;
        end;
      DR_DOWNRIGHT: begin //东南
          for I := 1 {0} to nRage do begin
            x := m_nCurrX + I;
            y := m_nCurrY + I; //20080404
            if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin //20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) then begin
                    if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                      BaseObject := TBaseObject(OSObject.CellObj);
                      if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                        rList.Add(BaseObject);
                      end;
                    end;
                  end;
                end; //for
              end;
            end;
          end;
        end;
      DR_DOWN: begin //南
          for y := m_nCurrY + 1 to m_nCurrY + nRage do begin //20080405
            if m_PEnvir.GetMapCellInfo(m_nCurrX, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin //20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) then begin
                    if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                      BaseObject := TBaseObject(OSObject.CellObj);
                      if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                        rList.Add(BaseObject);
                      end;
                    end;
                  end;
                end; //for
              end;
            end;
          end;
        end;
      DR_DOWNLEFT: begin //西南向
          for I := 1 {0} to nRage do begin
            x := m_nCurrX - I;
            y := m_nCurrY + I; //20080405
            if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin //20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) then begin
                    if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                      BaseObject := TBaseObject(OSObject.CellObj);
                      if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                        rList.Add(BaseObject);
                      end;
                    end;
                  end;
                end; //for
              end;
            end;
          end;
        end;
      DR_LEFT: begin //西
          for x := m_nCurrX - 1 downto m_nCurrX - nRage do begin
            if m_PEnvir.GetMapCellInfo(x, m_nCurrY, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin //20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) then begin
                    if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                      BaseObject := TBaseObject(OSObject.CellObj);
                      if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                        rList.Add(BaseObject);
                      end;
                    end;
                  end;
                end; //for
              end;
            end;
          end;
        end;
      DR_UPLEFT: begin //西北
          for I := 1 {0} to nRage do begin
            x := m_nCurrX - I;
            y := m_nCurrY - I; //20080404
            if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin //20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) then begin
                    if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                      BaseObject := TBaseObject(OSObject.CellObj);
                      if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                        rList.Add(BaseObject);
                      end;
                    end;
                  end;
                end; //for
              end;
            end;
          end;
        end;
    end;
  except   
    MainOutMessage(format(sExceptionMsg, [g_sExceptionVer]));
  end;
  Result := True;
end;



//判断人物所在地图坐标1格范围内是否有位置摆摊

function TBaseObject.GetMapCanShop(tEnvir: TEnvirnoment; nX, nY, nRage: Integer): Boolean;
var
  III: Integer;
  x, y, nCount: Integer;
  nStartX, nStartY, nEndX, nEndY: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
resourcestring
  sExceptionMsg = '{%s} TBaseObject::GetMapCanShop';
begin
  Result := False;
  nCount := 0;
  try
    nStartX := nX - nRage;
    nEndX := nX + nRage;
    nStartY := nY - nRage;
    nEndY := nY + nRage;
    for x := nStartX to nEndX do begin
      if nCount > 1 then Break;
      for y := nStartY to nEndY do begin
        if nCount > 1 then Break;
        if tEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
          if MapCellInfo.ObjList.Count > 0 then begin
            for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
              if nCount > 1 then Break;
              OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
              if (OSObject <> nil) then begin
                if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin
                  BaseObject := TBaseObject(OSObject.CellObj);
                  if (BaseObject <> nil) then begin
                    if (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then Inc(nCount);
                  end;
                end;
              end;
            end; //for
          end;
        end;
      end;
    end;
  except   
    MainOutMessage(format(sExceptionMsg, [g_sExceptionVer]));
  end;
  if nCount > 1 then Result := True;
end;

//取地图坐标对角线的怪(辟星斩使用)

function TBaseObject.GetMapBaseObjects_61(tEnvir: TEnvirnoment; nX, nY, nRage: Integer; rList: TList): Boolean;
var
  III, I: Integer;
  x, y: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
resourcestring
  sExceptionMsg = '{%s} TBaseObject::GetMapBaseObjects_61';
begin
  Result := False;
  if rList = nil then Exit;
  try
    for I := 1 to nRage do begin
      //东北向
      x := nX + I;
      y := nY - I;
      if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
        if MapCellInfo.ObjList.Count > 0 then begin
          for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
            OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
            if (OSObject <> nil) then begin
              if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin
                BaseObject := TBaseObject(OSObject.CellObj);
                if (BaseObject <> nil) then begin
                  if (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then rList.Add(BaseObject);
                end;
              end;
            end;
          end; //for
        end;
      end;
      //东南向
      x := nX + I;
      y := nY + I;
      if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
        if MapCellInfo.ObjList.Count > 0 then begin
          for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
            OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
            if (OSObject <> nil) then begin
              if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin
                BaseObject := TBaseObject(OSObject.CellObj);
                if (BaseObject <> nil) then begin
                  if (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then rList.Add(BaseObject);
                end;
              end;
            end;
          end; //for
        end;
      end;
      //西南向
      x := nX - I;
      y := nY + I;
      if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
        if MapCellInfo.ObjList.Count > 0 then begin
          for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
            OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
            if (OSObject <> nil) then begin
              if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin
                BaseObject := TBaseObject(OSObject.CellObj);
                if (BaseObject <> nil) then begin
                  if (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then rList.Add(BaseObject);
                end;
              end;
            end;
          end; //for
        end;
      end;
      //西北向
      x := nX - I;
      y := nY - I;
      if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
        if MapCellInfo.ObjList.Count > 0 then begin
          for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
            OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
            if (OSObject <> nil) then begin
              if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin
                BaseObject := TBaseObject(OSObject.CellObj);
                if (BaseObject <> nil) then begin
                  if (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then rList.Add(BaseObject);
                end;
              end;
            end;
          end; //for
        end;
      end;
    end;
  except   
    MainOutMessage(format(sExceptionMsg, [g_sExceptionVer]));
  end;
  Result := True;
end;

procedure TBaseObject.SendRefMsg(wIdent, wParam: Word; nParam1, nParam2, nParam3: Integer; sMsg: string);
var
  II, nC: Integer;
  nCX, nCY, nLX, nLY, nHX, nHY: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
  btType: Byte;
  nCode: Byte;
  boIsClear: Boolean; //20080915
  boIsShowMode: Boolean; //20090705
resourcestring
  sExceptionMsg = '{%s} TBaseObject::SendRefMsg Name:%s Code:%d';
begin
  nCode := 0;
  boIsClear := False; //20080915
  boIsShowMode := False;
  try
    if (m_PEnvir = nil) then Exit;
    nCode := 1;
    //01/21 增加，原来直接不发信息，如果隐身模式则只发送信息给自己
    if m_boObMode or m_boFixedHideMode then begin
      nCode := 2;
      SendMsg(Self, wIdent, wParam, nParam1, nParam2, nParam3, sMsg);
      Exit;
    end;
    EnterCriticalSection(ProcessMsgCriticalSection);
    nCode := 30;
    try //20090107 增加
      if m_VisibleHumanList <> nil then begin
        nCode := 31;
        if m_VisibleHumanList.Count = 0 then boIsClear := True; //20080915
      end;
    except
    end;
    nCode := 4;
    try
      if ((GetTickCount - m_SendRefMsgTick) >= 500) or boIsClear {(m_VisibleHumanList.Count = 0)} then begin
        m_SendRefMsgTick := GetTickCount();
        nCode := 5;
        try
          m_VisibleHumanList.Clear; //20080819 修改
        except
        end;
        nCode := 6;
        nLX := m_nCurrX - g_Config.nSendRefMsgRange {12};
        nHX := m_nCurrX + g_Config.nSendRefMsgRange {12};
        nLY := m_nCurrY - g_Config.nSendRefMsgRange {12};
        nHY := m_nCurrY + g_Config.nSendRefMsgRange {12};
        nCode := 7;
        for nCX := nLX to nHX do begin
          for nCY := nLY to nHY do begin
            nCode := 8;
            if m_PEnvir.GetMapCellInfo(nCX, nCY, MapCellInfo) then begin
              nCode := 9;
              if MapCellInfo <> nil then begin
                nCode := 203;
                if (MapCellInfo.ObjList <> nil) then begin //20080903 增加
                  nCode := 204;
                  try //20090705 增加
                    if MapCellInfo.ObjList.Count > 0 then boIsShowMode := True;
                  except
                    boIsShowMode := False;
                  end;
                  if boIsShowMode {MapCellInfo.ObjList.Count > 0} then begin //20090705 修改
                    nCode := 200;
                    for II := MapCellInfo.ObjList.Count - 1 downto 0 do begin
                      try //20100218 增加
                        //nCode:= 201;
                        if MapCellInfo.ObjList.Count <= 0 then Break; //20080803 增加
                      except
                        Break;
                      end;
                      nCode := 202;
                      try
                        OSObject := MapCellInfo.ObjList.Items[II];
                      except
                        OSObject := nil; //20090605 增加
                      end;
                      nCode := 110;
                      try //20090805 增加
                        if OSObject <> nil then begin
                          nCode := 111; //20090707 还原
                          try //20080923
                            btType := OSObject.btType;
                          except
                            nCode := 113;
                            if MapCellInfo <> nil then begin
                              if MapCellInfo.ObjList <> nil then begin
                                MapCellInfo.ObjList.Delete(II);
                                if MapCellInfo.ObjList.Count > 0 then Continue;
                                nCode := 114;
                                FreeAndNil(MapCellInfo.ObjList);
                              end;
                            end;
                            break;
                          end;
                          nCode := 112;
                          if not OSObject.boObjectDisPose then begin //20090510 增加
                            if OSObject.btType {btType} = OS_MOVINGOBJECT then begin //20090510 修改
                              if (GetTickCount - OSObject.dwAddTime) >= 60000 {60 * 1000} then begin
                                nCode := 120;
                                if MapCellInfo.ObjList <> nil then MapCellInfo.ObjList.Delete(II); //20080910 修改
                                nCode := 133;
                                if OSObject <> nil then begin
                                  OSObject.boObjectDisPose := True; //20090510 增加
                                  Dispose(OSObject); //20090323
                                end;
                                nCode := 121;
                                if MapCellInfo.ObjList.Count <= 0 then begin
                                  FreeAndNil(MapCellInfo.ObjList);
                                  Break;
                                end;
                              end else begin
                                nCode := 122;
                                try
                                  BaseObject := TBaseObject(OSObject.CellObj);
                                  if (BaseObject <> nil) then begin
                                    nCode := 123;
                                    if (BaseObject.m_PEnvir = m_PEnvir) and (not BaseObject.m_boGhost) then begin
                                      if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
                                        nCode := 124;
                                        if not TPLAYOBJECT(BaseObject).m_boNotOnlineAddExp then begin //20080717 非挂机才增加消息
                                          nCode := 125;
                                          BaseObject.SendMsg(Self, wIdent, wParam, nParam1, nParam2, nParam3, sMsg);
                                          try //20090808 增加
                                            nCode := 126;
                                            if (m_VisibleHumanList <> nil) and (BaseObject <> nil) then m_VisibleHumanList.Add(BaseObject); //20081223 修改
                                          except
                                          end;
                                        end;
                                      end else
                                        if BaseObject.m_boWantRefMsg then begin
                                          nCode := 127;
                                          if (wIdent = RM_STRUCK) or (wIdent = RM_HEAR) or (wIdent = RM_DEATH) or (wIdent = RM_CHARSTATUSCHANGED) then begin //增加分身的魔法盾效果
                                            nCode := 128;
                                            BaseObject.SendMsg(Self, wIdent, wParam, nParam1, nParam2, nParam3, sMsg);
                                            nCode := 129;
                                            if (m_VisibleHumanList <> nil) and (BaseObject <> nil) then m_VisibleHumanList.Add(BaseObject); //20081223 修改
                                            nCode := 130;
                                          end;
                                        end;
                                    end;
                                  end;
                                except
                                  on E: Exception do begin
                                    if MapCellInfo.ObjList <> nil then begin //20090413 增加
                                      MapCellInfo.ObjList.Delete(II);
                                      if MapCellInfo.ObjList.Count <= 0 then begin
                                        FreeAndNil(MapCellInfo.ObjList);
                                      end;
                                    end;
                                    MainOutMessage(Format(sExceptionMsg, [g_sExceptionVer, m_sCharName, nCode]));
                                  end;
                                end;
                              end;
                            end;
                          end;
                        end;
                      except
                      end;
                    end; //for II := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  end; //if MapCellInfo.ObjList.Count > 0 then begin//200080525 增加
                end; //if MapCellInfo.ObjList <> nil then begin
              end; //if MapCellInfo <> nil then begin
            end; //if PEnvir.GetMapCellInfo(nC,n10,MapCellInfo) then begin
          end;
        end;
      end else begin
        nCode := 131;
        if m_VisibleHumanList <> nil then begin //20081201 增加
          nCode := 132;
          if m_VisibleHumanList.Count > 0 then begin //20080627 增加
            nCode := 14;
            for nC := 0 to m_VisibleHumanList.Count - 1 do begin
              nCode := 15;
              try
                BaseObject := TBaseObject(m_VisibleHumanList.Items[nC]);
              except
                BaseObject := nil; //20090705 增加
              end;
              nCode := 150;
              if BaseObject <> nil then begin
                nCode := 151;
                if (BaseObject.m_boGhost) then Continue; //20100815 修改
                nCode := 152;
                if (BaseObject.m_PEnvir = m_PEnvir) and
                  (abs(BaseObject.m_nCurrX - m_nCurrX) < 11) and
                  (abs(BaseObject.m_nCurrY - m_nCurrY) < 11) then begin
                  nCode := 153;
                  if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
                    nCode := 16;
                    if not TPLAYOBJECT(BaseObject).m_boNotOnlineAddExp then //20080717 非挂机才增加消息
                      BaseObject.SendMsg(Self, wIdent, wParam, nParam1, nParam2, nParam3, sMsg);
                  end else
                    if BaseObject.m_boWantRefMsg then begin
                      nCode := 17;
                      if (wIdent = RM_STRUCK) or (wIdent = RM_HEAR) or (wIdent = RM_DEATH) or (wIdent = RM_CHARSTATUSCHANGED) then begin
                        BaseObject.SendMsg(Self, wIdent, wParam, nParam1, nParam2, nParam3, sMsg);
                      end;
                    end; //if BaseObject.m_boWantRefMsg then begin
                end; //if (BaseObject.m_PEnvir = m_PEnvir) and
              end; //if (BaseObject <> nil) then begin
            end; //for nC:= 0 to m_VisibleHumanList.Count - 1 do begin
          end;
        end;
      end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
  except   
    MainOutMessage(format('{%s} TBaseObject::SendRefMsg Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

procedure TBaseObject.UpdateVisibleGay(BaseObject: TBaseObject; nType: byte);
var
  I: Integer;
  VisibleBaseObject, VisibleBaseObject1: pTVisibleBaseObject;
  nCode: Byte;
begin
  try
    nCode := 0;
    VisibleBaseObject1 := nil;//By TasNat at: 2012-11-07 13:13:01
    if BaseObject = nil then Exit; //20081216
    if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or (BaseObject.m_Master <> nil) then m_boIsVisibleActive := True; //如果是人物或宝宝则置TRUE
    if nType = 1 then m_boIsVisibleActive := True;
    nCode := 1;
    if m_VisibleActors.Count > 0 then begin //20091109 增加
      for I := 0 to m_VisibleActors.Count - 1 do begin
        nCode := 2;
        VisibleBaseObject := m_VisibleActors.Items[I];
        nCode := 3;
        if (VisibleBaseObject <> nil) and (BaseObject <> nil) then begin //20090103
          nCode := 4;
          if VisibleBaseObject.BaseObject <> nil then begin //20090318
            nCode := 10;
            if VisibleBaseObject.BaseObject = BaseObject then begin
              nCode := 5;
              VisibleBaseObject.nVisibleFlag := 1;
              if (m_btRaceServer = RC_PLAYOBJECT) then begin //刷新NPC名字(使用全局变量命名时) 20101224
                if ((BaseObject.m_btRaceServer = RC_NPC) and TMerchant(BaseObject).m_boRefreshName)
                  then VisibleBaseObject.nVisibleFlag := 2;
              end;
              Exit; //20080815 增加
            end;
          end;
        end;
      end;
    end;
    try
      nCode := 62;
      New(VisibleBaseObject1);
      VisibleBaseObject1.nVisibleFlag := 2;
      nCode := 7;
      if BaseObject <> nil then begin //20090318
        nCode := 8;
        VisibleBaseObject1.BaseObject := BaseObject;
        nCode := 9;
        m_VisibleActors.Add(VisibleBaseObject1);
      end else begin
        Dispose(VisibleBaseObject1);
        VisibleBaseObject1 := nil;//By TasNat at: 2012-11-07 13:13:11
      end;
    except
      nCode := 6;
      if VisibleBaseObject1 <> nil then Dispose(VisibleBaseObject1); //20090103 加入不成功则防止内存泄露
    end;
  except   
    MainOutMessage(format('{%s} TBaseObject::UpdateVisibleGay Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

procedure TBaseObject.UpdateVisibleItem(wX, wY: Integer; MapItem: PTMapItem);
var
  I: Integer;
  VisibleMapItem: pTVisibleMapItem;
begin
  if m_VisibleItems.Count > 0 then begin //20080629
    for I := 0 to m_VisibleItems.Count - 1 do begin
      VisibleMapItem := m_VisibleItems.Items[I];
      if VisibleMapItem <> nil then begin
        if (VisibleMapItem.MapItem <> nil) and (VisibleMapItem.MapItem = MapItem) then begin
          VisibleMapItem.nVisibleFlag := 1;
          Exit; //20080815 增加
        end;
      end;
    end;
  end;
  New(VisibleMapItem);
  try
    VisibleMapItem.nVisibleFlag := 2;
    VisibleMapItem.nX := wX;
    VisibleMapItem.nY := wY;
    VisibleMapItem.MapItem := MapItem;
    VisibleMapItem.sName := MapItem.Name;
    VisibleMapItem.wLooks := MapItem.Looks;
    m_VisibleItems.Add(VisibleMapItem);
  except
    Dispose(VisibleMapItem); //20090313 增加，防止异常
  end;
end;

procedure TBaseObject.UpdateVisibleEvent(wX, wY: Integer; MapEvent: TObject);
var
  I: Integer;
  Event: TEvent;
begin
  if m_VisibleEvents.Count > 0 then begin //20091109 增加
    for i := 0 to m_VisibleEvents.Count - 1 do begin
      Event := m_VisibleEvents.Items[i];
      if Event <> nil then begin
        if Event = MapEvent then begin
          Event.nVisibleFlag := 1;
          Exit;
        end;
      end;
    end;
  end;
  TEvent(MapEvent).nVisibleFlag := 2;
  TEvent(MapEvent).m_nX := wX;
  TEvent(MapEvent).m_nY := wY;
  m_VisibleEvents.Add(MapEvent);
end;

//搜索查看范围

procedure TBaseObject.SearchViewRange;
var
  I: Integer;
  nStartX: Integer;
  nEndX: Integer;
  nStartY: Integer;
  nEndY: Integer;
  n18: Integer;
  n1C: Integer;
  nIdx: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
  MapItem: PTMapItem;
  //MapEvent: TEvent;
  VisibleBaseObject: pTVisibleBaseObject;
  VisibleMapItem: pTVisibleMapItem;
  nCheckCode: Byte;
  //btType: Byte;//20090510 注释
  nVisibleFlag: {Integer} Byte; //20090823 修改为Byte
  dwRunTick: LongWord; //20091103 测试
begin
  try
    if m_PEnvir = nil then begin
      KickException(); //20081226 地图不存在，则踢出角色
      Exit;
    end;
    nCheckCode := 1;
    m_boIsVisibleActive := False; //先置为FALSE

    if m_VisibleItems.Count > 0 then begin //20080629
      for I := 0 to m_VisibleItems.Count - 1 do begin
        try //20090515 增加
          VisibleMapItem := pTVisibleMapItem(m_VisibleItems.Items[I]); //20080526 增加
          if VisibleMapItem <> nil then VisibleMapItem.nVisibleFlag := 0; //20080526 增加
        except
          m_VisibleItems.Delete(I); //20091101 增加
        end;
      end;
    end;
  except //  
    //MainOutMessage(Format('{异常} TBaseObject::SearchViewRange Code:%d', [nCheckCode]));
    KickException();
  end;
  (*nCheckCode := 2;
  try //20090822 第三次循环直接初始为0
    if m_VisibleActors.Count > 0 then begin//20080629
      for I := 0 to m_VisibleActors.Count - 1 do begin
        VisibleBaseObject:= pTVisibleBaseObject(m_VisibleActors.Items[I]); //20080526 增加
        if VisibleBaseObject <> nil then VisibleBaseObject.nVisibleFlag := 0;//20080526 增加
      end;
    end;
  except   
    MainOutMessage(Format('{异常} TBaseObject::SearchViewRange Code:%d', [nCheckCode]));
    KickException();
  end;*)
  try
    nStartX := m_nCurrX - m_nViewRange;
    nEndX := m_nCurrX + m_nViewRange;
    nStartY := m_nCurrY - m_nViewRange;
    nEndY := m_nCurrY + m_nViewRange;

    dwRunTick := GetTickCount(); //20091103 测试用
    nCheckCode := 3;
    for n18 := nStartX to nEndX do begin
      for n1C := nStartY to nEndY do begin
        nCheckCode := 4;
        if m_PEnvir.GetMapCellInfo(n18, n1C, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
          nCheckCode := 5;
          nIdx := 0;
          while (True) do begin
            if ((GetTickCount - dwRunTick) > 500) then Break; //超时则退出循环(测试) 20091103
            nCheckCode := 53;
            if (MapCellInfo.ObjList <> nil) and (MapCellInfo.ObjList.Count <= 0) then begin //20100614 增加
              nCheckCode := 153;
              try
              FreeAndNil(MapCellInfo.ObjList);
              except
                MainOutMessage(IntToHex(Cardinal(MapCellInfo), 8));
              end;
              Break;
            end;
            try //200908705 增加
              if MapCellInfo.ObjList.Count <= nIdx then Break;
            except
              Break;
            end;
            nCheckCode := 54;
            try
              OSObject := MapCellInfo.ObjList.Items[nIdx];
            except
              //OSObject:= nil;//20090705 增加
              MapCellInfo.ObjList.Delete(nIdx); //20101103 修改
              Continue;
            end;
            nCheckCode := 51;
            if OSObject <> nil then begin
              nCheckCode := 6;
              if not OSObject.boObjectDisPose then begin
                case OSObject.btType of
                  OS_MOVINGOBJECT: begin
                      nCheckCode := 61;
                      if (GetTickCount - OSObject.dwAddTime) >= 60000 then begin
                        try //20090510 修改
                          if OSObject <> nil then begin
                            OSObject.boObjectDisPose := True; //20090510 增加
                            nCheckCode := 62;
                            Dispose(OSObject); //20090325
                          end;
                        except
                        end;
                        nCheckCode := 63;
                        if MapCellInfo.ObjList <> nil then begin //20090403 增加
                          try //20090801 增加
                            MapCellInfo.ObjList.Delete(nIdx); //20080916 修改
                            if MapCellInfo.ObjList.Count > 0 then Continue; //20080916 修改
                            FreeAndNil(MapCellInfo.ObjList);
                          except
                          end;
                        end;
                        Break;
                      end;
                      nCheckCode := 64;
                      BaseObject := TBaseObject(OSObject.CellObj);
                      if BaseObject <> nil then begin
                        if (not BaseObject.m_boGhost) and (not BaseObject.m_boFixedHideMode) and (not BaseObject.m_boObMode) then begin
                          if (m_btRaceServer < RC_ANIMAL) or (m_Master <> nil) or m_boCrazyMode or m_boWantRefMsg or
                            ((BaseObject.m_Master <> nil) and (abs(BaseObject.m_nCurrX - m_nCurrX) <= 3) and (abs(BaseObject.m_nCurrY - m_nCurrY) <= 3)) or
                            ((m_btRaceServer in [115, 151]) and (BaseObject.m_Master <> nil) and (abs(BaseObject.m_nCurrX - m_nCurrX) <= 5) and (abs(BaseObject.m_nCurrY - m_nCurrY) <= 5)) or //20090925 由3格变5格(修正,赤月恶魔3格后,就不能攻击英雄) 2010614修改，只针对115怪，搜索5格内的目标
                            (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or (BaseObject.m_btRaceServer = RC_HEROOBJECT) then begin //20091128 增加英雄
                            nCheckCode := 65;
                            UpdateVisibleGay(BaseObject, 0);
                          end else
                            if (m_btRaceServer = RC_PLAYMOSTER) and (m_Master = nil) and (BaseObject.m_btRaceServer <> RC_PLAYMOSTER) then begin //人形怪攻击指定类型的目标
                              if (TPlayMonster(self).TargetList <> nil) then begin
                                if TPlayMonster(self).TargetList.IndexOf(BaseObject.m_sCharName) > -1 then UpdateVisibleGay(BaseObject, 1);
                              end;
                            end;
                        end;
                      end;
                    end;
                  OS_ITEMOBJECT: begin //分身，英雄搜索地面物品
                      nCheckCode := 66;
                      if ((m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT)) and (m_Master <> nil) and (m_nCopyHumanLevel > 0) and (g_AllowPickUpItemList.Count > 0) then begin //20100614 移动位置
                        if ((GetTickCount - OSObject.dwAddTime) > g_Config.dwClearDropOnFloorItemTime) or
                          ((PTMapItem(OSObject.CellObj).UserItem.AddValue[0] = 1) and
                          (GetHoursCount(PTMapItem(OSObject.CellObj).UserItem.MaxDate, Now) <= 0)) then begin
                          nCheckCode := 67;
                          if PTMapItem(OSObject.CellObj) <> nil then begin
                            //DisPoseAndNil(PTMapItem(OSObject.CellObj)); //防止占用内存不释放现象 20080702 修改
                            DisPose(PTMapItem(OSObject.CellObj));//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 这里就有 By TasNat at: 2012-03-17 17:47:42
                            PTMapItem(OSObject.CellObj):= nil;

                          end;
                          try //20090504 增加
                            if (OSObject <> nil) then begin
                              OSObject.boObjectDisPose := True; //20090510 增加
                              Dispose(OSObject); //20090107 修改
                            end;
                          except
                          end;
                          MapCellInfo.ObjList.Delete(nIdx);
                          if MapCellInfo.ObjList.Count > 0 then Continue; //20080916 增加
                          nCheckCode := 68;
                          FreeAndNil(MapCellInfo.ObjList);
                          Break;
                        end;
                      //if ((m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT)) and (m_Master <> nil) and (m_nCopyHumanLevel > 0) and (g_AllowPickUpItemList.Count > 0) then begin
                        nCheckCode := 69;
                        MapItem := PTMapItem(OSObject.CellObj);
                        if IsAllowPickUpItem(MapItem.Name) then begin //是允许捡的物品才更新列表 20100614
                          nCheckCode := 70;
                          UpdateVisibleItem(n18, n1C, MapItem);
                          if (MapItem.OfBaseObject <> nil) or (MapItem.DropBaseObject <> nil) then begin
                            nCheckCode := 71;
                            if (GetTickCount - MapItem.dwCanPickUpTick) > g_Config.dwFloorItemCanPickUpTime {2 * 60 * 1000} then begin
                              MapItem.OfBaseObject := nil;
                              MapItem.DropBaseObject := nil;
                            end else begin
                              if TBaseObject(MapItem.OfBaseObject) <> nil then begin
                                if TBaseObject(MapItem.OfBaseObject).m_boGhost then MapItem.OfBaseObject := nil;
                              end;
                              if TBaseObject(MapItem.DropBaseObject) <> nil then begin
                                if TBaseObject(MapItem.DropBaseObject).m_boGhost then MapItem.DropBaseObject := nil;
                              end;
                            end;
                          end;
                        end;
                      end;
                    end;
                end; //case
              end;
            end;
            Inc(nIdx);
          end;
        end;
      end;
    end;
  except
    on E: Exception do begin
      //MainOutMessage(Format('{异常} TBaseObject::SearchViewRange %s %s %d %d %d', [m_sCharName, m_sMapName, m_nCurrX, m_nCurrY, nCheckCode]));
      KickException();
    end;
  end;

  try
    nCheckCode := 15;
    //英雄，分身搜索地面物品
    if ((m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT)) and (m_Master <> nil) and (m_nCopyHumanLevel > 0) and (g_AllowPickUpItemList.Count > 0) then begin //20090808 修改
      n18 := 0;
      while (True) do begin
        try //20101126 防止死循环
          if m_VisibleItems.Count <= n18 then Break;
          nCheckCode := 16;
          try //20080901
            VisibleMapItem := m_VisibleItems.Items[n18];
            nCheckCode := 17;
            if VisibleMapItem = nil then begin //20080526 增加
              m_VisibleItems.Delete(n18); //20080901
              if m_VisibleItems.Count > 0 then Continue; //20091102 修改
              Break; //20091102
            end;
            nCheckCode := 18;
            nVisibleFlag := VisibleMapItem.nVisibleFlag;
          except
            m_VisibleItems.Delete(n18);
            if m_VisibleItems.Count > 0 then Continue; //20090430 修改
            Break; //20090430 增加
          end;

          if {VisibleMapItem.nVisibleFlag} nVisibleFlag = 0 then begin //20080901 修改
            nCheckCode := 19;
            m_VisibleItems.Delete(n18);
            nCheckCode := 20;
            try //20090515 增加
              if VisibleMapItem <> nil then
              //DisPoseAndNil(VisibleMapItem); //20090103 修改
              DisPose(VisibleMapItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 这里就有...By TasNat at: 2012-03-17 17:47:42
              VisibleMapItem:= nil;
            except
            end;
            nCheckCode := 28;
            if m_VisibleItems.Count > 0 then Continue; //20090430 修改
            Break; //20090430 增加
          end;
        except
          Break;
        end;
        Inc(n18);
      end;
    end;

    nCheckCode := 21;
    n18 := 0;
    while (True) do begin
      try //20101126 防止死循环
        if m_VisibleActors.Count <= n18 then Break;
        nCheckCode := 22;
        try //20080901
          VisibleBaseObject := m_VisibleActors.Items[n18];
          nCheckCode := 23;
          if VisibleBaseObject = nil then begin //20080526 增加
            m_VisibleActors.Delete(n18); //20080901
            if m_VisibleActors.Count > 0 then Continue; //20091102 修改
            Break; //20091102
          end;
          nCheckCode := 24;
          nVisibleFlag := VisibleBaseObject.nVisibleFlag;
        except
          nCheckCode := 28;
          m_VisibleActors.Delete(n18);
          if m_VisibleActors.Count > 0 then Continue; //20090430 修改
          Break; //20090430 增加
        end;

        if {VisibleBaseObject.nVisibleFlag} nVisibleFlag = 0 then begin //20080901 修改
          nCheckCode := 25;
          m_VisibleActors.Delete(n18);
          try //20090510 修改
            nCheckCode := 26;
            if VisibleBaseObject <> nil then Dispose(VisibleBaseObject); //20090103 修改
          except
          end;
          nCheckCode := 27;
          if m_VisibleActors.Count > 0 then Continue; //20090430 修改
          Break; //20090430 增加
        end else begin //不为0的，全初始为0 20090822
          VisibleBaseObject.nVisibleFlag := 0;
        end;
      except
        Break;
      end;
      Inc(n18);
    end;
  except
    on E: Exception do begin
      //MainOutMessage(Format('{异常} TBaseObject::SearchViewRange %s %s %d %d %d', [m_sCharName, m_sMapName, m_nCurrX, m_nCurrY, nCheckCode]));
      KickException();
    end;
  end;
end;

//取着装效果

function TBaseObject.GetFeatureEx(): Word;
begin
  if m_boOnHorse then begin //骑马
    Result := MakeWord(m_btHorseType, m_btDressEffType);
  end else begin
    Result := MakeWord(0, m_btDressEffType);
  end;
end;
//取外观
//修改为动态长度By TasNat at:2012-11-22 13:29:02
function TBaseObject.GetFeature(var fResult : TFeatures): Integer;
var
  nDress, nWeapon, nHair, nStatus, nRaceImg, nAppr, nNPCAppr: Integer;
  StdItem: pTStdItem;
  bo25: Boolean;
  sStr: string;
  nCode: Byte; //20110719
  EffecItem: pTEffecItem;
begin
  try
    FillChar(fResult, SizeOf(fResult), #0);
    nStatus := 0;
    Result := 8;
    fResult.nDressLook := 65535; //衣服外观特效
    fResult.nWeaponLook := 65535; //武器外观特效
    nCode := 0;
    if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin
      nDress := 0;
      nCode := 1;
      //衣服
      if m_UseItems[U_DRESS].wIndex > 0 then begin
        StdItem := UserEngine.GetStdItem(m_UseItems[U_DRESS].wIndex);
        if StdItem <> nil then begin
          nDress := StdItem.Shape * 2;
          if StdItem.Anicount <> 50 then begin
            EffecItem := GetEffecItemList(StdItem.Name); //取物品特效
            if EffecItem <> nil then begin
              fResult.nDressLook := EffecItem.wLookIndex; //衣服外观特效
              fResult.nDressLookWil := EffecItem.btLookWilIndex; //衣服外观WIL索引
            end;
            Result := 11;
          end;
        end;
      end;
      Inc(nDress, m_btGender);
      nCode := 2;
      nWeapon := 0;
      //武器
      if m_UseItems[U_WEAPON].wIndex > 0 then begin
        StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
        if StdItem <> nil then begin
          nWeapon := StdItem.Shape * 2;
          EffecItem := GetEffecItemList(StdItem.Name); //取物品特效
          if EffecItem <> nil then begin
            fResult.nWeaponLook := EffecItem.wLookIndex; //武器外观特效
            fResult.nWeaponLookWil := EffecItem.btLookWilIndex; //武器外观WIL索引
          end;
          Result := 14;
        end;
      end;
      Inc(nWeapon, m_btGender);
      nCode := 3;
      //斗笠 20080417
      if m_UseItems[U_ZHULI].wIndex > 0 then begin
        StdItem := UserEngine.GetStdItem(m_UseItems[U_ZHULI].wIndex);
        if StdItem <> nil then begin
          case StdItem.Shape of
            0: nHair := High(Byte); //普通斗笠
            1: nHair := 254; //王者斗笠
            2: nHair := m_btHair * 2 + m_btGender; //黑巾 20090331
            3: nHair := 253; //必杀斗笠
            4: nHair := 252; //金牛斗笠
            5: nHair := 251; //主宰斗笠
            6: nHair := 250; //传奇斗笠
            7: nHair := 249; //皓月斗笠
          end;
        end else nHair := m_btHair * 2 + m_btGender;
      end else nHair := m_btHair * 2 + m_btGender;

      if m_boMagicShield or m_boMagicShield1 or m_boMagicShield2 then
        nStatus := 1;

      nCode := 4;
      case m_btRaceServer of //20110213 修改
        RC_PLAYOBJECT: begin
          //Result := MakeHumanFeature(RC_PLAYOBJECT, nDress, nWeapon, nHair);
            fResult.nDress := nDress;
            fResult.nWeapon := nWeapon;
            fResult.btHair := nHair;
            fResult.btStatus := nStatus;
            fResult.nRaceImg := RC_PLAYOBJECT; //角色类型
            //Features.nAppr := 0; //怪使用
          end;
        RC_PLAYMOSTER: begin
          //Result := MakeHumanFeature(RC_PLAYMOSTER, nDress, nWeapon, nHair);
            fResult.nDress := nDress;
            fResult.nWeapon := nWeapon;
            fResult.btHair := nHair;
            fResult.btStatus := nStatus;
            fResult.nRaceImg := RC_PLAYMOSTER; //角色类型
            //Features.nAppr := 0; //怪使用
          end;
        RC_HEROOBJECT: begin
          //Result := MakeHumanFeature(1, nDress, nWeapon, nHair);
            fResult.nDress := nDress;
            fResult.nWeapon := nWeapon;
            fResult.btHair := nHair;
            fResult.btStatus := nStatus;
            fResult.nRaceImg := 1; //角色类型
            //Features.nAppr := 0; //怪使用
          end;
      end;
      Exit;
    end;
    nCode := 5;
    {bo25 := False;注释掉 无用 By TasNat at: 2012-04-01 12:59:15
    if (BaseObject <> nil) and (BaseObject.bo245) then bo25 := True;
    nCode := 6;
    if bo25 then begin
      nRaceImg := m_btRaceImg;
      nAppr := m_wAppr;
      case nAppr of
        0: begin
            nRaceImg := 12;
            nAppr := 5;
          end;
        1: begin
            nRaceImg := 11;
            nAppr := 9;
          end;
        160: begin
            nRaceImg := 10;
            nAppr := 0;
          end;
        161: begin
            nRaceImg := 10;
            nAppr := 1;
          end;
        162: begin
            nRaceImg := 11;
            nAppr := 6;
          end;
        163: begin
            nRaceImg := 11;
            nAppr := 3;
          end;
      end; //case
      nCode := 7;
      //Result := MakeMonsterFeature(nRaceImg, m_btMonsterWeapon, nAppr);
      Features.nDress := 0;
      Features.nWeapon := m_btMonsterWeapon;
      Features.btHair := 0;
      Features.btStatus := 0;
      Features.nRaceImg := nRaceImg; //角色类型
      Features.nAppr := nAppr; //怪使用
      Result := Features;
      Exit;
    end;   }
    nCode := 8;
    if (m_btRaceServer = RC_NPC) then begin //NPC 变量外观 20110512
      nCode := 19;
      sStr := TNormNpc(self).m_sRefresAppr;
      nCode := 20;
      if sStr <> '' then begin
        nCode := 21;
        nAppr := GetValNameNo(sStr);
        nCode := 22;
        case nAppr of
          100..199: begin //G变量
              nCode := 12;
              nNPCAppr := g_Config.GlobalVal[nAppr - 100];
              nCode := 13;
              if nNPCAppr > High(m_wAppr) then m_wAppr := 0
              else m_wAppr := nNPCAppr;
            end;
          800..1199: begin
              nCode := 14;
              nNPCAppr := g_Config.GlobalVal[nAppr - 700];
              nCode := 15;
              if nNPCAppr > High(m_wAppr) then m_wAppr := 0
              else m_wAppr := nNPCAppr;
            end;
          2100..2599: begin //G变量(500-999)
              nCode := 16;
              nNPCAppr := g_Config.GlobalVal[nAppr - 1600];
              nCode := 17;
              if nNPCAppr > High(m_wAppr) then m_wAppr := 0
              else m_wAppr := nNPCAppr;
            end;
          //else m_wAppr := 0;
        end;
      end;
    end;
    nCode := 18;
    //Result := MakeMonsterFeature(m_btRaceImg, m_btMonsterWeapon, m_wAppr);
    fResult.nDress := m_wAppr;
    fResult.nWeapon := m_btMonsterWeapon;
    fResult.nRaceImg := m_btRaceImg; //角色类型
    //Features.nAppr := m_wAppr; //怪使用
    Result := 6;
  except   
    MainOutMessage(format('{%s} TBaseObject.GetFeature Code:%d', [g_sExceptionVer, nCode]));
  end;
end;
{各状态表示，客户端使用检查人物状态，例：m_nState and $80000000 <> 0  是否中绿毒
 10000000000000000000000000000000---0绿毒状态         $80000000
 1000000000000000000000000000000----1红毒状态         $40000000
 100000000000000000000000000000-----2状态(无)         $20000000
 10000000000000000000000000000------3中蛛网状态       $10000000
 1000000000000000000000000000-------4状态(无)         $08000000
 100000000000000000000000000--------5麻痹状态         $04000000
 10000000000000000000000000---------6万剑归宗击中状态 $02000000
 1000000000000000000000000----------7冰冻状态         $01000000
 100000000000000000000000-----------8隐身状态         $00800000
 10000000000000000000000------------9神圣战甲术状态   $00400000
 1000000000000000000000------------10幽灵盾状态       $00200000
 100000000000000000000-------------11魔法盾状态       $00100000
 10000000000000000000--------------12唯我独尊状态     $00080000
 1000000000000000000---------------13粉红魔法盾       $00040000
 100000000000000000----------------14龙卫状态         $00020000
 10000000000000000-----------------15减速状态         $00010000
 1000000000000000------------------16吟唱状态         $00008000
 100000000000000-------------------17定身状态         $00004000}
//取当前状态值

function TBaseObject.GetCharStatus(): Integer;
var
  I, nStatus: Integer;
begin
  try
    nStatus := 0;
    for I := Low(TStatusTime) to High(TStatusTime) do begin
      if I = POISON_DONTMOVE then Continue; //不能移动，中战连击,不处理状态值 20090904
      if m_wStatusTimeArr[I] > 0 then begin
        case I of
          2: nStatus := ($80000000 shr 12) or nStatus; //唯我独尊效果
{$IF M2Version <> 2}
          11: begin //魔法盾
              if (m_btRaceServer = RC_PLAYOBJECT) then begin
                if TPlayObject(Self).m_boFengHaoMagicEffect then begin //魔法粉红效果(传奇之星)
                  nStatus := ($80000000 shr 13) or nStatus;
                end else nStatus := ($80000000 shr I) or nStatus;
              end else nStatus := ($80000000 shr I) or nStatus;
            end
{$IFEND}
        else nStatus := ($80000000 shr I) or nStatus;
        end;
  (* $80000000 指十六进制值，转成二进制则为10000000000000000000000000000000  然后Shr右移
     例：I为3,右移3位，得到二进制值：10000000000000000000000000000
         I为6,右移6位，得到二进制值: 10000000000000000000000000
     or 代表运算, 需要两个运算数，即两个数的位运算，只有其中一个是1就返回1; 都是0才返回0
     and 表示 当对应位均为1时返回1，其余为0
     从上面算法得到，最终 nStatus得到是1,*)
      end;
    end;
{$IF M2Version <> 2}
    if (m_btRaceServer = RC_PLAYOBJECT) then begin
      if ((TPlayObject(Self).m_boHeartActive) and (TPlayObject(Self).m_MagicSkill_105 <> nil)) or
        ((m_wStatusArrValue[21] > 0) and (TPlayObject(Self).m_MagicSkill_106 <> nil) and (TPlayObject(Self).m_MyDivision <> nil)) then begin //龙卫状态
        nStatus := ($80000000 shr 14) or nStatus;
      end;
    end;
{$IFEND}
    if (m_wStatusArrValue[22] > 0) then begin //减速状态
      nStatus := ($80000000 shr 15) or nStatus;
    end;
{$IF M2Version <> 2}
    if (m_btRaceServer = RC_PLAYOBJECT) then begin
      if ((TPlayObject(Self).m_SkillHit_113 > 0) and (TPlayObject(Self).m_MagicSkill_113 <> nil)) then begin //吟唱状态
        nStatus := ($80000000 shr 16) or nStatus;
      end;
    end;
{$IFEND}
    if (m_wStatusArrValue[23] > 0) then begin //定身状态
      nStatus := ($80000000 shr 17) or nStatus;
    end;
    Result := (m_nCharStatusEx and $FFFFF) or nStatus; //and or 都为二进制的位运算
    {按位算  1 and 1 = 1
             0 and 0 = 0
             0 and 1 = 0}
  except   
    MainOutMessage(format('{%s} TBaseObject.GetCharStatus', [g_sExceptionVer]));
  end;
end;

procedure TBaseObject.AbilCopyToWAbil;
begin
  m_WAbil := m_Abil;
end;

//初始化魔法,加入地图等操作

procedure TBaseObject.Initialize;
var
  I: Integer;
  UserMagic: pTUserMagic;
begin
  AbilCopyToWAbil();
  case m_btRaceServer of
    RC_PLAYOBJECT: begin
        if m_MagicList.Count > 0 then begin
          for I := 0 to m_MagicList.Count - 1 do begin
            UserMagic := m_MagicList.Items[I];
            if (UserMagic.btLevel > 3) then begin
              case UserMagic.wMagIdx of
                SKILL_FIRECHARM, SKILL_FIRESWORD, SKILL_45, SKILL_66, SKILL_88..SKILL_94: if UserMagic.btLevel > 4 then UserMagic.btLevel := 4;
                SKILL_68: if UserMagic.btLevel > 100 then UserMagic.btLevel := 100;
                SKILL_71: if UserMagic.btLevel > 99 then UserMagic.btLevel := 99;
                SKILL_76..SKILL_87: if UserMagic.btLevel > 5 then UserMagic.btLevel := 5; //连击技能最高5级
                SKILL_95: begin
{$IF M2Version = 1}
                    if TPLAYOBJECT(self).m_boOpenupSkill95 then begin
                      if UserMagic.btLevel > 99 then UserMagic.btLevel := 99;
                    end else {$IFEND}
                      if UserMagic.btLevel > 64 then UserMagic.btLevel := 64; //斗转星移最高64级
                  end;
                SKILL_100: if UserMagic.btLevel > 15 then UserMagic.btLevel := 15;
                SKILL_104: if UserMagic.btLevel > 100 then UserMagic.btLevel := 100;
{$IF M2Version <> 2}
                SKILL_105: if UserMagic.btLevel > 100 then UserMagic.btLevel := 100;
                SKILL_106, SKILL_107, SKILL_108, SKILL_109, SKILL_110, SKILL_111,
                  SKILL_112, SKILL_113, SKILL_114: if UserMagic.btLevel > 9 then UserMagic.btLevel := 9;
                SKILL_200, Skill_202, Skill_236, Skill_204, Skill_206, Skill_239, Skill_230,
                  Skill_232, Skill_241, Skill_228, Skill_234, Skill_208, Skill_214, Skill_218,
                  Skill_222, Skill_210, Skill_212, Skill_216, Skill_224, Skill_226, Skill_220: begin
                    if UserMagic.btLevel > g_Config.nNGSkillMaxLevel then UserMagic.btLevel := g_Config.nNGSkillMaxLevel;
                  end;
{$IFEND}
              else UserMagic.btLevel := 0;
              end;
            end;
          end;
        end;
      end;
    RC_PLAYMOSTER: begin //20080417 英雄分身可以有4级技能
        if m_MagicList.Count > 0 then begin //20080629
          for I := 0 to m_MagicList.Count - 1 do begin
            UserMagic := m_MagicList.Items[I];
            if UserMagic.wMagIdx in [SKILL_76..SKILL_87] then Continue; //连击技能继续
            if (m_Master <> nil) and (m_Master.m_btRaceServer = RC_HEROOBJECT) then
              if UserMagic.btLevel > 4 then UserMagic.btLevel := 0
              else
                if UserMagic.btLevel > 3 then begin
                  case UserMagic.wMagIdx of
                    SKILL_FIRECHARM, SKILL_FIRESWORD, SKILL_45, 66, 88..94: if UserMagic.btLevel > 4 then UserMagic.btLevel := 4;
                  else UserMagic.btLevel := 0;
                  end;
                end;
          end; //for
        end;
      end;
    RC_HEROOBJECT: begin //20080320 英雄可以有4级技能
        if m_MagicList.Count > 0 then begin //20080629
          for I := 0 to m_MagicList.Count - 1 do begin
            UserMagic := m_MagicList.Items[I];
            if (UserMagic.btLevel > 4) then begin
              case UserMagic.wMagIdx of
                SKILL_66, SKILL_60..SKILL_65, SKILL_88..SKILL_94: UserMagic.btLevel := 4; //四级合击技能 20100719
                SKILL_68: if UserMagic.btLevel > 100 then UserMagic.btLevel := 100; //酒气护体
                SKILL_71, SKILL_99: if UserMagic.btLevel > 99 then UserMagic.btLevel := 99; //召唤圣兽,强身术
                SKILL_76..SKILL_87: if UserMagic.btLevel > 5 then UserMagic.btLevel := 5; //连击技能最高5级
                SKILL_95: begin
{$IF M2Version = 1}
                    if THEROOBJECT(self).m_boOpenupSkill95 then begin
                      if UserMagic.btLevel > 99 then UserMagic.btLevel := 99;
                    end else {$IFEND}
                      if UserMagic.btLevel > 64 then UserMagic.btLevel := 64; //斗转星移最高64级
                  end;
                SKILL_104: if UserMagic.btLevel > 100 then UserMagic.btLevel := 100;
{$IF M2Version <> 2} //怒之技能不能超过等级上限
                SKILL_200, Skill_202, Skill_236, Skill_204, Skill_206, Skill_239, Skill_230,
                  Skill_232, Skill_241, Skill_228, Skill_234, Skill_208, Skill_214, Skill_218,
                  Skill_222, Skill_210, Skill_212, Skill_216, Skill_224, Skill_226, Skill_220: begin
                    if UserMagic.btLevel > g_Config.nNGSkillMaxLevel then UserMagic.btLevel := g_Config.nNGSkillMaxLevel;
                  end;
{$IFEND}
              else UserMagic.btLevel := 0;
              end;
            end;
          end;
        end;
      end;
  end; //case
  m_boAddtoMapSuccess := True;
  if m_PEnvir.CanWalk(m_nCurrX, m_nCurrY, True) and AddToMap() then m_boAddtoMapSuccess := False;
  m_nCharStatus := GetCharStatus();
  AddBodyLuck(0);
  LoadSayMsg();
  if g_Config.boMonSayMsg then MonsterSayMsg(nil, s_MonGen);
end;
//==============================
//取得怪物说话信息列表

procedure TBaseObject.LoadSayMsg();
var
  I: Integer;
begin
  if g_MonSayMsgList.Count > 0 then begin //20080629
    if (m_btRaceServer <> RC_HEROOBJECT) and (m_btRaceServer <> RC_PLAYOBJECT) then begin //20090217 防止怪物名与英雄或主体一致时，出错
      for I := 0 to g_MonSayMsgList.Count - 1 do begin
        if CompareText(g_MonSayMsgList.Strings[I], m_sCharName) = 0 then begin
          m_SayMsgList := TList(g_MonSayMsgList.Objects[I]);
          Break;
        end;
      end;
    end;
  end;
end;

procedure TBaseObject.Disappear();
begin

end;
//着装效果改变

procedure TBaseObject.FeatureChanged;
var
  feature: TFeatures;
  nLen : Integer;//动态大小By TasNat at:2012-11-22 14:43:42
begin
  nLen := GetFeature(feature);
  SendRefMsg(RM_FEATURECHANGED, GetFeatureEx, nLen, 0, 0, EncodeBuffer(@feature, nLen));
end;
//状态改变 20080811 修改

procedure TBaseObject.StatusChanged(Str: string);
begin
  SendRefMsg(RM_CHARSTATUSCHANGED, m_nHitSpeed, m_nCharStatus, abs(m_nRunSpeed), 0, Str);
end;

procedure TBaseObject.DisappearA();
var
  FlowerEvent: TFlowerEvent;
begin
{$IF HEROVERSION = 1}
  try //20100122 增加
    if (m_btRaceServer = RC_HEROOBJECT) and (m_Master <> nil) then begin //20080403 英雄尸体消失后,左上角英雄窗口才消失
      if (not TPlayObject(m_Master).m_boReconnection) and (not TPlayObject(m_Master).m_boSoftClose) and (not THeroObject(self).boCallLogOut) then begin //20080425 主人不是小退时才显示动画
        if TPlayObject(m_Master).m_sDeputyHeroName <> '' then begin
          if TPlayObject(m_Master).m_boCallDeputyHero then begin //副将英雄死亡
            TPlayObject(m_Master).m_boCallDeputyHero := False;
            TPlayObject(m_Master).m_nRecallDeputyHeroTime := GetTickCount();
          end else TPlayObject(m_Master).m_nRecallHeroTime := GetTickCount(); //召唤主将英雄间隔
        end else TPlayObject(m_Master).m_nRecallHeroTime := GetTickCount(); //召唤英雄间隔
        FlowerEvent := TFlowerEvent.Create(m_PEnvir, m_nCurrX, m_nCurrY, SM_HEROLOGOUT, 3000); //英雄退出动画显示
        g_EventManager.AddEvent(FlowerEvent);
      end;
      m_Master.SendMsg(m_Master, RM_HERODEATH, 0, 0, 0, 0, '');
      m_Master := nil;
    end;
  except
  end;
{$IFEND}
  m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
  SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, '');
end;
//踢除异常角色

procedure TBaseObject.KickException;
var
  PlayObject: TPlayObject;
begin
  try
    if m_btRaceServer = RC_PLAYOBJECT then begin
      m_sMapName := g_Config.sHomeMap;
      m_nCurrX := g_Config.nHomeX;
      m_nCurrY := g_Config.nHomeY;
      PlayObject := TPlayObject(Self);
      PlayObject.m_boEmergencyClose := True;
      PlayObject.m_boNotOnlineAddExp := False;
      PlayObject.m_boPlayOffLine := False; //关闭下线触发
    end else begin
      m_boDeath := True;
      m_dwDeathTick := GetTickCount;
      MakeGhost;
    end;
  except   
    MainOutMessage(format('{%s} TBaseObject.KickException', [g_sExceptionVer]));
  end;
end;

function TBaseObject.Walk(nIdent: Integer): Boolean;
var
  I: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  GateObj: pTGateObj;
  bo1D: Boolean;
  Event: TEvent;
  PlayObject: TPlayObject;
  nCheckCode: Integer;
resourcestring
  sExceptionMsg = '{%s} TBaseObject::Walk  CheckCode:%d %s %s %d:%d';
begin
  Result := True;
  nCheckCode := -1;
  if m_PEnvir = nil then begin
    MainOutMessage('Walk nil PEnvir');
    Exit;
  end;
  try
    nCheckCode := 1;
    bo1D := m_PEnvir.GetMapCellInfo(m_nCurrX, m_nCurrY, MapCellInfo);
    GateObj := nil;
    Event := nil;
    nCheckCode := 2;
    if bo1D and (MapCellInfo.ObjList <> nil) then begin
      if MapCellInfo.ObjList.Count > 0 then begin //20080629
        for I := 0 to MapCellInfo.ObjList.Count - 1 do begin
          OSObject := MapCellInfo.ObjList.Items[I];
          if OSObject <> nil then begin
            if (not OSObject.boObjectDisPose) then begin
              if OSObject.btType = OS_GATEOBJECT then begin
                GateObj := pTGateObj(OSObject.CellObj);
              end;
              if OSObject.btType = OS_EVENTOBJECT then begin
                if TEvent(OSObject.CellObj).m_OwnBaseObject <> nil then
                  Event := TEvent(OSObject.CellObj);
              end;
              if OSObject.btType = OS_MAPEVENT then begin

              end;
              if OSObject.btType = OS_DOOR then begin

              end;
              if OSObject.btType = OS_ROON then begin

              end;
            end;
          end;
        end; //for
      end;
    end;
    nCheckCode := 3;
    if (Event <> nil) and (not Event.m_boClosed) then begin
      if Event.m_OwnBaseObject <> nil then begin
        nCheckCode := 36;
        if (not Event.m_OwnBaseObject.m_boDeath) or (not Event.m_OwnBaseObject.m_boGhost) then begin //20090505 增加
          nCheckCode := 37;
          if (not Event.m_OwnBaseObject.m_boRobotObject) then begin
            nCheckCode := 35;
            if Event.m_OwnBaseObject.IsProperTarget(Self) then begin
              nCheckCode := 33;
              if (Event.m_OwnBaseObject.m_btRaceServer = 156) and (m_btRaceServer <> 156)
                and (m_btRaceServer <> 157) then begin //朱火弹则目标直接死亡
                SetLastHiter(Event.m_OwnBaseObject);
                m_WAbil.HP := 0;
              end else SendMsg(Event.m_OwnBaseObject, RM_MAGSTRUCK_MINE, 0, Event.m_nDamage, 1 {0}, 0, ''); //20100926 修改
            end;
          end;
        end;
      end;
    end;
    nCheckCode := 4;
    if Result and (GateObj <> nil) then begin
      if m_btRaceServer = RC_PLAYOBJECT then begin
        if m_PEnvir.ArroundDoorOpened(m_nCurrX, m_nCurrY) then begin
          if (not TEnvirnoment(GateObj.DEnvir).m_boNEEDHOLE) or (g_EventManager.GetEvent(m_PEnvir, m_nCurrX, m_nCurrY, ET_DIGOUTZOMBI) <> nil) then begin
            if nServerIndex = TEnvirnoment(GateObj.DEnvir).nServerIndex then begin
              if not TEnvirnoment(GateObj.DEnvir).m_boNEEDLEVELTIME then begin //进入地图不需要等级 20081228
                if not EnterAnotherMap(TEnvirnoment(GateObj.DEnvir), GateObj.nDMapX, GateObj.nDMapY) then begin
                  Result := False;
                end;
              end else begin //雪域地图 20081228
                if m_Abil.Level >= TEnvirnoment(GateObj.DEnvir).m_nNEEDLEVELPOINT then begin //等级达到时才可进入地图
                  if not EnterAnotherMap(TEnvirnoment(GateObj.DEnvir), GateObj.nDMapX, GateObj.nDMapY) then begin
                    Result := False;
                  end;
                end else begin
                  TPlayObject(Self).MoveToHome(); //移动到回城点
                  if sNEEDLEVELToXYErrorMsg <> '' then SysMsg(Format_ToStr(sNEEDLEVELToXYErrorMsg, [TEnvirnoment(GateObj.DEnvir).m_nNEEDLEVELPOINT]), c_Red, t_Hint);
                end;
              end;
            end else begin
              DisappearA();
              m_bo316 := True;
              PlayObject := TPlayObject(Self);
              PlayObject.m_sSwitchMapName := TEnvirnoment(GateObj.DEnvir).sMapName;
              PlayObject.m_nSwitchMapX := GateObj.nDMapX;
              PlayObject.m_nSwitchMapY := GateObj.nDMapY;
              PlayObject.m_boSwitchData := True;
              PlayObject.m_nServerIndex := TEnvirnoment(GateObj.DEnvir).nServerIndex;
              PlayObject.m_boEmergencyClose := True;
              PlayObject.m_boReconnection := True;
              PlayObject.m_boPlayOffLine := False;
            end;
          end;
        end;
      end else
        if m_btRaceServer = 109 then begin //押镖怪，可以走过门 20091231
          if m_PEnvir.ArroundDoorOpened(m_nCurrX, m_nCurrY) then begin
            if (not TEnvirnoment(GateObj.DEnvir).m_boNEEDHOLE) or (g_EventManager.GetEvent(m_PEnvir, m_nCurrX, m_nCurrY, ET_DIGOUTZOMBI) <> nil) then begin
              if not EnterAnotherMap(TEnvirnoment(GateObj.DEnvir), GateObj.nDMapX, GateObj.nDMapY) then begin
                Result := False;
              end;
            end;
          end;
        end else Result := False;
    end else begin
      nCheckCode := 5;
      if Result then begin
        nCheckCode := 6;
        SendRefMsg(nIdent, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
      end;
    end;
  except   
    //on E: Exception do begin
    MainOutMessage(Format(sExceptionMsg, [g_sExceptionVer, nCheckCode, m_sCharName, m_sMapName, m_nCurrX, m_nCurrY]));
      //MainOutMessage(E.Message);
   //end;
  end;
end;
//进入另外的地图(从坐标走向另一个地图)

function TBaseObject.EnterAnotherMap(Envir: TEnvirnoment; nDMapX,
  nDMapY: Integer): Boolean;
var
  I, nOldX, nOldY: Integer;
  MapCellInfo: pTMapCellinfo;
  OldEnvir: TEnvirnoment;
  Castle: TUserCastle;
  boRef: Boolean;
  nCode: Byte; //20080901
resourcestring
  sExceptionMsg1 = '{%s} TBaseObject::EnterAnotherMap -> MsgTargetList Clear';
  sExceptionMsg2 = '{%s} TBaseObject::EnterAnotherMap -> VisbleItems Dispose';
  sExceptionMsg3 = '{%s} TBaseObject::EnterAnotherMap -> VisbleItems Clear';
  sExceptionMsg4 = '{%s} TBaseObject::EnterAnotherMap -> VisbleEvents Clear';
  sExceptionMsg5 = '{%s} TBaseObject::EnterAnotherMap -> VisbleActors Dispose';
  sExceptionMsg6 = '{%s} TBaseObject::EnterAnotherMap -> VisbleActors Clear';
  sExceptionMsg7 = '{%s} TBaseObject::EnterAnotherMap Code:%d';
begin
  Result := False;
  nCode := 0;
  try
    if Envir = nil then Exit; //20081014
    if m_Abil.Level < Envir.nRequestLevel then Exit;
    nCode := 1;
    if Envir <> nil then begin
      try
        nCode := 15;
        if Envir.QuestNPC <> nil then begin
          nCode := 17; //20090105 if not m_boGhost
          if not m_boGhost then TMerchant(Envir.QuestNPC).Click(TPlayObject(Self));
        end;
      except   
        MainOutMessage(format(sExceptionMsg7, [g_sExceptionVer, nCode]));
      end;
    end;
    nCode := 2;
    if Envir.nNEEDSETONFlag >= 0 then begin
      nCode := 3;
      if GetQuestFalgStatus(Envir.nNEEDSETONFlag) <> Envir.nNeedONOFF then Exit;
    end;
    nCode := 4;
    if not Envir.GetMapCellInfo(nDMapX, nDMapY, MapCellInfo) then Exit;
    nCode := 5;
    Castle := g_CastleManager.IsCastlePalaceEnvir(Envir);
    if (Castle <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then begin
      nCode := 6;
      if not Castle.CheckInPalace(m_nCurrX, m_nCurrY, Self) then Exit;
    end;
    OldEnvir := m_PEnvir;
    nOldX := m_nCurrX;
    nOldY := m_nCurrY;
    nCode := 7;
    if (OldEnvir <> Envir) then ChangMapDropItems; //换地图掉指定物品 20110301
    DisappearA();
    nCode := 8;
    try
      m_VisibleHumanList.Clear;
    except   
      MainOutMessage(format(sExceptionMsg1, [g_sExceptionVer]));
    end;
    try
      if m_VisibleItems.Count > 0 then begin //20080629
        for I := 0 to m_VisibleItems.Count - 1 do begin
          if pTVisibleMapItem(m_VisibleItems.Items[I]) <> nil then
            Dispose(pTVisibleMapItem(m_VisibleItems.Items[I]));
        end;
      end;
    except   
      MainOutMessage(format(sExceptionMsg2, [g_sExceptionVer]));
    end;
    try
      m_VisibleItems.Clear;
    except   
      MainOutMessage(format(sExceptionMsg3, [g_sExceptionVer]));
    end;

    try
      {if m_VisibleEvents.Count > 0 then begin//20080629   20090215 注释
        for I := 0 to m_VisibleEvents.Count - 1 do begin
          if pTVisibleMapEvent(m_VisibleEvents.Items[I]) <> nil then
             Dispose(pTVisibleMapEvent(m_VisibleEvents.Items[I]));
        end;
      end;}
      m_VisibleEvents.Clear;
    except   
      MainOutMessage(format(sExceptionMsg4, [g_sExceptionVer]));
    end;
    try
      if m_VisibleActors.Count > 0 then begin //20080629
        for I := 0 to m_VisibleActors.Count - 1 do begin
          if pTVisibleBaseObject(m_VisibleActors.Items[I]) <> nil then
            Dispose(pTVisibleBaseObject(m_VisibleActors.Items[I]));
        end;
      end;
    except   
      MainOutMessage(format(sExceptionMsg5, [g_sExceptionVer]));
    end;
    try
      m_VisibleActors.Clear;
    except   
      MainOutMessage(format(sExceptionMsg6, [g_sExceptionVer]));
    end;
    nCode := 9;
    SendMsg(Self, RM_CLEAROBJECTS, 0, 0, 0, 0, '');
    m_PEnvir := Envir;
    m_sMapName := Envir.sMapName;
    m_nCurrX := nDMapX;
    m_nCurrY := nDMapY;
    case m_btRaceServer of
      RC_PLAYOBJECT: begin
          if TPLAYOBJECT(self).m_boForMapShowHint and (TPLAYOBJECT(self).m_dwUserTick[0] > 0) then begin //换地图是否还显示倒计时信息 20090128
            TPLAYOBJECT(self).m_dwUserTick[0] := 0;
            TPLAYOBJECT(self).m_dwUserTick[3] := 0; //20090129
            TPLAYOBJECT(self).m_boForMapShowHint := False;
            SendMsg(self, RM_MOVEMESSAGE, 2 {倒记时消息}, 255, 0, 1, ''); //关闭客户端显示倒计时(快捷键上方显示)
          end;
        {if TPLAYOBJECT(self).m_boShowExpCrystal then begin//20090205 从一个地图直接跑到另一个地图不清天地结晶
          TPLAYOBJECT(self).m_boShowExpCrystal:= False;
          //TPLAYOBJECT(self).m_boGetExpCrystalExp := False;//是否可以提取经验
          //发消息关闭天地结晶图标
          SendMsg(self, RM_OPENEXPCRYSTAL, 0, 1, 0, 0, '');
        end;}
          if TPLAYOBJECT(self).m_boShowCattleGas then begin //关闭牛气管图标 20090518
            TPLAYOBJECT(self).m_boShowCattleGas := False;
            SendMsg(self, RM_OPENCATTLEGAS, 0, 1, 0, 0, ''); //发消息关闭牛气管图标
          end;
{$IF M2Version <> 2}
          TPLAYOBJECT(self).m_nHeapStruckDamage := 0; //受有武器暴击等级的人物累积攻击点 20100709
          if (OldEnvir <> m_PEnvir) then begin
            boRef := False;
            if OldEnvir.boLimitLevel then begin
              RecalcLevelAbilitys();
              boRef := True;
            end;
            if m_PEnvir.boLimitLevel then boRef := True;
            if (TPLAYOBJECT(self).m_nSetupMaxLeveltoHPMP > 0) then begin
              TPLAYOBJECT(self).m_nSetupMaxLeveltoHPMP := 0;
              boRef := True;
            end;
            if boRef then begin
              RecalcAbilitys();
              CompareSuitItem(False);
              SendDelayMsg(Self, RM_ABILITY, 0, 0, 0, 0, '', 1000); //由于换地图时，客户端对像不处理此消息，需要延时
            end;
          end;
{$IFEND}
        end;
      RC_HEROOBJECT: begin
{$IF M2Version <> 2}THeroObject(self).m_nHeapStruckDamage := 0{$IFEND}; //受有武器暴击等级的人物累积攻击点 20100709
          if (OldEnvir <> m_PEnvir) then begin
            if OldEnvir.boLimitLevel or m_PEnvir.boLimitLevel then begin
              if OldEnvir.boLimitLevel then RecalcLevelAbilitys();
              RecalcAbilitys();
              CompareSuitItem(False);
              THeroObject(self).SendMsg(Self, RM_HEROABILITY, 0, 0, 0, 0, '');
            end;
          end;
        end;
    end; //case
    SendMsg(Self, RM_CHANGEMAP, 0, 0, 0, 0, g_MapManager.GetMainMap(Envir));
    nCode := 10;
    if AddToMap() then begin
      m_dwMapMoveTick := GetTickCount();
      m_bo316 := True;
      Result := True;
    end else begin
      m_PEnvir := OldEnvir;
      m_nCurrX := nOldX;
      m_nCurrY := nOldY;
      nCode := 11;
      m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
    end;
    nCode := 12;
    if m_btRaceServer = RC_PLAYOBJECT then begin //复位泡点，及金币，时间
      nCode := 13;
      TPlayObject(Self).m_dwIncGamePointTick := GetTickCount();
      TPlayObject(Self).m_dwIncGameGoldTick := GetTickCount();
      TPlayObject(Self).m_dwAutoGetExpTick := GetTickCount();
      TPlayObject(Self).ShopCancel; //取消个人商店
{$IF M2Version <> 2}
      if (TPLAYOBJECT(self).m_nJewelX > -1) or (TPLAYOBJECT(self).m_nJewelY > -1) then begin
        SysMsg('因为您离开了宝物所在地图，灵媒的感应消失', c_Green, t_Hint);
        TPLAYOBJECT(self).m_nJewelX := -1; //宝物X坐标
        TPLAYOBJECT(self).m_nJewelY := -1; //宝物Y坐标
      end;
      if m_PEnvir.m_boCRIT and (sMapIncCritMsg <> '') then SysMsg(Format_ToStr(sMapIncCritMsg, [m_PEnvir.m_nCRIT]), c_Blue, t_Hint); //进入暴击等级地图提示 20110114
      if m_PEnvir.m_boPeak then begin
        if m_PEnvir.m_nPeakMaxRate > 100 then SysMsg(sMapPaekMsg1, c_Blue, t_Hint)
        else SysMsg(sMapPaekMsg, c_Blue, t_Hint);
      end;
{$IFEND}
    end;
    nCode := 14;
    if m_PEnvir.m_boFight3Zone and (m_PEnvir.m_boFight3Zone <> OldEnvir.m_boFight3Zone) then RefShowName();
  except   
    MainOutMessage(format(sExceptionMsg7, [g_sExceptionVer, nCode]));
  end;
end;

procedure TBaseObject.TurnTo(nDir: Integer);
begin
  m_btDirection := nDir;
  SendRefMsg(RM_TURN, nDir, m_nCurrX, m_nCurrY, 0, '');
end;

procedure TBaseObject.ProcessSayMsg(sMsg: string);
var
  sCharName: string;
begin
  if m_btRaceServer = RC_PLAYOBJECT then Exit; //修改
  sCharName := FilterShowName(m_sCharName);
  SendRefMsg(RM_HEAR, 0, g_Config.btHearMsgFColor, g_Config.btHearMsgBColor, 0, sCharName + ':' + sMsg);
end;

//加强版文件信息发送函数(供NPC命令-SendMsg使用) 20081214

procedure TBaseObject.ProcessSayMsg1(sMsg: string; FColor, BColor: Byte);
var
  sCharName: string;
begin
  if m_btRaceServer = RC_PLAYOBJECT then Exit; //修改
  sCharName := FilterShowName(m_sCharName);
  SendRefMsg(RM_HEAR, 0, FColor, BColor, 0, sCharName + ':' + sMsg);
end;
//发送文件信息 20080211

procedure TBaseObject.SysMsg(sMsg: string; MsgColor: TMsgColor; MsgType: TMsgType);
var
  str, FColor, BColor, nTime: string;
begin
  if ((m_btRaceServer = RC_PLAYOBJECT) and (TPlayObject(Self).m_boNotOnlineAddExp)) or m_boAI or (sMsg = '') then Exit; //修改离线人物不发送

  if g_Config.boShowPreFixMsg then begin
    case MsgType of
      t_Mon: sMsg := g_Config.sMonSayMsgpreFix + sMsg;
      t_Hint: sMsg := g_Config.sHintMsgPreFix + sMsg;
      t_GM: sMsg := g_Config.sGMRedMsgpreFix + sMsg;
      t_System: sMsg := g_Config.sSysMsgPreFix + sMsg;
      t_Cust: sMsg := g_Config.sCustMsgpreFix + sMsg;
      t_Castle: sMsg := g_Config.sCastleMsgpreFix + sMsg;
    end;
  end;

  //增加滚动公告   2007.11.13 (此处处理各种特殊的公告 20080106)
  if MsgType = t_Notice then begin //如果发的是公告
    if (sMsg[1] = '[') then begin //顶部滚动公告
      sMsg := ArrestStringEx(sMsg, '[', ']', str);
      BColor := GetValidStrCap(str, FColor, [',']);
      if g_Config.boShowPreFixMsg then sMsg := g_Config.sLineNoticePreFix + sMsg; //20080504 增加
      SendMsg(Self, RM_MOVEMESSAGE, 0, Str_ToInt(FColor, 255), Str_ToInt(BColor, 255), 0, sMsg);
    end else
   { if (sMsg[1] = '<') then begin //聊天框彩色公告
      sMsg:= ArrestStringEx(sMsg, '<', '>', str);
      BColor:= GetValidStrCap(str, FColor, [',']);
      if g_Config.boShowPreFixMsg then sMsg := g_Config.sLineNoticePreFix + sMsg;//20080504 增加
    end else      }
      if (sMsg[1] = '{') then begin //屏幕居中公告
        sMsg := ArrestStringEx(sMsg, '{', '}', str);
        str := GetValidStrCap(str, FColor, [',']);
        str := GetValidStrCap(str, BColor, [',']);
        str := GetValidStrCap(str, nTime, [',']); //20081226
        if g_Config.boShowPreFixMsg then sMsg := g_Config.sLineNoticePreFix + sMsg; //20080504 增加
        SendMsg(Self, RM_MOVEMESSAGE, 1, Str_ToInt(FColor, 255), Str_ToInt(BColor, 255), Str_ToInt(nTime, 0), sMsg); //20081226
      end else
  {  if (sMsg[1] = '(') then begin //聊天框顶部公告
      sMsg:= ArrestStringEx(sMsg, '(', ')', str);
      BColor:= GetValidStrCap(str, FColor, [',']);
      if g_Config.boShowPreFixMsg then sMsg := g_Config.sLineNoticePreFix + sMsg;//20080504 增加
    end else     }
      begin
        case MsgColor of //控制公告的颜色 20080503
          c_Red: begin
              if g_Config.boShowPreFixMsg then sMsg := g_Config.sLineNoticePreFix + sMsg; //20080504 增加
              SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btRedMsgFColor, g_Config.btRedMsgBColor, 0, sMsg);
            end;
          c_Green: begin
              if g_Config.boShowPreFixMsg then sMsg := g_Config.sLineNoticePreFix + sMsg; //20080504 增加
              SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btGreenMsgFColor, g_Config.btGreenMsgBColor, 0, sMsg);
            end;
          c_Blue: begin
              if g_Config.boShowPreFixMsg then sMsg := g_Config.sLineNoticePreFix + sMsg; //20080504 增加
              SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btBlueMsgFColor, g_Config.btBlueMsgBColor, 0, sMsg);
            end;
        end;
      end;
  end else begin
    case MsgColor of
      c_Green: SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btGreenMsgFColor, g_Config.btGreenMsgBColor, 0, sMsg);
      c_Blue: SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btBlueMsgFColor, g_Config.btBlueMsgBColor, 0, sMsg);
{$IF M2Version <> 2}
      c_Fuchsia: SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btSayMsgFColor, g_Config.btSayeMsgBColor, 0, sMsg); //千里传音颜色 20080309
{$IFEND}
      BB_Fuchsia: SendMsg(Self, RM_SYSMESSAGE, 0, 241, 255, 0, sMsg); //宝宝提示颜色 20080328
      C_HeroHint: SendMsg(Self, RM_SYSMESSAGE, 0, 255, 252, 0, sMsg); //英雄状态提示(兰底白字) 20080329
    else begin
        if MsgType = t_Cust then begin //祝福语
          SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btCustMsgFColor, g_Config.btCustMsgBColor, 0, sMsg);
        end else begin
          SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btRedMsgFColor, g_Config.btRedMsgBColor, 0, sMsg);
        end;
      end;
    end;
  end;
end;
//加强版文件信息发送函数(供NPC命令-SendMsg使用) 20081214

procedure TBaseObject.SysMsg1(sMsg: string; MsgColor: TMsgColor; MsgType: TMsgType; FColor, BColor: Byte);
begin
  if ((m_btRaceServer = RC_PLAYOBJECT) and (TPlayObject(Self).m_boNotOnlineAddExp))
    or (sMsg = '') or m_boAI then Exit; //修改离线人物不发送

  if g_Config.boShowPreFixMsg then begin
    case MsgType of
      t_System: sMsg := g_Config.sSysMsgPreFix + sMsg;
    end;
  end;

  case MsgColor of
    c_Green: SendMsg(Self, RM_SYSMESSAGE, 0, FColor, BColor, 0, sMsg);
    c_Blue: SendMsg(Self, RM_SYSMESSAGE, 0, FColor, BColor, 0, sMsg);
  else SendMsg(Self, RM_SYSMESSAGE, 0, FColor, BColor, 0, sMsg);
  end;
end;

procedure TBaseObject.MonsterSayMsg(AttackBaseObject: TBaseObject; MonStatus: TMonStatus);
var
  I: Integer;
  sMsg: string;
  MonSayMsg: pTMonSayMsg;
  sAttackName: string;
  nCode: Byte; //20090114
begin
  nCode := 0;
  try
    if m_SayMsgList = nil then Exit;
    nCode := 1;
    if (AttackBaseObject <> nil) then begin
      if (AttackBaseObject.m_btRaceServer <> RC_PLAYOBJECT) and (AttackBaseObject.m_Master = nil) then begin
        Exit;
      end;
      nCode := 2;
      if AttackBaseObject.m_Master <> nil then sAttackName := AttackBaseObject.m_Master.m_sCharName
      else sAttackName := AttackBaseObject.m_sCharName;
    end;
    nCode := 3;
    if m_SayMsgList.Count > 0 then begin //20080629
      for I := 0 to m_SayMsgList.Count - 1 do begin
        MonSayMsg := m_SayMsgList.Items[I];
        nCode := 4;
        if MonSayMsg = nil then Continue;
        nCode := 5;
        sMsg := AnsiReplaceText(MonSayMsg.sSayMsg, '%s', FilterShowName(m_sCharName));
        sMsg := AnsiReplaceText(sMsg, '%d', sAttackName);

        sMsg := AnsiReplaceText(sMsg, '%x', IntToStr(m_nCurrX));
        sMsg := AnsiReplaceText(sMsg, '%y', IntToStr(m_nCurrY));
        if m_PEnvir <> nil then
          sMsg := AnsiReplaceText(sMsg, '%m', m_PEnvir.sMapDesc)
        else sMsg := AnsiReplaceText(sMsg, '%m', '????');

        nCode := 6;
        if (MonSayMsg.State = MonStatus) and (Random(MonSayMsg.nRate) = 0) then begin
          if MonStatus = s_MonGen then begin
            nCode := 7;
            UserEngine.SendBroadCastMsg(sMsg, t_Mon);
            Break;
          end;
          nCode := 8;
          if MonSayMsg.Color = c_White then begin
            nCode := 9;
            ProcessSayMsg(sMsg);
          end else begin
            nCode := 10;
            if (AttackBaseObject <> nil) then //20090114 增加
              AttackBaseObject.SysMsg(sMsg, MonSayMsg.Color, t_Mon);
          end;
          Break;
        end;
      end; //for
    end;
  except
    on E:Exception do
    MainOutMessage(format('{%s} TBaseObject.MonsterSayMsg Code:%d', [E.Message, g_sExceptionVer, nCode]));
  end;
end;
//发送组队聊天

procedure TPlayObject.SendGroupText(sMsg: string);
var
  I: Integer;
  PlayObject: TPlayObject;
begin
  sMsg := g_Config.sGroupMsgPreFix + sMsg;
  if m_GroupOwner <> nil then begin
    if m_GroupOwner.m_GroupMembers.Count > 0 then begin //20080629
      for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
        PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[I]);
        if PlayObject = nil then Continue;
        PlayObject.SendMsg(PlayObject {Self}, RM_GROUPMESSAGE, 0, g_Config.btGroupMsgFColor, g_Config.btGroupMsgBColor, 0, sMsg); //20090211 修改
      end;
    end;
  end;
end;

procedure TBaseObject.MakeGhost();
begin
  m_boGhost := True;
  m_dwGhostTick := GetTickCount();
{$IF M2Version <> 2}
  if (m_btRaceServer = RC_PLAYOBJECT) then begin
    if TPlayObject(self).m_MyDivision <> nil then begin //刷新师门数据
      TDivision(TPlayObject(self).m_MyDivision).RefMemberName(m_sCharName);
    end;
  end;
{$IFEND}
  DisappearA();
end;
//设置肉的品质

procedure TBaseObject.ApplyMeatQuality;
var
  I: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
begin
  if m_ItemList.Count > 0 then begin //20080628
    for I := 0 to m_ItemList.Count - 1 do begin
      UserItem := m_ItemList.Items[I];
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
        if StdItem.StdMode = 40 then begin //肉
          UserItem.Dura := m_nMeatQuality;
        end;
      end;
    end;
  end;
end;

function TBaseObject.TakeBagItems(BaseObject: TBaseObject): Boolean;
var
  UserItem: pTUserItem;
  PlayObject: TPlayObject;
begin
  Result := False;
  while (True) do begin
    try //20101126  防止死循环
      if BaseObject.m_ItemList.Count <= 0 then Break;
      UserItem := BaseObject.m_ItemList.Items[0];
      if not AddItemToBag(UserItem) then Break;
      if Self is TPlayObject then begin
        PlayObject := TPlayObject(Self);
        PlayObject.SendAddItem(UserItem);
        Result := True;
      end;
      BaseObject.m_ItemList.Delete(0);
    except
      Break;
    end;
  end;
end;

//怪物掉物品,英雄爆包裹物品

procedure TBaseObject.ScatterBagItems(ItemOfCreat: TBaseObject);
var
  I, II, DropWide: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  boCanNotDrop: Boolean;
  MonDrop: pTMonDrop;
  pu: pTUserItem;
  DelList: TStringList;
  boDropall: Boolean;
  sCheckItemName: string;
  nCode: Byte;
resourcestring
  sExceptionMsg = '{%s} TBaseObject::ScatterBagItems Code:%d';
begin
  if m_btRaceServer = RC_HEROOBJECT then begin //英雄死后爆包裹
    if m_Master <> nil then begin //20090721 增加
      TPlayObject(m_Master).m_boCanQueryBag := True; //掉落装备物品时,不能刷新包裹 20080917
      try
        DelList := nil;
        if m_PEnvir.m_boNODROPITEM then Exit; //地图禁止死亡掉物品则退出 20080503
        if m_boAngryRing or m_boNoDropItem then Exit; //不死戒指
        boDropall := False;
        DropWide := 2;
        if g_Config.boHeroDieRedScatterBagAll and (PKLevel >= 2) then boDropall := True;
        nCode := 0;
        //非红名掉1/3 //红名全掉
        try
          for I := m_ItemList.Count - 1 downto 0 do begin
            nCode := 1;
            if m_ItemList.Count <= 0 then Break;
            nCode := 2;
            if boDropall or (Random(g_Config.nHeroDieScatterBagRate {3}) = 0) then begin
              nCode := 3;
              if m_ItemList[I] <> nil then begin
                nCode := 4;
                pu := pTUserItem(m_ItemList[I]);
                if (pu.AddValue[0] = 1) and (GetHoursCount(pu.MaxDate, Now) <= 0) then begin //删除到期装备
                  m_ItemList.Delete(I);
                  Dispose(pu);
                  Continue;
                end;
                if CheckItemValue(pu, 5) then Continue; //20110529 禁止爆出
                sCheckItemName := UserEngine.GetStdItemName(pu.wIndex);
                if PlugOfCheckCanItem(6, sCheckItemName, False, 0, 0) then Continue; //禁止物品规则(永不爆出) 20080729
                if THEROOBJECT(self).CheckItemBindDieNoDrop(m_ItemList[I]) then Continue; //人物装备绑定死亡不爆 20081127
                nCode := 5;
                StdItem := UserEngine.GetStdItem(pu.wIndex);
                if StdItem <> nil then begin
                  if (StdItem.StdMode = 51) and (pu.Dura > 0) and (pu.btValue[20] = 1) then begin
                    case StdItem.Shape of
                      0: begin //是聚灵珠 20080611
                          TPlayObject(m_Master).n_UsesItemTick := 0; //时间初始
                          pu.btValue[12] := 2; //不能聚集的标识
                        end;
                      1, 2: pu.btValue[12] := 2; //内功珠不能聚集的标识
                    end;
                  end;
                end;
                nCode := 6;
                if not TPlayObject(m_Master).m_boHeroLogOut then begin //英雄未退出,则爆出
                  nCode := 61;
                  if DropItemDown(pTUserItem(m_ItemList[I]), DropWide, True, True, ItemOfCreat, Self) then begin
                    if m_btRaceServer = RC_HEROOBJECT then begin
                      if DelList = nil then DelList := TStringList.Create;
                      DelList.AddObject(UserEngine.GetStdItemName(pu.wIndex), TObject(pu.MakeIndex));
                    end;
                    Dispose(pTUserItem(m_ItemList[I])); //修改
                    m_ItemList.Delete(I);
                  end;
                end;
              end;
            end;
          end; //for
          if DelList <> nil then begin
            SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
          end;
        except   
          MainOutMessage(format(sExceptionMsg, [g_sExceptionVer, nCode]));
        end;
      finally
        TPlayObject(m_Master).m_boCanQueryBag := False; //掉落装备物品时,不能刷新包裹 20080917
      end;
    end;
  end else begin
    if (m_Master <> nil) and (m_btRaceServer = RC_PLAYMOSTER) then Exit; //分身死亡不爆包裹物品 20100110
    if m_btRaceServer = 134 then begin
      if TIceEyesTrollAvatar(Self).m_boIsCopyMon then Exit; //是冰眼巨魔的分身则退出
    end;
    DropWide := 3;
    nCode := 7;
    try
      g_MonDropLimitLIst.Lock;
      try
        nCode := 8;
        if m_ItemList <> nil then begin
          for I := m_ItemList.Count - 1 downto 0 do begin
            if m_ItemList.Count <= 0 then Break;
            nCode := 9;
            UserItem := m_ItemList.Items[I];
            if UserItem <> nil then begin //20090114
              if (UserItem.AddValue[0] = 1) and (GetHoursCount(UserItem.MaxDate, Now) <= 0) then begin //删除到期装备
                m_ItemList.Delete(I);
                Dispose(UserItem);
                Continue;
              end;
              nCode := 15;
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              boCanNotDrop := False;
              nCode := 16;
              if (StdItem <> nil) and (g_MonDropLimitLIst.Count > 0) then begin
                nCode := 10;
                II := g_MonDropLimitLIst.IndexOf(StdItem.Name); //20110518修改
                if II > -1 then begin
                  MonDrop := pTMonDrop(g_MonDropLimitLIst.Objects[II]);
                  if MonDrop <> nil then begin
                    nCode := 12;
                    if MonDrop.nDropCount < MonDrop.nCountLimit then begin
                      Inc(MonDrop.nDropCount);
                      g_MonDropLimitLIst.Objects[II] := TObject(MonDrop);
                    end else begin
                      Inc(MonDrop.nNoDropCount);
                      boCanNotDrop := True;
                    end;
                  end;
                end;
               { for II := 0 to g_MonDropLimitLIst.Count - 1 do begin
                  if CompareText(StdItem.Name, g_MonDropLimitLIst.Strings[II]) = 0 then begin
                    nCode:= 11;
                    MonDrop := pTMonDrop(g_MonDropLimitLIst.Objects[II]);
                    if MonDrop <> nil then begin
                      nCode:= 12;
                      if MonDrop.nDropCount < MonDrop.nCountLimit then begin
                        Inc(MonDrop.nDropCount);
                        g_MonDropLimitLIst.Objects[II] := TObject(MonDrop);
                      end else begin
                        Inc(MonDrop.nNoDropCount);
                        boCanNotDrop := True;
                      end;
                    end;
                    Break;
                  end;
                end;//for}
              end;
              if boCanNotDrop then Continue;
              nCode := 13;
              if DropItemDown(UserItem, DropWide, True, True, ItemOfCreat, Self) then begin
                nCode := 14;
                m_ItemList.Delete(I);
                nCode := 17;
                try //20091124 增加
                  if UserItem <> nil then Dispose(UserItem);
                except
                end;
              end;
            end;
          end; //for
        end;
      finally
        g_MonDropLimitLIst.UnLock;
      end;
    except   
      MainOutMessage(format(sExceptionMsg, [g_sExceptionVer, nCode]));
    end;
  end;
end;
//分散金币

procedure TBaseObject.ScatterGolds(GoldOfCreat: TBaseObject);
var
  I, nGold: Integer;
begin
  if m_nGold > 0 then begin
    I := 0;
    while (True) do begin
      try //20101126 防止死循环
        //      for i:=0 to 18 do begin
        if m_nGold > g_Config.nMonOneDropGoldCount then begin
          nGold := g_Config.nMonOneDropGoldCount;
          m_nGold := m_nGold - g_Config.nMonOneDropGoldCount;
        end else begin
          nGold := m_nGold;
          m_nGold := 0;
        end;
        if nGold > 0 then begin
          if not DropGoldDown(nGold, True, GoldOfCreat, Self) then begin
            m_nGold := m_nGold + nGold;
            Break;
          end;
        end else Break;
      except
        Break;
      end;
      Inc(I);
      if I >= 17 then Break;
    end;
    GoldChanged;
  end;
end;
//掉装备 20080120

procedure TBaseObject.DropUseItems(BaseObject: TBaseObject; nBurstRate: Byte);
var
  I, K, J, nRate: Integer;
  StdItem: pTStdItem;
  DropItemList: TStringList;
  SelectItemList: TStringList;
  sCheckItemName: string;
resourcestring
  sExceptionMsg = '{%s} TBaseObject::DropUseItems';
begin
  DropItemList := nil;
  try
    if m_boNoDropUseItem or m_boAngryRing then Exit; //20091129 加入m_boAngryRing(170类物品不爆)
    if m_PEnvir.m_boNODROPITEM then Exit; //地图禁止死亡掉物品则退出 20080503
    if m_Master <> nil then begin
      if m_btRaceServer <> RC_HEROOBJECT then begin //如果不是人形怪或者英雄，装备不掉 20080602
        if m_btRaceServer <> RC_PLAYMOSTER then Exit;
      end;
    end;
    for I := Low(THumanUseItems) to High(THumanUseItems) do begin //死亡物品消失
      StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
      if StdItem <> nil then begin
        if CheckItemValue(@m_UseItems[I], 5) then Continue; //20080314 禁止爆出
        if PlugOfCheckCanItem(6, StdItem.Name, False, 0, 0) then Continue; //禁止物品规则(永不爆出) 20080729
        if m_btRaceServer = RC_HEROOBJECT then begin
          if THEROOBJECT(self).CheckItemBindDieNoDrop(@m_UseItems[I]) then Continue; //人物装备绑定死亡不爆 20081127
          if (StdItem.Shape = 193) then Continue; //20100325虎威系统不处理
        end;
        if (StdItem.Reserved and 8 <> 0) then begin
          if m_btRaceServer = RC_HEROOBJECT then begin
            if DropItemList = nil then DropItemList := TStringList.Create;
            DropItemList.AddObject('', TObject(m_UseItems[I].MakeIndex));
          end;
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('16' + #9 +
              m_sMapName + '(' + IntToStr(m_btRaceServer) + ')' + #9 +
              IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 + StdItem.Name + #9 + IntToStr(m_UseItems[I].MakeIndex) + #9 +
              '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
              '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
              '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
              '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
              '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
              IntToStr(m_UseItems[I].btValue[0]) + '/' + IntToStr(m_UseItems[I].btValue[1]) + '/' + IntToStr(m_UseItems[I].btValue[2]) + '/' +
              IntToStr(m_UseItems[I].btValue[3]) + '/' + IntToStr(m_UseItems[I].btValue[4]) + '/' + IntToStr(m_UseItems[I].btValue[5]) + '/' +
              IntToStr(m_UseItems[I].btValue[6]) + '/' + IntToStr(m_UseItems[I].btValue[7]) + '/' + IntToStr(m_UseItems[I].btValue[8]) + '/' +
              IntToStr(m_UseItems[I].btValue[14]) + #9 + '1');
          m_UseItems[I].wIndex := 0;
        end;
      end;
    end;

    case m_btRaceServer of
      RC_HEROOBJECT: begin //英雄
          if not m_boAI then begin
            if PKLevel > 2 then nRate := g_Config.nHeroDieRedDropUseItemRate {15}
            else nRate := g_Config.nHeroDieDropUseItemRate {30};
          end else begin
            nRate := m_nDropUseItemRate;
          end;
          if m_nUnBurstRate > 0 then nRate := _MIN(High(Byte), nRate + m_nUnBurstRate); //防爆点
          if nBurstRate > 0 then nRate := _MAX(0, nRate - nBurstRate); //20091129
        end;
      RC_PLAYMOSTER: begin //如果是人形怪,掉装备的几率 20080120 修改
          if (m_Master <> nil) or (not TPlayMonster(Self).m_boDropUseItem) then Exit; //如果设置不掉装备,是分身也不爆物品 20100110
          nRate := TPlayMonster(Self).m_nDieDropUseItemRate; //掉装备的几率
        end;
    end;
    for I := Low(THumanUseItems) to High(THumanUseItems) do begin
      if (m_UseItems[I].AddValue[0] = 1) and (GetHoursCount(m_UseItems[I].MaxDate, Now) <= 0) then begin //删除到期装备
        m_UseItems[I].wIndex := 0;
        Continue;
      end;
      if Random(nRate) <> 0 then Continue;
      if (nBurstRate > 0) and (m_btRaceServer = RC_HEROOBJECT) then begin //当有爆率装备时,一次只爆一次,物品位置随机 20100302
        SelectItemList := TStringList.Create;
        try
          for K := Low(THumanUseItems) to High(THumanUseItems) do begin
            if (m_UseItems[K].wIndex <= 0) or (m_UseItems[K].MakeIndex <= 0) then Continue;
            if InDisableTakeOffList(m_UseItems[K].wIndex) then Continue; //检查是否在禁止取下列表,如果在列表中则不掉此物品
            if CheckItemValue(@m_UseItems[K], 5) then Continue; //禁止爆出
            StdItem := UserEngine.GetStdItem(m_UseItems[K].wIndex);
            if StdItem <> nil then
              if PlugOfCheckCanItem(6, StdItem.Name, False, 0, 0) then Continue; //禁止物品规则(永不爆出)
            if THEROOBJECT(self).CheckItemBindDieNoDrop(@m_UseItems[K]) then Continue; //人物装备绑定死亡不爆
            SelectItemList.Add(IntToStr(K));
          end;
          if SelectItemList.Count > 0 then begin
            if m_Master <> nil then begin //主体不在或英雄退出则不爆出,
              if TPlayObject(m_Master).m_boHeroLogOut then Exit;
            end else Exit;
            J := Str_ToInt(SelectItemList.Strings[Random(SelectItemList.Count)], 0);
            if DropItemDown(@m_UseItems[J], 3, True, True, BaseObject, Self) then begin //爆出装备
              if m_btRaceServer = RC_HEROOBJECT then begin
                if DropItemList = nil then DropItemList := TStringList.Create;
                DropItemList.AddObject(UserEngine.GetStdItemName(m_UseItems[J].wIndex), TObject(m_UseItems[J].MakeIndex));
              end;
              m_UseItems[J].wIndex := 0;
              m_UseItems[J].MakeIndex := 0;
              Break; //当有爆率装备时，一次只爆一次 20100121
            end;
          end else Break;
        finally
          SelectItemList.Free;
        end;
      end else begin
        if (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then begin
          if InDisableTakeOffList(m_UseItems[I].wIndex) then Continue; //检查是否在禁止取下列表,如果在列表中则不掉此物品
        end;
        StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
        if CheckItemValue(@m_UseItems[I], 5) then Continue; //20080314 禁止爆出
        if StdItem <> nil then
          if PlugOfCheckCanItem(6, StdItem.Name, False, 0, 0) then Continue; //禁止物品规则(永不爆出) 20080729

        if m_btRaceServer = RC_HEROOBJECT then begin
          if THEROOBJECT(self).CheckItemBindDieNoDrop(@m_UseItems[I]) then Continue; //人物装备绑定死亡不爆 20081127
          if m_Master <> nil then begin //主体不在或英雄退出则不爆出,
            if TPlayObject(m_Master).m_boHeroLogOut then Exit;
          end else Exit;
        end;
        if DropItemDown(@m_UseItems[I], 3, True, True, BaseObject, Self) then begin
          if m_btRaceServer = RC_HEROOBJECT then begin
            if DropItemList = nil then DropItemList := TStringList.Create;
            DropItemList.AddObject(UserEngine.GetStdItemName(m_UseItems[I].wIndex), TObject(m_UseItems[I].MakeIndex));
          end;
          m_UseItems[I].wIndex := 0; //20090523
          m_UseItems[I].MakeIndex := 0; //20090523
        end;
      end;
    end;
    if DropItemList <> nil then begin
      if m_btRaceServer = RC_HEROOBJECT then begin //20110410 修改
        THEROOBJECT(self).SendDelItemList(DropItemList);
        DropItemList.Free;
      end else SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DropItemList), 0, 0, '');
    end;
  except   
    MainOutMessage(format(sExceptionMsg, [g_sExceptionVer]));
  end;
end;

//执行杀怪触发

function TPlayObject.KillMonsterFunc(BaseObject: TBaseObject): Boolean;
  function GotoKillMonsterFunc(): Boolean;
  begin
    Result := False;
    if g_FunctionNPC <> nil then begin
      //20080415 地图杀怪触发
      if m_PEnvir <> nil then begin //20090101
        if m_PEnvir.m_boKILLFUNC then g_FunctionNPC.GotoLable(Self, '@KillMonster' + Inttostr(m_PEnvir.m_nKILLFUNC), False, False);
      end;
      g_FunctionNPC.GotoLable(Self, '@KillMonster', False, False);
      Result := True;
    end;
  end;
var nCode: Byte;
begin
  Result := False;
  nCode := 0;
  try
    if BaseObject <> nil then begin
      nCode := 1;
      if not BaseObject.m_boGhost then begin //20090105
        nCode := 2;
        if BaseObject.m_btRaceServer >= RC_ANIMAL then begin
          nCode := 3;
          m_sString[0] := BaseObject.m_sCharName;
          nCode := 4;
          m_nInteger[0] := BaseObject.m_Abil.Level;
          nCode := 5;
          Result := GotoKillMonsterFunc;
        end;
      end;
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.KillMonsterFunc Code:%d', [g_sExceptionVer, nCode]));
  end;
end;
//死亡必掉物品

procedure TBaseObject.DieDropItems;
var
  I: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  ItemName: string;
  DelList: TStringList;
begin
  DelList := nil;
  try
    if (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYOBJECT) then begin
      for I := Low(THumanUseItems) to High(THumanUseItems) do begin //9格装备+4格装备
        StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
        if StdItem <> nil then begin
          if (m_UseItems[I].AddValue[0] = 1) and (GetHoursCount(m_UseItems[I].MaxDate, Now) <= 0) then begin
            m_UseItems[I].wIndex := 0;
            Continue;
          end;
          if CheckItemValue(@m_UseItems[I], 5) then Continue; //20110529 禁止爆出
          ItemName := StdItem.Name;
          if PlugOfCheckCanItem(6, ItemName, False, 0, 0) then Continue; //禁止物品规则(永不爆出) 20080729
          if (m_btRaceServer = RC_PLAYOBJECT) then begin
            if TPLAYOBJECT(self).CheckItemBindDieNoDrop(@m_UseItems[I]) then Continue; //人物装备绑定死亡不爆 20081127
          end else
            if (m_btRaceServer = RC_HEROOBJECT) then begin
              if THEROOBJECT(self).CheckItemBindDieNoDrop(@m_UseItems[I]) then Continue; //英雄装备绑定死亡不爆 20081127
            end;
          if PlugOfCheckCanItem(10, ItemName, False, 0, 0) then begin //禁止物品规则(死亡必爆) 20080729
            if DropItemDown(@m_UseItems[I], 3, True, True, nil, Self) then begin
              if DelList = nil then DelList := TStringList.Create;
              DelList.AddObject(ItemName {UserEngine.GetStdItemName(m_UseItems[I].wIndex)}, TObject(m_UseItems[I].MakeIndex)); //20110301 修改
              m_UseItems[I].wIndex := 0;
            end;
          end;
        end;
      end;

      for I := m_ItemList.Count - 1 downto 0 do begin //包裹不为空
        if m_ItemList.Count <= 0 then Break;
        UserItem := m_ItemList.Items[I];
        if UserItem <> nil then begin
          if (UserItem.AddValue[0] = 1) and (GetHoursCount(UserItem.MaxDate, Now) <= 0) then begin
            m_ItemList.Delete(I);
            Dispose(UserItem);
            Continue;
          end;
          if CheckItemValue(UserItem, 5) then Continue; //20110529 禁止爆出
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem <> nil then begin
            ItemName := StdItem.Name;
            if PlugOfCheckCanItem(6, ItemName, False, 0, 0) then Continue; //禁止物品规则(永不爆出) 20080729
            if (m_btRaceServer = RC_PLAYOBJECT) then begin
              if TPLAYOBJECT(self).CheckItemBindDieNoDrop(UserItem) then Continue; //人物装备绑定死亡不爆 20081127
            end else
              if (m_btRaceServer = RC_HEROOBJECT) then begin
                if THEROOBJECT(self).CheckItemBindDieNoDrop(UserItem) then Continue; //英雄装备绑定死亡不爆 20081127
              end;
            if PlugOfCheckCanItem(10, ItemName, False, 0, 0) then begin //禁止物品规则(死亡必爆) 20080729
              if DropItemDown(UserItem, 3, True, True, nil, Self) then begin
                if DelList = nil then DelList := TStringList.Create;
                DelList.AddObject(ItemName {UserEngine.GetStdItemName(UserItem.wIndex)}, TObject(UserItem.MakeIndex)); //20110301修改
                Dispose(pTUserItem(m_ItemList[I])); //20080618
                m_ItemList.Delete(I); //20080618
              end;
            end;
          end;
        end; //if m_ItemList[I] <> nil then begin
      end; //for
    end;
    if DelList <> nil then begin
      SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
    end;
  except
    on E: Exception do begin
      MainOutMessage(format('{%s} TBaseObject.DieDropItems', [g_sExceptionVer]));
    end;
  end;
end;
//换地图掉指定物品 20110301

procedure TBaseObject.ChangMapDropItems;
var
  I: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  ItemName: string;
  DelList: TStringList;
begin
  DelList := nil;
  try
    if ((m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYOBJECT))
      and (m_PEnvir.m_boChangMapDrops) and (m_PEnvir.m_ChangMapDropsList.Count > 0) then begin
      for I := Low(THumanUseItems) to High(THumanUseItems) do begin //9格装备+4格装备
        if (m_UseItems[I].AddValue[0] = 1) and (GetHoursCount(m_UseItems[I].MaxDate, Now) <= 0) then begin
          m_UseItems[I].wIndex := 0;
          Continue;
        end;
        StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
        if StdItem <> nil then begin
          ItemName := StdItem.Name;
          if not m_PEnvir.ChangMapDropStdItems(ItemName) then begin //换地图掉指定物品
            if DropItemDown(@m_UseItems[I], 3, True, True, g_FunctionNPC, Self) then begin
              if DelList = nil then DelList := TStringList.Create;
              DelList.AddObject(ItemName, TObject(m_UseItems[I].MakeIndex));
              m_UseItems[I].wIndex := 0;
            end;
          end;
        end;
      end;

      for I := m_ItemList.Count - 1 downto 0 do begin //包裹不为空
        if m_ItemList.Count <= 0 then Break;
        UserItem := m_ItemList.Items[I];
        if UserItem <> nil then begin
          if (UserItem.AddValue[0] = 1) and (GetHoursCount(UserItem.MaxDate, Now) <= 0) then begin
            m_ItemList.Delete(I);
            Dispose(UserItem);
            Continue;
          end;
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem <> nil then begin
            ItemName := StdItem.Name;
            if not m_PEnvir.ChangMapDropStdItems(ItemName) then begin //换地图掉指定物品
              if DropItemDown(UserItem, 3, True, True, g_FunctionNPC, Self) then begin
                if DelList = nil then DelList := TStringList.Create;
                DelList.AddObject(ItemName, TObject(UserItem.MakeIndex));
                m_ItemList.Delete(I);
                Dispose(UserItem);
              end;
            end;
          end;
        end; //if m_ItemList[I] <> nil then begin
      end; //for
    end;
    if DelList <> nil then SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
  except
    on E: Exception do begin
      MainOutMessage(format('{%s} TBaseObject.ChangMapDropItems', [g_sExceptionVer]));
    end;
  end;
end;

procedure TBaseObject.Die;
var
  boPK, guildwarkill: Boolean;
  tStr: string;
  tExp: LongWord;
  I: Integer;
  GroupHuman: TPlayObject;
  QuestNPC: TMerchant;
  tCheck, boCheck: Boolean;
  AttackBaseObject: TBaseObject;
  //BaseObject: TBaseObject;
  //HeroObject: THeroObject;
  Castle: TUserCastle;
  //n10: Integer;
  nBurstRate: Byte;
  nCheckCode: Byte;
  boGoto: Boolean;
resourcestring
  sExceptionMsg1 = '{%s} TBaseObject::Die 1 CheckCode:%d Name:%s';
  sExceptionMsg2 = '{%s} TBaseObject::Die 2 CheckCode:%d';
  sExceptionMsg3 = '{%s} TBaseObject::Die 3 CheckCode:%d';
begin
  try
    if m_boSuperMan then Exit;
    if m_boSupermanItem then Exit;
    m_boDeath := True;
    m_dwDeathTick := GetTickCount();
    nCheckCode := 0;
    if (m_Master <> nil) and (m_btRaceServer <> RC_HEROOBJECT) then begin //20080716 除英雄外
      m_ExpHitter := nil;
      m_LastHiter := nil;
    end;
    if (m_Master <> nil) and (m_btRaceServer = RC_HEROOBJECT) and (m_LastHiter <> nil) then begin //20080724 杀自己英雄
      if m_LastHiter = m_Master then begin
        m_ExpHitter := nil;
        m_LastHiter := nil;
      end;
    end;
    m_nIncSpell := 0;
    m_nIncHealth := 0;
    m_nIncHealing := 0;
    if (m_btRaceServer <> RC_PLAYOBJECT) and (m_btRaceServer <> RC_HEROOBJECT) and (m_LastHiter <> nil) then begin //20090311 修正：杀英雄也获得经验
      nCheckCode := 2;
      if g_Config.boMonSayMsg then MonsterSayMsg(m_LastHiter, s_Die); //怪物说
      boGoto := True;
      if m_btRaceServer = 134 then begin //是冰眼巨魔的分身,不执行任务脚本 20110104
        if TIceEyesTrollAvatar(Self).m_boIsCopyMon then boGoto := False;
      end;
      if (m_ExpHitter <> nil) then begin
        if m_ExpHitter.m_btRaceServer = RC_PLAYOBJECT then begin
          nCheckCode := 3;
          tExp := m_ExpHitter.CalcGetExp(m_Abil.Level, m_dwFightExp);
          if not g_Config.boVentureServer then begin
            nCheckCode := 4;
            if m_boIsNGMonster then //内功怪
              TPlayObject(m_ExpHitter).GainExp(tExp, 1)
            else TPlayObject(m_ExpHitter).GainExp(tExp, 0);
{$IF M2Version = 1}
            if m_boIsHeroPulsExpMon then begin //英雄经络怪 20090911
              TPlayObject(m_ExpHitter).HeroGetPulsExp(tExp);
            end;
{$IFEND}
          end;
          nCheckCode := 5;
          //是否执行任务脚本
          if m_PEnvir <> nil then begin //20090205
            if (m_PEnvir.IsCheapStuff) and (m_ExpHitter <> nil) then begin //20080827 修改
              boCheck := False;
              if (TPlayObject(m_ExpHitter).m_GroupOwner <> nil) and (TPlayObject(m_ExpHitter).m_GroupOwner.m_GroupMembers <> nil) and (TPlayObject(m_ExpHitter).m_GroupOwner.m_GroupMembers.Count > 0) then begin
                nCheckCode := 6;
                for I := 0 to TPlayObject(m_ExpHitter).m_GroupOwner.m_GroupMembers.Count - 1 do begin
                  GroupHuman := TPlayObject(TPlayObject(m_ExpHitter).m_GroupOwner.m_GroupMembers.Objects[I]);
                  if GroupHuman <> nil then begin
                    if not GroupHuman.m_boDeath and (m_ExpHitter.m_PEnvir = GroupHuman.m_PEnvir)
                      and (abs(m_ExpHitter.m_nCurrX - GroupHuman.m_nCurrX) <= 12) and
                      (abs(m_ExpHitter.m_nCurrX - GroupHuman.m_nCurrX) <= 12) then begin
                      if m_ExpHitter = GroupHuman then begin
                        tCheck := False;
                      end else begin
                        tCheck := True;
                      end;
                      nCheckCode := 66;
                      QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(GroupHuman, m_sCharName, '', tCheck));
                      if (QuestNPC <> nil) and (GroupHuman <> nil) then begin
                        if GroupHuman = m_ExpHitter then boCheck := True;
                        nCheckCode := 67;
                        if not GroupHuman.m_boGhost then begin
                          nCheckCode := 68;
                          if (GroupHuman.m_btRaceServer = RC_PLAYOBJECT) and boGoto then
                            QuestNPC.Click(GroupHuman);
                        end;
                      end;
                    end;
                  (*  if not GroupHuman.m_boDeath and (m_ExpHitter = GroupHuman) then begin//20110515 替换
                      nCheckCode:= 62;
                      boCheck := True;
                      if m_PEnvir <> nil then begin
                        nCheckCode:= 63;
                        QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(GroupHuman, m_sCharName, '', False));
                        nCheckCode:= 64;
                        if (QuestNPC <> nil) and (GroupHuman <> nil) then begin
                          nCheckCode:= 61;
                          if not GroupHuman.m_boGhost then begin
                            nCheckCode:= 70;
                            if (GroupHuman.m_btRaceServer = RC_PLAYOBJECT) and boGoto then//20090103
                              QuestNPC.Click(GroupHuman);//20081228
                          end;
                        end;
                      end;
                    end else
                    if not GroupHuman.m_boDeath and (m_ExpHitter.m_PEnvir = GroupHuman.m_PEnvir)
                      and (abs(m_ExpHitter.m_nCurrX - GroupHuman.m_nCurrX) <= 12) and
                      (abs(m_ExpHitter.m_nCurrX - GroupHuman.m_nCurrX) <= 12) and
                      (m_ExpHitter <> GroupHuman) then begin
                      tCheck := True;
                      nCheckCode:= 66;
                      QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(GroupHuman, m_sCharName, '', tCheck));
                      if (QuestNPC <> nil) and (GroupHuman <> nil) then begin
                        if GroupHuman = m_ExpHitter then boCheck := True;
                        nCheckCode:= 67;
                        if not GroupHuman.m_boGhost then begin
                          nCheckCode:= 68;
                          if (GroupHuman.m_btRaceServer = RC_PLAYOBJECT) and boGoto then//20090103
                            QuestNPC.Click(GroupHuman);//20081228
                        end;
                      end;
                    end;  *)
                  end;
                end; //for
              end;
            end;
            if not boCheck then begin
              nCheckCode := 7;
              if (m_ExpHitter <> nil) and (m_PEnvir <> nil) then begin //20081029
                nCheckCode := 71;
                QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(m_ExpHitter, m_sCharName, '', False));
                if (QuestNPC <> nil) and (m_ExpHitter <> nil) then begin
                  nCheckCode := 72;
                  if not m_ExpHitter.m_boGhost then begin
                    nCheckCode := 74;
                    if (m_ExpHitter.m_btRaceServer = RC_PLAYOBJECT) and boGoto then //20090103
                      QuestNPC.Click(TPlayObject(m_ExpHitter)); //20081228
                    nCheckCode := 75;
                  end;
                end;
              end;
            end;
          end;
        end else begin //if m_ExpHitter.m_btRaceServer = RC_PLAYOBJECT then begin
          if m_ExpHitter.m_Master <> nil then begin
            nCheckCode := 8;
            if m_ExpHitter.m_Master.m_btRaceServer = RC_HEROOBJECT then begin //英雄宝宝杀死怪,英雄获取经验  20080229
              m_ExpHitter.GainSlaveExp(m_Abil.Level); //宝宝升级 20080521
              tExp := m_ExpHitter.CalcGetExp(m_Abil.Level, m_dwFightExp);
              if not g_Config.boVentureServer then begin
                if m_ExpHitter.m_Master <> nil then begin //20080623 增加
                  if m_ExpHitter.m_Master.m_Master <> nil then begin //20080703
                    nCheckCode := 95;
                    if m_boIsNGMonster then //内功怪
                      TPlayObject(m_ExpHitter.m_Master.m_Master).GainExp(tExp, 1)
                    else TPlayObject(m_ExpHitter.m_Master.m_Master).GainExp(tExp, 0);
{$IF M2Version = 1}
                    if m_boIsHeroPulsExpMon then begin //英雄经络怪 20090911
                      TPlayObject(m_ExpHitter.m_Master.m_Master).HeroGetPulsExp(tExp);
                    end;
{$IFEND}
                    nCheckCode := 97;
                    if m_PEnvir <> nil then begin
                      if m_PEnvir.IsCheapStuff then begin //是否执行任务脚本 20080628
                        nCheckCode := 99;
                        QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(m_ExpHitter.m_Master.m_Master, m_sCharName, '', False));
                        if (QuestNPC <> nil) and (m_ExpHitter <> nil) then begin
                          nCheckCode := 98;
                          if (m_ExpHitter.m_Master <> nil) then begin
                            nCheckCode := 100;
                            if (m_ExpHitter.m_Master.m_Master <> nil) then begin
                              nCheckCode := 201;
                              if not m_ExpHitter.m_Master.m_Master.m_boGhost then begin
                                nCheckCode := 202;
                                if (m_ExpHitter.m_Master.m_Master.m_btRaceServer = RC_PLAYOBJECT) and boGoto then //20090103
                                  QuestNPC.Click(TPlayObject(m_ExpHitter.m_Master.m_Master)); //20081228
                                nCheckCode := 203;
                              end;
                            end;
                          end;
                        end;
                      end;
                    end;
                  end else begin
                    nCheckCode := 202;
                    THeroObject(m_ExpHitter.m_Master).GainExp(tExp);
{$IF M2Version <> 2}
                    nCheckCode := 203;
                    if m_boIsNGMonster then THeroObject(m_ExpHitter.m_Master).GetNGExp(tExp, 0); //取得内力经验 20081001
{$IFEND}
{$IF M2Version = 1}
                    if m_boIsHeroPulsExpMon then begin //英雄经络怪 20090911
                      THeroObject(m_ExpHitter.m_Master).GetPulsExp(tExp, 0);
                    end;
{$IFEND}
                  end;
                end;
              end;
            end else
              if (m_ExpHitter.m_Master.m_btRaceServer = RC_PLAYOBJECT) and
                (m_ExpHitter.m_btRaceServer <> RC_HEROOBJECT) then begin //人物宝宝杀死怪,除英雄外 20090208
                nCheckCode := 10;
                m_ExpHitter.GainSlaveExp(m_Abil.Level); //宝宝升级 20080521
                nCheckCode := 101;
                tExp := m_ExpHitter.CalcGetExp(m_Abil.Level, m_dwFightExp);
                if not g_Config.boVentureServer then begin
                  if m_ExpHitter.m_Master <> nil then begin
                    if m_boIsNGMonster then //20081224
                      TPlayObject(m_ExpHitter.m_Master).GainExp(tExp, 1)
                    else TPlayObject(m_ExpHitter.m_Master).GainExp(tExp, 0); //20080531
{$IF M2Version = 1}
                    if m_boIsHeroPulsExpMon then begin //英雄经络怪 20090911
                      TPlayObject(m_ExpHitter.m_Master).HeroGetPulsExp(tExp);
                    end;
{$IFEND}
                    nCheckCode := 103;
                    if m_PEnvir <> nil then begin
                      if m_PEnvir.IsCheapStuff then begin //是否执行任务脚本 20080628
                        nCheckCode := 104;
                        QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(m_ExpHitter.m_Master, m_sCharName, '', False));
                        if (QuestNPC <> nil) and (m_ExpHitter <> nil) then begin
                          nCheckCode := 106;
                          if m_ExpHitter.m_Master <> nil then begin
                            nCheckCode := 108;
                            if not m_ExpHitter.m_Master.m_boGhost then begin
                              nCheckCode := 109;
                              if (m_ExpHitter.m_Master.m_btRaceServer = RC_PLAYOBJECT) and boGoto then //20090103
                                QuestNPC.Click(TPlayObject(m_ExpHitter.m_Master)); //20081228
                              nCheckCode := 110;
                            end;
                          end;
                        end;
                      end;
                    end;
                  end;
                end;
              end else
                if m_ExpHitter.m_btRaceServer = RC_HEROOBJECT then begin //英雄获取经验
                  nCheckCode := 11;
                  tExp := m_ExpHitter.CalcGetExp(m_Abil.Level, m_dwFightExp);
                  nCheckCode := 117;
                  if not g_Config.boVentureServer then begin
                    if m_ExpHitter.m_Master <> nil then begin
                      nCheckCode := 111;
                      if m_boIsNGMonster then //20081224
                        TPlayObject(m_ExpHitter.m_Master).GainExp(tExp, 1)
                      else TPlayObject(m_ExpHitter.m_Master).GainExp(tExp, 0); //20080531
{$IF M2Version = 1}
                      if m_boIsHeroPulsExpMon then begin //英雄经络怪 20090911
                        TPlayObject(m_ExpHitter.m_Master).HeroGetPulsExp(tExp);
                      end;
{$IFEND}
                      nCheckCode := 112;
                  {if m_PEnvir <> nil then begin//20110820 替换
                    if m_PEnvir.IsCheapStuff then begin//是否执行任务脚本 20080628
                      nCheckCode:= 114;
                      QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(m_ExpHitter.m_Master, m_sCharName, '', False));
                      if (QuestNPC <> nil) and (m_ExpHitter <> nil) then begin
                        nCheckCode:= 115;
                        if (m_ExpHitter.m_Master <> nil) then begin
                          nCheckCode:= 116;
                          if not m_ExpHitter.m_Master.m_boGhost then begin
                            nCheckCode:= 118;
                            if (m_ExpHitter.m_Master.m_btRaceServer = RC_PLAYOBJECT) and boGoto then//20090103
                              QuestNPC.Click(TPlayObject(m_ExpHitter.m_Master));//20081228
                            nCheckCode:= 119;
                          end;
                        end;
                      end;
                    end;
                  end;}

                  //是否执行任务脚本(英雄杀怪，可全队触) 20110820
                      if m_PEnvir <> nil then begin
                        boCheck := False;
                        if (m_PEnvir.IsCheapStuff) and (m_ExpHitter.m_Master <> nil) then begin
                          if (TPlayObject(m_ExpHitter.m_Master).m_GroupOwner <> nil) and
                            (TPlayObject(m_ExpHitter.m_Master).m_GroupOwner.m_GroupMembers <> nil) and
                            (TPlayObject(m_ExpHitter.m_Master).m_GroupOwner.m_GroupMembers.Count > 0) then begin
                            for I := 0 to TPlayObject(m_ExpHitter.m_Master).m_GroupOwner.m_GroupMembers.Count - 1 do begin
                              GroupHuman := TPlayObject(TPlayObject(m_ExpHitter.m_Master).m_GroupOwner.m_GroupMembers.Objects[I]);
                              if GroupHuman <> nil then begin
                                if not GroupHuman.m_boDeath and (m_ExpHitter.m_Master.m_PEnvir = GroupHuman.m_PEnvir)
                                  and (abs(m_ExpHitter.m_Master.m_nCurrX - GroupHuman.m_nCurrX) <= 12) and
                                  (abs(m_ExpHitter.m_Master.m_nCurrX - GroupHuman.m_nCurrX) <= 12) then begin
                                  if m_ExpHitter.m_Master = GroupHuman then begin
                                    tCheck := False;
                                  end else begin
                                    tCheck := True;
                                  end;
                                  nCheckCode := 114;
                                  QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(GroupHuman, m_sCharName, '', tCheck));
                                  if (QuestNPC <> nil) and (GroupHuman <> nil) then begin
                                    if GroupHuman = m_ExpHitter.m_Master then boCheck := True;
                                    nCheckCode := 115;
                                    if not GroupHuman.m_boGhost then begin
                                      nCheckCode := 116;
                                      if (GroupHuman.m_btRaceServer = RC_PLAYOBJECT) and boGoto then
                                        QuestNPC.Click(GroupHuman);
                                    end;
                                  end;
                                end;
                              end;
                            end; //for
                          end;
                        end;
                        if not boCheck then begin
                          nCheckCode := 117;
                          if (m_ExpHitter.m_Master <> nil) and (m_PEnvir <> nil) then begin
                            nCheckCode := 118;
                            QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(m_ExpHitter.m_Master, m_sCharName, '', False));
                            if (QuestNPC <> nil) and (m_ExpHitter.m_Master <> nil) then begin
                              nCheckCode := 119;
                              if not m_ExpHitter.m_Master.m_boGhost then begin
                                nCheckCode := 120;
                                if (m_ExpHitter.m_Master.m_btRaceServer = RC_PLAYOBJECT) and boGoto then
                                  QuestNPC.Click(TPlayObject(m_ExpHitter.m_Master));
                                nCheckCode := 121;
                              end;
                            end;
                          end;
                        end;
                      end;
                    end;
                  end;
                end else begin
                  nCheckCode := 12;
                  m_ExpHitter.GainSlaveExp(m_Abil.Level); //宝宝升级
                  nCheckCode := 121;
                  tExp := m_ExpHitter.m_Master.CalcGetExp(m_Abil.Level, m_dwFightExp);
                  nCheckCode := 122;
                  if not g_Config.boVentureServer then begin
                    if m_ExpHitter.m_Master <> nil then begin
                      nCheckCode := 123;
                      if m_boIsNGMonster then //20081224
                        TPlayObject(m_ExpHitter.m_Master).GainExp(tExp, 1)
                      else TPlayObject(m_ExpHitter.m_Master).GainExp(tExp, 0); //20080531
{$IF M2Version = 1}
                      if m_boIsHeroPulsExpMon then begin //英雄经络怪 20090911
                        TPlayObject(m_ExpHitter.m_Master).HeroGetPulsExp(tExp);
                      end;
{$IFEND}
                      nCheckCode := 124;
                      if m_PEnvir <> nil then begin
                        nCheckCode := 125;
                        if m_PEnvir.IsCheapStuff then begin //是否执行任务脚本 20080629
                          nCheckCode := 126;
                          QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(m_ExpHitter.m_Master, m_sCharName, '', False));
                          nCheckCode := 127;
                          if (QuestNPC <> nil) and (m_ExpHitter <> nil) then begin
                            nCheckCode := 128;
                            if (m_ExpHitter.m_Master <> nil) then begin
                              nCheckCode := 129;
                              if not m_ExpHitter.m_Master.m_boGhost then begin
                                nCheckCode := 130;
                                if (m_ExpHitter.m_Master.m_btRaceServer = RC_PLAYOBJECT) and boGoto then //20090103
                                  QuestNPC.Click(TPlayObject(m_ExpHitter.m_Master)); //20081228
                                nCheckCode := 131;
                              end;
                            end;
                          end;
                        end;
                      end;
                    end;
                  end;
                end;
          end;
        end;
      end else begin
        if m_LastHiter <> nil then begin //20080531
          if m_LastHiter.m_btRaceServer = RC_PLAYOBJECT then begin
            nCheckCode := 13;
            tExp := m_LastHiter.CalcGetExp(m_Abil.Level, m_dwFightExp);
            if not g_Config.boVentureServer then begin
              if m_boIsNGMonster then //20081224
                TPlayObject(m_LastHiter).GainExp(tExp, 1)
              else TPlayObject(m_LastHiter).GainExp(tExp, 0);
{$IF M2Version = 1}
              if m_boIsHeroPulsExpMon then begin //英雄经络怪 20090911
                TPlayObject(m_LastHiter).HeroGetPulsExp(tExp);
              end;
{$IFEND}
            end;
          end else
            if (m_LastHiter.m_Master <> nil) and (m_LastHiter.m_btRaceServer = 135) then begin //20090106 修正魔王岭打怪，有时不得经验
              if m_LastHiter.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin
                nCheckCode := 131;
                tExp := m_LastHiter.CalcGetExp(m_Abil.Level, m_dwFightExp);
                if not g_Config.boVentureServer then begin
                  if m_boIsNGMonster then
                    TPlayObject(m_LastHiter.m_Master).GainExp(tExp, 1)
                  else TPlayObject(m_LastHiter.m_Master).GainExp(tExp, 0);
{$IF M2Version = 1}
                  if m_boIsHeroPulsExpMon then begin //英雄经络怪 20090911
                    TPlayObject(m_LastHiter.m_Master).HeroGetPulsExp(tExp);
                  end;
{$IFEND}
                end;
              end;
            end;
        end; //20080531
      end;
    end;
    if (g_Config.boMonSayMsg) and (m_btRaceServer = RC_PLAYOBJECT) and (m_LastHiter <> nil) then begin
      nCheckCode := 14;
      m_LastHiter.MonsterSayMsg(Self, s_KillHuman);
    end;
    nCheckCode := 151;
    //宝宝杀死怪触发    魔王岭,135宝宝杀怪主人记数,
    if (m_LastHiter <> nil) then begin
      nCheckCode := 152;
      if (m_LastHiter.m_Master <> nil) then begin //20090107
        nCheckCode := 153;
        if (m_LastHiter.m_Master.m_btRaceServer = RC_PLAYOBJECT) and (m_LastHiter.m_btRaceServer = 135) then begin {20080208 增加条件}
          nCheckCode := 154;
          TPlayObject(m_LastHiter.m_Master).KillMissionMob;
        end;
      end;
    end;
    nCheckCode := 16;
    //执行杀怪触发
    if (m_LastHiter <> nil) then begin
      nCheckCode := 161;
      if (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) then TPlayObject(m_LastHiter).KillMonsterFunc(self)
      else if (m_LastHiter.m_btRaceServer = RC_HEROOBJECT) and
              (m_LastHiter.m_Master <> nil) then TPlayObject(m_LastHiter.m_Master).KillMonsterFunc(self) //20081108 英雄杀怪,触发
      else if (m_LastHiter.m_Master <> nil) then begin
        nCheckCode := 162;
        if (m_LastHiter.m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
          nCheckCode := 163;
          TPlayObject(m_LastHiter.m_Master).KillMonsterFunc(self);
        end else
          if (m_LastHiter.m_Master.m_btRaceServer = RC_HEROOBJECT) then begin
            nCheckCode := 164;
            if m_LastHiter.m_Master.m_Master <> nil then TPlayObject(m_LastHiter.m_Master.m_Master).KillMonsterFunc(self);
          end;
      end;
    end;
    nCheckCode := 17;
    if (m_btRaceServer <> RC_HEROOBJECT) and (m_btRaceServer <> 156) then m_Master := nil;
  except
    on E: Exception do begin
      MainOutMessage(format(sExceptionMsg1, [g_sExceptionVer, nCheckCode, m_sCharName]));
    end;
  end;

  try
    nCheckCode := 183;
    {执行杀人和死亡触发}
    if {(m_LastHiter <> nil) and }(m_btRaceServer = RC_PLAYOBJECT) then TPlayObject(Self).DieGotoLable(); //20090716 修改
    nCheckCode := 181;
    boPK := False;
    if m_PEnvir <> nil then begin //20090104
      nCheckCode := 182;
      if (not g_Config.boVentureServer) and (not m_PEnvir.m_boFightZone) and
        (not m_PEnvir.m_boFight3Zone) and (not m_PEnvir.m_boFight2Zone) and
        (not m_PEnvir.m_boFight4Zone) and (not m_PEnvir.m_boFight5Zone) then begin //20090318
        nCheckCode := 191;
        //20080716 增加杀英雄
        if ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT))
          and (m_LastHiter <> nil) and (PKLevel < 2) then begin //英雄除行会战外 20080726
          nCheckCode := 192;
          if (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) or (m_LastHiter.m_btRaceServer = RC_NPC)
            or ((m_LastHiter.m_btRaceServer = RC_HEROOBJECT) and (not m_boInFreePKArea)) then begin //允许NPC杀死人物 20080721
            boPK := True;
          end;
          nCheckCode := 193;
          if (m_LastHiter.m_Master <> nil) and (m_LastHiter.m_btRaceServer <> RC_HEROOBJECT)
            and (m_LastHiter.m_btRaceServer <> 156) then begin //朱火弹除外 20110721
            if (m_LastHiter.m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
              nCheckCode := 20;
              m_LastHiter := m_LastHiter.m_Master;
              boPK := True;
            end;
          end;
        end;
      end;
    end;
    nCheckCode := 21;
    if (m_LastHiter <> nil) and boPK then begin //PK不红名
      if m_LastHiter.m_PEnvir <> nil then begin //20090107 增加
        if m_LastHiter.m_PEnvir.m_boFIGHTPK then m_LastHiter.m_boPKFlag := True; //m_boPKFlag = True 属于正当防卫
      end;
    end;
    nCheckCode := 210;
    if m_PEnvir.m_boFight4Zone and (m_btRaceServer = RC_PLAYOBJECT) then begin //挑战地图 20080706
      nCheckCode := 211;
      if TPLAYOBJECT(Self).m_boChallengeing and (TPLAYOBJECT(Self).m_ChallengeCreat <> nil) then begin
        if TPLAYOBJECT(Self).m_ChallengeCreat.m_PEnvir.m_boFight4Zone then
          TPLAYOBJECT(Self).m_ChallengeCreat.MapRandomMove(TPLAYOBJECT(Self).m_ChallengeCreat.m_sLastMapName, 0);
        SysMsg(g_sChallengeLoseMsg {'您挑战输了!'}, c_Blue, t_Hint);
        nCheckCode := 212;
        TPLAYOBJECT(Self).m_ChallengeCreat.SysMsg(g_sChallengeWinMsg {'您挑战获胜!'}, c_Blue, t_Hint);
        nCheckCode := 213;
        TPLAYOBJECT(Self).m_ChallengeCreat.WinGetChallengeItems; //取胜后得到挑战的抵押物品
      end;
    end;
    nCheckCode := 22;
    if boPK and (m_LastHiter <> nil) then begin
      guildwarkill := False;
      if (m_MyGuild <> nil) and (m_LastHiter.m_MyGuild <> nil) then begin
        if GetGuildRelation(Self, m_LastHiter) = 2 then guildwarkill := True;
      end;
      nCheckCode := 23;
      Castle := g_CastleManager.InCastleWarArea(Self);
      if ((Castle <> nil) and Castle.m_boUnderWar) or (m_boInFreePKArea) then guildwarkill := True; //攻城或行会战
      if (m_LastHiter.m_btRaceServer = RC_HEROOBJECT) and (not guildwarkill) then begin //20080928 英雄攻城或行会战杀人不加PK值
        if (m_LastHiter.m_Master <> nil) then begin
          if m_LastHiter.m_Master.m_boInFreePKArea then guildwarkill := True;
          if (m_MyGuild <> nil) and (m_LastHiter.m_Master.m_MyGuild <> nil) and (not guildwarkill) then begin //检查主人是否是在行会战 20080928
            if GetGuildRelation(Self, m_LastHiter.m_Master) = 2 then guildwarkill := True;
          end;
        end;
      end;
      if (m_btRaceServer = RC_HEROOBJECT) and (not guildwarkill) then begin
        if (m_Master <> nil) then begin
          if m_Master.m_boInFreePKArea then guildwarkill := True; //20081209
          if (m_Master.m_MyGuild <> nil) and (m_LastHiter.m_MyGuild <> nil) and (not guildwarkill) then begin //检查主人是否是在行会战 20080928
            if GetGuildRelation(m_Master, m_LastHiter) = 2 then guildwarkill := True;
          end;
          if (m_LastHiter.m_Master <> nil) then begin //20081209 行会战,英雄杀英雄不加PK值
            if (m_Master.m_MyGuild <> nil) and (m_LastHiter.m_Master.m_MyGuild <> nil) and (not guildwarkill) then begin
              if GetGuildRelation(m_Master, m_LastHiter.m_Master) = 2 then guildwarkill := True;
            end;
          end;
        end;
      end;

      //=================================================================
      if (not guildwarkill) and (not m_PEnvir.m_boFight4Zone) and (not m_PEnvir.m_boFight5Zone) then begin //20090318
        nCheckCode := 24;
        if (g_Config.boKillHumanWinLevel or g_Config.boKillHumanWinExp or m_PEnvir.m_boPKWINLEVEL or m_PEnvir.m_boFIGHTPK or m_PEnvir.m_boPKWINEXP) and ((m_LastHiter.m_btRaceServer = RC_PLAYOBJECT)) then begin
          TPlayObject(Self).PKDie(TPlayObject(m_LastHiter));
        end else begin
          if not m_LastHiter.IsGoodKilling(Self) then begin
            nCheckCode := 25;
            if g_Config.boLevelLessNotIncPKPoint then begin //等于小于指定值不增加PK值功能 20100418
              if m_Abil.Level >= g_Config.nNotIncPKPointLevel then begin
                m_LastHiter.IncPkPoint(g_Config.nKillHumanAddPKPoint {100}); //PK值增加
                if m_LastHiter.m_btRaceServer <> RC_HEROOBJECT then begin //20080721
                  nCheckCode := 251;
                  if (m_btRaceServer = RC_HEROOBJECT) then begin
                    if g_Config.boPKHeroDieAddBodyLuck then begin //杀英雄增加诅咒值 20090414
                      m_LastHiter.SysMsg(g_sYouMurderedMsg {'你犯了谋杀罪！！！'}, c_Red, t_Hint);
                      m_LastHiter.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint {500});
                      if PKLevel < 1 then
                        if Random(g_Config.nKillHumanWeaponUnlockRate {5}) = 0 then m_LastHiter.MakeWeaponUnlock;
                    end;
                  end else begin
                    m_LastHiter.SysMsg(g_sYouMurderedMsg {'你犯了谋杀罪！！！'}, c_Red, t_Hint);
                    m_LastHiter.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint {500});
                    if PKLevel < 1 then
                      if Random(g_Config.nKillHumanWeaponUnlockRate {5}) = 0 then m_LastHiter.MakeWeaponUnlock;
                  end;
                end else begin
                  nCheckCode := 252;
                  if (m_LastHiter.m_Master <> nil) then begin
                    if (m_btRaceServer = RC_HEROOBJECT) then begin
                      if g_Config.boPKHeroDieAddBodyLuck then begin //杀英雄增加诅咒值
                        nCheckCode := 253;
                        m_LastHiter.m_Master.SysMsg(g_sYouMurderedMsg {'你犯了谋杀罪！！！'}, c_Red, t_Hint); //英雄杀人,提示主人杀人 20080910
                        m_LastHiter.m_Master.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint {500});
                        if PKLevel < 1 then
                          if Random(g_Config.nKillHumanWeaponUnlockRate {5}) = 0 then m_LastHiter.m_Master.MakeWeaponUnlock;
                      end;
                    end else begin
                      nCheckCode := 253;
                      m_LastHiter.m_Master.SysMsg(g_sYouMurderedMsg {'你犯了谋杀罪！！！'}, c_Red, t_Hint); //英雄杀人,提示主人杀人 20080910
                      m_LastHiter.m_Master.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint {500});
                      if PKLevel < 1 then
                        if Random(g_Config.nKillHumanWeaponUnlockRate {5}) = 0 then m_LastHiter.m_Master.MakeWeaponUnlock;
                    end;
                  end;
                end;
                nCheckCode := 254;
                if g_Config.boUnKnowHum and m_LastHiter.IsUsesZhuLi then //20080424 带上斗笠,不显示人的真正名字
                  SysMsg(Format_ToStr(g_sYouKilledByMsg, ['神秘人']), c_Red, t_Hint)
                else begin
                  nCheckCode := 255;
                  if m_LastHiter.m_btRaceServer <> RC_HEROOBJECT then
                    SysMsg(Format_ToStr(g_sYouKilledByMsg, [m_LastHiter.m_sCharName]), c_Red, t_Hint)
                  else begin //20080915 英雄杀人,提示主人杀的
                    nCheckCode := 249;
                    if (m_LastHiter.m_Master <> nil) then begin
                      nCheckCode := 248;
                      if m_btRaceServer <> RC_HEROOBJECT then
                        SysMsg(Format_ToStr(g_sYouKilledByMsg, [m_LastHiter.m_Master.m_sCharName]), c_Red, t_Hint)
                      else THEROOBJECT(Self).SysMsg(Format_ToStr('(英雄)' + g_sYouKilledByMsg, [m_LastHiter.m_Master.m_sCharName]), c_Red, t_Hint)
                    end;
                  end;
                end;
              end;
            end else begin
              m_LastHiter.IncPkPoint(g_Config.nKillHumanAddPKPoint {100}); //PK值增加
              if m_LastHiter.m_btRaceServer <> RC_HEROOBJECT then begin //20080721
                nCheckCode := 251;
                if (m_btRaceServer = RC_HEROOBJECT) then begin
                  if g_Config.boPKHeroDieAddBodyLuck then begin //杀英雄增加诅咒值 20090414
                    m_LastHiter.SysMsg(g_sYouMurderedMsg {'你犯了谋杀罪！！！'}, c_Red, t_Hint);
                    m_LastHiter.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint {500});
                    if PKLevel < 1 then
                      if Random(g_Config.nKillHumanWeaponUnlockRate {5}) = 0 then m_LastHiter.MakeWeaponUnlock;
                  end;
                end else begin
                  m_LastHiter.SysMsg(g_sYouMurderedMsg {'你犯了谋杀罪！！！'}, c_Red, t_Hint);
                  m_LastHiter.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint {500});
                  if PKLevel < 1 then
                    if Random(g_Config.nKillHumanWeaponUnlockRate {5}) = 0 then m_LastHiter.MakeWeaponUnlock;
                end;
              end else begin
                nCheckCode := 252;
                if (m_LastHiter.m_Master <> nil) then begin
                  if (m_btRaceServer = RC_HEROOBJECT) then begin
                    if g_Config.boPKHeroDieAddBodyLuck then begin //杀英雄增加诅咒值 20090414
                      nCheckCode := 253;
                      m_LastHiter.m_Master.SysMsg(g_sYouMurderedMsg {'你犯了谋杀罪！！！'}, c_Red, t_Hint); //英雄杀人,提示主人杀人 20080910
                      m_LastHiter.m_Master.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint {500});
                      if PKLevel < 1 then
                        if Random(g_Config.nKillHumanWeaponUnlockRate {5}) = 0 then m_LastHiter.m_Master.MakeWeaponUnlock;
                    end;
                  end else begin
                    nCheckCode := 253;
                    m_LastHiter.m_Master.SysMsg(g_sYouMurderedMsg {'你犯了谋杀罪！！！'}, c_Red, t_Hint); //英雄杀人,提示主人杀人 20080910
                    m_LastHiter.m_Master.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint {500});
                    if PKLevel < 1 then
                      if Random(g_Config.nKillHumanWeaponUnlockRate {5}) = 0 then m_LastHiter.m_Master.MakeWeaponUnlock;
                  end;
                end;
              end;
              nCheckCode := 254;
              if g_Config.boUnKnowHum and m_LastHiter.IsUsesZhuLi then //20080424 带上斗笠,不显示人的真正名字
                SysMsg(Format_ToStr(g_sYouKilledByMsg, ['神秘人']), c_Red, t_Hint)
              else begin
                nCheckCode := 255;
                if m_LastHiter.m_btRaceServer <> RC_HEROOBJECT then
                  SysMsg(Format_ToStr(g_sYouKilledByMsg, [m_LastHiter.m_sCharName]), c_Red, t_Hint)
                else begin //20080915 英雄杀人,提示主人杀的
                  nCheckCode := 249;
                  if (m_LastHiter.m_Master <> nil) then begin
                    nCheckCode := 248;
                    if m_btRaceServer <> RC_HEROOBJECT then
                      SysMsg(Format_ToStr(g_sYouKilledByMsg, [m_LastHiter.m_Master.m_sCharName]), c_Red, t_Hint)
                    else THEROOBJECT(Self).SysMsg(Format_ToStr('(英雄)' + g_sYouKilledByMsg, [m_LastHiter.m_Master.m_sCharName]), c_Red, t_Hint)
                  end;
                end;
              end;
            end;
          end else m_LastHiter.SysMsg(g_sYouProtectedByLawOfDefense {'[你受到正当规则保护。]'}, c_Green, t_Hint);
        end;
        nCheckCode := 26;
        //检查攻击人是否用了着经验或等级装备
        if m_LastHiter.m_btRaceServer = RC_PLAYOBJECT then begin
          if m_LastHiter.m_dwPKDieLostExp > 0 then begin
            if m_Abil.nExp >= m_LastHiter.m_dwPKDieLostExp then begin
              Dec(m_Abil.nExp, m_LastHiter.m_dwPKDieLostExp);
            end else m_Abil.nExp := 0;
          end;
          nCheckCode := 27;
          if m_LastHiter.m_nPKDieLostLevel > 0 then begin
            if m_Abil.Level >= m_LastHiter.m_nPKDieLostLevel then begin
              Dec(m_Abil.Level, m_LastHiter.m_nPKDieLostLevel);
            end else m_Abil.Level := 0;
          end;
        end;
      end;
      //=================================================================
    end;
  except   
    MainOutMessage(format(sExceptionMsg2, [g_sExceptionVer, nCheckCode]));
  end;

  try
    nCheckCode := 28;
    DieDropItems; //死亡必掉物品 20080614
    nBurstRate := 0;
    if (not m_PEnvir.m_boFightZone) and (not m_PEnvir.m_boFight3Zone) and (not m_boAnimal) then begin
      nCheckCode := 39;
      //AttackBaseObject := m_ExpHitter;
      if (m_ExpHitter <> nil) then begin
        nBurstRate := m_ExpHitter.m_nBurstRate; //20091227
        AttackBaseObject := m_ExpHitter; //20090107 换位置
        if (m_ExpHitter.m_Master <> nil) then begin
          AttackBaseObject := m_ExpHitter.m_Master;
          if (m_ExpHitter.m_Master.m_btRaceServer = RC_HEROOBJECT) and
            (m_ExpHitter.m_Master.m_Master <> nil) then AttackBaseObject := m_ExpHitter.m_Master.m_Master; //20080309 英雄宝宝打到的物品,英雄主人可以捡
        end;
      end;
      nCheckCode := 29;
      if m_btRaceServer = RC_HEROOBJECT then begin //英雄死亡
        if not m_boNoItem then begin {修改日期2004/07/21，增加此行，允许设置 m_boNoItem 后人物死亡不掉物品}
          if AttackBaseObject <> nil then begin //20080602  英雄打死英雄也能掉装备
            nCheckCode := 48;
            if not AttackBaseObject.m_boGhost then begin //20090422 增加
              if (g_Config.boHeroKillByHumanDropUseItem and ((AttackBaseObject.m_btRaceServer = RC_PLAYOBJECT) or (AttackBaseObject.m_btRaceServer = RC_HEROOBJECT)))
                or (g_Config.boHeroKillByMonstDropUseItem and (AttackBaseObject.m_btRaceServer <> RC_PLAYOBJECT)) then begin
                nCheckCode := 51;
                DropUseItems(nil, nBurstRate); //20091227 修改
              end;
            end;
          end else begin
            nCheckCode := 49;
            DropUseItems(nil, 0); //20091129 修改
          end;
          if g_Config.boHeroDieScatterBag then ScatterBagItems(nil);
        end;
      end else
        if m_btRaceServer <> RC_PLAYOBJECT then begin
          nCheckCode := 30;
          if AttackBaseObject <> nil then DropUseItems(AttackBaseObject, nBurstRate); //掉装备 20091227 修改
          nCheckCode := 31;
          if m_btRaceServer = 136 then begin //20080127 魔王岭
            if (m_Master = nil) and (not m_boNoItem) then begin
              if m_LastHiter <> nil then begin //20101207 增加
                nCheckCode := 132;
                if m_LastHiter.m_Master <> nil then ScatterBagItems(m_LastHiter.m_Master) //掉物品
                else ScatterBagItems(m_LastHiter);
              end;
            end;
          end else begin
            nCheckCode := 33;
            if (m_Master = nil) and (not m_boNoItem) then begin
              nCheckCode := 47;
              if AttackBaseObject <> nil then ScatterBagItems(AttackBaseObject) //掉物品
              else if (m_wStatusTimeArr[POISON_DECHEALTH] <> 0) or (m_wStatusTimeArr[POISON_DAMAGEARMOR] <> 0) then begin //20090208 攻击目标不存在时，中毒死的，也掉物品
                if m_LastHiter <> nil then begin
                  ScatterBagItems(m_LastHiter);
                end else ScatterBagItems(nil); //掉物品 20090208
              end else begin //20090415 增加
                if m_LastHiter <> nil then begin
                  ScatterBagItems(m_LastHiter);
                end else ScatterBagItems(nil);
              end;
            end;
          end;
          nCheckCode := 34;
          if (m_btRaceServer >= RC_ANIMAL) and (m_Master = nil) and (not m_boNoItem) and (AttackBaseObject <> nil) then begin //20080812 修改
            nCheckCode := 39;
            if (AttackBaseObject.m_btRaceServer = RC_PLAYOBJECT) and (g_Config.boDropGoldToPlayBag) then begin
              nCheckCode := 40;
              if TPlayObject(AttackBaseObject).IncGold(m_nGold) then begin
                nCheckCode := 41;
                TPlayObject(AttackBaseObject).GoldChanged();
              end else begin
                nCheckCode := 42;
                ScatterGolds(AttackBaseObject);
              end;
            end else begin //如果是宝宝打到的金币,直接进入主人包裹 20080615
              nCheckCode := 43;
              if (AttackBaseObject.m_Master <> nil) and (AttackBaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT) and (g_Config.boDropGoldToPlayBag) then begin
                nCheckCode := 44;
                if TPlayObject(AttackBaseObject.m_Master).IncGold(m_nGold) then begin
                  nCheckCode := 45;
                  TPlayObject(AttackBaseObject.m_Master).GoldChanged();
                end else begin
                  nCheckCode := 46;
                  ScatterGolds(AttackBaseObject); //将金币分散到地上
                end;
              end else ScatterGolds(AttackBaseObject);
            end;
          end;
        end else begin
          if not m_boNoItem then begin {修改日期2004/07/21，增加此行，允许设置 m_boNoItem 后人物死亡不掉物品}
            nCheckCode := 35;
            if AttackBaseObject <> nil then begin
              if (g_Config.boKillByHumanDropUseItem and (AttackBaseObject.m_btRaceServer = RC_PLAYOBJECT)) or (g_Config.boKillByMonstDropUseItem and (AttackBaseObject.m_btRaceServer <> RC_PLAYOBJECT)) then
                DropUseItems(nil, nBurstRate); //20091227 修改
            end else begin
              DropUseItems(nil, 0);
            end;
            if g_Config.boDieScatterBag then ScatterBagItems(nil);
            if g_Config.boDieDropGold then ScatterGolds(nil);
          end;
          AddBodyLuck(-(50 - (50 - m_Abil.Level * 5)));
        end;
    end;
    nCheckCode := 36;
    if m_PEnvir.m_boFight3Zone then begin //行会战争地图
      Inc(m_nFightZoneDieCount); //在行会战争地图中死亡次数
      if m_MyGuild <> nil then begin
        TGUild(m_MyGuild).TeamFightWhoDead(m_sCharName);
      end;
      if (m_LastHiter <> nil) then begin
        if m_LastHiter.m_btRaceServer = RC_HEROOBJECT then begin //行会战杀人增加英雄忠诚度 20080214
          THeroObject(m_LastHiter).m_nLoyal := THeroObject(m_LastHiter).m_nLoyal + g_Config.nGuildIncLoyal;
          if THeroObject(m_LastHiter).m_nLoyal > 10000 then THeroObject(m_LastHiter).m_nLoyal := 10000;
        end;
        if (m_LastHiter.m_MyGuild <> nil) and (m_MyGuild <> nil) then begin
          TGUild(m_LastHiter.m_MyGuild).TeamFightWhoWinPoint(m_LastHiter.m_sCharName, 100);
          tStr := TGUild(m_LastHiter.m_MyGuild).sGuildName + ':' +
            IntToStr(TGUild(m_LastHiter.m_MyGuild).nContestPoint) + '  ' +
            TGUild(m_MyGuild).sGuildName + ':' +
            IntToStr(TGUild(m_MyGuild).nContestPoint);
          UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000, g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, '- ' + tStr);
        end;
      end;
    end;
    nCheckCode := 246;
    if m_btRaceServer = RC_HEROOBJECT then m_btLastOutStatus := 1; //20080404 增加英雄退出状态 1为死亡退出
    if m_btRaceServer = RC_PLAYOBJECT then begin
      m_btLastOutStatus := 1; //2006-01-12 增加人物最后退出状态 1为死亡退出
      nCheckCode := 247;
      //人物死亡立即退组，以防止组队刷经验
      if TPlayObject(Self).m_GroupOwner <> nil then TPlayObject(Self).m_GroupOwner.DelMember(TPlayObject(Self));
      nCheckCode := 245;
      if m_LastHiter <> nil then begin
        if m_LastHiter.m_btRaceServer = RC_PLAYOBJECT then tStr := m_LastHiter.m_sCharName
        else tStr := '#' + m_LastHiter.m_sCharName;
      end else tStr := '####';
      nCheckCode := 244;
      AddGameDataLog('19' + #9 + m_sMapName + #9 +
        IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
        m_sCharName + #9 + 'FZ-' + BoolToIntStr(m_PEnvir.m_boFightZone) +
        '_F3-' + BoolToIntStr(m_PEnvir.m_boFight3Zone) + #9 +
        '0' + #9 + '1' + #9 + tStr);
    end;
    nCheckCode := 38;
    //减少地图上怪物计数
    if (m_Master = nil) and (not m_boDelFormMaped) then begin
      m_PEnvir.DelObjectCount(Self);
      m_boDelFormMaped := True;
    end;
    SendRefMsg(RM_DEATH, m_btDirection, m_nCurrX, m_nCurrY, 1, '');
  except   
    MainOutMessage(format(sExceptionMsg3, [g_sExceptionVer, nCheckCode]));
  end;
end;

procedure TPlayObject.PKDie(PlayObject: TPlayObject);
var
  nWinLevel, nLostLevel, nWinExp, nLostExp: Integer;
  boWinLEvel, boLostLevel, boWinExp, boLostExp: Boolean;
begin
  nWinLevel := g_Config.nKillHumanWinLevel;
  nLostLevel := g_Config.nKilledLostLevel;
  nWinExp := g_Config.nKillHumanWinExp;
  nLostExp := g_Config.nKillHumanLostExp;

  boWinLEvel := g_Config.boKillHumanWinLevel;
  boLostLevel := g_Config.boKilledLostLevel;
  boWinExp := g_Config.boKillHumanWinExp;
  boLostExp := g_Config.boKilledLostExp;

  if m_PEnvir.m_boPKWINLEVEL then begin
    boWinLEvel := True;
    nWinLevel := m_PEnvir.m_nPKWINLEVEL;
  end;
  if m_PEnvir.m_boPKLOSTLEVEL then begin
    boLostLevel := True;
    nLostLevel := m_PEnvir.m_nPKLOSTLEVEL;
  end;
  if m_PEnvir.m_boPKWINEXP then begin
    boWinExp := True;
    nWinExp := m_PEnvir.m_nPKWINEXP;
  end;
  if m_PEnvir.m_boPKLOSTEXP then begin
    boLostExp := True;
    nLostExp := m_PEnvir.m_nPKLOSTEXP;
  end;

  if PlayObject.m_Abil.Level - m_Abil.Level > g_Config.nHumanLevelDiffer then begin
    if not PlayObject.IsGoodKilling(Self) then begin
      if g_Config.boLevelLessNotIncPKPoint then begin //等于小于指定值不增加PK值功能 20100418
        if m_Abil.Level >= g_Config.nNotIncPKPointLevel then begin
          PlayObject.IncPkPoint(g_Config.nKillHumanAddPKPoint {100});
          PlayObject.SysMsg(g_sYouMurderedMsg {'你犯了谋杀罪！！！'}, c_Red, t_Hint);
          if g_Config.boUnKnowHum and m_LastHiter.IsUsesZhuLi then //20080424 带上斗笠,不显示人的真正名字
            SysMsg(Format_ToStr(g_sYouKilledByMsg, ['神秘人']), c_Red, t_Hint)
          else SysMsg(Format_ToStr(g_sYouKilledByMsg, [m_LastHiter.m_sCharName]), c_Red, t_Hint);
          PlayObject.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint {500});
          if PKLevel < 1 then
            if Random(g_Config.nKillHumanWeaponUnlockRate {5}) = 0 then PlayObject.MakeWeaponUnlock;
        end;
      end else begin
        PlayObject.IncPkPoint(g_Config.nKillHumanAddPKPoint {100});
        PlayObject.SysMsg(g_sYouMurderedMsg {'你犯了谋杀罪！！！'}, c_Red, t_Hint);
        if g_Config.boUnKnowHum and m_LastHiter.IsUsesZhuLi then //20080424 带上斗笠,不显示人的真正名字
          SysMsg(Format_ToStr(g_sYouKilledByMsg, ['神秘人']), c_Red, t_Hint)
        else SysMsg(Format_ToStr(g_sYouKilledByMsg, [m_LastHiter.m_sCharName]), c_Red, t_Hint);
        PlayObject.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint {500});
        if PKLevel < 1 then
          if Random(g_Config.nKillHumanWeaponUnlockRate {5}) = 0 then PlayObject.MakeWeaponUnlock;
      end;
    end else begin
      PlayObject.SysMsg(g_sYouProtectedByLawOfDefense {'[你受到正当规则保护。]'}, c_Green, t_Hint);
    end;
    Exit;
  end;
  if boWinLEvel then begin
    if PlayObject.m_Abil.Level + nWinLevel <= MAXUPLEVEL then begin
      Inc(PlayObject.m_Abil.Level, nWinLevel);
      if not PlayObject.m_boAI then begin
        AddGameDataLog('12' + #9 + PlayObject.m_sMapName + #9 + //人物升级记录日志
          IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
          m_sCharName + #9 + IntToStr(PlayObject.m_Abil.nExp) + '/' + IntToStr(PlayObject.m_Abil.nMaxExp)
          + #9 + IntToStr(PlayObject.m_Abil.Level) + #9 + '1' + #9 + 'PK+');
      end;
    end else begin
      PlayObject.m_Abil.Level := MAXUPLEVEL;
      if not PlayObject.m_boAI then begin
        AddGameDataLog('12' + #9 + PlayObject.m_sMapName + #9 + //人物升级记录日志
          IntToStr(PlayObject.m_nCurrX) + #9 + IntToStr(PlayObject.m_nCurrY) + #9 +
          m_sCharName + #9 + IntToStr(PlayObject.m_Abil.nExp) + '/' + IntToStr(PlayObject.m_Abil.nMaxExp)
          + #9 + IntToStr(PlayObject.m_Abil.Level) + #9 + '1' + #9 + 'PK+');
      end;
    end;
    PlayObject.HasLevelUp(PlayObject.m_Abil.Level - nWinLevel);

    if boLostLevel then begin
      if PKLevel >= 2 then begin
        if m_Abil.Level >= nLostLevel * 2 then Dec(m_Abil.Level, nLostLevel * 2);
      end else begin
        if m_Abil.Level >= nLostLevel then Dec(m_Abil.Level, nLostLevel);
      end;
    end;
  end;

  if boWinExp then begin
    PlayObject.WinExp(nWinExp);
    if boLostExp then begin
      if m_Abil.nExp >= LongWord(nLostExp) then begin
        if m_Abil.nExp >= LongWord(nLostExp) then begin
          Dec(m_Abil.nExp, LongWord(nLostExp));
        end else begin
          m_Abil.nExp := 0;
        end;
      end else begin
        if m_Abil.Level >= 1 then begin
          Dec(m_Abil.Level);
          Inc(m_Abil.nExp, GetLevelExp(m_Abil.Level));
          if m_Abil.nExp >= LongWord(nLostExp) then begin
            Dec(m_Abil.nExp, LongWord(nLostExp));
          end else begin
            m_Abil.nExp := 0;
          end;
        end else begin
          m_Abil.Level := 0;
          m_Abil.nExp := 0;
        end;
        //HasLevelUp(m_Abil.Level + 1);
      end;
    end;
  end;
end;
//复活

procedure TBaseObject.ReAlive;
begin
  m_boDeath := False;
  SendRefMsg(RM_ALIVE, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
end;
//设置最后打自己的人

procedure TBaseObject.SetLastHiter(BaseObject: TBaseObject);
begin
  if BaseObject = nil then Exit; //20080726 增加
  m_LastHiter := BaseObject;
  m_LastHiterTick := GetTickCount();
  if m_ExpHitter = nil then begin
    m_ExpHitter := BaseObject;
    m_ExpHitterTick := GetTickCount();
  end else begin
    if m_ExpHitter = BaseObject then m_ExpHitterTick := GetTickCount();
  end;
end;
//设置人物名字变色,即灰名

procedure TBaseObject.SetPKFlag(BaseObject: TBaseObject);
var
  nCode: byte;
  //I: Integer;
  //Slave: TBaseObject;
begin
  nCode := 0;
  if BaseObject = nil then Exit; //20080726 增加
  try
    if (PKLevel < 2) and (BaseObject.PKLevel < 2) and
      (not m_PEnvir.m_boFightZone) and
      (not m_PEnvir.m_boFight2Zone) and //PK掉装备地图 20080525
      (not m_PEnvir.m_boFight3Zone) and
      (not m_PEnvir.m_boFight4Zone) and //挑战地图 20080711
      (not m_PEnvir.m_boFight5Zone) and //不同行会名字变不同颜色 20090318
      (not m_boPKFlag) then begin
      nCode := 1;
      BaseObject.m_dwPKTick := GetTickCount();
      if not BaseObject.m_boPKFlag then begin
        nCode := 2;
        BaseObject.m_boPKFlag := True;
        nCode := 3;
        BaseObject.RefNameColor();
      end;
    end;
  except   
    MainOutMessage(format('{%s} TBaseObject.SetPKFlag Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

function TBaseObject.IsGoodKilling(Cert: TBaseObject): Boolean;
begin
  Result := False;
  if Cert.m_boPKFlag then Result := True;
end;

function TBaseObject.IsProtectTarget(BaseObject: TBaseObject): Boolean;
begin
  Result := True;
  if BaseObject = nil then Exit;
  if (InSafeZone) or (BaseObject.InSafeZone) then Result := False; //安全区
  if not BaseObject.m_boInFreePKArea then begin
    if g_Config.boPKLevelProtect then begin //新人保护
      if (m_Abil.Level > g_Config.nPKProtectLevel) then begin //如果大于指定等级
        if not BaseObject.m_boPKFlag and (BaseObject.m_Abil.Level <= g_Config.nPKProtectLevel) and (BaseObject.PKLevel < 2) then begin
          //被攻击的人物小指定等级没有红名，则不可以攻击。
          Result := False;
          Exit;
        end;
      end;
      if (m_Abil.Level <= g_Config.nPKProtectLevel) then begin //如果小于指定等级
        if not BaseObject.m_boPKFlag and (BaseObject.m_Abil.Level > g_Config.nPKProtectLevel) and (BaseObject.PKLevel < 2) then begin
          Result := False;
          Exit;
        end;
      end;
    end;
    //大于指定级别的红名人物不可以杀指定级别未红名的人物。
    if (PKLevel >= 2) and (m_Abil.Level > g_Config.nRedPKProtectLevel) then begin
      if (BaseObject.m_Abil.Level <= g_Config.nRedPKProtectLevel) and (BaseObject.PKLevel < 2) then begin
        Result := False;
        Exit;
      end;
    end;

    //小于指定级别的非红名人物不可以杀指定级别红名人物。
    if (m_Abil.Level <= g_Config.nRedPKProtectLevel) and (PKLevel < 2) then begin
      if (BaseObject.PKLevel >= 2) and (BaseObject.m_Abil.Level > g_Config.nRedPKProtectLevel) then begin
        Result := False;
        Exit;
      end;
    end;

    if (GetTickCount - m_dwMapMoveTick < 3000) or (GetTickCount - BaseObject.m_dwMapMoveTick < 3000) then
      Result := False;
  end;
end;
//是否是攻击目标

function TBaseObject.IsAttackTarget(BaseObject: TBaseObject): Boolean;
var
  I: Integer;
begin
  Result := False;
  try
    if (BaseObject = nil) or ((BaseObject <> nil) and (BaseObject = Self)) then Exit;
    if BaseObject.m_btRaceServer = 135 then Exit; //20080122 135新型怪 让角色或英雄、宝宝不攻击
    if m_btRaceServer >= RC_ANIMAL {50} then begin
      if m_Master <> nil then begin
        if m_Master.m_LastHiter <> nil then begin
          if m_Master.m_LastHiter = BaseObject then Result := True;
        end;
        if m_Master.m_ExpHitter <> nil then begin
          if m_Master.m_ExpHitter = BaseObject then Result := True;
        end;
        if m_Master.m_TargetCret <> nil then begin
          if m_Master.m_TargetCret = BaseObject then Result := True;
        end;
        if m_LastHiter <> nil then begin
          if (m_LastHiter = BaseObject) then Result := True; //宝宝攻击 20090113
        end;
        if m_ExpHitter <> nil then begin
          if (m_ExpHitter = BaseObject) then Result := True; //宝宝攻击 20090113
        end;
        if (m_btRaceServer = RC_HEROOBJECT) and (not Result) then begin
          if (m_TargetCret = BaseObject) or (m_LastHiter = BaseObject) or (m_ExpHitter = BaseObject) then Result := True;
          if (m_SlaveList.Count > 0) and (not Result) then begin
            for I := 0 to m_SlaveList.Count - 1 do begin
              if TBaseObject(m_SlaveList.Items[I]).m_TargetCret <> nil then begin //20080803 攻击下属的目标
                if TBaseObject(m_SlaveList.Items[I]).m_TargetCret = BaseObject then begin
                  Result := True;
                  Break;
                end;
              end;
            end;
          end;
          if (m_Master <> nil) and (not Result) then begin
            if (m_Master.m_SlaveList.Count > 0) then begin
              for I := 0 to m_Master.m_SlaveList.Count - 1 do begin
                if TBaseObject(m_Master.m_SlaveList.Items[I]).m_TargetCret <> nil then begin
                  if TBaseObject(m_Master.m_SlaveList.Items[I]).m_TargetCret = BaseObject then begin
                    Result := True;
                    Break;
                  end;
                end;
              end;
            end;
          end;
          if (m_Master <> nil) and (not Result) then begin //行会模式下攻击敌对行会
            if (m_btAttatckMode <> HAM_PEACE) and (THeroObject(self).m_boProtectStatus)
              and (m_Master.m_PEnvir = m_PEnvir) then begin //非和平模式,守护模式，攻击敌对行会
              if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin //目标是人
                if (m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
                  if (m_Master.m_MyGuild <> nil) then begin
                    if m_Master.m_boGuildWarArea and (BaseObject.m_MyGuild <> nil) then begin
                      if TGUild(m_Master.m_MyGuild).IsWarGuild(TGUild(BaseObject.m_MyGuild)) then Result := True;
                    end;
                  end;
                end;
              end else
                if (BaseObject.m_btRaceServer = RC_HEROOBJECT) and (BaseObject.m_Master <> nil) then begin //目标是英雄,且主人存在
                  if (m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
                    if (m_Master.m_MyGuild <> nil) then begin
                      if m_Master.m_boGuildWarArea and (BaseObject.m_Master.m_MyGuild <> nil) then begin
                        if TGUild(m_Master.m_MyGuild).IsWarGuild(TGUild(BaseObject.m_Master.m_MyGuild)) then Result := True;
                      end;
                    end;
                  end;
                end; //英雄
            end; //if m_btAttatckMode <> HAM_PEACE
          end;
        end;
        if BaseObject.m_TargetCret <> nil then begin
          if (BaseObject.m_TargetCret = m_Master) and (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) then Result := True;
          if (BaseObject.m_TargetCret = Self) and (BaseObject.m_btRaceServer > {=} RC_ANIMAL) then Result := True;
        end;
        if (BaseObject.m_Master <> nil) and (not Result) then begin
          if (m_Master.m_LastHiter <> nil) then
            if (BaseObject.m_Master = m_Master.m_LastHiter) then Result := True;
          if (m_Master.m_TargetCret <> nil) then
            if (BaseObject.m_Master = m_Master.m_TargetCret) then Result := True;
          if (BaseObject.m_Master <> nil) and Result then begin
            if (BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT) then begin //20080812 不打英雄下属
              if BaseObject.m_Master.m_Master <> nil then begin
                if BaseObject.m_Master.m_Master = m_Master then Result := False;
              end;
            end;
          end;
        end;
        if ((m_Master.m_btRaceServer = RC_PLAYOBJECT) or (m_Master.m_btRaceServer = RC_HEROOBJECT))
          and Result and (m_Master <> nil) then begin
          case m_Master.m_btAttatckMode of
           (*HAM_ALL {0}: begin //全体攻击
              if (BaseObject.m_btRaceServer < RC_NPC {10}) or (BaseObject.m_btRaceServer > RC_PEACENPC {15}) then Result := True;
            end;*)
            HAM_PEACE {1}: begin //和平攻击
                if BaseObject.m_btRaceServer < RC_ANIMAL then Result := False;
                if BaseObject.m_Master <> nil then Result := False;
              end;
            HAM_DEAR: begin //夫妻攻击
                if m_Master <> nil then begin
                  if (TPlayObject(m_Master).m_DearHuman <> nil) and (BaseObject <> nil) then begin //20080713 增加
                    if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and (BaseObject = TPlayObject(m_Master).m_DearHuman) then Result := False;
                    if BaseObject <> nil then begin
                      if BaseObject.m_Master <> nil then begin //20080521 增加
                        if BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT then begin
                          if BaseObject.m_Master.m_Master = TPlayObject(m_Master).m_DearHuman then Result := False;
                        end else if BaseObject.m_Master = TPlayObject(m_Master).m_DearHuman then Result := False;
                      end;
                    end;
                  end;
                end;
              end;
            HAM_MASTER: begin //师徒攻击
                if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
                  if (m_Master <> nil) and (BaseObject <> nil) then begin
                    if (TPlayObject(m_Master).m_boMaster) then
                      if TPlayObject(BaseObject).m_sMasterName = m_Master.m_sCharName then Result := False;
                  end;
                  if TPlayObject(BaseObject).m_boMaster then begin
                    if m_Master.m_btRaceServer = RC_PLAYOBJECT then //主人是人
                      if BaseObject.m_sCharName = TPlayObject(m_Master).m_sMasterName then Result := False;
                    if (m_Master.m_btRaceServer = RC_HEROOBJECT) and (m_Master.m_Master <> nil) then //主人是英雄
                      if BaseObject.m_sCharName = TPlayObject(m_Master.m_Master).m_sMasterName then Result := False;
                  end;
                end else begin
                  if BaseObject.m_Master <> nil then begin
                    if (BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT) and (BaseObject.m_Master.m_Master <> nil) then begin
                      if (m_Master <> nil) then begin
                        if (TPlayObject(m_Master).m_boMaster) then
                          if TPlayObject(BaseObject.m_Master.m_Master).m_sMasterName = m_Master.m_sCharName then Result := False;
                      end;
                      if TPlayObject(BaseObject.m_Master.m_Master).m_boMaster then begin
                        if m_Master.m_btRaceServer = RC_PLAYOBJECT then //主人是人
                          if BaseObject.m_Master.m_Master.m_sCharName = TPlayObject(m_Master).m_sMasterName then Result := False;
                        if (m_Master.m_btRaceServer = RC_HEROOBJECT) and (m_Master.m_Master <> nil) then //主人是英雄
                          if BaseObject.m_Master.m_Master.m_sCharName = TPlayObject(m_Master.m_Master).m_sMasterName then Result := False;
                      end;
                    end else begin //主人不是英雄
                      if (BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
                        if (m_Master <> nil) then begin
                          if (TPlayObject(m_Master).m_boMaster) then
                            if TPlayObject(BaseObject.m_Master).m_sMasterName = m_Master.m_sCharName then Result := False;
                        end;
                        if TPlayObject(BaseObject.m_Master).m_boMaster then begin
                          if m_Master.m_btRaceServer = RC_PLAYOBJECT then //主人是人
                            if BaseObject.m_Master.m_sCharName = TPlayObject(m_Master).m_sMasterName then Result := False;
                          if (m_Master.m_btRaceServer = RC_HEROOBJECT) and (m_Master.m_Master <> nil) then //主人是英雄
                            if BaseObject.m_Master.m_sCharName = TPlayObject(m_Master.m_Master).m_sMasterName then Result := False;
                        end;
                      end;
                    end;
                  end; //if BaseObject.m_Master <> nil then begin
                end; //
              end;
            HAM_GROUP {2}: begin //编组攻击
                if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
                  if TPlayObject(m_Master).IsGroupMember(BaseObject) then begin
                    Result := False;
                    BreakCrazyMode();
                    Exit;
                  end;
                if m_Master.m_btRaceServer = RC_HEROOBJECT then begin //20080707
                  if (m_Master.m_Master <> nil) then
                    if TPlayObject(m_Master.m_Master).IsGroupMember(BaseObject) then begin
                      Result := False;
                      BreakCrazyMode();
                      Exit;
                    end;
                  if (BaseObject <> nil) and (BaseObject.m_Master <> nil) and (m_Master.m_Master <> nil)
                    and (m_Master.m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
                    if BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin
                      if TPlayObject(m_Master.m_Master).IsGroupMember(BaseObject.m_Master) then begin
                        Result := False;
                        BreakCrazyMode();
                        Exit;
                      end;
                    end;
                    if (BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT) and (BaseObject.m_Master.m_Master <> nil) then begin
                      if TPlayObject(m_Master.m_Master).IsGroupMember(BaseObject.m_Master.m_Master) then begin
                        Result := False;
                        BreakCrazyMode();
                        Exit;
                      end;
                    end;
                  end;
                end;
                if m_Master.m_btRaceServer = RC_PLAYOBJECT then begin //20080721
                  if TPlayObject(m_Master).IsGroupMember(BaseObject) then begin
                    Result := False;
                    BreakCrazyMode();
                    Exit;
                  end;
                  if (BaseObject <> nil) and Result then begin //20080916 修改
                    if (BaseObject.m_Master <> nil) and (m_Master <> nil) then begin //20080812
                      if BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin
                        if TPlayObject(m_Master).IsGroupMember(BaseObject.m_Master) then Result := False;
                      end;
                      if (BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT) and (BaseObject.m_Master.m_Master <> nil) and Result then begin
                        if TPlayObject(m_Master).IsGroupMember(BaseObject.m_Master.m_Master) then Result := False;
                      end;
                    end;
                  end;
                end;
              end;
            HAM_GUILD {5}: begin //行会攻击
                case BaseObject.m_btRaceServer of
                  RC_PLAYOBJECT: begin //目标是人
                      if (m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
                        if (m_Master.m_MyGuild <> nil) then begin
                          if TGUild(m_Master.m_MyGuild).IsMember(BaseObject.m_sCharName) then Result := False;
                          if m_Master.m_boGuildWarArea and (BaseObject.m_MyGuild <> nil) then begin //20090413 修改
                            if TGUild(m_Master.m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_MyGuild)) then Result := False;
                          end;
                        end;
                      end else begin
                        if m_Master.m_Master <> nil then begin
                          if (m_Master.m_Master.m_MyGuild <> nil) then begin
                            if TGUild(m_Master.m_Master.m_MyGuild).IsMember(BaseObject.m_sCharName) then Result := False;
                            if m_Master.m_Master.m_boGuildWarArea and (BaseObject.m_MyGuild <> nil) then begin //20090413 修改
                              if TGUild(m_Master.m_Master.m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_MyGuild)) then Result := False;
                            end;
                          end;
                        end;
                      end;
                    end; //RC_PLAYOBJECT
                  RC_HEROOBJECT: begin
                      if (BaseObject.m_Master <> nil) then begin //目标是英雄,且主人存在
                        if (m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
                          if (m_Master.m_MyGuild <> nil) then begin
                            if TGUild(m_Master.m_MyGuild).IsMember(BaseObject.m_Master.m_sCharName) then Result := False;
                            if m_Master.m_boGuildWarArea and (BaseObject.m_Master.m_MyGuild <> nil) then begin //20090413 修改
                              if TGUild(m_Master.m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_MyGuild)) then Result := False;
                            end;
                          end;
                        end else begin
                          if m_Master.m_Master <> nil then begin
                            if (m_Master.m_Master.m_MyGuild <> nil) then begin
                              if TGUild(m_Master.m_Master.m_MyGuild).IsMember(BaseObject.m_Master.m_sCharName) then Result := False;
                              if m_Master.m_Master.m_boGuildWarArea and (BaseObject.m_Master.m_MyGuild <> nil) then begin //20090413 修改
                                if TGUild(m_Master.m_Master.m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_MyGuild)) then Result := False;
                              end;
                            end;
                          end;
                        end;
                      end; //英雄
                    end; //RC_HEROOBJECT
                  RC_PLAYMOSTER: begin
                      if (BaseObject.m_Master <> nil) then begin //目标是分身,且主人存在 20090221
                        if (m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
                          if (m_Master.m_MyGuild <> nil) then begin
                            if BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin //分身的主人是人物时
                              if TGUild(m_Master.m_MyGuild).IsMember(BaseObject.m_Master.m_sCharName) then Result := False;
                              if m_Master.m_boGuildWarArea and (BaseObject.m_Master.m_MyGuild <> nil) then begin //20090413 修改
                                if TGUild(m_Master.m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_MyGuild)) then Result := False;
                              end;
                            end else begin //分身主人非人物时
                              if BaseObject.m_Master.m_Master <> nil then begin
                                if BaseObject.m_Master.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin
                                  if TGUild(m_Master.m_MyGuild).IsMember(BaseObject.m_Master.m_Master.m_sCharName) then Result := False;
                                  if m_Master.m_boGuildWarArea and (BaseObject.m_Master.m_Master.m_MyGuild <> nil) then begin //20090413 修改
                                    if TGUild(m_Master.m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_Master.m_MyGuild)) then Result := False;
                                  end;
                                end;
                              end;
                            end;
                          end;
                        end else begin
                          if m_Master.m_Master <> nil then begin
                            if (m_Master.m_Master.m_MyGuild <> nil) then begin
                              if BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin //分身的主人是人物时
                                if TGUild(m_Master.m_Master.m_MyGuild).IsMember(BaseObject.m_Master.m_sCharName) then Result := False;
                                if m_Master.m_Master.m_boGuildWarArea and (BaseObject.m_Master.m_MyGuild <> nil) then begin //20090413 修改
                                  if TGUild(m_Master.m_Master.m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_MyGuild)) then Result := False;
                                end;
                              end else begin //分身主人非人物时
                                if BaseObject.m_Master.m_Master <> nil then begin
                                  if BaseObject.m_Master.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin
                                    if TGUild(m_Master.m_Master.m_MyGuild).IsMember(BaseObject.m_Master.m_Master.m_sCharName) then Result := False;
                                    if m_Master.m_Master.m_boGuildWarArea and (BaseObject.m_Master.m_Master.m_MyGuild <> nil) then begin //20090413 修改
                                      if TGUild(m_Master.m_Master.m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_Master.m_MyGuild)) then Result := False;
                                    end;
                                  end;
                                end;
                              end;
                            end;
                          end;
                        end;
                      end;
                    end; //RC_PLAYMOSTER
                  //109:begin
                else begin //20110530 修改
                    if (m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
                      if m_Master.m_MyGuild <> nil then begin
                        if m_Master.m_MyGuild = BaseObject.m_MyGuild then Result := False;
                        if m_Master.m_boGuildWarArea and (BaseObject.m_MyGuild <> nil) then begin
                          if TGUild(m_Master.m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_MyGuild)) then Result := False;
                        end;
                        if BaseObject.m_Master <> nil then begin
                          if m_Master.m_MyGuild = BaseObject.m_Master.m_MyGuild then Result := False;
                          if m_Master.m_boGuildWarArea and (BaseObject.m_Master.m_MyGuild <> nil) then begin
                            if TGUild(m_Master.m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_MyGuild)) then Result := False;
                          end;
                        end;
                      end;
                    end else begin
                      if m_Master.m_Master <> nil then begin
                        if m_Master.m_Master.m_MyGuild <> nil then begin
                          if m_Master.m_Master.m_MyGuild = BaseObject.m_MyGuild then Result := False;
                          if m_Master.m_Master.m_boGuildWarArea and (BaseObject.m_MyGuild <> nil) then begin
                            if TGUild(m_Master.m_Master.m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_MyGuild)) then Result := False;
                          end;
                          if BaseObject.m_Master <> nil then begin
                            if m_Master.m_Master.m_MyGuild = BaseObject.m_Master.m_MyGuild then Result := False;
                            if m_Master.m_Master.m_boGuildWarArea and (BaseObject.m_Master.m_MyGuild <> nil) then begin
                              if TGUild(m_Master.m_Master.m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_MyGuild)) then Result := False;
                            end;
                          end;
                        end;
                      end;
                    end;
                  end; //109
                end; //行会case 2
              end;
{$IF M2Version <> 2}
            HAM_DIVISION: begin
                case BaseObject.m_btRaceServer of
                  RC_PLAYOBJECT: begin //目标是人
                      if (m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
                        if (TPlayObject(m_Master).m_MyDivision <> nil) then begin
                          if TDivision(TPlayObject(m_Master).m_MyDivision).IsMember(BaseObject.m_sCharName) then Result := False;
                        end;
                      end else begin
                        if m_Master.m_Master <> nil then begin
                          if (TPlayObject(m_Master.m_Master).m_MyDivision <> nil) then begin
                            if TDivision(TPlayObject(m_Master.m_Master).m_MyDivision).IsMember(BaseObject.m_sCharName) then Result := False;
                          end;
                        end;
                      end;
                    end; //RC_PLAYOBJECT
                  RC_HEROOBJECT: begin
                      if (BaseObject.m_Master <> nil) then begin //目标是英雄,且主人存在
                        if (m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
                          if (TPlayObject(m_Master).m_MyDivision <> nil) then begin
                            if TDivision(TPlayObject(m_Master).m_MyDivision).IsMember(BaseObject.m_Master.m_sCharName) then Result := False;
                          end;
                        end else begin
                          if m_Master.m_Master <> nil then begin
                            if (TPlayObject(m_Master.m_Master).m_MyDivision <> nil) then begin
                              if TDivision(TPlayObject(m_Master.m_Master).m_MyDivision).IsMember(BaseObject.m_Master.m_sCharName) then Result := False;
                            end;
                          end;
                        end;
                      end; //英雄
                    end; //RC_HEROOBJECT
                  RC_PLAYMOSTER: begin
                      if (BaseObject.m_Master <> nil) then begin //目标是分身,且主人存在 20090221
                        if (m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
                          if (TPlayObject(m_Master).m_MyDivision <> nil) then begin
                            if BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin //分身的主人是人物时
                              if TDivision(TPlayObject(m_Master).m_MyDivision).IsMember(BaseObject.m_Master.m_sCharName) then Result := False;
                            end else begin //分身主人非人物时
                              if BaseObject.m_Master.m_Master <> nil then begin
                                if BaseObject.m_Master.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin
                                  if TDivision(TPlayObject(m_Master).m_MyDivision).IsMember(BaseObject.m_Master.m_Master.m_sCharName) then Result := False;
                                end;
                              end;
                            end;
                          end;
                        end else begin
                          if m_Master.m_Master <> nil then begin
                            if (TPlayObject(m_Master.m_Master).m_MyDivision <> nil) then begin
                              if BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin //分身的主人是人物时
                                if TDivision(TPlayObject(m_Master.m_Master).m_MyDivision).IsMember(BaseObject.m_Master.m_sCharName) then Result := False;
                              end else begin //分身主人非人物时
                                if BaseObject.m_Master.m_Master <> nil then begin
                                  if BaseObject.m_Master.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin
                                    if TDivision(TPlayObject(m_Master.m_Master).m_MyDivision).IsMember(BaseObject.m_Master.m_Master.m_sCharName) then Result := False;
                                  end;
                                end;
                              end;
                            end;
                          end;
                        end;
                      end;
                    end; //RC_PLAYMOSTER
                else begin //20110530 修改
                    if (m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
                      if TPlayObject(m_Master).m_MyDivision <> nil then begin
                        if TPlayObject(m_Master).m_MyDivision = TPlayObject(BaseObject).m_MyDivision then Result := False;
                        if BaseObject.m_Master <> nil then begin
                          if TPlayObject(m_Master).m_MyDivision = TPlayObject(BaseObject.m_Master).m_MyDivision then Result := False;
                        end;
                      end;
                    end else begin
                      if m_Master.m_Master <> nil then begin
                        if TPlayObject(m_Master.m_Master).m_MyDivision <> nil then begin
                          if TPlayObject(m_Master.m_Master).m_MyDivision = TPlayObject(BaseObject).m_MyDivision then Result := False;
                          if BaseObject.m_Master <> nil then begin
                            if TPlayObject(m_Master.m_Master).m_MyDivision = TPlayObject(BaseObject.m_Master).m_MyDivision then Result := False;
                          end;
                        end;
                      end;
                    end;
                  end; //109
                end; //行会case 2
              end;
{$IFEND}
          end; //Case 1
        end;

        if (BaseObject.m_Master = m_Master) or (BaseObject = m_Master) then Result := False; {检测是主人不攻击主人}
        if (m_Master.m_btRaceServer = RC_PLAYOBJECT) and (BaseObject.m_Master <> nil) then
          if (TPlayObject(m_Master).m_MyHero <> nil) and (BaseObject.m_Master = TPlayObject(m_Master).m_MyHero) then Result := False; //20080614 主人下属不打英雄下属
        if (m_Master.m_btRaceServer = RC_HEROOBJECT) then begin
          if m_Master.m_Master <> nil then begin //20080213
            if BaseObject = m_Master.m_Master then Result := False; {如果主人是英雄,不攻击英雄的主人}
            if (m_Master.m_Master.m_SlaveList.Count > 0) {and (m_btAttatckMode <> HAM_ALL)} then begin //英雄的下属不打主人下属
              for I := m_Master.m_Master.m_SlaveList.Count - 1 downto 0 do begin //20101029 修改
                if TBaseObject(m_Master.m_Master.m_SlaveList.Items[I]) = BaseObject then begin
                  Result := False;
                  Break;
                end;
              end;
            end;
          end;
        end;
        if (m_SlaveList.Count > 0) and (m_btAttatckMode <> HAM_ALL) then begin //20080212 不能锁定自己的下属
          for I := m_SlaveList.Count - 1 downto 0 do begin //20101029 修改
            if TBaseObject(m_SlaveList.Items[I]) = BaseObject then begin
              Result := False;
              Break;
            end;
          end;
        end;
        if BaseObject.m_boHolySeize and (m_btRaceServer <> RC_HEROOBJECT) then Result := False; //20090716 增加，除英雄外
        if (m_Master.m_boSlaveRelax) and (m_btRaceServer <> RC_HEROOBJECT) and (m_btRaceServer <> 108) then Result := False; {检测宝宝是否处于休息状态,英雄,月灵除外}
        if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or (BaseObject.m_btRaceServer = RC_HEROOBJECT) or (BaseObject.m_Master <> nil) then begin //安全区不能打人物和英雄
          if BaseObject.InSafeZone or InSafeZone then Result := False; //20080721 修改
        end;
        BreakCrazyMode();
      end else begin
        if BaseObject.m_btRaceServer = RC_PLAYOBJECT then Result := True;
        if (m_btRaceServer > RC_PEACENPC {15}) and (m_btRaceServer < RC_ANIMAL {50}) then Result := True;
        if BaseObject.m_Master <> nil then Result := True;
        if (m_btRaceServer = 109) then begin //押镖怪,且属于行会
          Result := True;
          if (m_MyGuild <> nil) then begin
            case BaseObject.m_btRaceServer of
              RC_PLAYOBJECT: begin //目标是人
                  if TGUild(m_MyGuild).IsMember(BaseObject.m_sCharName) then Result := False;
                  if m_boGuildWarArea and (BaseObject.m_MyGuild <> nil) then begin
                    if TGUild(m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_MyGuild)) then Result := False;
                  end;
                end;
              RC_HEROOBJECT: begin
                  if (BaseObject.m_Master <> nil) then begin //目标是英雄,且主人存在
                    if TGUild(m_MyGuild).IsMember(BaseObject.m_Master.m_sCharName) then Result := False;
                    if m_boGuildWarArea and (BaseObject.m_Master.m_MyGuild <> nil) then begin
                      if TGUild(m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_MyGuild)) then Result := False;
                    end;
                  end;
                end;
              RC_PLAYMOSTER: begin
                  if (BaseObject.m_Master <> nil) then begin //目标是分身,且主人存在
                    if BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin //分身的主人是人物时
                      if TGUild(m_MyGuild).IsMember(BaseObject.m_Master.m_sCharName) then Result := False;
                      if m_boGuildWarArea and (BaseObject.m_Master.m_MyGuild <> nil) then begin
                        if TGUild(m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_MyGuild)) then Result := False;
                      end;
                    end else begin //分身主人非人物时
                      if BaseObject.m_Master.m_Master <> nil then begin
                        if BaseObject.m_Master.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin
                          if TGUild(m_MyGuild).IsMember(BaseObject.m_Master.m_Master.m_sCharName) then Result := False;
                          if m_boGuildWarArea and (BaseObject.m_Master.m_Master.m_MyGuild <> nil) then begin
                            if TGUild(m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_Master.m_MyGuild)) then Result := False;
                          end;
                        end;
                      end;
                    end;
                  end;
                end;
            end;
          end;
          if BaseObject.m_btRaceServer = RC_ARCHERGUARD then Result := False; //镖车不打弓箭手 20110508
        end;
        if (m_btRaceServer = RC_PLAYMOSTER) and (not Result) then begin //人形怪攻击指定类型的目标
          if (TPlayMonster(self).TargetList <> nil) and (BaseObject.m_btRaceServer <> RC_PLAYMOSTER) then begin
            if TPlayMonster(self).TargetList.IndexOf(BaseObject.m_sCharName) > -1 then Result := True;
          end;
        end;
      end; //if m_Master <> nil then begin
      if (BaseObject.m_btRaceServer = 158) then Result := False; //宠物类(不可打) 20110620
      if ((BaseObject.m_btRaceServer = 10) or (BaseObject.m_btRaceServer = 11) or (BaseObject.m_btRaceServer = RC_GUARD))
        and ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) or (m_Master <> nil) or (m_btRaceServer = 109)) then Result := False; //20080408 英雄不打卫士(10-12分类的怪) 20080409
      if m_boCrazyMode then Result := True;
    end else begin
      if m_btRaceServer = RC_PLAYOBJECT then begin
        case m_btAttatckMode of //攻击状态
          HAM_ALL {0}: begin //全体攻击
              if (BaseObject.m_btRaceServer < RC_NPC {10}) or (BaseObject.m_btRaceServer > RC_PEACENPC {15}) then Result := True;
              if g_Config.boNonPKServer then Result := True; //没有禁止PK
            end;
          HAM_PEACE {1}: begin //和平攻击
              if BaseObject.m_btRaceServer >= RC_ANIMAL then Result := True;
              if BaseObject.m_Master <> nil then Result := False;
            end;
          HAM_DEAR: begin //夫妻攻击
              if BaseObject <> TPlayObject(Self).m_DearHuman then Result := True;
              if BaseObject.m_Master <> nil then begin
                if BaseObject.m_Master <> TPlayObject(Self).m_DearHuman then Result := True;
              end;
            end;
          HAM_MASTER: begin //师徒攻击
              if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
                Result := True;
                if TPlayObject(Self).m_boMaster then begin
                  if TPlayObject(Self).m_MasterList.Count > 0 then begin //20080629
                    for I := 0 to TPlayObject(Self).m_MasterList.Count - 1 do begin
                      if TPlayObject(Self).m_MasterList.Items[I] = BaseObject then begin
                        Result := False;
                        Break;
                      end;
                    end;
                  end;
                end;
                if TPlayObject(BaseObject).m_boMaster then begin
                  if TPlayObject(BaseObject).m_MasterList.Count > 0 then begin //20080629
                    for I := 0 to TPlayObject(BaseObject).m_MasterList.Count - 1 do begin
                      if TPlayObject(BaseObject).m_MasterList.Items[I] = Self then begin
                        Result := False;
                        Break;
                      end;
                    end; //for
                  end;
                end;
              end else Result := True;
            end;
          HAM_GROUP {2}: begin //编组攻击
              if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC) then
                Result := True;
              if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
                if TPlayObject(Self).IsGroupMember(BaseObject) then Result := False;

              if BaseObject.m_Master <> nil then begin //20080611 修改
                if BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT then begin
                  if BaseObject.m_Master.m_Master <> nil then
                    if TPlayObject(Self).IsGroupMember(BaseObject.m_Master.m_Master) then Result := False;
                end else
                  if TPlayObject(Self).IsGroupMember(BaseObject.m_Master) then Result := False;
              end;

              if g_Config.boNonPKServer then Result := True;
            end;
          HAM_GUILD {5}: begin //行会攻击
              if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC) then Result := True;
              if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
                if m_MyGuild <> nil then begin
                  if TGUild(m_MyGuild).IsMember(BaseObject.m_sCharName) then
                    Result := False;
                  if m_boGuildWarArea and (BaseObject.m_MyGuild <> nil) then begin
                    if TGUild(m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_MyGuild)) then begin
                      Result := False;
                    end;
                  end;
                end;
              end else begin //不打同行会的宝宝
                if BaseObject.m_btRaceServer = 109 then begin
                  if BaseObject.m_MyGuild = m_MyGuild then Result := False;
                end;
                if BaseObject.m_Master <> nil then begin
                  if BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin
                    if m_MyGuild <> nil then begin
                      if TGUild(m_MyGuild).IsMember(BaseObject.m_Master.m_sCharName) then
                        Result := False;
                      if m_boGuildWarArea and (BaseObject.m_Master.m_MyGuild <> nil) then begin
                        if TGUild(m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_MyGuild)) then
                          Result := False;
                      end;
                    end;
                  end else
                    if BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT then begin
                      if (m_MyGuild <> nil) and (BaseObject.m_Master.m_Master <> nil) then begin
                        if TGUild(m_MyGuild).IsMember(BaseObject.m_Master.m_Master.m_sCharName) then
                          Result := False;
                        if m_boGuildWarArea and (BaseObject.m_Master.m_Master.m_MyGuild <> nil) then begin
                          if TGUild(m_MyGuild).IsAllyGuild(TGUild(BaseObject.m_Master.m_Master.m_MyGuild)) then
                            Result := False;
                        end;
                      end;
                    end;
                end; //if BaseObject.m_Master <> nil
              end;
              if g_Config.boNonPKServer then Result := True;
            end;
          HAM_PKATTACK {6}: begin //红名攻击
              if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC) then
                Result := True;
              if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
                if PKLevel >= 2 then begin
                  if BaseObject.PKLevel < 2 then
                    Result := True
                  else Result := False;
                end else begin
                  if BaseObject.PKLevel >= 2 then
                    Result := True
                  else Result := False;
                end;
              if g_Config.boNonPKServer then Result := True;
            end;
{$IF M2Version <> 2}
          HAM_DIVISION: begin //师门攻击
              if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC) then Result := True;
              if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
                if TPlayObject(Self).m_MyDivision <> nil then begin
                  if TDivision(TPlayObject(Self).m_MyDivision).IsMember(BaseObject.m_sCharName) then
                    Result := False;
                end;
              end else begin //不打同门派的宝宝
                if BaseObject.m_Master <> nil then begin
                  case BaseObject.m_Master.m_btRaceServer of
                    RC_PLAYOBJECT: begin
                        if TPlayObject(Self).m_MyDivision <> nil then begin
                          if TDivision(TPlayObject(Self).m_MyDivision).IsMember(BaseObject.m_Master.m_sCharName) then
                            Result := False;
                        end;
                      end;
                    RC_HEROOBJECT: begin
                        if (TPlayObject(Self).m_MyDivision <> nil) and (BaseObject.m_Master.m_Master <> nil) then begin
                          if TDivision(TPlayObject(Self).m_MyDivision).IsMember(BaseObject.m_Master.m_Master.m_sCharName) then
                            Result := False;
                        end;
                      end;
                  end;
                end; //if BaseObject.m_Master <> nil
              end;
              if g_Config.boNonPKServer then Result := True;
            end;
{$IFEND}
        end;
      end else Result := True;
    end;
    if BaseObject.m_boNoAttackMode and (BaseObject.m_Master = nil) and (BaseObject.m_btRaceServer = RC_PLAYMOSTER) then Result := False; //不攻击非攻击模式的人形怪 20090516
    if BaseObject.m_boAdminMode or BaseObject.m_boStoneMode then Result := False;
  except   
    //MainOutMessage('{异常} TBaseObject.IsAttackTarget Code:'+inttostr(nCode));
  end;
end;
//是否是适当的目标

function TBaseObject.IsProperTarget(BaseObject: TBaseObject): Boolean;
var I: integer;
  nCode: Byte;
begin
  nCode := 0;
  try
    Result := IsAttackTarget(BaseObject);
    nCode := 1;
    if Result then begin
      nCode := 2;
      if (m_btRaceServer = RC_PLAYOBJECT) and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
        nCode := 3;
        Result := IsProtectTarget(BaseObject); {检测人物是否符合攻击要求}
      end;
    end;
    nCode := 4;
    if (BaseObject <> nil) and
      (m_btRaceServer = RC_PLAYOBJECT) and (BaseObject.m_Master <> nil) and
      (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) and (BaseObject.m_btRaceServer <> 158) then begin
      nCode := 5;
      if BaseObject.m_Master = Self then begin
        nCode := 6;
        if (m_btAttatckMode <> HAM_ALL) and (BaseObject = TPlayObject(Self).m_MyHero) then Result := False; {检测是否是自己的宝宝}
        nCode := 7;
        if (m_SlaveList.Count > 0) and (m_btAttatckMode <> HAM_ALL) then begin //20080322 不能锁定主人的下属
          nCode := 8;
          for I := 0 to m_SlaveList.Count - 1 do begin
            nCode := 9;
            if TBaseObject(m_SlaveList.Items[I]) = BaseObject then begin
              nCode := 10;
              Result := False;
              Break;
            end;
          end;
        end;
      end else begin
        nCode := 11;
        Result := IsAttackTarget(BaseObject.m_Master); //20080522
        nCode := 12;
        if InSafeZone or BaseObject.InSafeZone then Result := False; {检测是否是在安全区}
        nCode := 13;
        if (m_btRaceServer = RC_HEROOBJECT) and (InSafeZone or BaseObject.InSafeZone) and (BaseObject.m_Master <> nil) then Result := False; //20080404 英雄不能在安全区PK
        nCode := 14;
        if (TPlayObject(self).m_MyHero <> nil) and (m_btAttatckMode <> HAM_ALL) then begin //20080323 不能锁定英雄的下属
          nCode := 15;
          if (TPlayObject(self).m_MyHero.m_SlaveList.Count > 0) and (m_btAttatckMode <> HAM_ALL) then begin
            nCode := 16;
            for I := 0 to TPlayObject(self).m_MyHero.m_SlaveList.Count - 1 do begin
              nCode := 17;
              if TBaseObject(TPlayObject(self).m_MyHero.m_SlaveList.Items[I]) = BaseObject then begin
                nCode := 18;
                Result := False;
                Break;
              end;
            end;
          end;
        end; // if (m_Master <> nil) then begin
      end;
    end;
  except   
    MainOutMessage(format('{%s} TBaseObject.IsProperTarget Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

//擒龙手目标检测

function TBaseObject.IsProperTargetSKILL_55(nLevel: Integer; BaseObject: TBaseObject): Boolean;
begin
  Result := False;
  if (BaseObject = nil) or (BaseObject = Self) then Exit;
  if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC) then begin
    if (BaseObject.m_btRaceServer <> RC_GUARD) and
      (BaseObject.m_btRaceServer <> RC_ARCHERGUARD) and
      (BaseObject.m_btRaceServer <> 110) and
      (BaseObject.m_btRaceServer <> 111) and
      (nLevel >= BaseObject.m_Abil.Level) and
      (not BaseObject.m_boGhost) and
      (not BaseObject.m_boDeath) then begin
      if ((not g_Config.boPullPlayObject) or (nLevel < BaseObject.m_Abil.Level)) and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then Exit;
      if g_Config.boPullCrossInSafeZone and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and BaseObject.InSafeZone then Exit;
      if g_Config.boPullCrossInSafeZone and (BaseObject.m_Master <> nil) and BaseObject.InSafeZone then Exit; //不允许抓安全区的宝宝
      Result := True;
    end;
  end;
end;

//骷髅咒

function TBaseObject.IsProperTargetSKILL_54(BaseObject: TBaseObject): Boolean;
begin
  Result := False;
  if (BaseObject = nil) or (BaseObject = Self) then Exit;
  if BaseObject.m_boDeath and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
    if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC) then begin
      if (BaseObject.m_btRaceServer <> RC_GUARD) and
        (BaseObject.m_btRaceServer <> RC_ARCHERGUARD) and
        (BaseObject.m_btRaceServer <> 110) and
        (BaseObject.m_btRaceServer <> 111) then Result := True;
    end;
  end;
end;

//复活术

function TBaseObject.IsProperTargetSKILL_57(BaseObject: TBaseObject): Boolean;
begin
  Result := False;
  if (BaseObject = nil) or (BaseObject = Self) then Exit;
  if BaseObject.m_boDeath and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
    if TPlayObject(BaseObject).m_boAllowReAlive then Result := True
    else SysMsg('对方禁止复活！', c_Green, t_Hint);
  end;
end;

{//召唤NPC  未使用 20080329
function TBaseObject.IsProperTargetSKILL_70(PlayObject: TBaseObject): Boolean;
begin
  Result := False;
  if (g_FunctionNPC <> nil) and (PlayObject <> nil) then begin
    if PlayObject.m_btRaceServer = RC_PLAYOBJECT then begin
      g_FunctionNPC.GotoLable(TPlayObject(PlayObject), '@Magic', False);
      Result := True;
    end;
  end;
end; }

//死亡触发函数

function TPlayObject.DieGotoLable(): Boolean;
var
  nCode: Byte;
begin
  Result := False;
  nCode := 0;
{$IF M2Version <> 2}
  m_nDieCount := _MIN(High(Byte), m_nDieCount + 1);
{$IFEND}
  try
    if (m_LastHiter <> nil) then begin
      nCode := 1;
      if m_LastHiter.m_Master <> nil then begin
        if m_LastHiter.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin
          nCode := 2;
          m_sString[0] := TPlayObject(m_LastHiter.m_Master).m_sCharName;
          m_nInteger[0] := TPlayObject(m_LastHiter.m_Master).m_WAbil.Level;
          TPlayObject(m_LastHiter.m_Master).m_sString[0] := m_sCharName;
          TPlayObject(m_LastHiter.m_Master).m_nInteger[0] := m_WAbil.Level;
          nCode := 3;
          TPlayObject(m_LastHiter.m_Master).KillPlayFunc;
        end else
          if m_LastHiter.m_Master.m_btRaceServer = RC_HEROOBJECT then begin //英雄下属杀人
            if m_LastHiter.m_Master.m_Master <> nil then begin
              nCode := 4;
              m_sString[0] := TPlayObject(m_LastHiter.m_Master.m_Master).m_sCharName;
              m_nInteger[0] := TPlayObject(m_LastHiter.m_Master.m_Master).m_WAbil.Level;
              TPlayObject(m_LastHiter.m_Master.m_Master).m_sString[0] := m_sCharName;
              TPlayObject(m_LastHiter.m_Master.m_Master).m_nInteger[0] := m_WAbil.Level;
              nCode := 5;
              TPlayObject(m_LastHiter.m_Master.m_Master).KillPlayFunc;
            end;
          end;
      end else
        if m_LastHiter.m_btRaceServer = RC_PLAYOBJECT then begin
          nCode := 6;
          m_sString[0] := TPlayObject(m_LastHiter).m_sCharName;
          m_nInteger[0] := TPlayObject(m_LastHiter).m_WAbil.Level;
          TPlayObject(m_LastHiter).m_sString[0] := m_sCharName;
          TPlayObject(m_LastHiter).m_nInteger[0] := m_WAbil.Level;
          nCode := 7;
          TPlayObject(m_LastHiter).KillPlayFunc;
        end;
      if m_LastHiter.m_btRaceServer <> RC_PLAYOBJECT then begin
        nCode := 8;
        m_sString[0] := m_LastHiter.m_sCharName;
        m_nInteger[0] := m_LastHiter.m_WAbil.Level;
      end;
    end;
    nCode := 9;
    Result := DieFunc(); //死亡触发
  except   
    MainOutMessage(format('{%s} TPlayObject.DieGotoLable Code:%d', [g_sExceptionVer, nCode]));
  end;
end;
//负重改变

procedure TBaseObject.WeightChanged;
begin
  m_WAbil.Weight := RecalcBagWeight();
  SendUpdateMsg(Self, RM_WEIGHTCHANGED, 0, 0, 0, 0, '');
end;
//跑步专用检查安全区函数

function TBaseObject.RunToCheckInSafeZone: Boolean;
var
  I, nSafeX, nSafeY: Integer;
  sMapName: string;
  StartPoint: pTStartPoint;
  nCode: Byte;
begin
  Result := False;
  nCode := 0;
  if m_boGhost then Exit;
  try
    nCode := 1;
    if m_PEnvir = nil then begin //修正机器人刷火墙的错误
      Result := True;
      Exit;
    end;
    nCode := 2;
    if (m_PEnvir <> nil) and (not m_boGhost) then begin
      nCode := 21;
      try
        if m_PEnvir.m_boSafeNoRun then Exit; //安全区禁止穿
        Result := m_PEnvir.m_boSAFE;
        nCode := 22;
        if Result then Exit;
        nCode := 3;
        if (m_PEnvir.sMapName <> g_Config.sRedHomeMap) or
          (abs(m_nCurrX - g_Config.nRedHomeX) > g_Config.nSafeZoneSize) or
          (abs(m_nCurrY - g_Config.nRedHomeY) > g_Config.nSafeZoneSize) then begin
          Result := False;
        end else begin
          Result := True;
        end;
      except
        Result := True;
      end;
    end;
    nCode := 4;
    if Result then Exit;
    try
      g_StartPointList.Lock;
      nCode := 5;
      if (g_StartPointList.Count > 0) then begin
        for I := 0 to g_StartPointList.Count - 1 do begin
          nCode := 6;
          sMapName := g_StartPointList.Strings[I];
          if m_boGhost then Break;
          nCode := 12;
          try
            if (m_PEnvir <> nil) and (sMapName <> '') and (not m_boGhost) then begin
              nCode := 11;
              if (sMapName = m_PEnvir.sMapName) then begin
                nCode := 8;
                StartPoint := pTStartPoint(g_StartPointList.Objects[I]);
                if StartPoint <> nil then begin
                  nCode := 9;
                  nSafeX := StartPoint.m_nCurrX;
                  nSafeY := StartPoint.m_nCurrY;
                  nCode := 10;
                  if (abs(m_nCurrX - nSafeX) <= (g_Config.nSafeZoneSize + 2)) and
                    (abs(m_nCurrY - nSafeY) <= (g_Config.nSafeZoneSize + 2)) then begin
                    Result := True;
                    Break;
                  end;
                end;
              end;
            end;
          except
            Break;
          end;
        end; //for
      end;
    finally
      g_StartPointList.UnLock;
    end;
  except   
    MainOutMessage(format('{%s} TBaseObject.RunToCheckInSafeZone Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

function TBaseObject.InSafeZone: Boolean;
var
  I, nSafeX, nSafeY: Integer;
  sMapName: string;
  StartPoint: pTStartPoint;
  nCode: Byte; //20081030
begin
  Result := False; //20080818 增加
  nCode := 0;
  if m_boGhost then Exit; //20081228
  try
    nCode := 1;
    if m_PEnvir = nil then begin //修正机器人刷火墙的错误
      Result := True;
      Exit;
    end;
    nCode := 2;
    if (m_PEnvir <> nil) and (not m_boGhost) then begin
      nCode := 21;
      try
        if m_PEnvir.m_boSafeNoRun then Exit; //安全区禁止穿
        Result := m_PEnvir.m_boSAFE;
        nCode := 22;
        if Result then Exit;
        nCode := 3;
        if (m_PEnvir.sMapName <> g_Config.sRedHomeMap) or
          (abs(m_nCurrX - g_Config.nRedHomeX) > g_Config.nSafeZoneSize) or
          (abs(m_nCurrY - g_Config.nRedHomeY) > g_Config.nSafeZoneSize) then begin
          Result := False;
        end else begin
          Result := True;
        end;
      except
        Result := True; //20090212 加入
        //MainOutMessage('{异常} TBaseObject.InSafeZone Code:'+ IntToStr(nCode));//20090315 注释
      end;
    end;
    nCode := 4;
    if Result then Exit;
    try
      g_StartPointList.Lock;
      nCode := 5;
      if g_StartPointList.Count > 0 then begin //20080629
        for I := 0 to g_StartPointList.Count - 1 do begin
          nCode := 6;
          sMapName := g_StartPointList.Strings[I];
          if m_boGhost then Break; //20081228
          nCode := 12;
          try
            if (m_PEnvir <> nil) and (sMapName <> '') and (not m_boGhost) then begin //20081228
              nCode := 11;
              if (sMapName = m_PEnvir.sMapName) then begin
                nCode := 8;
                StartPoint := pTStartPoint(g_StartPointList.Objects[I]);
                if StartPoint <> nil then begin
                  nCode := 9;
                  nSafeX := StartPoint.m_nCurrX;
                  nSafeY := StartPoint.m_nCurrY;
                  nCode := 10;
                  if (abs(m_nCurrX - nSafeX) <= g_Config.nSafeZoneSize) and
                    (abs(m_nCurrY - nSafeY) <= g_Config.nSafeZoneSize) then begin
                    Result := True;
                    Break;
                  end;
                end;
              end;
            end;
          except
            Break;
          end;
        end; //for
      end;
    finally
      g_StartPointList.UnLock;
    end;
  except   
    MainOutMessage(format('{%s} TBaseObject.InSafeZone Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

function TBaseObject.InSafeZone(Envir: TEnvirnoment; nX, nY: Integer): Boolean;
var
  I, nSafeX, nSafeY: Integer;
  sMapName: string;
  StartPoint: pTStartPoint;
begin
  if m_PEnvir = nil then begin //修正机器人刷火墙的错误 叶随风飘
    Result := True;
    Exit;
  end;
  Result := Envir.m_boSAFE;
  if Result then Exit;
  if (Envir.sMapName <> g_Config.sRedHomeMap) or
    (abs(nX - g_Config.nRedHomeX) > g_Config.nSafeZoneSize) or
    (abs(nY - g_Config.nRedHomeY) > g_Config.nSafeZoneSize) then begin
    Result := False;
  end else begin
    Result := True;
  end;
  if Result then Exit;
  try
    g_StartPointList.Lock;
    if g_StartPointList.Count > 0 then begin //20080629
      for I := 0 to g_StartPointList.Count - 1 do begin
        sMapName := g_StartPointList.Strings[I];
        if (sMapName = Envir.sMapName) then begin
          StartPoint := pTStartPoint(g_StartPointList.Objects[I]);
          if StartPoint <> nil then begin
            nSafeX := StartPoint.m_nCurrX;
            nSafeY := StartPoint.m_nCurrY;
            if (abs(nX - nSafeX) <= g_Config.nSafeZoneSize) and
              (abs(nY - nSafeY) <= g_Config.nSafeZoneSize) then begin
              Result := True;
              Break;
            end;
          end;
        end;
      end; //for
    end;
  finally
    g_StartPointList.UnLock;
  end;
end;

//不能走动模式

procedure TBaseObject.OpenHolySeizeMode(dwInterval: LongWord);
begin
  m_boHolySeize := True;
  m_dwHolySeizeTick := GetTickCount();
  m_dwHolySeizeInterval := dwInterval;
  RefNameColor();
end;

procedure TBaseObject.BreakHolySeizeMode;
begin
  m_boHolySeize := False;
  RefNameColor();
end;
//开启怪物狂化模式

procedure TBaseObject.OpenCrazyMode(nTime: Integer);
begin
  m_boCrazyMode := True;
  m_dwCrazyModeTick := GetTickCount();
  m_dwCrazyModeInterval := nTime * 1000;
  RefNameColor();
end;
//关闭怪物狂化模式

procedure TBaseObject.BreakCrazyMode;
begin
  if m_boCrazyMode then begin
    m_boCrazyMode := False;
    RefNameColor();
  end;
end;

procedure TPlayObject.LeaveGroup;
resourcestring
  sExitGropMsg = '%s 退出小组';
begin
  SendGroupText(Format(sExitGropMsg, [m_sCharName]));
  m_GroupOwner := nil;
  SendMsg(Self, RM_GROUPCANCEL, 0, 0, 0, 0, '');
end;

function TPlayObject.CancelGroup: Boolean;
resourcestring
  sCanceGrop = '你的小组被解散了。';
begin
  Result := True;
  if m_GroupMembers.Count <= 1 then begin
    SendGroupText(sCanceGrop);
    m_GroupMembers.Clear;
    m_GroupOwner := nil;
    Result := False;
  end;
end;
//发送组队数据

procedure TPlayObject.SendGroupMembers;
var
  I: Integer;
  PlayObject: TPlayObject;
  sSENDMSG: string;
begin
  sSENDMSG := '';
  if m_GroupMembers.Count > 0 then begin //20080629
    for I := 0 to m_GroupMembers.Count - 1 do begin
      PlayObject := TPlayObject(m_GroupMembers.Objects[I]);
      if PlayObject <> nil then sSENDMSG := sSENDMSG + PlayObject.m_sCharName + '/';
    end;
    for I := 0 to m_GroupMembers.Count - 1 do begin
      PlayObject := TPlayObject(m_GroupMembers.Objects[I]);
      if PlayObject <> nil then PlayObject.SendDefMessage(SM_GROUPMEMBERS, 0, 0, 0, 0, sSENDMSG);
    end;
  end;
end;
//根据魔法ID,取魔法数据

function TPlayObject.GetMagicInfo(nMagicID: Integer): pTUserMagic;
var
  I: Integer;
  UserMagic: pTUserMagic;
begin
  Result := nil;
  if m_MyHero <> nil then begin //20090512 修改
    case nMagicID of
      60..65: begin
          Result := THeroObject(m_MyHero).FindTogetherMagic;
          Exit;
        end;
    end;
  end;
  if m_MagicList.Count > 0 then begin //20080629
    for I := 0 to m_MagicList.Count - 1 do begin
      UserMagic := m_MagicList.Items[I];
      if UserMagic <> nil then begin
        if UserMagic.MagicInfo.wMagicId = nMagicID then begin
          Result := UserMagic;
          Break;
        end;
      end;
    end;
  end;
end;

function TPlayObject.GetMagicInfo(sMagicName: string): pTUserMagic;
var
  I: Integer;
  UserMagic: pTUserMagic;
begin
  Result := nil;
  if m_MagicList.Count > 0 then begin //20080629
    for I := 0 to m_MagicList.Count - 1 do begin
      UserMagic := m_MagicList.Items[I];
      if CompareText(UserMagic.MagicInfo.sMagicName, sMagicName) = 0 then begin
        Result := UserMagic;
        Break;
      end;
    end;
  end;
end;
//取技能消耗的MP值

function TPlayObject.GetSpellPoint(UserMagic: pTUserMagic): Integer;
begin //spell-魔法消耗                        //修炼等级        //魔法等级                        //升级魔法
  Result := Round(UserMagic.MagicInfo.wSpell / (UserMagic.MagicInfo.btTrainLv + 1) * (UserMagic.btLevel + 1)) + UserMagic.MagicInfo.btDefSpell;
end;
//野蛮冲撞

function TPlayObject.DoMotaebo(nDir: Byte; nMagicLevel: Integer): Boolean;
  function CanMotaebo(BaseObject: TBaseObject): Boolean;
  var
    nC: Integer;
  begin
    Result := False;
    if ((m_nStickIncLevel + m_Abil.Level) > BaseObject.m_Abil.Level) and (not BaseObject.m_boStickMode) then begin
      nC := m_nStickIncLevel + m_Abil.Level - BaseObject.m_Abil.Level;
      if Random(20) < ((nMagicLevel * 4) + 6 + nC) then begin
        if IsProperTarget(BaseObject) then Result := True;
      end;
    end;
  end;
var
  bo35: Boolean;
  I, n20, n24, n28: Integer;
  PoseCreate: TBaseObject;
  BaseObject_30: TBaseObject;
  BaseObject_34: TBaseObject;
  nX, nY: Integer;
begin
  Result := False;
  //增加禁锢检测 By TasNat at: 2012-03-08 12:22:41
  if (InMag113LockRect(m_nCurrX, m_nCurrY)) then begin
    SysMsg('禁锢中无法使用...', c_Red, t_Hint);
    Exit;
  end;

  bo35 := True;
  m_btDirection := nDir;
  BaseObject_34 := nil;
  n24 := nMagicLevel + 1;
  n28 := n24;
  PoseCreate := GetPoseCreate(); //取对面的角色
  if PoseCreate <> nil then begin
    for I := 0 to _MAX(2, nMagicLevel + 1) do begin
      PoseCreate := GetPoseCreate();
      if PoseCreate <> nil then begin
        n28 := 0;

        //增加禁锢检测 By TasNat at: 2012-03-08 12:22:41
        if (InMag113LockRect(nX, nY)) then Break;

        if not CanMotaebo(PoseCreate) then Break;
        if nMagicLevel >= 3 then begin
          if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, 2, nX, nY) then begin
            BaseObject_30 := m_PEnvir.GetMovingObject(nX, nY, True);
            if (BaseObject_30 <> nil) and CanMotaebo(BaseObject_30) then begin
              BaseObject_30.CharPushed(m_btDirection, 1);
              if BaseObject_30.m_btRaceServer = RC_PLAYOBJECT then
                TPlayObject(BaseObject_30).CmdUserCmd('@MagTagFunc27');//人物技能触发 20080609

            end;
          end;
        end;
        BaseObject_34 := PoseCreate;
        if PoseCreate.CharPushed(m_btDirection, 1) <> 1 then Break;
        GetFrontPosition(nX, nY);
        if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nX, nY, False) > 0 then begin
          m_nCurrX := nX;
          m_nCurrY := nY;
          SendRefMsg(RM_RUSH, nDir, m_nCurrX, m_nCurrY, 0, '');
          bo35 := False;
          Result := True;
        end;
        Dec(n24);
      end; //if PoseCreate <> nil  then begin
    end; //for i:=0 to _MAX(2,nMagicLevel + 1) do begin
  end else begin //if PoseCreate <> nil  then begin
    bo35 := False;
    for I := 0 to _MAX(2, nMagicLevel + 1) do begin
      GetFrontPosition(nX, nY); //sub_004B2790
      //增加禁锢检测 By TasNat at: 2012-03-08 12:22:41
      if (InMag113LockRect(nX, nY)) then Break;
      if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nX, nY, False) > 0 then begin
        m_nCurrX := nX;
        m_nCurrY := nY;
        SendRefMsg(RM_RUSH, nDir, m_nCurrX, m_nCurrY, 0, '');
        Dec(n28);
      end else begin
        if m_PEnvir.CanWalk(nX, nY, True) then n28 := 0
        else begin
          bo35 := True;
          Break;
        end;
      end;
    end;
  end;
  if (BaseObject_34 <> nil) then begin //目标掉血
    if n24 < 0 then n24 := 0;
    //n20 := Random((n24 + 1) * 10) + ((n24 + 1) * 10);
    if n24 > 3 then n24 := 3; //更换算法
    n20 := Random((n24 + 1) * 5) + ((n24 + 1) * 5);
    n20 := BaseObject_34.GetHitStruckDamage(Self, n20);
    BaseObject_34.StruckDamage(n20);
    BaseObject_34.SendRefMsg(RM_STRUCK, n20, BaseObject_34.m_WAbil.HP, BaseObject_34.m_WAbil.MaxHP, Integer(Self), '');
    if BaseObject_34.m_btRaceServer <> RC_PLAYOBJECT then begin
      BaseObject_34.SendMsg(BaseObject_34, RM_STRUCK, n20, BaseObject_34.m_WAbil.HP, BaseObject_34.m_WAbil.MaxHP, Integer(Self), '');
    end;
  end;
  if bo35 then begin
    GetFrontPosition(nX, nY);
    SendRefMsg(RM_RUSHKUNG, m_btDirection, nX, nY, 0, '');
    SysMsg(sMateDoTooweak {冲撞力不够！！！}, c_Red, t_Hint);
  end;
  if n28 > 0 then begin //自已掉血
    if n24 < 0 then n24 := 0;
    n20 := Random(n24 * 10) + ((n24 + 1) * 3);
    n20 := GetHitStruckDamage(Self, n20);
    StruckDamage(n20);
    SendRefMsg(RM_STRUCK, n20, m_WAbil.HP, m_WAbil.MaxHP, 0, '');
  end;
end;
//增加技能的修练值 20080112

procedure TBaseObject.TrainSkill(UserMagic: pTUserMagic; nTranPoint: Integer);
begin
  if m_boFastTrain then nTranPoint := nTranPoint * 3;
  Inc(UserMagic.nTranPoint, nTranPoint);
end;
//检查魔法升级

function TBaseObject.CheckMagicLevelup(UserMagic: pTUserMagic): Boolean;
var
  n10: Integer;
  nMaxExp, TrainExp: LongWord;
  nNeedNGLevel, nNeedItemCount: Word;
begin
  Result := False;
  try
    if (UserMagic.btLevel < 4) and (UserMagic.MagicInfo.btTrainLv >= UserMagic.btLevel) then
      n10 := UserMagic.btLevel
    else n10 := 0;
    if (UserMagic.MagicInfo.btTrainLv >= UserMagic.btLevel) and (UserMagic.wMagIdx in [SKILL_76..SKILL_87]) then begin //连击技能4，5级按3级的修炼点
      if UserMagic.btLevel in [4, 5] then n10 := 3;
    end;
    case UserMagic.wMagIdx of //20110818
      SKILL_100: TrainExp := 500 + (UserMagic.btLevel * 700);
{$IF M2Version <> 2}
      SKILL_105: TrainExp := UserMagic.MagicInfo.MaxTrain[0] + UserMagic.btLevel * (UserMagic.MagicInfo.MaxTrain[2] - UserMagic.MagicInfo.MaxTrain[1]);
      SKILL_107, SKILL_108, SKILL_109: TrainExp := UserMagic.MagicInfo.MaxTrain[0] + UserMagic.btLevel * (UserMagic.MagicInfo.MaxTrain[2] - UserMagic.MagicInfo.MaxTrain[1]);
{$IFEND}
    else TrainExp := UserMagic.MagicInfo.MaxTrain[n10];
    end; //case
    if (UserMagic.MagicInfo.btTrainLv > UserMagic.btLevel) and
      ({UserMagic.MagicInfo.MaxTrain[n10]}TrainExp <= UserMagic.nTranPoint) then begin //20110818 修改
      if (UserMagic.MagicInfo.btTrainLv > UserMagic.btLevel) then begin
        //先天元力不减修改经验
        if UserMagic.wMagIdx <> SKILL_67 then Dec(UserMagic.nTranPoint, {UserMagic.MagicInfo.MaxTrain[n10]} TrainExp); //20110818 修改
        Inc(UserMagic.btLevel);
        case m_btRaceServer of
          RC_PLAYOBJECT: begin
              case UserMagic.wMagIdx of //20110821
                SKILL_100: begin
                    nMaxExp := 500 + (UserMagic.btLevel * 700);
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nMaxExp, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                  end;
{$IF M2Version <> 2}
                SKILL_105: begin
                    nMaxExp := UserMagic.MagicInfo.MaxTrain[0] + UserMagic.btLevel * (UserMagic.MagicInfo.MaxTrain[2] - UserMagic.MagicInfo.MaxTrain[1]);
                {SendUpdateDelayMsg}SendDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nMaxExp, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                    if TPlayObject(Self).m_MyDivision <> nil then begin
                      if CompareText(TDivision(TPlayObject(Self).m_MyDivision).GetChiefName, m_sCharName) = 0 then begin //是否为门派老大
                        case UserMagic.btLevel of //更新门派传承心法等级
                          1..4: TDivision(TPlayObject(Self).m_MyDivision).nHeartLevel := 1;
                          5..9: TDivision(TPlayObject(Self).m_MyDivision).nHeartLevel := 2;
                          10..19: TDivision(TPlayObject(Self).m_MyDivision).nHeartLevel := 3;
                          20..29: TDivision(TPlayObject(Self).m_MyDivision).nHeartLevel := 4;
                          30..39: TDivision(TPlayObject(Self).m_MyDivision).nHeartLevel := 5;
                          40..49: TDivision(TPlayObject(Self).m_MyDivision).nHeartLevel := 6;
                          50..59: TDivision(TPlayObject(Self).m_MyDivision).nHeartLevel := 7;
                          60..69: TDivision(TPlayObject(Self).m_MyDivision).nHeartLevel := 8;
                          70..100: TDivision(TPlayObject(Self).m_MyDivision).nHeartLevel := 9;
                        end;
                        TDivision(TPlayObject(Self).m_MyDivision).SaveDivisionConfig(g_Config.sDivisionDir + TDivision(TPlayObject(Self).m_MyDivision).sDivisionName + '.ini');
                      end;
                    end;
                    TPlayObject(Self).DoSendHeartInfo(); //发送心法相关数据
                    if UserMagic.btLevel in [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] then begin
                      UserEngine.SendBroadCastMsgExt(Format(sHeartUpLevelHit, [m_sCharName, TPlayObject(Self).m_sHeartName, UserMagic.btLevel]), t_Say);
                    end;
                  end;
                SKILL_107, SKILL_108, SKILL_109: begin
                    nMaxExp := UserMagic.MagicInfo.MaxTrain[0] + UserMagic.btLevel * (UserMagic.MagicInfo.MaxTrain[2] - UserMagic.MagicInfo.MaxTrain[1]);
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nMaxExp, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                  end;
                SKILL_200: begin //怒之攻杀
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                    if (UserMagic.btLevel > 2) and (UserMagic.btLevel < g_Config.nNGSkillMaxLevel) then begin
                      nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_200NGStrong[0] + (UserMagic.btLevel - 3) * g_Config.nSKILL_200NGStrong[1]);
                      nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_200NGStrong[2] + (UserMagic.btLevel - 3) * g_Config.nSKILL_200NGStrong[3]);
                      SendMsg(Self, RM_NGMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nNeedNGLevel, UserMagic.btLevel, nNeedItemCount, '');
                    end;
                  end;
                Skill_202: begin //怒之半月
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                    if (UserMagic.btLevel > 2) and (UserMagic.btLevel < g_Config.nNGSkillMaxLevel) then begin
                      nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_202NGStrong[0] + (UserMagic.btLevel - 3) * g_Config.nSKILL_202NGStrong[1]);
                      nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_202NGStrong[2] + (UserMagic.btLevel - 3) * g_Config.nSKILL_202NGStrong[3]);
                      SendMsg(Self, RM_NGMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nNeedNGLevel, UserMagic.btLevel, nNeedItemCount, '');
                    end;
                  end;
                Skill_236: begin //怒之内功剑法
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                    if (UserMagic.btLevel > 2) and (UserMagic.btLevel < g_Config.nNGSkillMaxLevel) then begin
                      nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_236NGStrong[0] + (UserMagic.btLevel - 3) * g_Config.nSKILL_236NGStrong[1]);
                      nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_236NGStrong[2] + (UserMagic.btLevel - 3) * g_Config.nSKILL_236NGStrong[3]);
                      SendMsg(Self, RM_NGMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nNeedNGLevel, UserMagic.btLevel, nNeedItemCount, '');
                    end;
                  end;
                Skill_204: begin //怒之烈火
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                    if (UserMagic.btLevel > 2) and (UserMagic.btLevel < g_Config.nNGSkillMaxLevel) then begin
                      nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_204NGStrong[0] + (UserMagic.btLevel - 3) * g_Config.nSKILL_204NGStrong[1]);
                      nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_204NGStrong[2] + (UserMagic.btLevel - 3) * g_Config.nSKILL_204NGStrong[3]);
                      SendMsg(Self, RM_NGMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nNeedNGLevel, UserMagic.btLevel, nNeedItemCount, '');
                    end;
                  end;
                Skill_206: begin //怒之逐日
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                    if (UserMagic.btLevel > 2) and (UserMagic.btLevel < g_Config.nNGSkillMaxLevel) then begin
                      nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_206NGStrong[0] + (UserMagic.btLevel - 3) * g_Config.nSKILL_206NGStrong[1]);
                      nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_206NGStrong[2] + (UserMagic.btLevel - 3) * g_Config.nSKILL_206NGStrong[3]);
                      SendMsg(Self, RM_NGMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nNeedNGLevel, UserMagic.btLevel, nNeedItemCount, '');
                    end;
                  end;
                Skill_239: begin //怒之施毒术
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                    if (UserMagic.btLevel > 2) and (UserMagic.btLevel < g_Config.nNGSkillMaxLevel) then begin
                      nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_239NGStrong[0] + (UserMagic.btLevel - 3) * g_Config.nSKILL_239NGStrong[1]);
                      nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_239NGStrong[2] + (UserMagic.btLevel - 3) * g_Config.nSKILL_239NGStrong[3]);
                      SendMsg(Self, RM_NGMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nNeedNGLevel, UserMagic.btLevel, nNeedItemCount, '');
                    end;
                  end;
                Skill_230: begin //怒之火符
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                    if (UserMagic.btLevel > 2) and (UserMagic.btLevel < g_Config.nNGSkillMaxLevel) then begin
                      nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_230NGStrong[0] + (UserMagic.btLevel - 3) * g_Config.nSKILL_230NGStrong[1]);
                      nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_230NGStrong[2] + (UserMagic.btLevel - 3) * g_Config.nSKILL_230NGStrong[3]);
                      SendMsg(Self, RM_NGMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nNeedNGLevel, UserMagic.btLevel, nNeedItemCount, '');
                    end;
                  end;
                Skill_232: begin //怒之噬血
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                    if (UserMagic.btLevel > 2) and (UserMagic.btLevel < g_Config.nNGSkillMaxLevel) then begin
                      nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_232NGStrong[0] + (UserMagic.btLevel - 3) * g_Config.nSKILL_232NGStrong[1]);
                      nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_232NGStrong[2] + (UserMagic.btLevel - 3) * g_Config.nSKILL_232NGStrong[3]);
                      SendMsg(Self, RM_NGMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nNeedNGLevel, UserMagic.btLevel, nNeedItemCount, '');
                    end;
                  end;
                Skill_241: begin //怒之月灵
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                    if (UserMagic.btLevel > 2) and (UserMagic.btLevel < g_Config.nNGSkillMaxLevel) then begin
                      nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_241NGStrong[0] + (UserMagic.btLevel - 3) * g_Config.nSKILL_241NGStrong[1]);
                      nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_241NGStrong[2] + (UserMagic.btLevel - 3) * g_Config.nSKILL_241NGStrong[3]);
                      SendMsg(Self, RM_NGMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nNeedNGLevel, UserMagic.btLevel, nNeedItemCount, '');
                    end;
                  end;
                Skill_228: begin //怒之灭天火
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                    if (UserMagic.btLevel > 2) and (UserMagic.btLevel < g_Config.nNGSkillMaxLevel) then begin
                      nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_228NGStrong[0] + (UserMagic.btLevel - 3) * g_Config.nSKILL_228NGStrong[1]);
                      nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_228NGStrong[2] + (UserMagic.btLevel - 3) * g_Config.nSKILL_228NGStrong[3]);
                      SendMsg(Self, RM_NGMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nNeedNGLevel, UserMagic.btLevel, nNeedItemCount, '');
                    end;
                  end;
                Skill_234: begin //怒之流星火雨
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                    if (UserMagic.btLevel > 2) and (UserMagic.btLevel < g_Config.nNGSkillMaxLevel) then begin
                      nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_234NGStrong[0] + (UserMagic.btLevel - 3) * g_Config.nSKILL_234NGStrong[1]);
                      nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_234NGStrong[2] + (UserMagic.btLevel - 3) * g_Config.nSKILL_234NGStrong[3]);
                      SendMsg(Self, RM_NGMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nNeedNGLevel, UserMagic.btLevel, nNeedItemCount, '');
                    end;
                  end;
                Skill_208: begin //怒之火球
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                    if (UserMagic.btLevel > 2) and (UserMagic.btLevel < g_Config.nNGSkillMaxLevel) then begin
                      nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_208NGStrong[0] + (UserMagic.btLevel - 3) * g_Config.nSKILL_208NGStrong[1]);
                      nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_208NGStrong[2] + (UserMagic.btLevel - 3) * g_Config.nSKILL_208NGStrong[3]);
                      SendMsg(Self, RM_NGMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nNeedNGLevel, UserMagic.btLevel, nNeedItemCount, '');
                    end;
                  end;
                Skill_214: begin //怒之地狱火
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                    if (UserMagic.btLevel > 2) and (UserMagic.btLevel < g_Config.nNGSkillMaxLevel) then begin
                      nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_214NGStrong[0] + (UserMagic.btLevel - 3) * g_Config.nSKILL_214NGStrong[1]);
                      nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_214NGStrong[2] + (UserMagic.btLevel - 3) * g_Config.nSKILL_214NGStrong[3]);
                      SendMsg(Self, RM_NGMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nNeedNGLevel, UserMagic.btLevel, nNeedItemCount, '');
                    end;
                  end;
                Skill_218: begin //怒之爆裂火焰
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                    if (UserMagic.btLevel > 2) and (UserMagic.btLevel < g_Config.nNGSkillMaxLevel) then begin
                      nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_218NGStrong[0] + (UserMagic.btLevel - 3) * g_Config.nSKILL_218NGStrong[1]);
                      nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_218NGStrong[2] + (UserMagic.btLevel - 3) * g_Config.nSKILL_218NGStrong[3]);
                      SendMsg(Self, RM_NGMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nNeedNGLevel, UserMagic.btLevel, nNeedItemCount, '');
                    end;
                  end;
                Skill_222: begin //怒之雷电
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                    if (UserMagic.btLevel > 2) and (UserMagic.btLevel < g_Config.nNGSkillMaxLevel) then begin
                      nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_222NGStrong[0] + (UserMagic.btLevel - 3) * g_Config.nSKILL_222NGStrong[1]);
                      nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_222NGStrong[2] + (UserMagic.btLevel - 3) * g_Config.nSKILL_222NGStrong[3]);
                      SendMsg(Self, RM_NGMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nNeedNGLevel, UserMagic.btLevel, nNeedItemCount, '');
                    end;
                  end;
                Skill_210: begin //怒之大火球
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                    if (UserMagic.btLevel > 2) and (UserMagic.btLevel < g_Config.nNGSkillMaxLevel) then begin
                      nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_210NGStrong[0] + (UserMagic.btLevel - 3) * g_Config.nSKILL_210NGStrong[1]);
                      nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_210NGStrong[2] + (UserMagic.btLevel - 3) * g_Config.nSKILL_210NGStrong[3]);
                      SendMsg(Self, RM_NGMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nNeedNGLevel, UserMagic.btLevel, nNeedItemCount, '');
                    end;
                  end;
                Skill_212: begin //怒之火墙
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                    if (UserMagic.btLevel > 2) and (UserMagic.btLevel < g_Config.nNGSkillMaxLevel) then begin
                      nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_212NGStrong[0] + (UserMagic.btLevel - 3) * g_Config.nSKILL_212NGStrong[1]);
                      nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_212NGStrong[2] + (UserMagic.btLevel - 3) * g_Config.nSKILL_212NGStrong[3]);
                      SendMsg(Self, RM_NGMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nNeedNGLevel, UserMagic.btLevel, nNeedItemCount, '');
                    end;
                  end;
                Skill_216: begin //怒之疾光电影
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                    if (UserMagic.btLevel > 2) and (UserMagic.btLevel < g_Config.nNGSkillMaxLevel) then begin
                      nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_216NGStrong[0] + (UserMagic.btLevel - 3) * g_Config.nSKILL_216NGStrong[1]);
                      nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_216NGStrong[2] + (UserMagic.btLevel - 3) * g_Config.nSKILL_216NGStrong[3]);
                      SendMsg(Self, RM_NGMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nNeedNGLevel, UserMagic.btLevel, nNeedItemCount, '');
                    end;
                  end;
                Skill_224: begin //怒之地狱雷光
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                    if (UserMagic.btLevel > 2) and (UserMagic.btLevel < g_Config.nNGSkillMaxLevel) then begin
                      nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_224NGStrong[0] + (UserMagic.btLevel - 3) * g_Config.nSKILL_224NGStrong[1]);
                      nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_224NGStrong[2] + (UserMagic.btLevel - 3) * g_Config.nSKILL_224NGStrong[3]);
                      SendMsg(Self, RM_NGMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nNeedNGLevel, UserMagic.btLevel, nNeedItemCount, '');
                    end;
                  end;
                Skill_226: begin //怒之寒冰掌
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                    if (UserMagic.btLevel > 2) and (UserMagic.btLevel < g_Config.nNGSkillMaxLevel) then begin
                      nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_226NGStrong[0] + (UserMagic.btLevel - 3) * g_Config.nSKILL_226NGStrong[1]);
                      nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_226NGStrong[2] + (UserMagic.btLevel - 3) * g_Config.nSKILL_226NGStrong[3]);
                      SendMsg(Self, RM_NGMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nNeedNGLevel, UserMagic.btLevel, nNeedItemCount, '');
                    end;
                  end;
                Skill_220: begin //怒之冰咆哮
                    SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
                    if (UserMagic.btLevel > 2) and (UserMagic.btLevel < g_Config.nNGSkillMaxLevel) then begin
                      nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_220NGStrong[0] + (UserMagic.btLevel - 3) * g_Config.nSKILL_220NGStrong[1]);
                      nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_220NGStrong[2] + (UserMagic.btLevel - 3) * g_Config.nSKILL_220NGStrong[3]);
                      SendMsg(Self, RM_NGMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, nNeedNGLevel, UserMagic.btLevel, nNeedItemCount, '');
                    end;
                  end;
{$IFEND}
              else SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
              end; //case
{$IF M2Version = 1}
              with TPlayObject(self) do begin
                if m_boTrainingNG and (UserMagic.wMagIdx in [SKILL_76..SKILL_87]) then begin //学过内功
                  case UserMagic.wMagIdx of //更新暴击率
                    SKILL_76, SKILL_77, SKILL_78: begin //三绝杀 双龙破 虎啸诀
                        if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                          m_wHumanPulseArr[0].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                      end;
                    SKILL_79, SKILL_80, SKILL_81: begin //追心刺 凤舞祭 八卦掌
                        if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                          m_wHumanPulseArr[1].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                      end;
                    SKILL_82, SKILL_83, SKILL_84: begin //断岳斩 惊雷爆 三焰咒
                        if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                          m_wHumanPulseArr[2].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                      end;
                    SKILL_85, SKILL_86, SKILL_87: begin //横扫千军 冰天雪地 万剑归宗
                        if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                          m_wHumanPulseArr[3].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                      end;
                  end;
                end;
                SendUserPulseArr; //发送脉穴数据
              end;
{$IFEND}
            end;
          RC_HEROOBJECT: begin
              THeroObject(Self).SendUpdateDelayMsg(m_Master, RM_HEROMAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
{$IF M2Version = 1}
              with THeroObject(self) do begin
                if m_boTrainingNG and (UserMagic.wMagIdx in [SKILL_76..SKILL_87]) then begin //学过内功
                  case UserMagic.wMagIdx of //更新暴击率
                    SKILL_76, SKILL_77, SKILL_78: begin //三绝杀 双龙破 虎啸诀
                        if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                          m_wHumanPulseArr[0].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                      end;
                    SKILL_79, SKILL_80, SKILL_81: begin //追心刺 凤舞祭 八卦掌
                        if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                          m_wHumanPulseArr[1].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                      end;
                    SKILL_82, SKILL_83, SKILL_84: begin //断岳斩 惊雷爆 三焰咒
                        if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                          m_wHumanPulseArr[2].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                      end;
                    SKILL_85, SKILL_86, SKILL_87: begin //横扫千军 冰天雪地 万剑归宗
                        if (UserMagic.btLevel > 0) and (UserMagic.btLevel < 6) then
                          m_wHumanPulseArr[3].nStormsHit := g_Config.nStormsHitAppearRate[UserMagic.btLevel - 1];
                      end;
                  end;
                end;
                SendUserPulseArr; //发送脉穴数据
              end;
{$IFEND}
            end;
        else SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
        end;
        sub_4C713C(UserMagic); //判断心灵启示等级
      end else begin
        UserMagic.nTranPoint := UserMagic.MagicInfo.MaxTrain[n10];
      end;
      Result := True;
    end;
  except
  end;
end;

function TPlayObject.DoSpell(UserMagic: pTUserMagic; nTargetX,
  nTargetY: Integer; BaseObject: TBaseObject): Boolean;
var
  nSpellPoint: Integer;
begin
  Result := False;
  try
    if not MagicManager.IsWarrSkill(UserMagic.wMagIdx) then begin
      nSpellPoint := GetSpellPoint(UserMagic);
      if (nSpellPoint > 0) then begin
        case UserMagic.wMagIdx of
          SKILL_68, SKILL_50, SKILL_71, SKILL_97, SKILL_98, SKILL_105,
            SKILL_60, SKILL_61, SKILL_62, SKILL_63, SKILL_64, SKILL_65: ; //合击技能不减MP,酒气护体,无极真气,召唤圣兽不在此处减MP
          SKILL_110..SKILL_114: begin //主动神技
{$IF M2Version <> 2}
              if (m_MagicSkill_105 <> nil) then begin
                if (GetTickCount - mHeartSkillTick > g_Config.nHeartSkilltime * 1000) then begin
                  if (m_Skill69NH >= nSpellPoint) then begin
                    mHeartSkillTick := GetTickCount();
                    m_Skill69NH := _MAX(0, m_Skill69NH - nSpellPoint);
                    SendRefMsg(RM_MAGIC69SKILLNH, 0, m_Skill69NH, m_Skill69MaxNH, 0, '');
                  end else begin
                    SysMsg('内力不足,无法使用龙卫神技！', c_Green, t_Hint);
                    Exit;
                  end;
                end else begin
                  SysMsg(Format('龙卫神技冷却时间还有%d', [(g_Config.nHeartSkilltime - (GetTickCount - mHeartSkillTick) div 1000)]), c_Green, t_Hint); //提示用户
                  Exit;
                end;
              end else begin
                SysMsg('未学有龙卫心法无法使用龙卫神技！', c_Green, t_Hint);
                Exit;
              end;
{$IFEND}
            end;
        else begin
            if m_WAbil.MP < nSpellPoint then Exit;
            DamageSpell(nSpellPoint);
            HealthSpellChanged();
          end;
        end;
      end;
{$IF M2Version <> 2}
      if m_boTrainingNG and
        (not (UserMagic.wMagIdx in [SKILL_HEALLING, SKILL_BIGHEALLING, SKILL_105, SKILL_110..SKILL_114])) then begin //20081003 学过内功心法,每攻击一次减一点内力值
        m_Skill69NH := _MAX(0, m_Skill69NH - g_Config.nHitStruckDecNH);
        SendRefMsg(RM_MAGIC69SKILLNH, 0, m_Skill69NH, m_Skill69MaxNH, 0, '');
      end;
{$IFEND}
      Result := MagicManager.DoSpell(Self, UserMagic, nTargetX, nTargetY, BaseObject);
    end;
  except
    on E: Exception do begin
      MainOutMessage(Format('{%s} TPlayObject.DoSpell MagID:%d X:%d Y:%d', [g_sExceptionVer, UserMagic.wMagIdx, nTargetX, nTargetY]));
    end;
  end;
end;

//挖矿

function TPlayObject.PileStones(nX, nY: Integer): Boolean;
var
  //Event: TEvent;
  PileEvent: TEvent;
  s1C: string;
begin
  Result := False;
  s1C := '';
  {Event := TEvent(m_PEnvir.GetEvent(nX, nY));
  if (Event <> nil) then begin//20090203
    if (Event.m_nEventType = ET_STONEMINE) then begin
      if TStoneMineEvent(Event).m_nMineCount > 0 then begin
        Dec(TStoneMineEvent(Event).m_nMineCount);       }
  if Random(g_Config.nMakeMineHitRate {4}) = 0 then begin //命中机率
    PileEvent := TEvent(m_PEnvir.GetEvent(m_nCurrX, m_nCurrY));
    if PileEvent = nil then begin //显示挖出一堆矿的场景
      PileEvent := TPileStones.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_PILESTONES, 300000 {5 * 60 * 1000});
      g_EventManager.AddEvent(PileEvent);
    end else begin
      if PileEvent.m_nEventType = ET_PILESTONES then TPileStones(PileEvent).AddEventParam;
    end;
    if Random(g_Config.nMakeMineRate {12}) = 0 then begin //挖矿,给玩家矿石
      if m_PEnvir.m_boMINE then MakeMine(); //20100903 修改
    end;
    s1C := '1';
    DoDamageWeapon(Random(15) + 5); //减锄头持久
    Result := True;
  end;
      (*end else begin
        if (GetTickCount - TStoneMineEvent(Event).m_dwAddStoneMineTick) > 600000{10 * 60 * 1000} then
          TStoneMineEvent(Event).AddStoneMine();
      end;
    end;
  end;  *)
  SendRefMsg(RM_HEAVYHIT, m_btDirection, m_nCurrX, m_nCurrY, 0, s1C);
end;
//设置目标

procedure TBaseObject.SetTargetCreat(BaseObject: TBaseObject);
begin
  m_TargetCret := BaseObject;
  m_dwTargetFocusTick := GetTickCount();
end;
//清除目标

procedure TBaseObject.DelTargetCreat();
begin
  m_TargetCret := nil;
end;

function TBaseObject._Attack(var wHitMode: Word; AttackTarget: TBaseObject): Boolean;
var
  nPower, nSecPwr, NGSecPwr, NGSecPwr1, nWeaponDamage, nRandom: Integer;
  bo21, bo22, bo23, bo24, bo25, bo26, boisBaseObject, boHeartSkill: Boolean;
  n20: Integer;
  nCheckCode: Byte;
  MaxTrain: LongWord;
resourcestring
  sExceptionMsg = '{%s} TBaseObject::_Attack Name:%s Code:%d.%p';
  function MPow(UserMagic: pTUserMagic): Integer; //20080531 计算技能威力
  var nPower: Integer;
  begin
    if UserMagic.MagicInfo.wMaxPower > UserMagic.MagicInfo.wPower then begin //20090807 增加
      nPower := UserMagic.MagicInfo.wPower + Random(UserMagic.MagicInfo.wMaxPower - UserMagic.MagicInfo.wPower)
    end else nPower := UserMagic.MagicInfo.wPower;
    if UserMagic.MagicInfo.btDefMaxPower > UserMagic.MagicInfo.btDefPower then begin //20090807 增加
      Result := nPower + (UserMagic.btLevel * UserMagic.MagicInfo.btDefPower + Random(UserMagic.MagicInfo.btDefMaxPower - UserMagic.MagicInfo.btDefPower))
    end else Result := nPower + (UserMagic.btLevel * UserMagic.MagicInfo.btDefPower);
  end;
{$IF M2Version <> 2}
  function GetNGPow(BaseObject: TBaseObject; UserMagic: pTUserMagic; Power: Integer): Integer; //内功技能掉内力值
  var nNHPoint: Integer;
  begin
    Result := 0;
    if (UserMagic <> nil) and (BaseObject <> nil) then begin
      if UserMagic.btKey = 0 then begin //内功技能开启 20110426
        case BaseObject.m_btRaceServer of
          RC_PLAYOBJECT: begin
              nNHPoint := TPlayObject(BaseObject).GetSpellPoint(UserMagic); //掉内力值
              if TPlayObject(BaseObject).m_Skill69NH >= nNHPoint then begin
                TPlayObject(BaseObject).m_Skill69NH := _MAX(0, TPlayObject(BaseObject).m_Skill69NH - nNHPoint);
                TPlayObject(BaseObject).SendREFMsg(RM_MAGIC69SKILLNH, 0, TPlayObject(BaseObject).m_Skill69NH, TPlayObject(BaseObject).m_Skill69MaxNH, 0, '');
                if g_Config.nNGSkillRate = 0 then begin //20090808 修改
                  Result := MPow(UserMagic);
                end else Result := Round(Power * ((UserMagic.btLevel + 1) * (g_Config.nNGSkillRate / 100))); //计算攻击力
                TPlayObject(BaseObject).NGMAGIC_LVEXP(UserMagic); //内功技能升级 20081003
              end;
            end;
          RC_HEROOBJECT: begin
              nNHPoint := THEROOBJECT(BaseObject).GetSpellPoint(UserMagic);
              if THEROOBJECT(BaseObject).m_Skill69NH >= nNHPoint then begin
                THEROOBJECT(BaseObject).m_Skill69NH := _MAX(0, THEROOBJECT(BaseObject).m_Skill69NH - nNHPoint);
                THEROOBJECT(BaseObject).SendREFMsg(RM_MAGIC69SKILLNH, 0, THEROOBJECT(BaseObject).m_Skill69NH, THEROOBJECT(BaseObject).m_Skill69MaxNH, 0, '');
                if g_Config.nNGSkillRate = 0 then begin //20090808 修改
                  Result := MPow(UserMagic);
                end else Result := Round(Power * ((UserMagic.btLevel + 1) * (g_Config.nNGSkillRate / 100))); //计算攻击力
                THEROOBJECT(BaseObject).NGMAGIC_LVEXP(UserMagic); //内功技能升级 20081003
              end;
            end;
        end;
      end;
    end;
  end;
{$IFEND}
//攻击角色
  function DirectAttack(BaseObject: TBaseObject; nSecPwr: Integer; boIsObject: Boolean): Boolean;
  begin
    Result := False; //20080923 增加
    if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) or
      (BaseObject.m_btRaceServer = RC_HEROOBJECT) or //20080923 增加
      (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or
      not (InSafeZone and BaseObject.InSafeZone) then begin
      if IsProperTarget(BaseObject) then begin
        if Random(BaseObject.m_btSpeedPoint) < m_btHitPoint then begin
          BaseObject.StruckDamage(nSecPwr);
          BaseObject.SendDelayMsg(TBaseObject(RM_STRUCK),
            RM_10101,
            nSecPwr,
            BaseObject.m_WAbil.HP,
            BaseObject.m_WAbil.MaxHP,
            Integer(Self), '', 500);
          if (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) and //20081005 增加英雄过滤
            (BaseObject.m_btRaceServer <> RC_HEROOBJECT) and (not boIsObject) then begin
            BaseObject.SendMsg(BaseObject,
              RM_STRUCK,
              nSecPwr,
              BaseObject.m_WAbil.HP,
              BaseObject.m_WAbil.MaxHP,
              Integer(Self), '');
          end;
          Result := True;
        end;
      end;
    end;
  end;
  //刺杀前面一个位置的攻击   20080924 修改
  function SwordLongAttack(nSecPwr, nLevel: Integer; Target: TBaseObject): Boolean;
  var
    nX, nY: Integer;
    BaseObject: TBaseObject;
  begin
    Result := False;
    try //20090408 增加
      boisBaseObject := False;
      nSecPwr := Round(nSecPwr * (g_Config.nSwordLongPowerRate / 100));
      //nSecPwr := Round(nSecPwr * (nLevel * 0.2 + 0.4));//20081208 按技能等级计算攻击力 20110507 注释
{$IF M2Version <> 2}
      if not g_Config.boLimitSwordLongNG then begin
        case m_btRaceServer of
          RC_PLAYOBJECT: begin //内功护体,增加普通攻击力 20081020
              if TPlayObject(self).m_boTrainingNG and (TPlayObject(self).m_Skill69NH > 0) then begin
                case m_btJob of //20090812 按职业来计算内功攻击力
                  0: nSecPwr := nSecPwr + (TPlayObject(self).m_NGLevel div g_Config.nWarrNGLevelIncDC) + 5;
                  1: nSecPwr := nSecPwr + (TPlayObject(self).m_NGLevel div g_Config.nWizardNGLevelIncDC) + 3;
                  2: nSecPwr := nSecPwr + (TPlayObject(self).m_NGLevel div g_Config.nTaosNGLevelIncDC) + 3;
                end;
              end;
            end;
          RC_HEROOBJECT: begin
              if THeroObject(self).m_boTrainingNG and (THeroObject(self).m_Skill69NH > 0) then begin
                case m_btJob of //20090812 按职业来计算内功攻击力
                  0: nSecPwr := nSecPwr + (THeroObject(self).m_NGLevel div g_Config.nWarrNGLevelIncDC) + 5;
                  1: nSecPwr := nSecPwr + (THeroObject(self).m_NGLevel div g_Config.nWizardNGLevelIncDC) + 3;
                  2: nSecPwr := nSecPwr + (THeroObject(self).m_NGLevel div g_Config.nTaosNGLevelIncDC) + 3;
                end;
              end;
            end;
        end;
      end;
{$IFEND}
      if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, 2, nX, nY) then begin
        BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
        if BaseObject <> nil then begin
          if (nSecPwr > 0) and IsProperTarget(BaseObject) then begin
            if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
              TPlayObject(BaseObject).CmdUserCmd('@MagTagFunc12');//人物技能触发By TasNat at: 2012-07-21 16:49:36

            if Target <> nil then begin //判断刀尖位置与目标是不是同个对像
              if BaseObject = Target then boisBaseObject := True;
            end;
{$IF M2Version <> 2}
            if not g_Config.boLimitSwordLongNG then begin
              case BaseObject.m_btRaceServer of
                RC_PLAYOBJECT: begin //内功护体,增加防御 20081020
                    if TPlayObject(BaseObject).m_boTrainingNG and (TPlayObject(BaseObject).m_Skill69NH > 0) then begin
                      case m_btJob of //20090812 按职业来计算内功防御力
                        0: nSecPwr := _MAX(0, nSecPwr - ((TPlayObject(BaseObject).m_NGLevel div g_Config.nWarrNGLevelIncAC) + 12));
                        1: nSecPwr := _MAX(0, nSecPwr - ((TPlayObject(BaseObject).m_NGLevel div g_Config.nWizardNGLevelIncAC) + 15));
                        2: nSecPwr := _MAX(0, nSecPwr - ((TPlayObject(BaseObject).m_NGLevel div g_Config.nTaosNGLevelIncAC) + 13));
                      end;
                      TPlayObject(BaseObject).m_Skill69NH := _MAX(0, TPlayObject(BaseObject).m_Skill69NH - g_Config.nHitStruckDecNH);
                      TPlayObject(BaseObject).SendRefMsg(RM_MAGIC69SKILLNH, 0, TPlayObject(BaseObject).m_Skill69NH, TPlayObject(BaseObject).m_Skill69MaxNH, 0, '');
                    end;
                  end;
                RC_HEROOBJECT: begin
                    if THeroObject(BaseObject).m_boTrainingNG and (THeroObject(BaseObject).m_Skill69NH > 0) then begin
                      case m_btJob of //20090812 按职业来计算内功防御力
                        0: nSecPwr := _MAX(0, nSecPwr - ((THeroObject(Self).m_NGLevel div g_Config.nWarrNGLevelIncAC) + 12));
                        1: nSecPwr := _MAX(0, nSecPwr - ((THeroObject(Self).m_NGLevel div g_Config.nWizardNGLevelIncAC) + 15));
                        2: nSecPwr := _MAX(0, nSecPwr - ((THeroObject(Self).m_NGLevel div g_Config.nTaosNGLevelIncAC) + 13));
                      end;
                      THeroObject(BaseObject).m_Skill69NH := _MAX(0, THeroObject(BaseObject).m_Skill69NH - g_Config.nHitStruckDecNH);
                      THeroObject(BaseObject).SendRefMsg(RM_MAGIC69SKILLNH, 0, THeroObject(BaseObject).m_Skill69NH, THeroObject(BaseObject).m_Skill69MaxNH, 0, '');
                    end;
                  end;
              end;
            end;
{$IFEND}
            if BaseObject.m_boAbilMagBubbleDefence then begin //四级盾可防隔位刺杀 20081217
              if BaseObject.m_btMagBubbleDefenceLevel = 4 then begin
                nSecPwr := Round(nSecPwr * 0.86); //四级盾可以减少隔位刺杀14%的攻击力
              end;
            end;
            Result := DirectAttack(BaseObject, nSecPwr, boisBaseObject);
            if (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then m_ExpHitter := BaseObject; //20080711
            if m_btRaceServer <> RC_HEROOBJECT then SetTargetCreat(BaseObject); //20080711
          end;
          Result := True;
        end;
      end;
    except
    end;
  end;
  //半月攻击
  function SwordWideAttack(nSecPwr: Integer; nMode: Word): Boolean;
  var
    nC, n10: Integer;
    nX, nY: Integer;
    BaseObject: TBaseObject;
    nPwr, nSePwr: Integer;
  begin
    Result := False;
    nC := 0;
    while (True) do begin
      try //20101126 防止死循环
        case nMode of
          5: n10 := (m_btDirection + g_Config.WideAttack[nC]) mod 8;
          16: n10 := (m_btDirection + g_Config.CrsAttack[nC]) mod 8;
        end;
        if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, n10, 1, nX, nY) then begin
          BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
          if (nSecPwr > 0) and (BaseObject <> nil) then begin
            if IsProperTarget(BaseObject) then begin
              if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
                TPlayObject(BaseObject).CmdUserCmd('@MagTagFunc25');//人物技能触发By TasNat at: 2012-07-21 16:49:36
              nSePwr := nSecPwr;
{$IF M2Version <> 2}
              if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then begin
                nPwr := 0;
                case BaseObject.m_btRaceServer of
                  RC_PLAYOBJECT: nPwr := GetNGPow(BaseObject, TPlayObject(BaseObject).m_MagicSkill_203, nSePwr); //静之半月
                  RC_HEROOBJECT: nPwr := GetNGPow(BaseObject, THEROOBJECT(BaseObject).m_MagicSkill_203, nSePwr); //静之半月
                end;
                nSePwr := _MAX(0, nSePwr - nPwr);
              end;
{$IFEND}
              Result := DirectAttack(BaseObject, nSePwr, False);
              if (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then m_ExpHitter := BaseObject; //20080711
              if m_btRaceServer <> RC_HEROOBJECT then SetTargetCreat(BaseObject); //20080711
            end;
          end;
        end;
      except
      end;
      Inc(nC);
      case nMode of
        5: if nC >= 3 then Break;
        16: if nC >= 6 then Break;
      else if nC >= 3 then Break; //20101126 增加
      end;
    end;
  end;
  //抱月弯刀
  function CrsWideAttack(nSecPwr: Integer): Boolean;
  var
    nC, n10: Integer;
    nX, nY: Integer;
    BaseObject: TBaseObject;
  begin
    Result := False;
    nC := 0;
    while (True) do begin
      try //20101126 防止死循环
        n10 := (m_btDirection + g_Config.CrsAttack[nC]) mod 8;
        if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, n10, 1, nX, nY) then begin
          BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
          if (nSecPwr > 0) and (BaseObject <> nil) then begin
            if IsProperTarget(BaseObject) then begin
              if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
                TPlayObject(BaseObject).CmdUserCmd('@MagTagFunc40');//人物技能触发By TasNat at: 2012-07-21 16:49:36
              Result := DirectAttack(BaseObject, nSecPwr, False);
              if (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then m_ExpHitter := BaseObject; //20080711
              if m_btRaceServer <> RC_HEROOBJECT then SetTargetCreat(BaseObject); //20080711
            end;
          end;
        end;
      except
      end;
      Inc(nC);
      if nC >= 6 then Break;
    end;
  end;
  //逐日剑法 20080511
  function Attack_74(var Target: TBaseObject; var nSecPwr: Integer): Boolean;
  var
    I, NGSecPwr, nSePwr, nTwePwr: Integer;
    BaseObjectList: TList;
    TargeTBaseObject: TBaseObject;
    nDamage: Integer; //20080929
  begin
    Result := False;
    BaseObjectList := TList.Create;
    nTwePwr := nSecPwr;
    try
      GetDirectionBaseObjects(m_btDirection, 4, BaseObjectList); //同个方向的怪 4格
      if BaseObjectList.Count > 0 then begin //20080629
{$IF M2Version <> 2}
        case m_btRaceServer of
          RC_PLAYOBJECT: begin
              if TPlayObject(self).m_MagicSkill_206 <> nil then begin //20081223
                NGSecPwr := GetNGPow(self, TPlayObject(self).m_MagicSkill_206, nTwePwr); //怒之逐日
                nSecPwr := _MAX(0, nSecPwr + NGSecPwr);
              end;
            end;
          RC_HEROOBJECT: begin
              if THEROOBJECT(self).m_MagicSkill_206 <> nil then begin //20081223
                NGSecPwr := GetNGPow(self, THEROOBJECT(self).m_MagicSkill_206, nTwePwr); //怒之逐日
                nSecPwr := _MAX(0, nSecPwr + NGSecPwr);
              end;
            end;
        end;
{$IFEND}
        for I := 0 to BaseObjectList.Count - 1 do begin
          TargeTBaseObject := TBaseObject(BaseObjectList.Items[I]);
          if TargeTBaseObject <> nil then begin
            if (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then m_ExpHitter := TargeTBaseObject; //20080528
            if IsProperTarget(TargeTBaseObject) then begin
              if TargeTBaseObject.m_btRaceServer = RC_PLAYOBJECT then
                TPlayObject(TargeTBaseObject).CmdUserCmd('@MagTagFunc74');//人物技能触发By TasNat at: 2012-07-21 16:49:36
              if Target = nil then Target := TargeTBaseObject; //20100731 修正：隔位时不涨技能点
              nDamage := 0;
              nSePwr := nSecPwr;
{$IF M2Version <> 2}
              if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then begin
                NGSecPwr := 0;
                case TargeTBaseObject.m_btRaceServer of
                  RC_PLAYOBJECT: NGSecPwr := GetNGPow(TargeTBaseObject, TPlayObject(TargeTBaseObject).m_MagicSkill_207, nTwePwr); //静之逐日
                  RC_HEROOBJECT: NGSecPwr := GetNGPow(TargeTBaseObject, THEROOBJECT(TargeTBaseObject).m_MagicSkill_207, nTwePwr); //静之逐日
                end;
                nSePwr := _MAX(0, nSePwr - NGSecPwr);
              end;
{$IFEND}
              Inc(nDamage, TargeTBaseObject.GetHitStruckDamage(Self, nSePwr)); //20080929 魔法盾,护体神盾减少伤害
              Result := DirectAttack(TargeTBaseObject, nDamage, False);
              if m_btRaceServer <> RC_HEROOBJECT then SetTargetCreat(TargeTBaseObject); //20080528 不让英雄打一个目标后又换另一个目标
            end;
          end;
        end;
      end;
    finally
      BaseObjectList.Free;
    end;
  end;
  //血魄一击(战)
  function Attack_96(Target: TBaseObject; var nSecPwr: Integer): Boolean;
  var
    I: Integer;
    BaseObjectList: TList;
    TargeTBaseObject: TBaseObject;
    nDamage, nDamage1, nLevelPoor: Integer;
  begin
    Result := False;
    nDamage1 := nSecPwr;
    if (Random(g_Config.dwBloodSoulRate) = 0) then
      nSecPwr := Round(nSecPwr * (g_Config.nBloodSoulHitRate / 100)); //暴击倍数
    BaseObjectList := TList.Create;
    try
      GetDirectionBaseObjects(m_btDirection, 2, BaseObjectList); //2格内的目标
      if Target <> nil then Target.SendRefMsg(RM_10205, 20, 0 {X}, 0 {Y}, 0, ''); //击中目标的效果 20100323
      if BaseObjectList.Count > 0 then begin
        for I := 0 to BaseObjectList.Count - 1 do begin
          TargeTBaseObject := TBaseObject(BaseObjectList.Items[I]);
          if TargeTBaseObject <> nil then begin
            if (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then m_ExpHitter := TargeTBaseObject;
            if IsProperTarget(TargeTBaseObject) then begin
              if TargeTBaseObject.m_btRaceServer = RC_PLAYOBJECT then
                TPlayObject(TargeTBaseObject).CmdUserCmd('@MagTagFunc96');//人物技能触发By TasNat at: 2012-07-21 16:49:36
              nDamage := 0;
              Inc(nDamage, TargeTBaseObject.GetHitStruckDamage(Self, nSecPwr)); //魔法盾,护体神盾减少伤害
              if g_Config.boUseNewAttackFFT_96 then begin
                nLevelPoor := 0;
                nLevelPoor := TargeTBaseObject.m_Abil.Level - m_Abil.Level;
                if nLevelPoor > 50 then nLevelPoor := 50;
                if nLevelPoor > 0 then Inc(nDamage, Round(nDamage1 * nLevelPoor * 0.05)); //20100701 修改，按等级差增加威力
              end else begin
                if TargeTBaseObject.m_Abil.Level > m_Abil.Level then Inc(nDamage, Round(nDamage1 * 0.05));
              end;
              Result := DirectAttack(TargeTBaseObject, nDamage, False);
              if m_btRaceServer <> RC_HEROOBJECT then SetTargetCreat(TargeTBaseObject); //不让英雄打一个目标后又换另一个目标
            end;
          end;
        end;
      end;
    finally
      BaseObjectList.Free;
    end;
  end;
//开天斩 20080209
  function Attack_42(nSecPwr, m_n42kill: Integer): Boolean;
  var
    I: Integer;
    BaseObjectList: TList;
    TargeTBaseObject: TBaseObject;
    nDamage, nDamage1, NGSecPwr: Integer; //20080929
  begin
    Result := False;
    BaseObjectList := TList.Create;
    try
      case m_n42kill of //20080328 轻击重击范围有分别
        1: GetDirectionBaseObjects(m_btDirection, 2, BaseObjectList); //轻击,2格 //20090323
        2: GetDirectionBaseObjects(m_btDirection, 4, BaseObjectList); //同个方向的怪 重击,4格 //20090323
      end;
      if BaseObjectList.Count > 0 then begin //20080629
        for I := 0 to BaseObjectList.Count - 1 do begin
          TargeTBaseObject := TBaseObject(BaseObjectList.Items[I]);
          nDamage1 := nSecPwr;
          NGSecPwr := 0;
          if TargeTBaseObject <> nil then begin
            if (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then m_ExpHitter := TargeTBaseObject; //20080528
            if IsProperTarget(TargeTBaseObject) then begin
              if TargeTBaseObject.m_btRaceServer = RC_PLAYOBJECT then
                TPlayObject(TargeTBaseObject).CmdUserCmd('@MagTagFunc42');//人物技能触发By TasNat at: 2012-07-21 16:49:36
{$IF M2Version <> 2}
              case TargeTBaseObject.m_btRaceServer of //20091220 增加
                RC_PLAYOBJECT: NGSecPwr := GetNGPow(TargeTBaseObject, TPlayObject(TargeTBaseObject).m_MagicSkill_238, nDamage1); //静之开天斩
                RC_HEROOBJECT: NGSecPwr := GetNGPow(TargeTBaseObject, THEROOBJECT(TargeTBaseObject).m_MagicSkill_238, nDamage1); //静之开天斩
              end;
              nDamage1 := _MAX(0, nDamage1 - NGSecPwr);
{$IFEND}
              nDamage := 0;
              Inc(nDamage, TargeTBaseObject.GetHitStruckDamage(Self, nDamage1)); //20080929 魔法盾,护体神盾减少伤害
              Result := DirectAttack(TargeTBaseObject, nDamage, False);
              if m_btRaceServer <> RC_HEROOBJECT then SetTargetCreat(TargeTBaseObject); //20080528 不让英雄打一个目标后又换另一个目标
            end;
          end;
        end;
      end;
    finally
      BaseObjectList.Free;
    end;
  end;
  //龙影剑法 20080209
  function Attack_43(Target: TBaseObject; nSecPwr: Integer): Boolean;
  var
    I: Integer;
    BaseObjectList: TList;
    TargeTBaseObject: TBaseObject;
  begin
    Result := False;
    BaseObjectList := TList.Create;
    try
      GetDirectionBaseObjects_42(m_btDirection, g_Config.nMagicAttackRage_42 {龙影剑法范围 20080218}, BaseObjectList); //同个方向的怪  20080405
      if BaseObjectList.Count > 0 then begin //20080629
        for I := 0 to BaseObjectList.Count - 1 do begin
          TargeTBaseObject := TBaseObject(BaseObjectList.Items[I]);
          if TargeTBaseObject <> nil then begin //20080322
            if (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then m_ExpHitter := TargeTBaseObject; //20080528
            if IsProperTarget(TargeTBaseObject) then begin
              if TargeTBaseObject.m_btRaceServer = RC_PLAYOBJECT then
                TPlayObject(TargeTBaseObject).CmdUserCmd('@MagTagFunc43');//人物技能触发By TasNat at: 2012-07-21 16:49:36
              Result := DirectAttack(TargeTBaseObject, nSecPwr, False);
              if m_btRaceServer <> RC_HEROOBJECT then SetTargetCreat(TargeTBaseObject); //20080528 不让英雄打一个目标后又换另一个目标
            end;
          end;
        end;
      end;
    finally
      BaseObjectList.Free;
    end;
  end;
{$IF M2Version <> 2}
  //纵横剑术
  function Attack_107(Target: TBaseObject; nSecPwr: Integer; nLevel: Byte): Boolean;
  var
    I, K: Integer;
    BaseObjectList: TList;
    TargeTBaseObject: TBaseObject;
  begin
    Result := False;
    BaseObjectList := TList.Create;
    try
      GetDirectionBaseObjects_42(m_btDirection, g_Config.nMagicAttackRage_107, BaseObjectList); //同个方向的怪
      if BaseObjectList.Count > 0 then begin
        case nLevel of
          1..10: K := 50;
          11..20: K := 100;
          21..30: K := 150;
          31..40: K := 200;
          41..50: K := 250;
          51..60: K := 300;
          61..70: K := 350;
          71..80: K := 400;
          81..90: K := 450
          else K := 500;
        end;
        for I := 0 to BaseObjectList.Count - 1 do begin
          TargeTBaseObject := TBaseObject(BaseObjectList.Items[I]);
          if TargeTBaseObject <> nil then begin
            if (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then m_ExpHitter := TargeTBaseObject; //20080528
            if IsProperTarget(TargeTBaseObject) then begin
              if (Random(6) = 0) and (K > 0) and (TargeTBaseObject.m_wStatusArrValue[22] = 0)
                {and (TargeTBaseObject.m_btRaceServer = RC_PLAYOBJECT) }then begin //减速
                if TargeTBaseObject.m_btRaceServer = RC_PLAYOBJECT then
                  TPlayObject(TargeTBaseObject).CmdUserCmd('@MagTagFunc107');//人物技能触发By TasNat at: 2012-07-21 16:49:36
                TargeTBaseObject.m_dwStatusArrTimeOutTick[22] := GetTickCount + 2000; //使用时间
                TargeTBaseObject.m_wStatusArrValue[22] := K;
                if sDecRunTime <> '' then TargeTBaseObject.SysMsg(sDecRunTime, c_Red, t_Hint);
                TargeTBaseObject.m_nCharStatus := TargeTBaseObject.GetCharStatus();
                TargeTBaseObject.StatusChanged('');
                TargeTBaseObject.RecalcAbilitys();
                TargeTBaseObject.CompareSuitItem(False); //套装与身上装备对比
              end;
              Result := DirectAttack(TargeTBaseObject, nSecPwr, False);
              if m_btRaceServer <> RC_HEROOBJECT then SetTargetCreat(TargeTBaseObject); //不让英雄打一个目标后又换另一个目标
            end;
          end;
        end;
      end;
    finally
      BaseObjectList.Free;
    end;
  end;
{$IFEND}
  procedure sub_4C1E5C(nSecPwr: Integer);
  var
    btDir: Byte;
    nX, nY: Integer;
    BaseObject: TBaseObject;
    procedure sub_4C1DC0();
    begin
      if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, 1, nX, nY) then begin
        BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
        if (nSecPwr > 0) and (BaseObject <> nil) then begin
          Result := DirectAttack(BaseObject, nSecPwr, False);
        end;
      end;
    end;
  begin
    Result := False;
    btDir := m_btDirection;
    m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, 1, nX, nY);
    sub_4C1DC0();
    btDir := sub_4B2F80(m_btDirection, 2);
    sub_4C1DC0();
    btDir := sub_4B2F80(m_btDirection, 6);
    sub_4C1DC0();
  end;
begin
  Result := False;
  nCheckCode := 0;
  try
    bo21 := False;
    bo22 := False;
    bo23 := False;
    bo24 := False;
    bo25 := False;
    bo26 := False;
    boHeartSkill := False;
    nWeaponDamage := 0;
    if AttackTarget <> nil then begin //目标存在
      nCheckCode := 20600+wHitMode;
      if (AttackTarget.m_btRaceServer = 79) then Exit; //目标为富贵兽,只发送血量上限 20100711
      case wHitMode of //按DB库计算攻击力
        3: if m_MagicPowerHitSkill <> nil then nPower := GetAttackPower(MPow(m_MagicPowerHitSkill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        4: if m_MagicErgumSkill <> nil then nPower := GetAttackPower(MPow(m_MagicErgumSkill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        5: if m_MagicBanwolSkill <> nil then nPower := GetAttackPower(MPow(m_MagicBanwolSkill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        7: if m_MagicFireSwordSkill <> nil then nPower := GetAttackPower(MPow(m_MagicFireSwordSkill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        8: if m_MagicCrsSkill <> nil then nPower := GetAttackPower(MPow(m_MagicCrsSkill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        9: if m_Magic42Skill <> nil then nPower := GetAttackPower(MPow(m_Magic42Skill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        12: if m_Magic43Skill <> nil then nPower := GetAttackPower(MPow(m_Magic43Skill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        13: if m_Magic74Skill <> nil then nPower := GetAttackPower(MPow(m_Magic74Skill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        15: if m_Magic89Skill <> nil then nPower := GetAttackPower(MPow(m_Magic89Skill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        16: if m_Magic90Skill <> nil then nPower := GetAttackPower(MPow(m_Magic90Skill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        17: if m_Magic96Skill <> nil then nPower := GetAttackPower(MPow(m_Magic96Skill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        0, 1, 2: nPower := GetAttackPower(LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        18: begin
{$IF M2Version <> 2}
            nPower := GetAttackPower(LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
            if m_btRaceServer = RC_PLAYOBJECT then begin //纵横剑术
              if (TPlayObject(self).m_MagicSkill_105 <> nil) and (TPlayObject(self).m_boHeartActive) and
                (TPlayObject(self).m_MagicSkill_107 <> nil) then begin
                boHeartSkill := True;
                nPower := nPower + MPow(TPlayObject(self).m_MagicSkill_107);
              end;
            end;
{$IFEND}
          end
      else Exit; //20091228 增加
        //else nPower := GetAttackPower(LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC)))); //20091214 修改
      end;
      if (m_btRaceServer = RC_PLAYOBJECT) and (not m_boAI) then begin //人物判断攻击触发 20110114
        if m_PEnvir.m_boHitMon and (m_PEnvir.sHitMonScript <> '') then begin //触发地图
          if (AttackTarget.m_btRaceServer <> RC_PLAYOBJECT) and
            (AttackTarget.m_btRaceServer <> RC_HEROOBJECT) and (AttackTarget.m_Master = nil) then begin
            if g_FunctionNPC <> nil then begin
              g_FunctionNPC.GotoLable(TPlayObject(self), m_PEnvir.sHitMonScript, False, False); //攻击触发
            end;
          end;
        end;
{$IF M2Version <> 2}
        with TPlayObject(self) do begin
          if (m_MyDivision <> nil) and m_boTrainingNG then begin //弟子领悟触发
            if (m_Abil.Level >= g_Config.nUpHeartNeedLevel[0]) then begin
              if (m_MagicSkill_105 = nil) and (m_MagicSkill_106 = nil) and
                (Random(g_Config.nDivisionSavvyRate) = 0) then begin
                if g_FunctionNPC <> nil then
                  g_FunctionNPC.GotoLable(TPlayObject(self), '@Savvy', False, False); //弟子领悟触发
              end;
            end;
          end;
        end;
{$IFEND}
      end;
      nCheckCode := 207;
      if (wHitMode = 3) and m_boPowerHit then begin //攻杀
        m_boPowerHit := False;
{$IF M2Version <> 2}
        case m_btRaceServer of
          RC_PLAYOBJECT: begin
              nCheckCode := 208;
              NGSecPwr := GetNGPow(self, TPlayObject(self).m_MagicSkill_200, nPower); //怒之攻杀
              if AttackTarget <> nil then begin
                if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
                  NGSecPwr := NGSecPwr - GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_201, nPower); //静之攻杀
                end else
                  if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
                    NGSecPwr := NGSecPwr - GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_201, nPower); //静之攻杀
                  end;
              end;
              nPower := _MAX(0, nPower + NGSecPwr);
            end;
          RC_HEROOBJECT: begin
              nCheckCode := 209;
              NGSecPwr := GetNGPow(self, THEROOBJECT(self).m_MagicSkill_200, nPower); //怒之攻杀
              if AttackTarget <> nil then begin
                if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
                  NGSecPwr := NGSecPwr - GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_201, nPower); //静之攻杀
                end else
                  if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
                    NGSecPwr := NGSecPwr - GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_201, nPower); //静之攻杀
                  end;
              end;
              nPower := _MAX(0, nPower + NGSecPwr);
            end;
          RC_PLAYMOSTER: begin
              nCheckCode := 210;
              if AttackTarget <> nil then begin
                if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
                  NGSecPwr := GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_201, nPower); //静之攻杀
                end else
                  if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
                    NGSecPwr := GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_201, nPower); //静之攻杀
                  end;
                nPower := _MAX(0, nPower - NGSecPwr);
              end;
            end;
        end;
{$IFEND}
        Inc(nPower, m_nHitPlus);
        bo21 := True;
{$IF M2Version <> 2}
        if (m_MagicPowerHitSkill <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then begin //计算强化技能的威力
          if m_MagicPowerHitSkill.btLevel > 2 then begin
            if (TPlayObject(self).m_MagicSkill_105 <> nil) or (TPlayObject(self).m_MagicSkill_106 <> nil) then begin
              if (m_MagicPowerHitSkill.btLevelEx > 0) and (m_MagicPowerHitSkill.btLevelEx < 10) then begin
                nPower := nPower + Round(nPower * (m_MagicPowerHitSkill.btLevelEx * (g_Config.nSKILLStrongRate[0] / 100)))
              end;
            end;
            TPlayObject(self).IncreaseSkillLevel(m_MagicPowerHitSkill);
          end;
        end;
{$IFEND}
      end;
      nCheckCode := 211;
      if (wHitMode = 7) and m_boFireHitSkill then begin //烈火剑法
        m_boFireHitSkill := False;
        m_dwLatestFireHitTick := GetTickCount(); //Jacky 禁止双烈火
        if (m_MagicFireSwordSkill.btLevel = 4) and (THeroObject(self).m_nLoyal >= g_Config.nGotoLV4) then //如果是4级烈火技能 20080113
          nPower := nPower + Round(nPower / 100 * (m_nHitDouble * 10))
        else nPower := nPower + Round(nPower / 100 * (m_nHitDouble * 10)); //普通烈火的杀伤力 20080112
        nPower := Round(nPower * (g_Config.nAttackRate_26 / 100)); //威力倍数 20081208
{$IF M2Version <> 2}
        case m_btRaceServer of
          RC_PLAYOBJECT: begin
              NGSecPwr := GetNGPow(self, TPlayObject(self).m_MagicSkill_204, nPower); //怒之烈火
              if AttackTarget <> nil then begin
                if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
                  NGSecPwr := NGSecPwr - GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_205, nPower); //静之烈火
                end else
                  if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
                    NGSecPwr := NGSecPwr - GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_205, nPower); //静之烈火
                  end;
              end;
              nPower := _MAX(0, nPower + NGSecPwr);
            end;
          RC_HEROOBJECT: begin
              NGSecPwr := GetNGPow(self, THEROOBJECT(self).m_MagicSkill_204, nPower); //怒之烈火
              if AttackTarget <> nil then begin
                if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
                  NGSecPwr := NGSecPwr - GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_205, nPower); //静之烈火
                end else
                  if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
                    NGSecPwr := NGSecPwr - GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_205, nPower); //静之烈火
                  end;
              end;
              nPower := _MAX(0, nPower + NGSecPwr);
            end;
          RC_PLAYMOSTER: begin
              if AttackTarget <> nil then begin
                if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
                  NGSecPwr := GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_205, nPower); //静之烈火
                end else
                  if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
                    NGSecPwr := GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_205, nPower); //静之烈火
                  end;
                nPower := _MAX(0, nPower - NGSecPwr);
              end;
            end;
        end;
        if (m_MagicFireSwordSkill <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then begin //计算强化技能的威力
          if m_MagicFireSwordSkill.btLevel > 2 then begin
            if (TPlayObject(self).m_MagicSkill_105 <> nil) or (TPlayObject(self).m_MagicSkill_106 <> nil) then begin
              if (m_MagicFireSwordSkill.btLevelEx > 0) and (m_MagicFireSwordSkill.btLevelEx < 10) then begin
                nPower := nPower + Round(nPower * (m_MagicFireSwordSkill.btLevelEx * (g_Config.nSKILLStrongRate[3] / 100)))
              end;
            end;
            TPlayObject(self).IncreaseSkillLevel(m_MagicFireSwordSkill);
          end;
        end;
{$IFEND}
      end;
      nCheckCode := 212;
      if (wHitMode = 13) and m_boDailySkill then begin //逐日剑法 20080511
        m_boDailySkill := False;
        m_dwLatestDailyTick := GetTickCount();
        nPower := Round(nPower * (g_Config.nAttackRate_74 / 100)); //威力倍数
{$IF M2Version <> 2}
        if (m_Magic74Skill <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then begin //计算强化技能的威力
          if m_Magic74Skill.btLevel > 2 then begin
            if (TPlayObject(self).m_MagicSkill_105 <> nil) or (TPlayObject(self).m_MagicSkill_106 <> nil) then begin
              if (m_Magic74Skill.btLevelEx > 0) and (m_Magic74Skill.btLevelEx < 10) then begin
                nPower := nPower + Round(nPower * (m_Magic74Skill.btLevelEx * (g_Config.nSKILLStrongRate[4] / 100)));
              end;
            end;
            TPlayObject(self).IncreaseSkillLevel(m_Magic74Skill);
          end;
        end;
{$IFEND}
        bo22 := True;
      end;

      if (wHitMode = 17) and m_boBloodSoulSkill then begin //血魄一击(战)
        m_boBloodSoulSkill := False;
        m_dwLatestBloodSoulTick := GetTickCount();
        bo26 := True;
      end;

      if (wHitMode = 9) and m_bo42kill then begin //开天斩  20080202
        m_bo42kill := False;
        m_dwLatest42Tick := GetTickCount(); //禁止双开天斩
        if m_n42kill = 2 then nPower := Round(nPower * g_Config.n43KillAttackRate / 100); //重击杀伤力
        nPower := Round(nPower * (g_Config.nAttackRate_43 / 100)); //开天斩威力倍数  20080213
        bo23 := True;
      end;
      nCheckCode := 213;
      if (wHitMode = 12) and m_bo43kill then begin //龙影剑法  20080209
        m_dwLatest43Tick := GetTickCount(); //20080619 增加
        m_bo43kill := False; //20080619 增加
        nPower := Round(nPower * (g_Config.nAttackRate_42 / 100)); //龙影剑法威力倍数  20080213
        bo24 := True;
      end;
    end else begin
      nCheckCode := 214;
      case wHitMode of //20080531 按DB库计算攻击力
        3: if m_MagicPowerHitSkill <> nil then nPower := GetAttackPower(MPow(m_MagicPowerHitSkill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        4: if m_MagicErgumSkill <> nil then nPower := GetAttackPower(MPow(m_MagicErgumSkill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        5: if m_MagicBanwolSkill <> nil then nPower := GetAttackPower(MPow(m_MagicBanwolSkill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        7: if m_MagicFireSwordSkill <> nil then nPower := GetAttackPower(MPow(m_MagicFireSwordSkill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        8: if m_MagicCrsSkill <> nil then nPower := GetAttackPower(MPow(m_MagicCrsSkill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        9: if m_Magic42Skill <> nil then nPower := GetAttackPower(MPow(m_Magic42Skill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        12: if m_Magic43Skill <> nil then nPower := GetAttackPower(MPow(m_Magic43Skill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        13: if m_Magic74Skill <> nil then nPower := GetAttackPower(MPow(m_Magic74Skill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        15: if m_Magic89Skill <> nil then nPower := GetAttackPower(MPow(m_Magic89Skill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        16: if m_Magic90Skill <> nil then nPower := GetAttackPower(MPow(m_Magic90Skill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        17: if m_Magic96Skill <> nil then nPower := GetAttackPower(MPow(m_Magic96Skill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        0, 1, 2: nPower := GetAttackPower(LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        18: begin
{$IF M2Version <> 2}
            nPower := GetAttackPower(LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
            if m_btRaceServer = RC_PLAYOBJECT then begin //纵横剑术
              if (TPlayObject(self).m_MagicSkill_105 <> nil) and (TPlayObject(self).m_boHeartActive) and
                (TPlayObject(self).m_MagicSkill_107 <> nil) then begin
                boHeartSkill := True;
                nPower := nPower + MPow(TPlayObject(self).m_MagicSkill_107);
              end;
            end;
{$IFEND}
          end
      else Exit; //20091228 增加
        //else nPower := GetAttackPower(LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC)))); //20091214 修改
      end;
      nCheckCode := 215;
      if (wHitMode = 3) and m_boPowerHit then begin
        m_boPowerHit := False;
        Inc(nPower, m_nHitPlus);
        bo21 := True;
{$IF M2Version <> 2}
        if (m_MagicPowerHitSkill <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then begin //计算强化技能的威力
          if m_MagicPowerHitSkill.btLevel > 2 then begin
            if (TPlayObject(self).m_MagicSkill_105 <> nil) or (TPlayObject(self).m_MagicSkill_106 <> nil) then begin
              if (m_MagicPowerHitSkill.btLevelEx > 0) and (m_MagicPowerHitSkill.btLevelEx < 10) then begin
                nPower := nPower + Round(nPower * (m_MagicPowerHitSkill.btLevelEx * (g_Config.nSKILLStrongRate[0] / 100)))
              end;
            end;
            TPlayObject(self).IncreaseSkillLevel(m_MagicPowerHitSkill);
          end;
        end;
{$IFEND}
      end;
      //防止砍空刀刀烈火
      if (wHitMode = 7) and m_boFireHitSkill then begin
        m_boFireHitSkill := False;
        nPower := Round(nPower * (g_Config.nAttackRate_26 / 100)); //威力倍数 20081208
{$IF M2Version <> 2}
        if (m_MagicFireSwordSkill <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then begin //计算强化技能的威力
          if m_MagicFireSwordSkill.btLevel > 2 then begin
            if (TPlayObject(self).m_MagicSkill_105 <> nil) or (TPlayObject(self).m_MagicSkill_106 <> nil) then begin
              if (m_MagicFireSwordSkill.btLevelEx > 0) and (m_MagicFireSwordSkill.btLevelEx < 10) then begin
                nPower := nPower + Round(nPower * (m_MagicFireSwordSkill.btLevelEx * (g_Config.nSKILLStrongRate[3] / 100)))
              end;
            end;
            TPlayObject(self).IncreaseSkillLevel(m_MagicFireSwordSkill);
          end;
        end;
{$IFEND}
        m_dwLatestFireHitTick := GetTickCount(); //禁止双烈火
      end;
      nCheckCode := 216;
      if (wHitMode = 13) and m_boDailySkill then begin //逐日剑法 20080511
        m_boDailySkill := False;
        m_dwLatestDailyTick := GetTickCount();
        //以下代码 20080910 修改逐日远程攻击练功师 攻击与近身攻击一样威力
        nPower := Round(nPower * (g_Config.nAttackRate_74 / 100)); //威力倍数
{$IF M2Version <> 2}
        if (m_Magic74Skill <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then begin //计算强化技能的威力
          if m_Magic74Skill.btLevel > 2 then begin
            if (TPlayObject(self).m_MagicSkill_105 <> nil) or (TPlayObject(self).m_MagicSkill_106 <> nil) then begin
              if (m_Magic74Skill.btLevelEx > 0) and (m_Magic74Skill.btLevelEx < 10) then begin
                nPower := nPower + Round(nPower * (m_Magic74Skill.btLevelEx * (g_Config.nSKILLStrongRate[4] / 100)));
              end;
            end;
            TPlayObject(self).IncreaseSkillLevel(m_Magic74Skill);
          end;
        end;
{$IFEND}
        bo22 := True;
      end;

      if (wHitMode = 17) and m_boBloodSoulSkill then begin //血魄一击(战)
        m_boBloodSoulSkill := False;
        m_dwLatestBloodSoulTick := GetTickCount();
        bo26 := True;
      end;

      if (wHitMode = 9) and m_bo42kill then begin //开天斩  20080202
        m_bo42kill := False;
        m_dwLatest42Tick := GetTickCount(); //禁止双开天斩
        if m_n42kill = 2 then nPower := Round(nPower * g_Config.n43KillAttackRate / 100); //重击杀伤力
        nPower := Round(nPower * (g_Config.nAttackRate_43 / 100)); //开天斩威力倍数
        bo23 := True;
      end;

      if (wHitMode = 12) and m_bo43kill then begin //龙影剑法  20080619
        m_bo43kill := False; //20080619 增加
        m_dwLatest43Tick := GetTickCount(); //20080619 增加
        bo24 := True;
      end;
    end;
{$IF M2Version <> 2}
    if (wHitMode = 18) and boHeartSkill and (nPower > 0) then begin
      if m_btRaceServer = RC_PLAYOBJECT then begin //纵横剑术
        if (TPlayObject(self).m_MagicSkill_105 <> nil) and (TPlayObject(self).m_boHeartActive) and
          (TPlayObject(self).m_MagicSkill_107 <> nil) then begin
          Attack_107(AttackTarget, nPower, TPlayObject(self).m_MagicSkill_105.btLevel);
          if TPlayObject(self).m_MagicSkill_107.btLevel < 9 then begin
            if g_Config.nSKILL_107NeedHeart[TPlayObject(self).m_MagicSkill_107.btLevel] <= TPlayObject(self).m_MagicSkill_105.btLevel then begin
              TrainSkill(TPlayObject(self).m_MagicSkill_107, Random(3) + 1);
              if not CheckMagicLevelup(TPlayObject(self).m_MagicSkill_107) then begin
                MaxTrain := TPlayObject(self).m_MagicSkill_107.MagicInfo.MaxTrain[0] + TPlayObject(self).m_MagicSkill_107.btLevel * (TPlayObject(self).m_MagicSkill_107.MagicInfo.MaxTrain[2] - TPlayObject(self).m_MagicSkill_107.MagicInfo.MaxTrain[1]);
                SendDelayMsg(Self, RM_MAGIC_LVEXP, TPlayObject(self).m_MagicSkill_107.MagicInfo.wMagicId, MaxTrain, TPlayObject(self).m_MagicSkill_107.btLevel, TPlayObject(self).m_MagicSkill_107.nTranPoint, '', 1000);
              end;
            end;
          end;
        end;
      end;
    end;
{$IFEND}
    nCheckCode := 1;
    if (wHitMode = 4) then begin //刺杀
      nSecPwr := 0;
      if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin //增加分身魔法攻击
        if m_MagicErgumSkill <> nil then begin
          nSecPwr := Round(nPower / (m_MagicErgumSkill.MagicInfo.btTrainLv + 2) * (m_MagicErgumSkill.btLevel + 2));
          //nSecPwr := nPower;//20110507 修改
        end;
      end;
      if (nSecPwr > 0) and (m_MagicErgumSkill <> nil) then begin
        nCheckCode := 101;
        if not SwordLongAttack(nSecPwr, m_MagicErgumSkill.btLevel, AttackTarget) and g_Config.boLimitSwordLong then wHitMode := 0;
        nCheckCode := 102;
        if boisBaseObject and (AttackTarget <> nil) then begin //20090319 增加 AttackTarget <> nil
          if (AttackTarget.m_btRaceServer <> 55) then nPower := 0; //20081010 与隔位目标一样,则不再重复让目标掉血
        end;
      end;
    end;

    if (wHitMode = 15) then begin //四级刺杀
      nSecPwr := 0;
      if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin //增加分身魔法攻击
        if m_Magic89Skill <> nil then begin
          nSecPwr := nPower;
{$IF M2Version <> 2}
          if (m_Magic89Skill <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then begin //计算强化技能的威力
            if (TPlayObject(self).m_MagicSkill_105 <> nil) or (TPlayObject(self).m_MagicSkill_106 <> nil) then begin
              if (m_Magic89Skill.btLevelEx > 0) and (m_Magic89Skill.btLevelEx < 10) then begin
                nSecPwr := nSecPwr + Round(nSecPwr * (m_Magic89Skill.btLevelEx * (g_Config.nSKILLStrongRate[2] / 100)))
              end;
            end;
            TPlayObject(self).IncreaseSkillLevel(m_Magic89Skill);
          end;
{$IFEND}
        end;
      end;
      if (nSecPwr > 0) and (m_Magic89Skill <> nil) then begin
        nCheckCode := 101;
        if not SwordLongAttack(nSecPwr, m_Magic89Skill.btLevel, AttackTarget) and g_Config.boLimitSwordLong then wHitMode := 0;
        nCheckCode := 102;
        if boisBaseObject and (AttackTarget <> nil) then begin //20090319 增加 AttackTarget <> nil
          if (AttackTarget.m_btRaceServer <> 55) then nPower := 0; //20081010 与隔位目标一样,则不再重复让目标掉血
        end;
      end;
    end;
    nCheckCode := 2;
    if (wHitMode = 5) then begin //半月
      nSecPwr := 0;
      NGSecPwr1 := 0;
      if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin //增加分身魔法攻击
        if m_MagicBanwolSkill <> nil then begin
          //nSecPwr := Round(nPower / (m_MagicBanwolSkill.MagicInfo.btTrainLv + 10) * (m_MagicBanwolSkill.btLevel + 2));
{$IF M2Version <> 2}
          case m_btRaceServer of
            RC_PLAYOBJECT: begin
                NGSecPwr := GetNGPow(self, TPlayObject(self).m_MagicSkill_202, nPower); //怒之半月
                if AttackTarget <> nil then begin
                  if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
                    NGSecPwr1 := GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_203, nPower); //静之半月
                  end else
                    if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
                      NGSecPwr1 := GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_203, nPower); //静之半月
                    end;
                end;
                Inc(nPower, NGSecPwr);
              end;
            RC_HEROOBJECT: begin
                NGSecPwr := GetNGPow(self, THEROOBJECT(self).m_MagicSkill_202, nPower); //怒之半月
                if (AttackTarget <> nil) then begin
                  if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
                    NGSecPwr1 := GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_203, nPower); //静之半月
                  end else
                    if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
                      NGSecPwr1 := GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_203, nPower); //静之半月
                    end;
                end;
                Inc(nPower, NGSecPwr);
              end;
            RC_PLAYMOSTER: begin
                if (AttackTarget <> nil) then begin
                  if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
                    NGSecPwr1 := GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_203, nPower); //静之半月
                  end else
                    if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
                      NGSecPwr1 := GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_203, nPower); //静之半月
                    end;
                end;
              end;
          end;
          nPower := _MAX(0, nPower - NGSecPwr1); //对面目标掉血值
{$IFEND}
          //nSecPwr := nPower;//周围目标掉血值
          nSecPwr := Round(nPower * (m_MagicBanwolSkill.btLevel * 0.077 + 0.1538)); //周围目标掉血值 20081208
        end;
      end;
      if nSecPwr > 0 then SwordWideAttack(nSecPwr, wHitMode);
    end;
    if (wHitMode = 16) then begin //圆月弯刀
      nSecPwr := 0;
      NGSecPwr1 := 0;
      if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin //增加分身魔法攻击
        if m_Magic90Skill <> nil then begin
{$IF M2Version <> 2}
          case m_btRaceServer of
            RC_PLAYOBJECT: begin
                NGSecPwr := GetNGPow(self, TPlayObject(self).m_MagicSkill_202, nPower); //怒之半月
                if AttackTarget <> nil then begin
                  if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
                    NGSecPwr1 := GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_203, nPower); //静之半月
                  end else
                    if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
                      NGSecPwr1 := GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_203, nPower); //静之半月
                    end;
                end;
                Inc(nPower, NGSecPwr);
              end;
            RC_HEROOBJECT: begin
                NGSecPwr := GetNGPow(self, THEROOBJECT(self).m_MagicSkill_202, nPower); //怒之半月
                if (AttackTarget <> nil) then begin
                  if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
                    NGSecPwr1 := GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_203, nPower); //静之半月
                  end else
                    if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
                      NGSecPwr1 := GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_203, nPower); //静之半月
                    end;
                end;
                Inc(nPower, NGSecPwr);
              end;
            RC_PLAYMOSTER: begin
                if (AttackTarget <> nil) then begin
                  if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
                    NGSecPwr1 := GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_203, nPower); //静之半月
                  end else
                    if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
                      NGSecPwr1 := GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_203, nPower); //静之半月
                    end;
                end;
              end;
          end;
          nPower := _MAX(0, nPower - NGSecPwr1); //对面目标掉血值
{$IFEND}
          nSecPwr := Round(nPower * (m_Magic90Skill.btLevel * 0.077 + 0.1538)); //周围目标掉血值 20081208
{$IF M2Version <> 2}
          if (m_Magic90Skill <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then begin //计算强化技能的威力
            if (TPlayObject(self).m_MagicSkill_105 <> nil) or (TPlayObject(self).m_MagicSkill_106 <> nil) then begin
              if (m_Magic90Skill.btLevelEx > 0) and (m_Magic90Skill.btLevelEx < 10) then begin
                nSecPwr := nSecPwr + Round(nSecPwr * (m_Magic90Skill.btLevelEx * (g_Config.nSKILLStrongRate[1] / 100)))
              end;
            end;
            TPlayObject(self).IncreaseSkillLevel(m_Magic90Skill);
          end;
{$IFEND}
        end;
      end;
      if nSecPwr > 0 then SwordWideAttack(nSecPwr, wHitMode);
    end;
    nCheckCode := 3;
    if (wHitMode = 6) then begin //未知技能
      nSecPwr := 0;
      if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin {增加分身魔法攻击}
      end else nSecPwr := nSecPwr;
      if nSecPwr > 0 then sub_4C1E5C(nSecPwr);
    end;
    nCheckCode := 32; //20080222
    if (wHitMode = 8) then begin //抱月刀法
      nSecPwr := 0;
      if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin {增加分身魔法攻击}
        if m_MagicCrsSkill <> nil then begin
          nSecPwr := nPower;
        end;
      end else nSecPwr := nSecPwr;
      if nSecPwr > 0 then CrsWideAttack(nSecPwr);
    end;

    if (wHitMode = 9) and bo23 then begin //开天斩 20080209
      nSecPwr := 0;
      nCheckCode := 33;
      if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin {增加分身魔法攻击}
        if m_Magic42Skill <> nil then begin
          //nSecPwr := Round(nPower / (m_Magic42Skill.MagicInfo.btTrainLv + 10) * (m_Magic42Skill.btLevel + 2));
          nSecPwr := nPower;
        end;
      end else nSecPwr := nSecPwr;
      if nSecPwr > 0 then begin
        nCheckCode := 101;
        Attack_42(nSecPwr, m_n42kill);
      end;
    end;

    if (wHitMode = 13) and bo22 then begin //逐日剑法 20080511
      nSecPwr := 0;
      nCheckCode := 34;
      if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin
        if m_Magic74Skill <> nil then Attack_74(AttackTarget, nPower);
      end;
    end;

    if (wHitMode = 12) and bo24 then begin //龙影剑法 20080209
      nSecPwr := 0;
      nCheckCode := 35; //20080222
      if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin {增加分身魔法攻击}
        if m_Magic43Skill <> nil then begin
          nSecPwr := nPower;
        end;
      end else nSecPwr := nSecPwr;
      if nSecPwr > 0 then Attack_43(AttackTarget, nSecPwr);
    end;

    if (wHitMode = 17) and bo26 then begin //血魄一击(战)
      nSecPwr := 0;
      nCheckCode := 34;
      if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin
        if m_Magic96Skill <> nil then begin
          nSecPwr := nPower;
          if nSecPwr > 0 then Attack_96(AttackTarget, nSecPwr);
        end;
      end;
    end;
    if AttackTarget = nil then Exit;
    nCheckCode := 4;
    if IsProperTarget(AttackTarget) then begin
      if (Random(AttackTarget.m_btSpeedPoint) >= m_btHitPoint) then nPower := 0;
    end else nPower := 0;
    nCheckCode := 5;
    if nPower > 0 then begin
{$IF M2Version <> 2}
      case m_btRaceServer of
        RC_PLAYOBJECT: begin
            nCheckCode := 51;
            NGSecPwr := GetNGPow(self, TPlayObject(self).m_MagicSkill_236, nPower); //怒之内功剑法
            if AttackTarget <> nil then begin
              nCheckCode := 52;
              if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
                nCheckCode := 53;
                NGSecPwr := NGSecPwr - GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_237, nPower); //静之内功剑法
              end else
                if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
                  nCheckCode := 54;
                  NGSecPwr := NGSecPwr - GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_237, nPower); //静之内功剑法
                end;
            end;
            nPower := _MAX(0, nPower + NGSecPwr);
          end;
        RC_HEROOBJECT: begin
            nCheckCode := 55;
            NGSecPwr := GetNGPow(self, THEROOBJECT(self).m_MagicSkill_236, nPower); //怒之内功剑法
            if AttackTarget <> nil then begin
              nCheckCode := 56;
              if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
                nCheckCode := 57;
                NGSecPwr := NGSecPwr - GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_237, nPower); //静之内功剑法
              end else
                if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
                  nCheckCode := 58;
                  NGSecPwr := NGSecPwr - GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_237, nPower); //静之内功剑法
                end;
            end;
            nPower := _MAX(0, nPower + NGSecPwr);
          end;
        RC_PLAYMOSTER: begin
            nCheckCode := 59;
            if AttackTarget <> nil then begin
              if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then begin
                nCheckCode := 203;
                NGSecPwr := GetNGPow(AttackTarget, TPlayObject(AttackTarget).m_MagicSkill_237, nPower); //静之内功剑法
              end else
                if AttackTarget.m_btRaceServer = RC_HEROOBJECT then begin
                  nCheckCode := 204;
                  NGSecPwr := GetNGPow(AttackTarget, THEROOBJECT(AttackTarget).m_MagicSkill_237, nPower); //静之内功剑法
                end;
              nPower := _MAX(0, nPower - NGSecPwr);
            end;
          end;
      end;
{$IFEND}
      nCheckCode := 205;
      nPower := AttackTarget.GetHitStruckDamage(Self, nPower);
      nWeaponDamage := (Random(5) + 2) - m_AddAbil.btWeaponStrong;
    end;
    nCheckCode := 60;
    if nPower > 0 then begin
      nCheckCode := 61;
      if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER) then begin //20080606
        if (wHitMode <> 9) and (wHitMode <> 13) and (wHitMode <> 12) and (wHitMode <> 17) then begin //20081221 过滤龙影剑法  20100701过滤血魄一击两次攻击
          if (AttackTarget <> nil) then begin //20090107
            AttackTarget.StruckDamage(nPower); //减装备持久
            AttackTarget.SendDelayMsg(TBaseObject(RM_STRUCK), RM_10101, nPower, AttackTarget.m_WAbil.HP, AttackTarget.m_WAbil.MaxHP, Integer(Self), '', 200);
          end;
        end;
      end else begin
        nCheckCode := 200;
        if (AttackTarget <> nil) and (wHitMode <> 17) then begin //20090107 20100701过滤血魄一击两次攻击
          nCheckCode := 201;
          AttackTarget.StruckDamage(nPower);
          nCheckCode := 202;
          AttackTarget.SendDelayMsg(TBaseObject(RM_STRUCK), RM_10101, nPower, AttackTarget.m_WAbil.HP, AttackTarget.m_WAbil.MaxHP, Integer(Self), '', 200);
        end;
      end;

      if (AttackTarget <> nil) then begin
        if (not AttackTarget.m_boUnParalysis) and (AttackTarget.m_btUnParalysis = 0)//增加在一定时间内无视麻痹By TasNat at: 2012-04-23 18:46:57
        {$IF M2Version <> 2} and (not AttackTarget.m_boCanUerSkill102){$IFEND} then begin //对方没有防麻
          nRandom := AttackTarget.m_btAntiPoison + g_Config.nAttackPosionRate{5};
          nRandom := nRandom - Round(nRandom * (((m_nParalysisAddRate - AttackTarget.m_nUnParalysisRate)) / 100));
          //减去麻痹强化 TasNat 2012-03-05 16:37:37
          if m_boParalysis and (Random(nRandom) <= 0) then begin //20100513 防麻机率
            nCheckCode := 64;
            if ((m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER)) and (m_btJob = 0) then begin //英雄,人形刺杀位不麻目标
              if (abs(AttackTarget.m_nCurrX - m_nCurrX) = 1) or (abs(AttackTarget.m_nCurrY - m_nCurrY) = 1) then begin //20080803 修改
                AttackTarget.MakePosion(POISON_STONE, g_Config.nAttackPosionTime {5}, 0); //麻痹
              end;
            end else AttackTarget.MakePosion(POISON_STONE, g_Config.nAttackPosionTime {5}, 0); //麻痹
          end else begin
            nRandom := AttackTarget.m_btAntiPoison + g_Config.nAttackPosionRate1{2};
            nRandom := nRandom - Round(nRandom * (((m_nParalysisAddRate - AttackTarget.m_nUnParalysisRate)) / 100));
            if m_boParalysis1 and (Random(nRandom) <= 0) then begin //战意麻痹戒指，麻痹时间2秒  20100513 防麻机率
              if ((m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_PLAYMOSTER)) and (m_btJob = 0) then begin ////20091018 英雄,人形刺杀位不麻目标
                if (abs(AttackTarget.m_nCurrX - m_nCurrX) = 1) or (abs(AttackTarget.m_nCurrY - m_nCurrY) = 1) then begin //20080803 修改
                  AttackTarget.MakePosion(POISON_STONE, g_Config.nAttackPosionTime1 {2}, 0); //麻痹
                end;
              end else AttackTarget.MakePosion(POISON_STONE, g_Config.nAttackPosionTime1 {2}, 0); //麻痹
            end;
          end;
        end;
      end;
      nCheckCode := 65;
      //虹魔，吸血
      if m_nHongMoSuite > 0 then begin
        m_db3B0 := nPower / 1.E2 * m_nHongMoSuite;
        if m_db3B0 >= 2.0 then begin
          n20 := Trunc(m_db3B0);
          m_db3B0 := n20;
          DamageHealth(-n20);
        end;
      end;
{$IF M2Version = 1}
      if (nPower > 0) then begin //虎威装备吸血
        if (m_nVampirePoint > 0) and ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) then begin
          if Random(100) <= m_nVampireRate then begin
            n20 := 0;
            n20 := Random(m_nVampirePoint);
            if n20 > 0 then DamageHealth(-n20);
          end;
        end;
      end;
{$IFEND}
      nCheckCode := 66;
      if (m_MagicOneSwordSkill <> nil) and ((wHitMode = 0) or (wHitMode = 1) or (wHitMode = 2)) and
        ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and
        (m_MagicOneSwordSkill.btLevel < 3) and
        (m_MagicOneSwordSkill.MagicInfo.TrainLevel[m_MagicOneSwordSkill.btLevel] <= m_Abil.Level) then begin
        nCheckCode := 67;
        if m_btRaceServer = RC_PLAYOBJECT then begin
          TPlayObject(Self).TrainSkill(m_MagicOneSwordSkill, Random(3) + 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicOneSwordSkill) then begin
            nCheckCode := 68;
            SendDelayMsg(Self, RM_MAGIC_LVEXP, m_MagicOneSwordSkill.MagicInfo.wMagicId, 0, m_MagicOneSwordSkill.btLevel, m_MagicOneSwordSkill.nTranPoint, '', 3000);
            RecalcAbilitys; //20080823 增加
            CompareSuitItem(False); //20080823 套装
            SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, ''); //20080823 增加
          end;
        end else begin
          THeroObject(Self).TrainSkill(m_MagicOneSwordSkill, Random(3) + 1);
          if (not THeroObject(Self).CheckMagicLevelup(m_MagicOneSwordSkill)) and (not m_boGhost) then begin //20090413 增加 (not m_boGhost)
            nCheckCode := 69;
            THeroObject(Self).SendDelayMsg(Self, RM_HEROMAGIC_LVEXP, m_MagicOneSwordSkill.MagicInfo.wMagicId, 0, m_MagicOneSwordSkill.btLevel, m_MagicOneSwordSkill.nTranPoint, '', 3000);
            THeroObject(Self).RecalcAbilitys; //20080823 增加
            CompareSuitItem(False); //20080823 套装
            THeroObject(Self).SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, ''); //20080823 增加
          end;
        end;
        nCheckCode := 70;
      end;

      if bo21 and (m_MagicPowerHitSkill <> nil) and //攻杀
        ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and
        (m_MagicPowerHitSkill.btLevel < 3) and
        (m_MagicPowerHitSkill.MagicInfo.TrainLevel[m_MagicPowerHitSkill.btLevel] <= m_Abil.Level) then begin
        nCheckCode := 71;
        if m_btRaceServer = RC_PLAYOBJECT then begin
          TPlayObject(Self).TrainSkill(m_MagicPowerHitSkill, Random(3) + 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicPowerHitSkill) then begin
            nCheckCode := 72;
            SendDelayMsg(Self, RM_MAGIC_LVEXP, m_MagicPowerHitSkill.MagicInfo.wMagicId, 0, m_MagicPowerHitSkill.btLevel, m_MagicPowerHitSkill.nTranPoint, '', 3000);
          end;
        end else begin
          THeroObject(Self).TrainSkill(m_MagicPowerHitSkill, Random(3) + 1);
          if not THeroObject(Self).CheckMagicLevelup(m_MagicPowerHitSkill) then begin
            nCheckCode := 73;
            THeroObject(Self).SendDelayMsg(Self, RM_HEROMAGIC_LVEXP, m_MagicPowerHitSkill.MagicInfo.wMagicId, 0, m_MagicPowerHitSkill.btLevel, m_MagicPowerHitSkill.nTranPoint, '', 3000);
          end;
        end;
        nCheckCode := 74;
      end;
      nCheckCode := 75;
      if (wHitMode = 4) and (m_MagicErgumSkill <> nil) and //刺杀技能升级
        ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and
        (m_MagicErgumSkill.btLevel < 3) and
        (m_MagicErgumSkill.MagicInfo.TrainLevel[m_MagicErgumSkill.btLevel] <= m_Abil.Level) then begin
        nCheckCode := 76;
        if m_btRaceServer = RC_PLAYOBJECT then begin
          TPlayObject(Self).TrainSkill(m_MagicErgumSkill, Random(3) + 1); //升1-3点 20080924
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicErgumSkill) then begin
            SendDelayMsg(Self, RM_MAGIC_LVEXP, m_MagicErgumSkill.MagicInfo.wMagicId, 0, m_MagicErgumSkill.btLevel, m_MagicErgumSkill.nTranPoint, '', 3000);
          end;
        end else begin
          THeroObject(Self).TrainSkill(m_MagicErgumSkill, Random(3) + 1); //升1-3点 20080924
          if not THeroObject(Self).CheckMagicLevelup(m_MagicErgumSkill) then begin
            THeroObject(Self).SendDelayMsg(Self, RM_HEROMAGIC_LVEXP, m_MagicErgumSkill.MagicInfo.wMagicId, 0, m_MagicErgumSkill.btLevel, m_MagicErgumSkill.nTranPoint, '', 3000);
          end;
        end;
      end;
      nCheckCode := 77;
      if (wHitMode = 5) and (m_MagicBanwolSkill <> nil) and //半月弯刀
        ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and
        (m_MagicBanwolSkill.btLevel < 3) and
        (m_MagicBanwolSkill.MagicInfo.TrainLevel[m_MagicBanwolSkill.btLevel] <= m_Abil.Level) then begin
        if m_btRaceServer = RC_PLAYOBJECT then begin
          TPlayObject(Self).TrainSkill(m_MagicBanwolSkill, 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicBanwolSkill) then begin
            SendDelayMsg(Self, RM_MAGIC_LVEXP, m_MagicBanwolSkill.MagicInfo.wMagicId, 0, m_MagicBanwolSkill.btLevel, m_MagicBanwolSkill.nTranPoint, '', 3000);
          end;
        end else begin
          THeroObject(Self).TrainSkill(m_MagicBanwolSkill, 1);
          if not THeroObject(Self).CheckMagicLevelup(m_MagicBanwolSkill) then begin
            THeroObject(Self).SendDelayMsg(Self, RM_HEROMAGIC_LVEXP, m_MagicBanwolSkill.MagicInfo.wMagicId, 0, m_MagicBanwolSkill.btLevel, m_MagicBanwolSkill.nTranPoint, '', 3000);
          end;
        end;
      end;
      nCheckCode := 8;
      if (wHitMode = 7) and (m_MagicFireSwordSkill <> nil) and //烈火剑法技能升级 20080112
        ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and
        (m_MagicFireSwordSkill.btLevel < 3) and
        (m_MagicFireSwordSkill.MagicInfo.TrainLevel[m_MagicFireSwordSkill.btLevel] <= m_Abil.Level) then begin

        if m_btRaceServer = RC_PLAYOBJECT then begin
          TPlayObject(Self).TrainSkill(m_MagicFireSwordSkill, 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicFireSwordSkill) then begin
            SendDelayMsg(Self, RM_MAGIC_LVEXP, m_MagicFireSwordSkill.MagicInfo.wMagicId, 0, m_MagicFireSwordSkill.btLevel, m_MagicFireSwordSkill.nTranPoint, '', 3000);
          end;
        end else begin
          THeroObject(Self).TrainSkill(m_MagicFireSwordSkill, 1);
          if not THeroObject(Self).CheckMagicLevelup(m_MagicFireSwordSkill) then begin
            THeroObject(Self).SendDelayMsg(Self, RM_HEROMAGIC_LVEXP, m_MagicFireSwordSkill.MagicInfo.wMagicId, 0, m_MagicFireSwordSkill.btLevel, m_MagicFireSwordSkill.nTranPoint, '', 3000);
          end;
        end;
      end;

      if (wHitMode = 13) and (m_Magic74Skill <> nil) and //逐日剑法技能升级 20080511
        ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and
        (m_Magic74Skill.btLevel < 3) and
        (m_Magic74Skill.MagicInfo.TrainLevel[m_Magic74Skill.btLevel] <= m_Abil.Level) then begin

        if m_btRaceServer = RC_PLAYOBJECT then begin
          TPlayObject(Self).TrainSkill(m_Magic74Skill, 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_Magic74Skill) then
            SendDelayMsg(Self, RM_MAGIC_LVEXP, m_Magic74Skill.MagicInfo.wMagicId, 0, m_Magic74Skill.btLevel, m_Magic74Skill.nTranPoint, '', 3000);
        end else begin
          THeroObject(Self).TrainSkill(m_Magic74Skill, 1);
          if not THeroObject(Self).CheckMagicLevelup(m_Magic74Skill) then
            THeroObject(Self).SendDelayMsg(Self, RM_HEROMAGIC_LVEXP, m_Magic74Skill.MagicInfo.wMagicId, 0, m_Magic74Skill.btLevel, m_Magic74Skill.nTranPoint, '', 3000);
        end;
      end;

      if (wHitMode = 17) and (m_Magic96Skill <> nil) and //血魄一击(战)升级
        ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and
        (m_Magic96Skill.btLevel < 3) and
        (m_Magic96Skill.MagicInfo.TrainLevel[m_Magic96Skill.btLevel] <= m_Abil.Level) then begin

        if m_btRaceServer = RC_PLAYOBJECT then begin
          TPlayObject(Self).TrainSkill(m_Magic96Skill, 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_Magic96Skill) then
            SendDelayMsg(Self, RM_MAGIC_LVEXP, m_Magic96Skill.MagicInfo.wMagicId, 0, m_Magic96Skill.btLevel, m_Magic96Skill.nTranPoint, '', 3000);
        end else begin
          THeroObject(Self).TrainSkill(m_Magic96Skill, 1);
          if not THeroObject(Self).CheckMagicLevelup(m_Magic96Skill) then
            THeroObject(Self).SendDelayMsg(Self, RM_HEROMAGIC_LVEXP, m_Magic96Skill.MagicInfo.wMagicId, 0, m_Magic96Skill.btLevel, m_Magic96Skill.nTranPoint, '', 3000);
        end;
      end;

      if (wHitMode = 9) and (m_Magic42Skill <> nil) and //开天斩技能升级 20080202
        ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and
        (m_Magic42Skill.btLevel < 3) and
        (m_Magic42Skill.MagicInfo.TrainLevel[m_Magic42Skill.btLevel] <= m_Abil.Level) then begin
        if m_btRaceServer = RC_PLAYOBJECT then begin
          TPlayObject(Self).TrainSkill(m_Magic42Skill, 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_Magic42Skill) then begin
            SendDelayMsg(Self, RM_MAGIC_LVEXP, m_Magic42Skill.MagicInfo.wMagicId, 0, m_Magic42Skill.btLevel, m_Magic42Skill.nTranPoint, '', 3000);
          end;
        end else begin
          THeroObject(Self).TrainSkill(m_Magic42Skill, 1);
          if not THeroObject(Self).CheckMagicLevelup(m_Magic42Skill) then begin
            THeroObject(Self).SendDelayMsg(Self, RM_HEROMAGIC_LVEXP, m_Magic42Skill.MagicInfo.wMagicId, 0, m_Magic42Skill.btLevel, m_Magic42Skill.nTranPoint, '', 3000);
          end;
        end;
      end;

      if (wHitMode = 12) and (m_Magic43Skill <> nil) and //龙影剑法技能升级 20080203
        ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and
        (m_Magic43Skill.btLevel < 3) and
        (m_Magic43Skill.MagicInfo.TrainLevel[m_Magic43Skill.btLevel] <= m_Abil.Level) then begin

        if m_btRaceServer = RC_PLAYOBJECT then begin
          TPlayObject(Self).TrainSkill(m_Magic43Skill, 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_Magic43Skill) then begin
            SendDelayMsg(Self, RM_MAGIC_LVEXP, m_Magic43Skill.MagicInfo.wMagicId, 0, m_Magic43Skill.btLevel, m_Magic43Skill.nTranPoint, '', 3000);
          end;
        end else begin
          THeroObject(Self).TrainSkill(m_Magic43Skill, 1);
          if not THeroObject(Self).CheckMagicLevelup(m_Magic43Skill) then begin
            THeroObject(Self).SendDelayMsg(Self, RM_HEROMAGIC_LVEXP, m_Magic43Skill.MagicInfo.wMagicId, 0, m_Magic43Skill.btLevel, m_Magic43Skill.nTranPoint, '', 3000);
          end;
        end;
      end;

      if (wHitMode = 8) and (m_MagicCrsSkill <> nil) and {抱月弯刀}
        ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) and
        (m_MagicCrsSkill.btLevel < 3) and
        (m_MagicCrsSkill.MagicInfo.TrainLevel[m_MagicCrsSkill.btLevel] <= m_Abil.Level) then begin

        if m_btRaceServer = RC_PLAYOBJECT then begin
          TPlayObject(Self).TrainSkill(m_MagicCrsSkill, 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicCrsSkill) then begin
            SendDelayMsg(Self, RM_MAGIC_LVEXP, m_MagicCrsSkill.MagicInfo.wMagicId, 0, m_MagicCrsSkill.btLevel, m_MagicCrsSkill.nTranPoint, '', 3000);
          end;
        end else begin
          THeroObject(Self).TrainSkill(m_MagicCrsSkill, 1);
          if not THeroObject(Self).CheckMagicLevelup(m_MagicCrsSkill) then begin
            THeroObject(Self).SendDelayMsg(Self, RM_HEROMAGIC_LVEXP, m_MagicCrsSkill.MagicInfo.wMagicId, 0, m_MagicCrsSkill.btLevel, m_MagicCrsSkill.nTranPoint, '', 3000);
          end;
        end;
      end;
      Result := True;
    end;

    nCheckCode := 9;
    if (nWeaponDamage > 0) and (m_UseItems[U_WEAPON].wIndex > 0) then DoDamageWeapon(nWeaponDamage);

    if (AttackTarget <> nil) and (AttackTarget.m_btRaceServer <> RC_PLAYOBJECT) then begin
      case wHitMode of //20080904 修改 开天,逐日剑法,不重发消息 20081221 过滤龙影剑法
        9, 13, 12, 17: ;
      else begin
          AttackTarget.SendMsg(AttackTarget, RM_STRUCK, nPower, AttackTarget.m_WAbil.HP, AttackTarget.m_WAbil.MaxHP, Integer(Self), '');
        end;
      end;
      //AttackTarget.SendMsg(AttackTarget, RM_STRUCK, nPower, AttackTarget.m_WAbil.HP, AttackTarget.m_WAbil.MaxHP, Integer(Self), '');
    end;
  except
    on E: Exception do begin
      MainOutMessage(Format(sExceptionMsg, [g_sExceptionVer, m_sCharName, nCheckCode, ExceptAddr]));
    end;
  end;
end;

procedure TBaseObject.SendAttackMsg(wIdent: Word; btDir, btLevelEx: Byte; nX, nY: Integer);
begin
  SendRefMsg(wIdent, btDir, nX, nY, btLevelEx, '');
end;

//取打击减少的损害

function TBaseObject.GetHitStruckDamage(Target: TBaseObject; nDamage: Integer): Integer;
{$IF M2Version <> 2}
  function GetHeartPower(UserMagic: pTUserMagic): Integer; //计算龙卫心法的神圣属性
  var
    nPower: Integer;
  begin
    if UserMagic.MagicInfo.wMaxPower > UserMagic.MagicInfo.wPower then //心法的基本威力
      nPower := UserMagic.MagicInfo.wPower + Random(UserMagic.MagicInfo.wMaxPower - UserMagic.MagicInfo.wPower)
    else nPower := UserMagic.MagicInfo.wPower;
    if UserMagic.MagicInfo.btDefMaxPower > UserMagic.MagicInfo.btDefPower then //计算心法的升级威力
      Result := Round(nPower / (UserMagic.MagicInfo.btTrainLv + 1) * (UserMagic.btLevel + 1)) + (UserMagic.MagicInfo.btDefPower + Random(UserMagic.MagicInfo.btDefMaxPower - UserMagic.MagicInfo.btDefPower))
    else Result := Round(nPower / (UserMagic.MagicInfo.btTrainLv + 1) * (UserMagic.btLevel + 1)) + UserMagic.MagicInfo.btDefPower;
    if Result < 0 then Result := 0;
  end;
{$IFEND}
var
  n14, n15, n16, n17, n18, n19, nArmsCrit: Integer;
  boSKill101Use: Boolean;
begin
  Result := 0;
  n15 := 0;
  n16 := 0;
  n17 := 0;
  n18 := 0;
  boSKill101Use := False;
  try
{$IF M2Version <> 2}
    nArmsCrit := 0;
    if Target <> nil then begin //内功护体,增加普通攻击力 20081003
      try
        if not Target.m_boDeath then begin //20090105
          case Target.m_btRaceServer of
            RC_PLAYOBJECT: begin
                n16 := Target.m_nDecTargetNHPoint;
                n17 := TPlayObject(Target).m_boArmsCritPoint; //武器暴击等级 20100709
                if m_PEnvir.m_boCRIT then Inc(n17, m_PEnvir.m_nCRIT); //地图暴击等级 20110114
                if TPlayObject(Target).m_boTrainingNG and (TPlayObject(Target).m_Skill69NH > 0) then begin
                  case Target.m_btJob of //20090812 按职业来计算内功攻击力
                    0: n15 := (TPlayObject(Target).m_NGLevel div g_Config.nWarrNGLevelIncDC) + 5;
                    1: n15 := (TPlayObject(Target).m_NGLevel div g_Config.nWizardNGLevelIncDC) + 3;
                    2: n15 := (TPlayObject(Target).m_NGLevel div g_Config.nTaosNGLevelIncDC) + 3;
                  end;
                end;
                boSKill101Use := TPlayObject(Target).m_boCanUerSkill101;
                if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) then begin
                  if TPlayObject(Target).m_boFengHaoPower then begin //封号增加攻击倍率
                    nArmsCrit := Round(nDamage * ((TPlayObject(Target).m_nFengHaoMinPowerRate + Random(TPlayObject(Target).m_nFengHaoMaxPowerRate - TPlayObject(Target).m_nFengHaoMinPowerRate)) / 100));
                  end;
                  if Target.m_PEnvir.m_boPeak then begin //巅峰状态地图
                    nArmsCrit := nArmsCrit + Round(nDamage * ((Target.m_PEnvir.m_nPeakMinRate + Random(Target.m_PEnvir.m_nPeakMaxRate - Target.m_PEnvir.m_nPeakMinRate)) / 100));
                  end;
                  Inc(nDamage, nArmsCrit);
                end;
                if (m_btRaceServer = RC_PLAYOBJECT) then begin //人物，进行心法压制处理
                  if (TPlayObject(Target).m_MagicSkill_105 <> nil) then begin
                    if (TPlayObject(self).m_MagicSkill_105 <> nil) then begin
                      if TPlayObject(Target).m_MagicSkill_105.btLevel > TPlayObject(self).m_MagicSkill_105.btLevel then begin
                        nDamage := Round(nDamage * (1 + g_Config.nHeartIncDamageRate / 100));
                      end;
                    end else
                      if (TPlayObject(self).m_MagicSkill_106 <> nil) then begin
                        if TPlayObject(Target).m_MagicSkill_105.btLevel > TPlayObject(self).m_MagicSkill_106.btLevel then begin
                          nDamage := Round(nDamage * (1 + g_Config.nHeartIncDamageRate / 100));
                        end;
                      end else begin //无心法则增加%5伤害
                        nDamage := Round(nDamage * (1 + g_Config.nHeartIncDamageRate / 100));
                      end;
                  end else
                    if (TPlayObject(Target).m_MagicSkill_106 <> nil) then begin
                      if (TPlayObject(self).m_MagicSkill_105 <> nil) then begin
                        if TPlayObject(Target).m_MagicSkill_106.btLevel > TPlayObject(self).m_MagicSkill_105.btLevel then begin
                          nDamage := Round(nDamage * (1 + g_Config.nHeartIncDamageRate / 100));
                        end;
                      end else
                        if (TPlayObject(self).m_MagicSkill_106 <> nil) then begin
                          if TPlayObject(Target).m_MagicSkill_106.btLevel > TPlayObject(self).m_MagicSkill_106.btLevel then begin
                            nDamage := Round(nDamage * (1 + g_Config.nHeartIncDamageRate / 100));
                          end;
                        end else begin //无心法则增加%5伤害
                          nDamage := Round(nDamage * (1 + g_Config.nHeartIncDamageRate / 100));
                        end;
                    end;
                end;
                if (TPlayObject(Target).m_MagicSkill_105 <> nil) then begin
                  if g_Config.boHeratPowerNeed then begin
                    if (TPlayObject(Target).m_boHeartActive) then
                      nDamage := nDamage + GetHeartPower(TPlayObject(Target).m_MagicSkill_105); //心法神圣属性处理
                  end else begin
                    nDamage := nDamage + GetHeartPower(TPlayObject(Target).m_MagicSkill_105); //心法神圣属性处理
                  end;
                end;
              end;
            RC_HEROOBJECT: begin
                n16 := Target.m_nDecTargetNHPoint;
                n17 := THeroObject(Target).m_boArmsCritPoint; //武器暴击等级 20100709
                if m_PEnvir.m_boCRIT then Inc(n17, m_PEnvir.m_nCRIT); //地图暴击等级 20110114
                if THeroObject(Target).m_boTrainingNG and (THeroObject(Target).m_Skill69NH > 0) then begin
                  case Target.m_btJob of //20090812 按职业来计算内功攻击力
                    0: n15 := (THeroObject(Target).m_NGLevel div g_Config.nWarrNGLevelIncDC) + 5;
                    1: n15 := (THeroObject(Target).m_NGLevel div g_Config.nWizardNGLevelIncDC) + 3;
                    2: n15 := (THeroObject(Target).m_NGLevel div g_Config.nTaosNGLevelIncDC) + 3;
                  end;
                end;
                boSKill101Use := THeroObject(Target).m_boCanUerSkill101;
                if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) then begin
                  if (Target.m_Master <> nil) then begin
                    if not TPlayObject(Target.m_Master).m_boGhost then begin
                      if TPlayObject(Target.m_Master).m_boFengHaoPower then begin //封号增加攻击倍率
                        nArmsCrit := Round(nDamage * ((TPlayObject(Target.m_Master).m_nFengHaoMinPowerRate + Random(TPlayObject(Target.m_Master).m_nFengHaoMaxPowerRate - TPlayObject(Target.m_Master).m_nFengHaoMinPowerRate)) / 100));
                      end;
                    end;
                  end;
                  if Target.m_PEnvir.m_boPeak then begin //巅峰状态地图
                    nArmsCrit := nArmsCrit + Round(nDamage * ((Target.m_PEnvir.m_nPeakMinRate + Random(Target.m_PEnvir.m_nPeakMaxRate - Target.m_PEnvir.m_nPeakMinRate)) / 100));
                  end;
                  Inc(nDamage, nArmsCrit);
                end;
              end;
          end;
        end;
      except
        n15 := 0;
        n16 := 0;
        n17 := 0;
        boSKill101Use := False;
      end;
    end;
    Inc(nDamage, n15); //20090115
{$IFEND}
    n15 := SmallInt(HiWord(m_WAbil.AC) - LoWord(m_WAbil.AC)); //20090818 修改
    if n15 > 0 then //20090812 增加
      n14 := LoWord(m_WAbil.AC) + Random({SmallInt(HiWord(m_WAbil.AC) - LoWord(m_WAbil.AC))}n15 + 1)
    else n14 := LoWord(m_WAbil.AC);
    if n14 < 0 then n14 := 0; //20081020 防止为负数
    nDamage := _MAX(0, nDamage - n14);
    if (m_btLifeAttrib = LA_UNDEAD) and (Target <> nil) then begin
      Inc(nDamage, Target.m_AddAbil.bt1DF);
    end;
    if (nDamage > 0) then begin
      if m_boProtectionDefence then begin //护体神盾 20080107
        if Random(100) <= g_Config.nProtectionOKRate then begin //生效机率 20080929
          nDamage := Round(nDamage * (1 - g_Config.nProtectionRate / 100));
          SendRefMsg(RM_MYSHOW, ET_PROTECTION_STRUCK, 0, 0, 0, ''); //发送护体神盾 受攻击 动画
        end;
      end;

      if m_boAbilMagBubbleDefence then begin //魔法盾 0-15% 1-30% 2-45% 3-60% 4-75%
        if (nDamage > 0) then begin //20091127 增加
          if m_btMagBubbleDefenceLevel < 4 then begin //20080829 四级盾可以自己设置比例
            nDamage := Round(nDamage * ((100 - (m_btMagBubbleDefenceLevel + 1) * g_Config.nOrdinarySkill66Rate {15}) / 100)); //20080625 修改
          end else begin
            nDamage := Round(nDamage * ((100 - g_Config.nSkill66Rate) / 100)); //四级盾
          end;
        end;
        DamageBubbleDefence(nDamage); //减少打击的损害
      end;
{$IF M2Version <> 2}
      //内功护体,减少普通攻击伤害 20081003
      if (nDamage > 0) then begin
        if m_btRaceServer = RC_PLAYOBJECT then begin
          if TPlayObject(Self).m_boTrainingNG and (TPlayObject(Self).m_Skill69NH > 0) then begin
            case m_btJob of //20090812 按职业来计算内功防御力
              0: nDamage := _MAX(0, nDamage - ((TPlayObject(Self).m_NGLevel div g_Config.nWarrNGLevelIncAC) + 12));
              1: nDamage := _MAX(0, nDamage - ((TPlayObject(Self).m_NGLevel div g_Config.nWizardNGLevelIncAC) + 15));
              2: nDamage := _MAX(0, nDamage - ((TPlayObject(Self).m_NGLevel div g_Config.nTaosNGLevelIncAC) + 13));
            end;
            TPlayObject(Self).m_Skill69NH := _MAX(0, TPlayObject(Self).m_Skill69NH - g_Config.nHitStruckDecNH - n16);
            TPlayObject(Self).SendRefMsg(RM_MAGIC69SKILLNH, 0, TPlayObject(Self).m_Skill69NH, TPlayObject(Self).m_Skill69MaxNH, 0, '');
          end;
        end else
          if m_btRaceServer = RC_HEROOBJECT then begin
            if THeroObject(Self).m_boTrainingNG and (THeroObject(Self).m_Skill69NH > 0) then begin
              case m_btJob of //20090812 按职业来计算内功防御力
                0: nDamage := _MAX(0, nDamage - ((THeroObject(Self).m_NGLevel div g_Config.nWarrNGLevelIncAC) + 12));
                1: nDamage := _MAX(0, nDamage - ((THeroObject(Self).m_NGLevel div g_Config.nWizardNGLevelIncAC) + 15));
                2: nDamage := _MAX(0, nDamage - ((THeroObject(Self).m_NGLevel div g_Config.nTaosNGLevelIncAC) + 13));
              end;
              THeroObject(Self).m_Skill69NH := _MAX(0, THeroObject(Self).m_Skill69NH - g_Config.nHitStruckDecNH - n16);
              THeroObject(Self).SendRefMsg(RM_MAGIC69SKILLNH, 0, THeroObject(Self).m_Skill69NH, THeroObject(Self).m_Skill69MaxNH, 0, '');
            end;
          end;
      end;
{$IFEND}
    end;
    n18 := ItemStruckDamage(nDamage); //20080223 新戒指减少损害值
{$IF M2Version <> 2}
    if boSKill101Use then begin //神龙附体效果
      n18 := Round(n18 * (g_Config.nSkill101Point / 100));
      SendRefMsg(RM_ARMSCRIT, 0, 0, 0, n18, ''); //显示特殊效果
    end;
    if n17 > 0 then begin //对方有暴击等级 20100709
      try
        case m_btRaceServer of
          RC_PLAYOBJECT: begin
              if Random(2) = 0 then TPlayObject(Self).m_nHeapStruckDamage := _MIN(g_Config.nMaxHeapStruckDamage, TPlayObject(Self).m_nHeapStruckDamage + n18); //受有武器暴击等级的人物累积攻击点 20100709
              n19 := g_Config.nArmsCritRate - n17;
              if n19 < 0 then n19 := 0;
              if (n17 > 4) and (Random(n19) = 0) then begin //暴击等级5级才会出现暴击特效
                nDamage := 0;
                nDamage := Round(TPlayObject(Self).m_nHeapStruckDamage * (n17 * 0.005));
                if nDamage > 0 then begin
                  Inc(n18, nDamage);
                  Inc(nArmsCrit, nDamage);
                //SendRefMsg(RM_ARMSCRIT, 0, 0, 0, nDamage, '');//显示特殊效果
                end;
              end;
            end;
          RC_HEROOBJECT: begin
              if Random(2) = 0 then THeroObject(Self).m_nHeapStruckDamage := _MIN(g_Config.nMaxHeapStruckDamage, THeroObject(Self).m_nHeapStruckDamage + n18); //受有武器暴击等级的人物累积攻击点 20100709
              n19 := g_Config.nArmsCritRate - n17;
              if n19 < 0 then n19 := 0;
              if (n17 > 4) and (Random(n19) = 0) then begin //暴击等级5级才会出现暴击特效
                nDamage := 0;
                nDamage := Round(THeroObject(Self).m_nHeapStruckDamage * (n17 * 0.005));
                if nDamage > 0 then begin
                  Inc(n18, nDamage);
                  Inc(nArmsCrit, nDamage);
                //SendRefMsg(RM_ARMSCRIT, 0, 0, 0, nDamage, '');//显示特殊效果
                end;
              end;
            end;
        end;
      except
      end;
    end;
    if (nArmsCrit > 0) and ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) then
      SendRefMsg(RM_ARMSCRIT, 0, 0, 0, nArmsCrit, ''); //显示特殊效
{$IF M2Version = 1}
    if (m_Abil.TransferValue > 0) then begin
      case m_btRaceServer of
        RC_PLAYOBJECT: begin
            if TPlayObject(Self).m_Magic95Skill <> nil then begin //学有斗转星移技能
              case m_btJob of
                0: begin //伤害值达到斗转星移生效点数时处理
                    if (n18 >= g_Config.nSkill95EffectPowerWarror) and (Random(g_Config.nSkill95EffectRateWarror) = 0) then begin
                      nDamage := 0;
                      if g_Config.nSkill95LevelDecInjury > 0 then begin
                        nDamage := Round(n18 * (_MIN(100, (g_Config.nSkill95DecInjuryWarror + (TPlayObject(Self).m_Magic95Skill.btLevel div g_Config.nSkill95LevelDecInjury))) / 100)); //计算可减的伤害值
                      end else nDamage := Round(n18 * (g_Config.nSkill95DecInjuryWarror / 100));
                      if nDamage > 0 then begin //20110202
                        if nDamage <= m_WAbil.TransferValue then begin
                          Dec(m_WAbil.TransferValue, nDamage);
                          n18 := _MAX(0, n18 - nDamage);
                          SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
                        end else begin
                          Dec(nDamage, m_WAbil.TransferValue);
                          m_WAbil.TransferValue := 0;
                          n18 := _MAX(0, n18 - nDamage);
                          SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
                        end;
                      end;
                    end;
                  end;
                1: begin
                    if (n18 >= g_Config.nSkill95EffectPowerWizard) and (Random(g_Config.nSkill95EffectRateWizard) = 0) then begin
                      nDamage := 0;
                      if g_Config.nSkill95LevelDecInjury > 0 then begin
                        nDamage := Round(n18 * (_MIN(100, (g_Config.nSkill95DecInjuryWizard + (TPlayObject(Self).m_Magic95Skill.btLevel div g_Config.nSkill95LevelDecInjury))) / 100)); //计算可减的伤害值
                      end else nDamage := Round(n18 * (g_Config.nSkill95DecInjuryWizard / 100));
                      if nDamage > 0 then begin //20110202
                        if nDamage <= m_WAbil.TransferValue then begin
                          Dec(m_WAbil.TransferValue, nDamage);
                          n18 := _MAX(0, n18 - nDamage);
                          SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
                        end else begin
                          Dec(nDamage, m_WAbil.TransferValue);
                          m_WAbil.TransferValue := 0;
                          n18 := _MAX(0, n18 - nDamage);
                          SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
                        end;
                      end;
                    end;
                  end;
                2: begin
                    if (n18 >= g_Config.nSkill95EffectPowerTaoist) and (Random(g_Config.nSkill95EffectRateTaoist) = 0) then begin
                      nDamage := 0;
                      if g_Config.nSkill95LevelDecInjury > 0 then begin
                        nDamage := Round(n18 * (_MIN(100, (g_Config.nSkill95DecInjuryTaoist + (TPlayObject(Self).m_Magic95Skill.btLevel div g_Config.nSkill95LevelDecInjury))) / 100)); //计算可减的伤害值
                      end else nDamage := Round(n18 * (g_Config.nSkill95DecInjuryTaoist / 100));
                      if nDamage > 0 then begin //20110202
                        if nDamage <= m_WAbil.TransferValue then begin
                          Dec(m_WAbil.TransferValue, nDamage);
                          n18 := _MAX(0, n18 - nDamage);
                          SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
                        end else begin
                          Dec(nDamage, m_WAbil.TransferValue);
                          m_WAbil.TransferValue := 0;
                          n18 := _MAX(0, n18 - nDamage);
                          SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
                        end;
                      end;
                    end;
                  end;
              end;
            end;
          end;
        RC_HEROOBJECT: begin
            if THeroObject(Self).m_Magic95Skill <> nil then begin //学有斗转星移技能
              case m_btJob of
                0: begin //伤害值达到斗转星移生效点数时处理
                    if (n18 >= g_Config.nSkill95EffectPowerWarror) and (Random(g_Config.nSkill95EffectRateWarror) = 0) then begin
                      nDamage := 0;
                      if g_Config.nSkill95LevelDecInjury > 0 then begin
                        nDamage := Round(n18 * (_MIN(100, (g_Config.nSkill95DecInjuryWarror + (THeroObject(Self).m_Magic95Skill.btLevel div g_Config.nSkill95LevelDecInjury))) / 100)); //计算可减的伤害值
                      end else nDamage := Round(n18 * (g_Config.nSkill95DecInjuryWarror / 100));
                      if nDamage > 0 then begin //20110202
                        if nDamage <= m_WAbil.TransferValue then begin
                          Dec(m_WAbil.TransferValue, nDamage);
                          n18 := _MAX(0, n18 - nDamage);
                          THeroObject(Self).SendMsg(Self, RM_HEROABILITY, 0, 0, 0, 0, '');
                        end else begin
                          Dec(nDamage, m_WAbil.TransferValue);
                          m_WAbil.TransferValue := 0;
                          n18 := _MAX(0, n18 - nDamage);
                          THeroObject(Self).SendMsg(Self, RM_HEROABILITY, 0, 0, 0, 0, '');
                        end;
                      end;
                    end;
                  end;
                1: begin
                    if (n18 >= g_Config.nSkill95EffectPowerWizard) and (Random(g_Config.nSkill95EffectRateWizard) = 0) then begin
                      nDamage := 0;
                      if g_Config.nSkill95LevelDecInjury > 0 then begin
                        nDamage := Round(n18 * (_MIN(100, (g_Config.nSkill95DecInjuryWizard + (THeroObject(Self).m_Magic95Skill.btLevel div g_Config.nSkill95LevelDecInjury))) / 100)); //计算可减的伤害值
                      end else nDamage := Round(n18 * (g_Config.nSkill95DecInjuryWizard / 100));
                      if nDamage > 0 then begin //20110202
                        if nDamage <= m_WAbil.TransferValue then begin
                          Dec(m_WAbil.TransferValue, nDamage);
                          n18 := _MAX(0, n18 - nDamage);
                          THeroObject(Self).SendMsg(Self, RM_HEROABILITY, 0, 0, 0, 0, '');
                        end else begin
                          Dec(nDamage, m_WAbil.TransferValue);
                          m_WAbil.TransferValue := 0;
                          n18 := _MAX(0, n18 - nDamage);
                          THeroObject(Self).SendMsg(Self, RM_HEROABILITY, 0, 0, 0, 0, '');
                        end;
                      end;
                    end;
                  end;
                2: begin
                    if (n18 >= g_Config.nSkill95EffectPowerTaoist) and (Random(g_Config.nSkill95EffectRateTaoist) = 0) then begin
                      nDamage := 0;
                      if g_Config.nSkill95LevelDecInjury > 0 then begin
                        nDamage := Round(n18 * (_MIN(100, (g_Config.nSkill95DecInjuryTaoist + (THeroObject(Self).m_Magic95Skill.btLevel div g_Config.nSkill95LevelDecInjury))) / 100)); //计算可减的伤害值
                      end else nDamage := Round(n18 * (g_Config.nSkill95DecInjuryTaoist / 100));
                      if nDamage > 0 then begin //20110202
                        if nDamage <= m_WAbil.TransferValue then begin
                          Dec(m_WAbil.TransferValue, nDamage);
                          n18 := _MAX(0, n18 - nDamage);
                          THeroObject(Self).SendMsg(Self, RM_HEROABILITY, 0, 0, 0, 0, '');
                        end else begin
                          Dec(nDamage, m_WAbil.TransferValue);
                          m_WAbil.TransferValue := 0;
                          n18 := _MAX(0, n18 - nDamage);
                          THeroObject(Self).SendMsg(Self, RM_HEROABILITY, 0, 0, 0, 0, '');
                        end;
                      end;
                    end;
                  end;
              end;
            end;
          end;
      end;
    end;
{$IFEND}
{$IFEND}
    Result := n18;
  except   
    MainOutMessage(format('{%s} TBaseObject.GetHitStruckDamage', [g_sExceptionVer]));
  end;
end;
//取魔法攻击,减少的损害

function TBaseObject.GetMagStruckDamage(BaseObject: TBaseObject; nDamage, nType, nType1: Integer): Integer;
{$IF M2Version <> 2}
  function GetHeartPower(UserMagic: pTUserMagic): Integer; //计算龙卫心法的神圣属性
  var
    nPower: Integer;
  begin
    if UserMagic.MagicInfo.wMaxPower > UserMagic.MagicInfo.wPower then //心法的基本威力
      nPower := UserMagic.MagicInfo.wPower + Random(UserMagic.MagicInfo.wMaxPower - UserMagic.MagicInfo.wPower)
    else nPower := UserMagic.MagicInfo.wPower;
    if UserMagic.MagicInfo.btDefMaxPower > UserMagic.MagicInfo.btDefPower then //计算心法的升级威力
      Result := Round(nPower / (UserMagic.MagicInfo.btTrainLv + 1) * (UserMagic.btLevel + 1)) + (UserMagic.MagicInfo.btDefPower + Random(UserMagic.MagicInfo.btDefMaxPower - UserMagic.MagicInfo.btDefPower))
    else Result := Round(nPower / (UserMagic.MagicInfo.btTrainLv + 1) * (UserMagic.btLevel + 1)) + UserMagic.MagicInfo.btDefPower;
    if Result < 0 then Result := 0;
  end;
{$IFEND}
var
  n14, n15, n16, n17, n18, n19, nArmsCrit: Integer;
  boSKill101Use: Boolean;
  nCode: byte;
begin
  try
    Result := 0;
    nCode := 0;
    n15 := 0;
    n16 := 0;
    n17 := 0;
    n18 := 0;
    boSKill101Use := False;
{$IF M2Version <> 2}
    nArmsCrit := 0;
    //内功护体,增加普通攻击力 20081003
    if BaseObject <> nil then begin
      try
        if not BaseObject.m_boDeath then begin //20090105
          case BaseObject.m_btRaceServer of
            RC_PLAYOBJECT: begin
                n16 := BaseObject.m_nDecTargetNHPoint;
                n17 := TPlayObject(BaseObject).m_boArmsCritPoint; //武器暴击等级 20100709
                if m_PEnvir.m_boCRIT then Inc(n17, m_PEnvir.m_nCRIT); //地图暴击等级 20110114
                if TPlayObject(BaseObject).m_boTrainingNG and (TPlayObject(BaseObject).m_Skill69NH > 0) then begin
                  case BaseObject.m_btJob of //20090812 按职业来计算内功攻击力
                    0: n15 := (TPlayObject(BaseObject).m_NGLevel div g_Config.nWarrNGLevelIncDC) + 5;
                    1: n15 := (TPlayObject(BaseObject).m_NGLevel div g_Config.nWizardNGLevelIncDC) + 3;
                    2: n15 := (TPlayObject(BaseObject).m_NGLevel div g_Config.nTaosNGLevelIncDC) + 3;
                  end;
                end;
                boSKill101Use := TPlayObject(BaseObject).m_boCanUerSkill101;
                if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) then begin
                  if TPlayObject(BaseObject).m_boFengHaoPower then begin //封号增加攻击倍率
                    nArmsCrit := Round(nDamage * ((TPlayObject(BaseObject).m_nFengHaoMinPowerRate + Random(TPlayObject(BaseObject).m_nFengHaoMaxPowerRate - TPlayObject(BaseObject).m_nFengHaoMinPowerRate)) / 100));
                  end;
                  if BaseObject.m_PEnvir.m_boPeak then begin //巅峰状态地图
                    nArmsCrit := nArmsCrit + Round(nDamage * ((BaseObject.m_PEnvir.m_nPeakMinRate + Random(BaseObject.m_PEnvir.m_nPeakMaxRate - BaseObject.m_PEnvir.m_nPeakMinRate)) / 100));
                  end;
                  Inc(nDamage, nArmsCrit);
                end;


                if (m_btRaceServer = RC_PLAYOBJECT) and
                   ((nType <> 1) or (not g_Config.boMagFirNoneSSMagic))//火墙忽略神圣魔法
                then begin //人判断心法压制
                  if (TPlayObject(BaseObject).m_MagicSkill_105 <> nil) then begin
                    if (TPlayObject(self).m_MagicSkill_105 <> nil) then begin
                      if TPlayObject(BaseObject).m_MagicSkill_105.btLevel > TPlayObject(self).m_MagicSkill_105.btLevel then begin
                        nDamage := Round(nDamage * (1 + g_Config.nHeartIncDamageRate / 100));
                      end;
                    end else
                      if (TPlayObject(self).m_MagicSkill_106 <> nil) then begin
                        if TPlayObject(BaseObject).m_MagicSkill_105.btLevel > TPlayObject(self).m_MagicSkill_106.btLevel then begin
                          nDamage := Round(nDamage * (1 + g_Config.nHeartIncDamageRate / 100));
                        end;
                      end else begin //无心法则增加%5伤害
                        nDamage := Round(nDamage * (1 + g_Config.nHeartIncDamageRate / 100));
                      end;
                  end else 
                    if (TPlayObject(BaseObject).m_MagicSkill_106 <> nil) then begin
                      if (TPlayObject(self).m_MagicSkill_105 <> nil) then begin
                        if TPlayObject(BaseObject).m_MagicSkill_106.btLevel > TPlayObject(self).m_MagicSkill_105.btLevel then begin
                          nDamage := Round(nDamage * (1 + g_Config.nHeartIncDamageRate / 100));
                        end;
                      end else
                        if (TPlayObject(self).m_MagicSkill_106 <> nil) then begin
                          if TPlayObject(BaseObject).m_MagicSkill_106.btLevel > TPlayObject(self).m_MagicSkill_106.btLevel then begin
                            nDamage := Round(nDamage * (1 + g_Config.nHeartIncDamageRate / 100));
                          end;
                        end else begin //无心法则增加%5伤害
                          nDamage := Round(nDamage * (1 + g_Config.nHeartIncDamageRate / 100));
                        end;
                    end;
                end;
                if (TPlayObject(BaseObject).m_MagicSkill_105 <> nil) and 
                   ((nType <> 1) or (not g_Config.boMagFirNoneSSMagic))//火墙忽略神圣魔法
                then begin
                  if g_Config.boHeratPowerNeed then begin
                    if (TPlayObject(BaseObject).m_boHeartActive) then
                      nDamage := nDamage + GetHeartPower(TPlayObject(BaseObject).m_MagicSkill_105); //心法神圣属性处理
                  end else begin
                    nDamage := nDamage + GetHeartPower(TPlayObject(BaseObject).m_MagicSkill_105); //心法神圣属性处理
                  end;
                end;
              end;
            RC_HEROOBJECT: begin
                n16 := BaseObject.m_nDecTargetNHPoint;
                n17 := THeroObject(BaseObject).m_boArmsCritPoint; //武器暴击等级 20100709
                if m_PEnvir.m_boCRIT then Inc(n17, m_PEnvir.m_nCRIT); //地图暴击等级 20110114
                if THeroObject(BaseObject).m_boTrainingNG and (THeroObject(BaseObject).m_Skill69NH > 0) then begin
                  case BaseObject.m_btJob of //20090812 按职业来计算内功攻击力
                    0: n15 := (THeroObject(BaseObject).m_NGLevel div g_Config.nWarrNGLevelIncDC) + 5;
                    1: n15 := (THeroObject(BaseObject).m_NGLevel div g_Config.nWizardNGLevelIncDC) + 3;
                    2: n15 := (THeroObject(BaseObject).m_NGLevel div g_Config.nTaosNGLevelIncDC) + 3;
                  end;
                end;
                boSKill101Use := THeroObject(BaseObject).m_boCanUerSkill101;
                if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) then begin
                  if (BaseObject.m_Master <> nil) then begin
                    if not TPlayObject(BaseObject.m_Master).m_boGhost then begin
                      if TPlayObject(BaseObject.m_Master).m_boFengHaoPower then begin //封号增加攻击倍率
                        nArmsCrit := Round(nDamage * ((TPlayObject(BaseObject.m_Master).m_nFengHaoMinPowerRate + Random(TPlayObject(BaseObject.m_Master).m_nFengHaoMaxPowerRate - TPlayObject(BaseObject.m_Master).m_nFengHaoMinPowerRate)) / 100));
                      end;
                    end;
                  end;
                  if BaseObject.m_PEnvir.m_boPeak then begin //巅峰状态地图
                    nArmsCrit := nArmsCrit + Round(nDamage * ((BaseObject.m_PEnvir.m_nPeakMinRate + Random(BaseObject.m_PEnvir.m_nPeakMaxRate - BaseObject.m_PEnvir.m_nPeakMinRate)) / 100));
                  end;
                  Inc(nDamage, nArmsCrit);
                end;
              end;
          end;
        end;
      except
        n15 := 0;
        n16 := 0;
        n17 := 0;
        boSKill101Use := False;
      end;
    end;
    Inc(nDamage, n15);
{$IFEND}
    n15 := SmallInt(HiWord(m_WAbil.MAC) - LoWord(m_WAbil.MAC)); //20090818
    if n15 > 0 then //20090818 修改
      n14 := LoWord(m_WAbil.MAC) + Random({SmallInt(HiWord(m_WAbil.MAC) - LoWord(m_WAbil.MAC))}n15 + 1)
    else n14 := LoWord(m_WAbil.MAC);
    if n14 < 0 then n14 := 0; //20081020 防止为负数
    nDamage := _MAX(0, nDamage - n14);
    if (m_btLifeAttrib = LA_UNDEAD) and (BaseObject <> nil) then begin
      Inc(nDamage, m_AddAbil.bt1DF);
    end;
    nCode := 6;
    if (nDamage > 0) then begin
      nCode := 7;
      if m_boProtectionDefence then begin //护体神盾 20080107
        if Random(100) <= g_Config.nProtectionOKRate then begin //生效机率 20080929
          nDamage := Round(nDamage * (1 - g_Config.nProtectionRate / 100));
          SendRefMsg(RM_MYSHOW, ET_PROTECTION_STRUCK, 0, 0, 0, ''); //发送护体神盾 受攻击 动画
        end;
      end;
      nCode := 8;
      if m_boAbilMagBubbleDefence then begin //魔法盾  0-15% 1-30% 2-45% 3-60% 4-75%
        if (nDamage > 0) then begin //20091127 增加
          if m_btMagBubbleDefenceLevel < 4 then begin //20080829 四级盾可以自己设置比例
            nDamage := Round(nDamage * ((100 - (m_btMagBubbleDefenceLevel + 1) * g_Config.nOrdinarySkill66Rate {15}) / 100)); //20080625 修改
            //nDamage := Round((nDamage / 1.0E2) * (m_btMagBubbleDefenceLevel + 2) * 8.0);//1.0E2表示100
          end else begin
            nDamage := Round(nDamage * ((100 - g_Config.nSkill66Rate) / 100)); //四级盾
          end;
        end;
        DamageBubbleDefence(nDamage); //减少盾的使用时间
      end;
{$IF M2Version <> 2}
      nCode := 9;
      //内功护体,减少普通攻击伤害 20081003
      if (nDamage > 0) then begin
        case m_btRaceServer of
          RC_PLAYOBJECT: begin
              nCode := 10;
              if TPlayObject(Self).m_boTrainingNG and (TPlayObject(Self).m_Skill69NH > 0) then begin
                case m_btJob of //20090812 按职业来计算内功防御力
                  0: nDamage := _MAX(0, nDamage - ((TPlayObject(Self).m_NGLevel div g_Config.nWarrNGLevelIncAC) + 12));
                  1: nDamage := _MAX(0, nDamage - ((TPlayObject(Self).m_NGLevel div g_Config.nWizardNGLevelIncAC) + 15));
                  2: nDamage := _MAX(0, nDamage - ((TPlayObject(Self).m_NGLevel div g_Config.nTaosNGLevelIncAC) + 13));
                end;
                TPlayObject(Self).m_Skill69NH := _MAX(0, TPlayObject(Self).m_Skill69NH - g_Config.nHitStruckDecNH - n16);
                TPlayObject(Self).SendRefMsg(RM_MAGIC69SKILLNH, 0, TPlayObject(Self).m_Skill69NH, TPlayObject(Self).m_Skill69MaxNH, 0, '');
              end;
            end;
          RC_HEROOBJECT: begin
              nCode := 12;
              if THeroObject(Self).m_boTrainingNG and (THeroObject(Self).m_Skill69NH > 0) then begin
                case m_btJob of //20090812 按职业来计算内功防御力
                  0: nDamage := _MAX(0, nDamage - ((THeroObject(Self).m_NGLevel div g_Config.nWarrNGLevelIncAC) + 12));
                  1: nDamage := _MAX(0, nDamage - ((THeroObject(Self).m_NGLevel div g_Config.nWizardNGLevelIncAC) + 15));
                  2: nDamage := _MAX(0, nDamage - ((THeroObject(Self).m_NGLevel div g_Config.nTaosNGLevelIncAC) + 13));
                end;
                THeroObject(Self).m_Skill69NH := _MAX(0, THeroObject(Self).m_Skill69NH - g_Config.nHitStruckDecNH - n16);
                THeroObject(Self).SendRefMsg(RM_MAGIC69SKILLNH, 0, THeroObject(Self).m_Skill69NH, THeroObject(Self).m_Skill69MaxNH, 0, '');
              end;
            end;
        end; //case
      end;
{$IFEND}
    end;
    nCode := 14;
    n18 := ItemStruckDamage(nDamage); //20080223 吸伤减少损害值
    nCode := 15;
{$IF M2Version <> 2}
    if boSKill101Use then begin //神龙附体效果
      n18 := Round(n18 * (g_Config.nSkill101Point / 100));
      SendRefMsg(RM_ARMSCRIT, 0, 0, 0, n18, ''); //显示特殊效果
    end;
    nCode := 16;
    if (n17 > 0) and (nType = 0) then begin //对方有暴击等级,同时不是火墙攻击时 20100926
      try
        case m_btRaceServer of
          RC_PLAYOBJECT: begin
              if Random(3) = 0 then TPlayObject(Self).m_nHeapStruckDamage := _MIN(g_Config.nMaxHeapStruckDamage, TPlayObject(Self).m_nHeapStruckDamage + n18); //受有武器暴击等级的人物累积攻击点 20100709
              n19 := g_Config.nArmsCritRate - n17;
              if n19 < 0 then n19 := 0;
              if (n17 > 4) and (Random(n19) = 0) then begin //暴击等级5级才会出现暴击特效
                nDamage := 0;
                nDamage := Round(TPlayObject(Self).m_nHeapStruckDamage * (n17 * 0.005));
                if nDamage > 0 then begin
                  Inc(n18, nDamage);
                  Inc(nArmsCrit, nDamage);
                //SendRefMsg(RM_ARMSCRIT, 0, 0, 0, nDamage, '');//显示特殊效果
                end;
              end;
            end;
          RC_HEROOBJECT: begin
              if Random(3) = 0 then THeroObject(Self).m_nHeapStruckDamage := _MIN(g_Config.nMaxHeapStruckDamage, THeroObject(Self).m_nHeapStruckDamage + n18); //受有武器暴击等级的人物累积攻击点 20100709
              n19 := g_Config.nArmsCritRate - n17;
              if n19 < 0 then n19 := 0;
              if (n17 > 4) and (Random(n19) = 0) then begin //暴击等级5级才会出现暴击特效
                nDamage := 0;
                nDamage := Round(THeroObject(Self).m_nHeapStruckDamage * (n17 * 0.005));
                if nDamage > 0 then begin
                  Inc(n18, nDamage);
                  Inc(nArmsCrit, nDamage);
                //SendRefMsg(RM_ARMSCRIT, 0, 0, 0, nDamage, '');//显示特殊效果
                end;
              end;
            end;
        end;
      except
      end;
    end;
    nCode := 17;
    if (nType1 = 0) and (nArmsCrit > 0) and ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) then
      SendRefMsg(RM_ARMSCRIT, 0, 0, 0, nArmsCrit, ''); //显示特殊效果
{$IF M2Version = 1}
    //伤害值达到斗转星移生效点数时处理
    if (nType1 = 0) and (m_Abil.TransferValue > 0) and (n18 > 0) and (not m_boGhost) and (not m_boDeath) then begin
      case m_btRaceServer of
        RC_PLAYOBJECT: begin
            nCode := 18;
            if TPlayObject(Self).m_Magic95Skill <> nil then begin //学有斗转星移技能
              case m_btJob of
                0: begin //伤害值达到斗转星移生效点数时处理
                    if (n18 >= g_Config.nSkill95EffectPowerWarror) and (Random(g_Config.nSkill95EffectRateWarror) = 0) then begin
                      nDamage := 0;
                      nCode := 19;
                      if g_Config.nSkill95LevelDecInjury > 0 then begin
                        nDamage := Round(n18 * (_MIN(100, (g_Config.nSkill95DecInjuryWarror + (TPlayObject(Self).m_Magic95Skill.btLevel div g_Config.nSkill95LevelDecInjury))) / 100)); //计算可减的伤害值
                      end else nDamage := Round(n18 * (g_Config.nSkill95DecInjuryWarror / 100));
                      if nDamage > 0 then begin //20110202
                        if nDamage <= m_WAbil.TransferValue then begin
                          Dec(m_WAbil.TransferValue, nDamage);
                          nCode := 30;
                          n18 := _MAX(0, n18 - nDamage);
                          SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
                        end else begin
                          Dec(nDamage, m_WAbil.TransferValue);
                          m_WAbil.TransferValue := 0;
                          nCode := 31;
                          n18 := _MAX(0, n18 - nDamage);
                          SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
                        end;
                      end;
                    end;
                  end;
                1: begin
                    nCode := 21;
                    if (n18 >= g_Config.nSkill95EffectPowerWizard) and (Random(g_Config.nSkill95EffectRateWizard) = 0) then begin
                      nDamage := 0;
                      if g_Config.nSkill95LevelDecInjury > 0 then begin
                        nDamage := Round(n18 * (_MIN(100, (g_Config.nSkill95DecInjuryWizard + (TPlayObject(Self).m_Magic95Skill.btLevel div g_Config.nSkill95LevelDecInjury))) / 100)); //计算可减的伤害值
                      end else nDamage := Round(n18 * (g_Config.nSkill95DecInjuryWizard / 100));
                      if nDamage > 0 then begin //20110202
                        if nDamage <= m_WAbil.TransferValue then begin
                          Dec(m_WAbil.TransferValue, nDamage);
                          nCode := 32;
                          n18 := _MAX(0, n18 - nDamage);
                          SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
                        end else begin
                          Dec(nDamage, m_WAbil.TransferValue);
                          m_WAbil.TransferValue := 0;
                          nCode := 33;
                          n18 := _MAX(0, n18 - nDamage);
                          SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
                        end;
                      end;
                    end;
                  end;
                2: begin
                    nCode := 23;
                    if (n18 >= g_Config.nSkill95EffectPowerTaoist) and (Random(g_Config.nSkill95EffectRateTaoist) = 0) then begin
                      nDamage := 0;
                      if g_Config.nSkill95LevelDecInjury > 0 then begin
                        nDamage := Round(n18 * (_MIN(100, (g_Config.nSkill95DecInjuryTaoist + (TPlayObject(Self).m_Magic95Skill.btLevel div g_Config.nSkill95LevelDecInjury))) / 100)); //计算可减的伤害值
                      end else nDamage := Round(n18 * (g_Config.nSkill95DecInjuryTaoist / 100));
                      nCode := 24;
                      if nDamage > 0 then begin //20110202
                        if nDamage <= m_WAbil.TransferValue then begin
                          Dec(m_WAbil.TransferValue, nDamage);
                          nCode := 34;
                          n18 := _MAX(0, n18 - nDamage);
                          SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
                        end else begin
                          Dec(nDamage, m_WAbil.TransferValue);
                          m_WAbil.TransferValue := 0;
                          nCode := 35;
                          n18 := _MAX(0, n18 - nDamage);
                          SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
                        end;
                      end;
                    end;
                  end;
              end;
            end;
          end;
        RC_HEROOBJECT: begin
            nCode := 25;
            if THeroObject(Self).m_Magic95Skill <> nil then begin //学有斗转星移技能
              case m_btJob of
                0: begin //伤害值达到斗转星移生效点数时处理
                    if (n18 >= g_Config.nSkill95EffectPowerWarror) and (Random(g_Config.nSkill95EffectRateWarror) = 0) then begin
                      nDamage := 0;
                      if g_Config.nSkill95LevelDecInjury > 0 then begin
                        nDamage := Round(n18 * (_MIN(100, (g_Config.nSkill95DecInjuryWarror + (THeroObject(Self).m_Magic95Skill.btLevel div g_Config.nSkill95LevelDecInjury))) / 100)); //计算可减的伤害值
                      end else nDamage := Round(n18 * (g_Config.nSkill95DecInjuryWarror / 100));
                      nCode := 26;
                      if nDamage > 0 then begin //20110202
                        if nDamage <= m_WAbil.TransferValue then begin
                          Dec(m_WAbil.TransferValue, nDamage);
                          nCode := 36;
                          n18 := _MAX(0, n18 - nDamage);
                          THeroObject(Self).SendMsg(Self, RM_HEROABILITY, 0, 0, 0, 0, '');
                        end else begin
                          Dec(nDamage, m_WAbil.TransferValue);
                          m_WAbil.TransferValue := 0;
                          nCode := 37;
                          n18 := _MAX(0, n18 - nDamage);
                          THeroObject(Self).SendMsg(Self, RM_HEROABILITY, 0, 0, 0, 0, '');
                        end;
                      end;
                    end;
                  end;
                1: begin
                    nCode := 27;
                    if (n18 >= g_Config.nSkill95EffectPowerWizard) and (Random(g_Config.nSkill95EffectRateWizard) = 0) then begin
                      nDamage := 0;
                      if g_Config.nSkill95LevelDecInjury > 0 then begin
                        nDamage := Round(n18 * (_MIN(100, (g_Config.nSkill95DecInjuryWizard + (THeroObject(Self).m_Magic95Skill.btLevel div g_Config.nSkill95LevelDecInjury))) / 100)); //计算可减的伤害值
                      end else nDamage := Round(n18 * (g_Config.nSkill95DecInjuryWizard / 100));
                      nCode := 28;
                      if nDamage > 0 then begin //20110202
                        if nDamage <= m_WAbil.TransferValue then begin
                          Dec(m_WAbil.TransferValue, nDamage);
                          nCode := 38;
                          n18 := _MAX(0, n18 - nDamage);
                          THeroObject(Self).SendMsg(Self, RM_HEROABILITY, 0, 0, 0, 0, '');
                        end else begin
                          Dec(nDamage, m_WAbil.TransferValue);
                          m_WAbil.TransferValue := 0;
                          nCode := 39;
                          n18 := _MAX(0, n18 - nDamage);
                          THeroObject(Self).SendMsg(Self, RM_HEROABILITY, 0, 0, 0, 0, '');
                        end;
                      end;
                    end;
                  end;
                2: begin
                    if (n18 >= g_Config.nSkill95EffectPowerTaoist) and (Random(g_Config.nSkill95EffectRateTaoist) = 0) then begin
                      nDamage := 0;
                      if g_Config.nSkill95LevelDecInjury > 0 then begin
                        nDamage := Round(n18 * (_MIN(100, (g_Config.nSkill95DecInjuryTaoist + (THeroObject(Self).m_Magic95Skill.btLevel div g_Config.nSkill95LevelDecInjury))) / 100)); //计算可减的伤害值
                      end else nDamage := Round(n18 * (g_Config.nSkill95DecInjuryTaoist / 100));
                      nCode := 29;
                      if nDamage > 0 then begin //20110202
                        if nDamage <= m_WAbil.TransferValue then begin
                          Dec(m_WAbil.TransferValue, nDamage);
                          nCode := 40;
                          n18 := _MAX(0, n18 - nDamage);
                          THeroObject(Self).SendMsg(Self, RM_HEROABILITY, 0, 0, 0, 0, '');
                        end else begin
                          Dec(nDamage, m_WAbil.TransferValue);
                          m_WAbil.TransferValue := 0;
                          nCode := 41;
                          n18 := _MAX(0, n18 - nDamage);
                          THeroObject(Self).SendMsg(Self, RM_HEROABILITY, 0, 0, 0, 0, '');
                        end;
                      end;
                    end;
                  end;
              end;
            end;
          end;
      end;
    end;
{$IFEND}
{$IFEND}
    nCode := 17;
    Result := n18;
  except   
    MainOutMessage(format('{%s} TBaseObject.GetMagStruckDamage Code:%d', [g_sExceptionVer, nCode]));
  end;
end;
//受攻击,减身上装备的持久

procedure TBaseObject.StruckDamage(nDamage: Integer);
var
  I: Integer;
  nDam: Integer;
  nDura, nOldDura: Integer;
  PlayObject, PushedObject: TPlayObject;
  StdItem: pTStdItem;
  bo19: Boolean;
begin
  try
    if nDamage <= 0 then Exit;
    nDam := Random(10) + 5;
    if m_wStatusTimeArr[POISON_DAMAGEARMOR] > 0 then begin //中红毒
      nDam := Round(nDam * (g_Config.nPosionDamagarmor / 10) {1.2});
      nDamage := Round(nDamage * (g_Config.nPosionDamagarmor / 10) {1.2});
    end;
    bo19 := False;
    if (m_UseItems[U_DRESS].wIndex > 0) and ((m_UseItems[U_DRESS].Dura > 0) or g_Config.boItmeAutoOver) then begin //衣服
      nDura := m_UseItems[U_DRESS].Dura;
      nOldDura := Round(nDura / 1000);
      Dec(nDura, nDam);
      if nDura <= 0 then begin
        if g_Config.boItmeAutoOver then begin //20110117 持久0物品不消失
          if m_btRaceServer = RC_PLAYOBJECT then begin
            PlayObject := TPlayObject(Self);
            PlayObject.SendDelItems(@m_UseItems[U_DRESS]);
            StdItem := UserEngine.GetStdItem(m_UseItems[U_DRESS].wIndex);
            if StdItem <> nil then begin //20090115
              if StdItem.NeedIdentify = 1 then
                AddGameDataLog('3' + #9 + m_sMapName + #9 +
                  IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                  m_sCharName + #9 + StdItem.Name + #9 +
                  IntToStr(m_UseItems[U_DRESS].MakeIndex) + #9 +
                  '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                  '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                  '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                  '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                  '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                  IntToStr(m_UseItems[U_DRESS].btValue[0]) + '/' + IntToStr(m_UseItems[U_DRESS].btValue[1]) + '/' + IntToStr(m_UseItems[U_DRESS].btValue[2]) + '/' +
                  IntToStr(m_UseItems[U_DRESS].btValue[3]) + '/' + IntToStr(m_UseItems[U_DRESS].btValue[4]) + '/' + IntToStr(m_UseItems[U_DRESS].btValue[5]) + '/' +
                  IntToStr(m_UseItems[U_DRESS].btValue[6]) + '/' + IntToStr(m_UseItems[U_DRESS].btValue[7]) + '/' + IntToStr(m_UseItems[U_DRESS].btValue[8]) + '/' +
                  IntToStr(m_UseItems[U_DRESS].btValue[14]) + #9 + BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT));
            end;
            m_UseItems[U_DRESS].wIndex := 0;
            FeatureChanged();
          end;
          m_UseItems[U_DRESS].wIndex := 0;
        end;
        m_UseItems[U_DRESS].Dura := 0;
        if not g_Config.boItmeAutoOver then SendMsg(Self, RM_DURACHANGE, U_DRESS, m_UseItems[U_DRESS].Dura, m_UseItems[U_DRESS].DuraMax, 0, ''); //20110117 增加，
        bo19 := True;
      end else begin
        m_UseItems[U_DRESS].Dura := nDura;
      end;
      if nOldDura <> Round(nDura / 1000) then begin
        SendMsg(Self, RM_DURACHANGE, U_DRESS, nDura, m_UseItems[U_DRESS].DuraMax, 0, '');
      end;
    end;

    for I := Low(THumanUseItems) to High(THumanUseItems) do begin //9格装备+4格装备
      if (m_UseItems[I].wIndex > 0) and ((m_UseItems[I].Dura > 0) or g_Config.boItmeAutoOver) and (Random(8) = 0) then begin
        StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex); //20080404
        if StdItem = nil then Continue; //20090115
        if (StdItem <> nil) and (((StdItem.StdMode = 2) and (StdItem.AniCount = 21)) or (StdItem.StdMode = 25) or (StdItem.StdMode = 7)) then Continue; //是祝福罐,火龙之心物品则跳过
        nDura := m_UseItems[I].Dura;
        nOldDura := Round(nDura / 1000);
        Dec(nDura, nDam);
        if nDura <= 0 then begin
          if g_Config.boItmeAutoOver then begin //20110117 持久0物品不消失
            if m_btRaceServer = RC_PLAYOBJECT then begin
              PlayObject := TPlayObject(Self);
              PlayObject.SendDelItems(@m_UseItems[I]);
              if StdItem.NeedIdentify = 1 then
                AddGameDataLog('3' + #9 +
                  m_sMapName + #9 +
                  IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                  m_sCharName + #9 + StdItem.Name + #9 +
                  IntToStr(m_UseItems[I].MakeIndex) + #9 +
                  '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                  '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                  '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                  '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                  '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                  IntToStr(m_UseItems[I].btValue[0]) + '/' + IntToStr(m_UseItems[I].btValue[1]) + '/' + IntToStr(m_UseItems[I].btValue[2]) + '/' +
                  IntToStr(m_UseItems[I].btValue[3]) + '/' + IntToStr(m_UseItems[I].btValue[4]) + '/' + IntToStr(m_UseItems[I].btValue[5]) + '/' +
                  IntToStr(m_UseItems[I].btValue[6]) + '/' + IntToStr(m_UseItems[I].btValue[7]) + '/' + IntToStr(m_UseItems[I].btValue[8]) + '/' +
                  IntToStr(m_UseItems[I].btValue[14]) + #9 + BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT));
              m_UseItems[I].wIndex := 0;
              FeatureChanged();
            end;
            m_UseItems[I].wIndex := 0;
          end;
          m_UseItems[I].Dura := 0;
          if not g_Config.boItmeAutoOver then SendMsg(Self, RM_DURACHANGE, I, m_UseItems[I].Dura, m_UseItems[I].DuraMax, 0, ''); //20110117 增加，
          bo19 := True;
        end else begin
          m_UseItems[I].Dura := nDura;
        end; //if nDura <= 0 then begin
        if nOldDura <> Round(nDura / 1000) then begin
          SendMsg(Self, RM_DURACHANGE, I, nDura, m_UseItems[I].DuraMax, 0, '');
        end;
      end; // if (m_UseItems[I].wIndex > 0) and (Random(8) = 0) then begin
    end; //for I := Low(THumanUseItems) to High(THumanUseItems) do begin
    if bo19 then begin
      RecalcAbilitys();
      CompareSuitItem(False); //套装与身上装备对比 20080729
    end;
    DamageHealth(nDamage);
{$IF M2Version <> 2} //PK时，护花使者，传奇之星相互提示
    if (not m_boDeath) and (not m_boGhost) and (m_TargetCret <> nil) and
      (m_btRaceServer = RC_PLAYOBJECT) then begin
      PlayObject := TPlayObject(Self);
      if (not PlayObject.m_boNotOnlineAddExp) and (PlayObject.m_boCanTitle) and
        ((m_TargetCret.m_btRaceServer = RC_PLAYOBJECT) or (m_TargetCret.m_btRaceServer = RC_HEROOBJECT)
        or (m_TargetCret.m_Master <> nil)) then begin
        if (GetTickCount - PlayObject.m_AttackShowMsgTick) > 180000 then begin
          PlayObject.m_AttackShowMsgTick := GetTickCount();
          if PlayObject.m_boFengHaoHuhua and (PlayObject.m_sHuhuaName <> '') then begin //护花使者受攻击，提示传奇之星
            PushedObject := UserEngine.GetPlayObject(PlayObject.m_sHuhuaName); //检查是否在线
            if PushedObject <> nil then begin
              if (not PushedObject.m_boNotOnlineAddExp) and (not PushedObject.m_boDeath)
                and (not PushedObject.m_boGhost) and (PushedObject.m_boFengHaoMagicEffect) then begin
                PushedObject.SysMsg(Format('%s 地图【%s】坐标%d:%d', [m_sCharName, m_PEnvir.sMapDesc, m_nCurrX, m_nCurrY]), c_Blue, t_Hint);
              end;
            end;
          end;
          if PlayObject.m_boFengHaoMagicEffect and (PlayObject.m_HuhuaList.Count > 0) then begin
            for I := PlayObject.m_HuhuaList.Count - 1 downto 0 do begin
              PushedObject := UserEngine.GetPlayObject(PlayObject.m_HuhuaList.Strings[I]); //检查是否在线
              if PushedObject <> nil then begin
                if (not PushedObject.m_boNotOnlineAddExp) and (not PushedObject.m_boDeath)
                  and (not PushedObject.m_boGhost) and (PushedObject.m_boFengHaoHuhua) then begin
                  PushedObject.SysMsg(Format('%s 地图【%s】坐标%d:%d', [m_sCharName, m_PEnvir.sMapDesc, m_nCurrX, m_nCurrY]), c_Blue, t_Hint);
                end;
              end;
            end;
          end;
          if PlayObject.m_boFengHaoComrade and (PlayObject.m_sDominateName <> '') then begin //主宰龙卫受攻击，提示玛法主宰者
            PushedObject := UserEngine.GetPlayObject(PlayObject.m_sDominateName); //检查是否在线
            if PushedObject <> nil then begin
              if (not PushedObject.m_boNotOnlineAddExp) and (not PushedObject.m_boDeath)
                and (not PushedObject.m_boGhost) and (PushedObject.m_boFengHaoDominate) then begin
                PushedObject.SysMsg(Format('%s 地图【%s】坐标%d:%d', [m_sCharName, m_PEnvir.sMapDesc, m_nCurrX, m_nCurrY]), c_Blue, t_Hint);
              end;
            end;
          end;
          if PlayObject.m_boFengHaoDominate and (PlayObject.m_ComradeList.Count > 0) then begin
            for I := PlayObject.m_ComradeList.Count - 1 downto 0 do begin
              PushedObject := UserEngine.GetPlayObject(PlayObject.m_ComradeList.Strings[I]); //检查是否在线
              if PushedObject <> nil then begin
                if (not PushedObject.m_boNotOnlineAddExp) and (not PushedObject.m_boDeath)
                  and (not PushedObject.m_boGhost) and (PushedObject.m_boFengHaoComrade) then begin
                  PushedObject.SysMsg(Format('%s 地图【%s】坐标%d:%d', [m_sCharName, m_PEnvir.sMapDesc, m_nCurrX, m_nCurrY]), c_Blue, t_Hint);
                end;
              end;
            end;
          end;
        end;
      end;
    end;
{$IFEND}
  except   
    MainOutMessage(format('{%s} TBaseObject.StruckDamage', [g_sExceptionVer]));
  end;
end;

function TBaseObject.GeTBaseObjectInfo(): string;
begin
  Result := m_sCharName + ' ' +
    '地图:' + m_sMapName + '(' + m_PEnvir.sMapDesc + ') ' +
    '座标:' + IntToStr(m_nCurrX) + '/' + IntToStr(m_nCurrY) + ' ' +
    '等级:' + IntToStr(m_Abil.Level) + ' ' +
    '经验:' + IntToStr(m_Abil.nExp) + ' ' +
    '生命值: ' + IntToStr(m_WAbil.HP) + '-' + IntToStr(m_WAbil.MaxHP) + ' ' +
    '魔法值: ' + IntToStr(m_WAbil.MP) + '-' + IntToStr(m_WAbil.MaxMP) + ' ' +
    '攻击力: ' + IntToStr(LoWord(m_WAbil.DC)) + '-' + IntToStr(HiWord(m_WAbil.DC)) + ' ' +
    '魔法力: ' + IntToStr(LoWord(m_WAbil.MC)) + '-' + IntToStr(HiWord(m_WAbil.MC)) + ' ' +
    '道术: ' + IntToStr(LoWord(m_WAbil.SC)) + '-' + IntToStr(HiWord(m_WAbil.SC)) + ' ' +
    '防御力: ' + IntToStr(LoWord(m_WAbil.AC)) + '-' + IntToStr(HiWord(m_WAbil.AC)) + ' ' +
    '魔防力: ' + IntToStr(LoWord(m_WAbil.MAC)) + '-' + IntToStr(HiWord(m_WAbil.MAC)) + ' ' +
    '准确:' + IntToStr(m_btHitPoint) + ' ' +
    '敏捷:' + IntToStr(m_btSpeedPoint);
end;

function TBaseObject.GetBackPosition(var nX, nY: Integer): Boolean;
var
  Envir: TEnvirnoment;
begin
  Envir := m_PEnvir;
  nX := m_nCurrX;
  nY := m_nCurrY;
  case m_btDirection of
    DR_UP {0}: if nY < (Envir.m_nHeight - 1) then Inc(nY);
    DR_DOWN {4}: if nY > 0 then Dec(nY);
    DR_LEFT {6}: if nX < (Envir.m_nWidth - 1) then Inc(nX);
    DR_RIGHT {2}: if nX > 0 then Dec(nX);
    DR_UPLEFT {西北向}: begin
        if (nX < (Envir.m_nWidth - 1)) and (nY < (Envir.m_nHeight - 1)) then begin
          Inc(nX);
          Inc(nY);
        end;
      end;
    DR_UPRIGHT {东北向}: begin
        if (nX < (Envir.m_nWidth - 1)) and (nY > 0) then begin
          Dec(nX);
          Inc(nY);
        end
      end;
    DR_DOWNLEFT {西南向}: begin
        if (nX > 0) and (nY < (Envir.m_nHeight - 1)) then begin
          Inc(nX);
          Dec(nY);
        end;
      end;
    DR_DOWNRIGHT {东南向}: begin
        if (nX > 0) and (nY > 0) then begin
          Dec(nX);
          Dec(nY);
        end;
      end;
  end;
  Result := True;
end;
//物理攻击

procedure TAnimalObject.HitMagAttackTarget(TargeTBaseObject: TBaseObject; nHitPower,
  nMagPower: Integer; boFlag: Boolean);
var
  I: Integer;
  nDamage: Integer;
  BaseObjectList: TList;
  BaseObject: TBaseObject;
begin
  m_btDirection := GetNextDirection(m_nCurrX, m_nCurrY, TargeTBaseObject.m_nCurrX, TargeTBaseObject.m_nCurrY);
  BaseObjectList := TList.Create;
  try
    m_PEnvir.GeTBaseObjects(TargeTBaseObject.m_nCurrX, TargeTBaseObject.m_nCurrY, False, BaseObjectList);
    if BaseObjectList.Count > 0 then begin //20080629
      for I := 0 to BaseObjectList.Count - 1 do begin
        BaseObject := TBaseObject(BaseObjectList.Items[I]);
        if BaseObject <> nil then begin //20090405 增加
          if IsProperTarget(BaseObject) then begin
            nDamage := 0;
            Inc(nDamage, BaseObject.GetHitStruckDamage(Self, nHitPower));
            Inc(nDamage, BaseObject.GetMagStruckDamage(Self, nMagPower, 0, 0));
            if nDamage > 0 then begin
              BaseObject.StruckDamage(nDamage);
              BaseObject.SendDelayMsg(TBaseObject(RM_STRUCK), RM_10101, nDamage, BaseObject.m_WAbil.HP, BaseObject.m_WAbil.MaxHP, Integer(Self), '', 200);
            end;
          end;
        end;
      end;
    end;
  finally
    BaseObjectList.Free;
  end;
  SendRefMsg(RM_HIT, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
end;

procedure TAnimalObject.DelTargetCreat;
begin
  inherited;
  m_nTargetX := -1;
  m_nTargetY := -1;
end;
//搜索目标

procedure TAnimalObject.SearchTarget;
var
  BaseObject, BaseObject18: TBaseObject;
  I, nC, n10: Integer;
begin
  BaseObject18 := nil;
  try
    n10 := 11; //20080803
    if m_VisibleActors.Count > 0 then begin //20081214
      for I := 0 to m_VisibleActors.Count - 1 do begin
        BaseObject := TBaseObject(pTVisibleBaseObject(m_VisibleActors.Items[I]).BaseObject);
        if BaseObject <> nil then begin
          //目标为英雄,且等级不超过22级,跟随状态,则不攻击英雄 20080421
          if (BaseObject.m_btRaceServer = RC_HEROOBJECT) and (BaseObject.m_Abil.Level <= 22) then begin //20090510 修改
            if (THEROOBJECT(BaseObject).m_btStatus = 1) then Continue;
          end;
          if not BaseObject.m_boDeath then begin
            if IsProperTarget(BaseObject) and (not BaseObject.m_boHideMode or m_boCoolEye) then begin
              nC := abs(m_nCurrX - BaseObject.m_nCurrX) + abs(m_nCurrY - BaseObject.m_nCurrY);
              if nC <= n10 then begin
                n10 := nC;
                BaseObject18 := BaseObject;
              end;
            end;
          end;
        end;
      end;
    end;
    if BaseObject18 <> nil then SetTargetCreat(BaseObject18);
  except   
    MainOutMessage(format('{%s} TAnimalObject.SearchTarget', [g_sExceptionVer]));
  end;
end;

procedure TAnimalObject.sub_4C959C;
var
  I, nC, n10: Integer;
  Creat, BaseObject: TBaseObject;
begin
  Creat := nil;
  n10 := 10 {9999}; //20080629
  if m_VisibleActors.Count > 0 then begin //20080629
    for I := 0 to m_VisibleActors.Count - 1 do begin
      BaseObject := TBaseObject(pTVisibleBaseObject(m_VisibleActors.Items[I]).BaseObject);
      if BaseObject <> nil then begin
        if BaseObject.m_boDeath then Continue;
        if IsProperTarget(BaseObject) then begin
          nC := abs(m_nCurrX - BaseObject.m_nCurrX) + abs(m_nCurrY - BaseObject.m_nCurrY);
          if nC < n10 then begin
            n10 := nC;
            Creat := BaseObject;
          end;
        end;
      end;
    end; // for
  end;
  if Creat <> nil then SetTargetCreat(Creat);
end;

procedure TAnimalObject.SetTargetXY(nX, nY: Integer);
begin
  m_nTargetX := nX;
  m_nTargetY := nY;
end;

procedure TAnimalObject.Wondering;
begin
  if (Random(20) = 0) then
    if (Random(4) = 1) then TurnTo(Random(8))
    else WalkTo(m_btDirection, False);
end;
//中毒   POISON_STONE 石化

function TBaseObject.MakePosion(nType, nTime, nPoint: Integer): Boolean;
var
  nOldCharStatus: Integer;
  nCheckCode: byte; //测试用 20080528
begin
  Result := False;
  nCheckCode := 0;
  try
    if (nType < MAX_STATUS_ATTRIBUTE) and (nType >= 0) then begin //20081203  防止组数越界
      if (m_btUnParalysis = 0) and (nType = POISON_STONE) and (m_nUnParalysisRate >= 125) then begin//麻痹免疫激活 By TasNat at: 2012-04-23 18:30:37
        //这里只管激活本次还是要被麻滴.
        case m_nUnParalysisRate of
          //0..124 :m_btUnParalysis := 0;
          125..149 :m_btUnParalysis := 4;
          150..174 :m_btUnParalysis := 5;
          175..199 :m_btUnParalysis := 6;
          200..224 :m_btUnParalysis := 7;
          225..249 :m_btUnParalysis := 8;
          250..274 :m_btUnParalysis := 9;
          else m_btUnParalysis := 10;
        end;
        //SysMsg(Format_ToStr('麻痹抗性激活！%d秒内无视麻痹.', [m_btUnParalysis]), c_Red, t_Hint);
        m_dwDecUnParalysisTick := GetTickCount;
      end;
      nCheckCode := 1;
      nOldCharStatus := m_nCharStatus;
      nCheckCode := 2;
      if m_wStatusTimeArr[nType] > 0 then begin
        if m_wStatusTimeArr[nType] < nTime then begin //20080330 修改,
          m_wStatusTimeArr[nType] := nTime;
        end;
        //m_wStatusTimeArr[nType] := m_wStatusTimeArr[nType] + nTime;//时间累加 20080330
      end else begin //004C35FF
        m_wStatusTimeArr[nType] := nTime;
      end;
      //防止和隐身戒指冲突 By TasNat at: 2012-05-16 10:10:41
      if m_wStatusTimeArr[nType] = MaxWord then
       m_wStatusTimeArr[nType] := MaxWord - 1;
      nCheckCode := 3;
      m_dwStatusArrTick[nType] := GetTickCount();
      m_nCharStatus := GetCharStatus();
      nCheckCode := 4;
      if nOldCharStatus <> m_nCharStatus then StatusChanged('');
      if m_btRaceServer = RC_PLAYOBJECT then begin
        nCheckCode := 5;
{$IF DEBUG = 1}
        if sYouPoisoned <> '' then SysMsg(Format_ToStr(sYouPoisoned {'中毒了！！！%d秒 %d点'}, [nTime, nPoint]), c_Red, t_Hint);
{$ELSE}
        case nType of //20090202 修改
          POISON_STONE: begin //石化
              SysMsg('你被石化了！', c_Red, t_Hint);
            end;
          POISON_SKILLDECHEALTH: begin //中毒类型：减血，被连击技能万剑归宗击中后掉血 20090628
            end;
          POISON_DECHEALTH: begin
              m_btGreenPoisoningPoint := nPoint;
              if sYouPoisoned <> '' then SysMsg(Format_ToStr(sYouPoisoned {中毒了！！！}, [nTime, nPoint]), c_Red, t_Hint); //20090810 修改
            end;
        else begin
            if sYouPoisoned <> '' then
              SysMsg(Format_ToStr(sYouPoisoned {中毒了！！！}, [nTime, nPoint]), c_Red, t_Hint); //20090810 修改
          end;
        end;
{$IFEND}
      end else
        if m_btRaceServer = RC_HEROOBJECT then begin //20080425 英雄中毒提示
          nCheckCode := 6;
{$IF DEBUG = 1}
          if (m_Master <> nil) and (sYouPoisoned <> '') then m_Master.SysMsg(Format_ToStr('(英雄) ' + sYouPoisoned, [nTime, nPoint]), c_Red, t_Hint);
{$ELSE}
          if m_Master <> nil then begin
            case nType of //20090202 修改
              POISON_STONE: begin
                  m_Master.SysMsg('(英雄) 你被石化了！', c_Red, t_Hint);
                end;
              POISON_SKILLDECHEALTH: begin //中毒类型：减血，被连击技能万剑归宗击中后掉血 20090628
                end;
              POISON_DECHEALTH: begin
                  m_btGreenPoisoningPoint := nPoint;
                  if sYouPoisoned <> '' then
                    m_Master.SysMsg(Format_ToStr('(英雄) ' + sYouPoisoned {中毒了！！！}, [nTime, nPoint]), c_Red, t_Hint); //20090810 修改
                end;
            else begin
                if sYouPoisoned <> '' then
                  m_Master.SysMsg(Format_ToStr('(英雄) ' + sYouPoisoned {中毒了！！！}, [nTime, nPoint]), c_Red, t_Hint); //20090810 修改
              end;
            end;
          end;
{$IFEND}
        end else begin
          case nType of
            POISON_DECHEALTH: begin
                m_btGreenPoisoningPoint := nPoint;
              end;
          end;
        end;
      Result := True;
    end else
      if (nType = 65535) and (nTime > 0) then begin //定身
        m_dwStatusArrTimeOutTick[23] := GetTickCount + nTime * 1000; //使用时间
        m_wStatusArrValue[23] := nTime;
        m_nCharStatus := GetCharStatus();
        StatusChanged('');
        Result := True;
      end;
  except   
    MainOutMessage(format('{%s} TBaseObject.MakePosion Code:%d', [g_sExceptionVer, nCheckCode]));
  end;
end;

//中蛛网，不能跑动 20080811

function TBaseObject.MakeSpiderMag(nTime: Integer): Boolean;
var
  nOldCharStatus: Integer;
begin
  Result := False;
  if m_wStatusTimeArr[STATE_LOCKRUN] <> 0 then Exit;
  nOldCharStatus := m_nCharStatus;
  m_wStatusTimeArr[STATE_LOCKRUN] := nTime; //持继多少久(秒)
  m_dwStatusArrTick[STATE_LOCKRUN] := GetTickCount(); //人物状态持续的开始时间
  m_nCharStatus := GetCharStatus();
  if nOldCharStatus <> m_nCharStatus then StatusChanged('');
  if m_btRaceServer = RC_PLAYOBJECT then begin
    TPlayObject(self).m_boCanRun := False; //是否允许跑
    SysMsg(sYouPoisonedSpider, c_Red, t_Hint); //中蛛网提示
  end else
    if m_btRaceServer = RC_HEROOBJECT then begin
      THeroObject(self).m_boCanRun := False; //是否允许跑
      if (m_Master <> nil) and (sYouPoisonedSpider <> '') then m_Master.SysMsg('(英雄) ' + sYouPoisonedSpider, c_Red, t_Hint); //中蛛网提示
    end;
  Result := True;
end;
//目标的防御和魔防减到0，并且效果持续10秒

function TBaseObject.MakeSkill102Mag(nTime: Integer): Boolean;
var
  nOldCharStatus: Integer;
begin
  Result := False;
  if m_wStatusTimeArr[POISON_LOCK1] <> 0 then Exit;
  nOldCharStatus := m_nCharStatus;
  m_wStatusTimeArr[POISON_LOCK1] := nTime; //持继多少久(秒)
  m_dwStatusArrTick[POISON_LOCK1] := GetTickCount(); //人物状态持续的开始时间
  m_nCharStatus := GetCharStatus();
  if nOldCharStatus <> m_nCharStatus then StatusChanged('');
  case m_btRaceServer of
    RC_PLAYOBJECT: begin
        SysMsg(Format_toStr(g_sSkill102Time, [nTime]), c_Red, t_Hint);
        RecalcAbilitys();
        CompareSuitItem(False); //套装与身上装备对比
        SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
      end;
    RC_HEROOBJECT: begin
        if m_Master <> nil then m_Master.SysMsg(Format_toStr('(英雄) ' + g_sSkill102Time, [nTime]), c_Red, t_Hint);
        THeroObject(self).RecalcAbilitys();
        CompareSuitItem(False); //套装与身上装备对比
        THeroObject(self).SendMsg(self, RM_HEROABILITY, 0, 0, 0, 0, ''); //发送英雄属性
      end;
  end;
  Result := True;
end;
//被冰冻，不能走，不能跑，不能使用魔法，不能攻击

function TBaseObject.MakeFreezeMag(nTime: Integer): Boolean;
var
  nOldCharStatus: Integer;
begin
  Result := False;
  if m_wStatusTimeArr[POISON_LOCKSPELL] <> 0 then Exit;
  nOldCharStatus := m_nCharStatus;
  m_wStatusTimeArr[POISON_LOCKSPELL] := nTime; //持继多少久(秒)
  m_dwStatusArrTick[POISON_LOCKSPELL] := GetTickCount(); //人物状态持续的开始时间
  m_nCharStatus := GetCharStatus();
  if nOldCharStatus <> m_nCharStatus then StatusChanged('');
  case m_btRaceServer of
    RC_PLAYOBJECT: SysMsg(sYouPoisonedFreeze, c_Red, t_Hint); //被冰冻提示
    RC_HEROOBJECT: if (m_Master <> nil) and (sYouPoisonedFreeze <> '') then m_Master.SysMsg('(英雄) ' + sYouPoisonedFreeze, c_Red, t_Hint); //被冰冻提示
  end;
  Result := True;
end;

function TBaseObject.sub_4DD704: Boolean;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  Result := False;
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    if m_MsgList.Count > 0 then begin
      for I := 0 to m_MsgList.Count - 1 do begin
        SendMessage := m_MsgList.Items[I];
        if (SendMessage <> nil) and (SendMessage.wIdent = RM_10401) then begin
          Result := True;
          Break;
        end;
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;
//发送存在普通仓库里的物品

procedure TPlayObject.SendSaveItemList(nBaseObject: Integer);
var
  I: Integer;
  Item: pTStdItem;
  sSENDMSG: string;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  StdItem: TStdItem;
  UserItem: pTUserItem;
  sUserItemName: string;
begin
  if m_boNotOnlineAddExp or m_boAI then Exit;
  if m_nSoftVersionDateEx = 0 then begin
    sSENDMSG := '';
    if m_StorageItemList.Count > 0 then begin //20080629
      for I := 0 to m_StorageItemList.Count - 1 do begin
        UserItem := m_StorageItemList.Items[I];
        Item := UserEngine.GetStdItem(UserItem.wIndex);
        if Item <> nil then begin
          StdItem := Item^;
          ItemUnit.GetItemAddValue(UserItem, StdItem);
          CopyStdItemToOStdItem(@StdItem, @OClientItem.s);
          //取自定义物品名称
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sUserItemName <> '' then
            OClientItem.s.Name := sUserItemName;
          OClientItem.Dura := UserItem.Dura;
          OClientItem.DuraMax := UserItem.DuraMax;
          OClientItem.MakeIndex := UserItem.MakeIndex;
          sSENDMSG := sSENDMSG + EncodeBuffer(@OClientItem, SizeOf(TOClientItem)) + '/';
        end;
      end; //for
    end;
    m_DefMsg := MakeDefaultMsg(SM_SAVEITEMLIST, nBaseObject, 0, 0, m_StorageItemList.Count, 0);
    SendSocket(@m_DefMsg, sSENDMSG);
  end else begin
    sSENDMSG := '';
    if m_StorageItemList.Count > 0 then begin //20080629
      for I := 0 to m_StorageItemList.Count - 1 do begin
        UserItem := m_StorageItemList.Items[I];
        if (UserItem.AddValue[0] = 1) and (GetHoursCount(UserItem.MaxDate, Now) <= 0) then Continue; //删除到期装备
        if (UserItem.AddValue[0] = 2) and (GetHoursCount(UserItem.MaxDate, Now) <= 0) then UserItem.AddValue[0] := 0; //绑定48时到期恢复正常
        Item := UserEngine.GetStdItem(UserItem.wIndex);
        if Item <> nil then begin
          StdItem := Item^;
          ItemUnit.GetItemAddValue(UserItem, StdItem);
          Move(StdItem, ClientItem.s, SizeOf(TStdItem));
          //取自定义物品名称
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sUserItemName <> '' then ClientItem.s.Name := sUserItemName;

          if (UserItem.btValue[12] = 1) and (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) then ClientItem.s.Reserved1 := 1 //物品发光 20080708
          else ClientItem.s.Reserved1 := 0;

          case StdItem.StdMode of //20090816
{$IF M2Version <> 2}
            5, 6: begin
                ClientItem.s.NeedIdentify := _MIN(High(Byte), UserItem.btValue[11] + UserItem.btValue[20]); //武器暴击等级 20100708
                if CheckItemSpiritMedia(UserItem) then begin
                  ClientItem.Aura := UserItem.btValue[12];
                  ClientItem.MaxAura := g_Config.nMaxAuraValue;
                end;
              end;
            10, 11, 15, 16, 19..24, 26..30, 52, 54, 55, 62, 64: begin
                if CheckItemSpiritMedia(UserItem) then begin
                  ClientItem.Aura := UserItem.btValue[11];
                  ClientItem.MaxAura := g_Config.nMaxAuraValue;
                end;
              end;
            44: begin
                if StdItem.Shape = 255 then ClientItem.s.NeedIdentify := UserItem.btValue[0];
                if StdItem.Shape = 253 then begin //除魔灵媒
                  ClientItem.Aura := UserItem.btValue[11];
                  ClientItem.MaxAura := g_Config.nMaxAuraValue;
                end;
              end;
{$IFEND}
            8: if UserItem.btValue[0] <> 0 then ClientItem.s.AC := UserItem.btValue[0]; //材料的品质
            17: if StdItem.Weight > 0 then ClientItem.s.Weight := UserItem.Dura; //拆加物品的重量 20090816
            60: begin
                if (StdItem.shape <> 0) then begin //酒类,除烧酒外 20080708
                  if UserItem.btValue[0] <> 0 then ClientItem.s.AC := UserItem.btValue[0]; //酒的品质
                  if UserItem.btValue[1] <> 0 then ClientItem.s.MAC := UserItem.btValue[1]; //酒的酒精度
                  if UserItem.btValue[3] > 0 then ClientItem.s.NeedLevel := UserItem.btValue[3] //酒的等级 20091117
                  else ClientItem.s.NeedLevel := 0;
                end;
              end;
          end;
          ClientItem.Dura := UserItem.Dura;
          ClientItem.DuraMax := UserItem.DuraMax;
          ClientItem.MakeIndex := UserItem.MakeIndex;
          //Modified By TasNat at: 2012-04-12 09:28:18
          ClientItem.btAppraisalLevel := UserItem.btAppraisalLevel;
          ClientItem.btUnKnowValueCount := UserItem.btUnKnowValueCount;
          Move(UserItem.btAppraisalValue, ClientItem.btAppraisalValue, SizeOf(ClientItem.btAppraisalValue));

          Move(UserItem.btUnKnowValue, ClientItem.btUnKnowValue, SizeOf(ClientItem.btUnKnowValue)); //20100822
          ClientItem.BindValue := UserItem.AddValue[0]; //20110622
          ClientItem.MaxDate := UserItem.MaxDate; //20110622
          if ClientItem.BindValue = 0 then begin //禁止交易,扔物品,显示绑定 20110626
            if (CheckItemValue(UserItem, 1) and CheckItemValue(UserItem, 0)) or
              (GetCheckItemList(0, StdItem.Name) and GetCheckItemList(1, StdItem.Name)) then
              ClientItem.BindValue := 3;
          end;
          sSENDMSG := sSENDMSG + EncodeBuffer(@ClientItem, SizeOf(ClientItem)) + '/';
        end;
      end; //for
    end;
    m_DefMsg := MakeDefaultMsg(SM_SAVEITEMLIST, nBaseObject, 0, 0, m_StorageItemList.Count, 0);
    SendSocket(@m_DefMsg, sSENDMSG);
  end;
end;
//发送保存到无限仓库的物品

procedure TPlayObject.SendSaveBigStorageItemList(nBaseObject: Integer; nPage: Integer);
var
  I: Integer;
  Item: pTStdItem;
  sSENDMSG: string;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  StdItem: TStdItem;
  sUserItemName: string;
  BigStorage: pTBigStorage;
  nCount: Integer;
  nIndex: Integer;
  function GetPageCount(nListCount: Integer): Integer;
  begin
    Result := 0;
    if nListCount > 0 then begin
      Result := nListCount div 50;
      if (nListCount mod 50) > 0 then Inc(Result);
    end;
  end;
begin
  if m_boNotOnlineAddExp or m_boAI then Exit;
  if m_nSoftVersionDateEx = 0 then begin
    sSENDMSG := '';
    nCount := 0;
    nIndex := 0; //20080522
    if m_BigStorageItemList <> nil then begin
      if nPage = 0 then nIndex := 0;
      if nPage > 0 then nIndex := nPage * 50;
      if nIndex > m_BigStorageItemList.Count - 1 then begin
        m_nBigStoragePage := GetPageCount(m_BigStorageItemList.Count);
        Exit;
      end;
      for I := nIndex to m_BigStorageItemList.Count - 1 do begin
        BigStorage := m_BigStorageItemList.Items[I];
        Item := UserEngine.GetStdItem(BigStorage.UseItems.wIndex);
        if Item <> nil then begin
          Inc(nCount);
          StdItem := Item^;
          ItemUnit.GetItemAddValue(@BigStorage.UseItems, StdItem);
          CopyStdItemToOStdItem(@StdItem, @OClientItem.s);
          //取自定义物品名称
          sUserItemName := '';
          if BigStorage.UseItems.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(BigStorage.UseItems.MakeIndex, BigStorage.UseItems.wIndex);
          if sUserItemName <> '' then
            OClientItem.s.Name := sUserItemName;
          OClientItem.Dura := BigStorage.UseItems.Dura;
          OClientItem.DuraMax := BigStorage.UseItems.DuraMax;
          OClientItem.MakeIndex := BigStorage.UseItems.MakeIndex;
          sSENDMSG := sSENDMSG + EncodeBuffer(@OClientItem, SizeOf(TOClientItem)) + '/';
          if nCount >= 50 then Break;
        end;
      end;
    end;
    m_DefMsg := MakeDefaultMsg(SM_SAVEITEMLIST, nBaseObject, 0, 0, nCount, 0);
    SendSocket(@m_DefMsg, sSENDMSG);
  end else begin
    sSENDMSG := '';
    nCount := 0;
    nIndex := 0; //20080522
    if m_BigStorageItemList <> nil then begin
      if nPage = 0 then nIndex := 0;
      if nPage > 0 then nIndex := nPage * 50;
      if nIndex > m_BigStorageItemList.Count - 1 then begin
        m_nBigStoragePage := GetPageCount(m_BigStorageItemList.Count);
        Exit;
      end;
      for I := nIndex to m_BigStorageItemList.Count - 1 do begin
        BigStorage := m_BigStorageItemList.Items[I];
        if (BigStorage.UseItems.AddValue[0] = 1) and (GetHoursCount(BigStorage.UseItems.MaxDate, Now) <= 0) then Continue; //删除到期装备
        if (BigStorage.UseItems.AddValue[0] = 2) and (GetHoursCount(BigStorage.UseItems.MaxDate, Now) <= 0) then BigStorage.UseItems.AddValue[0] := 0;
        Item := UserEngine.GetStdItem(BigStorage.UseItems.wIndex);
        if Item <> nil then begin
          Inc(nCount);
          StdItem := Item^;
          ItemUnit.GetItemAddValue(@BigStorage.UseItems, StdItem);
          Move(StdItem, ClientItem.s, SizeOf(TStdItem));
          //取自定义物品名称
          sUserItemName := '';
          if BigStorage.UseItems.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(BigStorage.UseItems.MakeIndex, BigStorage.UseItems.wIndex);
          if sUserItemName <> '' then ClientItem.s.Name := sUserItemName;

          if (BigStorage.UseItems.btValue[12] = 1) and (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) then ClientItem.s.Reserved1 := 1 //物品发光 20080708
          else ClientItem.s.Reserved1 := 0;

          case StdItem.StdMode of //20090816
{$IF M2Version <> 2}
            5, 6: begin
                ClientItem.s.NeedIdentify := _MIN(High(Byte), BigStorage.UseItems.btValue[11] + BigStorage.UseItems.btValue[20]); //武器暴击等级
                if CheckItemSpiritMedia(BigStorage.UseItems) then begin
                  ClientItem.Aura := BigStorage.UseItems.btValue[12];
                  ClientItem.MaxAura := g_Config.nMaxAuraValue;
                end;
              end;
            10, 11, 15, 16, 19..24, 26..30, 52, 54, 55, 62, 64: begin
                if CheckItemSpiritMedia(BigStorage.UseItems) then begin
                  ClientItem.Aura := BigStorage.UseItems.btValue[11];
                  ClientItem.MaxAura := g_Config.nMaxAuraValue;
                end;
              end;
            44: begin
                if StdItem.Shape = 255 then ClientItem.s.NeedIdentify := BigStorage.UseItems.btValue[0];
                if StdItem.Shape = 253 then begin //除魔灵媒
                  ClientItem.Aura := BigStorage.UseItems.btValue[11];
                  ClientItem.MaxAura := g_Config.nMaxAuraValue;
                end;
              end;
{$IFEND}
            8: if BigStorage.UseItems.btValue[0] <> 0 then ClientItem.s.AC := BigStorage.UseItems.btValue[0]; //材料的品质
            17: if StdItem.Weight > 0 then ClientItem.s.Weight := BigStorage.UseItems.Dura; //拆加物品的重量 20090816
            60: begin
                if (StdItem.shape <> 0) then begin //酒类,除烧酒外 20080708
                  if BigStorage.UseItems.btValue[0] <> 0 then ClientItem.s.AC := BigStorage.UseItems.btValue[0]; //酒的品质
                  if BigStorage.UseItems.btValue[1] <> 0 then ClientItem.s.MAC := BigStorage.UseItems.btValue[1]; //酒的酒精度
                  if BigStorage.UseItems.btValue[3] > 0 then ClientItem.s.NeedLevel := BigStorage.UseItems.btValue[3] //酒等级
                  else ClientItem.s.NeedLevel := 0;
                end;
              end;
          end;

          ClientItem.Dura := BigStorage.UseItems.Dura;
          ClientItem.DuraMax := BigStorage.UseItems.DuraMax;
          ClientItem.MakeIndex := BigStorage.UseItems.MakeIndex;
          //Modified By TasNat at: 2012-04-12 09:28:18
          ClientItem.btAppraisalLevel :=  BigStorage.UseItems.btAppraisalLevel;
          ClientItem.btUnKnowValueCount := BigStorage.UseItems.btUnKnowValueCount;
          Move(BigStorage.UseItems.btAppraisalValue, ClientItem.btAppraisalValue, SizeOf(ClientItem.btAppraisalValue));

          Move(BigStorage.UseItems.btUnKnowValue, ClientItem.btUnKnowValue, SizeOf(ClientItem.btUnKnowValue)); //20100822
          ClientItem.BindValue := BigStorage.UseItems.AddValue[0]; //20110622
          ClientItem.MaxDate := BigStorage.UseItems.MaxDate; //20110622
          if ClientItem.BindValue = 0 then begin //禁止交易,扔物品,显示绑定 20110626
            if (CheckItemValue(@BigStorage.UseItems, 1) and CheckItemValue(@BigStorage.UseItems, 0)) or
              (GetCheckItemList(0, StdItem.Name) and GetCheckItemList(1, StdItem.Name)) then
              ClientItem.BindValue := 3;
          end;
          sSENDMSG := sSENDMSG + EncodeBuffer(@ClientItem, SizeOf(ClientItem)) + '/';
          if nCount >= 50 then Break;
        end;
      end;
    end;
    m_DefMsg := MakeDefaultMsg(SM_SAVEITEMLIST, nBaseObject, 0, 0, nCount, 0);
    SendSocket(@m_DefMsg, sSENDMSG);
  end;
end;

procedure TPlayObject.SendChangeGuildName;
begin
  if m_boNotOnlineAddExp or m_boAI then Exit;
  if m_MyGuild <> nil then begin
    SendDefMessage(SM_CHANGEGUILDNAME, 0, 0, 0, 0, TGUild(m_MyGuild).sGuildName + '/' + m_sGuildRankName);
  end else begin
    SendDefMessage(SM_CHANGEGUILDNAME, 0, 0, 0, 0, '');
  end;
end;

procedure TPlayObject.SendDelItemList(ItemList: TStringList);
var
  I: Integer;
  s10: string;
begin
  if m_boNotOnlineAddExp or m_boAI then Exit;
  s10 := '';
  if ItemList.Count > 0 then begin
    for I := 0 to ItemList.Count - 1 do begin
      s10 := s10 + ItemList.Strings[I] + '/' + IntToStr(Integer(ItemList.Objects[I])) + '/';
    end;
  end;
  m_DefMsg := MakeDefaultMsg(SM_DELITEMS, 0, 0, 0, ItemList.Count, 0);
  SendSocket(@m_DefMsg, EncodeString(s10));
end;
//发送删除身上装备物品

procedure TPlayObject.SendDelItems(UserItem: pTUserItem);
var
  StdItem: pTStdItem;
  StdItem80: TStdItem;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  sUserItemName: string;
begin
  if m_boNotOnlineAddExp or m_boAI then Exit;
  if (m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0) then begin
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then begin
      StdItem80 := StdItem^;
      ItemUnit.GetItemAddValue(@UserItem, StdItem80);
      CopyStdItemToOStdItem(@StdItem80, @OClientItem.s);

      //取自定义物品名称
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        OClientItem.s.Name := sUserItemName;

      OClientItem.MakeIndex := UserItem.MakeIndex;
      OClientItem.Dura := UserItem.Dura;
      OClientItem.DuraMax := UserItem.DuraMax;
      m_DefMsg := MakeDefaultMsg(SM_DELITEM, Integer(Self), 0, 0, 1, 0);
      SendSocket(@m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
    end;
  end else begin
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then begin
      StdItem80 := StdItem^;
      ItemUnit.GetItemAddValue(@UserItem, StdItem80);
      Move(StdItem80, ClientItem.s, SizeOf(TStdItem));
      //取自定义物品名称
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        ClientItem.s.Name := sUserItemName;
      if (UserItem.btValue[12] = 1) and (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) then ClientItem.s.Reserved1 := 1 //物品发光 20080224
      else ClientItem.s.Reserved1 := 0;
{$IF M2Version <> 2}
      if (StdItem.StdMode = 5) or (StdItem.StdMode = 6) then begin //武器暴击等级 20100708
        ClientItem.s.NeedIdentify := _MIN(High(Byte), UserItem.btValue[11] + UserItem.btValue[20]);
        if CheckItemSpiritMedia(UserItem) then begin
          ClientItem.Aura := UserItem.btValue[12];
          ClientItem.MaxAura := g_Config.nMaxAuraValue;
        end;
      end else begin
        if CheckItemSpiritMedia(UserItem) or ((StdItem.StdMode = 44) and (StdItem.shape = 253)) then begin
          ClientItem.Aura := UserItem.btValue[11];
          ClientItem.MaxAura := g_Config.nMaxAuraValue;
        end;
      end;
      if (StdItem.StdMode = 44) and (StdItem.shape = 255) then begin //神秘卷轴
        ClientItem.s.NeedIdentify := UserItem.btValue[0];
      end;
{$IFEND}
      if (StdItem.StdMode = 60) and (StdItem.shape <> 0) then begin //酒类,除烧酒外 20080622
        if UserItem.btValue[0] <> 0 then ClientItem.s.AC := UserItem.btValue[0]; //酒的品质
        if UserItem.btValue[1] <> 0 then ClientItem.s.MAC := UserItem.btValue[1]; //酒的酒精度
        if UserItem.btValue[3] > 0 then ClientItem.s.NeedLevel := UserItem.btValue[3] //酒的等级 20091117
        else ClientItem.s.NeedLevel := 0;
      end;

      ClientItem.MakeIndex := UserItem.MakeIndex;
      ClientItem.Dura := UserItem.Dura;
      ClientItem.DuraMax := UserItem.DuraMax;
      //Modified By TasNat at: 2012-04-12 09:28:18
      ClientItem.btAppraisalLevel :=  UserItem.btAppraisalLevel;
      ClientItem.btUnKnowValueCount :=UserItem.btUnKnowValueCount;
      Move(UserItem.btAppraisalValue, UserItem.btAppraisalValue, SizeOf(UserItem.btAppraisalValue));

      Move(UserItem.btUnKnowValue, ClientItem.btUnKnowValue, SizeOf(ClientItem.btUnKnowValue)); //20100822
      m_DefMsg := MakeDefaultMsg(SM_DELITEM, Integer(Self), 0, 0, 1, 0);
      SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(ClientItem)));
    end;
  end;
end;

procedure TPlayObject.SendUpdateItem(UserItem: pTUserItem);
var
  StdItem: pTStdItem;
  StdItem80: TStdItem;
  ClientItem: TClientItem;
  EffecItem: pTEffecItem;
  OClientItem: TOClientItem;
  sUserItemName: string;
begin
  if m_boNotOnlineAddExp or m_boAI then Exit;
  if (m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0) then begin
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then begin
      StdItem80 := StdItem^;
      ItemUnit.GetItemAddValue(UserItem, StdItem80);
      //Move(StdItem80,ClientItem.S,SizeOf(TStdItem));
      CopyStdItemToOStdItem(@StdItem80, @OClientItem.s);

      //取自定义物品名称
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        OClientItem.s.Name := sUserItemName;
      OClientItem.MakeIndex := UserItem.MakeIndex;
      OClientItem.Dura := UserItem.Dura;
      OClientItem.DuraMax := UserItem.DuraMax;
      {if StdItem.StdMode = 50 then begin //20080808 注释
        OClientItem.s.Name := ClientItem.s.Name + ' #' + IntToStr(UserItem.Dura);
      end;}
      m_DefMsg := MakeDefaultMsg(SM_UPDATEITEM, Integer(Self), 0, 0, 1, 0);
      SendSocket(@m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
    end;
  end else begin
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then begin
      FillChar(ClientItem, SizeOf(ClientItem), #0);
      StdItem80 := StdItem^;
      ItemUnit.GetItemAddValue(UserItem, StdItem80);
      ClientItem.s := StdItem80;
      //取特效配置
      {By TasNat at: 2012-11-22 11:14:36
      EffecItem := GetEffecItemList(StdItem.Name); //取物品特效
      if EffecItem <> nil then begin
        Move(EffecItem^, ClientItem.ClientEffec, SizeOf(TEffecItem));
      end;}
      //取自定义物品名称
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then ClientItem.s.Name := sUserItemName;
      if (UserItem.btValue[12] = 1) and (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) then ClientItem.s.Reserved1 := 1 //物品发光 20080223
      else ClientItem.s.Reserved1 := 0;
{$IF M2Version <> 2}
      if (StdItem.StdMode = 5) or (StdItem.StdMode = 6) then begin //武器暴击等级 20100708
        ClientItem.s.NeedIdentify := _MIN(High(Byte), UserItem.btValue[11] + UserItem.btValue[20]);
        if CheckItemSpiritMedia(UserItem) then begin
          ClientItem.Aura := UserItem.btValue[12];
          ClientItem.MaxAura := g_Config.nMaxAuraValue;
        end;
      end else begin
        if CheckItemSpiritMedia(UserItem) or ((StdItem.StdMode = 44) and (StdItem.shape = 253)) then begin
          ClientItem.Aura := UserItem.btValue[11];
          ClientItem.MaxAura := g_Config.nMaxAuraValue;
        end;
      end;
      if (StdItem.StdMode = 44) and (StdItem.shape = 255) then begin //神秘卷轴
        ClientItem.s.NeedIdentify := UserItem.btValue[0];
      end;
{$IFEND}
      if (StdItem.StdMode = 60) and (StdItem.shape <> 0) then begin //酒类,除烧酒外 20080622
        if UserItem.btValue[0] <> 0 then ClientItem.s.AC := UserItem.btValue[0]; //酒的品质
        if UserItem.btValue[1] <> 0 then ClientItem.s.MAC := UserItem.btValue[1]; //酒的酒精度
        if UserItem.btValue[3] > 0 then ClientItem.s.NeedLevel := UserItem.btValue[3] //酒的等级 20091117
        else ClientItem.s.NeedLevel := 0;
      end;
      if (StdItem.StdMode = 17) and (StdItem.Weight > 0) then ClientItem.s.Weight := UserItem.Dura; //拆加物品的重量 20090816

      ClientItem.MakeIndex := UserItem.MakeIndex;
      ClientItem.Dura := UserItem.Dura;
      ClientItem.DuraMax := UserItem.DuraMax;
      Move(UserItem.btValue, ClientItem.btValue, SizeOf(ClientItem.btValue)); //20100822
      //Modified By TasNat at: 2012-04-12 09:28:18
      ClientItem.btAppraisalLevel :=  UserItem.btAppraisalLevel;
      ClientItem.btUnKnowValueCount := UserItem.btUnKnowValueCount;
      Move(UserItem.btAppraisalValue,ClientItem.btAppraisalValue, SizeOf(UserItem.btAppraisalValue));

      Move(UserItem.btUnKnowValue, ClientItem.btUnKnowValue, SizeOf(ClientItem.btUnKnowValue)); //20100822
      ClientItem.BindValue := UserItem.AddValue[0]; //20110622
      ClientItem.MaxDate := UserItem.MaxDate; //20110622
      if ClientItem.BindValue = 0 then begin //禁止交易,扔物品,显示绑定 20110626
        if (CheckItemValue(UserItem, 1) and CheckItemValue(UserItem, 0)) or
          (GetCheckItemList(0, StdItem.Name) and GetCheckItemList(1, StdItem.Name)) then
          ClientItem.BindValue := 3;
      end;
      m_DefMsg := MakeDefaultMsg(SM_UPDATEITEM, Integer(Self), 0, 0, 1, 0);
      SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(ClientItem)));
    end;
  end;
end;

//检查装备是否可以穿上身

function TPlayObject.CheckTakeOnItems(nWhere: Integer; var StdItem: TStdItem): Boolean; //004C5084
var
  Castle: TUserCastle;
begin
  Result := False;
  if (StdItem.StdMode = 10) and (m_btGender <> 0) then begin
    SysMsg(sWearNotOfWoMan, c_Red, t_Hint);
    Exit;
  end;
  if (StdItem.StdMode = 11) and (m_btGender <> 1) then begin
    SysMsg(sWearNotOfMan, c_Red, t_Hint);
    Exit;
  end;
  if (nWhere = 1) or (nWhere = 2) then begin
    if StdItem.Weight > m_WAbil.MaxHandWeight then begin //腕力不足
      SysMsg(sHandWeightNot, c_Red, t_Hint);
      Exit;
    end;
  end else begin
    if (StdItem.Weight + GetUserItemWeitht(nWhere)) > m_WAbil.MaxWearWeight then begin
      SysMsg(sWearWeightNot, c_Red, t_Hint); //负重不足
      Exit;
    end;
  end;
  Castle := g_CastleManager.IsCastleMember(Self);
  case StdItem.Need of
    0, 18, 22, 26, 30, 34, 45, 49, 65, 71, 91: begin //0-等级  18-需等级，装备可提搞内力恢复速度%(金牛套装) 26-需等级，装备(Stock)可增加防爆属性 30-需等级，装备(Stock)可增加吸血属性 34-需等级，减内力 45-需等级，防麻机率 49-武器暴击，需等级 65-目标爆率
        if m_Abil.Level >= StdItem.NeedLevel then begin
          Result := True;
        end else begin
          SysMsg(g_sLevelNot, c_Red, t_Hint);
        end;
      end;
    1, 19, 23, 27, 31, 35, 46, 50, 66, 72, 92: begin //攻击力  19-需攻击力，装备可提搞内力恢复速度%   27-需攻击力，装备(Stock)可增加防爆属性 31-需攻击力，装备(Stock)可增加吸血属性 35-需攻，减内力 46-需攻，防麻机率 50-武器暴击，需攻击 66-目标爆率
        if HiWord(m_WAbil.DC) >= StdItem.NeedLevel then begin
          Result := True;
        end else begin
          SysMsg(g_sDCNot, c_Red, t_Hint);
        end;
      end;
    2, 20, 24, 28, 32, 36, 47, 51, 67, 73, 93: begin //魔法力  20-需魔法力，装备可提搞内力恢复速度%  28-需魔法，装备(Stock)可增加防爆属性 32-需魔法，装备(Stock)可增加吸血属性  36-需魔法，减内力 47-需魔法，防麻机率 51-武器暴击，需魔法 67-目标爆率
        if HiWord(m_WAbil.MC) >= StdItem.NeedLevel then begin
          Result := True;
        end else begin
          SysMsg(g_sMCNot, c_Red, t_Hint);
        end;
      end;
    3, 21, 25, 29, 33, 37, 48, 52, 68, 74, 94: begin //道术  21-需道术，装备可提搞内力恢复速度%  29-需道术，装备(Stock)可增加防爆属性 33-需道术，装备(Stock)可增加吸血属性  37-需道术，减内力  48-需道术，防麻机率  52-武器暴击，需道术 68-目标爆率
        if HiWord(m_WAbil.SC) >= StdItem.NeedLevel then begin
          Result := True;
        end else begin
          SysMsg(g_sSCNot, c_Red, t_Hint);
        end;
      end;
    4: begin //转生等级
        if m_btReLevel >= StdItem.NeedLevel then begin
          Result := True;
        end else begin
          SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
        end;
      end;
    5: begin //所需声望
        if m_btCreditPoint >= StdItem.NeedLevel then begin
          Result := True;
        end else begin
          SysMsg(g_sCreditPointNot, c_Red, t_Hint);
        end;
      end;
    6: begin //行会物品
        if (m_MyGuild <> nil) then begin
          Result := True;
        end else begin
          SysMsg(g_sGuildNot, c_Red, t_Hint);
        end;
      end;
    7: begin //沙城成员物品
        if (m_MyGuild <> nil) and (Castle <> nil) then begin
          Result := True;
        end else begin
          SysMsg(g_sSabukHumanNot, c_Red, t_Hint);
        end;
      end;
    8: begin //会员物品
        if m_nMemberType <> 0 then begin
          Result := True;
        end else begin
          SysMsg(g_sMemberNot, c_Red, t_Hint);
        end;
      end;
    10: begin //职业+等级
        if (m_btJob = LoWord(StdItem.NeedLevel)) and (m_Abil.Level >= HiWord(StdItem.NeedLevel)) then begin
          Result := True;
        end else begin
          SysMsg(g_sJobOrLevelNot, c_Red, t_Hint);
        end;
      end;
    11: begin //职业+攻击力
        if (m_btJob = LoWord(StdItem.NeedLevel)) and (HiWord(m_WAbil.DC) >= HiWord(StdItem.NeedLevel)) then begin
          Result := True;
        end else begin
          SysMsg(g_sJobOrDCNot, c_Red, t_Hint);
        end;
      end;
    12: begin //职业+魔法力
        if (m_btJob = LoWord(StdItem.NeedLevel)) and (HiWord(m_WAbil.MC) >= HiWord(StdItem.NeedLevel)) then begin
          Result := True;
        end else begin
          SysMsg(g_sJobOrMCNot, c_Red, t_Hint);
        end;
      end;
    13: begin //职业+道术
        if (m_btJob = LoWord(StdItem.NeedLevel)) and (HiWord(m_WAbil.SC) >= HiWord(StdItem.NeedLevel)) then begin
          Result := True;
        end else begin
          SysMsg(g_sJobOrSCNot, c_Red, t_Hint);
        end;
      end;
    14: begin //等级+声望(隐藏条件)  20090305
        if (m_Abil.Level >= HiWord(StdItem.NeedLevel)) and (m_btCreditPoint >= StdItem.Stock) then begin
          Result := True;
        end else begin
          if (m_Abil.Level < HiWord(StdItem.NeedLevel)) then begin //等级不足
            SysMsg(g_sLevelNot, c_Red, t_Hint);
          end else
            if (m_btCreditPoint < StdItem.Stock) then begin //声望不足
              SysMsg(g_sCreditPointNot, c_Red, t_Hint);
            end;
        end;
      end;
    15: begin //攻击+声望(隐藏条件)  20090305
        if (HiWord(m_WAbil.DC) >= StdItem.NeedLevel) and (m_btCreditPoint >= StdItem.Stock) then begin
          Result := True;
        end else begin
          if (HiWord(m_WAbil.DC) < HiWord(StdItem.NeedLevel)) then begin //攻击不足
            SysMsg(g_sDCNot, c_Red, t_Hint);
          end else
            if (m_btCreditPoint < StdItem.Stock) then begin //声望不足
              SysMsg(g_sCreditPointNot, c_Red, t_Hint);
            end;
        end;
      end;
    16: begin //魔法+声望(隐藏条件)  20090305
        if (HiWord(m_WAbil.MC) >= StdItem.NeedLevel) and (m_btCreditPoint >= StdItem.Stock) then begin
          Result := True;
        end else begin
          if (HiWord(m_WAbil.MC) < HiWord(StdItem.NeedLevel)) then begin //魔法不足
            SysMsg(g_sMCNot, c_Red, t_Hint);
          end else
            if (m_btCreditPoint < StdItem.Stock) then begin //声望不足
              SysMsg(g_sCreditPointNot, c_Red, t_Hint);
            end;
        end;
      end;
    17: begin //道术+声望(隐藏条件)  20090305
        if (HiWord(m_WAbil.SC) >= StdItem.NeedLevel) and (m_btCreditPoint >= StdItem.Stock) then begin
          Result := True;
        end else begin
          if (HiWord(m_WAbil.SC) < HiWord(StdItem.NeedLevel)) then begin //道术不足
            SysMsg(g_sSCNot, c_Red, t_Hint);
          end else
            if (m_btCreditPoint < StdItem.Stock) then begin //声望不足
              SysMsg(g_sCreditPointNot, c_Red, t_Hint);
            end;
        end;
      end;
    40: begin //转生等级+等级
        if m_btReLevel >= LoWord(StdItem.NeedLevel) then begin
          if m_Abil.Level >= HiWord(StdItem.NeedLevel) then begin
            Result := True;
          end else begin
            SysMsg(g_sLevelNot, c_Red, t_Hint);
          end;
        end else begin
          SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
        end;
      end;
    41: begin //转生等级+攻击力
        if m_btReLevel >= LoWord(StdItem.NeedLevel) then begin
          if HiWord(m_WAbil.DC) >= HiWord(StdItem.NeedLevel) then begin
            Result := True;
          end else begin
            SysMsg(g_sDCNot, c_Red, t_Hint);
          end;
        end else begin
          SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
        end;
      end;
    42: begin //转生等级+魔法
        if m_btReLevel >= LoWord(StdItem.NeedLevel) then begin
          if HiWord(m_WAbil.MC) >= HiWord(StdItem.NeedLevel) then begin
            Result := True;
          end else begin
            SysMsg(g_sMCNot, c_Red, t_Hint);
          end;
        end else begin
          SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
        end;
      end;
    43: begin //转生等级
        if m_btReLevel >= LoWord(StdItem.NeedLevel) then begin
          if HiWord(m_WAbil.SC) >= HiWord(StdItem.NeedLevel) then begin
            Result := True;
          end else begin
            SysMsg(g_sSCNot, c_Red, t_Hint);
          end;
        end else begin
          SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
        end;
      end;
    44: begin //所需声望和转生等级
        if m_btReLevel >= LoWord(StdItem.NeedLevel) then begin
          if m_btCreditPoint >= HiWord(StdItem.NeedLevel) then begin
            Result := True;
          end else begin
            SysMsg(g_sCreditPointNot, c_Red, t_Hint);
          end;
        end else begin
          SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
        end;
      end;
    53..56: SysMsg(g_sHeroCanUse, c_Red, t_Hint); //英雄物品,主体不能使用
    60: begin //行会掌门物品
        if (m_MyGuild <> nil) and (m_nGuildRankNo = 1) then begin
          Result := True;
        end else begin
          SysMsg(g_sGuildMasterNot, c_Red, t_Hint);
        end;
      end;
    61: begin //性别用品，需要等级
        if (m_btGender = StdItem.NeedLevel) then begin
          if m_Abil.Level >= StdItem.Stock then begin
            Result := True;
          end else begin
            SysMsg(g_sLevelNot, c_Red, t_Hint);
          end;
        end else begin
          case StdItem.NeedLevel of
            0: SysMsg(sWearNotOfWoMan, c_Red, t_Hint);
            1: SysMsg(sWearNotOfMan, c_Red, t_Hint);
          end;
        end;
      end;
    62: begin //性别用品，需要攻击
        if (m_btGender = StdItem.NeedLevel) then begin
          if HiWord(m_WAbil.DC) >= StdItem.Stock then begin
            Result := True;
          end else begin
            SysMsg(g_sDCNot, c_Red, t_Hint);
          end;
        end else begin
          case StdItem.NeedLevel of
            0: SysMsg(sWearNotOfWoMan, c_Red, t_Hint);
            1: SysMsg(sWearNotOfMan, c_Red, t_Hint);
          end;
        end;
      end;
    63: begin //性别用品，需要魔法
        if (m_btGender = StdItem.NeedLevel) then begin
          if HiWord(m_WAbil.MC) >= StdItem.Stock then begin
            Result := True;
          end else begin
            SysMsg(g_sMCNot, c_Red, t_Hint);
          end;
        end else begin
          case StdItem.NeedLevel of
            0: SysMsg(sWearNotOfWoMan, c_Red, t_Hint);
            1: SysMsg(sWearNotOfMan, c_Red, t_Hint);
          end;
        end;
      end;
    64: begin //性别用品，需要道术
        if (m_btGender = StdItem.NeedLevel) then begin
          if HiWord(m_WAbil.SC) >= StdItem.Stock then begin
            Result := True;
          end else begin
            SysMsg(g_sSCNot, c_Red, t_Hint);
          end;
        end else begin
          case StdItem.NeedLevel of
            0: SysMsg(sWearNotOfWoMan, c_Red, t_Hint);
            1: SysMsg(sWearNotOfMan, c_Red, t_Hint);
          end;
        end;
      end;
    70: begin //沙城城主物品
        //      if (m_MyGuild <> nil) and (UserCastle.m_MasterGuild = m_MyGuild) and (m_nGuildRankNo = 1) then begin
        if (m_MyGuild <> nil) and (Castle <> nil) and (m_nGuildRankNo = 1) then begin
          if m_Abil.Level >= StdItem.NeedLevel then begin
            Result := True;
          end else begin
            SysMsg(g_sLevelNot, c_Red, t_Hint);
          end;
        end else begin
          SysMsg(g_sSabukMasterManNot, c_Red, t_Hint);
        end;
      end;
    81: begin //指定类型的会员物品
        if (m_nMemberType = LoWord(StdItem.NeedLevel)) and (m_nMemberLevel >= HiWord(StdItem.NeedLevel)) then begin
          Result := True;
        end else begin
          SysMsg(g_sMemberTypeNot, c_Red, t_Hint);
        end;
      end;
    82: begin //指定类型的会员物品
        if (m_nMemberType >= LoWord(StdItem.NeedLevel)) and (m_nMemberLevel >= HiWord(StdItem.NeedLevel)) then begin
          Result := True;
        end else begin
          SysMsg(g_sMemberTypeNot, c_Red, t_Hint);
        end;
      end;
  end;
end;

function TBaseObject.sub_4C5370(nX, nY: Integer; nRange: Integer; var nDX, nDY: Integer): Boolean; //004C5370
var
  I: Integer;
  II: Integer;
  III: Integer;
begin
  Result := False;
  if m_PEnvir.GetMovingObject(nX, nY, True) = nil then begin
    Result := True;
    nDX := nX;
    nDY := nY;
  end;
  if nRange <= 0 then nRange := 1; //20091113 增加
  if not Result then begin
    for I := 1 to nRange do begin
      for II := -I to I do begin
        for III := -I to I do begin
          nDX := nX + III;
          nDY := nY + II;
          if m_PEnvir.GetMovingObject(nDX, nDY, True) = nil then begin
            Result := True;
            Break;
          end;
        end;
        if Result then Break;
      end;
      if Result then Break;
    end;
  end;
  if not Result then begin
    nDX := nX;
    nDY := nY;
  end;
end;
//取装备物品的重量

function TPlayObject.GetUserItemWeitht(nWhere: Integer): Integer;
var
  I: Integer;
  n14: Integer;
  StdItem: pTStdItem;
begin
  n14 := 0;
  for I := Low(THumanUseItems) to High(THumanUseItems) do begin //9格装备+4格装备
    if (nWhere = -1) or (not (I = nWhere) and not (I = 1) and not (I = 2)) then begin
      StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
      if StdItem <> nil then Inc(n14, StdItem.Weight);
    end;
  end;
  Result := n14;
end;

function TPlayObject.EatItems(StdItem: pTStdItem; nType: Byte): Boolean;
var
  bo06: Boolean;
  nOldStatus: Integer;
  dwExp: LongWord; //20081021
begin
  Result := False;
  if m_PEnvir.m_boNODRUG then begin //地图不允许使用任何药品
    SysMsg(sCanotUseDrugOnThisMap, c_Red, t_Hint);
    Exit;
  end;
  case StdItem.StdMode of
    0: begin
        if nType <> 1 then Exit; //200990810 增加用药标识
        case StdItem.Shape of
          1: begin //增加HP，MP的药品(特殊)
              if GetTickCount() - m_dwUserTick[4] > g_Config.dwEatHPItemsIntervalTime then begin //20090325 使用药品间隔
                m_dwUserTick[4] := GetTickCount();
                IncHealthSpell(StdItem.AC, StdItem.MAC); //增加HP,MP
                Result := True;
              end;
            end;
          2: begin
              m_boUserUnLockDurg := True;
              Result := True;
            end;
{$IF M2Version <> 2}
          3: begin //增加内功经验物品 20081002
              if m_boTrainingNG then begin
                if g_Config.boUseNGItemIncExp then
                  dwExp := StdItem.AC * 1000 + abs(Round(StdItem.AC * m_NGLevel * 3.92)) //20081021 每级加的内功经验不同
                else dwExp := StdItem.AC * 1000;
                GetNGExp(dwExp, 1);
                Result := True;
              end else SysMsg('内力不足，无法使用', c_Green, t_Hint);
            end;
          4: begin //增加内力值物品 20090809
              if m_boTrainingNG then begin
                m_Skill69NH := _MIN(m_Skill69MaxNH, m_Skill69NH + StdItem.AC);
                SendRefMsg(RM_MAGIC69SKILLNH, 0, m_Skill69NH, m_Skill69MaxNH, 0, '');
                Result := True;
              end else SysMsg('内力不足，无法使用', c_Green, t_Hint);
            end;
{$IFEND}
        else begin //普通药品，增加HP
            if GetTickCount() - m_dwUserTick[4] > g_Config.dwEatHPItemsIntervalTime then begin //20090325 使用药品间隔
              m_dwUserTick[4] := GetTickCount();
              if (StdItem.AC > 0) then begin
                Inc(m_nIncHealth, StdItem.AC);
              end;
              if (StdItem.MAC > 0) then begin
                Inc(m_nIncSpell, StdItem.MAC);
              end;
              Result := True;
            end;
          end;
        end; //case
      end;
    1: begin
        nOldStatus := GetMyStatus();
        Inc(m_nHungerStatus, StdItem.DuraMax div 10);
        m_nHungerStatus := _MIN(5000, m_nHungerStatus);
        if nOldStatus <> GetMyStatus() then RefMyStatus();
        Result := True;
      end;
    2: Result := True;
    3: begin
        case StdItem.Shape of
          12: begin
              bo06 := False;
              if LoWord(StdItem.DC) > 0 then begin
                m_wStatusArrValue[0] := LoWord(StdItem.DC);
                m_dwStatusArrTimeOutTick[0] := GetTickCount + HiWord(StdItem.MAC) * 1000;
                SysMsg('攻击力增加' + IntToStr(HiWord(StdItem.MAC)) + '秒', c_Green, t_Hint);
                bo06 := True;
              end;
              if LoWord(StdItem.MC) > 0 then begin
                m_wStatusArrValue[1] := LoWord(StdItem.MC);
                m_dwStatusArrTimeOutTick[1] := GetTickCount + HiWord(StdItem.MAC) * 1000;
                SysMsg('魔法力增加' + IntToStr(HiWord(StdItem.MAC)) + '秒', c_Green, t_Hint);
                bo06 := True;
              end;
              if LoByte(StdItem.SC) > 0 then begin
                m_wStatusArrValue[20] := LoWord(StdItem.SC);
                m_dwStatusArrTimeOutTick[20] := GetTickCount + HiWord(StdItem.MAC) * 1000;
                SysMsg('道术增加' + IntToStr(HiWord(StdItem.MAC)) + '秒', c_Green, t_Hint);
                bo06 := True;
              end;
              if HiWord(StdItem.AC) > 0 then begin
                m_wStatusArrValue[3] := HiWord(StdItem.AC);
                m_dwStatusArrTimeOutTick[3] := GetTickCount + HiWord(StdItem.MAC) * 1000;
                SysMsg('攻击速度增加' + IntToStr(HiWord(StdItem.MAC)) + '秒', c_Green, t_Hint);
                bo06 := True;
              end;
              if LoWord(StdItem.AC) > 0 then begin
                m_wStatusArrValue[4] := LoWord(StdItem.AC);
                m_dwStatusArrTimeOutTick[4] := GetTickCount + HiWord(StdItem.MAC) * 1000;
                SysMsg('生命值增加' + IntToStr(HiWord(StdItem.MAC)) + '秒', c_Green, t_Hint);
                bo06 := True;
              end;
              if LoWord(StdItem.MAC) > 0 then begin
                m_wStatusArrValue[5] := LoWord(StdItem.MAC);
                m_dwStatusArrTimeOutTick[5] := GetTickCount + HiWord(StdItem.MAC) * 1000;
                SysMsg('魔法值增加' + IntToStr(HiWord(StdItem.MAC)) + '秒', c_Green, t_Hint);
                bo06 := True;
              end;
              if bo06 then begin
                RecalcAbilitys();
                CompareSuitItem(False); //套装与身上装备对比 20080729
                if m_btRaceServer = RC_PLAYOBJECT then SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, ''); //20090501 修改
                Result := True;
              end;
            end; //12
          13: begin //除魔攻击药剂(随机增加点数)
              bo06 := False;
              if (StdItem.AC > 0) then begin
                case m_btJob of //职业
                  0: begin
                      m_wStatusArrValue[0] := 1 + Random(StdItem.AC);
                      m_dwStatusArrTimeOutTick[0] := GetTickCount + HiWord(StdItem.MAC) * 1000;
                      SysMsg('攻击力上下限瞬间提高' + IntToStr(HiWord(StdItem.MAC)) + '秒', c_Green, t_Hint);
                      bo06 := True;
                    end;
                  1: begin
                      m_wStatusArrValue[1] := 1 + Random(StdItem.AC);
                      m_dwStatusArrTimeOutTick[1] := GetTickCount + HiWord(StdItem.MAC) * 1000;
                      SysMsg('魔法上下限瞬间提高' + IntToStr(HiWord(StdItem.MAC)) + '秒', c_Green, t_Hint);
                      bo06 := True;
                    end;
                  2: begin
                      m_wStatusArrValue[20] := 1 + Random(StdItem.AC);
                      m_dwStatusArrTimeOutTick[20] := GetTickCount + HiWord(StdItem.MAC) * 1000;
                      SysMsg('道术上下限瞬间提高' + IntToStr(HiWord(StdItem.MAC)) + '秒', c_Green, t_Hint);
                      bo06 := True;
                    end;
                end;
              end;
              if bo06 then begin
                RecalcAbilitys();
                CompareSuitItem(False); //套装与身上装备对比 20080729
                if m_btRaceServer = RC_PLAYOBJECT then SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, ''); //20090501 修改
                Result := True;
              end;
            end; //13
          14: begin //除魔防御药剂
              bo06 := False;
              if (StdItem.AC > 0) then begin
                case Random(2) of
                  0: begin //防御
                      m_wStatusArrValue[12] := StdItem.AC + Random(3);
                      m_dwStatusArrTimeOutTick[12] := GetTickCount + HiWord(StdItem.MAC) * 1000;
                      SysMsg('防御上下限瞬间提高' + IntToStr(HiWord(StdItem.MAC)) + '秒', c_Green, t_Hint);
                      bo06 := True;
                    end; //0
                  1: begin //魔防
                      m_wStatusArrValue[13] := StdItem.AC + Random(3);
                      m_dwStatusArrTimeOutTick[13] := GetTickCount + HiWord(StdItem.MAC) * 1000;
                      SysMsg('魔御上下限瞬间提高' + IntToStr(HiWord(StdItem.MAC)) + '秒', c_Green, t_Hint);
                      bo06 := True;
                    end; //1
                end;
              end;
              if bo06 then begin
                RecalcAbilitys();
                CompareSuitItem(False); //套装与身上装备对比 20080729
                if m_btRaceServer = RC_PLAYOBJECT then SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, ''); //20090501 修改
                Result := True;
              end;
            end; //14
        else begin
            Result := EatUseItems(StdItem.Shape);
          end;
        end; //case
      end; //3
    17: begin
        if StdItem.Shape = 237 then begin
          if GetTickCount() - m_dwUserTick[4] > g_Config.dwEatHPItemsIntervalTime then begin //使用药品间隔
            m_dwUserTick[4] := GetTickCount();
{$IF M2Version <> 2}
            if (StdItem.DC > 0) then begin //龙卫心法经验吸收 20110821
              if m_MagicSkill_105 <> nil then begin //无龙卫心法则不能使用物品
                //龙卫心法经验吸收(减当前经验)
                if not IncHeartPoint(g_Config.nIncHeartPointNeedExp * 10000) then begin
                  SysMsg(Format('已累积经验%u，相差%u经验，无法使用！', [m_Abil.nExp, (g_Config.nIncHeartPointNeedExp * 10000 - m_Abil.nExp)]), c_Green, t_Hint);
                  Exit;
                end;
              end else begin
                SysMsg('未学习龙卫心法，无法使用！', c_Green, t_Hint);
                Exit;
              end;
            end;
{$IFEND}
            if StdItem.AniCount = 0 then begin //慢速型
              if (StdItem.AC > 0) then begin
                Inc(m_nIncHealth, StdItem.AC);
              end;
              if (StdItem.MAC > 0) then begin
                Inc(m_nIncSpell, StdItem.MAC);
              end;
            end else begin //快速型
              IncHealthSpell(StdItem.AC, StdItem.MAC); //增加HP,MP
            end;
            Result := True;
          end;
        end;
      end;
  end; //case
end;
//学习技能书

function TPlayObject.ReadBook(StdItem: pTStdItem): Boolean;
var
  Magic: pTMagic;
  UserMagic: pTUserMagic;
  sStr: string;
begin
  Result := False;
  if (StdItem.Need > 0) and (StdItem.NeedLevel > 0) and (StdItem.AC = 0) then begin //四级技能书
    Magic := UserEngine.FindMagic(StdItem.NeedLevel);
    if Magic <> nil then begin
      if not IsTrainingSkill(Magic.wMagicId){$IF M2Version = 1} or ((Magic.wMagicId = StdItem.Need)
        and (StdItem.NeedLevel in [SKILL_FIRESWORD, SKILL_FIRECHARM, SKILL_45, SKILL_110, SKILL_111, SKILL_112, SKILL_113, SKILL_114])){$IFEND} then begin
        if (Magic.sDescr = '') and ((Magic.btJob = 99) or (Magic.btJob = m_btJob)) then begin
          if TrainingSkillToLevel(StdItem.Need, Magic, 3, 4, sStr) then begin
            Result := True;
          end else SysMsg('您不能学习此技能！', c_Red, t_Hint);
{$IF M2Version <> 2}
        end else
          if (Magic.sDescr = '神技') and ((Magic.btJob = 99) or (Magic.btJob = m_btJob)) then begin
            if TrainingSkillToLevel(StdItem.Need, Magic, 3, 4, sStr) then Result := True;
            if sStr <> '' then SysMsg(sStr, c_Red, t_Hint);
{$IFEND}
          end else SysMsg('您的职业不能学习此技能！', c_Red, t_Hint);
      end else SysMsg('已经学过此技能,不能再学习！', c_Red, t_Hint);
    end;
  end else begin
    Magic := UserEngine.FindMagic(StdItem.Name);
    if Magic <> nil then begin
      if not IsTrainingSkill(Magic.wMagicId) then begin
        if ((Magic.sDescr = ''){$IF M2Version <> 2} or (Magic.sDescr = '内功') or
          (Magic.sDescr = '连击') or (Magic.sDescr = '通用') or (Magic.sDescr = '神技'){$IFEND})
          and ((Magic.btJob = 99) or (Magic.btJob = m_btJob)) then begin
{$IF M2Version <> 2}
          if (Magic.sDescr = '内功') or (Magic.sDescr = '连击') then begin //内功、连击技能
            if m_boTrainingNG then begin //学过内功心法才能学习技能
              if m_NGLevel >= Magic.TrainLevel[0] then begin //等级达到最低要求
                New(UserMagic);
                UserMagic.MagicInfo := Magic;
                UserMagic.wMagIdx := Magic.wMagicId;
                UserMagic.btKey := 0;
                UserMagic.btLevel := 0;
                UserMagic.nTranPoint := 0;
                UserMagic.btLevelEx := 0;
                if Magic.wMagicId = SKILL_102 then UserMagic.btLevel := 1; //唯我独尊,学习等级为1级
                m_MagicList.Add(UserMagic);
                AddSkillFunc(Magic.wMagicId); //人物学技能触发  20080324
                RecalcAbilitys();
                CompareSuitItem(False); //套装与身上装备对比 20080729
                SendAddMagic(UserMagic);
                Result := True;
{$IF M2Version = 1}
                if (not m_boTrainBatterSkill) and (Magic.sDescr = '连击') then begin
                  m_boTrainBatterSkill := True; //是否学习过连击技能 20090702
                  m_boSendCanBatterMsg := False;
                end;
{$IFEND}
              end else SysMsg(Format('您的内功心法等级没有达到 %d,不能学习此内功技能！', [Magic.TrainLevel[0]]), c_Red, t_Hint);
            end else SysMsg('您没学过内功心法,不能学习此内功技能！', c_Red, t_Hint);
          end else begin //普通技能
{$IFEND}
            if (m_Abil.Level >= Magic.TrainLevel[0]) then begin
              case Magic.wMagicId of
                SKILL_75: begin
                    if m_boProtectionDefence then begin                                  
                      SysMsg('已经学过此技能,不能再学习！', c_Red, t_Hint);
                      Exit;
                    end;
                    m_boProtectionDefence := True; //是否学过护体神盾
                    AddSkillFunc(Magic.wMagicId); //人物学技能触发
                    Result := True;
                    Exit;
                  end;
{$IF M2Version <> 2}
                SKILL_105: if (m_MagicSkill_106 <> nil) or (not m_boTrainingNG) then Exit;
                SKILL_106: if (m_MagicSkill_105 <> nil) or (not m_boTrainingNG) then Exit;
                SKILL_107, SKILL_108, SKILL_109, SKILL_110, SKILL_111, SKILL_112, SKILL_113, SKILL_114: begin
                    if (m_MagicSkill_105 = nil) then begin
                      SysMsg('未学有龙卫心法,不能学习此技能！', c_Red, t_Hint);
                      Exit;
                    end;
                    if (m_MagicSkill_105 <> nil) then begin
                      if m_MagicSkill_105.btLevel < Magic.TrainLevel[0] then begin
                        SysMsg(Format('您的龙卫心法等级没有达到 %d,不能学习此技能！', [Magic.TrainLevel[0]]), c_Red, t_Hint);
                        Exit;
                      end;
                    end;
                  end;
{$IFEND}
              end;
              New(UserMagic);
              UserMagic.MagicInfo := Magic;
              UserMagic.wMagIdx := Magic.wMagicId;
              UserMagic.btKey := 0;
              UserMagic.btLevel := 0;
              if UserMagic.wMagIdx in [SKILL_110, SKILL_111, SKILL_112, SKILL_113, SKILL_114] then UserMagic.btLevel := 1;
              UserMagic.nTranPoint := 0;
              UserMagic.btLevelEx := 0;
              m_MagicList.Add(UserMagic);
              AddSkillFunc(Magic.wMagicId); //人物学技能触发  20080324
              RecalcAbilitys();
              CompareSuitItem(False); //套装与身上装备对比 20080729
              if ((m_MagicBanwolSkill <> nil) and (Magic.wMagicId = SKILL_BANWOL)) or ((m_Magic90Skill <> nil) and (Magic.wMagicId = SKILL_90)) then begin //开启半月 20080606
                if not m_boUseHalfMoon then begin
                  case Magic.wMagicId of
                    SKILL_BANWOL: begin
                        HalfMoonOnOff(True, 0);
                        SendSocket(nil, '+WID');
                      end;
                    SKILL_90: begin
                        HalfMoonOnOff(True, 1);
                        SendSocket(nil, '+WID4');
                      end;
                  end;
                end;
              end;
              if ((m_MagicErgumSkill <> nil) and (Magic.wMagicId = SKILL_ERGUM)) or ((m_Magic89Skill <> nil) and (Magic.wMagicId = SKILL_89)) then begin //开启刺杀 20080606
                if not m_boUseThrusting then begin
                  ThrustingOnOff(True);
                  case Magic.wMagicId of
                    SKILL_ERGUM: SendSocket(nil, '+LNG');
                    SKILL_89: SendSocket(nil, '+LNG4');
                  end;
                end;
              end;
              SendAddMagic(UserMagic);
              Result := True;
            end;
{$IF M2Version <> 2}
          end;
{$IFEND}
        end else SysMsg('您的职业不能学习此技能！', c_Red, t_Hint);
      end else SysMsg('已经学过此技能,不能再学习！', c_Red, t_Hint);
    end else SysMsg('您不能学习英雄的技能！', c_Red, t_Hint);
  end;
end;
//查找指定技能,是否达到指定等级，如达到并改变等级(四级技能使用) 20091201

function TBaseObject.TrainingSkillToLevel(nIndex: Integer; Magic: pTMagic; nLevel, nToLevel: Byte; var Str: string): Boolean;
var
  I, nMagLevel: Integer;
  UserMagic, NewUserMagic: pTUserMagic;
begin
  Result := False;
  Str := '';
  if m_MagicList.Count > 0 then begin
    for I := 0 to m_MagicList.Count - 1 do begin
      UserMagic := m_MagicList.Items[I];
      if (UserMagic <> nil) then begin
        if (UserMagic.wMagIdx = nIndex) then begin
          if (Magic.sDescr = '神技') then begin //神技则判断心法等级
{$IF M2Version <> 2}
            if (m_btRaceServer = RC_PLAYOBJECT) then begin
              if (UserMagic.btLevel < 9) and ((UserMagic.wMagIdx = Magic.wMagicId)) then begin
                if (TPlayObject(self).m_MagicSkill_105 <> nil) then begin
                  if UserMagic.wMagIdx in [SKILL_100..SKILL_114] then begin
                    nMagLevel := Magic.TrainLevel[0] + (Magic.TrainLevel[2] - Magic.TrainLevel[1]) * UserMagic.btLevel;
                    if TPlayObject(self).m_MagicSkill_105.btLevel >= nMagLevel then begin
                      Inc(UserMagic.btLevel);
                      Result := True;
                      SendDelayMsg(self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 500);
                    end else Str := Format('龙卫心法等级未达到%d级,不能使用此技能书升级！', [nMagLevel]);
                  end else Str := '主动龙卫神技才能使用此技能书升级！';
                end else Str := '未学有龙卫心法不能使用此技能书！';
              end else Str := '神技已达9重不能再升级！';
            end else Str := '只有主体才能学习！';
{$IFEND}
          end else begin
            if (UserMagic.btLevel = nLevel) and (m_Abil.Level >= Magic.TrainLevel[0]) then begin
              New(NewUserMagic);
              NewUserMagic.MagicInfo := Magic;
              NewUserMagic.wMagIdx := Magic.wMagicId;
              NewUserMagic.btKey := UserMagic.btKey;
              NewUserMagic.btLevel := nToLevel;
              NewUserMagic.nTranPoint := UserMagic.nTranPoint;
              NewUserMagic.btLevelEx := 0;
              m_MagicList.Add(NewUserMagic);
              Result := True;
              case m_btRaceServer of
                RC_PLAYOBJECT: begin
                    TPlayObject(self).SendDelMagic(UserMagic);
                    TPlayObject(self).SendAddMagic(NewUserMagic);
                    TPlayObject(self).AddSkillFunc(Magic.wMagicId); //人物学技能触发
                    m_MagicList.Delete(I);
                    //防止释放内存后的非法访问 By TasNat at: 2012-03-11 
                    //m_MagicOfDelList.Add(UserMagic);
                    Dispose(UserMagic);
                    RecalcAbilitys();
                    CompareSuitItem(False); //套装与身上装备对比
                    if Magic.wMagicId = SKILL_88 then begin
                      SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, ''); //四级基本剑术则更新属性
                      SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
                    end;
                  end;
                RC_HEROOBJECT: begin
                    if m_Master <> nil then begin
                      THeroObject(self).SendDelMagic(UserMagic);
                      THeroObject(self).SendAddMagic(NewUserMagic);
                      m_MagicList.Delete(I);
                      //防止释放内存后的非法访问 By TasNat at: 2012-03-11 
                      //m_MagicOfDelList.Add(UserMagic);
                      Dispose(UserMagic);
                      RecalcAbilitys();
                      CompareSuitItem(False); //套装与身上装备对比
                      TPlayObject(m_Master).HeroAddSkillFunc(Magic.wMagicId); //英雄学技能触发
                      if Magic.wMagicId = SKILL_88 then begin
                        THeroObject(self).SendMsg(self, RM_HEROABILITY, 0, 0, 0, 0, ''); //四级基本剑术则更新属性
                        THeroObject(self).SendMsg(self, RM_SUBABILITY, 0, 0, 0, 0, '');
                      end;
                    end;
                  end;
              end;
            end;
          end;
          Break;
        end;
      end;
    end;
  end;
end;

//检查是否学习过某个技能

function TBaseObject.IsTrainingSkill(nIndex: Integer): Boolean;
var
  I: Integer;
  UserMagic: pTUserMagic;
begin
  Result := False;
  if m_MagicList.Count > 0 then begin
    for I := 0 to m_MagicList.Count - 1 do begin
      UserMagic := m_MagicList.Items[I];
      if (UserMagic <> nil) then begin
        case nIndex of
          SKILL_ONESWORD: begin //检查是否学有四级基本剑术
              if ((UserMagic.wMagIdx = nIndex) or (UserMagic.wMagIdx = SKILL_88)) then begin
                Result := True;
                Break;
              end;
            end;
          SKILL_ERGUM: begin //刺杀剑术,检查是否学有四级刺杀剑术
              if ((UserMagic.wMagIdx = nIndex) or (UserMagic.wMagIdx = SKILL_89)) then begin
                Result := True;
                Break;
              end;
            end;
          SKILL_BANWOL: begin //半月弯刀,判断是不是有4级技能
              if ((UserMagic.wMagIdx = nIndex) or (UserMagic.wMagIdx = SKILL_90)) then begin
                Result := True;
                Break;
              end;
            end;
          SKILL_LIGHTENING: begin //雷电术,判断是不是有4级技能
              if ((UserMagic.wMagIdx = nIndex) or (UserMagic.wMagIdx = SKILL_91)) then begin
                Result := True;
                Break;
              end;
            end;
          SKILL_58: begin //流星火雨,判断是不是有4级技能
              if ((UserMagic.wMagIdx = nIndex) or (UserMagic.wMagIdx = SKILL_92)) then begin
                Result := True;
                Break;
              end;
            end;
          SKILL_AMYOUNSUL: begin //施毒术,判断是不是有4级技能
              if ((UserMagic.wMagIdx = nIndex) or (UserMagic.wMagIdx = SKILL_93)) then begin
                Result := True;
                Break;
              end;
            end;
          SKILL_SHIELD: begin //是魔法盾则判断是不是有4级魔法盾或普通魔法盾
              if ((UserMagic.wMagIdx = nIndex) or (UserMagic.wMagIdx = SKILL_66)) then begin
                Result := True;
                Break;
              end;
            end;
          SKILL_59: begin //检查是否学有四级噬血术,判断是不是有4级技能
              if ((UserMagic.wMagIdx = nIndex) or (UserMagic.wMagIdx = SKILL_94)) then begin
                Result := True;
                Break;
              end;
            end;
        else begin
            if (UserMagic.wMagIdx = nIndex) then begin
              Result := True;
              Break;
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TPlayObject.SendAddMagic(UserMagic: pTUserMagic);
var
  ClientMagic: TClientMagic;
begin
  if m_boNotOnlineAddExp or m_boAI then Exit;
  ClientMagic.Key := Char(UserMagic.btKey);
  ClientMagic.Level := UserMagic.btLevel;
  ClientMagic.CurTrain := UserMagic.nTranPoint;
  ClientMagic.Def := UserMagic.MagicInfo^;
  ClientMagic.btLevelEx := UserMagic.btLevelEx;
  case ClientMagic.Def.wMagicId of
    SKILL_68: ClientMagic.Def.MaxTrain[0] := GetSkill68Exp(UserMagic.btLevel); //酒气护体
{$IF M2Version <> 2}
{$IF M2Version = 1}
    SKILL_95: ClientMagic.Def.MaxTrain[0] := GetSkill95Exp(UserMagic.btLevel); //斗转星移
{$IFEND}
    SKILL_105: begin //龙卫心法
        ClientMagic.Def.sMagicName := m_sHeartName; //自定义技能名称
        ClientMagic.Def.btDefMaxPower := m_nHeartType; //心法类型
        if UserMagic.btLevel > 0 then
          ClientMagic.Def.MaxTrain[0] := ClientMagic.Def.MaxTrain[0] + UserMagic.btLevel * (ClientMagic.Def.MaxTrain[2] - ClientMagic.Def.MaxTrain[1]);
      end;
    SKILL_106: begin //传承龙卫心法
        ClientMagic.Def.sMagicName := m_sHeartName; //自定义技能名称
        ClientMagic.Def.btDefMaxPower := m_nHeartType; //心法类型
        if UserMagic.btLevel > 0 then
          ClientMagic.Def.MaxTrain[0] := ClientMagic.Def.MaxTrain[0] + UserMagic.btLevel * (ClientMagic.Def.MaxTrain[2] - ClientMagic.Def.MaxTrain[1]);
      end;
    SKILL_107, SKILL_108, SKILL_109: begin //被动龙卫技能
        if UserMagic.btLevel > 0 then
          ClientMagic.Def.MaxTrain[0] := ClientMagic.Def.MaxTrain[0] + UserMagic.btLevel * (ClientMagic.Def.MaxTrain[2] - ClientMagic.Def.MaxTrain[1]);
      end;
    SKILL_200: begin //怒之攻杀强化
        if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
          ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_200NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_200NGStrong[1]);
          ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_200NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_200NGStrong[3]);
        end else begin
          ClientMagic.Def.wPower := 0;
          ClientMagic.Def.wMaxPower := 0;
        end;
      end;
    Skill_202: begin //怒之半月强化
        if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
          ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_202NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_202NGStrong[1]);
          ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_202NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_202NGStrong[3]);
        end else begin
          ClientMagic.Def.wPower := 0;
          ClientMagic.Def.wMaxPower := 0;
        end;
      end;
    Skill_236: begin //怒之内功剑法强化
        if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
          ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_236NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_236NGStrong[1]);
          ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_236NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_236NGStrong[3]);
        end else begin
          ClientMagic.Def.wPower := 0;
          ClientMagic.Def.wMaxPower := 0;
        end;
      end;
    Skill_204: begin //怒之烈火强化
        if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
          ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_204NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_204NGStrong[1]);
          ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_204NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_204NGStrong[3]);
        end else begin
          ClientMagic.Def.wPower := 0;
          ClientMagic.Def.wMaxPower := 0;
        end;
      end;
    Skill_206: begin //怒之逐日强化
        if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
          ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_206NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_206NGStrong[1]);
          ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_206NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_206NGStrong[3]);
        end else begin
          ClientMagic.Def.wPower := 0;
          ClientMagic.Def.wMaxPower := 0;
        end;
      end;
    Skill_239: begin //怒之施毒术强化
        if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
          ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_239NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_239NGStrong[1]);
          ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_239NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_239NGStrong[3]);
        end else begin
          ClientMagic.Def.wPower := 0;
          ClientMagic.Def.wMaxPower := 0;
        end;
      end;
    Skill_230: begin //怒之火符强化
        if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
          ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_230NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_230NGStrong[1]);
          ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_230NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_230NGStrong[3]);
        end else begin
          ClientMagic.Def.wPower := 0;
          ClientMagic.Def.wMaxPower := 0;
        end;
      end;
    Skill_232: begin //怒之噬血强化
        if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
          ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_232NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_232NGStrong[1]);
          ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_232NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_232NGStrong[3]);
        end else begin
          ClientMagic.Def.wPower := 0;
          ClientMagic.Def.wMaxPower := 0;
        end;
      end;
    Skill_241: begin //怒之月灵强化
        if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
          ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_241NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_241NGStrong[1]);
          ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_241NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_241NGStrong[3]);
        end else begin
          ClientMagic.Def.wPower := 0;
          ClientMagic.Def.wMaxPower := 0;
        end;
      end;
    Skill_228: begin //怒之灭天火强化
        if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
          ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_228NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_228NGStrong[1]);
          ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_228NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_228NGStrong[3]);
        end else begin
          ClientMagic.Def.wPower := 0;
          ClientMagic.Def.wMaxPower := 0;
        end;
      end;
    Skill_234: begin //怒之流星火雨强化
        if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
          ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_234NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_234NGStrong[1]);
          ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_234NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_234NGStrong[3]);
        end else begin
          ClientMagic.Def.wPower := 0;
          ClientMagic.Def.wMaxPower := 0;
        end;
      end;
    Skill_208: begin //怒之火球强化
        if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
          ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_208NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_208NGStrong[1]);
          ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_208NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_208NGStrong[3]);
        end else begin
          ClientMagic.Def.wPower := 0;
          ClientMagic.Def.wMaxPower := 0;
        end;
      end;
    Skill_214: begin //怒之地狱火强化
        if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
          ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_214NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_214NGStrong[1]);
          ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_214NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_214NGStrong[3]);
        end else begin
          ClientMagic.Def.wPower := 0;
          ClientMagic.Def.wMaxPower := 0;
        end;
      end;
    Skill_218: begin //怒之爆裂火焰强化
        if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
          ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_218NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_218NGStrong[1]);
          ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_218NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_218NGStrong[3]);
        end else begin
          ClientMagic.Def.wPower := 0;
          ClientMagic.Def.wMaxPower := 0;
        end;
      end;
    Skill_222: begin //怒之雷电强化
        if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
          ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_222NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_222NGStrong[1]);
          ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_222NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_222NGStrong[3]);
        end else begin
          ClientMagic.Def.wPower := 0;
          ClientMagic.Def.wMaxPower := 0;
        end;
      end;
    Skill_210: begin //怒之大火球强化
        if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
          ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_210NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_210NGStrong[1]);
          ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_210NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_210NGStrong[3]);
        end else begin
          ClientMagic.Def.wPower := 0;
          ClientMagic.Def.wMaxPower := 0;
        end;
      end;
    Skill_212: begin //怒之火墙强化
        if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
          ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_212NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_212NGStrong[1]);
          ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_212NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_212NGStrong[3]);
        end else begin
          ClientMagic.Def.wPower := 0;
          ClientMagic.Def.wMaxPower := 0;
        end;
      end;
    Skill_216: begin //怒之疾光电影强化
        if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
          ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_216NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_216NGStrong[1]);
          ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_216NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_216NGStrong[3]);
        end else begin
          ClientMagic.Def.wPower := 0;
          ClientMagic.Def.wMaxPower := 0;
        end;
      end;
    Skill_224: begin //怒之地狱雷光强化
        if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
          ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_224NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_224NGStrong[1]);
          ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_224NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_224NGStrong[3]);
        end else begin
          ClientMagic.Def.wPower := 0;
          ClientMagic.Def.wMaxPower := 0;
        end;
      end;
    Skill_226: begin //怒之寒冰掌强化
        if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
          ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_226NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_226NGStrong[1]);
          ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_226NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_226NGStrong[3]);
        end else begin
          ClientMagic.Def.wPower := 0;
          ClientMagic.Def.wMaxPower := 0;
        end;
      end;
    Skill_220: begin //怒之冰咆哮强化
        if (ClientMagic.Level > 2) and (ClientMagic.Level < g_Config.nNGSkillMaxLevel) then begin //等于达到3级时计算
          ClientMagic.Def.wPower := _MIN(High(Word), g_Config.nSKILL_220NGStrong[0] + (ClientMagic.Level - 3) * g_Config.nSKILL_220NGStrong[1]);
          ClientMagic.Def.wMaxPower := _MIN(High(Word), g_Config.nSKILL_220NGStrong[2] + (ClientMagic.Level - 3) * g_Config.nSKILL_220NGStrong[3]);
        end else begin
          ClientMagic.Def.wPower := 0;
          ClientMagic.Def.wMaxPower := 0;
        end;
      end;
{$IFEND}
    SKILL_99: ClientMagic.Def.MaxTrain[0] := 300 + (UserMagic.btLevel * 200); //强身术的升级经验通过算法取出
    SKILL_100: ClientMagic.Def.MaxTrain[0] := 500 + (UserMagic.btLevel * 700); //神秘解读
    SKILL_71, SKILL_104: ClientMagic.Def.MaxTrain[0] := GetUpKill71Count(UserMagic.btLevel); //召唤圣兽,召唤火灵
  end;
  m_DefMsg := MakeDefaultMsg(SM_ADDMAGIC, 0, 0, 0, 1, 0);
  SendSocket(@m_DefMsg, EncodeBuffer(@ClientMagic, SizeOf(TClientMagic)));
end;

procedure TPlayObject.SendDelMagic(UserMagic: pTUserMagic);
begin
  if m_boNotOnlineAddExp or m_boAI then Exit;
  m_DefMsg := MakeDefaultMsg(SM_DELMAGIC, UserMagic.wMagIdx, 0, 0, 1, 0);
  SendSocket(@m_DefMsg, '');
end;

function TPlayObject.EatUseItems(nShape: Integer): Boolean;
var
  Castle: TUserCastle;
begin
  Result := False;
  case nShape of //
    1: begin
        {$IF M2Version = 1}
        if g_Config.boMag113LockCanFly and InMag113LockRect(m_nCurrX, m_nCurrY) then begin //在被天雷乱舞锁定范围 则不考虑 By TasNat at: 2012-03-08 11:53:11
          SysMsg('禁锢中无法使用...', c_Red, t_Hint);
          Exit;
        end;
        {$ifend}
        SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
        BaseObjectMove(m_sHomeMap, '', '');
        Result := True;
      end;
    2: begin //随机传送卷
        {$IF M2Version = 1}
        if g_Config.boMag113LockCanFly and InMag113LockRect(m_nCurrX, m_nCurrY) then begin //在被天雷乱舞锁定范围 则不考虑 By TasNat at: 2012-03-08 11:53:11
          SysMsg('禁锢中无法使用...', c_Red, t_Hint);
          Exit;
        end;
        {$ifend}
        if not m_PEnvir.m_boNORANDOMMOVE then begin
          SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
          BaseObjectMove(m_sMapName, '', '');
          Result := True;
        end;
      end;
    3: begin
        {$IF M2Version = 1}
        if g_Config.boMag113LockCanFly and InMag113LockRect(m_nCurrX, m_nCurrY) then begin //在被天雷乱舞锁定范围 则不考虑 By TasNat at: 2012-03-08 11:53:11
          SysMsg('禁锢中无法使用...', c_Red, t_Hint);
          Exit;
        end;
        {$ifend}
        SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
        if PKLevel < 2 then begin
          BaseObjectMove(m_sHomeMap, IntToStr(m_nHomeX), IntToStr(m_nHomeY));
        end else begin
          BaseObjectMove(g_Config.sRedHomeMap, IntToStr(g_Config.nRedHomeX), IntToStr(g_Config.nRedHomeY));
        end;
        Result := True;
      end;
    4: begin
        if WeaptonMakeLuck() then Result := True;
      end;
    5: begin
        {$IF M2Version = 1}
        if g_Config.boMag113LockCanFly and InMag113LockRect(m_nCurrX, m_nCurrY) then begin //在被天雷乱舞锁定范围 则不考虑 By TasNat at: 2012-03-08 11:53:11
          SysMsg('禁锢中无法使用...', c_Red, t_Hint);
          Exit;
        end;
        {$ifend}
        if m_MyGuild <> nil then begin
          if not m_boInFreePKArea then begin
            Castle := g_CastleManager.IsCastleMember(Self);
            if (Castle <> nil) and Castle.IsMasterGuild(TGUild(m_MyGuild)) then begin
              BaseObjectMove(Castle.m_sHomeMap, IntToStr(Castle.GetHomeX), IntToStr(Castle.GetHomeY));
            end else begin
              SysMsg('无效', c_Red, t_Hint);
            end;
            Result := True;
          end else begin
            SysMsg('此处无法使用', c_Red, t_Hint);
          end;
        end;
      end;
    9: begin
        if RepairWeapon() then Result := True;
      end;
    10: begin
        if SuperRepairWeapon() then Result := True;
      end;
    11: begin
        if WinLottery() then Result := True;
      end;
  end;
end;

procedure TPlayObject.MoveToHome;
begin
  SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
  BaseObjectMove(m_sHomeMap, IntToStr(m_nHomeX), IntToStr(m_nHomeY));
end;

procedure TPlayObject.BaseObjectMove(sMAP, sX, sY: string);
var
  Envir: TEnvirnoment;
  nX, nY: Integer;
begin
  Envir := m_PEnvir;
  if sMAP = '' then sMAP := m_sMapName;
  if (sX <> '') and (sY <> '') then begin
    nX := Str_ToInt(sX, 0);
    nY := Str_ToInt(sY, 0);
    SpaceMove(sMAP, nX, nY, 0);
  end else begin
    MapRandomMove(sMAP, 0);
  end;
  if (Envir <> m_PEnvir) and (m_btRaceServer = RC_PLAYOBJECT) then begin
    m_boTimeRecall := False;
  end;
end;
//使用祝福油,给武器加幸运

function TPlayObject.WeaptonMakeLuck: Boolean;
var
  StdItem: pTStdItem;
  nRand: Integer;
  boMakeLuck: Boolean;
  nCode: Byte;
begin
  Result := False;
  nCode := 0;
  try
    if m_UseItems[U_WEAPON].wIndex <= 0 then Exit;
    nCode := 1;
    nRand := 0;
    StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
    nCode := 2;
    if StdItem <> nil then begin
      nRand := abs((HiWord(StdItem.DC) - LoWord(StdItem.DC))) div 5;
    end;
    nCode := 3;
    if Random(g_Config.nWeaponMakeUnLuckRate {20}) = 1 then begin
      nCode := 4;
      MakeWeaponUnlock(); //武器加诅咒
    end else begin
      nCode := 5;
      boMakeLuck := False;
      if m_UseItems[U_WEAPON].btValue[4] > 0 then begin
        nCode := 6;
        Dec(m_UseItems[U_WEAPON].btValue[4]);
        SysMsg(g_sWeaptonMakeLuck {'武器被加幸运了...'}, c_Green, t_Hint);
        boMakeLuck := True;
      end else if m_UseItems[U_WEAPON].btValue[3] < g_Config.nWeaponMakeLuckPoint1 {1} then begin
        nCode := 7;
        Inc(m_UseItems[U_WEAPON].btValue[3]);
        SysMsg(g_sWeaptonMakeLuck {'武器被加幸运了...'}, c_Green, t_Hint);
        boMakeLuck := True;
      end else if (m_UseItems[U_WEAPON].btValue[3] < g_Config.nWeaponMakeLuckPoint2 {3}) and (Random(nRand + g_Config.nWeaponMakeLuckPoint2Rate {6}) = 1) then begin
        nCode := 8;
        Inc(m_UseItems[U_WEAPON].btValue[3]);
        SysMsg(g_sWeaptonMakeLuck {'武器被加幸运了...'}, c_Green, t_Hint);
        boMakeLuck := True;
      end else if (m_UseItems[U_WEAPON].btValue[3] < g_Config.nWeaponMakeLuckPoint3 {7}) and (Random(nRand * g_Config.nWeaponMakeLuckPoint3Rate {10 + 30}) = 1) then begin
        nCode := 9;
        Inc(m_UseItems[U_WEAPON].btValue[3]);
        SysMsg(g_sWeaptonMakeLuck {'武器被加幸运了...'}, c_Green, t_Hint);
        boMakeLuck := True;
      end;
      nCode := 10;
      //有效才更新By TasNat at: 2012-06-24 14:24:17
      if boMakeLuck and (m_btRaceServer = RC_PLAYOBJECT) then begin
        nCode := 11;
        RecalcAbilitys();
        nCode := 12;
        CompareSuitItem(False); //套装与身上装备对比 20080729
        nCode := 13;
        SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
        SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
        //修复喝了祝福油不更新属性By TasNat at: 2012-06-24 14:50:56
        SendUpdateItem(@m_UseItems[U_WEAPON]);
        //SendMsg(self, RM_DURACHANGE,m_UseItems[U_WEAPON].wIndex, m_UseItems[U_WEAPON].Dura, m_UseItems[U_WEAPON].DuraMax, 0, ''); //20071229 增加
      end;
      nCode := 14;
      if not boMakeLuck then SysMsg(g_sWeaptonNotMakeLuck {'无效'}, c_Green, t_Hint);
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.WeaptonMakeLuck Code:%d', [g_sExceptionVer, nCode]));
  end;
  Result := True;
end;
//修复武器

function TPlayObject.RepairWeapon: Boolean;
var
  nDura: Integer;
  UserItem: pTUserItem;
begin
  Result := False;
  UserItem := @m_UseItems[U_WEAPON];
  //if (UserItem.wIndex <= 0) or (UserItem.DuraMax <= UserItem.Dura) then Exit;
  if (UserItem.wIndex <= 0) or ((UserItem.DuraMax div 1000) <= (UserItem.Dura div 1000)) then Exit; //20080415
  if CheckItemValue(UserItem, 3) then Exit; //20080314 禁止修
  Dec(UserItem.DuraMax, (UserItem.DuraMax - UserItem.Dura) div g_Config.nRepairItemDecDura {30});
  nDura := _MIN(5000, UserItem.DuraMax - UserItem.Dura);
  if nDura > 0 then begin
    Inc(UserItem.Dura, nDura);
    SendMsg(Self, RM_DURACHANGE, 1, UserItem.Dura, UserItem.DuraMax, 0, '');
    SysMsg(g_sWeaponRepairSuccess {'武器修复成功...'}, c_Green, t_Hint);
    Result := True;
  end;
end;

function TPlayObject.SuperRepairWeapon: Boolean;
begin
  Result := False;
  if m_UseItems[U_WEAPON].wIndex <= 0 then Exit;
  if CheckItemValue(@m_UseItems[U_WEAPON], 3) then Exit; //20080314 禁止修
  m_UseItems[U_WEAPON].Dura := m_UseItems[U_WEAPON].DuraMax;
  SendMsg(Self, RM_DURACHANGE, 1, m_UseItems[U_WEAPON].Dura, m_UseItems[U_WEAPON].DuraMax, 0, '');
  SysMsg(g_sWeaponRepairSuccess {'武器修复成功...'}, c_Green, t_Hint);
  Result := True;
end;
//赢彩票

function TPlayObject.WinLottery: Boolean;
var
  nGold, nWinLevel, nRate: Integer;
begin
  nGold := 0;
  nWinLevel := 0;
  nRate := Random(g_Config.nWinLotteryRate);
  if (nRate >= g_Config.nWinLottery6Min) and (nRate <= g_Config.nWinLottery6Max) then begin //20080725 修改
  //if nRate in [g_Config.nWinLottery6Min..g_Config.nWinLottery6Max] then begin
    if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then begin
      nGold := g_Config.nWinLottery6Gold;
      nWinLevel := 6;
      Inc(g_Config.nWinLotteryLevel6);
      Inc(g_Config.nWinLotteryCount); //20080725 中奖人数
      Dec(g_Config.nNoWinLotteryCount); //20080725 未中奖人数
    end;
  end else
    if (nRate >= g_Config.nWinLottery5Min) and (nRate <= g_Config.nWinLottery5Max) then begin //20080725 修改
    //if nRate in [g_Config.nWinLottery5Min..g_Config.nWinLottery5Max] then begin
      if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then begin
        nGold := g_Config.nWinLottery5Gold;
        nWinLevel := 5;
        Inc(g_Config.nWinLotteryLevel5);
        Inc(g_Config.nWinLotteryCount); //20080725 中奖人数
        Dec(g_Config.nNoWinLotteryCount); //20080725 未中奖人数
      end;
    end else
      if (nRate >= g_Config.nWinLottery4Min) and (nRate <= g_Config.nWinLottery4Max) then begin //20080725 修改
    //if nRate in [g_Config.nWinLottery4Min..g_Config.nWinLottery4Max] then begin
        if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then begin
          nGold := g_Config.nWinLottery4Gold;
          nWinLevel := 4;
          Inc(g_Config.nWinLotteryLevel4);
          Inc(g_Config.nWinLotteryCount); //20080725 中奖人数
          Dec(g_Config.nNoWinLotteryCount); //20080725 未中奖人数
        end;
      end else
        if (nRate >= g_Config.nWinLottery3Min) and (nRate <= g_Config.nWinLottery3Max) then begin //20080725 修改
    //if nRate in [g_Config.nWinLottery3Min..g_Config.nWinLottery3Max] then begin
          if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then begin
            nGold := g_Config.nWinLottery3Gold;
            nWinLevel := 3;
            Inc(g_Config.nWinLotteryLevel3);
            Inc(g_Config.nWinLotteryCount); //20080725 中奖人数
            Dec(g_Config.nNoWinLotteryCount); //20080725 未中奖人数
          end;
        end else
          if (nRate >= g_Config.nWinLottery2Min) and (nRate <= g_Config.nWinLottery2Max) then begin //20080725 修改
    //if nRate in [g_Config.nWinLottery2Min..g_Config.nWinLottery2Max] then begin
            if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then begin
              nGold := g_Config.nWinLottery2Gold;
              nWinLevel := 2;
              Inc(g_Config.nWinLotteryLevel2);
              Inc(g_Config.nWinLotteryCount); //20080725 中奖人数
              Dec(g_Config.nNoWinLotteryCount); //20080725 未中奖人数
            end;
          end else
            if (nRate >= g_Config.nWinLottery1Min) and (nRate <= g_Config.nWinLottery1Max) then begin //20080725 修改
    //if nRate in [g_Config.nWinLottery1Min + g_Config.nWinLottery1Max] then begin
              if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then begin
                nGold := g_Config.nWinLottery1Gold;
                nWinLevel := 1;
                Inc(g_Config.nWinLotteryLevel1);
                Inc(g_Config.nWinLotteryCount); //20080725 中奖人数
                Dec(g_Config.nNoWinLotteryCount); //20080725 未中奖人数
              end;
            end;
  if nGold > 0 then begin
    case nWinLevel of //
      1: SysMsg(g_sWinLottery1Msg {'祝贺您，中了一等奖。'}, c_Green, t_Hint);
      2: SysMsg(g_sWinLottery2Msg {'祝贺您，中了二等奖。'}, c_Green, t_Hint);
      3: SysMsg(g_sWinLottery3Msg {'祝贺您，中了三等奖。'}, c_Green, t_Hint);
      4: SysMsg(g_sWinLottery4Msg {'祝贺您，中了四等奖。'}, c_Green, t_Hint);
      5: SysMsg(g_sWinLottery5Msg {'祝贺您，中了五等奖。'}, c_Green, t_Hint);
      6: SysMsg(g_sWinLottery6Msg {'祝贺您，中了六等奖。'}, c_Green, t_Hint);
    end;
    if IncGold(nGold) then begin
      GoldChanged();
    end else begin
      DropGoldDown(nGold, True, nil, nil);
    end;
  end else begin
    Inc(g_Config.nNoWinLotteryCount, 500);
    SysMsg(g_sNotWinLotteryMsg {'等下次机会吧！！！'}, c_Red, t_Hint);
  end;
  Result := True;
end;

procedure TBaseObject.DamageBubbleDefence(nInt: Integer);
begin
  if m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP] > 0 then begin
    if m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP] > 3 then
      Dec(m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP], 3)
    else m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP] := 1;
  end;
end;

//是否是行会主人

function TBaseObject.IsGuildMaster: Boolean;
begin
  Result := False;
  if (m_MyGuild <> nil) and (m_nGuildRankNo = 1) then
    Result := True;
end;
(*
Function TBaseObject.IsCastleMaster:Integer;//判断是不是城主或精英团 20080330
var Castle: TUserCastle;
begin
  Result := 0;
  if (m_MyGuild <> nil) then begin
    Castle := g_CastleManager.IsCastleMember(Self);
    if Castle <> nil then
    if  (CompareText(Castle.m_sOwnGuild,TGUild(m_MyGuild).sGuildName)= 0 ) and (Castle.m_MasterGuild = TGUild(m_MyGuild)) then begin
      Result := 1;//是精英团
      if (CompareText(m_sGuildRankName, g_Config.sGuildChief{掌门人})= 0) and IsGuildMaster then Result := 2;//是城主
    end;
  end;
end; *)

procedure TPlayObject.ChangeServerMakeSlave(SalveInfo: pTSlaveInfo);
var
  nSlavecount: Integer;
  BaseObject: TBaseObject;
begin
  if m_btJob = 2 then begin
    nSlavecount := 1;
  end else begin
    nSlavecount := 5;
  end;
  BaseObject := MakeSlave(SalveInfo.sSalveName, 3, SalveInfo.btSalveLevel, nSlavecount, SalveInfo.dwRoyaltySec);
  if BaseObject <> nil then begin
    BaseObject.n294 := SalveInfo.nKillCount;
    BaseObject.m_btSlaveExpLevel := SalveInfo.btSlaveExpLevel;
    BaseObject.m_WAbil.HP := SalveInfo.nHP;
    BaseObject.m_WAbil.MP := SalveInfo.nMP;
    if (1500 - SalveInfo.btSalveLevel * 200) < BaseObject.m_nWalkSpeed then begin
      BaseObject.m_nWalkSpeed := 1500 - SalveInfo.btSalveLevel * 200;
    end;
    if Integer(2000 - SalveInfo.btSalveLevel * 200) < BaseObject.m_nNextHitTime then begin
      BaseObject.m_nWalkSpeed := 2000 - SalveInfo.btSalveLevel * 200;
    end;
    RecalcAbilitys();
    CompareSuitItem(False); //套装与身上装备对比 20080729
  end;
end;

procedure TPlayObject.SendDelDealItem(UserItem: pTUserItem);
var
  StdItem: pTStdItem;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  sUserItemName: string;
begin
  SendDefMessage(SM_DEALDELITEM_OK, 0, 0, 0, 0, '');
  if m_DealCreat <> nil then begin
    if m_DealCreat.m_nSoftVersionDateEx = 0 then begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
        //ClientItem.S:=StdItem^;
        CopyStdItemToOStdItem(StdItem, @OClientItem.s);
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          OClientItem.s.Name := sUserItemName;

        OClientItem.MakeIndex := UserItem.MakeIndex;
        OClientItem.Dura := UserItem.Dura;
        OClientItem.DuraMax := UserItem.DuraMax;
      end;
      m_DefMsg := MakeDefaultMsg(SM_DEALREMOTEDELITEM, Integer(Self), 0, 0, 1, 0);
      m_DealCreat.SendSocket(@m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
    end else begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
        ClientItem.s := StdItem^;
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          ClientItem.s.Name := sUserItemName;
        if (UserItem.btValue[12] = 1) and (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) then ClientItem.s.Reserved1 := 1 //物品发光 20080223
        else ClientItem.s.Reserved1 := 0;
{$IF M2Version <> 2}
        if (StdItem.StdMode = 5) or (StdItem.StdMode = 6) then begin //武器暴击等级 20100708
          ClientItem.s.NeedIdentify := _MIN(High(Byte), UserItem.btValue[11] + UserItem.btValue[20]);
          if CheckItemSpiritMedia(UserItem) then begin
            ClientItem.Aura := UserItem.btValue[12];
            ClientItem.MaxAura := g_Config.nMaxAuraValue;
          end;
        end else begin
          if CheckItemSpiritMedia(UserItem) or ((StdItem.StdMode = 44) and (StdItem.shape = 253)) then begin
            ClientItem.Aura := UserItem.btValue[11];
            ClientItem.MaxAura := g_Config.nMaxAuraValue;
          end;
        end;
        if (StdItem.StdMode = 44) and (StdItem.shape = 255) then begin //神秘卷轴
          ClientItem.s.NeedIdentify := UserItem.btValue[0];
        end;
{$IFEND}
        if (StdItem.StdMode = 60) and (StdItem.shape <> 0) then begin //酒类,除烧酒外 20080622
          if UserItem.btValue[0] <> 0 then ClientItem.s.AC := UserItem.btValue[0]; //酒的品质
          if UserItem.btValue[1] <> 0 then ClientItem.s.MAC := UserItem.btValue[1]; //酒的酒精度
          if UserItem.btValue[3] > 0 then ClientItem.s.NeedLevel := UserItem.btValue[3] //酒的等级 20091117
          else ClientItem.s.NeedLevel := 0;
        end;

        ClientItem.MakeIndex := UserItem.MakeIndex;
        ClientItem.Dura := UserItem.Dura;
        ClientItem.DuraMax := UserItem.DuraMax;
        //Modified By TasNat at: 2012-04-12 09:28:18
        ClientItem.btAppraisalLevel :=   UserItem.btAppraisalLevel;
        ClientItem.btUnKnowValueCount := UserItem.btUnKnowValueCount;
        Move(UserItem.btAppraisalValue, UserItem.btAppraisalValue, SizeOf(UserItem.btAppraisalValue));

        Move(UserItem.btUnKnowValue, ClientItem.btUnKnowValue, SizeOf(ClientItem.btUnKnowValue)); //20100822
      end;
      m_DefMsg := MakeDefaultMsg(SM_DEALREMOTEDELITEM, Integer(Self), 0, 0, 1, 0);
      TPlayObject(m_DealCreat).SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(ClientItem)));
    end;
    m_DealCreat.m_DealLastTick := GetTickCount();
    m_DealLastTick := GetTickCount();
  end;
end;
//发送交易物品

procedure TPlayObject.SendAddDealItem(UserItem: pTUserItem); //004DD464
var
  StdItem: pTStdItem;
  StdItem80: TStdItem;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  sUserItemName: string;
 // sCheckItemName: string;
begin
  SendDefMessage(SM_DEALADDITEM_OK, 0, 0, 0, 0, '');
  if m_DealCreat <> nil then begin
    if m_DealCreat.m_nSoftVersionDateEx = 0 then begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
        StdItem80 := StdItem^;
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          StdItem80.Name := sUserItemName;

        ItemUnit.GetItemAddValue(UserItem, StdItem80);
        //OClientItem.S:=StdItem80;
        CopyStdItemToOStdItem(@StdItem80, @OClientItem.s);
        //if sItemNewName <> '' then
        //  OClientItem.S.Name:=sItemNewName;
        OClientItem.MakeIndex := UserItem.MakeIndex;
        OClientItem.Dura := UserItem.Dura;
        OClientItem.DuraMax := UserItem.DuraMax;
        m_DefMsg := MakeDefaultMsg(SM_DEALREMOTEADDITEM, Integer(Self), 0, 0, 1, 0);
        m_DealCreat.SendSocket(@m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
        m_DealCreat.m_DealLastTick := GetTickCount();
        m_DealLastTick := GetTickCount();
      end;
    end else begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
        StdItem80 := StdItem^;
        ItemUnit.GetItemAddValue(UserItem, StdItem80);

        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          StdItem80.Name := sUserItemName;
        if (UserItem.btValue[12] = 1) and (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) then StdItem80.Reserved1 := 1 //物品发光 20080223
        else StdItem80.Reserved1 := 0;

        ClientItem.s := StdItem80; //20090505 改变位置
        if (StdItem.StdMode = 60) and (StdItem.shape <> 0) then begin //酒类,除烧酒外 20080622
          if UserItem.btValue[0] <> 0 then ClientItem.s.AC := UserItem.btValue[0]; //酒的品质
          if UserItem.btValue[1] <> 0 then ClientItem.s.MAC := UserItem.btValue[1]; //酒的酒精度
          if UserItem.btValue[3] > 0 then ClientItem.s.NeedLevel := UserItem.btValue[3] //酒的等级 20091117
          else ClientItem.s.NeedLevel := 0;
        end;
        if (StdItem.StdMode = 17) and (StdItem.Weight > 0) then ClientItem.s.Weight := UserItem.Dura; //拆加物品的重量 20090816
{$IF M2Version <> 2}
        if (StdItem.StdMode = 5) or (StdItem.StdMode = 6) then begin //武器暴击等级 20100708
          ClientItem.s.NeedIdentify := _MIN(High(Byte), UserItem.btValue[11] + UserItem.btValue[20]);
          if CheckItemSpiritMedia(UserItem) then begin
            ClientItem.Aura := UserItem.btValue[12];
            ClientItem.MaxAura := g_Config.nMaxAuraValue;
          end;
        end else begin
          if CheckItemSpiritMedia(UserItem) or ((StdItem.StdMode = 44) and (StdItem.shape = 253)) then begin
            ClientItem.Aura := UserItem.btValue[11];
            ClientItem.MaxAura := g_Config.nMaxAuraValue;
          end;
        end;
        if (StdItem.StdMode = 44) and (StdItem.shape = 255) then begin //神秘卷轴
          ClientItem.s.NeedIdentify := UserItem.btValue[0];
        end;
{$IFEND}
        ClientItem.MakeIndex := UserItem.MakeIndex;
        ClientItem.Dura := UserItem.Dura;
        ClientItem.DuraMax := UserItem.DuraMax;
        ClientItem.BindValue := UserItem.AddValue[0]; //20110622
        ClientItem.MaxDate := UserItem.MaxDate; //20110622
        if ClientItem.BindValue = 0 then begin //禁止交易,扔物品,显示绑定 20110626
          if (CheckItemValue(UserItem, 1) and CheckItemValue(UserItem, 0)) or
            (GetCheckItemList(0, StdItem.Name) and GetCheckItemList(1, StdItem.Name)) then
            ClientItem.BindValue := 3;
        end;
        //Modified By TasNat at: 2012-04-12 09:28:18
        ClientItem.btAppraisalLevel :=   UserItem.btAppraisalLevel;
        ClientItem.btUnKnowValueCount := UserItem.btUnKnowValueCount;
        Move(UserItem.btAppraisalValue, ClientItem.btAppraisalValue, SizeOf(ClientItem.btAppraisalValue));

        Move(UserItem.btUnKnowValue, ClientItem.btUnKnowValue, SizeOf(ClientItem.btUnKnowValue)); //20100822
        m_DefMsg := MakeDefaultMsg(SM_DEALREMOTEADDITEM, Integer(Self), 0, 0, 1, 0);
        m_DealCreat.SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(ClientItem)));
        m_DealCreat.m_DealLastTick := GetTickCount();
        m_DealLastTick := GetTickCount();
      end;
    end;
  end;
end;

procedure TPlayObject.OpenDealDlg(PlayObject: TPlayObject);
begin
  m_boDealing := True;
  m_DealCreat := PlayObject;
  GetBackDealItems();
  SendDefMessage(SM_DEALMENU, 0, 0, 0, 0, m_DealCreat.m_sCharName);
  m_DealLastTick := GetTickCount();
end;
//加入小组

procedure TPlayObject.JoinGroup(PlayObject: TPlayObject);
begin
  m_GroupOwner := PlayObject;
  SendGroupText(Format_ToStr(g_sJoinGroup, [m_sCharName]));
end;
//魔法能打到目标

function TBaseObject.MagCanHitTarget(nX, nY: Integer; TargeTBaseObject: TBaseObject): Boolean;
var
  n14, n18, n1C, n20: Integer;
begin
  Result := False;
  if TargeTBaseObject = nil then Exit;
  //魔法攻击必中目标 By TasNat at: 2012-05-17 14:37:42
  if (g_Config.boMagLock) and (abs(nX - TargeTBaseObject.m_nCurrX) <= g_Config.nMagicAttackRage) and
    (abs(nX - TargeTBaseObject.m_nCurrY) <= g_Config.nMagicAttackRage)then begin
    Result := True;
    Exit;
  end;
  n20 := abs(nX - TargeTBaseObject.m_nCurrX) + abs(nY - TargeTBaseObject.m_nCurrY);
  n14 := 0;
  while (n14 < 13) do begin
    n18 := GetNextDirection(nX, nY, TargeTBaseObject.m_nCurrX, TargeTBaseObject.m_nCurrY);
    if m_PEnvir.GetNextPosition(nX, nY, n18, 1, nX, nY) and m_PEnvir.sub_4B5FC8(nX, nY) then begin
      if (nX = TargeTBaseObject.m_nCurrX) and (nY = TargeTBaseObject.m_nCurrY) then begin
        Result := True;
        Break;
      end else begin
        n1C := abs(nX - TargeTBaseObject.m_nCurrX) + abs(nY - TargeTBaseObject.m_nCurrY);
        if n1C > n20 then begin
          Result := True;
          Break;
        end;
        //n1C := n20;
      end;
    end else begin
      Break;
    end;
    Inc(n14);
  end;
end;

//是否是适当的朋友

function TBaseObject.IsProperFriend(BaseObject: TBaseObject): Boolean;
  function IsFriend(cret: TBaseObject): Boolean; //是否是朋友
  var
    I: Integer;
    nCode: Byte;
  begin
    Result := False;
    nCode := 0;
    try
      if m_btRaceServer = RC_HEROOBJECT then begin //20080630 英雄给自己的宝宝加防
        if cret.m_Master <> nil then begin
          if m_Master = cret.m_Master then Result := True;
          if cret.m_Master = self then Result := True;
        end else
          if m_Master = cret then Result := True;
      end;
      nCode := 21;
      if cret.m_btRaceServer = RC_HEROOBJECT then begin //20080902 主人给英雄宝宝加防
        if cret.m_Master = self then Result := True;
      end;
      nCode := 1;
      if (cret.m_btRaceServer = RC_PLAYOBJECT) and (m_btRaceServer = RC_PLAYOBJECT) then begin //如果对象是人物
        case m_btAttatckMode of
          HAM_ALL: Result := True;
          HAM_PEACE: begin //和平攻击
              nCode := 2;
              Result := True;
              if (cret.m_btRaceServer = RC_PLAYOBJECT) and (m_btRaceServer = RC_HEROOBJECT) then Result := False; // 20080424 英雄和平模式下不攻击人物
              nCode := 3;
            end;
          HAM_DEAR: begin
              nCode := 4;
              if (Self = cret) or (cret = TPlayObject(Self).m_DearHuman) then begin
                Result := True;
              end;
            end;
          HAM_MASTER: begin //师徒攻击
              nCode := 5;
              if (Self = cret) then begin Result := True;
              end else
                if TPlayObject(Self).m_boMaster then begin
                  nCode := 6;
                  if TPlayObject(Self).m_MasterList.Count > 0 then begin //20080629
                    for I := 0 to TPlayObject(Self).m_MasterList.Count - 1 do begin
                      nCode := 7;
                      if TPlayObject(Self).m_MasterList.Items[I] = cret then begin
                        nCode := 8;
                        Result := True;
                        Break;
                      end;
                    end; //for
                  end;
                end else
                  if TPlayObject(cret).m_boMaster then begin
                    nCode := 9;
                    if TPlayObject(cret).m_MasterList.Count > 0 then begin //20080629
                      for I := 0 to TPlayObject(cret).m_MasterList.Count - 1 do begin
                        nCode := 10;
                        if TPlayObject(cret).m_MasterList.Items[I] = Self then begin
                          nCode := 11;
                          Result := True;
                          Break;
                        end;
                      end; //for
                    end;
                  end;
            end;
          HAM_GROUP: begin
              nCode := 12;
              if cret = Self then Result := True;
              nCode := 13;
              if TPlayObject(Self).IsGroupMember(TPlayObject(cret)) then Result := True;
            end;
          HAM_GUILD: begin
              nCode := 14;
              if cret = Self then Result := True;
              nCode := 15;
              if m_MyGuild <> nil then begin
                nCode := 16;
                if TGUild(m_MyGuild).IsMember(cret.m_sCharName) then Result := True;
                nCode := 17;
                if m_boGuildWarArea and (cret.m_MyGuild <> nil) then begin
                  nCode := 18;
                  if TGUild(m_MyGuild).IsAllyGuild(TGUild(cret.m_MyGuild)) then Result := True;
                  nCode := 19;
                end;
              end;
            end;
          HAM_PKATTACK: begin
              nCode := 20;
              if cret = Self then Result := True;
              if PKLevel >= 2 then begin
                if cret.PKLevel < 2 then Result := True;
              end else begin
                if cret.PKLevel >= 2 then Result := True;
              end;
            end;
{$IF M2Version <> 2}
          HAM_DIVISION: begin //师门攻击
              if cret = Self then Result := True;
              nCode := 15;
              if TPlayObject(Self).m_MyDivision <> nil then begin
                nCode := 16;
                if TDivision(TPlayObject(Self).m_MyDivision).IsMember(cret.m_sCharName) then Result := True;
              end;
            end;
{$IFEND}
        end;
      end;
    except   
      MainOutMessage(format('{%s} TBaseObject.IsProperFriend Code:%d', [g_sExceptionVer, nCode]));
    end;
  end;
begin
  Result := False;
  if BaseObject = nil then Exit;

  if (m_btRaceServer = RC_PLAYMOSTER) or (m_btRaceServer = RC_HEROOBJECT) then begin //分身检测
    if m_Master = nil then begin
      if (BaseObject.m_btRaceServer >= RC_ANIMAL) then
        Result := True;
      if (BaseObject.m_Master <> nil) or (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then
        Result := False;
    end else begin
      if (BaseObject.m_btRaceServer >= RC_ANIMAL) then
        Result := False;
      if BaseObject.m_Master <> nil then
        Result := IsFriend(BaseObject.m_Master);
      if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
        Result := IsFriend(BaseObject);
      if BaseObject = m_Master then
        Result := True;
    end;
    Exit;
  end;

  if (m_btRaceServer >= RC_ANIMAL) then begin
    if (BaseObject.m_btRaceServer >= RC_ANIMAL) then
      Result := True;
    if BaseObject.m_Master <> nil then
      Result := False;
    Exit;
  end;

  if m_btRaceServer = RC_PLAYOBJECT then begin
    Result := IsFriend(BaseObject);
    if BaseObject.m_btRaceServer < RC_ANIMAL then Exit;
    if BaseObject.m_Master = Self then begin
      Result := True;
      Exit;
    end;
    if BaseObject.m_Master <> nil then begin
      Result := IsFriend(BaseObject.m_Master);
      Exit;
    end;
  end else Result := True;
end;
//幽灵盾  神圣战甲术  btState=1 幽灵盾 0 神圣战甲术

function TBaseObject.MagMakeDefenceArea(nX, nY, nRange, nSec: Integer; btState: Byte): Integer;
var
  III: Integer;
  I, II: Integer;
  nStartX, nStartY, nEndX, nEndY: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
begin
  Result := 0;
  nStartX := nX - nRange;
  nEndX := nX + nRange;
  nStartY := nY - nRange;
  nEndY := nY + nRange;
  for I := nStartX to nEndX do begin
    for II := nStartY to nEndY do begin
      if m_PEnvir.GetMapCellInfo(I, II, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
        if MapCellInfo.ObjList.Count > 0 then begin //20080629
          for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
            OSObject := MapCellInfo.ObjList.Items[III];
            if (OSObject <> nil) then begin
              if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                BaseObject := TBaseObject(OSObject.CellObj);
                if (BaseObject <> nil) then begin
                  if (not BaseObject.m_boGhost) then begin
                    if IsProperFriend(BaseObject) then begin
                      if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or (BaseObject.m_btRaceServer = RC_HEROOBJECT)
                        or (BaseObject.m_btRaceServer = RC_PLAYMOSTER) then begin //20110226 只有人物和英雄，人形怪才能加防，魔防
                        if btState = 0 then begin
                          BaseObject.DefenceUp(nSec);
                        end else begin
                          BaseObject.MagDefenceUp(nSec);
                        end;
                      end;
                      Inc(Result);
                    end;
                  end;
                end;
              end;
            end;
          end; //for
        end;
      end;
    end;
  end;
end;

//诅咒术

function TBaseObject.MagMakeAbilityArea(nX, nY, nRange, nSec: Integer): Integer;
var
  III: Integer;
  I, II: Integer;
  nStartX, nStartY, nEndX, nEndY: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
  bo06: Boolean;
begin
  Result := 0;
  nStartX := nX - nRange;
  nEndX := nX + nRange;
  nStartY := nY - nRange;
  nEndY := nY + nRange;
  for I := nStartX to nEndX do begin
    for II := nStartY to nEndY do begin
      if m_PEnvir.GetMapCellInfo(I, II, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
        if MapCellInfo.ObjList.Count > 0 then begin //20080629
          for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
            OSObject := MapCellInfo.ObjList.Items[III];
            if (OSObject <> nil) then begin
              if (OSObject.btType = OS_MOVINGOBJECT) and (not OSObject.boObjectDisPose) then begin //20090510 增加
                BaseObject := TBaseObject(OSObject.CellObj);
                if (BaseObject <> nil) then begin
                  if (not BaseObject.m_boGhost) then begin
                    if IsProperTarget(BaseObject) then begin
                      bo06 := False;
                      case BaseObject.m_btJob of
                        0: begin
                            if BaseObject.m_wStatusArrValue[6] = 0 then begin
                              BaseObject.m_wStatusArrValue[6] := MakeLong(LoWord(BaseObject.m_WAbil.DC), HiWord(BaseObject.m_WAbil.DC) - 2 - (BaseObject.m_Abil.Level div 7));
                              BaseObject.m_dwStatusArrTimeOutTick[6] := GetTickCount + nSec * 1000;
                              if BaseObject.m_btRaceServer = RC_HEROOBJECT then
                                BaseObject.m_Master.SysMsg('(英雄) 攻击力减少' + IntToStr(nSec) + '秒', c_Green, t_Hint)
                              else BaseObject.SysMsg('攻击力减少' + IntToStr(nSec) + '秒', c_Green, t_Hint);
                              bo06 := True;
                            end;
                          end;
                        1: begin
                            if BaseObject.m_wStatusArrValue[7] = 0 then begin
                              BaseObject.m_wStatusArrValue[7] := MakeLong(LoWord(BaseObject.m_WAbil.MC), HiWord(BaseObject.m_WAbil.MC) - 2 - (BaseObject.m_Abil.Level div 7));
                              BaseObject.m_dwStatusArrTimeOutTick[7] := GetTickCount + nSec * 1000;
                              if BaseObject.m_btRaceServer = RC_HEROOBJECT then
                                BaseObject.m_Master.SysMsg('(英雄) 魔法力减少' + IntToStr(nSec) + '秒', c_Green, t_Hint)
                              else BaseObject.SysMsg('魔法力减少' + IntToStr(nSec) + '秒', c_Green, t_Hint);
                              bo06 := True;
                            end;
                          end;
                        2: begin
                            if BaseObject.m_wStatusArrValue[8] = 0 then begin
                              BaseObject.m_wStatusArrValue[8] := MakeLong(LoWord(BaseObject.m_WAbil.SC), HiWord(BaseObject.m_WAbil.SC) - 2 - (BaseObject.m_Abil.Level div 7));
                              BaseObject.m_dwStatusArrTimeOutTick[8] := GetTickCount + nSec * 1000;
                              if BaseObject.m_btRaceServer = RC_HEROOBJECT then
                                BaseObject.m_Master.SysMsg('(英雄) 道术减少' + IntToStr(nSec) + '秒', c_Green, t_Hint)
                              else BaseObject.SysMsg('道术减少' + IntToStr(nSec) + '秒', c_Green, t_Hint);
                              bo06 := True;
                            end;
                          end;
                        {3: begin//刺客(暂时用战士参数)
                            if BaseObject.m_wStatusArrValue[6] = 0 then begin
                              BaseObject.m_wStatusArrValue[6] := MakeLong(LoWord(BaseObject.m_WAbil.DC), HiWord(BaseObject.m_WAbil.DC) - 2 - (BaseObject.m_Abil.Level div 7));
                              BaseObject.m_dwStatusArrTimeOutTick[6] := GetTickCount + nSec * 1000;
                              if BaseObject.m_btRaceServer = RC_HEROOBJECT then
                                BaseObject.m_Master.SysMsg('(英雄) 攻击力减少' + IntToStr(nSec) + '秒', c_Green, t_Hint)
                              else BaseObject.SysMsg('攻击力减少' + IntToStr(nSec) + '秒', c_Green, t_Hint);
                              bo06 := True;
                            end;
                          end; }
                      end;
                      if bo06 then begin
                        if BaseObject.m_btRaceServer = RC_HEROOBJECT then begin
                          THeroObject(BaseObject).RecalcAbilitys();
                          BaseObject.CompareSuitItem(False); //套装与身上装备对比 20080729
                          THeroObject(BaseObject).SendMsg(BaseObject {BaseObject.m_Master}, RM_HEROABILITY, 0, 0, 0, 0, ''); //发送英雄属性  20090107 修改
                        end else begin
                          BaseObject.RecalcAbilitys();
                          BaseObject.CompareSuitItem(False); //套装与身上装备对比 20080729
                          if BaseObject.m_btRaceServer = RC_PLAYOBJECT then BaseObject.SendMsg(BaseObject {self}, RM_ABILITY, 0, 0, 0, 0, ''); //20081010 修改 //20090501 修改
                        end;
                      end;
                      Inc(Result);
                    end
                  end;
                end;
              end;
            end;
          end; //for
        end;
      end;
    end;
  end;
end;

//人物的无极真气  每次使用间隔28秒
//0级提升道术40%(2秒)   1级提升60%(4秒)   2级提升80%(6秒)  3级提升100%(8秒)

function TPlayObject.AbilityUp(UserMagic: pTUserMagic): Boolean;
var
  nSpellPoint, n14: Integer;
begin
  Result := False;
  nSpellPoint := GetSpellPoint(UserMagic);
  if nSpellPoint > 0 then begin
    if (GetTickCount - m_dwSkill50Tick > g_Config.nAbilityUpTick * 1000) and (m_wStatusArrValue[2] = 0) and (GetTickCount - m_dwStatusArrTimeOutTick[2] > 2000) then begin //时间间隔
      if m_WAbil.MP < nSpellPoint then Exit;
      if UserMagic.btLevel > 3 then UserMagic.btLevel := 3; //20100405 增加
      m_dwSkill50Tick := GetTickCount();
      DamageSpell(nSpellPoint);
      HealthSpellChanged();
      if g_Config.boAbilityUpFixMode then begin //无极真气使用固定时长模式 20081109
        n14 := g_Config.nAbilityUpFixUseTime; //无极真气使用固定时长 20081109
      end else n14 := (UserMagic.btLevel * 2) + 2 + g_Config.nAbilityUpUseTime;
      m_dwStatusArrTimeOutTick[2] := GetTickCount + n14 * 1000; //使用时间 20080427
      m_wStatusArrValue[2] := _MIN(HiWord(m_TrueSC), Round(HiWord(m_TrueSC) * (UserMagic.btLevel * 0.2 + 0.4)));
      SysMsg(Format('道术瞬时提升%d，持续 %d 秒', [m_wStatusArrValue[2], n14]), c_Green, t_Hint);
      RecalcAbilitys();
      CompareSuitItem(False); //套装与身上装备对比 20080729
      SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
      Result := True;
    end else SysMsg('精神力凝聚失败', c_Red, t_Hint);
  end;
end;

//减少掉蓝时间

procedure TBaseObject.MagDownHealth(nType, nTime, nPoint: Integer);
var
  nHealthType: Integer;
begin
  nHealthType := 9 + nType;
  if (nHealthType >= 0) and (nHealthType < MAX_STATUS_ATTRIBUTE) then begin //20081203 防止组数越界
    if m_wStatusArrValue[nHealthType] = 0 then begin
      m_wStatusArrValue[nHealthType] := nPoint;
      m_dwStatusArrTimeOutTick[nHealthType] := GetTickCount + nTime * 1000;
    end;
  end;
end;

(*//未使用 20080329
function TBaseObject.DefenceDown(nSec: Integer): Boolean;
begin
  {Result := False; //此段原来注释的
  if m_wStatusTimeArr2[STATE_DEFENCEUP] > 0 then begin
    if m_wStatusTimeArr2[STATE_DEFENCEUP] < nSec then begin
      m_wStatusTimeArr2[STATE_DEFENCEUP] := nSec;
      Result := True;
    end;
  end else begin
    m_wStatusTimeArr2[STATE_DEFENCEUP] := nSec;
    Result := True;
  end;
  m_dwStatusArrTick2[STATE_DEFENCEUP] := GetTickCount;
  SysMsg(Format(g_sDefenceDownTime, [nSec]), c_Green, t_Hint);
  RecalcAbilitys();
  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, ''); }
end; *)
(*//未使用 20080329
function TBaseObject.MagDefenceDown(nSec: Integer): Boolean;
begin
  Result := False;
  if m_wStatusTimeArr[STATE_MAGDEFENCEUP] > 0 then begin
    if m_wStatusTimeArr[STATE_MAGDEFENCEUP] < nSec then begin
      m_wStatusTimeArr[STATE_MAGDEFENCEUP] := nSec;
      Result := True;
    end;
  end else begin
    m_wStatusTimeArr[STATE_MAGDEFENCEUP] := nSec;
    Result := True;
  end;
  m_dwStatusArrTick[STATE_MAGDEFENCEUP] := GetTickCount;
  SysMsg(Format(g_sMagDefenceDownTime, [nSec]), c_Green, t_Hint);
  RecalcAbilitys();
  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
end;*)

function TBaseObject.DefenceUp(nSec: Integer): Boolean;
begin
  Result := False;
  if m_wStatusTimeArr[STATE_DEFENCEUP] > 0 then begin
    if m_wStatusTimeArr[STATE_DEFENCEUP] < nSec then begin
      m_wStatusTimeArr[STATE_DEFENCEUP] := nSec;
      Result := True;
    end;
  end else begin
    m_wStatusTimeArr[STATE_DEFENCEUP] := nSec;
    Result := True;
  end;
  m_dwStatusArrTick[STATE_DEFENCEUP] := GetTickCount;
  if m_btRaceServer = RC_HEROOBJECT then begin
    THeroObject(Self).SysMsg(Format_ToStr('(英雄) ' + g_sDefenceUpTime, [nSec]), c_Green, t_Hint);
    THeroObject(self).RecalcAbilitys();
    CompareSuitItem(False); //套装与身上装备对比 20080729
    THeroObject(self).SendMsg(self {m_Master}, RM_HEROABILITY, 0, 0, 0, 0, ''); //发送英雄属性  20090107 修改
  end else
    if m_btRaceServer = RC_PLAYOBJECT then begin //20090427 修改
      SysMsg(Format_ToStr(g_sDefenceUpTime, [nSec]), c_Green, t_Hint);
      RecalcAbilitys();
      CompareSuitItem(False); //套装与身上装备对比 20080729
      SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
    end else begin
      RecalcAbilitys();
    end;
end;

function TBaseObject.MagDefenceUp(nSec: Integer): Boolean;
begin
  Result := False;
  if m_wStatusTimeArr[STATE_MAGDEFENCEUP] > 0 then begin
    if m_wStatusTimeArr[STATE_MAGDEFENCEUP] < nSec then begin
      m_wStatusTimeArr[STATE_MAGDEFENCEUP] := nSec;
      Result := True;
    end;
  end else begin
    m_wStatusTimeArr[STATE_MAGDEFENCEUP] := nSec;
    Result := True;
  end;
  m_dwStatusArrTick[STATE_MAGDEFENCEUP] := GetTickCount;
  case m_btRaceServer of //20091204 修改
    RC_HEROOBJECT: begin
        THeroObject(Self).SysMsg(Format_ToStr('(英雄) ' + g_sMagDefenceUpTime, [nSec]), c_Green, t_Hint);
        THeroObject(self).RecalcAbilitys();
        CompareSuitItem(False); //套装与身上装备对比 20080729
        THeroObject(self).SendMsg(self {m_Master}, RM_HEROABILITY, 0, 0, 0, 0, ''); //发送英雄属性  20090107 修改
      end;
    RC_PLAYOBJECT: begin
        SysMsg(Format_ToStr(g_sMagDefenceUpTime, [nSec]), c_Green, t_Hint);
        RecalcAbilitys();
        CompareSuitItem(False); //套装与身上装备对比 20080729
        SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
      end;
  else RecalcAbilitys();
  end; //case
  (*if m_btRaceServer = RC_HEROOBJECT then begin
    THeroObject(self).RecalcAbilitys();
    CompareSuitItem(False);//套装与身上装备对比 20080729
    THeroObject(self).SendMsg(self{m_Master}, RM_HEROABILITY, 0, 0, 0, 0, ''); //发送英雄属性  20090107 修改
  end else
  if m_btRaceServer = RC_PLAYOBJECT then begin//20090427 修改
    RecalcAbilitys();
    CompareSuitItem(False);//套装与身上装备对比 20080729
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
  end else begin
    RecalcAbilitys();
  end;*)
end;

//魔法盾  道力盾

function TBaseObject.MagBubbleDefenceUp(nLevel, nSec: Integer): Boolean;
var
  nOldStatus: Integer;
begin
  Result := False;
  if m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP] > 0 then Exit;
  nOldStatus := m_nCharStatus;
  m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP] := nSec; //持继多少久(秒)
  m_dwStatusArrTick[STATE_BUBBLEDEFENCEUP] := GetTickCount(); //人物状态持续的开始时间
  m_nCharStatus := GetCharStatus();
  if nOldStatus <> m_nCharStatus then begin
    if nLevel = 4 then StatusChanged('444') //20080811 4级盾,发个消息给客户端显示特有的效果
    else StatusChanged('');
  end;
  m_boAbilMagBubbleDefence := True; //是否使用魔法盾
  m_btMagBubbleDefenceLevel := nLevel; //魔法盾等级
  Result := True;
end;
//------------------------------------------------------------------------------
//挖矿,给玩家矿石

procedure TPlayObject.MakeMine;
  function RandomDrua(): Integer;
  begin
    Result := Random(g_Config.nStoneGeneralDuraRate {13000}) + g_Config.nStoneMinDura {3000};
    if Random(g_Config.nStoneAddDuraRate {20}) = 0 then begin
      Result := Result + Random(g_Config.nStoneAddDuraMax {10000});
    end;
  end;
var
  UserItem: pTUserItem;
  nRANDOM: Integer;
begin
  if m_ItemList.Count >= MAXBAGITEM then Exit;
  nRANDOM := Random(g_Config.nStoneTypeRate {120});
  if nRANDOM in [g_Config.nGoldStoneMin {1}..g_Config.nGoldStoneMax {2}] then begin
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(g_Config.sGoldStone, UserItem) then begin
      UserItem.Dura := RandomDrua();
      m_ItemList.Add(UserItem);
      WeightChanged();
      SendAddItem(UserItem);
    end else Dispose(UserItem);
    Exit;
  end;
  if nRANDOM in [g_Config.nSilverStoneMin {3}..g_Config.nSilverStoneMax {20}] then begin
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(g_Config.sSilverStone, UserItem) then begin
      UserItem.Dura := RandomDrua();
      m_ItemList.Add(UserItem);
      WeightChanged();
      SendAddItem(UserItem);
    end else Dispose(UserItem);
    Exit;
  end;
  if nRANDOM in [g_Config.nSteelStoneMin {21}..g_Config.nSteelStoneMax {45}] then begin
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(g_Config.sSteelStone, UserItem) then begin
      UserItem.Dura := RandomDrua();
      m_ItemList.Add(UserItem);
      WeightChanged();
      SendAddItem(UserItem);
    end else Dispose(UserItem);
    Exit;
  end;
  if nRANDOM in [g_Config.nBlackStoneMin {46}..g_Config.nBlackStoneMax {56}] then begin
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(g_Config.sBlackStone, UserItem) then begin
      UserItem.Dura := RandomDrua();
      m_ItemList.Add(UserItem);
      WeightChanged();
      SendAddItem(UserItem);
    end else Dispose(UserItem);
    Exit;
  end;
  New(UserItem);
  if UserEngine.CopyToUserItemFromName(g_Config.sCopperStone, UserItem) then begin
    UserItem.Dura := RandomDrua();
    m_ItemList.Add(UserItem);
    WeightChanged();
    SendAddItem(UserItem);
  end else Dispose(UserItem);
end;

function TPlayObject.QuestCheckItem(sItemName {物品名}: string; var nCount {数量},
  nParam: Integer; var nDura: Integer): pTUserItem;
var
  I: Integer;
  UserItem: pTUserItem;
  s1C: string;
begin
  Result := nil;
  nParam := 0;
  nDura := 0;
  nCount := 0;
  if m_ItemList.Count > 0 then begin //20080628
    for I := 0 to m_ItemList.Count - 1 do begin
      UserItem := m_ItemList.Items[I];
      if UserItem <> nil then begin //20090322
        s1C := UserEngine.GetStdItemName(UserItem.wIndex);
        if CompareText(s1C, sItemName) = 0 then begin
          if UserItem.Dura > nDura then begin
            nDura := UserItem.Dura;
            Result := UserItem;
          end;
          Inc(nParam, UserItem.Dura);
          if Result = nil then Result := UserItem;
          Inc(nCount);
        end;
      end;
    end;
  end;
end;

function TBaseObject.GetUserItemByName(sItemName: string;  var nCount: Integer): pTUserItem;
var
  I: Integer;
  sName: string;
begin
  Result := nil;
  nCount := 0;
  for I := Low(THumanUseItems) to High(THumanUseItems) do begin //9格装备+4格装备
    sName := UserEngine.GetStdItemName(m_UseItems[I].wIndex);
    if CompareText(sName, sItemName) = 0 then begin
      Result := @m_UseItems[I];
      Inc(nCount);
    end;
  end;
end;

function TPlayObject.QuestTakeCheckItem(CheckItem: pTUserItem): Boolean;
var
  I: Integer;
  UserItem: pTUserItem;
begin
  Result := False;
  for I := m_ItemList.Count - 1 downto 0 do begin
    if m_ItemList.Count <= 0 then Break;
    UserItem := m_ItemList.Items[I];
    if UserItem = CheckItem then begin
      SendDelItems(UserItem);
      m_ItemList.Delete(I);
      Dispose(UserItem);
      Result := True;
      Break;
    end;
  end;

  for I := Low(m_UseItems) to High(m_UseItems) do begin
    if @m_UseItems[I] = CheckItem then begin
      SendDelItems(@m_UseItems[I]);
      m_UseItems[I].wIndex := 0;
      Result := True;
      Break;
    end;
  end;
end;

procedure TPlayObject.ClientQueryRepairCost(nParam1, nInt: Integer;
  sMsg: string);
var
  I: Integer;
  UserItem: pTUserItem;
  UserItemA: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
begin
  UserItemA := nil;
  if m_ItemList.Count > 0 then begin //20080628
    for I := 0 to m_ItemList.Count - 1 do begin
      UserItem := m_ItemList.Items[I];
      if UserItem = nil then Continue;
      if (UserItem.MakeIndex = nInt) then begin
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

        if (CompareText(sUserItemName, sMsg) = 0) then begin
          UserItemA := UserItem;
          Break;
        end;
      end;
    end;
  end;
  if UserItemA = nil then Exit;
  Merchant := UserEngine.FindMerchant(TObject(nParam1));
  if (Merchant <> nil) and
    ((Merchant.m_PEnvir = m_PEnvir) and
    (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
    (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientQueryRepairCost(Self, UserItemA);
end;

//客户端修复物品

procedure TPlayObject.ClientRepairItem(nParam1, nInt: Integer; sMsg: string);
var
  I: Integer;
  UserItem: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
  sCheckItemName: string;
  bo19: Boolean;
begin
  UserItem := nil;
  bo19 := False;
  if m_ItemList.Count > 0 then begin //20080628
    for I := 0 to m_ItemList.Count - 1 do begin
      UserItem := m_ItemList.Items[I];
      if UserItem.MakeIndex = nInt then begin
        if CheckItemValue(UserItem, 3) then begin
          SendMsg(Self, RM_USERREPAIRITEM_FAIL, 0, 0, 0, 0, '');
          Break //20080314 禁止修
        end else begin
          sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
          if PlugOfCheckCanItem(3, sCheckItemName, False, 0, 0) then begin //禁止物品规则(管理插件功能) 20080729
            SendMsg(Self, RM_USERREPAIRITEM_FAIL, 0, 0, 0, 0, ''); //20080409
            Break;
          end;
        end;
      end;
      //取自定义物品名称
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
      if (UserItem.MakeIndex = nInt) and
        (CompareText(sUserItemName, sMsg) = 0) then begin
        bo19 := True;
        Break;
      end;
    end; // for
  end;
  if (UserItem = nil) or (not bo19) then Exit;

  Merchant := UserEngine.FindMerchant(TObject(nParam1));
  if (Merchant <> nil) and
    ((Merchant.m_PEnvir = m_PEnvir) and
    (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
    (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientRepairItem(Self, UserItem);
end;
{$IF M2Version <> 2}
//客户端拆分赤炎石 20100708

procedure TPlayObject.ClientArmsTearItem(NPC: TObject; nItemIdx: Integer; sMsg: string);
var
  I, nPrice, n15: Integer;
  UserItem, UserItem1: pTUserItem;
  StdItem, StdItem1: pTStdItem;
  sUserItemName: string;
  bo19, boArmsTear, boPriceOK: Boolean;
begin
  boArmsTear := False;
  UserItem := nil;
  bo19 := False;
  n15 := 0;
  if Pos(' ', sMsg) >= 0 then GetValidStr3(sMsg, sMsg, [' ']); //折分物品名称(信件物品的名称后面加了使用次数)
  for I := m_ItemList.Count - 1 downto 0 do begin
    if m_ItemList.Count <= 0 then Break;
    UserItem := m_ItemList.Items[I];
    if UserItem <> nil then begin
      //取自定义物品名称
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
      if (UserItem.MakeIndex = nItemIdx) and (CompareText(sUserItemName, sMsg) = 0) then begin
        bo19 := True;
        Break;
      end;
    end;
  end;
  if (UserItem = nil) or (not bo19) then begin
    SendMsg(Self, RM_USERARMSTEAR_FAIL, 0, 1, 0, 0, ''); //'您的装备上没有镶嵌赤炎石'
    Exit;
  end;
  if UserItem <> nil then begin
    nPrice := Round(UserItem.btValue[11] * g_Config.nArmsTearPriceRate);
    if nPrice > 0 then begin
      boPriceOK := False;
      case g_Config.nArmsTearPriceType of //拆分赤炎石费用类型 0-元宝 1-金币 2-灵符 3-金刚石
        1: if m_nGold >= nPrice then boPriceOK := True; //金币
        2: if m_nGameGird >= nPrice then boPriceOK := True; //灵符
        3: if m_nGameDiamond >= nPrice then boPriceOK := True; //金刚石
      else begin //元宝
          if m_nGameGold >= nPrice then boPriceOK := True;
        end;
      end;
      if boPriceOK then begin
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem <> nil then begin
          if StdItem.StdMode in [5, 6] then begin //是武器，则退对应的赤炎石
            StdItem1 := UserEngine.GetArmsTearStdItem(UserItem.btValue[11]); //通过武器暴击等级，得到对应赤炎石物品 20100914修改
            if StdItem1 <> nil then begin
              New(UserItem1);
              if UserEngine.CopyToUserItemFromName(StdItem1.Name, UserItem1) then begin
                if IsEnoughBag and IsAddWeightAvailable(StdItem1.Weight) then begin
                  case g_Config.nArmsTearPriceType of //拆分赤炎石费用类型 0-元宝 1-金币 2-灵符 3-金刚石
                    1: begin //金币
                        if m_nGold > nPrice then begin
                          Dec(m_nGold, nPrice);
                        end else begin
                          nPrice := m_nGold;
                          m_nGold := 0;
                        end;
                        GoldChanged();
                        if g_boGameLogGold then
                          AddGameDataLog(Format(g_sGameLogMsg1, [13, m_sMapName,
                            m_nCurrX, m_nCurrY, m_sCharName, sSTRING_GOLDNAME,
                              m_nGold, '-(' + inttostr(nPrice) + ')', '暴击拆分']));
                      end;
                    2: begin //灵符
                        if m_nGameGird > nPrice then begin
                          Dec(m_nGameGird, nPrice);
                        end else begin
                          nPrice := m_nGameGird;
                          m_nGameGird := 0;
                        end;
                        GoldGameGirdChanged();
                        if g_boGameLogGameGird then begin //记录灵符日志
                          AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GameGird, m_sMapName,
                            m_nCurrX, m_nCurrY, m_sCharName, g_Config.sGameGird,
                              m_nGameGird, '-' + inttostr(nPrice), '暴击拆分']));
                        end;
                      end;
                    3: begin //金刚石
                        if m_nGameDiaMond > nPrice then begin
                          Dec(m_nGameDiaMond, nPrice);
                        end else begin
                          nPrice := m_nGameDiaMond;
                          m_nGameDiaMond := 0;
                        end;
                        GameGoldChanged(); //更新金刚石数量
                        if g_boGameLogGameDiaMond then begin
                          AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GameDiaMond, m_sMapName,
                            m_nCurrX, m_nCurrY, m_sCharName, g_Config.sGameDiaMond,
                              m_nGameDiaMond, '-' + inttostr(nPrice), '暴击拆分']));
                        end;
                      end;
                  else begin //元宝
                      DecGameGold(nPrice); //先减元宝值，再给物品
                      GameGoldChanged;
                      if g_boGameLogGameGold then
                        AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, m_sMapName,
                          m_nCurrX, m_nCurrY, m_sCharName, g_Config.sGameGoldName,
                            m_nGameGold, '-(' + inttostr(nPrice) + ')', '暴击拆分']));
                    end;
                  end;
                  UserItem.btValue[11] := 0;
                  m_ItemList.Add(UserItem1);
                  SendAddItem(UserItem1);
                  n15 := UserItem.btValue[20];
                  boArmsTear := True;
                end else begin
                  SendMsg(Self, RM_USERARMSTEAR_FAIL, 0, 4, 0, 0, ''); //'您的包裹已没有办法装下任何物品!'
                  Dispose(UserItem1);
                end;
              end else Dispose(UserItem1);
            end;
            if boArmsTear then SendMsg(Self, RM_USERARMSTEAR_OK, 0, n15, 0, 0, ''); //'拆分成功，请查看你的包裹'
          end else begin //失败
            SendMsg(Self, RM_USERARMSTEAR_FAIL, 0, 3, 0, 0, ''); //'只有武器才能拆分赤炎石'
            Exit;
          end;
        end;
      end else begin
        SendMsg(Self, RM_USERARMSTEAR_FAIL, 0, 2, g_Config.nArmsTearPriceType, 0, ''); //元宝不足
        Exit;
      end;
    end else begin
      SendMsg(Self, RM_USERARMSTEAR_FAIL, 0, 1, 0, 0, ''); //'您的装备上没有镶嵌赤炎石'
      Exit;
    end;
  end;
end;
{$IFEND}
//客户端存物品至移动仓库

procedure TPlayObject.ClientStorageItem(NPC: TObject; nItemIdx: Integer; sMsg: string);
var
  Merchant: TMerchant;
  I: Integer;
  UserItem: pTUserItem;
  bo19: Boolean;
  StdItem: pTStdItem;
  sUserItemName: string;
  sCheckItemName: string;
  nCode: Byte;
begin
  nCode := 0;
  m_boCanQueryBag := True; //出售物品时,不能刷新包裹 20080917
  try
    try
      case m_dwStorageType of //20090901 修改
        1: begin //移动仓库
            bo19 := False;
            nCode := 13;
          //UserItem := nil; //未使用 20080411
            if Pos(' ', sMsg) >= 0 then GetValidStr3(sMsg, sMsg, [' ']); //折分物品名称(信件物品的名称后面加了使用次数)
            if (m_nPayMent = 1) and not g_Config.boTryModeUseStorage then begin
              SysMsg(g_sTryModeCanotUseStorage {'试玩模式不可以使用仓库功能！！！'}, c_Red, t_Hint);
              Exit;
            end;
            if m_boShop then begin //开启个人商店时不能扔物品 20100704
              SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropItemMsg);
              Exit;
            end;
            nCode := 14;
            for I := m_ItemList.Count - 1 downto 0 do begin
              if m_ItemList.Count <= 0 then Break;
              UserItem := m_ItemList.Items[I];
              if UserItem <> nil then begin //20090206 增加
                nCode := 15;
                if UserItem.MakeIndex = nItemIdx then begin
                  if (UserItem.AddValue[0] = 1) and (GetDayCount(UserItem.MaxDate, Now) <= 0) then begin //删除到期装备
                    m_ItemList.Delete(I);
                    SendDelItems(UserItem);
                    Dispose(UserItem);
                    Break;
                  end;
                  if (UserItem.AddValue[0] = 2) and (GetDayCount(UserItem.MaxDate, Now) <= 0) then UserItem.AddValue[0] := 0;
                  if CheckItemValue(UserItem, 2) then Break //20080314 禁止存
                  else begin
                    nCode := 16;
                    sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                    if PlugOfCheckCanItem(2, sCheckItemName, False, 0, 0) then Break; //禁止物品规则(禁止存) 20080729
                  end;
                end;
              //取自定义物品名称
                sUserItemName := '';
                if UserItem.btValue[13] = 1 then
                  sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
                if sUserItemName = '' then
                  sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                nCode := 17;
                if (UserItem.MakeIndex = nItemIdx) and (CompareText(sUserItemName, sMsg) = 0) then begin
                  nCode := 18;
                  Merchant := UserEngine.FindMerchant(NPC);
                  if (Merchant <> nil) then begin
                    if (Merchant.m_boStorage) and //检查NPC是否允许存物品
                      (((Merchant.m_PEnvir = m_PEnvir) and
                      (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
                      (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC)) then begin
                      nCode := 19;
                      if m_StorageItemList.Count < MAXBAGITEM then begin
                        nCode := 21;
                        m_StorageItemList.Add(UserItem);
                        nCode := 22;
                        m_ItemList.Delete(I);
                        nCode := 23;
                        WeightChanged();
                        nCode := 24;
                        SendDefMessage(SM_STORAGE_OK, 0, 0, 0, 0, '');
                        nCode := 25;
                        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                        nCode := 26;
                        if StdItem.NeedIdentify = 1 then
                          AddGameDataLog('1' + #9 + m_sMapName + #9 +
                            IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                            m_sCharName + #9 + StdItem.Name + #9 +
                            IntToStr(UserItem.MakeIndex) + #9 +
                            '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                            '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                            '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                            '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                            '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                            IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                            IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                            IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                            IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + Merchant.m_sCharName);
                      end else begin
                        SendDefMessage(SM_STORAGE_FULL, 0, 0, 0, 0, '');
                      end;
                      bo19 := True;
                    end;
                  end;
                  Break;
                end;
              end;
            end; //for
          end; //1
        2: begin //无限仓库
            Merchant := UserEngine.FindMerchant(NPC);
            if (Merchant <> nil) and (Merchant.m_boBigStorage) then begin
              nCode := 2;
              bo19 := False;
            //UserItem := nil;//未使用 20080411
              if Pos(' ', sMsg) >= 0 then GetValidStr3(sMsg, sMsg, [' ']); //折分物品名称(信件物品的名称后面加了使用次数)
              if (m_nPayMent = 1) and not g_Config.boTryModeUseStorage then begin
                SysMsg(g_sTryModeCanotUseStorage {'试玩模式不可以使用仓库功能！！！'}, c_Red, t_Hint);
                SendDefMessage(SM_STORAGE_FAIL, 0, 0, 0, 0, '');
                Exit;
              end;
              if m_boShop then begin //开启个人商店时不能扔物品 20100704
                SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropItemMsg);
                Exit;
              end;
              nCode := 3;
              if (m_BigStorageItemList <> nil) and (m_BigStorageItemList.Count > g_Config.nBigStorageLimitCount) then begin
                SysMsg(Format_ToStr(g_sBigStorageCountIsNul, [g_Config.nBigStorageLimitCount]), c_Red, t_Hint);
                SendDefMessage(SM_STORAGE_FAIL, 0, 0, 0, 0, '');
                Exit;
              end;
              nCode := 4;
              for I := m_ItemList.Count - 1 downto 0 do begin
                if m_ItemList.Count <= 0 then Break;
                UserItem := m_ItemList.Items[I];
                if UserItem.MakeIndex = nItemIdx then begin
                  if (UserItem.AddValue[0] = 1) and (GetDayCount(UserItem.MaxDate, Now) <= 0) then begin //删除到期装备
                    m_ItemList.Delete(I);
                    SendDelItems(UserItem);
                    Dispose(UserItem);
                    Break;
                  end;
                  if (UserItem.AddValue[0] = 2) and (GetDayCount(UserItem.MaxDate, Now) <= 0) then UserItem.AddValue[0] := 0;
                  nCode := 5;
                  if CheckItemValue(UserItem, 2) then Break //20080314 禁止存
                  else begin
                    nCode := 6;
                    sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                    if PlugOfCheckCanItem(2, sCheckItemName, False, 0, 0) then Break; //禁止物品规则(禁止存) 20080729
                  end;
                end;
              //取自定义物品名称
                nCode := 7;
                sUserItemName := '';
                if UserItem.btValue[13] = 1 then
                  sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
                if sUserItemName = '' then
                  sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                nCode := 8;
                if (UserItem.MakeIndex = nItemIdx) and (CompareText(sUserItemName, sMsg) = 0) then begin
                  nCode := 9;
                  if (Merchant.m_boBigStorage) and //检查NPC是否允许存物品
                    (((Merchant.m_PEnvir = m_PEnvir) and
                    (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
                    (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC)) then begin
                    nCode := 10;
                    if g_Storage.Add(m_BigStorageItemList, m_sCharName, UserItem) then begin
                      nCode := 11;
                      m_ItemList.Delete(I);
                      ClearCopyItem(0, UserItem.wIndex, UserItem.MakeIndex); //清理包裹和仓库复制物品 20080816
                      Dispose(UserItem);
                      WeightChanged();
                      SendDefMessage(SM_STORAGE_OK, 0, 0, 0, 0, '');
                      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                      nCode := 12;
                      if StdItem <> nil then begin //20080722 增加
                        nCode := 23;
                        if StdItem.NeedIdentify = 1 then
                          AddGameDataLog('1' + #9 + m_sMapName + #9 +
                            IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                            m_sCharName + #9 + StdItem.Name + #9 +
                            IntToStr(UserItem.MakeIndex) + #9 +
                            '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                            '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                            '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                            '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                            '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                            IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                            IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                            IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                            IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + Merchant.m_sCharName);
                      end;
                    end else begin
                      SendDefMessage(SM_STORAGE_FULL, 0, 0, 0, 0, '');
                    end;
                    bo19 := True;
                  end;
                  Break;
                end;
              end; //for
            end;
          end; //2
      end;
      nCode := 1;
      (*if (Merchant <> nil) and (Merchant.m_boBigStorage) then begin //无限仓库
        nCode:= 2;
        bo19 := False;
        //UserItem := nil;//未使用 20080411
        if Pos(' ', sMsg) >= 0 then //折分物品名称(信件物品的名称后面加了使用次数)
          GetValidStr3(sMsg, sMsg, [' ']);
        if (m_nPayMent = 1) and not g_Config.boTryModeUseStorage then begin
          SysMsg(g_sTryModeCanotUseStorage {'试玩模式不可以使用仓库功能！！！'}, c_Red, t_Hint);
          SendDefMessage(SM_STORAGE_FAIL, 0, 0, 0, 0, '');
          Exit;
        end;
        nCode:= 3;
        if (m_BigStorageItemList <> nil) and (m_BigStorageItemList.Count > g_Config.nBigStorageLimitCount) then begin
          SysMsg(Format_ToStr(g_sBigStorageCountIsNul, [g_Config.nBigStorageLimitCount]), c_Red, t_Hint);
          SendDefMessage(SM_STORAGE_FAIL, 0, 0, 0, 0, '');
          Exit;
        end;
        nCode:= 4;
        for I := m_ItemList.Count - 1 downto 0 do begin
          if m_ItemList.Count <= 0 then Break;
          UserItem := m_ItemList.Items[I];
          if UserItem.MakeIndex = nItemIdx then begin
            nCode:= 5;
            if CheckItemValue(UserItem,2) then Break //20080314 禁止存
            else begin
              nCode:= 6;
              sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
              if PlugOfCheckCanItem(2, sCheckItemName, False, 0, 0) then Break;//禁止物品规则(禁止存) 20080729
            end;
          end;
          //取自定义物品名称
          nCode:= 7;
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sUserItemName = '' then
            sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
          nCode:= 8;
          if (UserItem.MakeIndex = nItemIdx) and (CompareText(sUserItemName, sMsg) = 0) then begin
            nCode:= 9;
            if (Merchant.m_boBigStorage) and //检查NPC是否允许存物品
              (((Merchant.m_PEnvir = m_PEnvir) and
              (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
              (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC)) then begin
              nCode:= 10;
              if g_Storage.Add(m_BigStorageItemList, m_sCharName, UserItem) then begin
                nCode:= 11;
                m_ItemList.Delete(I);
                ClearCopyItem(0, UserItem.wIndex, UserItem.MakeIndex);//清理包裹和仓库复制物品 20080816
                Dispose(UserItem);
                WeightChanged();
                SendDefMessage(SM_STORAGE_OK, 0, 0, 0, 0, '');
                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                nCode:= 12;
                if StdItem <> nil then begin//20080722 增加
                  nCode:= 23;
                  if StdItem.NeedIdentify = 1 then
                    AddGameDataLog('1' + #9 + m_sMapName + #9 +
                      IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                      m_sCharName + #9 + StdItem.Name + #9 +
                      IntToStr(UserItem.MakeIndex) + #9 +
                      '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                      '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                      '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                      '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                      '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                      IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                      IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                      IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                      IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + Merchant.m_sCharName);
                 end;
              end else begin
                SendDefMessage(SM_STORAGE_FULL, 0, 0, 0, 0, '');
              end;
              bo19 := True;
            end;
            Break;
          end;
        end;//for
      end else begin
        bo19 := False;
        nCode:= 13;
        //UserItem := nil; //未使用 20080411
        if Pos(' ', sMsg) >= 0 then //折分物品名称(信件物品的名称后面加了使用次数)
          GetValidStr3(sMsg, sMsg, [' ']);
        if (m_nPayMent = 1) and not g_Config.boTryModeUseStorage then begin
          SysMsg(g_sTryModeCanotUseStorage {'试玩模式不可以使用仓库功能！！！'}, c_Red, t_Hint);
          Exit;
        end;
        nCode:= 14;
        for I := m_ItemList.Count - 1 downto 0 do begin
          if m_ItemList.Count <= 0 then Break;
          UserItem := m_ItemList.Items[I];
          if UserItem <> nil then begin//20090206 增加
            nCode:= 15;
            if UserItem.MakeIndex = nItemIdx then begin
              if CheckItemValue(UserItem,2) then Break //20080314 禁止存
              else begin
                nCode:= 16;
                sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                if PlugOfCheckCanItem(2, sCheckItemName, False, 0, 0) then Break;//禁止物品规则(禁止存) 20080729
              end;
            end;
            //取自定义物品名称
            sUserItemName := '';
            if UserItem.btValue[13] = 1 then
              sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
            if sUserItemName = '' then
              sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
            nCode:= 17;
            if (UserItem.MakeIndex = nItemIdx) and (CompareText(sUserItemName, sMsg) = 0) then begin
              nCode:= 18;
              Merchant := UserEngine.FindMerchant(NPC);
              if (Merchant <> nil) then begin
                if (Merchant.m_boStorage) and //检查NPC是否允许存物品
                  (((Merchant.m_PEnvir = m_PEnvir) and
                  (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
                  (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC)) then begin
                  nCode:= 19;
                  if m_StorageItemList.Count < MAXBAGITEM then begin
                    nCode:= 21;
                    m_StorageItemList.Add(UserItem);
                    nCode:= 22;
                    m_ItemList.Delete(I);
                    nCode:= 23;
                    WeightChanged();
                    nCode:= 24;
                    SendDefMessage(SM_STORAGE_OK, 0, 0, 0, 0, '');
                    nCode:= 25;
                    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                    nCode:= 26;
                    if StdItem.NeedIdentify = 1 then
                      AddGameDataLog('1' + #9 + m_sMapName + #9 +
                        IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 + StdItem.Name + #9 +
                        IntToStr(UserItem.MakeIndex) + #9 +
                        '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                        '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                        '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                        '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                        '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                        IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                        IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                        IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                        IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + Merchant.m_sCharName);
                  end else begin
                    SendDefMessage(SM_STORAGE_FULL, 0, 0, 0, 0, '');
                  end;
                  bo19 := True;
                end;
              end;
              Break;
            end;
          end;
        end;//for
      end;*)
      if not bo19 then SendDefMessage(SM_STORAGE_FAIL, 0, 0, 0, 0, '');
    except   
      MainOutMessage(format('{%s} TPlayObject.ClientStorageItem Code:%d', [g_sExceptionVer, nCode]));
    end;
  finally
    m_boCanQueryBag := False; //出售物品时,不能刷新包裹 20080917
  end;
end;
//仓库取物品

procedure TPlayObject.ClientTakeBackStorageItem(NPC: TObject;
  nItemIdx: Integer; sMsg: string);
var
  Merchant: TMerchant;
  I: Integer;
  UserItem: pTUserItem;
  Item: TUserItem;
  bo19: Boolean;
  StdItem: pTStdItem;
  sUserItemName: string;
begin
  if m_boCanQueryBag then Exit; //使用物品时,不能取出物品 20081009
  Merchant := UserEngine.FindMerchant(NPC);
  case m_dwStorageType of //20090901 修改
    1: begin //移动仓库
        bo19 := False;
      //UserItem := nil;//未使用 20080411
        if Merchant = nil then Exit;
        if (m_nPayMent = 1) and not g_Config.boTryModeUseStorage then begin
          SysMsg(g_sTryModeCanotUseStorage {'试玩模式不可以使用仓库功能！！！'}, c_Red, t_Hint);
          Exit;
        end;
        if not m_boCanGetBackItem then begin
          SendMsg(Merchant, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sStorageIsLockedMsg + '\ \'
            + '仓库开锁命令: @' + g_GameCommand.UNLOCKSTORAGE.sCmd + '\'
            + '仓库加锁命令: @' + g_GameCommand.Lock.sCmd + '\'
            + '设置密码命令: @' + g_GameCommand.SETPASSWORD.sCmd + '\'
            + '修改密码命令: @' + g_GameCommand.CHGPASSWORD.sCmd);
          Exit;
        end;
        if m_StorageItemList.Count > 0 then begin
          for I := m_StorageItemList.Count - 1 downto 0 do begin //20081009
            UserItem := m_StorageItemList.Items[I];
          //取自定义物品名称
            sUserItemName := '';
            if UserItem.btValue[13] = 1 then
              sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
            if sUserItemName = '' then sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

            if (UserItem.MakeIndex = nItemIdx) and (CompareText(sUserItemName, sMsg) = 0) then begin
              if (IsAddWeightAvailable(UserEngine.GetStdItemWeight(UserItem.wIndex))) then begin
                if (Merchant <> nil) and (Merchant.m_boGetback) and //检查NPC是否允许取物品
                  (((Merchant.m_PEnvir = m_PEnvir) and
                  (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
                  (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC)) then begin
                  ClearCopyItem(0, UserItem.wIndex, UserItem.MakeIndex); //清理包裹和仓库复制物品 20080816
                  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                  if (StdItem <> nil) then begin
                    if StdItem.StdMode = 17 then begin //叠加物品自动合并 20110113
                      if not AutoItemMerger(UserItem) then begin //自动合并物品
                        if AddItemToBag(UserItem) then begin
                          SendAddItem(UserItem);
                          m_StorageItemList.Delete(I);
                          SendDefMessage(SM_TAKEBACKSTORAGEITEM_OK, nItemIdx, 0, 0, 0, '');
                          if StdItem.NeedIdentify = 1 then
                            AddGameDataLog('0' + #9 + m_sMapName + #9 +
                              IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                              m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                              '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                              '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                              '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                              '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                              '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                              IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                              IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                              IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                              IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + Merchant.m_sCharName);
                        end else begin
                          SendDefMessage(SM_TAKEBACKSTORAGEITEM_FULLBAG, 0, 0, 0, 0, '');
                        end;
                      end else begin
                        m_StorageItemList.Delete(I);
                        SendDefMessage(SM_TAKEBACKSTORAGEITEM_OK, nItemIdx, 0, 0, 0, '');
                      end;
                    end else begin
                      if AddItemToBag(UserItem) then begin
                        SendAddItem(UserItem);
                        m_StorageItemList.Delete(I);
                        SendDefMessage(SM_TAKEBACKSTORAGEITEM_OK, nItemIdx, 0, 0, 0, '');
                        if StdItem.NeedIdentify = 1 then
                          AddGameDataLog('0' + #9 + m_sMapName + #9 +
                            IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                            m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                            '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                            '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                            '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                            '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                            '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                            IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                            IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                            IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                            IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + Merchant.m_sCharName);
                      end else begin
                        SendDefMessage(SM_TAKEBACKSTORAGEITEM_FULLBAG, 0, 0, 0, 0, '');
                      end;
                    end;
                  end;
                  bo19 := True;
                end;
              end else begin
                SysMsg(g_sCanotGetItems {'无法携带更多的东西！！！'}, c_Red, t_Hint);
              end;
              Break;
            end;
          end; //for
        end;
      end; //1
    2: begin //无限仓库
        if (Merchant <> nil) and (Merchant.m_boBigGetBack) then begin
          bo19 := False;
          if (m_nPayMent = 1) and not g_Config.boTryModeUseStorage then begin
            SysMsg(g_sTryModeCanotUseStorage {'试玩模式不可以使用仓库功能！！！'}, c_Red, t_Hint);
            Exit;
          end;
          if not m_boCanGetBackItem then begin
            SendMsg(Merchant, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sStorageIsLockedMsg + '\ \'
              + '仓库开锁命令: @' + g_GameCommand.UNLOCKSTORAGE.sCmd + '\'
              + '仓库加锁命令: @' + g_GameCommand.Lock.sCmd + '\'
              + '设置密码命令: @' + g_GameCommand.SETPASSWORD.sCmd + '\'
              + '修改密码命令: @' + g_GameCommand.CHGPASSWORD.sCmd);
            Exit;
          end;
          if g_Storage.GetItem(m_BigStorageItemList, sMsg, nItemIdx, Item) then begin
            New(UserItem);
            FillChar(UserItem^, SizeOf(TUserItem), #0); //20080820 增加
            UserItem^ := Item;
            if (IsAddWeightAvailable(UserEngine.GetStdItemWeight(UserItem.wIndex))) then begin
              if (Merchant <> nil) and (Merchant.m_boBigGetBack) and //检查NPC是否允许取物品
                (((Merchant.m_PEnvir = m_PEnvir) and
                (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
                (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC)) then begin
                ClearCopyItem(0, UserItem.wIndex, UserItem.MakeIndex); //清理包裹和仓库复制物品 20080816
                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
{$IF M2var = 1}
                if UserItem.AddValue[2] <> 255 then begin //临时处理14-19属性值，过N版后去掉 20110528
                  UserItem.AddValue[2] := UserItem.btValue[14];
                  UserItem.btValue[14] := 0;
                  SetItemState(UserItem, 0, UserItem.AddValue[2]);
                  SetItemState(UserItem, 1, UserItem.btValue[15]);
                  SetItemState(UserItem, 2, UserItem.btValue[16]);
                  SetItemState(UserItem, 3, UserItem.btValue[17]);
                  SetItemState(UserItem, 4, UserItem.btValue[18]);
                  SetItemState(UserItem, 5, UserItem.btValue[19]);
                  UserItem.btValue[15] := 0;
                  UserItem.btValue[16] := 0;
                  UserItem.btValue[17] := 0;
                  UserItem.btValue[18] := 0;
                  UserItem.btValue[19] := 0;
                  UserItem.AddValue[2] := 255;
                end;
{$IFEND}
                if StdItem <> nil then begin
                  if StdItem.StdMode = 17 then begin //叠加物品自动合并 20110113
                    if not AutoItemMerger(UserItem) then begin //自动合并物品
                      if AddItemToBag(UserItem) then begin
                        SendAddItem(UserItem);
                        g_Storage.Delete(m_BigStorageItemList, sMsg, nItemIdx);
                        SendDefMessage(SM_TAKEBACKSTORAGEITEM_OK, nItemIdx, 0, 0, 0, '');

                        if StdItem.NeedIdentify = 1 then
                          AddGameDataLog('0' + #9 + m_sMapName + #9 +
                            IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                            m_sCharName + #9 + StdItem.Name + #9 +
                            IntToStr(UserItem.MakeIndex) + #9 +
                            '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                            '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                            '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                            '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                            '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                            IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                            IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                            IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                            IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + Merchant.m_sCharName);
                      end else begin
                        Dispose(UserItem);
                        SendDefMessage(SM_TAKEBACKSTORAGEITEM_FULLBAG, 0, 0, 0, 0, '');
                      end;
                    end else begin
                      g_Storage.Delete(m_BigStorageItemList, sMsg, nItemIdx);
                      SendDefMessage(SM_TAKEBACKSTORAGEITEM_OK, nItemIdx, 0, 0, 0, '');
                    end;
                  end else begin
                    if AddItemToBag(UserItem) then begin
                      SendAddItem(UserItem);
                      g_Storage.Delete(m_BigStorageItemList, sMsg, nItemIdx);
                      SendDefMessage(SM_TAKEBACKSTORAGEITEM_OK, nItemIdx, 0, 0, 0, '');

                      if StdItem.NeedIdentify = 1 then
                        AddGameDataLog('0' + #9 + m_sMapName + #9 +
                          IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                          m_sCharName + #9 + StdItem.Name + #9 +
                          IntToStr(UserItem.MakeIndex) + #9 +
                          '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                          '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                          '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                          '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                          '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                          IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                          IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                          IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                          IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + Merchant.m_sCharName);
                    end else begin
                      Dispose(UserItem);
                      SendDefMessage(SM_TAKEBACKSTORAGEITEM_FULLBAG, 0, 0, 0, 0, '');
                    end;
                  end;
                end else Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                bo19 := True;
              end;
            end else begin
              Dispose(UserItem);
              SysMsg(g_sCanotGetItems {'无法携带更多的东西！！！'}, c_Red, t_Hint);
            end;
          end;
        end;
      end; //2
  end;

  (*Merchant := UserEngine.FindMerchant(NPC);
  if (Merchant <> nil) and (Merchant.m_boBigGetBack) then begin //无限仓库
    bo19 := False;
    if (m_nPayMent = 1) and not g_Config.boTryModeUseStorage then begin
      SysMsg(g_sTryModeCanotUseStorage {'试玩模式不可以使用仓库功能！！！'}, c_Red, t_Hint);
      Exit;
    end;
    if not m_boCanGetBackItem then begin
      SendMsg(Merchant, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sStorageIsLockedMsg + '\ \'
        + '仓库开锁命令: @' + g_GameCommand.UNLOCKSTORAGE.sCmd + '\'
        + '仓库加锁命令: @' + g_GameCommand.Lock.sCmd + '\'
        + '设置密码命令: @' + g_GameCommand.SETPASSWORD.sCmd + '\'
        + '修改密码命令: @' + g_GameCommand.CHGPASSWORD.sCmd);
      Exit;
    end;
    if g_Storage.GetItem(m_BigStorageItemList, sMsg, nItemIdx, Item) then begin
      New(UserItem);
      FillChar(UserItem^, SizeOf(TUserItem), #0);//20080820 增加
      UserItem^ := Item;
      if (IsAddWeightAvailable(UserEngine.GetStdItemWeight(UserItem.wIndex))) then begin
        if (Merchant <> nil) and (Merchant.m_boBigGetBack) and //检查NPC是否允许取物品
          (((Merchant.m_PEnvir = m_PEnvir) and
          (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
          (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC)) then begin
          ClearCopyItem(0,UserItem.wIndex, UserItem.MakeIndex);//清理包裹和仓库复制物品 20080816
          if AddItemToBag(UserItem) then begin
            SendAddItem(UserItem);
            g_Storage.Delete(m_BigStorageItemList, sMsg, nItemIdx);
            SendDefMessage(SM_TAKEBACKSTORAGEITEM_OK, nItemIdx, 0, 0, 0, '');
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('0' + #9 + m_sMapName + #9 +
                IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                m_sCharName + #9 + StdItem.Name + #9 +
                IntToStr(UserItem.MakeIndex) + #9 +
                '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + Merchant.m_sCharName);
          end else begin
            Dispose(UserItem);
            SendDefMessage(SM_TAKEBACKSTORAGEITEM_FULLBAG, 0, 0, 0, 0, '');
          end;
          bo19 := True;
        end;
      end else begin
        Dispose(UserItem);
        SysMsg(g_sCanotGetItems {'无法携带更多的东西！！！'}, c_Red, t_Hint);
      end;
    end;
  end else begin
    bo19 := False;
    //UserItem := nil;//未使用 20080411
    Merchant := UserEngine.FindMerchant(NPC);
    if Merchant = nil then Exit;
    if (m_nPayMent = 1) and not g_Config.boTryModeUseStorage then begin
      SysMsg(g_sTryModeCanotUseStorage {'试玩模式不可以使用仓库功能！！！'}, c_Red, t_Hint);
      Exit;
    end;
    if not m_boCanGetBackItem then begin
      SendMsg(Merchant, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sStorageIsLockedMsg + '\ \'
        + '仓库开锁命令: @' + g_GameCommand.UNLOCKSTORAGE.sCmd + '\'
        + '仓库加锁命令: @' + g_GameCommand.Lock.sCmd + '\'
        + '设置密码命令: @' + g_GameCommand.SETPASSWORD.sCmd + '\'
        + '修改密码命令: @' + g_GameCommand.CHGPASSWORD.sCmd);
      Exit;
    end;
    if  m_StorageItemList.Count > 0 then begin
      for I:= m_StorageItemList.Count - 1 downto 0 do begin//20081009
        UserItem := m_StorageItemList.Items[I];
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

        if (UserItem.MakeIndex = nItemIdx) and (CompareText(sUserItemName, sMsg) = 0) then begin
          if (IsAddWeightAvailable(UserEngine.GetStdItemWeight(UserItem.wIndex))) then begin
            if (Merchant <> nil) and (Merchant.m_boGetback) and //检查NPC是否允许取物品
              (((Merchant.m_PEnvir = m_PEnvir) and
              (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
              (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC)) then begin
              ClearCopyItem(0,UserItem.wIndex, UserItem.MakeIndex);//清理包裹和仓库复制物品 20080816
              if AddItemToBag(UserItem) then begin
                SendAddItem(UserItem);
                m_StorageItemList.Delete(I);
                SendDefMessage(SM_TAKEBACKSTORAGEITEM_OK, nItemIdx, 0, 0, 0, '');
                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                if StdItem.NeedIdentify = 1 then
                  AddGameDataLog('0' + #9 + m_sMapName + #9 +
                    IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                    m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 +
                    '('+IntToStr(LoWord(StdItem.DC))+'/'+IntToStr(HiWord(StdItem.DC))+')'+
                    '('+IntToStr(LoWord(StdItem.MC))+'/'+IntToStr(HiWord(StdItem.MC))+')'+
                    '('+IntToStr(LoWord(StdItem.SC))+'/'+IntToStr(HiWord(StdItem.SC))+')'+
                    '('+IntToStr(LoWord(StdItem.AC))+'/'+IntToStr(HiWord(StdItem.AC))+')'+
                    '('+IntToStr(LoWord(StdItem.MAC))+'/'+IntToStr(HiWord(StdItem.MAC))+')'+
                    IntToStr(UserItem.btValue[0])+'/'+IntToStr(UserItem.btValue[1])+'/'+IntToStr(UserItem.btValue[2])+'/'+
                    IntToStr(UserItem.btValue[3])+'/'+IntToStr(UserItem.btValue[4])+'/'+IntToStr(UserItem.btValue[5])+'/'+
                    IntToStr(UserItem.btValue[6])+'/'+IntToStr(UserItem.btValue[7])+'/'+IntToStr(UserItem.btValue[8])+'/'+
                    IntToStr(UserItem.btValue[14])+'['+IntToStr(UserItem.Dura)+'/'+inttostr(UserItem.DuraMax)+']'+ #9 + Merchant.m_sCharName);
              end else begin
                SendDefMessage(SM_TAKEBACKSTORAGEITEM_FULLBAG, 0, 0, 0, 0, '');
              end;
              bo19 := True;
            end;
          end else begin
            SysMsg(g_sCanotGetItems {'无法携带更多的东西！！！'}, c_Red, t_Hint);
          end;
          Break;
        end;
      end;//for
    end;
  end; *)
  if Merchant = nil then Exit;
  if not bo19 then SendDefMessage(SM_TAKEBACKSTORAGEITEM_FAIL, 0, 0, 0, 0, '');
end;

function TBaseObject.CheckItems(sItemName: string): pTUserItem;
var
  I: Integer;
  UserItem: pTUserItem;
begin
  Result := nil;
  if m_ItemList.Count > 0 then begin //20080628
    for I := 0 to m_ItemList.Count - 1 do begin
      UserItem := m_ItemList.Items[I];
      if UserItem <> nil then begin //20090310
        if CompareText(UserEngine.GetStdItemName(UserItem.wIndex), sItemName) = 0 then begin
          Result := UserItem;
          Break;
        end;
      end;
    end; // for
  end;
end;

procedure TPlayObject.MakeSaveRcd(var HumanRcd: THumDataInfo);
var
  I, J, K: Integer;
  HumData: pTHumData;
  HumItems: pTHumItems;
  HumAddItems: pTHumAddItems;
  BagItems: pTBagItems;
  HumMagics: pTHumMagics;
{$IF M2Version <> 2}
  HumNGMagics: pTHumNGMagics;
{$IFEND}
  UserMagic: pTUserMagic;
  StorageItems: pTStorageItems;
  nCode: byte; //20090807
begin
  nCode := 0;
  try
    HumanRcd.Header.boIsHero := False;
    HumData := @HumanRcd.Data;
    HumData.sChrName := m_sCharName;
    HumData.sCurMap := m_sMapName;
    HumData.wCurX := m_nCurrX;
    HumData.wCurY := m_nCurrY;
    HumData.btDir := m_btDirection;
    HumData.btHair := m_btHair;
    HumData.btSex := m_btGender;
    HumData.btJob := m_btJob;
    HumData.nGold := m_nGold;

    nCode := 1;
    HumData.Abil.Level := m_Abil.Level;
    HumData.Abil.HP := LoWord(m_WAbil.HP); //20091026 修改
    HumData.Abil.AC := HiWord(m_WAbil.HP); //20091026

    HumData.Abil.MP := LoWord(m_WAbil.MP); //20091026 修改
    HumData.Abil.MAC := HiWord(m_WAbil.MP); //20091026

    HumData.Abil.MaxHP := LoWord(m_Abil.MaxHP); //20091026 修改
    HumData.Abil.DC := HiWord(m_Abil.MaxHP); //20091026

    HumData.Abil.MaxMP := LoWord(m_Abil.MaxMP); //20091026 修改
    HumData.Abil.MC := HiWord(m_Abil.MaxMP); //20091026

    HumData.Abil.nExp := m_Abil.nExp;
    HumData.Abil.nMaxExp := m_Abil.nMaxExp;
    HumData.Abil.Weight := m_Abil.Weight;
    HumData.Abil.MaxWeight := m_Abil.MaxWeight;
    HumData.Abil.WearWeight := m_Abil.WearWeight; //此处出现越界 Byte:= Word;
    HumData.Abil.MaxWearWeight := m_Abil.MaxWearWeight; //此处出现越界 Byte:= Word;
    HumData.Abil.HandWeight := m_Abil.HandWeight; //此处出现越界 Byte:= Word;
    HumData.Abil.MaxHandWeight := m_Abil.MaxHandWeight; //此处出现越界 Byte:= Word;

    HumData.Abil.NG := LoWord(m_Skill69NH); //内功当前内力值 20110226
    HumData.Abil.MaxNG := HiWord(m_Skill69NH); //内力值上限 20110226
    HumData.UnKnow[37] := m_btUnParalysis; //无视麻痹剩余时间 By TasNat at: 2012-04-23 18:50:05
    HumData.UnKnow[6] := Integer(m_boTrainingNG); //是否学习过内功 20081002
    if m_boTrainingNG then begin
      HumData.UnKnow[7] := LoByte(m_NGLevel); //内功等级 20081204
      HumData.UnKnow[33] := HiByte(m_NGLevel); //内功等级
    end else begin
      HumData.UnKnow[7] := 0;
      HumData.UnKnow[33] := 0;
    end;
    HumData.nExpSkill69 := m_ExpSkill69; //内功当前经验 20080930
    HumData.n_Reserved := m_Abil.Alcohol; //酒量 20080622
    HumData.n_Reserved1 := m_Abil.MaxAlcohol; //酒量上限 20080622
    HumData.n_Reserved2 := m_Abil.WineDrinkValue; //醉酒度 2008623
    HumData.btUnKnow2[2] := n_DrinkWineQuality; //饮酒时酒的品质
    HumData.UnKnow[4] := n_DrinkWineAlcohol; //饮酒时酒的度数 20080624
    HumData.UnKnow[5] := m_btMagBubbleDefenceLevel; //魔法盾等级 20080811

    HumData.nReserved1 := m_Abil.MedicineValue; //当前药力值 20080623
    HumData.nReserved2 := m_Abil.MaxMedicineValue; //药力值上限 20080623
    HumData.boReserved3 := n_DrinkWineDrunk; //人是否喝酒醉了 20080627
    HumData.nReserved3 := dw_UseMedicineTime; //使用药酒时间,计算长时间没使用药酒 20080623
    HumData.n_Reserved3 := n_MedicineLevel; //药力值等级 20080623
    if g_Config.boSaveHighLevelKillMonFixExp then //是否保存真视经验时间 20090213
      HumData.m_nReserved4 := m_dwHighLevelKillMonFixExpTime; //真视秘籍使用时间 20090213
    HumData.m_nReserved5 := m_dwUseItmeChangMsgFColorTime; //使用物品改变说话颜色的使用时间(秒) 玄绿,玄紫,玄褐 20090221
    HumData.UnKnow[8] := m_dwUseItmeChangMsgFColorType; //颜色类型

    HumData.m_nReserved1 := m_nDecDamage; //吸伤属性 20090618
    if g_Config.boClearGamePoint then
      HumData.Reserved5 := m_ClearGamePointDate; //初始游戏点的日期
{$IF M2Version = 1}
    HumData.btDivorce := LoWord(dw_UseMedicineTime1);
    HumData.UnKnow[25] := HiWord(dw_UseMedicineTime1);

    HumData.UnKnow[35] := Integer(m_boOpenupSkill95); //打通斗转99级
    HumData.Reserved3 := m_JingYuanValue; //当前精元值
    if m_Magic95Skill <> nil then HumData.Reserved4 := m_WAbil.TransferValue; //当前斗转值
    HumData.Exp68 := m_InitialJingYuanDate; //初始精元值的日期

    HumData.UnKnow[29] := Integer(m_boUser4BatterSkill); //使用第四格连击 20100720
    HumData.UnKnow[21] := Integer(m_boTrainBatterSkill); //是否学习过连击技能 20090702
  //经络数据
    HumData.UnKnow[9] := m_wHumanPulseArr[0].nPulsePoint;
    HumData.UnKnow[10] := m_wHumanPulseArr[0].nPulseLevel;

    HumData.UnKnow[11] := m_wHumanPulseArr[1].nPulsePoint;
    HumData.UnKnow[12] := m_wHumanPulseArr[1].nPulseLevel;

    HumData.UnKnow[13] := m_wHumanPulseArr[2].nPulsePoint;
    HumData.UnKnow[14] := m_wHumanPulseArr[2].nPulseLevel;

    HumData.UnKnow[15] := m_wHumanPulseArr[3].nPulsePoint;
    HumData.UnKnow[16] := m_wHumanPulseArr[3].nPulseLevel;

    HumData.UnKnow[32] := m_wHumanPulseArr[4].nPulsePoint; //奇经

    HumData.UnKnow[22] := m_SetBatterKey; //第一个连击技能格 20090702
    HumData.UnKnow[23] := m_SetBatterKey1; //第二个连击技能格 20090702
    HumData.UnKnow[24] := m_SetBatterKey2; //第三个连击技能格 20090702
    HumData.UnKnow[28] := m_SetBatterKey3; //第四个连击技能格 20100719
{$IFEND}
    HumData.UnKnow[26] := Integer(m_boProtectionDefence); //是否学过护体神盾 20091126
    HumData.UnKnow[17] := m_PulseAddAC;
    HumData.UnKnow[18] := m_PulseAddAC1;
    HumData.UnKnow[19] := m_PulseAddMAC;
    HumData.UnKnow[20] := m_PulseAddMAC1;
    nCode := 2;

    //HumData.Abil:=m_Abil;
    HumData.Abil.HP := m_WAbil.HP;
    HumData.Abil.MP := m_WAbil.MP;

    HumData.wStatusTimeArr := m_wStatusTimeArr;
    HumData.sHomeMap := m_sHomeMap;
    HumData.wHomeX := m_nHomeX;
    HumData.wHomeY := m_nHomeY;
    HumData.nPKPOINT := m_nPkPoint;
    HumData.BonusAbil := m_BonusAbil; // 08/09
    HumData.nBonusPoint := m_nBonusPoint; // 08/09
    HumData.sStoragePwd := m_sStoragePwd;
    HumData.btCreditPoint := m_btCreditPoint;
    HumData.btReLevel := m_btReLevel;

    HumData.sMasterName := m_sMasterName;
    HumData.boMaster := m_boMaster;
    HumData.sDearName := m_sDearName;

    //HumanRCD.Header.sName:= m_sDeputyHeroName;//副将英雄名字 利用HumanRCD.Header.sName传递副将名称，DBS判断后写入HumHero.DB
    HumData.sHeroChrName1 := m_sDeputyHeroName; //副将英雄名字 20110130
    HumData.btStatus := m_btDeputyHeroJob; //所选副将职业 0-战 1-法 2-道 3-刺客
    HumData.m_nReserved2 := m_nHeroLevel1; //主将英雄等级
    HumData.m_nReserved3 := m_nHeroLevel2; //副将英雄等级
    HumData.m_nReserved7 := m_nHeroNGLevel1; //主将英雄内功等级
    HumData.m_nReserved8 := m_nHeroNGLevel2; //副将英雄内功等级
    HumData.nLoyal := m_nMainExp; //主将累计经验(当副将等级低于主将3级时使用)
    HumData.m_nReserved6 := m_nMainNGExp; //主将累计内功经验(当副将等级低于主将3级时使用)
    HumData.UnKnow[27] := Integer(m_boHeroAutoPractice); //副将英雄是否自动修炼
    HumData.Abil.Sc := MakeWord(m_nHeroAutoPracticePlace, m_nHeroAutoPracticeStrength); //自动修炼修炼场所, 强度
    HumData.MaxExp68 := m_HeroAutoPracticeTime; //自动修炼累计时长
    HumData.nGameGold := m_nGameGold;
    HumData.nGameDiaMond := m_nGameDiaMond; //金刚石
    HumData.nGameGird := m_nGameGird; //灵符
    HumData.btGameGlory := m_btGameGlory; //荣誉
    HumData.nGamePoint := m_nGamePoint;
    HumData.nPayMentPoint := m_nPayMentPoint; //秒卡点
    nCode := 3;
    if g_Config.boSaveExpRate then begin //是否保存双倍经验时间 20080412
      HumData.nEXPRATE := m_nKillMonExpRate - m_nItmeIncMonExpRate; //20071230 经验倍数
      if HumData.nEXPRATE <= 0 then HumData.nEXPRATE := 100; //20081229 临时处理用
      HumData.nExpTime := m_dwKillMonExpRateTime; //20071230 双倍经验时间
    end else begin
      HumData.nEXPRATE := 100; //20080506
      HumData.nExpTime := 0; //20080506
    end;

    if m_boAllowGroup then HumData.btAllowGroup := 1
    else HumData.btAllowGroup := 0;
    HumData.btF9 := btB2;
    HumData.btAttatckMode := m_btAttatckMode;
    HumData.btIncHealth := m_nIncHealth;
    HumData.btIncSpell := m_nIncSpell;
    HumData.btIncHealing := m_nIncHealing;
    HumData.btFightZoneDieCount := m_nFightZoneDieCount;
    HumData.sAccount := m_sUserID;
    HumData.boLockLogon := m_boLockLogon;
    HumData.wContribution := m_wContribution;
    HumData.nHungerStatus := m_nHungerStatus;
    HumData.boAllowGuildReCall := m_boAllowGuildReCall;
    HumData.wGroupRcallTime := m_wGroupRcallTime;
    HumData.dBodyLuck := m_dBodyLuck;
    HumData.boAllowGroupReCall := m_boAllowGroupReCall;
    //HumData.QuestUnitOpen := m_QuestUnitOpen;
    //HumData.QuestUnit := m_QuestUnit;
    HumData.btLastOutStatus := m_btLastOutStatus; //2006-01-12增加 退出状态 1为死亡退出
    HumData.wMasterCount := m_wMasterCount; //出师徒弟数
    HumData.btUnKnow2[0] := Integer(bo_YBDEAL); //是否开通元宝寄售 20080316
    HumData.n_WinExp := m_nWinExp; //20080221 聚灵珠  累计经验
    HumData.n_UsesItemTick := n_UsesItemTick; //聚灵珠聚集时间 20080221
    HumData.QuestFlag := m_QuestFlag;
    HumData.boHasHero := m_boHasHero;
    HumData.boReserved1 := m_boHasHeroTwo;
    HumData.boIsHero := False;
    HumData.sHeroChrName := m_sHeroCharName;
    HumData.btUnKnow2[1] := n_HeroSave; //是否保存英雄 20080514
    HumData.btHeroType := n_myHeroTpye; //角色身上带的英雄所属的类型  20080515
    HumData.boReserved := m_boPlayDrink; //是否请过酒 T-请过酒 20080515

    HumData.m_GiveDate := m_GiveGuildFountationDate; //人物领取行会酒泉日期 20080625
    HumData.boReserved2 := m_boMakeWine; //是否酿酒 20080620
    HumData.nReserved := m_MakeWineTime; //酿酒的时间,即还有多长时间可以取回酒 20080620
    HumData.UnKnow[0] := n_MakeWineItmeType; //酿酒后,应该可以得到酒的类型 2008020
    HumData.UnKnow[1] := n_MakeWineType; //酿酒的类型 1-普通酒 2-药酒  20080620
    HumData.UnKnow[2] := n_MakeWineQuality; //酿酒后,应该可以得到酒的品质 20080620
    HumData.UnKnow[3] := n_MakeWineAlcohol; //酿酒后,应该可以得到酒的酒精度 20080620
    nCode := 4;
    HumItems := @HumanRcd.Data.HumItems;
    HumItems[U_DRESS] := m_UseItems[U_DRESS];
    HumItems[U_WEAPON] := m_UseItems[U_WEAPON];
    HumItems[U_RIGHTHAND] := m_UseItems[U_RIGHTHAND];
    nCode := 5;
    HumItems[U_HELMET] := m_UseItems[U_NECKLACE];
    HumItems[U_NECKLACE] := m_UseItems[U_HELMET];
    nCode := 6;
    HumItems[U_ARMRINGL] := m_UseItems[U_ARMRINGL];
    HumItems[U_ARMRINGR] := m_UseItems[U_ARMRINGR];
    HumItems[U_RINGL] := m_UseItems[U_RINGL];
    HumItems[U_RINGR] := m_UseItems[U_RINGR];
    nCode := 7;
    //修改1.76支持四格By TasNat at: 2012-10-20 11:34:20
    HumAddItems := @HumanRcd.Data.HumAddItems;
    HumAddItems[U_BUJUK] := m_UseItems[U_BUJUK];
    HumAddItems[U_BELT] := m_UseItems[U_BELT];
    HumAddItems[U_BOOTS] := m_UseItems[U_BOOTS];
    HumAddItems[U_DRUM] := m_UseItems[U_DRUM];
    HumAddItems[U_CHARM] := m_UseItems[U_CHARM];
    HumAddItems[U_ZHULI] := m_UseItems[U_ZHULI]; //20080416 斗笠
{$IF M2Version <> 2}
    HumData.UnKnow[36] := m_nHeartType; //心法类型
    //HumData.UnKnow[37] := m_nHeartType2; //心法类型
    HumData.sHeartName := m_sHeartName; //心法名称
    HumData.HumTitles := m_wHumTitles; //人物称号
    HumData.UnKnow[34] := m_nDieCount; //人物死亡计数


    if m_SpiritMedia.MakeIndex > 0 then HumData.SpiritMedia := m_SpiritMedia; //灵媒装备位 20100827
    HumData.UnKnow[31] := m_nEnergyValue; //精力值(制造神秘卷轴)
    HumData.UnKnow[30] := m_nLuckyValue; //幸运值(制造神秘卷轴)
    HumData.Proficiency := m_nProficiency; //熟练度(制造神秘卷轴)
{$IFEND}
    HumData.Reserved2 := n_LevelOrder; //人物排行
    nCode := 8;
    BagItems := @HumanRcd.Data.BagItems;
    if m_ItemList.Count > 0 then begin //20080628
      for I := 0 to m_ItemList.Count - 1 do begin
        if I >= MAXBAGITEM then Break;
        nCode := 9;
        if pTUserItem(m_ItemList.Items[I]) <> nil then begin //20090212 增加
          nCode := 10;
          if (pTUserItem(m_ItemList.Items[I]).wIndex = 0) or (pTUserItem(m_ItemList.Items[I]).MakeIndex <= 0) then Continue; //20080915 ID为0的物品则不保存 20090502制造ID为0也不保存
          nCode := 11;
          BagItems[I] := pTUserItem(m_ItemList.Items[I])^;
        end;
      end;
    end;
    nCode := 9;
    StorageItems := @HumanRcd.Data.StorageItems;
    if m_StorageItemList.Count > 0 then begin //20080629
      for I := 0 to m_StorageItemList.Count - 1 do begin
        if I >= MAXBAGITEM then Break;
        nCode := 16;
        if (pTUserItem(m_StorageItemList.Items[I]).wIndex = 0) or (pTUserItem(m_StorageItemList.Items[I]).MakeIndex <= 0) then Continue; //20080915 ID为0的物品则不保存  20090502制造ID为0也不保存
        nCode := 17;
        StorageItems[I] := pTUserItem(m_StorageItemList.Items[I])^;
      end;
    end;
    nCode := 12;
    HumMagics := @HumanRcd.Data.HumMagics;
{$IF M2Version <> 2}
    HumNGMagics := @HumanRcd.Data.HumNGMagics; //20081001 内功技能
{$IFEND}
    if m_MagicList <> nil then begin //20080629
      J := 0;
      K := 0;
      for I := 0 to m_MagicList.Count - 1 do begin
        nCode := 13;
        UserMagic := m_MagicList.Items[I];
        if UserMagic <> nil then begin //20090212 增加
          nCode := 14;
          if UserMagic.MagicInfo.wMagicId = SKILL_75 then Continue; //原护体神盾技能不保存 20091126
          nCode := 140;
          if (UserMagic.MagicInfo.sDescr = '内功') and (UserMagic.MagicInfo.wMagicId <> SKILL_102) then begin
{$IF M2Version <> 2}                                                                    //唯我独尊 By TasNat at: 2012-03-13 19:59:04
            if K >= MAXNGMAGIC then Continue;
            nCode := 145;
            HumNGMagics[K].wMagIdx := UserMagic.wMagIdx;
            nCode := 146;
            HumNGMagics[K].btLevel := UserMagic.btLevel;
            nCode := 147;
            HumNGMagics[K].btKey := UserMagic.btKey;
            nCode := 148;
            HumNGMagics[K].nTranPoint := UserMagic.nTranPoint;
            Inc(K);
{$IFEND}
          end else begin
            nCode := 141;
            if J >= MAXMAGIC then Continue;
            HumMagics[J].wMagIdx := UserMagic.wMagIdx;
            nCode := 142;
            HumMagics[J].btLevel := UserMagic.btLevel;
            nCode := 143;
            HumMagics[J].btKey := UserMagic.btKey;
            nCode := 144;
            HumMagics[J].nTranPoint := UserMagic.nTranPoint;
            HumMagics[J].btLevelEx := UserMagic.btLevelEx;
            Inc(J);
          end;
        end;
      end;
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.MakeSaveRcd Code:%d.%p', [g_sExceptionVer, nCode, ExceptAddr]));
  end;
end;

function TBaseObject.sub_4C3538: Integer;
var
  nC, n10: Integer;
begin
  Result := 0;
  nC := -1;
  while (nC <> 2) do begin
    n10 := -1;
    while (n10 <> 2) do begin
      if not m_PEnvir.CanWalk(m_nCurrX + nC, m_nCurrY + n10, False) then begin
        if (nC <> 0) or (n10 <> 0) then Inc(Result);
      end;
      Inc(n10);
    end;
    Inc(nC);
  end;
end;

procedure TPlayObject.RefRankInfo(nRankNo: Integer; sRankName: string);
begin
  m_nGuildRankNo := nRankNo;
  m_sGuildRankName := sRankName;
  SendMsg(Self, RM_CHANGEGUILDNAME, 0, 0, 0, 0, '');
end;

//清理自己背包物品 By TasNat at: 2012-10-17 11:01:05
procedure TBaseObject.ClearBagItem;
var
  I: Integer;
  UserItem: pTUserItem;
  DelList: TStringList;
begin
  DelList := nil;

  try
    m_boOperationItemList := True; //正在操作背包列表 20080928
    if m_ItemList.Count > 0 then begin
      for I := m_ItemList.Count - 1 downto 0 do begin
        UserItem := m_ItemList.Items[I];
        if DelList = nil then DelList := TStringList.Create;
        DelList.AddObject(UserEngine.GetStdItemName(UserItem.wIndex), TObject(UserItem.MakeIndex));
        Dispose(UserItem);
        m_ItemList.Delete(I); //20080928
      end;
      m_ItemList.Clear;
    end;
    if DelList <> nil then begin
      if (m_btRaceServer = RC_HEROOBJECT) and (THeroObject(Self).m_Master <> nil) then
        THeroObject(Self).m_Master.SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '')
      else

      SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
    end;
  finally
    m_boOperationItemList := False; //正在操作背包列表 20080928
  end;
end;

function TBaseObject.DelBagItem(nIndex: Integer): Boolean;
begin
  Result := False;
  if (nIndex < 0) or (nIndex >= m_ItemList.Count) then Exit;
  if pTUserItem(m_ItemList.Items[nIndex]) <> nil then begin
    Dispose(pTUserItem(m_ItemList.Items[nIndex]));
    m_ItemList.Delete(nIndex);
    Result := True;
  end;
  if Result then WeightChanged();
end;

function TBaseObject.DelBagItem(nItemIndex: Integer;
  sItemName: string): Boolean;
var
  I: Integer;
  UserItem: pTUserItem;
begin
  Result := False;
  for I := m_ItemList.Count - 1 downto 0 do begin
    if m_ItemList.Count <= 0 then Break;
    UserItem := m_ItemList.Items[I];
    if (UserItem.MakeIndex = nItemIndex) and
      (CompareText(UserEngine.GetStdItemName(UserItem.wIndex), sItemName) = 0) then begin
      m_ItemList.Delete(I);
      Dispose(UserItem);
      Result := True;
      Break;
    end;
  end;
  if Result then WeightChanged();
end;

function TBaseObject.DelBagItem(UserItem: pTUserItem): Boolean;
var
  I: Integer;
  Item: pTUserItem;
begin
  Result := False;
  for I := m_ItemList.Count - 1 downto 0 do begin
    if m_ItemList.Count <= 0 then Break;
    Item := m_ItemList.Items[I];
    if UserItem.wIndex = Item.wIndex then begin
      m_ItemList.Delete(I);
      Dispose(Item);
      Result := True;
      Break;
    end;
  end;
  if Result then WeightChanged();
end;

procedure TPlayObject.GetOldAbil(var OAbility: TOAbility);
begin
  FillChar(OAbility, SizeOf(TOAbility), #0);
  OAbility.Level := m_WAbil.Level;
  OAbility.AC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.AC)), _MIN(High(Byte), HiWord(m_WAbil.AC)));
  OAbility.MAC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.MAC)), _MIN(High(Byte), HiWord(m_WAbil.MAC)));
  OAbility.DC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.DC)), _MIN(High(Byte), HiWord(m_WAbil.DC)));
  OAbility.MC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.MC)), _MIN(High(Byte), HiWord(m_WAbil.MC)));
  OAbility.SC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.SC)), _MIN(High(Byte), HiWord(m_WAbil.SC)));
  OAbility.HP := m_WAbil.HP;
  OAbility.MP := m_WAbil.MP;
  OAbility.MaxHP := m_WAbil.MaxHP;
  OAbility.MaxMP := m_WAbil.MaxMP;
  OAbility.nExp := m_WAbil.nExp;
  OAbility.nMaxExp := m_WAbil.nMaxExp;
  OAbility.Weight := m_WAbil.Weight;
  OAbility.MaxWeight := m_WAbil.MaxWeight;
  OAbility.WearWeight := _MIN(High(Byte), m_WAbil.WearWeight);
  OAbility.MaxWearWeight := _MIN(High(Byte), m_WAbil.MaxWearWeight);
  OAbility.HandWeight := _MIN(High(Byte), m_WAbil.HandWeight);
  OAbility.MaxHandWeight := _MIN(High(Byte), m_WAbil.MaxHandWeight);
end;

function TPlayObject.GetHitMsgCount: Integer;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  Result := 0;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    if m_MsgList.Count > 0 then begin //20080629
      for I := 0 to m_MsgList.Count - 1 do begin
        SendMessage := m_MsgList.Items[I];
        if (SendMessage.wIdent = CM_HIT) or
          (SendMessage.wIdent = CM_HIT_107) or
          (SendMessage.wIdent = CM_HEAVYHIT) or
          (SendMessage.wIdent = CM_BIGHIT) or
          (SendMessage.wIdent = CM_POWERHIT) or
          (SendMessage.wIdent = CM_LONGHIT) or
{$IF M2Version <> 2}
        (SendMessage.wIdent = CM_LONGHITFORFENGHAO) or
          (SendMessage.wIdent = CM_DAILYFORFENGHAO) or //逐日粉红效果
          (SendMessage.wIdent = CM_FIREHITFORFENGHAO) {烈火} or
{$IFEND}
        (SendMessage.wIdent = CM_LONGHIT4) or //四级刺杀
          (SendMessage.wIdent = CM_WIDEHIT) or
          (SendMessage.wIdent = CM_WIDEHIT4) or //圆月弯刀
          (SendMessage.wIdent = CM_CRSHIT) or
          (SendMessage.wIdent = CM_DAILY) or //逐日剑法
          (SendMessage.wIdent = CM_BLOODSOUL) or //血魄一击(战)
          (SendMessage.wIdent = CM_FIREHIT) {烈火} or
          (SendMessage.wIdent = CM_4FIREHIT) {4级烈火 20080112} then begin
          Inc(Result);
        end;
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;
//取攻击消息数量

function TPlayObject.GetSpellMsgCount: Integer;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  Result := 0;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    if m_MsgList.Count > 0 then begin //20080629
      for I := 0 to m_MsgList.Count - 1 do begin
        SendMessage := m_MsgList.Items[I];
        if (SendMessage.wIdent = CM_SPELL) then begin
          Inc(Result);
        end;
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.GetRunMsgCount: Integer;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  Result := 0;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    if m_MsgList.Count > 0 then begin //20080629
      for I := 0 to m_MsgList.Count - 1 do begin
        SendMessage := m_MsgList.Items[I];
        if (SendMessage.wIdent = CM_RUN) then begin
          Inc(Result);
        end;
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.GetWalkMsgCount: Integer;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  Result := 0;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    if m_MsgList.Count > 0 then begin //20080629
      for I := 0 to m_MsgList.Count - 1 do begin
        SendMessage := m_MsgList.Items[I];
        if (SendMessage.wIdent = CM_WALK) then begin
          Inc(Result);
        end;
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.GetTurnMsgCount: Integer;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  Result := 0;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    if m_MsgList.Count > 0 then begin //20080629
      for I := 0 to m_MsgList.Count - 1 do begin
        SendMessage := m_MsgList.Items[I];
        if (SendMessage.wIdent = CM_TURN) then begin
          Inc(Result);
        end;
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.GetSiteDownMsgCount: Integer;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  Result := 0;
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    if m_MsgList.Count > 0 then begin //20080629
      for I := 0 to m_MsgList.Count - 1 do begin
        SendMessage := m_MsgList.Items[I];
        if (SendMessage.wIdent = CM_SITDOWN) then begin
          Inc(Result);
        end;
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.CheckActionStatus(wIdent: Word; var dwDelayTime: LongWord): Boolean;
var
  dwCheckTime: LongWord;
//  dwCurrTick: LongWord;
  dwActionIntervalTime: LongWord;
begin
  Result := False;
  dwDelayTime := 0;
  //检查人物弯腰停留时间
  if not g_Config.boDisableStruck then begin
    dwCheckTime := GetTickCount - m_dwStruckTick;
    if g_Config.dwStruckTime > dwCheckTime then begin
      dwDelayTime := g_Config.dwStruckTime - dwCheckTime;
      m_btOldDir := m_btDirection;
      Exit;
    end;
  end;

  //检查二个不同操作之间所需间隔时间
  dwCheckTime := GetTickCount - m_dwActionTick;

  if m_boTestSpeedMode then SysMsg('间隔: ' + IntToStr(dwCheckTime), c_Blue, t_Notice);

  if m_wOldIdent = wIdent then begin //当二次操作一样时，则将 boFirst 设置为 真 ，退出由调用函数本身检查二个相同操作之间的间隔时间
    Result := True;
    Exit;
  end;
  if not g_Config.boControlActionInterval then begin
    Result := True;
    Exit;
  end;

  dwActionIntervalTime := m_dwActionIntervalTime;
  case wIdent of
    CM_LONGHIT, CM_LONGHIT4: begin
        //跑位刺杀
        if g_Config.boControlRunLongHit and (m_wOldIdent = CM_RUN) and (m_btOldDir <> m_btDirection) then begin
          dwActionIntervalTime := m_dwRunLongHitIntervalTime;
        end;
      end;
    CM_HIT, CM_HIT_107: begin
        //走位攻击
        if g_Config.boControlWalkHit and (m_wOldIdent = CM_WALK) and (m_btOldDir <> m_btDirection) then begin
          dwActionIntervalTime := m_dwWalkHitIntervalTime;
        end;
        //跑位攻击
        if g_Config.boControlRunHit and (m_wOldIdent = CM_RUN) and (m_btOldDir <> m_btDirection) then begin
          dwActionIntervalTime := m_dwRunHitIntervalTime;
        end;
      end;
    CM_RUN: begin
        //跑位刺杀
        if g_Config.boControlRunLongHit and ((m_wOldIdent = CM_LONGHIT){$IF M2Version <> 2} or (m_wOldIdent = CM_LONGHITFORFENGHAO){$IFEND} or (m_wOldIdent = CM_LONGHIT4)) and (m_btOldDir <> m_btDirection) then begin
          dwActionIntervalTime := m_dwRunLongHitIntervalTime;
        end;
        //跑位攻击
        if g_Config.boControlRunHit and (m_wOldIdent = CM_HIT) and (m_btOldDir <> m_btDirection) then begin
          dwActionIntervalTime := m_dwRunHitIntervalTime;
        end;
        //跑位魔法
        if g_Config.boControlRunMagic and (m_wOldIdent = CM_SPELL) and (m_btOldDir <> m_btDirection) then begin
          dwActionIntervalTime := m_dwRunMagicIntervalTime;
        end;
      end;
    CM_WALK: begin
        //走位攻击
        if g_Config.boControlWalkHit and (m_wOldIdent = CM_HIT) and (m_btOldDir <> m_btDirection) then begin
          dwActionIntervalTime := m_dwWalkHitIntervalTime;
        end;
        //跑位刺杀
        if g_Config.boControlRunLongHit and ((m_wOldIdent = CM_LONGHIT){$IF M2Version <> 2} or (m_wOldIdent = CM_LONGHITFORFENGHAO){$IFEND} or (m_wOldIdent = CM_LONGHIT4)) and (m_btOldDir <> m_btDirection) then begin
          dwActionIntervalTime := m_dwRunLongHitIntervalTime;
        end;
      end;
    CM_SPELL: begin
        //跑位魔法
        if g_Config.boControlRunMagic and (m_wOldIdent = CM_RUN) and (m_btOldDir <> m_btDirection) then begin
          dwActionIntervalTime := m_dwRunMagicIntervalTime;
        end;
      end;
  end;

  //将几个攻击操作合并成一个攻击操作代码
  if (wIdent = CM_HIT) or
    (wIdent = CM_HEAVYHIT) or
    (wIdent = CM_BIGHIT) or
    (wIdent = CM_POWERHIT) or
{$IF M2Version <> 2}
  (wIdent = CM_DAILYFORFENGHAO) or //逐日粉红效果
    (wIdent = CM_FIREHITFORFENGHAO) {烈火} or
{$IFEND}
  (wIdent = CM_WIDEHIT) or
    (wIdent = CM_WIDEHIT4) or //圆月弯刀
    (wIdent = CM_CRSHIT) or
    (wIdent = CM_DAILY) or //逐日剑法 20080511
    (wIdent = CM_BLOODSOUL) or //血魄一击(战)
    (wIdent = CM_FIREHIT) {烈火} or
    (wIdent = CM_4FIREHIT) {4级烈火 20080112} then begin
    wIdent := CM_HIT;
  end;

  if dwCheckTime >= dwActionIntervalTime then begin
    m_dwActionTick := GetTickCount();
    Result := True;
  end else begin
    dwDelayTime := dwActionIntervalTime - dwCheckTime;
  end;
  m_wOldIdent := wIdent;
  m_btOldDir := m_btDirection;
end;

procedure TPlayObject.SetScriptLabel(sLabel: string);
begin
  m_CanJmpScriptLableList.Clear;
  m_CanJmpScriptLableList.Add(sLabel);
end;
//取得当前脚本可以跳转的标签

procedure TPlayObject.GetScriptLabel(sMsg: string);
var
  sCmdStr, sLabel, sData, sText: string;
begin
  try
    if m_boGhost then Exit; //20091124 增加
    if m_CanJmpScriptLableList <> nil then begin //20090315 增加
      m_CanJmpScriptLableList.Clear;
      while (True) do begin
        if sMsg = '' then Break;
        sMsg := GetValidStr3(sMsg, sText, ['\']);
        if sText <> '' then begin
          sData := '';
          while (Pos('<', sText) > 0) and (Pos('>', sText) > 0) and (sText <> '') do begin
            if sText[1] <> '<' then begin
              sText := '<' + GetValidStr3(sText, sData, ['<']);
            end;
            sText := ArrestStringEx(sText, '<', '>', sCmdStr);
            sLabel := GetValidStr3(sCmdStr, sCmdStr, ['/']);

            if (pos('@@InPutString', sLabel) <> 0) or (pos('@@InPutInteger', sLabel) <> 0) then begin
              if Pos('|', sLabel) > 0 then GetValidStr3(sLabel, sLabel, ['|']); //20110715 自定义标题(@@InPutString)
            end;

            if sLabel <> '' then m_CanJmpScriptLableList.Add(sLabel);
          end;
        end;
      end;
    end;
  except   
    MainOutMessage(Format('{%s} TPlayObject.GetScriptLabel', [g_sExceptionVer]));
  end;
end;

function TPlayObject.LableIsCanJmp(sLabel: string): Boolean;
var
  I: Integer;
begin
  Result := False;
  if (CompareText(sLabel, '@main') = 0) or (LowerCase(sLabel) = sBigMain) then begin // @main问题
    Result := True;
    Exit;
  end;
  if m_CanJmpScriptLableList.Count > 0 then begin //20080629
    for I := 0 to m_CanJmpScriptLableList.Count - 1 do begin
      if CompareText(sLabel, m_CanJmpScriptLableList.Strings[I]) = 0 then begin
        Result := True;
        Break;
      end;
    end;
  end;
  if CompareText(sLabel, m_sPlayDiceLabel) = 0 then begin
    m_sPlayDiceLabel := '';
    Result := True;
    Exit;
  end;
end;

procedure TPlayObject.RecalcAbilitys;
begin
  inherited;
  RecalcAdjusBonus();
end;
//挂机后,清除相关列表

procedure TPlayObject.ClearViewRange;
var
  I: Integer;
begin
  try
    m_VisibleHumanList.Clear;
    if m_VisibleItems.Count > 0 then begin //20080629
      for I := 0 to m_VisibleItems.Count - 1 do begin
        if pTVisibleMapItem(m_VisibleItems.Items[I]) <> nil then
          Dispose(pTVisibleMapItem(m_VisibleItems.Items[I]));
      end;
    end;
    m_VisibleItems.Clear;
    if m_VisibleActors.Count > 0 then begin //20080629
      for I := 0 to m_VisibleActors.Count - 1 do begin
        if pTVisibleBaseObject(m_VisibleActors.Items[I]) <> nil then
          Dispose(pTVisibleBaseObject(m_VisibleActors.Items[I]));
      end;
    end;
    m_VisibleActors.Clear; //清除人物列表
    {if m_VisibleEvents.Count > 0 then begin//20080629  20090215 注释
      for I := 0 to m_VisibleEvents.Count - 1 do begin
        if pTVisibleMapEvent(m_VisibleEvents.Items[I]) <> nil then
           Dispose(pTVisibleMapEvent(m_VisibleEvents.Items[I]));
      end;
    end;}
    m_VisibleEvents.Clear;
  except
    KickException();
  end;
end;

procedure TPlayObject.SearchViewRange;
var
  I, nStartX, nEndX, nStartY, nEndY, n18, n1C, nIdx, n24, n25: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
  MapItem: PTMapItem;
  MapEvent: TEvent;
  VisibleBaseObject: pTVisibleBaseObject;
  VisibleMapItem: pTVisibleMapItem;
  nCheckCode: Byte;
  //btType: Byte;//20090510 注释
  nVisibleFlag: {Integer} Byte; //20090823 修改为 Byte
  dwRunTick: LongWord; //20091103 测试用
resourcestring
  sExceptionMsg1 = '{%s} TPlayObject::SearchViewRange Code:%d';
  sExceptionMsg2 = '{%s} TPlayObject::SearchViewRange 1-%d %s %s %d %d %d';
begin
  nCheckCode := 1;
  n24 := 0;
  try
    if m_boNotOnlineAddExp or m_boGhost then Exit; //2006-10-22 叶随风飘 修改 离线挂机不搜索
    {nCheckCode := 2;
    if m_VisibleItems.Count > 0 then begin
      for I := 0 to m_VisibleItems.Count - 1 do begin
        pTVisibleMapItem(m_VisibleItems.Items[I]).nVisibleFlag := 0;
      end;
    end; }
    {nCheckCode := 3;
    if m_VisibleEvents.Count > 0 then begin//20080629 20090823 注释，第三步处理完后直接初始为0
      for I := 0 to m_VisibleEvents.Count - 1 do begin
        if TEvent(m_VisibleEvents.Items[I]) <> nil then begin
          TEvent(m_VisibleEvents.Items[I]).nVisibleFlag := 0;
        end;
      end;
    end;
    nCheckCode := 4;
    if m_VisibleActors.Count > 0 then begin//20080629  20090822 注释，第三步处理完后直接初始为0
      for I := 0 to m_VisibleActors.Count - 1 do begin
        pTVisibleBaseObject(m_VisibleActors.Items[I]).nVisibleFlag := 0;
      end;
    end;}
  except
    begin
    MainOutMessage(Format(sExceptionMsg1, [g_sExceptionVer, nCheckCode]));
    KickException();
    end;
  end;
  nCheckCode := 6;

  try
    nStartX := m_nCurrX - m_nViewRange;
    nEndX := m_nCurrX + m_nViewRange;
    nStartY := m_nCurrY - m_nViewRange;
    nEndY := m_nCurrY + m_nViewRange;

    dwRunTick := GetTickCount(); //20091103 测试
    nCheckCode := 7;
    for n18 := nStartX to nEndX do begin
      for n1C := nStartY to nEndY do begin
        nCheckCode := 8;
        if m_PEnvir.GetMapCellInfo(n18, n1C, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
          nCheckCode := 9;
          n24 := 1;
          nIdx := 0;
          while (True) do begin
            if ((GetTickCount - dwRunTick) > 500) then Break; //超时则退出循环(测试) 20091103
            if MapCellInfo <> nil then begin //20080910 增加  20090316 注释  20100614 还原
              if (MapCellInfo.ObjList <> nil) and (MapCellInfo.ObjList.Count <= 0) then begin //200-11-1 增加
                nCheckCode := 10;
                FreeAndNil(MapCellInfo.ObjList);
                nCheckCode := 101;
                Break;
              end;
            end;
            nCheckCode := 11;
            try //20091102 增加
              if MapCellInfo.ObjList.Count <= nIdx then Break;
            except
              Break;
            end;
            nCheckCode := 121;
            try //20091101 增加
              OSObject := MapCellInfo.ObjList.Items[nIdx];
            except
              //OSObject:= nil;
              MapCellInfo.ObjList.Delete(nIdx); //20101103 修改
              Continue;
            end;
            nCheckCode := 131;
            if OSObject <> nil then begin
              if (not OSObject.boObjectDisPose) then begin
                case OSObject.btType of
                  OS_MOVINGOBJECT: begin
                      if (GetTickCount - OSObject.dwAddTime) >= 60000 then begin
                        OSObject.boObjectDisPose := True; //20090510 增加
                        Dispose(OSObject);
                        MapCellInfo.ObjList.Delete(nIdx);
                        if MapCellInfo.ObjList.Count <= 0 then begin
                          FreeAndNil(MapCellInfo.ObjList);
                          Break;
                        end;
                        Continue;
                      end;
                      BaseObject := TBaseObject(OSObject.CellObj);
                      if BaseObject <> nil then begin
                        if not BaseObject.m_boGhost and not BaseObject.m_boFixedHideMode and not BaseObject.m_boObMode then begin
                          if (m_btRaceServer < RC_ANIMAL) or (m_Master <> nil) or m_boCrazyMode or m_boWantRefMsg or
                            ((BaseObject.m_Master <> nil) and (abs(BaseObject.m_nCurrX - m_nCurrX) <= 3) and (abs(BaseObject.m_nCurrY - m_nCurrY) <= 3)) or
                            (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
                            UpdateVisibleGay(BaseObject, 0);
                          end;
                        end;
                      end; //if BaseObject <> nil then begin
                    end; //OS_MOVINGOBJECT
                  OS_ITEMOBJECT: begin
                      if m_btRaceServer = RC_PLAYOBJECT then begin
                        if ((GetTickCount - OSObject.dwAddTime) > g_Config.dwClearDropOnFloorItemTime) or
                          ((PTMapItem(OSObject.CellObj).UserItem.AddValue[0] = 1) and
                          (GetHoursCount(PTMapItem(OSObject.CellObj).UserItem.MaxDate, Now) <= 0)) then begin
                          if PTMapItem(OSObject.CellObj) <> nil then begin
                            //DisPoseAndNil(PTMapItem(OSObject.CellObj)); //防止占用内存不释放现象 20080702
                            DisPose(PTMapItem(OSObject.CellObj));//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                            PTMapItem(OSObject.CellObj):= nil;
                          end;
                          try //20090504 增加
                            if OSObject <> nil then begin
                              OSObject.boObjectDisPose := True; //20090510 增加
                              //DisPoseAndNil(OSObject); //20090107 增加<>nil
                              DisPose(OSObject);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                              OSObject  := nil;
                            end;
                          except
                          end;
                          MapCellInfo.ObjList.Delete(nIdx);
                          if MapCellInfo.ObjList.Count <= 0 then begin
                            FreeAndNil(MapCellInfo.ObjList);
                            Break;
                          end;
                          Continue;
                        end;
                        MapItem := PTMapItem(OSObject.CellObj);
                        UpdateVisibleItem(n18, n1C, MapItem);
                        if (MapItem.OfBaseObject <> nil) or (MapItem.DropBaseObject <> nil) then begin
                          if (GetTickCount - MapItem.dwCanPickUpTick) > g_Config.dwFloorItemCanPickUpTime {2 * 60 * 1000} then begin
                            MapItem.OfBaseObject := nil;
                            MapItem.DropBaseObject := nil;
                          end else begin
                            if TBaseObject(MapItem.OfBaseObject) <> nil then begin
                              if TBaseObject(MapItem.OfBaseObject).m_boGhost then MapItem.OfBaseObject := nil;
                            end;
                            if TBaseObject(MapItem.DropBaseObject) <> nil then begin
                              if TBaseObject(MapItem.DropBaseObject).m_boGhost then MapItem.DropBaseObject := nil;
                            end;
                          end;
                        end;
                      end;
                    end; //OS_ITEMOBJECT
                  OS_EVENTOBJECT: begin
                      if m_btRaceServer = RC_PLAYOBJECT then begin
                        if OSObject.CellObj <> nil then begin //20080913
                          MapEvent := TEvent(OSObject.CellObj);
                          if MapEvent.m_boVisible then begin
                            UpdateVisibleEvent(n18, n1C, MapEvent);
                          end;
                        end;
                      end;
                    end; //OS_EVENTOBJECT
                end; //Case
              end;
            end; //if OSObject <> nil then begin
            Inc(nIdx);
          end; //while
        end;
      end; //for n1C:= n10 to n14  do begin
    end; //for n18:= n8 to nC do begin
  except
    on E: Exception do begin
      MainOutMessage(Format(sExceptionMsg2, [g_sExceptionVer, n24, m_sCharName, m_sMapName, m_nCurrX, m_nCurrY, nCheckCode])); //20100125 注释
      KickException();
    end;
  end;
  nCheckCode := 26;
  n24 := 2;
  try
    n18 := 0;
    while (True) do begin
      try //20101126 防止死循环
        if m_VisibleActors.Count <= n18 then Break;
        nCheckCode := 27;
        try //20081017 去注释
          VisibleBaseObject := m_VisibleActors.Items[n18];
          nCheckCode := 28;
          nVisibleFlag := VisibleBaseObject.nVisibleFlag; //2006-10-14 防止内存出错
        except
          m_VisibleActors.Delete(n18);
          if m_VisibleActors.Count > 0 then Continue; //20090430 修改
          Break; //20090430 增加
        end;
        case VisibleBaseObject.nVisibleFlag of //20090822 修改
          0: begin
              if m_btRaceServer = RC_PLAYOBJECT then begin
                nCheckCode := 29;
                BaseObject := TBaseObject(VisibleBaseObject.BaseObject);
                nCheckCode := 30;
                if BaseObject <> nil then begin
                  nCheckCode := 51;
                  if (not BaseObject.m_boFixedHideMode) and (not BaseObject.m_boGhost) then begin //01/21 修改防止人物退出时发送重复的消息占用带宽，人物进入隐身模式时人物不消失问题
                    nCheckCode := 31;
                    SendMsg(BaseObject, RM_DISAPPEAR, 0, 0, 0, 0, '');
                  end;
                end;
              end;
              nCheckCode := 52;
              m_VisibleActors.Delete(n18);
              nCheckCode := 32;
              try
                if VisibleBaseObject <> nil then begin
                  //DisPoseAndNil(VisibleBaseObject); //20091017 修改
                  DisPose(VisibleBaseObject);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                  VisibleBaseObject:= nil;
                end;
              except
              end;
              Continue;
            end; //0
          2: begin
              if (m_btRaceServer = RC_PLAYOBJECT) then begin
                nCheckCode := 34;
                BaseObject := TBaseObject(VisibleBaseObject.BaseObject);
                if (BaseObject <> nil) then begin
                  if (BaseObject <> Self) and (not BaseObject.m_boGhost) and (not m_boGhost) then begin
                    if BaseObject.m_boDeath then begin
                      if BaseObject.m_boSkeleton then begin
                        nCheckCode := 35;
                        SendMsg(BaseObject, RM_SKELETON, BaseObject.m_btDirection, BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0, '');
                      end else begin
                        nCheckCode := 36;
                        SendMsg(BaseObject, RM_DEATH, BaseObject.m_btDirection, BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0, '');
                      end;
                    end else begin
                      try //20090721 增加
                        if (BaseObject <> nil) then begin //20090721 增加
{$IF M2Version <> 2}
                          n25 := 0;
                          case BaseObject.m_btRaceServer of //20090818 修改
                            RC_PLAYOBJECT: begin
                                if (not TPlayObject(BaseObject).m_boShowFengHao) and (TPlayObject(BaseObject).m_boUseTitle) then n25 := TPlayObject(BaseObject).m_boUseIitleIdx;
                                SendMsg(BaseObject, RM_TURN, BaseObject.m_btDirection, BaseObject.m_nCurrX, BaseObject.m_nCurrY, n25, BaseObject.GetShowName);
                                if TPlayObject(BaseObject).m_boTrainingNG then
                                  SendMsg(BaseObject, RM_MAGIC69SKILLNH, 0, TPlayObject(BaseObject).m_Skill69NH, TPlayObject(BaseObject).m_Skill69MaxNH, 0, '');
                              end;
                            RC_HEROOBJECT: begin
                                SendMsg(BaseObject, RM_TURN, BaseObject.m_btDirection, BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0, BaseObject.GetShowName);
                                if THeroObject(BaseObject).m_boTrainingNG then
                                  SendMsg(BaseObject, RM_MAGIC69SKILLNH, 0, THeroObject(BaseObject).m_Skill69NH, THeroObject(BaseObject).m_Skill69MaxNH, 0, '');
                              end;
                            RC_PLAYMOSTER: begin
                                if (BaseObject.m_Master <> nil) and (BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
                                  if (not TPlayObject(BaseObject.m_Master).m_boShowFengHao) and (TPlayObject(BaseObject.m_Master).m_boUseTitle) then n25 := TPlayObject(BaseObject.m_Master).m_boUseIitleIdx;
                                end;
                                SendMsg(BaseObject, RM_TURN, BaseObject.m_btDirection, BaseObject.m_nCurrX, BaseObject.m_nCurrY, n25, BaseObject.GetShowName);
                                if (BaseObject.m_Master <> nil) then begin //学过内功人物的分身也显示黄条值
                                  if (BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
                                    if TPlayObject(BaseObject.m_Master).m_boTrainingNG then begin
                                      SendMsg(BaseObject, RM_MAGIC69SKILLNH, 0, TPlayObject(BaseObject.m_Master).m_Skill69NH, TPlayObject(BaseObject.m_Master).m_Skill69MaxNH, 0, '');
                                    end;
                                  end else
                                    if (BaseObject.m_Master.m_btRaceServer = RC_HEROOBJECT) then begin
                                      if THeroObject(BaseObject.m_Master).m_boTrainingNG then begin
                                        SendMsg(BaseObject, RM_MAGIC69SKILLNH, 0, THeroObject(BaseObject.m_Master).m_Skill69NH, THeroObject(BaseObject.m_Master).m_Skill69MaxNH, 0, '');
                                      end;
                                    end;
                                end;
                              end;
                          else SendMsg(BaseObject, RM_TURN, BaseObject.m_btDirection, BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0, BaseObject.GetShowName);
                          end; //case
{$ELSE}
                          SendMsg(BaseObject, RM_TURN, BaseObject.m_btDirection, BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0, BaseObject.GetShowName);
{$IFEND}
                        end;
                      except
                      end;
                    end;
                  end;
                end;
              end;
              VisibleBaseObject.nVisibleFlag := 0; //处理完初始变量 20090822
            end; //2
          1: VisibleBaseObject.nVisibleFlag := 0; //处理完初始变量 20090822
        end; //case
      except
        Break;
      end;
      Inc(n18);
    end;
  except
    on E: Exception do begin
      MainOutMessage(Format(sExceptionMsg2, [g_sExceptionVer, n24, m_sCharName, m_sMapName, m_nCurrX, m_nCurrY, nCheckCode]));
      KickException();
    end;
  end;
  try
    I := 0;
    while (True) do begin
      try //20101126 防止死循环
        if m_VisibleItems.Count <= I then Break;
        nCheckCode := 49;
        try //20081017 去注释
          VisibleMapItem := m_VisibleItems.Items[I];
          nCheckCode := 50;
          nVisibleFlag := VisibleMapItem.nVisibleFlag; //2006-10-14 防止内存出错
        except
          m_VisibleItems.Delete(I);
          if m_VisibleItems.Count > 0 then Continue; //20090430 修改
          Break; //20090430 增加
        end;
        nCheckCode := 38;
        case VisibleMapItem.nVisibleFlag of //20090822 修改
          0: begin
              nCheckCode := 39;
              if (not m_boAI) and (not m_boNotOnlineAddExp) then begin
                SendMsg(Self, RM_ITEMHIDE, 0, Integer(VisibleMapItem.MapItem), VisibleMapItem.nX, VisibleMapItem.nY, '');
              end;
              nCheckCode := 40;
              m_VisibleItems.Delete(I);
              nCheckCode := 41;
              try
                //DisPoseAndNil(VisibleMapItem);
                DisPose(VisibleMapItem);//DisPoseAndNil是个不可能实现的函数 用得不好还会产生幻觉 By TasNat at: 2012-03-17 17:47:42
                VisibleMapItem:= nil;
              except
                VisibleMapItem := nil;
              end;
              if m_VisibleItems.Count > 0 then Continue; //20090511 修改
              Break; //20090511 增加
            end; //0
          2: begin
              if (not m_boAI) and (not m_boNotOnlineAddExp) then begin
                SendMsg(Self, RM_ITEMSHOW, VisibleMapItem.wLooks, Integer(VisibleMapItem.MapItem), VisibleMapItem.nX, VisibleMapItem.nY, VisibleMapItem.sName);
              end;
              VisibleMapItem.nVisibleFlag := 0;
            end; //2
          1: VisibleMapItem.nVisibleFlag := 0;
        end; //case
      except
        Break;
      end;
      Inc(I);
    end;
    I := 0;
    while (True) do begin //2006-01-20 修改
      try //20101126 防止死循环
        if m_VisibleEvents.Count <= I then Break;
        nCheckCode := 43;
        try //20081017 去注释
          MapEvent := m_VisibleEvents.Items[I];
          nVisibleFlag := MapEvent.nVisibleFlag; //20090322 修改
        except
          m_VisibleEvents.Delete(I);
          if m_VisibleEvents.Count > 0 then Continue; //20090511 修改
          Break; //20090511 增加
        end;
        if MapEvent <> nil then begin
          nCheckCode := 44;
          case MapEvent.nVisibleFlag of //20090822 修改
            0: begin
                nCheckCode := 45;
                SendMsg(Self, RM_HIDEEVENT, 0, Integer(MapEvent), MapEvent.m_nX, MapEvent.m_nY, '');
                nCheckCode := 46;
                m_VisibleEvents.Delete(I);
                nCheckCode := 47;
                if m_VisibleEvents.Count > 0 then Continue; //20090511 修改
                Break; //20090511 增加
              end; //0
            1: MapEvent.nVisibleFlag := 0; //处理完初始变量 20090823
            2: begin //在客户端显示可见的场景
                SendMsg(Self, RM_SHOWEVENT, MapEvent.m_nEventType, Integer(MapEvent), MakeLong(MapEvent.m_nX, MapEvent.m_nEventParam), MapEvent.m_nY, '');
                MapEvent.nVisibleFlag := 0; //处理完初始变量 20090823
              end;
          end; //case
        end;
      except
        Break;
      end;
      Inc(I);
    end;
  except
    MainOutMessage(m_sCharName + ',' + m_sMapName + ',' + IntToStr(m_nCurrX) + ',' +
      IntToStr(m_nCurrY) + ',' + ' SearchViewRange 3 CheckCode:' + IntToStr(nCheckCode));
    KickException();
  end;
end;

//人物显示名字 20080330

function TPlayObject.GetShowName: string;
var
  sShowName, sCharName, sGuildName, sDearName, sMasterName: string;
  Castle: TUserCastle;
{$IF M2Version <> 2}
  sComradeName, sHuhuashizheName: string;
{$IFEND}
begin
  try
    if m_boGhost then Exit; //20090413 清理人物则退出
    if g_Config.boUnKnowHum and IsUsesZhuLi then begin
      Result := '神秘人'; //带上斗笠即显示神秘人 20080424
    end else begin
      sCharName := '';
      sGuildName := '';
      sDearName := '';
      sMasterName := '';
{$IF M2Version <> 2}
      sComradeName := '';
      sHuhuashizheName := '';
{$IFEND}
      if m_MyGuild <> nil then begin
        Castle := g_CastleManager.IsCastleMember(Self);
        if Castle <> nil then begin
          sGuildName := AnsiReplaceText(g_sCastleGuildName, '%castlename', Castle.m_sName); //城堡名字
          sGuildName := AnsiReplaceText(sGuildName, '%guildname', TGUild(m_MyGuild).sGuildName); //行会名字
          sGuildName := AnsiReplaceText(sGuildName, '%rankname', m_sGuildRankName); //行会封号
        end else begin
          Castle := g_CastleManager.InCastleWarArea(Self);
          if g_Config.boShowGuildName or (((Castle <> nil) and Castle.m_boUnderWar) or m_boInFreePKArea) then begin
            sGuildName := AnsiReplaceText(g_sNoCastleGuildName, '%guildname', TGUild(m_MyGuild).sGuildName);
            sGuildName := AnsiReplaceText(sGuildName, '%rankname', m_sGuildRankName);
          end;
        end;
      end;
      if not g_Config.boShowRankLevelName then begin
        if m_btReLevel > 0 then begin
          case m_btJob of
            0: sCharName := AnsiReplaceText(g_sWarrReNewName, '%chrname', m_sCharName);
            1: sCharName := AnsiReplaceText(g_sWizardReNewName, '%chrname', m_sCharName);
            2: sCharName := AnsiReplaceText(g_sTaosReNewName, '%chrname', m_sCharName);
            //3:;//刺客
          end;
        end else begin
          sCharName := m_sCharName;
        end;
      end else begin
        sCharName := Format_Tostr(m_sRankLevelName, [m_sCharName]);
      end;
      if m_sMasterName <> '' then begin
        if m_boMaster then begin
          sMasterName := Format_ToStr(g_sMasterName {'的师傅'}, [m_sMasterName]);
        end else begin
          sMasterName := Format_ToStr(g_sNoMasterName {'的徒弟'}, [m_sMasterName, MoneyToCharacter(m_nMasterNo, False)]); //20080530
        end;
      end;
      if m_sDearName <> '' then begin
        if m_btGender = 0 then begin
          sDearName := Format_ToStr(g_sManDearName, [m_sDearName]); //+ '的老公';
        end else begin
          sDearName := Format_ToStr(g_sWoManDearName, [m_sDearName]); // + '的老婆';
        end;
      end;
{$IF M2Version <> 2}
      if m_boCanTitle then begin //启用称号
        if m_boFengHaoHuhua and (m_sHuhuaName <> '') then sHuhuashizheName := Format_ToStr(g_sHuhuashizheName, [m_sHuhuaName]); //护花使者称号
        if m_boFengHaoComrade and (m_sDominateName <> '') then sComradeName := Format_ToStr(g_sComradeName, [m_sDominateName]); //主宰龙卫
      end;
{$IFEND}
      sShowName := AnsiReplaceText(g_sHumanShowName, '%chrname', sCharName); //人物名
      sShowName := AnsiReplaceText(sShowName, '%guildname', sGuildName); //行会名
      sShowName := AnsiReplaceText(sShowName, '%dearname', sDearName); //夫妻名
      sShowName := AnsiReplaceText(sShowName, '%mastername', sMasterName); //师徒名
{$IF M2Version <> 2}
      sShowName := AnsiReplaceText(sShowName, '%comradename', sComradeName); //战友
      sShowName := AnsiReplaceText(sShowName, '%huhuaname', sHuhuashizheName); //护花使者
      if Pos('|', sShowName) > 0 then sShowName := AnsiReplaceText(sShowName, '|', ''); //20110402 过滤封号带|符号
{$IFEND}
      Result := sShowName;
{$IF M2Version <> 2}
      if (not m_boShowFengHao) and (m_boUseTitle) then Result := Result + '|' + m_sUseIitleName;
{$IFEND}
    end;
  except
  end;
end;
//定时检测物品是否过期  20110520

procedure TPlayObject.CheckItemsDay();
var
  I: Integer;
  UserItem: pTUserItem;
  boNeed: boolean;
begin
  //删除包裹中到期装备
  for I := m_ItemList.Count - 1 downto 0 do begin
    if m_ItemList.Count <= 0 then Break;
    UserItem := pTUserItem(m_ItemList.Items[I]);
    if (UserItem.wIndex > 0) then begin
      if (UserItem.AddValue[0] = 1) and (GetHoursCount(UserItem.MaxDate, Now) <= 0) then begin //删除到期装备
        m_ItemList.Delete(I);
        SendDelItems(UserItem);
        Dispose(UserItem);
        Continue;
      end;
      if (UserItem.AddValue[0] = 2) and (GetHoursCount(UserItem.MaxDate, Now) <= 0) then UserItem.AddValue[0] := 0; //绑定物品到期 恢复正常
    end;
  end;
{$IF HEROVERSION = 1}
  if m_MyHero <> nil then begin
    if (not m_MyHero.m_boDeath) and (not m_MyHero.m_boGhost) then begin
      //删除包裹中到期装备
      for I := m_MyHero.m_ItemList.Count - 1 downto 0 do begin
        if m_MyHero.m_ItemList.Count <= 0 then Break;
        UserItem := pTUserItem(m_MyHero.m_ItemList.Items[I]);
        if (UserItem.wIndex > 0) then begin
          if (UserItem.AddValue[0] = 1) and (GetHoursCount(UserItem.MaxDate, Now) <= 0) then begin //删除到期装备
            m_MyHero.m_ItemList.Delete(I);
            THeroObject(m_MyHero).SendDelItems(UserItem);
            Dispose(UserItem);
            Continue;
          end;
          if (UserItem.AddValue[0] = 2) and (GetHoursCount(UserItem.MaxDate, Now) <= 0) then UserItem.AddValue[0] := 0; //绑定物品到期 恢复正常
        end;
      end;
      boNeed := False;
      for I := Low(THumanUseItems) to High(THumanUseItems) do begin //9格装备+4格装备
        if m_MyHero.m_UseItems[I].wIndex > 0 then begin
          if (m_MyHero.m_UseItems[I].AddValue[0] = 1) and (GetHoursCount(m_MyHero.m_UseItems[I].MaxDate, Now) <= 0) then begin //删除到期装备
            THeroObject(m_MyHero).SendDelItems(@m_MyHero.m_UseItems[I]);
            m_MyHero.m_UseItems[I].wIndex := 0;
            m_MyHero.m_UseItems[I].MakeIndex := 0;
            boNeed := True;
          end;
        end;
      end;
      if boNeed then begin
        THeroObject(m_MyHero).RecalcAbilitys();
        m_MyHero.CompareSuitItem(False); //套装与身上装备对比 20080712
        m_MyHero.FeatureChanged;
      end;
    end;
  end;
{$IFEND}
end;

function TPlayObject.CheckItemsNeed(StdItem: pTStdItem): Boolean;
var
  Castle: TUserCastle;
begin
  Result := True;
  Castle := g_CastleManager.IsCastleMember(Self);
  case StdItem.Need of
    6: begin
        if (m_MyGuild = nil) then begin
          Result := False;
        end;
      end;
    60: begin
        if (m_MyGuild = nil) or (m_nGuildRankNo <> 1) then begin
          Result := False;
        end;
      end;
    7: begin
        //if (m_MyGuild = nil) or (UserCastle.m_MasterGuild <> m_MyGuild) then begin
        if Castle = nil then begin
          Result := False;
        end;
      end;
    70: begin
        //if (m_MyGuild = nil) or (UserCastle.m_MasterGuild <> m_MyGuild) or (m_nGuildRankNo <> 1) then begin
        if (Castle = nil) or (m_nGuildRankNo <> 1) then begin
          Result := False;
        end;
      end;
    8: begin
        if m_nMemberType = 0 then Result := False;
      end;
    81: begin
        if (m_nMemberType <> LoWord(StdItem.NeedLevel)) or (m_nMemberLevel < HiWord(StdItem.NeedLevel)) then
          Result := False;
      end;
    82: begin
        if (m_nMemberType < LoWord(StdItem.NeedLevel)) or (m_nMemberLevel < HiWord(StdItem.NeedLevel)) then
          Result := False;
      end;
  end;
end;

//检查离婚

procedure TPlayObject.CheckMarry;
var
  boIsfound: Boolean;
  sUnMarryFileName: string;
  LoadList: TStringList;
  I: Integer;
  sSayMsg: string;
begin
  boIsfound := False;
  sUnMarryFileName := g_Config.sEnvirDir + 'UnMarry.txt';
  if FileExists(sUnMarryFileName) then begin
    LoadList := TStringList.Create;
    try
      LoadList.LoadFromFile(sUnMarryFileName);
      for I := LoadList.Count - 1 downto 0 do begin
        if LoadList.Count <= 0 then Break;
        if CompareText(LoadList.Strings[I], m_sCharName) = 0 then begin
          LoadList.Delete(I);
          boIsfound := True;
          Break;
        end;
      end;
      LoadList.SaveToFile(sUnMarryFileName);
    finally
      LoadList.Free;
    end;
  end;
  if boIsfound then begin
    if m_btGender = 0 then begin
      sSayMsg := AnsiReplaceText(g_sfUnMarryManLoginMsg, '%d', m_sDearName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sDearName);
    end else begin
      sSayMsg := AnsiReplaceText(g_sfUnMarryWoManLoginMsg, '%d', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
    end;
    SysMsg(sSayMsg, c_Red, t_Hint);
    m_sDearName := '';
    RefShowName;
  end;
  m_DearHuman := UserEngine.GetPlayObject(m_sDearName);
  if m_DearHuman <> nil then begin
    m_DearHuman.m_DearHuman := Self;
    if m_btGender = 0 then begin
      sSayMsg := AnsiReplaceText(g_sManLoginDearOnlineSelfMsg, '%d', m_sDearName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_DearHuman.m_PEnvir.sMapDesc);
      sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_DearHuman.m_nCurrX));
      sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_DearHuman.m_nCurrY));
      SysMsg(sSayMsg, c_Blue, t_Hint);

      sSayMsg := AnsiReplaceText(g_sManLoginDearOnlineDearMsg, '%d', m_sDearName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
      sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
      sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
      m_DearHuman.SysMsg(sSayMsg, c_Blue, t_Hint);
    end else begin
      sSayMsg := AnsiReplaceText(g_sWoManLoginDearOnlineSelfMsg, '%d', m_sDearName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_DearHuman.m_PEnvir.sMapDesc);
      sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_DearHuman.m_nCurrX));
      sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_DearHuman.m_nCurrY));
      SysMsg(sSayMsg, c_Blue, t_Hint);

      sSayMsg := AnsiReplaceText(g_sWoManLoginDearOnlineDearMsg, '%d', m_sDearName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
      sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
      sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
      m_DearHuman.SysMsg(sSayMsg, c_Blue, t_Hint);
    end;
  end else begin
    if m_btGender = 0 then begin
      SysMsg(g_sManLoginDearNotOnlineMsg, c_Red, t_Hint);
    end else begin
      SysMsg(g_sWoManLoginDearNotOnlineMsg, c_Red, t_Hint);
    end;
  end;
end;
//检查师傅

procedure TPlayObject.CheckMaster(boAutoUnMaster: Boolean);
var
  boIsfound: Boolean;
  sSayMsg: string;
  I: Integer;
  Human: TPlayObject;
  s01, s02, s03: string;
begin
  if not boAutoUnMaster then begin
    //处理强行脱离师徒关系
    boIsfound := False;
    g_UnForceMasterList.Lock;
    try
      for I := g_UnForceMasterList.Count - 1 downto 0 do begin
        if g_UnForceMasterList.Count <= 0 then Break;
        s01 := Trim(g_UnForceMasterList.Strings[I]);
        if (s01 <> '') and (s01[1] <> ';') then begin
          s01 := GetValidStr3(s01, s02, [' ', #9]); //师傅名
          s01 := GetValidStr3(s01, s03, [' ', #9]); //徒弟名
          if CompareText(s02, m_sCharName) = 0 then begin
            g_UnForceMasterList.Delete(I);
            SaveUnForceMasterList();
            boIsfound := True;
            Break;
          end;
        end;
      end;
    finally
      g_UnForceMasterList.UnLock;
    end;

    if boIsfound then begin
      if m_boMaster then begin
        sSayMsg := AnsiReplaceText(g_sfUnMasterLoginMsg, '%d', s03); //20080603
        //sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sMasterName);
        DelMaster(s03); //出师 20080530
        if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(self, '@UnMasterEnd', False, False); //师傅触发 20080530
      end else begin
        sSayMsg := AnsiReplaceText(g_sfUnMasterListLoginMsg, '%d', m_sMasterName);
        if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(self, '@UnMasterEnd1', False, False); //徒弟触发By TasNat at: 2012-11-25 12:14:41
        //sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sMasterName);
      end;
      SysMsg(sSayMsg, c_Red, t_Hint);
      m_sMasterName := '';
      RefShowName;
    end;
  end;
  if (m_sMasterName <> '') and not m_boMaster then begin
    if m_Abil.Level >= g_Config.nMasterOKLevel then begin
      Human := UserEngine.GetPlayObject(m_sMasterName);
      if (Human <> nil) and (not Human.m_boDeath) and (not Human.m_boGhost) then begin
        sSayMsg := AnsiReplaceText(g_sYourMasterListUnMasterOKMsg, '%d', MoneyToCharacter(m_nMasterNo, False)); //20080603
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName); //20080603
        Human.SysMsg(sSayMsg, c_Red, t_Hint);
        if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(self, '@UnMasterEnd', False, False); //师傅触发By TasNat at: 2012-11-25 12:14:41
        SysMsg(g_sYouAreUnMasterOKMsg, c_Red, t_Hint);
        Human.DelMaster(m_sCharName); //出师 20080603
        if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(self, '@UnMasterEnd1', False, False); //徒弟触发By TasNat at: 2012-11-25 12:14:41
        //如果大徒弟则将师父上的名字去掉
        if m_sCharName = Human.m_sMasterName then begin
          Human.m_sMasterName := '';
          Human.RefShowName;
        end;
        for I := Human.m_MasterList.Count - 1 downto 0 do begin
          if Human.m_MasterList.Count <= 0 then Break;
          if Human.m_MasterList.Items[I] = Self then begin
            Human.m_MasterList.Delete(I);
            Break;
          end;
        end;
        m_sMasterName := '';
        RefShowName;
        Inc(Human.m_wMasterCount); //增加出师徒弟数
        if Human.m_btCreditPoint + g_Config.nMasterOKCreditPoint <= High(Integer {Byte}) then begin //20080522
          Inc(Human.m_btCreditPoint, g_Config.nMasterOKCreditPoint); //增加师傅的声望
          Human.GameGoldChanged();
        end;
        Inc(Human.m_nBonusPoint, g_Config.nMasterOKBonusPoint);
        Human.SendMsg(Human, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
      end else begin
        //如果师父不在线则保存到记录表中
        g_UnMasterList.Lock;
        try
          boIsfound := False;
          if g_UnMasterList.Count > 0 then begin //20080629
            for I := 0 to g_UnMasterList.Count - 1 do begin
              s01 := Trim(g_UnMasterList.Strings[I]);
              if (s01 <> '') and (s01[1] <> ';') then begin //20080603 增加
                s01 := GetValidStr3(s01, s02, [' ', #9]); //师傅名
                s01 := GetValidStr3(s01, s03, [' ', #9]);
                if CompareText({g_UnMasterList.Strings[I]}s02, m_sCharName) = 0 then begin
                  boIsfound := True;
                  Break;
                end;
              end;
            end; //for
          end;
          if not boIsfound then begin
            g_UnMasterList.Add(m_sMasterName + ' ' + m_sCharName); //20080603 修改
          end;
        finally
          g_UnMasterList.UnLock;
        end;
        if not boIsfound then SaveUnMasterList();
        if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(self, '@UnMasterEnd1', False, False); //徒弟触发By TasNat at: 2012-11-25 12:14:41
        SysMsg(g_sYouAreUnMasterOKMsg, c_Red, t_Hint);
        m_sMasterName := '';
        RefShowName;
      end;
    end;
  end;

  //处理出师记录
  boIsfound := False;
  g_UnMasterList.Lock;
  try
    for I := g_UnMasterList.Count - 1 downto 0 do begin
      if g_UnMasterList.Count <= 0 then Break; //20080917
      s01 := Trim(g_UnMasterList.Strings[I]);
      if (s01 <> '') and (s01[1] <> ';') then begin //20080603 增加
        s01 := GetValidStr3(s01, s02, [' ', #9]); //师傅名
        s01 := GetValidStr3(s01, s03, [' ', #9]); //徒弟名
        if CompareText({g_UnMasterList.Strings[I]}s02, m_sCharName) = 0 then begin
          g_UnMasterList.Delete(I);
          SaveUnMasterList();
          boIsfound := True;
          Break;
        end;
      end;
    end;
  finally
    g_UnMasterList.UnLock;
  end;

  if boIsfound and m_boMaster then begin
    sSayMsg := AnsiReplaceText(g_sUnMasterLoginMsg, '%s', s03); //20080603 修改
    if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(self, '@UnMasterEnd', False, False); //师傅触发By TasNat at: 2012-11-25 12:14:41
    SysMsg(sSayMsg, c_Red, t_Hint);
    DelMaster(s03); //出师 20080603
    m_sMasterName := '';
    RefShowName;

    Inc(m_wMasterCount); //增加出师徒弟数
    if m_btCreditPoint + g_Config.nMasterOKCreditPoint <= High(Integer {Byte}) then begin //20080522
      Inc(m_btCreditPoint, g_Config.nMasterOKCreditPoint);
      GameGoldChanged();
    end;
    Inc(m_nBonusPoint, g_Config.nMasterOKBonusPoint);
    SendMsg(Self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
  end;
  if not boAutoUnMaster then begin
    if m_boMaster then begin //是师傅
      //师父上线通知
      //m_MasterHuman := UserEngine.GetPlayObject(m_sMasterName);
      m_MasterHuman := UserEngine.GetMasterObject(m_sCharName); //20080512
      if m_MasterHuman <> nil then begin
        m_MasterHuman.m_MasterHuman := Self;
        m_MasterList.Add(m_MasterHuman);

        if g_sMasterOnlineSelfMsg <> '' then begin
          sSayMsg := AnsiReplaceText(g_sMasterOnlineSelfMsg, '%d', MoneyToCharacter(m_nMasterNo, False) {m_sMasterName}); //20080603
          sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_MasterHuman.m_PEnvir.sMapDesc);
          sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_MasterHuman.m_nCurrX));
          sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_MasterHuman.m_nCurrY));
          SysMsg(sSayMsg, c_Blue, t_Hint);
        end;

        if g_sMasterOnlineMasterListMsg <> '' then begin
          sSayMsg := AnsiReplaceText(g_sMasterOnlineMasterListMsg, '%d', m_sMasterName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
          sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
          sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
          m_MasterHuman.SysMsg(sSayMsg, c_Blue, t_Hint);
        end;
      end else begin
        if m_MasterNoList.Count <> 0 then SysMsg(g_sMasterNotOnlineMsg {您的徒弟现不在线}, c_Red, t_Hint); //20080530
      end;
    end else begin
      //徒弟上线通知
      if m_sMasterName <> '' then begin
        m_MasterHuman := UserEngine.GetPlayObject(m_sMasterName);
        if m_MasterHuman <> nil then begin

          if m_MasterHuman.m_sMasterName = m_sCharName then begin
            m_MasterHuman.m_MasterHuman := Self;
          end;

          m_MasterHuman.m_MasterList.Add(Self);

          sSayMsg := AnsiReplaceText(g_sMasterListOnlineSelfMsg, '%d', m_sMasterName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_MasterHuman.m_PEnvir.sMapDesc);
          sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_MasterHuman.m_nCurrX));
          sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_MasterHuman.m_nCurrY));
          SysMsg(sSayMsg, c_Blue, t_Hint);

          if g_sMasterListOnlineMasterMsg <> '' then begin
            sSayMsg := AnsiReplaceText(g_sMasterListOnlineMasterMsg, '%d', MoneyToCharacter(m_nMasterNo, False)); //20080602
            sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
            sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
            sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
            sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
            m_MasterHuman.SysMsg(sSayMsg, c_Blue, t_Hint);
          end;
        end else begin
          SysMsg(g_sMasterListNotOnlineMsg {您的师父现不在线}, c_Red, t_Hint);
        end;
      end;
    end;
  end;
end;

procedure TPlayObject.MakeGhost;
var
  I: Integer;
  sSayMsg: string;
  Human: TPlayObject;
resourcestring
  sExceptionMsg = '{%s} TPlayObject::MakeGhost';
begin
  try
    if (g_HighLevelHuman = Self) then g_HighLevelHuman := nil;
    if (g_HighPKPointHuman = Self) then g_HighPKPointHuman := nil;
    if (g_HighDCHuman = Self) then g_HighDCHuman := nil;
    if (g_HighMCHuman = Self) then g_HighMCHuman := nil;
    if (g_HighSCHuman = Self) then g_HighSCHuman := nil;
    if (g_HighOnlineHuman = Self) then g_HighOnlineHuman := nil;
    //人物下线后通知配偶，并把对方的相关记录清空
    if m_DearHuman <> nil then begin
      if m_btGender = 0 then begin
        if g_sManLongOutDearOnlineMsg <> '' then begin
          sSayMsg := AnsiReplaceText(g_sManLongOutDearOnlineMsg, '%d', m_sDearName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
          sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
          sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
          m_DearHuman.SysMsg(sSayMsg, c_Red, t_Hint);
        end;
      end else begin
        if g_sWoManLongOutDearOnlineMsg <> '' then begin
          sSayMsg := AnsiReplaceText(g_sWoManLongOutDearOnlineMsg, '%d', m_sDearName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
          sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
          sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
          m_DearHuman.SysMsg(sSayMsg, c_Red, t_Hint);
        end;
      end;
      m_DearHuman.m_DearHuman := nil;
      m_DearHuman := nil;
    end;
    if (m_MasterHuman <> nil) or (m_MasterList.Count > 0) then begin
      if m_boMaster then begin
        if m_MasterList.Count > 0 then begin //2008629
          for I := 0 to m_MasterList.Count - 1 do begin
            Human := TPlayObject(m_MasterList.Items[I]);
            if g_sMasterLongOutMasterListOnlineMsg <> '' then begin
              sSayMsg := AnsiReplaceText(g_sMasterLongOutMasterListOnlineMsg, '%s', m_sCharName);
              sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
              sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
              sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
              Human.SysMsg(sSayMsg, c_Red, t_Hint);
            end;
            Human.m_MasterHuman := nil;
          end;
        end;
      end else begin
        if m_MasterHuman = nil then Exit;
        if g_sMasterListLongOutMasterOnlineMsg <> '' then begin
          sSayMsg := AnsiReplaceText(g_sMasterListLongOutMasterOnlineMsg, '%d', MoneyToCharacter(m_nMasterNo, False) {m_sMasterName}); //20080603
          sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
          sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
          sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
          m_MasterHuman.SysMsg(sSayMsg, c_Red, t_Hint);
        end;
        //如果为大徒弟则将对方的记录清空
        if m_MasterHuman.m_sMasterName = m_sCharName then begin
          m_MasterHuman.m_MasterHuman := nil;
        end;

        for I := m_MasterHuman.m_MasterList.Count - 1 downto 0 do begin
          if m_MasterHuman.m_MasterList.Count <= 0 then Break;
          if m_MasterHuman.m_MasterList.Items[I] = Self then begin
            m_MasterHuman.m_MasterList.Delete(I);
            Break;
          end;
        end; //for
      end;
    end;
  except
    on E: Exception do begin
      MainOutMessage(format(sExceptionMsg, [g_sExceptionVer]));
      //MainOutMessage(E.Message);
    end;
  end;
  inherited;
end;
//取玩家数据

function TPlayObject.GetMyInfo: string;
var
  sMyInfo: string;
begin
  sMyInfo := g_sMyInfo;
  sMyInfo := AnsiReplaceText(sMyInfo, '%name', m_sCharName);
  sMyInfo := AnsiReplaceText(sMyInfo, '%map', m_PEnvir.sMapDesc);
  sMyInfo := AnsiReplaceText(sMyInfo, '%x', IntToStr(m_nCurrX));
  sMyInfo := AnsiReplaceText(sMyInfo, '%y', IntToStr(m_nCurrY));
  sMyInfo := AnsiReplaceText(sMyInfo, '%level', IntToStr(m_Abil.Level));
  sMyInfo := AnsiReplaceText(sMyInfo, '%gold', IntToStr(m_nGold));
  sMyInfo := AnsiReplaceText(sMyInfo, '%pk', IntToStr(m_nPkPoint));
  sMyInfo := AnsiReplaceText(sMyInfo, '%minhp', IntToStr(m_WAbil.HP));
  sMyInfo := AnsiReplaceText(sMyInfo, '%maxhp', IntToStr(m_WAbil.MaxHP));
  sMyInfo := AnsiReplaceText(sMyInfo, '%minmp', IntToStr(m_WAbil.MP));
  sMyInfo := AnsiReplaceText(sMyInfo, '%maxmp', IntToStr(m_WAbil.MaxMP));
  sMyInfo := AnsiReplaceText(sMyInfo, '%mindc', IntToStr(LoWord(m_WAbil.DC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%maxdc', IntToStr(HiWord(m_WAbil.DC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%minmc', IntToStr(LoWord(m_WAbil.MC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%maxmc', IntToStr(HiWord(m_WAbil.MC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%minsc', IntToStr(LoWord(m_WAbil.SC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%maxsc', IntToStr(HiWord(m_WAbil.SC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%logontime', DateTimeToStr(m_dLogonTime));
  sMyInfo := AnsiReplaceText(sMyInfo, '%logonlong', IntToStr((GetTickCount - m_dwLogonTick) div 60000));
  Result := sMyInfo;
end;
//检查物品是当前账号的捆绑物品

function TPlayObject.CheckItemBindUse(UserItem: pTUserItem): Boolean;
var
  I: Integer;
  ItemBind: pTItemBind;
begin
  Result := True;
  g_ItemBindAccount.Lock;
  try
    if g_ItemBindAccount.Count > 0 then begin //20080629
      for I := 0 to g_ItemBindAccount.Count - 1 do begin
        ItemBind := g_ItemBindAccount.Items[I];
        if ItemBind <> nil then begin
          if (ItemBind.nMakeIdex = UserItem.MakeIndex) and
            (ItemBind.nItemIdx = UserItem.wIndex) then begin
            Result := False;
            if (CompareText(ItemBind.sBindName, m_sUserID) = 0) then begin
              Result := True;
            end else begin
              SysMsg(g_sItemIsNotThisAccount, c_Red, t_Hint);
            end;
            Exit;
          end;
        end;
      end;
    end;
  finally
    g_ItemBindAccount.UnLock;
  end;

  g_ItemBindIPaddr.Lock;
  try
    if g_ItemBindIPaddr.Count > 0 then begin //20080629
      for I := 0 to g_ItemBindIPaddr.Count - 1 do begin
        ItemBind := g_ItemBindIPaddr.Items[I];
        if ItemBind <> nil then begin
          if (ItemBind.nMakeIdex = UserItem.MakeIndex) and
            (ItemBind.nItemIdx = UserItem.wIndex) then begin
            Result := False;
            if (CompareText(ItemBind.sBindName, m_sIPaddr) = 0) then begin
              Result := True;
            end else begin
              SysMsg(g_sItemIsNotThisIPaddr, c_Red, t_Hint);
            end;
            Exit;
          end;
        end;
      end;
    end;
  finally
    g_ItemBindIPaddr.UnLock;
  end;
  g_ItemBindCharName.Lock;
  try
    if g_ItemBindCharName.Count > 0 then begin //20080629
      for I := 0 to g_ItemBindCharName.Count - 1 do begin
        ItemBind := g_ItemBindCharName.Items[I];
        if ItemBind <> nil then begin
          if (ItemBind.nMakeIdex = UserItem.MakeIndex) and
            (ItemBind.nItemIdx = UserItem.wIndex) then begin
            Result := False;
            if (CompareText(ItemBind.sBindName, m_sCharName) = 0) then begin
              Result := True;
            end else begin
              SysMsg(g_sItemIsNotThisCharName, c_Red, t_Hint);
            end;
            Exit;
          end;
        end;
      end;
    end;
  finally
    g_ItemBindCharName.UnLock;
  end;
end;

procedure TPlayObject.ProcessClientPassword(ProcessMsg: pTProcessMessage);
var
  nLen: Integer;
  sData: string;
begin
  if ProcessMsg.wParam = 0 then begin
    ProcessUserLineMsg('@' + g_GameCommand.UnLock.sCmd);
    Exit;
  end;
  sData := ProcessMsg.sMsg;
  nLen := Length(sData);
  if m_boSetStoragePwd then begin
    m_boSetStoragePwd := False;
    if (nLen > 3) and (nLen < 8) then begin
      m_sTempPwd := sData;
      m_boReConfigPwd := True;
      SysMsg(g_sReSetPasswordMsg, c_Green, t_Hint); {'请重复输入一次仓库密码：'}
      SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
    end else begin
      SysMsg(g_sPasswordOverLongMsg, c_Red, t_Hint); {'输入的密码长度不正确！！！，密码长度必须在 4 - 7 的范围内，请重新设置密码。'}
    end;
    Exit;
  end;
  if m_boReConfigPwd then begin
    m_boReConfigPwd := False;
    if CompareStr(m_sTempPwd, sData) = 0 then begin
      m_sStoragePwd := sData;
      m_boPasswordLocked := True;
      m_sTempPwd := '';
      SysMsg(g_sReSetPasswordOKMsg, c_Blue, t_Hint); {'密码设置成功！！，仓库已经自动上锁，请记好您的仓库密码，在取仓库时需要使用此密码开锁。'}
    end else begin
      m_sTempPwd := '';
      SysMsg(g_sReSetPasswordNotMatchMsg, c_Red, t_Hint);
    end;
    Exit;
  end;
  if m_boUnLockPwd or m_boUnLockStoragePwd then begin
    if CompareStr(m_sStoragePwd, sData) = 0 then begin
      m_boPasswordLocked := False;
      if m_boUnLockPwd then begin
        if g_Config.boLockDealAction then m_boCanDeal := True;
        if g_Config.boLockDropAction then m_boCanDrop := True;
        if g_Config.boLockWalkAction then m_boCanWalk := True;
        if g_Config.boLockRunAction then m_boCanRun := True;
        if g_Config.boLockHitAction then m_boCanHit := True;
        if g_Config.boLockSpellAction then m_boCanSpell := True;
        if g_Config.boLockCallHeroAction then m_boCallHero := True; //是否锁定召唤英雄操作  20080529
        if g_Config.boLockSendMsgAction then m_boCanSendMsg := True;
        if g_Config.boLockUserItemAction then m_boCanUseItem := True;
        if g_Config.boLockInObModeAction then begin
          m_boObMode := False;
          m_boAdminMode := False;
        end;
        m_boLockLogoned := True;
        SysMsg(g_sPasswordUnLockOKMsg, c_Blue, t_Hint);
      end;
      if m_boUnLockStoragePwd then begin
        if g_Config.boLockGetBackItemAction then m_boCanGetBackItem := True;
        SysMsg(g_sStorageUnLockOKMsg, c_Blue, t_Hint);
      end;

    end else begin
      Inc(m_btPwdFailCount);
      SysMsg(g_sUnLockPasswordFailMsg, c_Red, t_Hint);
      if m_btPwdFailCount > 3 then begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
      end;
    end;
    m_boUnLockPwd := False;
    m_boUnLockStoragePwd := False;
    Exit;
  end;

  if m_boCheckOldPwd then begin
    m_boCheckOldPwd := False;
    if m_sStoragePwd = sData then begin
      SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
      SysMsg(g_sSetPasswordMsg, c_Green, t_Hint);
      m_boSetStoragePwd := True;
    end else begin
      Inc(m_btPwdFailCount);
      SysMsg(g_sOldPasswordIncorrectMsg, c_Red, t_Hint);
      if m_btPwdFailCount > 3 then begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        m_boPasswordLocked := True;
      end;
    end;
    Exit;
  end;
end;
//人物死亡掉背包物品 20080120

procedure TPlayObject.ScatterBagItems(ItemOfCreat: TBaseObject);
var
  I, DropWide: Integer;
  pu: pTUserItem;
  DelList: TStringList;
  boDropall: Boolean;
  sCheckItemName: string;
  StdItem: pTStdItem;
resourcestring
  sExceptionMsg = '{%s} TPlayObject::ScatterBagItems';
begin
  m_boCanQueryBag := True; //死亡掉背包时,不能刷新包裹 20080917
  try
    DelList := nil;
    if m_boAngryRing or m_boNoDropItem then Exit; //不死戒指
    if m_PEnvir.m_boNODROPITEM then Exit; //地图禁止死亡掉物品则退出 20080503
    boDropall := False;
    DropWide := 2;
    if g_Config.boDieRedScatterBagAll and (PKLevel >= 2) then boDropall := True;
    //非红名掉1/3 //红名全掉
    try
      for I := m_ItemList.Count - 1 downto 0 do begin
        if m_ItemList.Count <= 0 then Break;
        if boDropall or (Random(g_Config.nDieScatterBagRate) = 0) then begin
          if m_ItemList[I] <> nil then begin
            pu := pTUserItem(m_ItemList[I]);
            if (pu.AddValue[0] = 1) and (GetHoursCount(pu.MaxDate, Now) <= 0) then begin //删除到期装备
              m_ItemList.Delete(I);
              Dispose(pu);
              Continue;
            end;
            if CheckItemValue(pu, 5) then Continue; //20110529 禁止爆出
            sCheckItemName := UserEngine.GetStdItemName(pu.wIndex);
            if PlugOfCheckCanItem(6, sCheckItemName, False, 0, 0) then Continue; //禁止物品规则(永不爆出) 20080729
            if CheckItemBindDieNoDrop(m_ItemList[I]) then Continue; //人物装备绑定死亡不爆 20081127

            StdItem := UserEngine.GetStdItem(pu.wIndex);
            if StdItem <> nil then begin
              if (StdItem.StdMode = 51) and (pu.Dura > 0) and (pu.btValue[20] = 1) then begin
                case StdItem.Shape of
                  0: begin //是聚灵珠 20080611
                      n_UsesItemTick := 0; //时间初始
                      pu.btValue[12] := 2; //不能聚集的标识
                    end;
                  1, 2: pu.btValue[12] := 2; //内功珠不能聚集的标识
                end;
              end;
            end;
            if DropItemDown(pTUserItem(m_ItemList[I]), DropWide, True, True, ItemOfCreat, Self) then begin
              if m_btRaceServer = RC_PLAYOBJECT then begin
                if DelList = nil then DelList := TStringList.Create;
                DelList.AddObject(UserEngine.GetStdItemName(pu.wIndex), TObject(pu.MakeIndex));
              end;
              Dispose(pTUserItem(m_ItemList[I])); //修改
              m_ItemList.Delete(I);
            end;
          end;
        end;
      end; //for
      if DelList <> nil then begin
        SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
      end;
    except   
      MainOutMessage(format(sExceptionMsg, [g_sExceptionVer]));
    end;
  finally
    m_boCanQueryBag := False; //死亡掉背包时,不能刷新包裹 20080917
  end;
end;

procedure TPlayObject.RecallHuman(sHumName: string);
var
  PlayObject: TPlayObject;
  nX, nY, n18, n1C: Integer;
begin
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject <> nil then begin
    if GetFrontPosition(nX, nY) then begin
      if sub_4C5370(nX, nY, 3, n18, n1C) then begin
        PlayObject.SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
        PlayObject.SpaceMove(m_sMapName, n18, n1C, 0);
      end;
    end else begin
      SysMsg('召唤失败！', c_Red, t_Hint);
    end;
  end else begin
    SysMsg(Format_ToStr(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
  end;
end;
//申请行会战

procedure TPlayObject.ReQuestGuildWar(sGuildName: string);
var
  Guild: TGUild;
  WarGuild: pTWarGuild;
  boReQuestOK: Boolean;
begin
  if not IsGuildMaster then begin
    SysMsg('只有行会掌门人才能申请！', c_Red, t_Hint);
    Exit;
  end;
  if nServerIndex <> 0 then begin
    SysMsg('这个命令不能在本服务器上使用！', c_Red, t_Hint);
    Exit;
  end;
  Guild := g_GuildManager.FindGuild(sGuildName);
  if Guild = nil then begin
    SysMsg(sGuildName + ' 无法查找指定行会', c_Red, t_Hint);
    Exit;
  end;
  if Guild = TGUild(m_MyGuild) then begin //20090510 不能与自己行会进行行会战
    SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '我们不鼓励打内战的，请重新输入');
    Exit;
  end;
  boReQuestOK := False;
  WarGuild := TGUild(m_MyGuild).AddWarGuild(Guild);
  if WarGuild <> nil then begin
    if Guild.AddWarGuild(TGUild(m_MyGuild)) = nil then begin
      WarGuild.dwWarTick := 0;
    end else begin
      boReQuestOK := True;
    end;
  end;
  {if boReQuestOK then begin//20101022 注释
    UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGUild(m_MyGuild).sGuildName);
    UserEngine.SendServerGroupMsg(SS_207, nServerIndex, Guild.sGuildName);
  end;}
end;
//客户端申请行会战 20090510

procedure TPlayObject.ClientReQuestGuildWar(sGuildName: string);
var
  Guild: TGUild;
  WarGuild: pTWarGuild;
  boReQuestOK: Boolean;
begin
  try
    if not IsGuildMaster then begin
      SysMsg('只有行会掌门人才能申请！', c_Red, t_Hint);
      Exit;
    end;
    Guild := g_GuildManager.FindGuild(sGuildName);
    if Guild <> nil then begin
      if Guild = TGUild(m_MyGuild) then begin //20090510 不能与自己行会进行行会战
        SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '我们不鼓励打内战的，请重新输入');
        Exit;
      end;
      if m_nGold >= g_Config.nGuildWarPrice then begin
        DecGold(g_Config.nGuildWarPrice);
        GoldChanged();
        boReQuestOK := False;
        WarGuild := TGUild(m_MyGuild).AddWarGuild(Guild);
        if WarGuild <> nil then begin
          if Guild.AddWarGuild(TGUild(m_MyGuild)) = nil then begin
            WarGuild.dwWarTick := 0;
          end else begin
            boReQuestOK := True;
          end;
        end;
        {if boReQuestOK then begin //20101022 注释
          UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGUild(m_MyGuild).sGuildName);
          UserEngine.SendServerGroupMsg(SS_207, nServerIndex, Guild.sGuildName);
        end;}
      end else begin
        SysMsg('您没有足够的金币！！！', c_Red, t_Hint);
      end;
    end else begin
      SysMsg(sGuildName + ' 无法查找指定行会', c_Red, t_Hint);
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientReQuestGuildWar', [g_sExceptionVer]));
  end;
end;

function TPlayObject.CheckDenyLogon(): Boolean;
begin
  Result := False;
  if GetDenyIPaddrList(m_sIPaddr) then begin
    SysMsg(g_sYourIPaddrDenyLogon, c_Red, t_Hint);
    Result := True;
  end else
    if GetDenyAccountList(m_sUserID) then begin
      SysMsg(g_sYourAccountDenyLogon, c_Red, t_Hint);
      Result := True;
    end else
      if GetDenyChrNameList(m_sCharName) then begin //检查是否是禁止登陆的人物
        SysMsg(g_sYourCharNameDenyLogon, c_Red, t_Hint);
        Result := True;
      end;
  if Result then begin
    m_boEmergencyClose := True;
    m_boPlayOffLine := False;
  end;
end;

function TPlayObject.IsGotoLabel(sMapName: string; nX, nY, nRange, nQuestFalgStatus: Integer; boQuestFalgStatus: Boolean; sItemName1, sItemName2: string; boNeedGroup: Boolean; nRandomCount: Integer): Boolean;
var
  n01: Integer;
  nMaxCurrX, nMaxCurrY, nMinCurrX, nMinCurrY: Integer;
  function GetAllowItem: Boolean;
  begin
    Result := False;
    if sItemName1 = '*' then begin
      Result := True;
    end else
      if CompareText(sItemName1, sItemName2) = 0 then begin
        Result := True;
      end;
  end;
  function GetRandomCount: Boolean;
  begin
    Result := False;
    if nRandomCount = 0 then Result := True
    else if (nRandomCount > 0) and (Random(nRandomCount div 2 + nRandomCount) = nRandomCount) then Result := True;
  end;
  function GetGroup: Boolean;
  begin
    Result := False;
    if not boNeedGroup then Result := True
    else if m_GroupOwner <> nil then Result := True;
  end;
begin
  Result := False;
  nMaxCurrX := nX + nRange;
  nMaxCurrY := nY + nRange;
  nMinCurrX := nX - nRange;
  nMinCurrY := nY - nRange;
  if (CompareText(sMapName, m_sMapName) = 0) and (m_nCurrX <= nMaxCurrX) and (m_nCurrX >= nMinCurrX) and (m_nCurrY <= nMaxCurrY) and (m_nCurrY >= nMinCurrY) then begin
    if nQuestFalgStatus > 0 then begin
      n01 := GetQuestFalgStatus(nQuestFalgStatus);
      if (n01 = 0) and (not boQuestFalgStatus) then begin
        if GetAllowItem and GetGroup and GetRandomCount then begin
          Result := True;
        end;
      end else
        if (n01 <> 0) and (boQuestFalgStatus) then begin
          if GetAllowItem and GetGroup and GetRandomCount then begin
            Result := True;
          end;
        end;
    end else begin
      if GetAllowItem and GetGroup and GetRandomCount then begin
        Result := True;
      end;
    end;
  end;
end;

procedure TPlayObject.StartMapEventOfDropItem(sItemName: string);
var
  I: Integer;
  boGotoLabel: Boolean;
  MapEvent: pTMapEvent;
  nCode: Byte;
begin
  try
    nCode := 0;
    {g_MapEventListOfDropItem.Lock;
    try }
    MapEvent := nil; //20080529
    boGotoLabel := False;
    if g_MapEventListOfDropItem.Count > 0 then begin //20080629
      nCode := 1;
      for I := 0 to g_MapEventListOfDropItem.Count - 1 do begin
        nCode := 2;
        MapEvent := pTMapEvent(g_MapEventListOfDropItem.Items[I]);
        nCode := 3;
        if MapEvent <> nil then begin
          nCode := 4;
          if IsGotoLabel(MapEvent.m_sMapName,
            MapEvent.m_nCurrX,
            MapEvent.m_nCurrY,
            MapEvent.m_nRange,
            MapEvent.m_MapFlag.nQuestUnit,
            MapEvent.m_MapFlag.boOpen,
            MapEvent.m_Condition.sItemName,
            sItemName,
            MapEvent.m_Condition.boNeedGroup, MapEvent.m_nRandomCount) then begin
            boGotoLabel := True;
            Break;
          end;
        end;
      end;
    end;
    if boGotoLabel and (MapEvent <> nil) then begin
      case MapEvent.m_StartScript.nLable of
        0: ;
        1: begin
            if g_FunctionNPC <> nil then begin
              nCode := 5;
              g_FunctionNPC.GotoLable(Self, MapEvent.m_StartScript.sLable, False, False);
            end;
          end;
      end;
    end;
    {finally
      g_MapEventListOfDropItem.UnLock;
    end; }
  except   
    MainOutMessage(format('{%s} TPlayObject.StartMapEventOfDropItem Code:%d', [g_sExceptionVer, nCode]));
  end;
end;
//地图捡物品触发

procedure TPlayObject.StartMapEventOfPickUpItem(sItemName: string);
var
  I: Integer;
  boGotoLabel: Boolean;
  MapEvent: pTMapEvent;
  nCode: Byte;
begin
  try
    nCode := 0;
    {g_MapEventListOfPickUpItem.Lock;
    try}
    MapEvent := nil; //20080529
    boGotoLabel := False;
    nCode := 1;
    if g_MapEventListOfPickUpItem.Count > 0 then begin //20080629
      nCode := 2;
      for I := 0 to g_MapEventListOfPickUpItem.Count - 1 do begin
        nCode := 3;
        MapEvent := pTMapEvent(g_MapEventListOfPickUpItem.Items[I]);
        nCode := 4;
        if MapEvent <> nil then begin
          nCode := 5;
          if IsGotoLabel(MapEvent.m_sMapName,
            MapEvent.m_nCurrX,
            MapEvent.m_nCurrY,
            MapEvent.m_nRange,
            MapEvent.m_MapFlag.nQuestUnit,
            MapEvent.m_MapFlag.boOpen,
            MapEvent.m_Condition.sItemName,
            sItemName,
            MapEvent.m_Condition.boNeedGroup, MapEvent.m_nRandomCount) then begin
            boGotoLabel := True;
            Break;
          end;
        end;
      end;
    end;
    if boGotoLabel and (MapEvent <> nil) then begin
      case MapEvent.m_StartScript.nLable of
        0: ;
        1: begin
            if g_FunctionNPC <> nil then begin
              nCode := 6;
              g_FunctionNPC.GotoLable(Self, MapEvent.m_StartScript.sLable, False, False);
            end;
          end;
      end;
    end;
   { finally
      g_MapEventListOfPickUpItem.UnLock;
    end;}
  except   
    MainOutMessage(format('{%s} TPlayObject.StartMapEventOfPickUpItem Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

procedure TPlayObject.StartMapEventOfMine();
var
  I: Integer;
  boGotoLabel: Boolean;
  MapEvent: pTMapEvent;
  nCode: Byte;
begin
  try
    nCode := 0;
   { g_MapEventListOfMine.Lock;
    try}
    MapEvent := nil; //20080529
    boGotoLabel := False;
    nCode := 1;
    if g_MapEventListOfMine.Count > 0 then begin //20080629
      nCode := 2;
      for I := 0 to g_MapEventListOfMine.Count - 1 do begin
        nCode := 3;
        MapEvent := pTMapEvent(g_MapEventListOfMine.Items[I]);
        nCode := 4;
        if MapEvent <> nil then begin
          nCode := 5;
          if IsGotoLabel(MapEvent.m_sMapName,
            MapEvent.m_nCurrX,
            MapEvent.m_nCurrY,
            MapEvent.m_nRange,
            MapEvent.m_MapFlag.nQuestUnit,
            MapEvent.m_MapFlag.boOpen,
            MapEvent.m_Condition.sItemName,
            '*',
            MapEvent.m_Condition.boNeedGroup, MapEvent.m_nRandomCount) then begin
            boGotoLabel := True;
            Break;
          end;
        end;
      end;
    end;
    if boGotoLabel and (MapEvent <> nil) then begin
      case MapEvent.m_StartScript.nLable of
        0: ;
        1: begin
            if g_FunctionNPC <> nil then begin
              nCode := 6;
              g_FunctionNPC.GotoLable(Self, MapEvent.m_StartScript.sLable, False, False);
            end;
          end;
      end;
    end;
    {finally
      g_MapEventListOfMine.UnLock;
    end;}
  except   
    MainOutMessage(format('{%s} TPlayObject.StartMapEventOfMine Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

procedure TPlayObject.StartMapEventOfWalk();
var
  I: Integer;
  boGotoLabel: Boolean;
  MapEvent: pTMapEvent;
  nCode: Byte;
begin
  try
    nCode := 0;
    {g_MapEventListOfWalk.Lock;
    try}
    MapEvent := nil; //20080529
    boGotoLabel := False;
    nCode := 1;
    if g_MapEventListOfWalk.Count > 0 then begin //20081223
      nCode := 2;
      for I := 0 to g_MapEventListOfWalk.Count - 1 do begin
        nCode := 3;
        MapEvent := pTMapEvent(g_MapEventListOfWalk.Items[I]);
        nCode := 4;
        if MapEvent <> nil then begin
          nCode := 5;
          if IsGotoLabel(MapEvent.m_sMapName,
            MapEvent.m_nCurrX,
            MapEvent.m_nCurrY,
            MapEvent.m_nRange,
            MapEvent.m_MapFlag.nQuestUnit,
            MapEvent.m_MapFlag.boOpen,
            MapEvent.m_Condition.sItemName,
            '*',
            MapEvent.m_Condition.boNeedGroup, MapEvent.m_nRandomCount) then begin
            boGotoLabel := True;
            Break;
          end;
        end;
      end;
    end;
    if boGotoLabel and (MapEvent <> nil) then begin
      case MapEvent.m_StartScript.nLable of
        0: ;
        1: begin
            if g_FunctionNPC <> nil then begin
              nCode := 6;
              g_FunctionNPC.GotoLable(Self, MapEvent.m_StartScript.sLable, False, False);
            end;
          end;
      end;
    end;
    {finally
      g_MapEventListOfWalk.UnLock;
    end;}
  except   
    MainOutMessage(format('{%s} TPlayObject.StartMapEventOfWalk Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

procedure TPlayObject.StartMapEventOfRun();
var
  I: Integer;
  boGotoLabel: Boolean;
  MapEvent: pTMapEvent;
  nCode: Byte;
begin
  try
    nCode := 0;
   { g_MapEventListOfRun.Lock;
    try}
    MapEvent := nil; //20080529
    boGotoLabel := False;
    nCode := 1;
    if g_MapEventListOfRun.Count > 0 then begin //20080629
      nCode := 2;
      for I := 0 to g_MapEventListOfRun.Count - 1 do begin
        nCode := 3;
        MapEvent := pTMapEvent(g_MapEventListOfRun.Items[I]);
        nCode := 4;
        if MapEvent <> nil then begin
          nCode := 5;
          if IsGotoLabel(MapEvent.m_sMapName,
            MapEvent.m_nCurrX,
            MapEvent.m_nCurrY,
            MapEvent.m_nRange,
            MapEvent.m_MapFlag.nQuestUnit,
            MapEvent.m_MapFlag.boOpen,
            MapEvent.m_Condition.sItemName,
            '*',
            MapEvent.m_Condition.boNeedGroup, MapEvent.m_nRandomCount) then begin
            boGotoLabel := True;
            Break;
          end;
        end;
      end;
    end;
    if boGotoLabel and (MapEvent <> nil) then begin
      case MapEvent.m_StartScript.nLable of
        0: ;
        1: begin
            if g_FunctionNPC <> nil then begin
              nCode := 6;
              g_FunctionNPC.GotoLable(Self, MapEvent.m_StartScript.sLable, False, False);
            end;
          end;
      end;
    end;
    {finally
      g_MapEventListOfRun.UnLock;
    end;}
  except   
    MainOutMessage(format('{%s} TPlayObject.StartMapEventOfRun Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

procedure TPlayObject.ProcessUserCmd(sParam1, sParam2, sParam3, sParam4,
  sParam5, sParam6, sParam7: string);
begin
  SysMsg(sParam2, c_Green, t_Hint);
end;

function TPlayObject.WearDragon: Boolean;
var
  StdItem: pTStdItem;
begin
// 20080102修改成下面那段,以支持祝福罐.魔令包功
  Result := False;
  if m_UseItems[U_BUJUK].wIndex > 0 then begin
    StdItem := UserEngine.GetStdItem(m_UseItems[U_BUJUK].wIndex);
    if (StdItem <> nil) and (StdItem.StdMode = 2) and (StdItem.AniCount = 21) then begin
      Result := True; //祝福罐.魔令包
    end;
  end;
end;
//支持祝福罐.魔令包功能 20080102  btType:2--主人  4--英雄

procedure TPlayObject.RepairDragon(btType: Byte; nItemIdx: Integer; sItemName: string);
var
  I, n14: Integer;
  UserItem: pTUserItem;
  StdItem, StdItem1: pTStdItem; //20080313
  sUserItemName: string;
  boRepairOK: Boolean;
  ItemList: TList;
  OldDura: Word;
begin
  boRepairOK := False;
  ItemList := nil;
  StdItem := nil;
  StdItem1 := nil;
  UserItem := nil;
  OldDura := 0;
  n14 := -1;
  if WearDragon then begin
    if m_UseItems[U_BUJUK].Dura < m_UseItems[U_BUJUK].DuraMax then begin
      OldDura := m_UseItems[U_BUJUK].Dura;
      case btType of
        2: ItemList := m_Master.m_ItemList;
        4: ItemList := m_ItemList;
      end;
      if ItemList <> nil then begin
        if ItemList.Count > 0 then begin //20080629
          for I := 0 to ItemList.Count - 1 do begin
            UserItem := ItemList.Items[I];
            if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then begin
              //取自定义物品名称
              sUserItemName := '';
              if UserItem.btValue[13] = 1 then sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
              if sUserItemName = '' then sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem <> nil then begin
                if CompareText(sUserItemName, sItemName) = 0 then begin
                  n14 := I;
                  StdItem1 := UserEngine.GetStdItem(m_UseItems[U_BUJUK].wIndex); //20080313
                  Break;
                end;
              end;
            end;
            UserItem := nil;
          end; //for
        end;
                                                                     {存的物品的外观要对罐的Source属性,罐物品的Shape=放入物品的StdMode ,衣服武器不能存 20080315}
        if (StdItem <> nil) and (UserItem <> nil) and (StdItem.Shape = StdItem1.Source) and (StdItem.StdMode = StdItem1.Shape) and (not (StdItem.StdMode in [5, 6, 10, 11])) then begin
          Inc(m_UseItems[U_BUJUK].Dura, 1000);
          if m_UseItems[U_BUJUK].Dura > m_UseItems[U_BUJUK].DuraMax then m_UseItems[U_BUJUK].Dura := m_UseItems[U_BUJUK].DuraMax;
          boRepairOK := True;
          case btType of
            2: m_Master.DelBagItem(n14);
            4: DelBagItem(n14);
          end;
        end;
      end;
    end;
  end;
  if boRepairOK then begin
    if OldDura <> m_UseItems[U_BUJUK].Dura then
      SendMsg(Self, RM_DURACHANGE, U_BUJUK, m_UseItems[U_BUJUK].Dura, m_UseItems[U_BUJUK].DuraMax, 0, '');
    SendDefMessage(SM_REPAIRDRAGON_OK, btType, 0, 0, 0, '');
  end else begin
    SendDefMessage(SM_REPAIRDRAGON_FAIL, btType, 0, 0, 0, '');
  end;
end;
//双击装备位置的祝福罐,自动把包裹里的祝福油填充完毕) 20100928

procedure TPlayObject.ClientDblRepairDragon();
var
  I: Integer;
  UserItem: pTUserItem;
  StdItem, StdItem1: pTStdItem;
begin
  try
    if WearDragon then begin //判断装备是否为祝福罐类物品
      if m_UseItems[U_BUJUK].Dura < m_UseItems[U_BUJUK].DuraMax then begin
        if m_ItemList.Count > 0 then begin
          StdItem1 := UserEngine.GetStdItem(m_UseItems[U_BUJUK].wIndex);
          if StdItem1 <> nil then begin
            for I := m_ItemList.Count - 1 downto 0 do begin
              if (m_ItemList.Count <= 0) or (m_UseItems[U_BUJUK].Dura = m_UseItems[U_BUJUK].DuraMax) then Break;
              UserItem := m_ItemList.Items[I];
              if (UserItem <> nil) then begin
                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                if StdItem <> nil then begin
                  if (StdItem.Shape = StdItem1.Source) and (StdItem.StdMode = StdItem1.Shape) and (not (StdItem.StdMode in [5, 6, 10, 11])) then begin
                    Inc(m_UseItems[U_BUJUK].Dura, 1000);
                    SendDelItems(UserItem); //发送删除物品
                    DelBagItem(I);
                    if m_UseItems[U_BUJUK].Dura > m_UseItems[U_BUJUK].DuraMax then begin
                      m_UseItems[U_BUJUK].Dura := m_UseItems[U_BUJUK].DuraMax;
                      Break;
                    end;
                  end;
                end;
              end;
            end; //for
            SendUpdateItem(@m_UseItems[U_BUJUK]);
          end;
        end;
      end;
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientDblRepairDragon', [g_sExceptionVer]));
  end;
end;
//自动填充祝福油类物品  20110411

function TPlayObject.AutoRepairDragon(StdItem: pTStdItem): Boolean;
var
  I: Integer;
  StdItem1: pTStdItem;
begin
  Result := False;
  try
    if WearDragon then begin //判断装备是否为祝福罐类物品
      if m_UseItems[U_BUJUK].Dura < m_UseItems[U_BUJUK].DuraMax then begin
        StdItem1 := UserEngine.GetStdItem(m_UseItems[U_BUJUK].wIndex);
        if StdItem1 <> nil then begin
          if StdItem <> nil then begin
            if (StdItem.Shape = StdItem1.Source) and (StdItem.StdMode = StdItem1.Shape)
              and (not (StdItem.StdMode in [5, 6, 10, 11])) and (StdItem1.StdMode = 2)
              and (StdItem1.AniCount = 21) then begin
              Inc(m_UseItems[U_BUJUK].Dura, 1000);
              if m_UseItems[U_BUJUK].Dura > m_UseItems[U_BUJUK].DuraMax then begin
                m_UseItems[U_BUJUK].Dura := m_UseItems[U_BUJUK].DuraMax;
              end;
              SendUpdateItem(@m_UseItems[U_BUJUK]);
              Result := True;
            end;
          end;
        end;
      end;
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.AutoRepairDragon', [g_sExceptionVer]));
  end;
end;
//-----------------------------------宝箱系统-----------------------------------
//判断宝箱和钥匙是否对应,对应是打开箱子，并删除箱子及钥匙物品

procedure TPlayObject.ClientSendBoxItem(BoxsIdx: Integer; str: string {str为客户端传来的钥匙makeidx}; boShowEff: Boolean);
var
  I: Integer;
  UserItem: pTUserItem;
  StdItemBox, StdItemKey: pTStdItem;
  KeysIdx: Integer;
  boDelBox, boDelKey: Boolean;
begin
  try
    if m_boOpenBox or m_CattleGasOpenBox then Exit; //如果有宝箱正在操作,则退出 20090310
    StdItemBox := nil;
    StdItemKey := nil;
    KeysIdx := Str_ToInt(trim(str), 0);
    if not m_boDeath then begin
      if IsEnoughBag then begin //包裹不满时
        if m_ItemList.Count > 0 then begin //20080629
          for I := m_ItemList.Count - 1 downto 0 do begin
            if m_ItemList.Count <= 0 then Break;
            UserItem := m_ItemList.Items[I];
            if UserItem = nil then Continue;
            if (UserItem.MakeIndex = BoxsIdx) then begin //得到宝箱
              StdItemBox := UserEngine.GetStdItem(UserItem.wIndex);
              if (StdItemBox <> nil) then begin
                if (StdItemBox.StdMode = 48) then Break;
              end;
            end;
          end; //for

          for I := m_ItemList.Count - 1 downto 0 do begin
            if m_ItemList.Count <= 0 then Break;
            UserItem := m_ItemList.Items[I];
            if UserItem = nil then Continue;
            if (UserItem.MakeIndex = KeysIdx) then begin //得到钥匙
              StdItemKey := UserEngine.GetStdItem(UserItem.wIndex);
              if (StdItemKey <> nil) then begin
                if (StdItemKey.StdMode = 49) then Break;
              end;
            end;
          end; //for
        end;

        if (StdItemBox <> nil) and (StdItemKey <> nil) and (StdItemBox.AniCount = StdItemKey.Shape) then begin //宝箱和钥匙对应,则打开宝箱,删除物品
          if m_ItemList.Count + 4 > MAXBAGITEM then begin //检查包裹是否有4个空位 20090225
            case StdItemBox.Reserved of //Reserved 0=旧宝箱 1=新宝箱 2-九周年宝箱
              0: begin
                  SendMsg(Self, RM_OPENBOXS_FAIL, 0, 0, 0, 0, ''); //失败
                  SysMsg('至少需要预留六个空位', c_Red, t_Hint);
                  Exit;
                end; //0
              1: begin
                  SendMsg(Self, RM_OPENBOXS_FAIL, 0, 0, 0, 0, ''); //失败
                  SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '请保证包裹有6个空位');
                  Exit;
                end; //1
              2: begin
                  SendMsg(Self, RM_OPENBOXS_FAIL, 0, 0, 0, 0, ''); //失败
                  SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '请保证包裹有6个空位');
                  Exit;
                end;
            end;
          end;
          n_OpenBoxCount := 0; //转动宝箱的次数
          n_BoxItmeFilledCount := 0; //物品填充次数
          if ClientOpenBoxs(StdItemBox.Source, StdItemBox.Reserved, boShowEff, True) then begin //宝箱开启 20080618
            boDelBox := False;
            boDelKey := False;
            for I := m_ItemList.Count - 1 downto 0 do begin //删除物品  20080308
              if (m_ItemList.Count <= 0) or (boDelBox and boDelKey) then Break;
              UserItem := m_ItemList.Items[I];
              if UserItem = nil then Continue;
              if (UserItem <> nil) then begin
                if (UserItem.MakeIndex = BoxsIdx) then begin
                  if StdItemBox.NeedIdentify = 1 then
                    AddGameDataLog('11' + #9 + m_sMapName + #9 +
                      IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                      m_sCharName + #9 + StdItemBox.Name + #9 +
                      IntToStr(UserItem.MakeIndex) + #9 + '(开宝箱)' + #9 + '0');
                  m_ItemList.Delete(I);
                  boDelBox := True;
                  SendDelItems(UserItem); //20090225
                  Dispose(UserItem); //20100928 增加
                end else
                  if (UserItem.MakeIndex = KeysIdx) then begin
                    if StdItemKey.NeedIdentify = 1 then
                      AddGameDataLog('11' + #9 + m_sMapName + #9 +
                        IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 + StdItemKey.Name + #9 +
                        IntToStr(UserItem.MakeIndex) + #9 + '(开宝箱)' + #9 + '0');
                    m_ItemList.Delete(I);
                    boDelKey := True;
                    SendDelItems(UserItem); //20090225
                    Dispose(UserItem); //20100928 增加
                  end;
              end; //if (UserItem <> nil) then begin
            end;
          end else begin
            SendMsg(Self, RM_OPENBOXS_FAIL, 0, 0, 0, 0, ''); //失败 20080306
            SysMsg('开启宝箱失败!', c_Red, t_Hint);
          end;
        end else begin
          SendMsg(Self, RM_OPENBOXS_FAIL, 0, 0, 0, 0, ''); //发送打开失败消息
          SysMsg('您的宝箱和钥匙不对应,不能打开宝箱!', c_Red, t_Hint);
        end;
      end else begin //if IsEnoughBag then begin //包裹不满时
        SendMsg(Self, RM_OPENBOXS_FAIL, 0, 0, 0, 0, ''); //失败 20080306
        SysMsg('您的包裹已满,不能开启宝箱!', c_Red, t_Hint);
      end;
    end; //if not m_boDeath
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientSendBoxItem', [g_sExceptionVer]));
  end;
end;
//检查发来的制造ID是否为宝箱物品，检查包裹是否有对应的钥匙,有钥匙则自动打开箱子，没有则提示玩家购买 20090225
//新宝箱模式(双击宝箱)

procedure TPlayObject.CheckItemsKey(MakeIndex: Integer; Anicount: Byte; BoxClose: Byte; BoShowEff: Boolean);
var
  I, KeyMakeIndex: Integer;
  UserItem: pTUserItem;
  StdItemKey: pTStdItem;
  boIsBoxItem: Boolean;
begin
  if BoxClose = 1 then begin //箱子关闭，初始变量，后退出过程
    m_boOpenBox := False; //是否宝箱在打开
    n_OpenBoxTpye := 0; //打开宝箱的类型 0-不可填充 1-可填充 2-九周年度
    m_OpenBoxMakeID := 0; //打开箱子时，没钥匙时，记录ID
    m_boCanRotation := False; //是否可以转动宝箱
    n_KeyAnicount := 0; //钥匙标实
    n_OpenBoxCount := 0; //转动宝箱的次数
    m_boGivePlayItme := False; //给玩家物品
    m_boNoCanRotation := False; //用于标识提示用户无同类宝箱
    n_9YearBoxsID := 0;
    n_9YearUpdateCount := 0; //更换物品次数
    m_boFree9YearsBox := False; //是否取得免费奖励20格箱子
    ClientCloseBoxs(); //清空个人箱子列表资源,关闭箱子 20090719
    Exit;
  end;
  if m_boOpenBox or m_CattleGasOpenBox then Exit; //如果有宝箱正在操作,则退出
  KeyMakeIndex := 0;
  boIsBoxItem := False;
  if m_ItemList.Count > 0 then begin //检查物品是否是宝箱类型
    for I := m_ItemList.Count - 1 downto 0 do begin
      if m_ItemList.Count <= 0 then Break;
      UserItem := m_ItemList.Items[I];
      if UserItem = nil then Continue;
      if (UserItem.MakeIndex = MakeIndex) then begin //找到宝箱
        StdItemKey := UserEngine.GetStdItem(UserItem.wIndex);
        if (StdItemKey <> nil) then begin
          if (StdItemKey.StdMode = 48) and (StdItemKey.AniCount = Anicount) then begin
            boIsBoxItem := True;
            Break;
          end;
        end;
      end;
    end; //for
  end;
  if boIsBoxItem then begin
    for I := m_ItemList.Count - 1 downto 0 do begin //检查是否有钥匙
      if m_ItemList.Count <= 0 then Break;
      UserItem := m_ItemList.Items[I];
      if UserItem = nil then Continue;
      StdItemKey := UserEngine.GetStdItem(UserItem.wIndex);
      if (StdItemKey <> nil) then begin
        if (StdItemKey.StdMode = 49) and (StdItemKey.Shape = Anicount) then begin //找到对应的钥匙
          KeyMakeIndex := UserItem.MakeIndex;
          Break;
        end;
      end;
    end; //for
    if KeyMakeIndex > 0 then begin //包裹有钥匙，直接打开箱子
      n_KeyAnicount := Anicount; //钥匙标实
      ClientSendBoxItem(MakeIndex, IntToStr(KeyMakeIndex), BoShowEff); //发送箱子物品
    end else begin //提示玩家购买对应的钥匙
      StdItemKey := UserEngine.GetBoxKeyItem(Anicount);
      if (StdItemKey <> nil) then begin //提示玩家购买， 取钥匙名字，及元宝数
        if m_nGameGold > 0 then begin //检查玩家元宝是否为0
          m_OpenBoxMakeID := MakeIndex; //打开箱子时，没钥匙时，记录ID
          n_KeyAnicount := Anicount; //钥匙标实
          if BoShowEff then
            SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 1, 1 {显示全部更新的特效}, Format('您需要 %s(%d%s) 才能开启此宝箱，是否现在购买钥匙？', [StdItemKey.Name, StdItemKey.Reserved, g_Config.sGameGoldName]))
          else SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 1, 0, Format('您需要 %s(%d%s) 才能开启此宝箱，是否现在购买钥匙？', [StdItemKey.Name, StdItemKey.Reserved, g_Config.sGameGoldName]));
        end else begin
          SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, Format('您需要 %s 才能开启此宝箱。', [StdItemKey.Name]));
        end;
      end;
    end;
  end;
end;
//购买宝箱钥匙,给玩家钥匙，并减元宝，自动打开宝箱 20090225
//nTpye 1-自动转动

procedure TPlayObject.BuyKeyAutoBox(nTpye: Integer; nShowEff: Byte);
var
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  boShowEff, boCanOpenBox: Boolean;
  I, KeyMakeIndex: Integer;
  ItemNum: Byte;
begin
  if (n_KeyAnicount <> 0) then begin
    StdItem := UserEngine.GetBoxKeyItem(n_KeyAnicount);
    if (StdItem <> nil) then begin
      boCanOpenBox := False;
      KeyMakeIndex := 0;
      ItemNum := StdItem.AniCount; //一次可以得到钥匙数
      if ItemNum <= 0 then ItemNum := 1;
      if m_ItemList.Count + ItemNum <= MAXBAGITEM then begin //检查包裹是否有空位
        if m_nGameGold >= StdItem.Reserved then begin //检查元宝数,给钥匙，自动打开箱子
          DecGameGold(StdItem.Reserved);
          GameGoldChanged(); //更新客户端元宝
          if g_boGameLogGameGold then
            AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, m_sMapName,
              m_nCurrX, m_nCurrY, m_sCharName, g_Config.sGameGoldName,
                m_nGameGold, '-(' + inttostr(StdItem.Reserved) + ')', '购买钥匙']));
          m_BuyShopPrice := StdItem.Reserved; //每次商铺花的元宝数量，$BUYSHOP变量使用 20090311
          CmdUserCmd('@BuyShop');//商铺购买触发
          for I := 0 to ItemNum - 1 do begin
            New(UserItem);
            if UserEngine.CopyToUserItemFromName(StdItem.Name, UserItem) then begin
              m_ItemList.Add(UserItem);
              if StdItem.NeedIdentify = 1 then
                AddGameDataLog('30' + #9 + m_sMapName + #9 +
                  IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                  m_sCharName + #9 + StdItem.Name + #9 +
                  IntToStr(UserItem.MakeIndex) + #9 +
                  '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                  '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                  '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                  '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                  '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                  IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                  IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                  IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                  IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + '0');
              SendAddItem(UserItem);
              boCanOpenBox := True;
              KeyMakeIndex := UserItem.MakeIndex; //记录KEY的制造ID
            end else begin
              Dispose(UserItem);
              Break;
            end;
          end; //for
          if boCanOpenBox then begin //自动开启箱子(删除箱子及钥匙)
            boShowEff := nShowEff <> 0;
            if (m_OpenBoxMakeID > 0) then ClientSendBoxItem(m_OpenBoxMakeID, IntToStr(KeyMakeIndex), boShowEff)
            else ClientRotationBoxs(True); //自动开启箱子，删除钥匙物品
          end;
        end else begin
          if nTpye = 1 then //如果客户端选择自动开启，没有元宝时以不同的参数提示客户端
            SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 2, 0, Format('你的%s数量不足:%d', [g_Config.sGameGoldName, StdItem.Reserved]))
          else SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, Format('你的%s数量不足:%d', [g_Config.sGameGoldName, StdItem.Reserved])); //20090719 增加钥匙元宝数
        end;
      end else begin
        if nTpye = 1 then //如果客户端选择自动开启，没有空位时以不同的参数提示客户端
          SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 2, 0, '包裹空位不足，不能购买钥匙')
        else SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '包裹空位不足，不能购买钥匙');
      end;
    end;
    m_OpenBoxMakeID := 0;
  end;
end;
//取开箱子得到的物品ID

function TPlayObject.GetItemID(BoxS: TList; ItemType: Integer): Integer;
  function GetBoxsItemMinID(vList1: TList): Integer; //取宝箱物品中几率最小的物品的制造ID 20090527 修改
  var
    I, K: Integer;
    BoxsInfo1: pTBoxsInfo;
    LoadList: TList;
  begin
    Result := 0;
    K := 65536;
    LoadList := TList.Create;
    try
      if vList1.Count > 0 then begin
        for I := 0 to vList1.Count - 1 do begin
          BoxsInfo1 := pTBoxsInfo(vList1.Items[I]);
          if BoxsInfo1 <> nil then begin
            if BoxsInfo1.nItemRace < K then begin
              LoadList.Clear;
              LoadList.Add(BoxsInfo1);
              K := BoxsInfo1.nItemRace;
              Result := BoxsInfo1.StdItem.MakeIndex;
            end else
              if BoxsInfo1.nItemRace = K then begin
                LoadList.Add(BoxsInfo1);
              end;
          end;
        end; //for
      end;
      if LoadList.Count > 1 then begin
        BoxsInfo1 := pTBoxsInfo(LoadList.Items[Random(LoadList.Count)]);
        if BoxsInfo1 <> nil then begin
          Result := BoxsInfo1.StdItem.MakeIndex;
        end;
      end;
    finally
      LoadList.Free;
    end;
  end;
var
  pBoxsInfo: pTBoxsInfo;
  I: Integer;
  sTemp: TList;
begin
  Result := 0;
  sTemp := TList.Create;
  try
    if Boxs.Count > 0 then begin
      for I := 0 to Boxs.Count - 1 do begin
        pBoxsInfo := pTBoxsInfo(Boxs.Items[I]);
        if pBoxsInfo <> nil then begin
          if (pBoxsInfo.StdItem.s.Reserved1 = ItemType) then begin
            sTemp.Add(pBoxsInfo);
            if Random(pBoxsInfo.nItemRace) = 0 then begin //20110712 修改
              Result := pBoxsInfo.StdItem.MakeIndex;
              if Result <> 0 then Break;
            end;
          end;
        end;
      end;
    end;
    if sTemp.Count > 0 then begin
      {for I:= 0 to sTemp.Count -1 do begin//20110712 注释
        pBoxsInfo := pTBoxsInfo(sTemp.Items[I]);
        if pBoxsInfo <> nil then begin
          if Random(pBoxsInfo.nItemRace) = 0 then begin
            Result:= pBoxsInfo.StdItem.MakeIndex;
            if Result <> 0 then Break;
          end;
        end;
      end; }
      if Result = 0 then begin //没有得到物品ID，则取最小几率的物品ID
        Result := GetBoxsItemMinID(sTemp);
      end;
    end;
  finally
    sTemp.Free;
  end;
end;
//宝箱开启,随机取出9件物品 20080115

function TPlayObject.ClientOpenBoxs(sBoxsID {宝箱类型,即Source}, nBoxTpye {0-不填充 1-填充 2-九周年宝箱 即Reserved}: Integer; boShowEff {显示特效}, boSendItem {是否发送中间格物品}: Boolean): Boolean;
var
  vList1, vList2, vList3, vList4: TList;
  I, T: Integer;
  BoxsInfo: TBoxsInfo;
  BoxsInfo1, BoxsInfo2: pTBoxsInfo;
  sSendStr: string;
  nCode: byte;
  boBoxsItemOK: Boolean;
  List28: TList;
begin
  Result := False;
  nCode := 0;
  sSendStr := '';
  boBoxsItemOK := False;
  try
    if (BoxsList = nil) or m_boOpenBox or m_CattleGasOpenBox then Exit; //如果有宝箱正在操作,则退出,一次只能开一个宝箱 20080407
    nCode := 1;
    m_boOpenBox := True; //宝箱正在打开中 20080407
    n_BoxsItmeID := 0; //初始化给人物物品的ID
    Randomize; //播下随机种子
    vList1 := TList.Create;
    vList2 := TList.Create;
    vList3 := TList.Create;
    vList4 := TList.Create;
    try
      nCode := 2;
      if BoxsList.Count > 0 then begin //20080629
        nCode := 21;
        T := BoxsList.IndexOf(IntToStr(SBoxsID)); //20100511 修改
        if T > -1 then begin
          List28 := TList(BoxsList.Objects[T]);
          if List28 <> nil then begin
            if List28.count > 0 then begin
              for T := 0 to List28.count - 1 do begin
                BoxsInfo1 := pTBoxsInfo(List28.Items[T]);
                if BoxsInfo1 <> nil then begin
                  if BoxsInfo1.SBoxsID <> SBoxsID then Continue; //如果不是Source对应的txt文件则跳过
                  nCode := 23;
                  case BoxsInfo1.nItemType of
                    0: vList1.Add(BoxsInfo1); //普通物品写入vList1
                    1: vList2.Add(BoxsInfo1); //填充物品写入vList2
                    2: vList3.Add(BoxsInfo1); //中间格物品写入vList3
                    3: vList4.Add(BoxsInfo1); //天赐极品物品
                  end;
                end;
              end;
            end;
          end;
        end;
        {for T := 0 to BoxsList.Count - 1 do begin
          BoxsInfo1 := pTBoxsInfo(BoxsList.Items[T]);
          nCode:= 22;
          if BoxsInfo1 <> nil then begin
            if BoxsInfo1.SBoxsID <> SBoxsID then Continue; //如果不是Source对应的txt文件则跳过
            nCode:= 23;
            case BoxsInfo1.nItemType of
              0: vList1.Add(BoxsInfo1); //普通物品写入vList1
              1: vList2.Add(BoxsInfo1); //填充物品写入vList2
              2: vList3.Add(BoxsInfo1); //中间格物品写入vList3
              3: vList4.Add(BoxsInfo1); //天赐极品物品
            end;
          end;
        end; }

      end;
      case nBoxTpye of //要求：奖励物品需要3件 普通物品需8件 中间格物品需1件
        0: if (vList1.Count > 7) and (vList3.Count > 0) then boBoxsItemOK := True; //不填充箱
        1: if (vList1.Count > 7) and (vList2.Count > 2) and (vList3.Count > 0) then boBoxsItemOK := True; //填充箱
        2: if (vList1.Count > 7) and (vList4.Count > 1) then boBoxsItemOK := True; //天赐 普通8件，极品2件
      end;
      if boBoxsItemOK then begin
        nCode := 3;
        if m_Boxs.Count > 0 then begin //20090705 增加
          for I := 0 to m_Boxs.Count - 1 do begin
            if pTBoxsInfo(m_Boxs.Items[I]) <> nil then Dispose(pTBoxsInfo(m_Boxs.Items[I]));
          end;
          m_Boxs.Clear;
        end;
        nCode := 4;
        n_OpenBoxTpye := nBoxTpye; //打开宝箱的类型 0-不可填充 1-可填充 2-九周年宝箱
        if (nBoxTpye = 2) then begin //九周年宝箱
          case Random(6) of
            0: begin
                T := Random(vList4.Count);
                BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList4.Delete(T); //抽取完后从临时列表中删除数据

                for I := 0 to 5 do begin //取出6件物品
                  nCode := 51;
                  T := Random(vList1.Count);
                  BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                  New(BoxsInfo2);
                  BoxsInfo2^ := BoxsInfo1^;
                  BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                  BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                  BoxsInfo := BoxsInfo2^;
                  nCode := 52;
                  m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                  sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                  vList1.Delete(T); //抽取完后从临时列表中删除数据
                end;

                nCode := 53;
                T := Random(vList4.Count);
                BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList4.Delete(T); //抽取完后从临时列表中删除数据
              end;
            1: begin
                nCode := 54;
                T := Random(vList4.Count);
                BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList4.Delete(T); //抽取完后从临时列表中删除数据

                nCode := 55;
                for I := 0 to 1 do begin //取出2件物品
                  T := Random(vList1.Count);
                  BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                  New(BoxsInfo2);
                  BoxsInfo2^ := BoxsInfo1^;
                  BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                  BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                  BoxsInfo := BoxsInfo2^;
                  m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                  sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                  vList1.Delete(T); //抽取完后从临时列表中删除数据
                end;

                T := Random(vList4.Count);
                BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList4.Delete(T); //抽取完后从临时列表中删除数据

                for I := 0 to 3 do begin //取出4件物品
                  T := Random(vList1.Count);
                  BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                  New(BoxsInfo2);
                  BoxsInfo2^ := BoxsInfo1^;
                  BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                  BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                  BoxsInfo := BoxsInfo2^;
                  m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                  sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                  vList1.Delete(T); //抽取完后从临时列表中删除数据
                end;
              end;
            2: begin
                nCode := 56;
                for I := 0 to 2 do begin //取出3件物品
                  T := Random(vList1.Count);
                  BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                  New(BoxsInfo2);
                  BoxsInfo2^ := BoxsInfo1^;
                  BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                  BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                  BoxsInfo := BoxsInfo2^;
                  m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                  sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                  vList1.Delete(T); //抽取完后从临时列表中删除数据
                end;
                nCode := 57;
                T := Random(vList4.Count);
                BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList4.Delete(T); //抽取完后从临时列表中删除数据

                nCode := 58;
                for I := 0 to 2 do begin //取出3件物品
                  T := Random(vList1.Count);
                  BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                  New(BoxsInfo2);
                  BoxsInfo2^ := BoxsInfo1^;
                  BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                  BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                  BoxsInfo := BoxsInfo2^;
                  m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                  sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                  vList1.Delete(T); //抽取完后从临时列表中删除数据
                end;

                T := Random(vList4.Count);
                BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList4.Delete(T); //抽取完后从临时列表中删除数据
              end;
            3: begin
                nCode := 59;
                for I := 0 to 1 do begin //取出2件物品
                  T := Random(vList1.Count);
                  BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                  New(BoxsInfo2);
                  BoxsInfo2^ := BoxsInfo1^;
                  BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                  BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                  BoxsInfo := BoxsInfo2^;
                  m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                  sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                  vList1.Delete(T); //抽取完后从临时列表中删除数据
                end;

                nCode := 60;
                T := Random(vList4.Count);
                BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList4.Delete(T); //抽取完后从临时列表中删除数据

                nCode := 61;
                for I := 0 to 1 do begin //取出2件物品
                  T := Random(vList1.Count);
                  BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                  New(BoxsInfo2);
                  BoxsInfo2^ := BoxsInfo1^;
                  BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                  BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                  BoxsInfo := BoxsInfo2^;
                  m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                  sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                  vList1.Delete(T); //抽取完后从临时列表中删除数据
                end;

                nCode := 62;
                T := Random(vList4.Count);
                BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList4.Delete(T); //抽取完后从临时列表中删除数据

                nCode := 63;
                for I := 0 to 1 do begin //取出2件物品
                  T := Random(vList1.Count);
                  BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                  New(BoxsInfo2);
                  BoxsInfo2^ := BoxsInfo1^;
                  BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                  BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                  BoxsInfo := BoxsInfo2^;
                  m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                  sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                  vList1.Delete(T); //抽取完后从临时列表中删除数据
                end;
              end;
            4: begin
                for I := 0 to 3 do begin //取出4件物品
                  T := Random(vList1.Count);
                  BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                  New(BoxsInfo2);
                  BoxsInfo2^ := BoxsInfo1^;
                  BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                  BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                  BoxsInfo := BoxsInfo2^;
                  m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                  sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                  vList1.Delete(T); //抽取完后从临时列表中删除数据
                end;

                T := Random(vList4.Count);
                BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList4.Delete(T); //抽取完后从临时列表中删除数据

                for I := 0 to 2 do begin //取出3件物品
                  T := Random(vList1.Count);
                  BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                  New(BoxsInfo2);
                  BoxsInfo2^ := BoxsInfo1^;
                  BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                  BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                  BoxsInfo := BoxsInfo2^;
                  m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                  sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                  vList1.Delete(T); //抽取完后从临时列表中删除数据
                end;
              end;
            5: begin
                for I := 0 to 1 do begin //取出2件物品
                  T := Random(vList1.Count);
                  BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                  New(BoxsInfo2);
                  BoxsInfo2^ := BoxsInfo1^;
                  BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                  BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                  BoxsInfo := BoxsInfo2^;
                  m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                  sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                  vList1.Delete(T); //抽取完后从临时列表中删除数据
                end;

                T := Random(vList4.Count);
                BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList4.Delete(T); //抽取完后从临时列表中删除数据

                for I := 0 to 4 do begin //取出3件物品
                  T := Random(vList1.Count);
                  BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                  New(BoxsInfo2);
                  BoxsInfo2^ := BoxsInfo1^;
                  BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                  BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                  BoxsInfo := BoxsInfo2^;
                  m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                  sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                  vList1.Delete(T); //抽取完后从临时列表中删除数据
                end;
              end; //5
          end;
        end else begin
          nCode := 5;
          if nBoxTpye = 1 then begin //根据箱子类型，是否选取填充物品
            for I := 0 to 2 do begin //取出3件填充物品
              T := Random(vList2.Count);
              BoxsInfo1 := pTBoxsInfo(vList2.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 3; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //20090527 重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList2.Delete(T); //抽取完后从临时列表中删除数据
            end;
          end;
          nCode := 8;
          for I := 0 to 7 do begin //取出8件物品
            T := Random(vList1.Count);
            BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
            New(BoxsInfo2);
            BoxsInfo2^ := BoxsInfo1^;
            BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
            BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //20090527 重新计算持久值
            BoxsInfo := BoxsInfo2^;
            m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
            sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
            vList1.Delete(T); //抽取完后从临时列表中删除数据
          end;
        end;
        nCode := 6;
        if boSendItem then begin //取中间格物品
          I := Random(vList3.Count);
          BoxsInfo1 := pTBoxsInfo(vList3.Items[I]);
          New(BoxsInfo2);
          BoxsInfo2^ := BoxsInfo1^;
          BoxsInfo2.StdItem.s.Reserved1 := 2; //标识 1-普通物品 2-中间物品 3-填充物品
          BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //20090527 重新计算持久值
          BoxsInfo := BoxsInfo2^;
          n_BoxsItmeID := BoxsInfo.StdItem.MakeIndex; //得到中间物品的ID
          m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
          sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
          vList3.Delete(I); //抽取完后从临时列表中删除数据
        end else n_BoxsItmeID := 0;
      end;
    finally
      vList1.Free;
      vList2.Free;
      vList3.Free;
      vList4.Free;
    end;
    nCode := 7;
    if sSendStr <> '' then begin
      if m_boOpenNew9YearBox then begin //开启新天赐(20格开完后，“开启新天赐”按键)   wTag-1为开启新天赐
        if boShowEff then SendMsg(Self, RM_OPENBOXS, 0, 1, n_OpenBoxTpye, 1, sSendStr) //显示特效
        else SendMsg(Self, RM_OPENBOXS, 0, 0, n_OpenBoxTpye, 1, sSendStr);
      end else begin
        if boShowEff then SendMsg(Self, RM_OPENBOXS, 0, 1, n_OpenBoxTpye, 0, sSendStr) //显示特效
        else SendMsg(Self, RM_OPENBOXS, 0, 0, n_OpenBoxTpye, 0, sSendStr);
      end;
      m_boCanRotation := True; //是否可以转动宝箱
      m_boNoCanRotation := False;
      Result := True;
      n_9YearUpdateCount := 0; //更换物品次数
    end else m_boOpenBox := False;
    m_boOpenNew9YearBox := False;
  except
    on E: Exception do begin
      MainOutMessage(format('{%s} TPlayObject.ClientOpenBoxs Code:%d', [g_sExceptionVer, nCode]));
    end;
  end;
end;
//转动宝箱,随机选择转动最后停止的物品  nType-True 检查包裹是否有钥匙，没有则提示购买

procedure TPlayObject.ClientRotationBoxs(nType: Boolean);
var
  I, KeyMakeIndex: Integer;
  UserItem: pTUserItem;
  StdItemKey: pTStdItem;
begin
  try
    if (m_Boxs = nil) or (m_Boxs.Count = 0) or (not m_boCanRotation) or ((n_OpenBoxTpye = 0) and (n_OpenBoxCount > 0)) or (n_OpenBoxCount > 4) then Exit;
    if nType and (n_OpenBoxTpye = 1) and (n_OpenBoxCount > 0) then begin //检查包裹里是否有钥匙，没有则提示购买
      KeyMakeIndex := 0;
      if m_boNoCanRotation then begin
        if GetPlayBoxItem(n_KeyAnicount) = 0 then begin
          m_boCanRotation := False; //20100212 增加
          n_OpenBoxCount := 5; //20100405 增加
          SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '没有同类宝箱');
          Exit;
        end else begin //有箱子
          ClientUpdateBoxsItme(); //检查是否有同类宝箱，则重新刷物品
          Exit;
        end;
      end;
      if m_ItemList.Count + 5 > MAXBAGITEM then begin //检查包裹是否有5个空位 20090311
        SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '包裹空位不足，不能开启');
        Exit;
      end;
      for I := m_ItemList.Count - 1 downto 0 do begin //检查包裹里是否有对应的钥匙
        if m_ItemList.Count <= 0 then Break;
        UserItem := m_ItemList.Items[I];
        if UserItem = nil then Continue;
        StdItemKey := UserEngine.GetStdItem(UserItem.wIndex);
        if (StdItemKey <> nil) then begin
          if (StdItemKey.StdMode = 49) and (StdItemKey.Shape = n_KeyAnicount) then begin //找到对应的钥匙，删除钥匙
            KeyMakeIndex := UserItem.MakeIndex;
            m_ItemList.Delete(I);
            SendDelItems(UserItem);
            Dispose(UserItem); //20100928 增加
            m_boOpenBox := True;
            Break;
          end;
        end;
      end; //for
      if KeyMakeIndex = 0 then begin //提示玩家购买对应的钥匙
        StdItemKey := UserEngine.GetBoxKeyItem(n_KeyAnicount);
        if (StdItemKey <> nil) then begin //提示玩家购买钥匙
          SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 1, 0, Format('您需要 %s(%d%s) 才能开启此宝箱，是否现在购买钥匙？', [StdItemKey.Name, StdItemKey.Reserved, g_Config.sGameGoldName]));
        end;
        Exit;
      end;
    end;
    m_boCanRotation := False;
    if m_boOpenBox then begin
      n_BoxsItmeID := 0;
      Inc(n_OpenBoxCount); //开宝箱记数
      n_BoxsItmeID := GetItemID(m_Boxs, 1);
      if n_BoxsItmeID <> 0 then SendMsg(Self, RM_MOVEBOXS, 0, n_BoxsItmeID, 0, 0, ''); //发消息给客户端
    end;
  except
    on E: Exception do begin
      MainOutMessage(format('{%s} TPlayObject.ClientRotationBoxs', [g_sExceptionVer]));
    end;
  end;
end;
//宝箱给玩家物品 20080117

procedure TPlayObject.ClientGetBoxsItme(nTpye: Byte);
var
  I, ItemNum, K: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  BoxsInfo, BoxsInfo1: pTBoxsInfo;
  ItemName: string;
  sCheckItemName, szString: string;
  boHithOK: Boolean;
begin
  if (not m_boOpenBox) or (n_BoxsItmeID = 0) or m_boGivePlayItme then Exit; //20080924
  m_boGivePlayItme := True; //给玩家物品
  boHithOK := False;
  try
    try
      m_boOpenBox := False; //20080407
      ItemNum := 0;
      ItemName := '';
      if n_BoxsItmeID <> 0 then begin
        if m_Boxs.Count > 0 then begin
          for I := 0 to m_Boxs.Count - 1 do begin
            BoxsInfo := pTBoxsInfo(m_Boxs.Items[I]);
            if BoxsInfo.StdItem.MakeIndex = n_BoxsItmeID then begin
              ItemName := BoxsInfo.StdItem.s.Name; //物品名称
              ItemNum := BoxsInfo.nItemNum; //物品数量
            end;
            if ItemName <> '' then break;
          end;
        end;
        if (ItemName <> '') then begin //20090524 增加
          StdItem := UserEngine.GetStdItem(ItemName);
          if (StdItem <> nil) then begin //20090312
            if ItemNum <= 0 then ItemNum := 1; //20080629
            for I := 0 to ItemNum - 1 do begin //支持物品的多数量获取 20080221
              New(UserItem);
              if UserEngine.CopyToUserItemFromName(StdItem.Name, UserItem) then begin
                case StdItem.StdMode of
                  2, 7, 8, 17, 18, 51: ; //酿酒材料,叠加物品和符,聚集物品,千里传音，传音筒不重新算值 20090814
                else UserItem.Dura := BoxsInfo.StdItem.Dura; //20080328
                end;
                if IsEnoughBag and IsAddWeightAvailable(StdItem.Weight) then begin //包裹有位置则放到包裹里,没有则扔出物品 20080616
                  if StdItem.StdMode = 17 then begin //叠加物品自动合并 20091126
                    if m_btRaceServer = RC_PLAYOBJECT then begin
                      sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                      boHithOK := True;
                    end;
                    if not AutoItemMerger(UserItem) then begin //自动合并物品
                      m_ItemList.Add(UserItem);
                      SendAddItem(UserItem);
                      if StdItem.NeedIdentify = 1 then
                        AddGameDataLog('40' + #9 + m_sMapName + #9 +
                          IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                          m_sCharName + #9 + StdItem.Name + #9 +
                          IntToStr(UserItem.MakeIndex) + #9 +
                          '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + '0');
                    end;
                  end else begin
                    m_ItemList.Add(UserItem);
                    if StdItem.NeedIdentify = 1 then
                      AddGameDataLog('40' + #9 + m_sMapName + #9 +
                        IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 + StdItem.Name + #9 +
                        IntToStr(UserItem.MakeIndex) + #9 +
                        '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                        '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                        '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                        '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                        '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                        IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                        IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                        IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                        IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + '0');

                    if m_btRaceServer = RC_PLAYOBJECT then begin
                      SendAddItem(UserItem);
                      sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                      boHithOK := True;
                    end;
                  end;
                end else begin //包裹满扔出物品
                  DropItemDown(UserItem, 3, False, False, self, self); //20080616
                  Dispose(UserItem);//修复内存泄露By TasNat at: 2012-06-01 12:10:51
                end;
              end else begin
                Dispose(UserItem);
                Break;
              end;
            end;
            if boHithOK then begin
              if not m_CattleGasOpenBox then begin
                if not PlugOfCheckCanItem(5, sCheckItemName, False, ItemNum, 0) then begin //禁止物品规则(没有设置全F提示的物品) 20080729
                  szString := AnsiReplaceText(g_sBoxsItemHintMsg1, '%name', m_sCharName);
                  szString := AnsiReplaceText(szString, '%s', sCheckItemName);
                  szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                  SysMsg(szString, c_Blue, t_Say);
                end;
              end else begin //开牛气箱子的提示 20090524
                m_CattleGasOpenBox := False;
                if not PlugOfCheckCanItem(5, sCheckItemName, False, ItemNum, 1) then begin //禁止物品规则(没有设置全F提示的物品) 20091117
                  szString := AnsiReplaceText(g_sBoxsItemHintMsg2, '%name', m_sCharName);
                  szString := AnsiReplaceText(szString, '%s', ItemName);
                  szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                  SysMsg(szString, c_Blue, t_Say);
                end;
              end;
            end;
          end else begin //不是数据库里的物品
            if (CompareText(Trim(ItemName), '经验') = 0) or (CompareText(Trim(ItemName), '经验(大量)') = 0) or (CompareText(Trim(ItemName), '经验(海量)') = 0) then begin
              GetExpToItem(ItemNum); //取得的经验,累积到聚灵珠 20080817
              if not m_CattleGasOpenBox then begin
                if not PlugOfCheckCanItem(5, Trim(ItemName), False, ItemNum, 0) then begin //禁止物品规则(没有设置全F提示的物品) 20080729
                  szString := AnsiReplaceText(g_sBoxsItemHintMsg1, '%name', m_sCharName); //20080617
                  szString := AnsiReplaceText(szString, '%s', '经验'); //20080617
                  szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                  SysMsg(szString, c_Blue, t_Say);
                end;
              end else begin //开牛气箱子的提示 20090524
                m_CattleGasOpenBox := False;
                if not PlugOfCheckCanItem(5, sCheckItemName, False, ItemNum, 1) then begin //禁止物品规则(没有设置全F提示的物品) 20091117
                  szString := AnsiReplaceText(g_sBoxsItemHintMsg2, '%name', m_sCharName);
                  szString := AnsiReplaceText(szString, '%s', '经验');
                  szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                  SysMsg(szString, c_Red, t_Say);
                end;
              end;

              if m_MyHero <> nil then begin
                if m_MyHero.m_Abil.Level < g_Config.nLimitExpLevelHero then begin //20110116 增加
                  THeroObject(m_MyHero).GetExp(abs(Round((g_Config.nHeroNoKillMonExpRate / 100) * ItemNum)), 0); //20081018 修改
                  ItemNum := abs(Round(((100 - g_Config.nHeroNoKillMonExpRate) / 100) * ItemNum)); //20081018 修改
                end;
              end;
              if m_Abil.nExp >= LongWord(ItemNum) then begin //20090102
                if (High(uInt64) - m_Abil.nExp) < LongWord(ItemNum) then begin
                  ItemNum := High(uInt64) - m_Abil.nExp;
                end;
              end else begin
                if (High(uInt64) - LongWord(ItemNum)) < m_Abil.nExp then begin
                  ItemNum := High(uInt64) - LongWord(ItemNum);
                end;
              end;
              m_GetExp := ItemNum; //人物取得的经验,$GetExp变量使用 20090102
              if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(self, '@GetExp', False, False); //取经验触发 20090102
              Inc(m_Abil.nExp, ItemNum);
              SendMsg(self, RM_WINEXP, 0, 0, 0, 0, EncodeExp(m_Abil.nExp, ItemNum));
              if (m_Abil.Level < MAXUPLEVEL) and
                (m_Abil.Level < g_Config.nLimitExpLevel) then begin //20110925 达到等级上限时不处理
                if g_Config.boContinuousUpLevel then begin //20100605
                  K := 0;
                  while (m_Abil.nExp >= m_Abil.nMaxExp) do begin //20100408 循环处理升级
                    if K >= 8 then Break;
                    Inc(K);
                    if m_Abil.nExp <= 0 then begin
                      m_Abil.nExp := 0;
                      Break;
                    end;
                  //if m_Abil.Exp >= m_Abil.MaxExp then begin//20100223 开箱子检查升级
                    Dec(m_Abil.nExp, m_Abil.nMaxExp);
                    if (m_Abil.Level < MAXUPLEVEL) and (m_Abil.Level < g_Config.nLimitExpLevel) then begin
                      Inc(m_Abil.Level);
                      if (m_sMasterName <> '') and not m_boMaster then begin //自动出师 20100408
                        if m_Abil.Level >= g_Config.nMasterOKLevel then CheckMaster(True);
                      end;
                    end;
                    if m_Abil.Level < g_Config.nLimitExpLevel then begin
                      HasLevelUp(m_Abil.Level - 1); //增加限制等级
                      if not m_boAI then begin
                        AddGameDataLog('12' + #9 + m_sMapName + #9 + //人物升级记录日志
                          IntToStr(m_nCurrX) + #9 +
                          IntToStr(m_nCurrY) + #9 +
                          m_sCharName + #9 + IntToStr(m_Abil.nExp) + '/' + IntToStr(m_Abil.nMaxExp) + #9 + IntToStr(m_Abil.Level) + #9 + '1' + #9 + '(箱子经验)');
                      end;
                    end;
                  end;
                end else begin
                  if m_Abil.nExp >= m_Abil.nMaxExp then begin //20100223 开箱子检查升级
                    Dec(m_Abil.nExp, m_Abil.nMaxExp);
                    if (m_Abil.Level < MAXUPLEVEL) and (m_Abil.Level < g_Config.nLimitExpLevel) then begin
                      Inc(m_Abil.Level);
                      if (m_sMasterName <> '') and not m_boMaster then begin //自动出师 20100408
                        if m_Abil.Level >= g_Config.nMasterOKLevel then CheckMaster(True);
                      end;
                    end;
                    if m_Abil.Level < g_Config.nLimitExpLevel then begin
                      HasLevelUp(m_Abil.Level - 1); //增加限制等级
                      if not m_boAI then begin
                        AddGameDataLog('12' + #9 + m_sMapName + #9 + //人物升级记录日志
                          IntToStr(m_nCurrX) + #9 +
                          IntToStr(m_nCurrY) + #9 +
                          m_sCharName + #9 + IntToStr(m_Abil.nExp) + '/' + IntToStr(m_Abil.nMaxExp) + #9 + IntToStr(m_Abil.Level) + #9 + '1' + #9 + '(箱子经验)');
                      end;
                    end;
                  end;
                end;
              end;
            end else
              if (CompareText(Trim(ItemName), '声望') = 0) then begin
                Inc(m_btCreditPoint, ItemNum);
                GameGoldChanged();
                if not m_CattleGasOpenBox then begin
                  if not PlugOfCheckCanItem(5, Trim(ItemName), False, ItemNum, 0) then begin //禁止物品规则(没有设置全F提示的物品)
                    szString := AnsiReplaceText(g_sBoxsItemHintMsg1, '%name', m_sCharName); //20080617
                    szString := AnsiReplaceText(szString, '%s', '声望'); //20080617
                    szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                    SysMsg(szString, c_Blue, t_Say);
                  end;
                end else begin //开牛气箱子的提示 20090524
                  m_CattleGasOpenBox := False;
                  if not PlugOfCheckCanItem(5, sCheckItemName, False, ItemNum, 1) then begin //禁止物品规则(没有设置全F提示的物品) 20091117
                    szString := AnsiReplaceText(g_sBoxsItemHintMsg2, '%name', m_sCharName);
                    szString := AnsiReplaceText(szString, '%s', '声望');
                    szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                    SysMsg(szString, c_Blue, t_Say);
                  end;
                end;
              end else
                if (CompareText(Trim(ItemName), g_Config.sGameGird) = 0) or
                  (CompareText(Trim(ItemName), Format('%s(大量)', [g_Config.sGameGird {'灵符'}])) = 0) or
                  (CompareText(Trim(ItemName), Format('%s(海量)', [g_Config.sGameGird {'灵符'}])) = 0) then begin
                  Inc(m_nGAMEGIRD, ItemNum);
                  GameGoldChanged; //更新灵符数量
                  if not m_CattleGasOpenBox then begin
                    if not PlugOfCheckCanItem(5, Trim(ItemName), False, ItemNum, 0) then begin //禁止物品规则(没有设置全F提示的物品)
                      szString := AnsiReplaceText(g_sBoxsItemHintMsg1, '%name', m_sCharName);
                      szString := AnsiReplaceText(szString, '%s', g_Config.sGameGird);
                      szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                      SysMsg(szString, c_Blue, t_Say);
                    end;
                  end else begin //开牛气箱子的提示 20090524
                    m_CattleGasOpenBox := False;
                    if not PlugOfCheckCanItem(5, sCheckItemName, False, ItemNum, 1) then begin //禁止物品规则(没有设置全F提示的物品) 20091117
                      SysMsg('恭喜：你获得了：' + g_Config.sGameGird + ':' + IntToStr(ItemNum), c_Blue, t_Say);
                    end;
                  end;
                end else
                  if (CompareText(Trim(ItemName), g_Config.sGameDiaMond) = 0) then begin
                    Inc(m_nGAMEDIAMOND, ItemNum);
                    GameGoldChanged; //更新金刚石数量
                    if not m_CattleGasOpenBox then begin
                      if not PlugOfCheckCanItem(5, Trim(ItemName), False, ItemNum, 0) then begin //禁止物品规则(没有设置全F提示的物品)
                        szString := AnsiReplaceText(g_sBoxsItemHintMsg1, '%name', m_sCharName); //20080617
                        szString := AnsiReplaceText(szString, '%s', g_Config.sGameDiaMond); //20080617
                        szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                        SysMsg(szString, c_Blue, t_Say);
                      end;
                    end else begin //开牛气箱子的提示 20090524
                      m_CattleGasOpenBox := False;
                      if not PlugOfCheckCanItem(5, sCheckItemName, False, ItemNum, 1) then begin //禁止物品规则(没有设置全F提示的物品) 20091117
                        szString := AnsiReplaceText(g_sBoxsItemHintMsg2, '%name', m_sCharName);
                        szString := AnsiReplaceText(szString, '%s', g_Config.sGameDiaMond);
                        szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                        SysMsg(szString, c_Blue, t_Say);
                      end;
                    end;
{$IF M2Version <> 2}
                  end else
                    if (CompareText(Trim(ItemName), '内功') = 0) or (CompareText(Trim(ItemName), '内功(大量)') = 0) or (CompareText(Trim(ItemName), '内功(海量)') = 0) then begin //内功经验 20100413
                      if m_boTrainingNG then begin
                        GetNGExp(ItemNum, 1); //取得内功经验
                        if not m_CattleGasOpenBox then begin
                          if not PlugOfCheckCanItem(5, Trim(ItemName), False, ItemNum, 0) then begin //禁止物品规则(没有设置全F提示的物品)
                            szString := AnsiReplaceText(g_sBoxsItemHintMsg1, '%name', m_sCharName);
                            szString := AnsiReplaceText(szString, '%s', '内功经验');
                            szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                            SysMsg(szString, c_Blue, t_Say);
                          end;
                        end else begin //开牛气箱子的提示
                          m_CattleGasOpenBox := False;
                          if not PlugOfCheckCanItem(5, sCheckItemName, False, ItemNum, 1) then begin //禁止物品规则(没有设置全F提示的物品)
                            szString := AnsiReplaceText(g_sBoxsItemHintMsg2, '%name', m_sCharName);
                            szString := AnsiReplaceText(szString, '%s', '内功经验');
                            szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                            SysMsg(szString, c_Red, t_Say);
                          end;
                        end;
                      end;
{$IFEND}
                    end;
          end;
        end;
        if n_OpenBoxTpye = 1 then begin //填充模式,进行物品填充
          if m_Boxs.Count > 0 then begin
            for I := 0 to m_Boxs.Count - 1 do begin
              BoxsInfo := pTBoxsInfo(m_Boxs.Items[I]);
              if (BoxsInfo.StdItem.MakeIndex = n_BoxsItmeID) then begin //找到玩家得到的物品
                if (BoxsInfo.nItemType = 2) then Break; //如果是中间物品则不填充
                BoxsInfo.StdItem.s.Reserved1 := 4; //标识
                if n_BoxItmeFilledCount >= 3 then begin //所有填充物品填充完后，检查是否有同类宝箱，则重新刷物品
                  SendMsg(Self, RM_BOXITMEFILLED, 0, BoxsInfo.StdItem.MakeIndex {玩家得到的物品}, 0 {填充的物品}, 0, '');
                  n_BoxItmeFilledCount := 0;
                  Break;
                end else begin
                  BoxsInfo1 := pTBoxsInfo(m_Boxs.Items[n_BoxItmeFilledCount]);
                  if BoxsInfo1.nItemType = 1 then begin //填充物品
                    BoxsInfo1.StdItem.s.Reserved1 := 1; //标识
                    SendMsg(Self, RM_BOXITMEFILLED, 0, BoxsInfo.StdItem.MakeIndex {玩家得到的物品}, BoxsInfo1.StdItem.MakeIndex {填充的物品}, 0, '');
                    m_boCanRotation := True; //填充完后可以转动箱子
                  end;
                end;
                Inc(n_BoxItmeFilledCount); //累计填充次数
                Break;
              end;
            end;
          end;
        end else begin //if n_OpenBoxTpye = 1 then
          if nTpye <> 5 then ClientCloseBoxs(); //清空个人箱子列表资源,关闭箱子 20090719
          if n_OpenBoxTpye = 0 then n_OpenBoxCount := 0; //转动宝箱的次数
        end;
        n_BoxsItmeID := 0;
        if nTpye = 5 then ClientCloseBoxs(); //清空个人箱子列表资源,关闭箱子 20090719
      end; //if n_BoxsItmeID <> 0 then begin
    except
      on E: Exception do begin
        MainOutMessage(format('{%s} TPlayObject.ClientGetBoxsItme', [g_sExceptionVer]));
      end;
    end;
  finally
    m_boGivePlayItme := False; //给玩家物品
  end;
end;
//检查包裹里是否有同类宝箱

function TPlayObject.GetPlayBoxItem(Anicount: Byte): Integer;
var
  I: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
begin
  Result := 0;
  if Anicount < 0 then Exit;
  if m_ItemList.Count > 0 then begin
    for I := 0 to m_ItemList.Count - 1 do begin
      UserItem := m_ItemList.Items[I];
      if UserItem = nil then Continue;
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
        if (StdItem.AniCount = Anicount) and (StdItem.StdMode = 48) then begin
          Result := UserItem.MakeIndex;
          Break;
        end;
      end;
    end;
  end;
end;
//所有填充物品填充完后，检查是否有同类宝箱，则重新刷物品

procedure TPlayObject.ClientUpdateBoxsItme();
var
  MakeIndexID: Integer;
begin
  if (n_KeyAnicount > 0) and (n_OpenBoxTpye = 1) then begin
    MakeIndexID := GetPlayBoxItem(n_KeyAnicount); //检查包裹里是否有同类宝箱
    if MakeIndexID > 0 then begin
      CheckItemsKey(MakeIndexID, n_KeyAnicount, 0, True);
      m_boNoCanRotation := False; //用于标识提示用户无同类宝箱
    end else begin
      m_boNoCanRotation := True; //用于标识提示用户无同类宝箱
      m_boCanRotation := True;
      SendMsg(Self, RM_OPENBOXS, 0, 2, 0, 0, ''); //返回给客户端显示关闭按键
    end;
  end;
end;
//清空个人箱子列表资源,关闭箱子 20090705

procedure TPlayObject.ClientCloseBoxs();
var I: Integer;
begin
  try
    if (not m_boOpenBox) and (m_Boxs.Count > 0) then begin
      for I := 0 to m_Boxs.Count - 1 do begin
        if pTBoxsInfo(m_Boxs.Items[I]) <> nil then Dispose(pTBoxsInfo(m_Boxs.Items[I]));
      end;
      m_Boxs.Clear;
    end;
  except
  end;
end;
//----------------------------------九周年宝箱----------------------------------
//双击九周年宝箱

procedure TPlayObject.Check9YearsBoxsKey(MakeIndex: Integer; Anicount: Byte; BoxClose: Byte);
var
  I, KeyMakeIndex, ItemNum, K, nBoxTpye, nBoxsID: Integer;
  UserItem: pTUserItem;
  StdItemKey: pTStdItem;
  boIsBoxItem, boKeyOK: Boolean;
begin
  if BoxClose = 1 then begin //箱子关闭，初始变量，后退出过程
    m_boOpenBox := False; //是否宝箱在打开
    n_OpenBoxTpye := 0; //打开宝箱的类型 0-不可填充 1-可填充 2-九周年度
    m_OpenBoxMakeID := 0; //打开箱子时，没钥匙时，记录ID
    m_boCanRotation := False; //是否可以转动宝箱
    n_KeyAnicount := 0; //钥匙标实
    n_OpenBoxCount := 0; //转动宝箱的次数
    m_boGivePlayItme := False; //给玩家物品
    m_boNoCanRotation := False; //用于标识提示用户无同类宝箱
    n_9YearBoxsID := 0;
    n_9YearUpdateCount := 0; //更换物品次数
    m_boFree9YearsBox := False; //是否取得免费奖励20格箱子
    ClientCloseBoxs(); //清空个人箱子列表资源,关闭箱子 20090719
    Exit;
  end;
  if m_boOpenBox or m_CattleGasOpenBox then Exit; //如果有宝箱牛气宝箱正在操作,则退出
  KeyMakeIndex := 0;
  boIsBoxItem := False;
  if m_ItemList.Count > 0 then begin //检查物品是否是宝箱类型
    for I := m_ItemList.Count - 1 downto 0 do begin
      if m_ItemList.Count <= 0 then Break;
      UserItem := m_ItemList.Items[I];
      if UserItem = nil then Continue;
      if (UserItem.MakeIndex = MakeIndex) then begin //找到宝箱
        StdItemKey := UserEngine.GetStdItem(UserItem.wIndex);
        if (StdItemKey <> nil) then begin
          if (StdItemKey.StdMode = 48) and (StdItemKey.AniCount = Anicount) then begin
            nBoxTpye := StdItemKey.Reserved;
            nBoxsID := StdItemKey.Source;
            boIsBoxItem := True;
            Break;
          end;
        end;
      end;
    end; //for
  end;
  if boIsBoxItem then begin
    ItemNum := 0;
    K := 0;
    boKeyOK := False;
    if n_OpenBoxCount = 0 then begin //检查开启次数，计算出所需元宝数
      ItemNum := g_Config.nFirstOpen9Years; //一次可以得到钥匙数
    end else Exit;
    for I := m_ItemList.Count - 1 downto 0 do begin //检查是否有钥匙
      if m_ItemList.Count <= 0 then Break;
      UserItem := m_ItemList.Items[I];
      if UserItem = nil then Continue;
      StdItemKey := UserEngine.GetStdItem(UserItem.wIndex);
      if (StdItemKey <> nil) then begin
        if (StdItemKey.StdMode = 49) and (StdItemKey.Shape = Anicount) then begin //找到对应的钥匙
          Inc(K);
          if K >= ItemNum then begin
            boKeyOK := True;
            Break;
          end;
        end;
      end;
    end; //for
    if boKeyOK then begin //包裹有足够数的钥匙，直接打开箱子
      n_KeyAnicount := Anicount; //钥匙标实
      n_9YearBoxsID := nBoxsID; //更新物品时使用
      ClientSend9YearsBoxItem(MakeIndex, nBoxsID, nBoxTpye, n_KeyAnicount, g_Config.nFirstOpen9Years); //删除钥匙及箱子，并发送箱子物品
    end else begin //提示玩家购买对应的钥匙
      StdItemKey := UserEngine.GetBoxKeyItem(Anicount);
      if (StdItemKey <> nil) then begin //提示玩家购买， 取钥匙名字，及元宝数
        if m_nGameGold > 0 then begin //检查玩家元宝是否为0
          m_OpenBoxMakeID := MakeIndex; //打开箱子时，没钥匙时，记录ID
          n_KeyAnicount := Anicount; //钥匙标实
          n_9YearBoxsID := nBoxsID; //更新物品时使用
          SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 4, 0, Format('您需要 %s 才能开启此天赐，是否花费%d%s从商城购买%s把\%s？(%s商城定价:%d%s一把)', [StdItemKey.Name, Round(StdItemKey.nHP * g_Config.nFirstOpen9Years), g_Config.sGameGoldName, MoneyToCharacter(g_Config.nFirstOpen9Years, True), StdItemKey.Name, StdItemKey.Name, StdItemKey.nHP, g_Config.sGameGoldName]));
        end else begin
          SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, Format('您需要 %s 才能开启此天赐。', [StdItemKey.Name]));
        end;
      end;
    end;
  end;
end;

//判断九周年宝箱和钥匙是否对应,对应是打开箱子，并删除箱子及对应数量的钥匙物品(双击时使用)

procedure TPlayObject.ClientSend9YearsBoxItem(BoxsIdx {箱子制造ID}, sBoxsID {宝箱类型,即Source}, nBoxTpye {0-不填充 1-填充 2-九周年宝箱 即Reserved}, KeyAnicount {钥匙标识}, nKeyCount {钥匙数量}: Integer);
var
  I, K: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  boIsBoxItem, boKeyOK: Boolean;
  nCode: byte;
begin
  nCode := 0;
  try
    if m_boOpenBox or m_CattleGasOpenBox then Exit; //如果有宝箱正在操作,则退出
    if not m_boDeath then begin
      nCode := 1;
      if IsEnoughBag then begin //包裹不满时
        nCode := 11;
        if m_ItemList.Count + 4 > MAXBAGITEM then begin //检查包裹是否有4个空位
          SendMsg(Self, RM_OPENBOXS_FAIL, 0, 0, 0, 0, ''); //失败
          SysMsg('至少需要预留六个空位', c_Red, t_Hint);
          Exit;
        end;
        nCode := 2;
        n_OpenBoxCount := 0; //转动宝箱的次数
        n_BoxItmeFilledCount := 0; //物品填充次数
        boIsBoxItem := False; //是否删除宝箱成功
        boKeyOK := False; //是否删除够数量的钥匙
        K := 0;
        nCode := 3;
        for I := m_ItemList.Count - 1 downto 0 do begin //删除物品
          if m_ItemList.Count <= 0 then Break;
          UserItem := m_ItemList.Items[I];
          if UserItem = nil then Continue;
          nCode := 4;
          if (UserItem <> nil) then begin
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if (StdItem <> nil) then begin
              if (UserItem.MakeIndex = BoxsIdx) then begin //箱子
                if StdItem.NeedIdentify = 1 then
                  AddGameDataLog('11' + #9 + m_sMapName + #9 +
                    IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                    m_sCharName + #9 + StdItem.Name + #9 +
                    IntToStr(UserItem.MakeIndex) + #9 + '(开宝箱)' + #9 + '0');
                m_ItemList.Delete(I);
                boIsBoxItem := True;
                SendDelItems(UserItem);
                Dispose(UserItem); //20100928 增加
              end else
                if (StdItem.StdMode = 49) and (StdItem.Shape = KeyAnicount) and (nKeyCount > K) then begin //对应的钥匙
                  if StdItem.NeedIdentify = 1 then
                    AddGameDataLog('11' + #9 + m_sMapName + #9 +
                      IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                      m_sCharName + #9 + StdItem.Name + #9 +
                      IntToStr(UserItem.MakeIndex) + #9 + '(开宝箱)' + #9 + '0');
                  m_ItemList.Delete(I);
                  SendDelItems(UserItem);
                  Dispose(UserItem); //20100928 增加
                  Inc(K);
                  if K >= nKeyCount then boKeyOK := True;
                end;
              if boIsBoxItem and boKeyOK then Break;
            end;
          end; //if (UserItem <> nil) then begin
        end;
        nCode := 5;
        if boIsBoxItem and boKeyOK then begin //删除物品成功才发送物品数量
          nCode := 6;
          if not ClientOpenBoxs(sBoxsID, nBoxTpye, False, False) then begin //宝箱开启,发送物品数据给客户端
            SendMsg(Self, RM_OPENBOXS_FAIL, 0, 0, 0, 0, ''); //失败
            SysMsg('开启天赐失败!', c_Red, t_Hint);
          end;
        end;
      end else begin //if IsEnoughBag then begin //包裹不满时
        SendMsg(Self, RM_OPENBOXS_FAIL, 0, 0, 0, 0, ''); //失败
        SysMsg('您的包裹已满,不能开启天赐!', c_Red, t_Hint);
      end;
    end; //if not m_boDeath
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientSend9YearsBoxItem Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

//购买钥匙对话框，按下“确定”，购买九周年宝箱钥匙,给玩家钥匙，并减元宝，自动打开宝箱

procedure TPlayObject.ClientBuy9YearsKeyAutoBox();
var
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  boCanOpenBox: Boolean;
  I, nRequiredGameGold: Integer;
  ItemNum, nCode: Byte;
begin
  nCode := 0;
  try
    if (n_KeyAnicount <> 0) then begin
      StdItem := UserEngine.GetBoxKeyItem(n_KeyAnicount);
      nCode := 1;
      if (StdItem <> nil) then begin
        boCanOpenBox := False;
        nRequiredGameGold := 0;
        nCode := 2;
        case n_OpenBoxCount of //检查开启次数，计算出所需元宝数
          0: begin
              nRequiredGameGold := Round(StdItem.Reserved * g_Config.nFirstOpen9Years); //第一次开启
              ItemNum := g_Config.nFirstOpen9Years; //一次可以得到钥匙数
            end;
          1: begin
              nRequiredGameGold := Round(StdItem.Reserved * g_Config.nSecondOpen9Years); //第二次开启
              ItemNum := g_Config.nSecondOpen9Years; //可以得到钥匙数
            end;
          2: begin
              nRequiredGameGold := Round(StdItem.Reserved * g_Config.nThreeOpen9Years); //第三次开启
              ItemNum := g_Config.nThreeOpen9Years; //可以得到钥匙数
            end;
          3: begin
              nRequiredGameGold := Round(StdItem.Reserved * g_Config.nFourOpen9Years); //第四次开启
              ItemNum := g_Config.nFourOpen9Years; //可以得到钥匙数
            end;
        else Exit;
        end;
        nCode := 3;
        if ItemNum <= 0 then ItemNum := 1;
        if (m_nGameGold >= nRequiredGameGold) and (nRequiredGameGold >= 0) then begin //检查元宝数,给钥匙，自动打开箱子
          if nRequiredGameGold > 0 then begin
            nCode := 4;
            DecGameGold(nRequiredGameGold);
            GameGoldChanged(); //更新客户端元宝
            if g_boGameLogGameGold then
              AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, m_sMapName,
                m_nCurrX, m_nCurrY, m_sCharName, g_Config.sGameGoldName,
                  m_nGameGold, '-(' + inttostr(nRequiredGameGold) + ')', '购买钥匙']));
            m_BuyShopPrice := nRequiredGameGold; //每次商铺花的元宝数量，$BUYSHOP变量使用 20090311
            nCode := 5;
            
            if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(self, '@BuyShop', False, False); //商铺购买触发
          end;
          nCode := 6;
          if ItemNum > 0 then begin
            for I := 0 to ItemNum - 1 do begin
              New(UserItem);
              nCode := 7;
              if UserEngine.CopyToUserItemFromName(StdItem.Name, UserItem) then begin
                nCode := 8;
                m_ItemList.Add(UserItem);
                nCode := 9;
                if StdItem.NeedIdentify = 1 then
                  AddGameDataLog('30' + #9 + m_sMapName + #9 +
                    IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                    m_sCharName + #9 + StdItem.Name + #9 +
                    IntToStr(UserItem.MakeIndex) + #9 +
                    '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                    '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                    '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                    '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                    '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                    IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                    IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                    IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                    IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + '0');
                nCode := 10;
                SendAddItem(UserItem);
                boCanOpenBox := True;
              end else begin
                nCode := 11;
                Dispose(UserItem);
                Break;
              end;
            end; //for
          end;
          nCode := 12;
          //自动开启箱子(删除箱子及钥匙)
          if boCanOpenBox then begin
            if (m_OpenBoxMakeID > 0) then begin
              nCode := 13;
              ClientSend9YearsBoxItem(m_OpenBoxMakeID, n_9YearBoxsID, 2, n_KeyAnicount, ItemNum); //删除箱子以及钥匙物品
            end else begin
              nCode := 14;
              Client9YearsOpenBoxs(True, ItemNum); //自动开启箱子，删除钥匙物品
            end;
          end;
        end else SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, Format('你的%s数量不足:%d', [g_Config.sGameGoldName, nRequiredGameGold])); //增加钥匙元宝数
      end;
      nCode := 15;
      m_OpenBoxMakeID := 0;
    end;
  except
    on E: Exception do begin
      MainOutMessage(format('{%s} TPlayObject.ClientBuy9YearsKeyAutoBox Code:%d', [g_sExceptionVer, nCode]));
    end;
  end;
end;

//开启宝箱,随机选择开到的物品
//nType-True 检查包裹是否有钥匙，没有则提示购买
//nKeyCount 所需钥匙数

procedure TPlayObject.Client9YearsOpenBoxs(nType: Boolean; nKeyCount: byte);
var
  I, K, KeyMakeIndex, nRequiredGameGold: Integer;
  UserItem: pTUserItem;
  StdItemKey: pTStdItem;
begin
  try
    if (m_Boxs = nil) or (m_Boxs.Count = 0) or (n_OpenBoxTpye <> 2) or (n_OpenBoxCount > 3) or (m_Boxs.Count < 5) then Exit;
    if nType then begin //检查包裹里是否有钥匙，没有则提示购买
      KeyMakeIndex := 0;
      K := 0;
      if m_ItemList.Count + 5 - nKeyCount > MAXBAGITEM then begin //检查包裹是否有5个空位
        SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '至少需要预留六个空位');
        Exit;
      end;
      if (n_OpenBoxCount > 0) then begin
        for I := m_ItemList.Count - 1 downto 0 do begin //检查包裹里是否有对应的钥匙
          if m_ItemList.Count <= 0 then Break;
          UserItem := m_ItemList.Items[I];
          if UserItem = nil then Continue;
          StdItemKey := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItemKey <> nil) then begin
            if (StdItemKey.StdMode = 49) and (StdItemKey.Shape = n_KeyAnicount) then begin //找到对应的钥匙，删除钥匙
              Inc(K);
              m_ItemList.Delete(I);
              SendDelItems(UserItem);
              Dispose(UserItem); //20100928 增加
              if K >= nKeyCount then begin
                m_boOpenBox := True;
                Break;
              end;
            end;
          end;
        end; //for
      end else begin //第一次，由于双击时已减元宝，所以此处直接进入
        if (n_OpenBoxCount = 0) and (nKeyCount = 0) then m_boOpenBox := True;
      end;
      if not m_boOpenBox then begin //提示玩家购买对应的钥匙
        StdItemKey := UserEngine.GetBoxKeyItem(n_KeyAnicount);
        if (StdItemKey <> nil) then begin //提示玩家购买钥匙
          case n_OpenBoxCount of //检查开启次数，计算出所需元宝数
            0: nRequiredGameGold := Round(StdItemKey.nHP * g_Config.nFirstOpen9Years); //第一次开启
            1: nRequiredGameGold := Round(StdItemKey.nHP * g_Config.nSecondOpen9Years); //第二次开启
            2: nRequiredGameGold := Round(StdItemKey.nHP * g_Config.nThreeOpen9Years); //第三次开启
            3: nRequiredGameGold := Round(StdItemKey.nHP * g_Config.nFourOpen9Years); //第四次开启
          end;
          SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 4, 0, Format('您需要 %s 才能开启此天赐，是否花费%d%s从商城购买%s把\%s？(%s商城定价:%d%s一把)', [StdItemKey.Name, nRequiredGameGold, g_Config.sGameGoldName, MoneyToCharacter(nKeyCount, True), StdItemKey.Name, StdItemKey.Name, StdItemKey.nHP, g_Config.sGameGoldName]));
        end;
        Exit;
      end;
    end;
    if m_boOpenBox then begin
      n_BoxsItmeID := 0;
      Inc(n_OpenBoxCount); //开宝箱记数
      n_BoxsItmeID := GetItemID(m_Boxs, 1);
      if n_BoxsItmeID <> 0 then SendMsg(Self, RM_SEND9YEARSITEMID, 0, n_BoxsItmeID, 0, 0, ''); //发消息给客户端
    end;
  except
    on E: Exception do begin
      MainOutMessage(format('{%s} TPlayObject.Client9YearsOpenBoxs', [g_sExceptionVer]));
    end;
  end;
end;

//点击“开始选择”，先判断是否有钥匙，没钥匙，则提示购买

procedure TPlayObject.ClientCheck9YearsBoxsKey();
var
  I, K, KeyMakeIndex, nKeyCount, nRequiredGameGold: Integer;
  UserItem: pTUserItem;
  StdItemKey: pTStdItem;
begin
  try
    if (m_Boxs = nil) or (m_Boxs.Count = 0) or (n_OpenBoxTpye <> 2) or (n_OpenBoxCount > 3) or (m_Boxs.Count < 5) then begin
      n_BoxsItmeID := 0;
      Exit;
    end;
    KeyMakeIndex := 0;
    K := 0;
    case n_OpenBoxCount of //检查开启次数，计算出所需钥匙数
      0: nKeyCount := 0; //一次可以得到钥匙数
      1: nKeyCount := g_Config.nSecondOpen9Years; //可以得到钥匙数
      2: nKeyCount := g_Config.nThreeOpen9Years; //可以得到钥匙数
      3: nKeyCount := g_Config.nFourOpen9Years; //可以得到钥匙数
    else Exit;
    end;
    if m_ItemList.Count + 5 - nKeyCount > MAXBAGITEM then begin //检查包裹是否有5个空位
      SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, '至少需要预留六个空位');
      Exit;
    end;
    if (n_OpenBoxCount > 0) then begin
      for I := m_ItemList.Count - 1 downto 0 do begin //检查包裹里是否有对应的钥匙
        if m_ItemList.Count <= 0 then Break;
        UserItem := m_ItemList.Items[I];
        if UserItem = nil then Continue;
        StdItemKey := UserEngine.GetStdItem(UserItem.wIndex);
        if (StdItemKey <> nil) then begin
          if (StdItemKey.StdMode = 49) and (StdItemKey.Shape = n_KeyAnicount) then begin //找到对应的钥匙，删除钥匙
            Inc(K);
            m_ItemList.Delete(I);
            SendDelItems(UserItem);
            Dispose(UserItem); //20100928 增加
            if K >= nKeyCount then begin
              m_boOpenBox := True;
              Break;
            end;
          end;
        end;
      end; //for
    end else begin //第一次，由于双击时已减元宝，所以此处直接进入
      if (n_OpenBoxCount = 0) and (nKeyCount = 0) then m_boOpenBox := True;
    end;
    if not m_boOpenBox then begin //提示玩家购买对应的钥匙
      StdItemKey := UserEngine.GetBoxKeyItem(n_KeyAnicount);
      if (StdItemKey <> nil) then begin //提示玩家购买钥匙
        case n_OpenBoxCount of //检查开启次数，计算出所需元宝数
          0: nRequiredGameGold := Round(StdItemKey.nHp * g_Config.nFirstOpen9Years); //第一次开启
          1: nRequiredGameGold := Round(StdItemKey.nHp * g_Config.nSecondOpen9Years); //第二次开启
          2: nRequiredGameGold := Round(StdItemKey.nHp * g_Config.nThreeOpen9Years); //第三次开启
          3: nRequiredGameGold := Round(StdItemKey.nHp * g_Config.nFourOpen9Years); //第四次开启
        end;
        SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 4, 0, Format('您需要 %s 才能开启此天赐，是否花费%d%s从商城购买%s把\%s？(%s商城定价:%d%s一把)', [StdItemKey.Name, nRequiredGameGold, g_Config.sGameGoldName, MoneyToCharacter(nKeyCount, True), StdItemKey.Name, StdItemKey.Name, StdItemKey.nhp, g_Config.sGameGoldName]));
      end;
      Exit;
    end;

    if m_boOpenBox then begin
      n_BoxsItmeID := 0;
      Inc(n_OpenBoxCount); //开宝箱记数
      n_BoxsItmeID := GetItemID(m_Boxs, 1);
      if n_BoxsItmeID <> 0 then SendMsg(Self, RM_SEND9YEARSITEMID, 0, n_BoxsItmeID, 0, 0, ''); //发消息给客户端
    end;
  except
    on E: Exception do begin
      MainOutMessage(format('{%s} TPlayObject.ClientCheck9YearsBoxsKey', [g_sExceptionVer]));
    end;
  end;
end;

//未开启前，更新物品(三次机会)

procedure TPlayObject.ClientUpdate9YearsBoxsItem();
var
  vList1, vList4: TList;
  I, T: Integer;
  BoxsInfo: TBoxsInfo;
  BoxsInfo1, BoxsInfo2: pTBoxsInfo;
  sSendStr: string;
  List28: TList;
begin
  if m_boUpdate9YearsBoxsItem then Exit;
  try
    m_boUpdate9YearsBoxsItem := True;
    if (not m_boOpenBox) or (n_OpenBoxTpye <> 2) or (n_OpenBoxCount <> 0) or (n_9YearUpdateCount > 2) then Exit;
    Inc(n_9YearUpdateCount);
    sSendStr := '';
    Randomize; //播下随机种子
    vList1 := TList.Create;
    vList4 := TList.Create;
    try
      if BoxsList.Count > 0 then begin //20100511 修改
        T := BoxsList.IndexOf(IntToStr(n_9YearBoxsID));
        if T > -1 then begin
          List28 := TList(BoxsList.Objects[T]);
          if List28 <> nil then begin
            if List28.count > 0 then begin
              for T := 0 to List28.count - 1 do begin
                BoxsInfo1 := pTBoxsInfo(List28.Items[T]);
                if BoxsInfo1 <> nil then begin
                  if (BoxsInfo1.SBoxsID <> n_9YearBoxsID) then Continue; //如果不是Source对应的txt文件则跳过
                  case BoxsInfo1.nItemType of
                    0: vList1.Add(BoxsInfo1); //普通物品写入vList1
                    3: vList4.Add(BoxsInfo1); //天赐极品物品
                  end;
                end;
              end;
            end;
          end;
        end;
        {for T := 0 to BoxsList.Count - 1 do begin
          BoxsInfo1 := pTBoxsInfo(BoxsList.Items[T]);
          if BoxsInfo1 <> nil then begin
            if (BoxsInfo1.SBoxsID <> n_9YearBoxsID) then Continue; //如果不是Source对应的txt文件则跳过
            case BoxsInfo1.nItemType of
              0: vList1.Add(BoxsInfo1); //普通物品写入vList1
              3: vList4.Add(BoxsInfo1); //天赐极品物品
            end;
          end;
        end;}
      end;
      //要求：普通物品需8件,极品物品2件
      if (vList1.Count > 7) and (vList4.Count > 1) then begin
        if m_Boxs.Count > 0 then begin //
          for I := 0 to m_Boxs.Count - 1 do begin
            if pTBoxsInfo(m_Boxs.Items[I]) <> nil then Dispose(pTBoxsInfo(m_Boxs.Items[I]));
          end;
          m_Boxs.Clear;
        end;
        case Random(8) of
          0: begin
              T := Random(vList4.Count);
              BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList4.Delete(T); //抽取完后从临时列表中删除数据

              for I := 0 to 5 do begin //取出6件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;

              T := Random(vList4.Count);
              BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList4.Delete(T); //抽取完后从临时列表中删除数据
            end;
          1: begin
              T := Random(vList4.Count);
              BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList4.Delete(T); //抽取完后从临时列表中删除数据

              for I := 0 to 2 do begin //取出3件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;

              T := Random(vList4.Count);
              BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList4.Delete(T); //抽取完后从临时列表中删除数据

              for I := 0 to 2 do begin //取出3件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;
            end;
          2: begin
              for I := 0 to 2 do begin //取出3件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;

              T := Random(vList4.Count);
              BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList4.Delete(T); //抽取完后从临时列表中删除数据

              for I := 0 to 2 do begin //取出3件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;

              T := Random(vList4.Count);
              BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList4.Delete(T); //抽取完后从临时列表中删除数据
            end;
          3: begin
              for I := 0 to 1 do begin //取出2件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;

              T := Random(vList4.Count);
              BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList4.Delete(T); //抽取完后从临时列表中删除数据

              for I := 0 to 1 do begin //取出2件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;

              T := Random(vList4.Count);
              BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList4.Delete(T); //抽取完后从临时列表中删除数据

              for I := 0 to 1 do begin //取出2件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;
            end;
          4: begin
              T := Random(vList1.Count);
              BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList1.Delete(T); //抽取完后从临时列表中删除数据

              T := Random(vList4.Count);
              BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList4.Delete(T); //抽取完后从临时列表中删除数据

              for I := 0 to 1 do begin //取出2件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;

              T := Random(vList4.Count);
              BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList4.Delete(T); //抽取完后从临时列表中删除数据

              for I := 0 to 2 do begin //取出3件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;
            end;
          5: begin
              for I := 0 to 4 do begin //取出5件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;

              T := Random(vList4.Count);
              BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList4.Delete(T); //抽取完后从临时列表中删除数据

              for I := 0 to 1 do begin //取出2件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;
            end;
          6: begin
              T := Random(vList1.Count);
              BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList1.Delete(T); //抽取完后从临时列表中删除数据

              T := Random(vList4.Count);
              BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList4.Delete(T); //抽取完后从临时列表中删除数据

              for I := 0 to 5 do begin //取出6件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;
            end; //6
          7: begin
              for I := 0 to 6 do begin //取出7件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;

              T := Random(vList4.Count);
              BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList4.Delete(T); //抽取完后从临时列表中删除数据
            end; //7
        end; //Case
      end;
      if sSendStr <> '' then SendMsg(Self, RM_OPENBOXS, 0, 1, n_OpenBoxTpye, 0, sSendStr) //显示特效
    finally
      vList1.Free;
      vList4.Free;
    end;
  finally
    m_boUpdate9YearsBoxsItem := False;
  end;
end;
//给玩家9周年宝箱物品

procedure TPlayObject.ClientGet9YearsBoxsItem();
var
  I, ItemNum, nDura, K: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  BoxsInfo: pTBoxsInfo;
  ItemName, sCheckItemName, szString: string;
  boHithOK: Boolean;
begin
  if (not m_boOpenBox) or (n_BoxsItmeID <= 0) or (n_OpenBoxTpye <> 2) or (n_OpenBoxCount > 4) or (n_OpenBoxCount <= 0) or m_boGivePlayItme or (m_Boxs.Count < 5) then Exit;
  m_boGivePlayItme := True; //给玩家物品
  m_boOpenBox := False;
  boHithOK := False;
  try
    try
      ItemNum := 0;
      ItemName := '';
      nDura := 0;
      if (n_OpenBoxCount >= 3) then m_boFree9YearsBox := True; //是否取得免费奖励20格箱子
      if n_BoxsItmeID <> 0 then begin
        if m_Boxs.Count > 0 then begin
          for I := 0 to m_Boxs.Count - 1 do begin
            BoxsInfo := pTBoxsInfo(m_Boxs.Items[I]);
            if BoxsInfo.StdItem.MakeIndex = n_BoxsItmeID then begin
              ItemName := BoxsInfo.StdItem.s.Name; //物品名称
              ItemNum := BoxsInfo.nItemNum; //物品数量
              nDura := BoxsInfo.StdItem.Dura;
              m_Boxs.Delete(I);
              try
                Dispose(BoxsInfo);
              except
              end;
            end;
            if ItemName <> '' then break;
          end;
        end;
        if (ItemName <> '') then begin
          StdItem := UserEngine.GetStdItem(ItemName);
          if (StdItem <> nil) then begin
            if ItemNum <= 0 then ItemNum := 1;
            for I := 0 to ItemNum - 1 do begin //支持物品的多数量获取
              New(UserItem);
              if UserEngine.CopyToUserItemFromName(StdItem.Name, UserItem) then begin
                case StdItem.StdMode of
                  2, 7, 8, 17, 18, 51: ; //酿酒材料, 叠加物品和符,聚集物品,千里传音，传音筒不重新算值
                else UserItem.Dura := nDura;
                end;
                if IsEnoughBag and IsAddWeightAvailable(StdItem.Weight) then begin //包裹有位置则放到包裹里,没有则扔出物品
                  if StdItem.StdMode = 17 then begin //叠加物品自动合并
                    if m_btRaceServer = RC_PLAYOBJECT then begin
                      sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                      boHithOK := True;
                    end;
                    if not AutoItemMerger(UserItem) then begin //自动合并物品
                      m_ItemList.Add(UserItem);
                      SendAddItem(UserItem);
                      if StdItem.NeedIdentify = 1 then
                        AddGameDataLog('40' + #9 + m_sMapName + #9 +
                          IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                          m_sCharName + #9 + StdItem.Name + #9 +
                          IntToStr(UserItem.MakeIndex) + #9 +
                          '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + '0');
                    end;
                  end else begin
                    m_ItemList.Add(UserItem);
                    if StdItem.NeedIdentify = 1 then
                      AddGameDataLog('40' + #9 + m_sMapName + #9 +
                        IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 + StdItem.Name + #9 +
                        IntToStr(UserItem.MakeIndex) + #9 +
                        '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                        '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                        '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                        '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                        '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                        IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                        IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                        IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                        IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + '0');

                    if m_btRaceServer = RC_PLAYOBJECT then begin
                      SendAddItem(UserItem);
                      sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                      boHithOK := True;
                    end;
                  end;
                end else begin //包裹满扔出物品
                  DropItemDown(UserItem, 3, False, False, self, self);
                  Dispose(UserItem);//修复内存泄露By TasNat at: 2012-06-01 12:10:51
                end;
              end else begin
                Dispose(UserItem);
                Break;
              end;
            end;
            if boHithOK then begin
              if not PlugOfCheckCanItem(5, sCheckItemName, False, ItemNum, 0) then begin //禁止物品规则(没有设置全F提示的物品)
                szString := AnsiReplaceText(g_sBoxsItemHintMsg1, '%name', m_sCharName);
                szString := AnsiReplaceText(szString, '%s', sCheckItemName);
                szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                SysMsg(szString, c_Blue, t_Say);
              end;
            end;
          end else begin //不是数据库里的物品
            if (CompareText(Trim(ItemName), '经验') = 0) or (CompareText(Trim(ItemName), '经验(大量)') = 0) or (CompareText(Trim(ItemName), '经验(海量)') = 0) then begin
              GetExpToItem(ItemNum); //取得的经验,累积到聚灵珠 20080817
              if not PlugOfCheckCanItem(5, Trim(ItemName), False, ItemNum, 0) then begin //禁止物品规则(没有设置全F提示的物品)
                szString := AnsiReplaceText(g_sBoxsItemHintMsg1, '%name', m_sCharName);
                szString := AnsiReplaceText(szString, '%s', '经验'); //20080617
                szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                SysMsg(szString, c_Blue, t_Say);
              end;

              if m_MyHero <> nil then begin
                if m_MyHero.m_Abil.Level < g_Config.nLimitExpLevelHero then begin //20110116 增加
                  THeroObject(m_MyHero).GetExp(abs(Round((g_Config.nHeroNoKillMonExpRate / 100) * ItemNum)), 0);
                  ItemNum := abs(Round(((100 - g_Config.nHeroNoKillMonExpRate) / 100) * ItemNum));
                end;
              end;
              if m_Abil.nExp >= LongWord(ItemNum) then begin
                if (High(uInt64) - m_Abil.nExp) < LongWord(ItemNum) then begin
                  ItemNum := High(uInt64) - m_Abil.nExp;
                end;
              end else begin
                if (High(uInt64) - LongWord(ItemNum)) < m_Abil.nExp then begin
                  ItemNum := High(uInt64) - LongWord(ItemNum);
                end;
              end;
              m_GetExp := ItemNum; //人物取得的经验,$GetExp变量使用
              if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(self, '@GetExp', False, False); //取经验触发
              Inc(m_Abil.nExp, ItemNum);
              SendMsg(self, RM_WINEXP, 0, 0, 0, 0, EncodeExp(m_Abil.nExp, ItemNum));
              if (m_Abil.Level < MAXUPLEVEL) and
                (m_Abil.Level < g_Config.nLimitExpLevel) then begin //20110925 达到等级上限时
                if g_Config.boContinuousUpLevel then begin //20100605
                  K := 0;
                  while (m_Abil.nExp >= m_Abil.nMaxExp) do begin //20100408 循环处理升级
                    if K >= 8 then Break;
                    Inc(K);
                    if m_Abil.nExp <= 0 then begin
                      m_Abil.nExp := 0;
                      Break;
                    end;
                  //if m_Abil.Exp >= m_Abil.MaxExp then begin//箱子检查升级
                    Dec(m_Abil.nExp, m_Abil.nMaxExp);
                    if (m_Abil.Level < MAXUPLEVEL) and (m_Abil.Level < g_Config.nLimitExpLevel) then begin
                      Inc(m_Abil.Level);
                      if (m_sMasterName <> '') and not m_boMaster then begin //自动出师 20100408
                        if m_Abil.Level >= g_Config.nMasterOKLevel then CheckMaster(True);
                      end;
                    end;
                    if m_Abil.Level < g_Config.nLimitExpLevel then begin
                      HasLevelUp(m_Abil.Level - 1); //增加限制等级
                      if not m_boAI then begin
                        AddGameDataLog('12' + #9 + m_sMapName + #9 + //人物升级记录日志
                          IntToStr(m_nCurrX) + #9 +
                          IntToStr(m_nCurrY) + #9 +
                          m_sCharName + #9 + IntToStr(m_Abil.nExp) + '/' + IntToStr(m_Abil.nMaxExp) + #9 + IntToStr(m_Abil.Level) + #9 + '1' + #9 + '(箱子经验)');
                      end;
                    end;
                  end;
                end else begin
                  if m_Abil.nExp >= m_Abil.nMaxExp then begin //箱子检查升级
                    Dec(m_Abil.nExp, m_Abil.nMaxExp);
                    if (m_Abil.Level < MAXUPLEVEL) and (m_Abil.Level < g_Config.nLimitExpLevel) then begin
                      Inc(m_Abil.Level);
                      if (m_sMasterName <> '') and not m_boMaster then begin //自动出师 20100408
                        if m_Abil.Level >= g_Config.nMasterOKLevel then CheckMaster(True);
                      end;
                    end;
                    if m_Abil.Level < g_Config.nLimitExpLevel then begin
                      HasLevelUp(m_Abil.Level - 1); //增加限制等级
                      if not m_boAI then begin
                        AddGameDataLog('12' + #9 + m_sMapName + #9 + //人物升级记录日志
                          IntToStr(m_nCurrX) + #9 +
                          IntToStr(m_nCurrY) + #9 +
                          m_sCharName + #9 + IntToStr(m_Abil.nExp) + '/' + IntToStr(m_Abil.nMaxExp) + #9 + IntToStr(m_Abil.Level) + #9 + '1' + #9 + '(箱子经验)');
                      end;
                    end;
                  end;
                end;
              end;
            end else
              if (CompareText(Trim(ItemName), '声望') = 0) then begin
                Inc(m_btCreditPoint, ItemNum);
                GameGoldChanged();
                if not PlugOfCheckCanItem(5, Trim(ItemName), False, ItemNum, 0) then begin //禁止物品规则(没有设置全F提示的物品)
                  szString := AnsiReplaceText(g_sBoxsItemHintMsg1, '%name', m_sCharName); //20080617
                  szString := AnsiReplaceText(szString, '%s', '声望'); //20080617
                  szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                  SysMsg(szString, c_Blue, t_Say);
                end;
              end else
                if (CompareText(Trim(ItemName), g_Config.sGameGird) = 0) or
                  (CompareText(Trim(ItemName), Format('%s(大量)', [g_Config.sGameGird {'灵符'}])) = 0) or
                  (CompareText(Trim(ItemName), Format('%s(海量)', [g_Config.sGameGird {'灵符'}])) = 0) then begin
                  Inc(m_nGAMEGIRD, ItemNum);
                  GameGoldChanged; //更新灵符数量
                  if not PlugOfCheckCanItem(5, Trim(ItemName), False, ItemNum, 0) then begin //禁止物品规则(没有设置全F提示的物品)
                    szString := AnsiReplaceText(g_sBoxsItemHintMsg1, '%name', m_sCharName);
                    szString := AnsiReplaceText(szString, '%s', g_Config.sGameGird);
                    szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                    SysMsg(szString, c_Blue, t_Say);
                  end;
                end else
                  if (CompareText(Trim(ItemName), g_Config.sGameDiaMond) = 0) then begin
                    Inc(m_nGAMEDIAMOND, ItemNum);
                    GameGoldChanged; //更新金刚石数量
                    if not PlugOfCheckCanItem(5, Trim(ItemName), False, ItemNum, 0) then begin //禁止物品规则(没有设置全F提示的物品)
                      szString := AnsiReplaceText(g_sBoxsItemHintMsg1, '%name', m_sCharName);
                      szString := AnsiReplaceText(szString, '%s', g_Config.sGameDiaMond);
                      szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                      SysMsg(szString, c_Blue, t_Say);
                    end;
{$IF M2Version <> 2}
                  end else
                    if (CompareText(Trim(ItemName), '内功') = 0) or (CompareText(Trim(ItemName), '内功(大量)') = 0) or (CompareText(Trim(ItemName), '内功(海量)') = 0) then begin //内功经验 20100413
                      if m_boTrainingNG then begin
                        GetNGExp(ItemNum, 1); //取得内功经验
                        if not PlugOfCheckCanItem(5, Trim(ItemName), False, ItemNum, 0) then begin //禁止物品规则(没有设置全F提示的物品)
                          szString := AnsiReplaceText(g_sBoxsItemHintMsg1, '%name', m_sCharName);
                          szString := AnsiReplaceText(szString, '%s', '内功经验');
                          szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                          SysMsg(szString, c_Blue, t_Say);
                        end;
                      end;
{$IFEND}
                    end;
          end;
        end;
        SendMsg(Self, RM_GET9YEARSBOXSITEM_OK, 0, 0, 0, 0, ''); //九周年宝箱取物品成功
        n_BoxsItmeID := 0;
      end; //if n_BoxsItmeID <> 0 then begin
    except
      on E: Exception do begin
        MainOutMessage(format('{%s} TPlayObject.ClientGet9YearsBoxsItem', [g_sExceptionVer]));
      end;
    end;
  finally
    m_boGivePlayItme := False; //给玩家物品
  end;
end;
//免费奖励(20格箱子,选出20个物品，同时选择得到的物品的ID，发送给客户端)

procedure TPlayObject.ClientOpenFree9YearsBoxs();
var
  vList1, vList4: TList;
  I, T: Integer;
  BoxsInfo: TBoxsInfo;
  BoxsInfo1, BoxsInfo2: pTBoxsInfo;
  sSendStr: string;
  List28: TList;
begin
  if (not m_boOpenBox) and m_boFree9YearsBox and (n_OpenBoxTpye = 2) and (n_OpenBoxCount = 4) then begin
    n_OpenBoxTpye := 3; //20格宝箱
    n_OpenBoxCount := 0;
    n_BoxsItmeID := 0;
    sSendStr := '';
    vList1 := TList.Create;
    vList4 := TList.Create;
    try
      if BoxsList.Count > 0 then begin //20100511 修改
        T := BoxsList.IndexOf(IntToStr(g_Config.nFree9YearsBoxID));
        if T > -1 then begin
          List28 := TList(BoxsList.Objects[T]);
          if List28 <> nil then begin
            if List28.count > 0 then begin
              for T := 0 to List28.count - 1 do begin
                BoxsInfo1 := pTBoxsInfo(List28.Items[T]);
                if BoxsInfo1 <> nil then begin
                  if (BoxsInfo1.SBoxsID <> g_Config.nFree9YearsBoxID) then Continue; //如果不是Source对应的txt文件则跳过
                  case BoxsInfo1.nItemType of
                    0: vList1.Add(BoxsInfo1); //普通物品写入vList1
                    3: vList4.Add(BoxsInfo1); //天赐极品物品
                  end;
                end;
              end;
            end;
          end;
        end;
        {for T := 0 to BoxsList.Count - 1 do begin
          BoxsInfo1 := pTBoxsInfo(BoxsList.Items[T]);
          if BoxsInfo1 <> nil then begin
            if (BoxsInfo1.SBoxsID <> g_Config.nFree9YearsBoxID) then Continue; //如果不是Source对应的txt文件则跳过
            case BoxsInfo1.nItemType of
              0: vList1.Add(BoxsInfo1); //普通物品写入vList1
              3: vList4.Add(BoxsInfo1); //天赐极品物品
            end;
          end;
        end;}
      end;
      //要求：普通物品需18件,极品2件
      if (vList1.Count > 17) and (vList4.Count > 1) then begin
        if m_Boxs.Count > 0 then begin //
          for I := 0 to m_Boxs.Count - 1 do begin
            if pTBoxsInfo(m_Boxs.Items[I]) <> nil then Dispose(pTBoxsInfo(m_Boxs.Items[I]));
          end;
          m_Boxs.Clear;
        end;
        Randomize; //播下随机种子
        case Random(4) of
          0: begin
              for I := 0 to 9 do begin //取出10件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;

              T := Random(vList4.Count);
              BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList4.Delete(T); //抽取完后从临时列表中删除数据

              for I := 0 to 7 do begin //取出8件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;

              T := Random(vList4.Count);
              BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList4.Delete(T); //抽取完后从临时列表中删除数据
            end;
          1: begin
              for I := 0 to 5 do begin //取出6件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;

              T := Random(vList4.Count);
              BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList4.Delete(T); //抽取完后从临时列表中删除数据

              for I := 0 to 5 do begin //取出6件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;

              T := Random(vList4.Count);
              BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList4.Delete(T); //抽取完后从临时列表中删除数据

              for I := 0 to 5 do begin //取出6件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;
            end;
          2: begin
              for I := 0 to 2 do begin //取出3件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;

              T := Random(vList4.Count);
              BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList4.Delete(T); //抽取完后从临时列表中删除数据

              for I := 0 to 9 do begin //取出10件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;

              T := Random(vList4.Count);
              BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList4.Delete(T); //抽取完后从临时列表中删除数据

              for I := 0 to 4 do begin //取出5件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;
            end;
          3: begin
              for I := 0 to 10 do begin //取出11件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;

              T := Random(vList4.Count);
              BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList4.Delete(T); //抽取完后从临时列表中删除数据

              for I := 0 to 3 do begin //取出4件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;

              T := Random(vList4.Count);
              BoxsInfo1 := pTBoxsInfo(vList4.Items[T]);
              New(BoxsInfo2);
              BoxsInfo2^ := BoxsInfo1^;
              BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
              BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
              BoxsInfo := BoxsInfo2^;
              m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
              sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
              vList4.Delete(T); //抽取完后从临时列表中删除数据

              for I := 0 to 2 do begin //取出3件物品
                T := Random(vList1.Count);
                BoxsInfo1 := pTBoxsInfo(vList1.Items[T]);
                New(BoxsInfo2);
                BoxsInfo2^ := BoxsInfo1^;
                BoxsInfo2.StdItem.s.Reserved1 := 1; //标识
                BoxsInfo2.StdItem.Dura := Round((BoxsInfo2.StdItem.DuraMax / 100) * (20 + Random(80))); //重新计算持久值
                BoxsInfo := BoxsInfo2^;
                m_Boxs.Add(BoxsInfo2); //保存随机取出的宝箱物品
                sSendStr := sSendStr + EncodeBuffer(@BoxsInfo, SizeOf(TBoxsInfo)) + '/';
                vList1.Delete(T); //抽取完后从临时列表中删除数据
              end;
            end;
        end; //case
      end else SysMsg('免费奖励宝箱开启失败，配置文件少于20个物品！', c_Red, t_Hint);
      if sSendStr <> '' then begin
        m_boOpenBox := True;
        n_BoxsItmeID := GetItemID(m_Boxs, 1);
        if n_BoxsItmeID <> 0 then SendMsg(Self, RM_SEND9YEARSITEMID, 1 {区别9周年天赐-0 免费-1}, n_BoxsItmeID, 0, 0, ''); //取出所得物品制ID，发消息给客户端
        SendMsg(Self, RM_OPENBOXS, 0, 1, n_OpenBoxTpye, 0, sSendStr); //显示特效
      end;
    finally
      vList1.Free;
      vList4.Free;
    end;
  end;
end;
//取20格免费奖励宝箱物品

procedure TPlayObject.ClientGetFree9YearsBoxsItem();
var
  I, ItemNum, K: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  BoxsInfo: pTBoxsInfo;
  ItemName: string;
  sCheckItemName, szString: string;
  boHithOK: Boolean;
begin
  if m_boOpenBox then begin
    m_boOpenBox := False;
    if m_boFree9YearsBox and (n_OpenBoxTpye = 3) and (n_BoxsItmeID > 0) then begin
      if not m_boGivePlayItme then begin
        m_boGivePlayItme := True; //给玩家物品
        boHithOK := False;
        try
          try
            ItemNum := 0;
            ItemName := '';
            if m_Boxs.Count > 0 then begin
              for I := 0 to m_Boxs.Count - 1 do begin
                BoxsInfo := pTBoxsInfo(m_Boxs.Items[I]);
                if BoxsInfo.StdItem.MakeIndex = n_BoxsItmeID then begin
                  n_BoxsItmeID := 0;
                  ItemName := BoxsInfo.StdItem.s.Name; //物品名称
                  ItemNum := BoxsInfo.nItemNum; //物品数量
                end;
                if ItemName <> '' then break;
              end;
            end;
            if (ItemName <> '') then begin
              StdItem := UserEngine.GetStdItem(ItemName);
              if (StdItem <> nil) then begin
                if ItemNum <= 0 then ItemNum := 1;
                for I := 0 to ItemNum - 1 do begin //支持物品的多数量获取
                  New(UserItem);
                  if UserEngine.CopyToUserItemFromName(StdItem.Name, UserItem) then begin
                    case StdItem.StdMode of
                      2, 7, 8, 17, 18, 51: ; //酿酒材料,叠加物品和符,聚集物品,千里传音，传音筒不重新算值
                    else UserItem.Dura := BoxsInfo.StdItem.Dura;
                    end;
                    if IsEnoughBag and IsAddWeightAvailable(StdItem.Weight) then begin //包裹有位置则放到包裹里,没有则扔出物品
                      if StdItem.StdMode = 17 then begin //叠加物品自动合并
                        if m_btRaceServer = RC_PLAYOBJECT then begin
                          sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                          boHithOK := True;
                        end;
                        if not AutoItemMerger(UserItem) then begin //自动合并物品
                          m_ItemList.Add(UserItem);
                          SendAddItem(UserItem);
                          if StdItem.NeedIdentify = 1 then
                            AddGameDataLog('40' + #9 + m_sMapName + #9 +
                              IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                              m_sCharName + #9 + StdItem.Name + #9 +
                              IntToStr(UserItem.MakeIndex) + #9 +
                              '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + '0');
                        end;
                      end else begin
                        m_ItemList.Add(UserItem);
                        if StdItem.NeedIdentify = 1 then
                          AddGameDataLog('40' + #9 + m_sMapName + #9 +
                            IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                            m_sCharName + #9 + StdItem.Name + #9 +
                            IntToStr(UserItem.MakeIndex) + #9 +
                            '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                            '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                            '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                            '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                            '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                            IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                            IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                            IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                            IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + '0');

                        if m_btRaceServer = RC_PLAYOBJECT then begin
                          SendAddItem(UserItem);
                          sCheckItemName := UserEngine.GetStdItemName(UserItem.wIndex);
                          boHithOK := True;
                        end;
                      end;
                    end else begin //包裹满扔出物品
                      DropItemDown(UserItem, 3, False, False, self, self);
                      Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                    end;
                  end else begin
                    Dispose(UserItem);
                    Break;
                  end;
                end;
                if boHithOK then begin
                  if not PlugOfCheckCanItem(5, sCheckItemName, False, ItemNum, 0) then begin //禁止物品规则(没有设置全F提示的物品) 20080729
                    szString := AnsiReplaceText(g_sBoxsItemHintMsg1, '%name', m_sCharName);
                    szString := AnsiReplaceText(szString, '%s', sCheckItemName);
                    szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                    SysMsg(szString, c_Blue, t_Say);
                  end;
                end;
              end else begin //不是数据库里的物品
                if (CompareText(Trim(ItemName), '经验') = 0) or (CompareText(Trim(ItemName), '经验(大量)') = 0) or (CompareText(Trim(ItemName), '经验(海量)') = 0) then begin
                  GetExpToItem(ItemNum); //取得的经验,累积到聚灵珠
                  if not PlugOfCheckCanItem(5, Trim(ItemName), False, ItemNum, 0) then begin //禁止物品规则(没有设置全F提示的物品)
                    szString := AnsiReplaceText(g_sBoxsItemHintMsg1, '%name', m_sCharName);
                    szString := AnsiReplaceText(szString, '%s', '经验');
                    szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                    SysMsg(szString, c_Blue, t_Say);
                  end;

                  if m_MyHero <> nil then begin
                    if m_MyHero.m_Abil.Level < g_Config.nLimitExpLevelHero then begin //20110116 增加
                      THeroObject(m_MyHero).GetExp(abs(Round((g_Config.nHeroNoKillMonExpRate / 100) * ItemNum)), 0);
                      ItemNum := abs(Round(((100 - g_Config.nHeroNoKillMonExpRate) / 100) * ItemNum));
                    end;
                  end;
                  if m_Abil.nExp >= LongWord(ItemNum) then begin
                    if (High(uInt64) - m_Abil.nExp) < LongWord(ItemNum) then begin
                      ItemNum := High(uInt64) - m_Abil.nExp;
                    end;
                  end else begin
                    if (High(uInt64) - LongWord(ItemNum)) < m_Abil.nExp then begin
                      ItemNum := High(uInt64) - LongWord(ItemNum);
                    end;
                  end;
                  m_GetExp := ItemNum; //人物取得的经验,$GetExp变量使用
                  if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(self, '@GetExp', False, False); //取经验触发
                  Inc(m_Abil.nExp, ItemNum);
                  SendMsg(self, RM_WINEXP, 0, 0, 0, 0, EncodeExp(m_Abil.nExp, ItemNum));
                  if (m_Abil.Level < MAXUPLEVEL) and
                    (m_Abil.Level < g_Config.nLimitExpLevel) then begin //20110925 达到等级上限时
                    if g_Config.boContinuousUpLevel then begin //20100605
                      K := 0;
                      while (m_Abil.nExp >= m_Abil.nMaxExp) do begin //20100408 循环处理升级
                        if K >= 8 then Break;
                        Inc(K);
                        if m_Abil.nExp <= 0 then begin
                          m_Abil.nExp := 0;
                          Break;
                        end;
                      //if m_Abil.Exp >= m_Abil.MaxExp then begin//开箱子检查升级
                        Dec(m_Abil.nExp, m_Abil.nMaxExp);
                        if (m_Abil.Level < MAXUPLEVEL) and (m_Abil.Level < g_Config.nLimitExpLevel) then begin
                          Inc(m_Abil.Level);
                          if (m_sMasterName <> '') and not m_boMaster then begin //自动出师 20100408
                            if m_Abil.Level >= g_Config.nMasterOKLevel then CheckMaster(True);
                          end;
                        end;
                        if m_Abil.Level < g_Config.nLimitExpLevel then begin
                          HasLevelUp(m_Abil.Level - 1); //增加限制等级
                          if not m_boAI then begin
                            AddGameDataLog('12' + #9 + m_sMapName + #9 + //人物升级记录日志
                              IntToStr(m_nCurrX) + #9 +
                              IntToStr(m_nCurrY) + #9 +
                              m_sCharName + #9 + IntToStr(m_Abil.nExp) + '/' + IntToStr(m_Abil.nMaxExp) + #9 + IntToStr(m_Abil.Level) + #9 + '1' + #9 + '(箱子经验)');
                          end;
                        end;
                      end;
                    end else begin
                      if m_Abil.nExp >= m_Abil.nMaxExp then begin //开箱子检查升级
                        Dec(m_Abil.nExp, m_Abil.nMaxExp);
                        if (m_Abil.Level < MAXUPLEVEL) and (m_Abil.Level < g_Config.nLimitExpLevel) then begin
                          Inc(m_Abil.Level);
                          if (m_sMasterName <> '') and not m_boMaster then begin //自动出师 20100408
                            if m_Abil.Level >= g_Config.nMasterOKLevel then CheckMaster(True);
                          end;
                        end;
                        if m_Abil.Level < g_Config.nLimitExpLevel then begin
                          HasLevelUp(m_Abil.Level - 1); //增加限制等级
                          if not m_boAI then begin
                            AddGameDataLog('12' + #9 + m_sMapName + #9 + //人物升级记录日志
                              IntToStr(m_nCurrX) + #9 +
                              IntToStr(m_nCurrY) + #9 +
                              m_sCharName + #9 + IntToStr(m_Abil.nExp) + '/' + IntToStr(m_Abil.nMaxExp) + #9 + IntToStr(m_Abil.Level) + #9 + '1' + #9 + '(箱子经验)');
                          end;
                        end;
                      end;
                    end;
                  end;
                end else
                  if (CompareText(Trim(ItemName), '声望') = 0) then begin
                    Inc(m_btCreditPoint, ItemNum);
                    GameGoldChanged();
                    if not PlugOfCheckCanItem(5, Trim(ItemName), False, ItemNum, 0) then begin //禁止物品规则(没有设置全F提示的物品)
                      szString := AnsiReplaceText(g_sBoxsItemHintMsg1, '%name', m_sCharName); //20080617
                      szString := AnsiReplaceText(szString, '%s', '声望'); //20080617
                      szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                      SysMsg(szString, c_Blue, t_Say);
                    end;
                  end else
                    if (CompareText(Trim(ItemName), g_Config.sGameGird) = 0) or
                      (CompareText(Trim(ItemName), Format('%s(大量)', [g_Config.sGameGird {'灵符'}])) = 0) or
                      (CompareText(Trim(ItemName), Format('%s(海量)', [g_Config.sGameGird {'灵符'}])) = 0) then begin
                      Inc(m_nGAMEGIRD, ItemNum);
                      GameGoldChanged; //更新灵符数量
                      if not PlugOfCheckCanItem(5, Trim(ItemName), False, ItemNum, 0) then begin //禁止物品规则(没有设置全F提示的物品)
                        szString := AnsiReplaceText(g_sBoxsItemHintMsg1, '%name', m_sCharName);
                        szString := AnsiReplaceText(szString, '%s', g_Config.sGameGird);
                        szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                        SysMsg(szString, c_Blue, t_Say);
                      end;
                    end else
                      if (CompareText(Trim(ItemName), g_Config.sGameDiaMond) = 0) then begin
                        Inc(m_nGAMEDIAMOND, ItemNum);
                        GameGoldChanged; //更新金刚石数量
                        if not PlugOfCheckCanItem(5, Trim(ItemName), False, ItemNum, 0) then begin //禁止物品规则(没有设置全F提示的物品)
                          szString := AnsiReplaceText(g_sBoxsItemHintMsg1, '%name', m_sCharName); //20080617
                          szString := AnsiReplaceText(szString, '%s', g_Config.sGameDiaMond); //20080617
                          szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                          SysMsg(szString, c_Blue, t_Say);
                        end;
{$IF M2Version <> 2}
                      end else
                        if (CompareText(Trim(ItemName), '内功') = 0) or (CompareText(Trim(ItemName), '内功(大量)') = 0) or (CompareText(Trim(ItemName), '内功(海量)') = 0) then begin //内功经验 20100413
                          if m_boTrainingNG then begin
                            GetNGExp(ItemNum, 1); //取得内功经验
                            if not PlugOfCheckCanItem(5, Trim(ItemName), False, ItemNum, 0) then begin //禁止物品规则(没有设置全F提示的物品)
                              szString := AnsiReplaceText(g_sBoxsItemHintMsg1, '%name', m_sCharName);
                              szString := AnsiReplaceText(szString, '%s', '内功经验');
                              szString := AnsiReplaceText(szString, '%d', IntToStr(ItemNum));
                              SysMsg(szString, c_Blue, t_Say);
                            end;
                          end;
{$IFEND}
                        end;
              end;
            end;
          except
            on E: Exception do begin
              MainOutMessage(format('{%s} TPlayObject.ClientGetFree9YearsBoxsItem', [g_sExceptionVer]));
            end;
          end;
        finally
          m_boGivePlayItme := False; //给玩家物品
        end;
      end;
    end;
    SendMsg(Self, RM_GET9YEARSBOXSITEM_OK, 0, 0, 0, 0, ''); //九周年宝箱取物品成功
    n_OpenBoxTpye := 0; //打开宝箱的类型 0-不可填充 1-可填充 2-九周年度
    m_OpenBoxMakeID := 0; //打开箱子时，没钥匙时，记录ID
    m_boCanRotation := False; //是否可以转动宝箱
    n_KeyAnicount := 0; //钥匙标实
    n_OpenBoxCount := 0; //转动宝箱的次数
    m_boGivePlayItme := False; //给玩家物品
    m_boNoCanRotation := False; //用于标识提示用户无同类宝箱
    n_9YearBoxsID := 0;
    n_9YearUpdateCount := 0; //更换物品次数
    m_boFree9YearsBox := False; //是否取得免费奖励20格箱子
    ClientCloseBoxs(); //清空个人箱子列表资源,关闭箱子
  end;
end;
//开启新天赐(检查是否天赐)

procedure TPlayObject.ClientOpenNew9YearsBoxs();
var
  I, KeyMakeIndex, ItemNum, K, nBoxTpye, nBoxsID, nAnicount, MakeIndex: Integer;
  UserItem: pTUserItem;
  StdItemKey: pTStdItem;
  boIsBoxItem, boKeyOK: Boolean;
begin
  if m_boOpenBox then Exit; //如果有宝箱正在操作,则退出
  KeyMakeIndex := 0;
  boIsBoxItem := False;
  if m_ItemList.Count > 0 then begin //检查物品是否是天赐宝箱类型
    for I := m_ItemList.Count - 1 downto 0 do begin
      if m_ItemList.Count <= 0 then Break;
      UserItem := m_ItemList.Items[I];
      if UserItem = nil then Continue;
      StdItemKey := UserEngine.GetStdItem(UserItem.wIndex);
      if (StdItemKey <> nil) then begin
        if (StdItemKey.StdMode = 48) and (StdItemKey.Reserved = 2) then begin //天赐
          nBoxTpye := StdItemKey.Reserved;
          nBoxsID := StdItemKey.Source;
          nAnicount := StdItemKey.AniCount;
          MakeIndex := UserItem.MakeIndex;
          boIsBoxItem := True;
          Break;
        end;
      end;
    end; //for
  end;
  if boIsBoxItem and (n_OpenBoxCount = 0) then begin
    ItemNum := 0;
    K := 0;
    boKeyOK := False;
    ItemNum := g_Config.nFirstOpen9Years; //一次可以得到钥匙数
    for I := m_ItemList.Count - 1 downto 0 do begin //检查是否有钥匙
      if m_ItemList.Count <= 0 then Break;
      UserItem := m_ItemList.Items[I];
      if UserItem = nil then Continue;
      StdItemKey := UserEngine.GetStdItem(UserItem.wIndex);
      if (StdItemKey <> nil) then begin
        if (StdItemKey.StdMode = 49) and (StdItemKey.Shape = nAnicount) then begin //找到对应的钥匙
          Inc(K);
          if K >= ItemNum then begin
            boKeyOK := True;
            Break;
          end;
        end;
      end;
    end; //for
    m_boOpenNew9YearBox := True;
    if boKeyOK then begin //包裹有足够数的钥匙，直接打开箱子
      n_KeyAnicount := nAnicount; //钥匙标实
      ClientSend9YearsBoxItem(MakeIndex, nBoxsID, nBoxTpye, n_KeyAnicount, g_Config.nFirstOpen9Years); //删除钥匙及箱子，并发送箱子物品
    end else begin //提示玩家购买对应的钥匙
      StdItemKey := UserEngine.GetBoxKeyItem(nAnicount);
      if (StdItemKey <> nil) then begin //提示玩家购买， 取钥匙名字，及元宝数
        if m_nGameGold > 0 then begin //检查玩家元宝是否为0
          m_OpenBoxMakeID := MakeIndex; //打开箱子时，没钥匙时，记录ID
          n_KeyAnicount := nAnicount; //钥匙标实
          n_9YearBoxsID := nBoxsID;
          SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 4, 0, Format('您需要 %s 才能开启此天赐，是否花费%d%s从商城购买%s把\%s？(%s商城定价:%d%s)', [StdItemKey.Name, Round(StdItemKey.Reserved * g_Config.nFirstOpen9Years), g_Config.sGameGoldName, MoneyToCharacter(g_Config.nFirstOpen9Years, True), StdItemKey.Name, StdItemKey.Name, Round(StdItemKey.Reserved * g_Config.nFirstOpen9Years), g_Config.sGameGoldName]));
        end else begin
          SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, Format('您需要 %s 才能开启此天赐。', [StdItemKey.Name]));
        end;
      end;
    end;
  end else SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '您没有天赐。');
end;
//----------------------------------------------------------------------------
//更新角色的动态密钥(防WPE)

procedure TPlayObject.UpdateSendMsgCount();
begin
  try //20100412 增加异常保护
    if not m_boGhost then begin
      //SendDefMessage(SM_UPSENDMSGCOUNT, Random(10000), m_nSendMsgCount, Random(10000), Random(10000), '');
      m_DefMsg := MakeDefaultMsg(SM_UPSENDMSGCOUNT, Random(10000), m_nSendMsgCount, Random(10000), Random(10000), Random(10000));
      with m_DefMsg do
        nSessionID := (Param shr (Tag mod 7)) or (Param shl (Series mod 6));
      m_nSendMsgCount := m_DefMsg.nSessionID  mod 10000;
      SendSocket(@m_DefMsg, '');
    end;
  except
  end;
end;

{$IF HEROVERSION = 1}
//取回英雄 20080514

procedure TPlayObject.ClientGETHERO(sHeroName: string; nHeroTpye: Byte);
begin
  if sHeroName <> '' then begin
    m_sHeroCharName := sHeroName;
    n_myHeroTpye := nHeroTpye; //20080515 英雄的类型
    case n_myHeroTpye of
      0: m_boHasHero := True;
      1: m_boHasHeroTwo := True;
    end;
    if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(self, '@GetHeroOk', False, False);
  end else begin
    if g_FunctionNPC <> nil then
      g_FunctionNPC.GotoLable(self, '@GetHeroBak', False, False);
  end;
end;
{$IFEND}
//请酒 20080515

procedure TPlayObject.ClientPlayDrinkItem(NPC: TObject; nItemIdx: Integer; sMsg: string);
var
  Merchant: TMerchant;
  I: Integer;
  UserItem: pTUserItem;
  bo19: Boolean;
  StdItem: pTStdItem;
  sUserItemName: string;
begin
  bo19 := False;
  Merchant := UserEngine.FindMerchant(NPC);
  if (Merchant <> nil) and (Merchant.m_boPlayDrink) then begin //请酒斗酒NPC
    //折分物品名称(信件物品的名称后面加了使用次数)
    if Pos(' ', sMsg) >= 0 then GetValidStr3(sMsg, sMsg, [' ']);
    for I := m_ItemList.Count - 1 downto 0 do begin
      if m_ItemList.Count <= 0 then Break;
      UserItem := m_ItemList.Items[I];
      if UserItem.MakeIndex = nItemIdx then begin
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

        if CompareText(sUserItemName, sMsg) = 0 then begin
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem.StdMode = 60) and (StdItem.Shape = 0) then begin //是烧酒
            m_ItemList.Delete(I); //删除物品
            bo19 := True;
          end;
        end;
        Break;
      end;
    end;
  end;
  if bo19 then begin
    SendDefMessage(SM_USERPLAYDRINK_OK, 0, 0, 0, 0, '');
    if Merchant <> nil then
      Merchant.GotoLable(self, '~PlayDrink_Game', False, False);
  end else SendDefMessage(SM_USERPLAYDRINK_FAIL, 0, 0, 0, 0, '');
end;

//请酒信息跳转 20080515

procedure TPlayObject.ClientPlayDrinkLable(nParam1: Integer; sMsg: string);
var
  NPC: TNormNpc;
  sLabel: string;
begin
  if m_boDeath or m_boGhost then Exit;
  NPC := UserEngine.FindMerchant(TObject(nParam1));
  if NPC = nil then NPC := UserEngine.FindNPC(TObject(nParam1));
  if NPC = nil then Exit;
  if (sMsg <> '') and (sMsg[1] = '@') then begin
    GetValidStr3(sMsg, sLabel, [#13]);
    NPC.GotoLable(self, sLabel, False, False);
  end;
end;
//比较NPC与玩家出码数,并判断输赢 20080516
//码值:0-石 1-剪刀 2-布  nCode 0-赢  1-输  2-平

procedure TPlayObject.ClientPlayDrinkToDrink(nParam1: Integer; nPlayNum: Byte);
var
  nNpcNum, nCode: Byte;
  NPC: TNormNpc;
begin
  nCode := 3; //猜码结果
  Randomize(); //随机种子
  nNpcNum := Random(3); //随机取NPC出码值
  case nPlayNum of
    0: begin
        case nNpcNum of
          0: nCode := 2; //平
          1: nCode := 0; //输
          2: nCode := 1; //赢
        end;
      end;
    1: begin
        case nNpcNum of
          0: nCode := 1; //输
          1: nCode := 2; //平
          2: nCode := 0; //赢
        end;
      end;
    2: begin
        case nNpcNum of
          0: nCode := 0; //赢
          1: nCode := 1; //输
          2: nCode := 2; //平
        end;
      end;
  end; //case nPlayNum of
  if {nCode in [0..2]}(nCode < 3) then begin //有了结果,发消息给客户端
    NPC := UserEngine.FindMerchant(TObject(nParam1));
    if NPC = nil then NPC := UserEngine.FindNPC(TObject(nParam1));
    case nCode of
      0: NPC.GotoLable(self, '~PlayDrink_PlayWil', False, False); //玩家赢
      1: NPC.GotoLable(self, '~PlayDrink_NpcWil', False, False); //NPC赢
    end;
    SendMsg(Self, RM_PlayDrinkToDrink, 0, nPlayNum, nNpcNum, nCode, '');
  end;
end;
//喝酒并增加醉酒值 20080517
//参数:nPlayNum--谁喝酒(0-玩家喝 1-NPC喝)  nCode--谁赢(0-NPC 1-玩家)
//如果NPC胜,则随机选择谁喝酒,玩家胜,则以玩家的选择来决定

procedure TPlayObject.ClientDrinkUpdateValue(nParam1: Integer; nPlayNum, nCode: Byte);
var
  NPC: TNormNpc;
  boDrinkLoss: Boolean;
begin
  if n_DrinkCount < 7 then begin
    boDrinkLoss := True;
    NPC := UserEngine.FindMerchant(TObject(nParam1));
    if NPC = nil then NPC := UserEngine.FindNPC(TObject(nParam1));
    Inc(n_DrinkCount); //累积喝酒次数,即喝了几瓶酒
    Randomize(); //随机种子
    case nCode of
      0: begin //NPC胜
          case Random(2) of
            0: begin //玩家喝
                n_DrinkValue[1] := n_DrinkValue[1] + Random(25) + 8;
                if n_DrinkValue[1] > 100 then n_DrinkValue[1] := 100;
                nPlayNum := 0;
                NPC.GotoLable(self, '~PlayDrink_NpcToSelf', False, False);
              end;
            1: begin //NPC喝
                n_DrinkValue[0] := n_DrinkValue[0] + Random(25) + 8;
                if n_DrinkValue[0] > 100 then n_DrinkValue[0] := 100;
                nPlayNum := 1;
                NPC.GotoLable(self, '~PlayDrink_NpcToNpc', False, False);
              end;
          end;
        end;
      1: begin //玩家胜
          case nPlayNum of
            0: begin //玩家喝
                n_DrinkValue[1] := n_DrinkValue[1] + Random(30) + 10;
                if n_DrinkValue[1] > 100 then n_DrinkValue[1] := 100;
                NPC.GotoLable(self, '~PlayDrink_SelfToSelf', False, False);
              end;
            1: begin //NPC喝
                n_DrinkValue[0] := n_DrinkValue[0] + Random(30) + 10;
                if n_DrinkValue[0] > 100 then n_DrinkValue[0] := 100;
                NPC.GotoLable(self, '~PlayDrink_SelfToNpc', False, False);
              end;
          end;
        end;
    end; //case nCode of

    if n_DrinkValue[0] >= 92 then begin //NPC喝醉,斗酒失败
      NPC.GotoLable(self, '~PlayDrink_Npc_Drunk', False, False);
      boDrinkLoss := False;
    end else
      if n_DrinkValue[1] >= 92 then begin //玩家喝醉
        NPC.GotoLable(self, '~PlayDrink_Self_Drunk', False, False);
        boDrinkLoss := False;
      end else
        if n_DrinkCount = 6 then begin //喝完酒,判断结果
          if n_DrinkValue[0] > n_DrinkValue[1] then //玩家斗酒胜
            NPC.GotoLable(self, '~PlayDrink_Npc_Loss', False, False)
          else NPC.GotoLable(self, '~PlayDrink_Self_Loss', False, False);
          boDrinkLoss := False;
        end;

    if boDrinkLoss then //参数0-可以继续喝 1-斗酒结束
      SendMsg(Self, RM_DrinkUpdateValue, 0, nPlayNum, n_DrinkValue[0], n_DrinkValue[1], '')
    else SendMsg(Self, RM_DrinkUpdateValue, 1, nPlayNum, n_DrinkValue[0], n_DrinkValue[1], '');
  end;
end;
//请酒 20080517
//判断放上的两物品是不是烧酒,如果是则删除物品,触发脚本段

procedure TPlayObject.ClientPlayDrink(sMsg: string);
var
  Merchant: TMerchant;
  I: Integer;
  UserItem: pTUserItem;
  bo19, bo20: Boolean;
  StdItem: pTStdItem;
  nItemIdx, nItemIdx1, NPCID: Integer;
  Str, Str1: string;
begin
  NPCID := 0;
  nItemIdx := 0;
  nItemIdx1 := 0;
  bo19 := False;
  bo20 := False;
  if sMsg <> '' then begin
    sMsg := GetValidStr3(sMsg, Str, ['/', #9]);
    sMsg := GetValidStr3(sMsg, Str1, ['/', #9]);
    NPCID := Str_ToInt(Str, 0);
    nItemIdx := Str_ToInt(Str1, 0);
    nItemIdx1 := Str_ToInt(sMsg, 0);
  end;

  if (NPCID <> 0) and (nItemIdx <> 0) and (nItemIdx1 <> 0) then begin
    Merchant := UserEngine.FindMerchant(TObject(NPCID));
    if (Merchant <> nil) and (Merchant.m_boPlayDrink) then begin //请酒NPC
      for I := m_ItemList.Count - 1 downto 0 do begin
        if m_ItemList.Count <= 0 then Break;
        UserItem := m_ItemList.Items[I];
        if UserItem.MakeIndex = nItemIdx then begin
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem.StdMode = 60) and (StdItem.Shape = 0) then begin //是烧酒
            bo19 := True;
          end;
        end else
          if UserItem.MakeIndex = nItemIdx1 then begin
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if (StdItem.StdMode = 60) and (StdItem.Shape = 0) then begin //是烧酒
              bo20 := True;
            end;
          end;
        if bo19 and bo20 then Break;
      end; //for I := m_ItemList.Count - 1 downto 0 do begin
    end; //if (Merchant <> nil) and (Merchant.m_boPlayDrink) then begin

    if bo19 and bo20 then begin
      for I := m_ItemList.Count - 1 downto 0 do begin //删除物品
        if m_ItemList.Count <= 0 then Break;
        UserItem := m_ItemList.Items[I];
        if (UserItem.MakeIndex = nItemIdx) or (UserItem.MakeIndex = nItemIdx1) then m_ItemList.Delete(I);
      end;
      SendDefMessage(SM_USERPLAYDRINKITEM_OK, 0, 0, 0, 0, '');
      m_boPlayDrink := True; //是否请过酒 T-请过酒 20080518
      if Merchant <> nil then Merchant.GotoLable(self, '~PlayDrink_Ok', False, False);
    end else begin
      SendDefMessage(SM_USERPLAYDRINKITEM_FAIL, 0, 0, 0, 0, '');
    end;
  end;
end;
//------------------------------------------------------------------------------
//读取师徒文件 20080530

function TPlayObject.GetMasterNoList: Boolean;
var
  I: Integer;
  LoadList: TStringList;
  sFileName: string;
  s01, s02, s03: string;
  TMasterList: pTMasterList;
begin
  Result := False;
  try
    sFileName := g_Config.sEnvirDir + 'MasterNo';
    if not DirectoryExists(sFileName) then CreateDir(sFileName); //目录不存在,则创建
    if m_sMasterName <> '' then begin //有师傅,取排名
      sFileName := sFileName + '\' + m_sMasterName + '.txt';
      LoadList := TStringList.Create;
      try
        if FileExists(sFileName) then begin
          LoadList.LoadFromFile(sFileName);
          if LoadList.Count > 0 then begin //20080629
            for I := 0 to LoadList.Count - 1 do begin
              s01 := Trim(LoadList.Strings[I]);
              if (s01 <> '') and (s01[1] <> ';') then begin
                s01 := GetValidStr3(s01, s02, [' ', #9]); //徒弟名
                s01 := GetValidStr3(s01, s03, [' ', #9]); //排行
                if s02 <> '' then begin
                  if CompareText(m_sCharName, s02) = 0 then begin
                    m_nMasterNo := Str_ToInt(s03, 0);
                    Result := True;
                    Break;
                  end;
                end;
              end; //if (s01 <> '') and (s01[1] <> ';') then begin
            end; //for
          end;
        end; //if FileExists(sFileName)
      finally
        LoadList.Free;
      end;
    end else
      if m_boMaster then begin //有徒弟,取列表内容
        sFileName := sFileName + '\' + m_sCharName + '.txt';
        LoadList := TStringList.Create;
        try
          if FileExists(sFileName) then begin
            LoadList.LoadFromFile(sFileName);
            if LoadList.Count > 0 then begin //20080629
              for I := 0 to LoadList.Count - 1 do begin
                s01 := Trim(LoadList.Strings[I]);
                if (s01 <> '') and (s01[1] <> ';') then begin
                  s01 := GetValidStr3(s01, s02, [' ', #9]); //徒弟名
                  s01 := GetValidStr3(s01, s03, [' ', #9]); //排行
                  if s02 <> '' then begin
                    New(TMasterList);
                    TMasterList.ID := StrToInt(s03);
                    TMasterList.sChrName := s02;
                    m_MasterNoList.AddObject(s03, TObject(TMasterList));
                  end;
                end; //if (s01 <> '') and (s01[1] <> ';') then begin
              end; //for
            end;
            Result := True;
          end; //if FileExists(sFileName)
        finally
          LoadList.Free;
        end;
      end;
  except   
    MainOutMessage(format('{%s} TPlayObject.GetMasterNoList', [g_sExceptionVer]));
  end;
end;

//保存师徒文件 20080530

procedure TPlayObject.SaveMasterNoList();
var
  I: Integer;
  SaveList: TStringList;
  sFileName: string;
  TMasterList: pTMasterList;
begin
  try
    sFileName := g_Config.sEnvirDir + 'MasterNo';
    if not DirectoryExists(sFileName) then CreateDir(sFileName); //目录不存在,则创建
    if m_boMaster then begin //有徒弟才能保存列表
      sFileName := sFileName + '\' + m_sCharName + '.txt';
      SaveList := TStringList.Create();
      try
        MasterNoListQuickSort(m_MasterNoList, True); //排序
        if m_MasterNoList.Count > 0 then begin //20080629
          for I := 0 to m_MasterNoList.Count - 1 do begin
            TMasterList := PTMasterList(m_MasterNoList.Objects[I]);
            if TMasterList <> nil then begin
              SaveList.Add(TMasterList.sChrName + ' ' + inttostr(TMasterList.ID));
            end;
          end;
        end;
        SaveList.SaveToFile(sFileName);
      finally
        SaveList.Free;
      end;
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.SaveMasterNoList', [g_sExceptionVer]));
  end;
end;

//收徒 20080530

procedure TPlayObject.AddMaster(MasterName: string);
var
  MasterList: pTMasterList;
begin
  new(MasterList);
  MasterList.sChrName := MasterName;
  MasterList.ID := m_MasterNoList.Count + 1;
  m_MasterNoList.AddObject(inttostr(MasterList.ID), TObject(MasterList));
  SaveMasterNoList(); //保存师徒文件 20080530
end;

//出师 20080530

procedure TPlayObject.DelMaster(MasterName: string);
var
  I: integer;
  TMasterList: pTMasterList;
begin
  for I := m_MasterNoList.Count - 1 downto 0 do begin
    if m_MasterNoList.Count <= 0 then Break; //20080917
    TMasterList := PTMasterList(m_MasterNoList.Objects[I]);
    if TMasterList <> nil then begin
      if CompareText(Trim(TMasterList.sChrName), Trim(MasterName)) = 0 then begin
        Dispose(TMasterList);
        m_MasterNoList.Delete(I);
        break;
      end;
    end;
  end;
  SaveMasterNoList(); //保存师徒文件 20080530
end;
//检查输入的名字是否为自己的徒弟 20090208

function TPlayObject.IsMyApprentice(sName: string): Boolean;
var
  I: integer;
  TMasterList: pTMasterList;
begin
  Result := False;
  for I := m_MasterNoList.Count - 1 downto 0 do begin
    if m_MasterNoList.Count <= 0 then Break;
    TMasterList := PTMasterList(m_MasterNoList.Objects[I]);
    if TMasterList <> nil then begin
      if CompareText(Trim(TMasterList.sChrName), Trim(sName)) = 0 then begin
        Result := True;
        break;
      end;
    end;
  end;
end;
//取徒弟名字 20090208

function TPlayObject.GetApprenticeName(nMasterNo: Integer): string;
var
  TMasterList: pTMasterList;
begin
  Result := '';
  try
    if (nMasterNo > 0) and (m_MasterNoList.Count > 0) and m_boMaster then begin
      if nMasterNo <= m_MasterNoList.Count then begin
        TMasterList := PTMasterList(m_MasterNoList.Objects[nMasterNo - 1]);
        if TMasterList <> nil then Result := TMasterList.sChrName;
      end;
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.GetApprenticeName', [g_sExceptionVer]));
  end;
end;
//师徒数据排序 20080530 (用于徒弟出师,收徒后进行排名的排序)

procedure TPlayObject.MasterNoListQuickSort(sList: TStringList; Order: Boolean);
  procedure QuickSortStrListCase(List: TStringList; l, r: Integer);
  var
    I, j: Integer;
    p: string;
  begin
    if List.Count <= 0 then Exit;
    repeat
      I := l;
      j := r;
      p := List[(l + r) shr 1];
      repeat
        if Order then begin //升序
          while CompareStr(List[I], p) < 0 do Inc(I);
          while CompareStr(List[j], p) > 0 do Dec(j);
        end else begin //降序
          while CompareStr(p, List[I]) < 0 do Inc(I);
          while CompareStr(p, List[j]) > 0 do Dec(j);
        end;
        if I <= j then begin
          List.Exchange(I, j);
          Inc(I);
          Dec(j);
        end;
      until I > j;
      if l < j then QuickSortStrListCase(List, l, j);
      l := I;
    until I >= r;
  end;
  procedure AddList(TempList: TStringList; slen: string; s: string; AObject: TObject);
  var
    I: Integer;
    List: TStringList;
    boFound: Boolean;
  begin
    boFound := False;
    if TempList.Count > 0 then begin
      for I := 0 to TempList.Count - 1 do begin
        if CompareText(TempList.Strings[I], slen) = 0 then begin
          List := TStringList(TempList.Objects[I]);
          List.AddObject(s, AObject);
          boFound := True;
          Break;
        end;
      end;
    end;
    if not boFound then begin
      List := TStringList.Create;
      List.AddObject(s, AObject);
      TempList.AddObject(slen, List);
    end;
  end;
var
  TempList: TStringList;
  List: TStringList;
  I: Integer;
  nLen: Integer;
  TMasterList: pTMasterList;
begin
  TempList := TStringList.Create;
  try
    if sList.Count > 0 then begin //20080629
      for I := 0 to sList.Count - 1 do begin
        nLen := Length(sList.Strings[I]);
        AddList(TempList, IntToStr(nLen), Inttostr(I + 1) {sList.Strings[I]}, sList.Objects[I]);
      end;
    end;
    QuickSortStrListCase(TempList, 0, TempList.Count - 1);
    sList.Clear;
    if TempList.Count > 0 then begin //20080629
      for I := 0 to TempList.Count - 1 do begin
        List := TStringList(TempList.Objects[I]);
        QuickSortStrListCase(List, 0, List.Count - 1);
        sList.AddStrings(List);
        List.Free;
      end;
    end;
  finally
    TempList.Free;
  end;
  if m_MasterNoList.Count > 0 then begin //20080629
    for I := 0 to m_MasterNoList.Count - 1 do begin
      TMasterList := PTMasterList(m_MasterNoList.Objects[I]);
      TMasterList.ID := I + 1;
    end;
  end;
end;
//--------------------------酿酒系统-------------------------------------------
//客户端开始酿酒  nCode酿酒种类 0-普通 1-药酒  nParam1-NPC标识

procedure TPlayObject.ClientPlayMakeWine(nCode: Byte; sMsg: string);
  function GetRandomRange(nCount, nRate: Integer): Integer;
  var
    I: Integer;
  begin
    Result := 0;
    if nCount <= 0 then Exit;
    for I := 0 to nCount - 1 do
      if Random(nRate) = 0 then Inc(Result);
  end;
var
  nItemId, nItemId1, nItemId2, nItemId3, nItemId4, nItemId5, nItemId6: Integer;
  Str, Str1, Str2, Str3, Str4, Str5, Str6: string;
  StdItem, StdItem1, StdItem2, StdItem3, StdItem4, StdItem5, StdItem6: pTStdItem;
  UserItem: pTUserItem;
  I, nC: Integer;
  boMakeWine, boMakeWineOK: Boolean;
  Check: Byte;
begin
  boMakeWine := False;
  boMakeWineOK := False;
  Check := 0;
  try
    if (nCode in [0, 1]) and (sMsg <> '') and (not m_boMakeWine) then begin
      case nCode of
        0: begin //普通酒
            sMsg := GetValidStr3(sMsg, Str, ['/', #9]);
            sMsg := GetValidStr3(sMsg, Str1, ['/', #9]);
            sMsg := GetValidStr3(sMsg, Str2, ['/', #9]);
            sMsg := GetValidStr3(sMsg, Str3, ['/', #9]);
            sMsg := GetValidStr3(sMsg, Str4, ['/', #9]);
            sMsg := GetValidStr3(sMsg, Str5, ['/', #9]);
            sMsg := GetValidStr3(sMsg, Str6, ['/', #9]);
            nItemId := Str_ToInt(Str, 0); //主材料
            nItemId1 := Str_ToInt(Str1, 0); //酒曲
            nItemId2 := Str_ToInt(Str2, 0); //水
            nItemId3 := Str_ToInt(Str3, 0); //酒坛
            nItemId4 := Str_ToInt(Str4, 0); //辅助材料1
            nItemId5 := Str_ToInt(Str5, 0); //辅助材料2
            nItemId6 := Str_ToInt(Str6, 0); //辅助材料3
            Check := 1;
            if m_ItemList.Count > 0 then begin //20080628
              for I := 0 to m_ItemList.Count - 1 do begin
                Check := 2;
                UserItem := m_ItemList.Items[I];
                Check := 3;
                if UserItem <> nil then begin
                  if UserItem.MakeIndex = nItemId then StdItem := UserEngine.GetStdItem(UserItem.wIndex)
                  else if UserItem.MakeIndex = nItemId1 then StdItem1 := UserEngine.GetStdItem(UserItem.wIndex)
                  else if UserItem.MakeIndex = nItemId2 then StdItem2 := UserEngine.GetStdItem(UserItem.wIndex)
                  else if UserItem.MakeIndex = nItemId3 then StdItem3 := UserEngine.GetStdItem(UserItem.wIndex)
                  else if UserItem.MakeIndex = nItemId4 then StdItem4 := UserEngine.GetStdItem(UserItem.wIndex)
                  else if UserItem.MakeIndex = nItemId5 then StdItem5 := UserEngine.GetStdItem(UserItem.wIndex)
                  else if UserItem.MakeIndex = nItemId6 then StdItem6 := UserEngine.GetStdItem(UserItem.wIndex);
                end;
              end; //for I := m_ItemList.Count - 1 downto 0 do begin
            end;
            Check := 4;
            if (StdItem <> nil) and (StdItem2 <> nil) and (StdItem3 <> nil) and (StdItem4 <> nil) and (StdItem5 <> nil) and (StdItem6 <> nil) then begin
              Check := 5;
              if (StdItem.StdMode = 8) and (StdItem2.StdMode = 9) and ((StdItem3.StdMode = 12) and (StdItem3.Shape = 0)) and
                (StdItem4.StdMode = 8) and (StdItem5.StdMode = 8) and (StdItem6.StdMode = 8) then begin
                n_MakeWineQuality := StdItem.AC; //主料的品质值
               { if StdItem4.Source = 1 then n_MakeWineQuality:= n_MakeWineQuality + 1;//主料为精制材料
                if StdItem5.Source = 1 then n_MakeWineQuality:= n_MakeWineQuality + 1;//主料为精制材料
                if StdItem6.Source = 1 then n_MakeWineQuality:= n_MakeWineQuality + 1;//主料为精制材料}
                if StdItem2.Shape = 1 then n_MakeWineQuality := n_MakeWineQuality + 1; //使用泉水品质+1
                Check := 6;
                m_boMakeWine := True; //是否酿酒
                m_MakeWineTime := g_Config.nMakeWineTime; //酿酒等待的时间
                n_MakeWineItmeType := StdItem.AniCount; //酿酒后,应该可以得到酒的类型
                n_MakeWineType := 1; //酿酒的类型 1-普通酒 2-药酒
                Randomize(); //随机种子
                if StdItem1 <> nil then begin //判断酒曲是否是与主材料对应,对应则加品质+1
                  if (StdItem1.Shape = StdItem.AniCount) and (Random(3) = 0) then n_MakeWineQuality := n_MakeWineQuality + 1;
                end;
                if StdItem.Source = 1 then begin //精制材料可以得到酒的品质
                  nC := GetRandomRange(3, 5);
                  n_MakeWineQuality := n_MakeWineQuality + nC;
                  if n_MakeWineQuality > 10 then n_MakeWineQuality := 10;
                end else begin //普通材料
                  nC := GetRandomRange(3, 4);
                  n_MakeWineQuality := n_MakeWineQuality + nC; //可以得到酒的品质
                  if n_MakeWineQuality > 5 then n_MakeWineQuality := 5;
                end;
                if n_MakeWineQuality = 0 then n_MakeWineQuality := 1;

                n_MakeWineAlcohol := StdItem.Reserved + StdItem4.Reserved + Random(StdItem5.Reserved) + Random(StdItem6.Reserved); //可以得到酒的酒精度
                if n_MakeWineAlcohol > 100 then n_MakeWineAlcohol := Random(30) + 35;
                boMakeWine := True;
                Check := 7;
              end;
            end;
            if boMakeWine then begin
              for I := m_ItemList.Count - 1 downto 0 do begin
                if m_ItemList.Count <= 0 then Break;
                Check := 8;
                UserItem := m_ItemList.Items[I];
                Check := 9;
                if UserItem <> nil then begin
                  if (UserItem.MakeIndex = nItemId) or (UserItem.MakeIndex = nItemId1) or
                    (UserItem.MakeIndex = nItemId2) or (UserItem.MakeIndex = nItemId3) or
                    (UserItem.MakeIndex = nItemId4) or (UserItem.MakeIndex = nItemId5) or
                    (UserItem.MakeIndex = nItemId6) then begin
                    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                    if StdItem <> nil then begin
                      Check := 10;
                      SendDelItems(UserItem);
                      Check := 12;
                      m_ItemList.Delete(I);
                      Check := 11;
                      Dispose(UserItem);
                    end;
                  end;
                end;
              end;
            end;
          end;
        1: begin //药酒
            sMsg := GetValidStr3(sMsg, Str, ['/', #9]);
            sMsg := GetValidStr3(sMsg, Str1, ['/', #9]);
            nItemId := Str_ToInt(Str, 0); //药材
            nItemId1 := Str_ToInt(Str1, 0); //酒
            nItemId2 := Str_ToInt(sMsg, 0); //酒瓶
            if m_ItemList.Count > 0 then begin //20080628
              for I := 0 to m_ItemList.Count - 1 do begin
                UserItem := m_ItemList.Items[I];
                if UserItem <> nil then begin
                  if UserItem.MakeIndex = nItemId then StdItem := UserEngine.GetStdItem(UserItem.wIndex)
                  else if UserItem.MakeIndex = nItemId1 then begin
                    StdItem1 := UserEngine.GetStdItem(UserItem.wIndex);
                    if (StdItem1.StdMode = 60) and (StdItem1.Shape <> 0) then begin //普通酒
                      if (UserItem.btValue[0] > 5) and (UserItem.Dura = UserItem.DuraMax) then begin //普通酒品质达6以上,并且没喝过,才做酿造药酒
                        boMakeWineOK := True;
                        n_MakeWineQuality := UserItem.btValue[0]; //可以得到酒的品质
                        n_MakeWineAlcohol := UserItem.btValue[1]; //可以得到酒的酒精度
                        if n_MakeWineAlcohol > 100 then n_MakeWineAlcohol := Random(30) + 30; //20080827 增加
                      end;
                    end;
                  end
                  else if UserItem.MakeIndex = nItemId2 then StdItem2 := UserEngine.GetStdItem(UserItem.wIndex);
                end;
              end; //for
            end;
            if (StdItem <> nil) and (StdItem1 <> nil) and (StdItem2 <> nil) then begin
              if (StdItem.StdMode = 14) and boMakeWineOK and ((StdItem2.StdMode = 12) and (StdItem2.Shape = 1)) then begin
                m_boMakeWine := True; //是否酿酒
                m_MakeWineTime := g_Config.nMakeWineTime1; //酿药酒等待的时间
                n_MakeWineItmeType := StdItem.AniCount; //酿酒后,应该可以得到酒的类型
                n_MakeWineType := 2; //酿酒的类型 1-普通酒 2-药酒
                boMakeWine := True;
              end;
            end; //if (StdItem <> nil) and (StdItem1 <> nil) and (StdItem2 <> nil) then begin
            if not boMakeWine then begin
              n_MakeWineQuality := 0; //可以得到酒的品质
              n_MakeWineAlcohol := 0; //可以得到酒的酒精度
            end else begin
              for I := m_ItemList.Count - 1 downto 0 do begin
                if m_ItemList.Count <= 0 then Break;
                Check := 18;
                UserItem := m_ItemList.Items[I];
                Check := 19;
                if UserItem <> nil then begin
                  if (UserItem.MakeIndex = nItemId) or (UserItem.MakeIndex = nItemId1) or
                    (UserItem.MakeIndex = nItemId2) then begin
                    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                    if StdItem <> nil then begin
                      Check := 20;
                      SendDelItems(UserItem);
                      Check := 22;
                      m_ItemList.Delete(I);
                      Check := 21;
                      Dispose(UserItem);
                    end;
                  end;
                end;
              end;
            end;
          end;
      end;
    end;

    //材料全对应上后,提示玩家开始酿造,需等待一会,并发个消息给客户端把窗口关掉
    if boMakeWine then begin //酿造成功
      SendMsg(Self, RM_MAKEWINE_OK, 0, nCode, 0, 0, ''); //酿造成功
      if g_FunctionNPC <> nil then begin
        g_FunctionNPC.GotoLable(Self, '@BeginMakeWine', False, False); //酿造成功
      end;
    end else begin //酿酒失败
      SendMsg(Self, RM_MAKEWINE_FAIL, 0, nCode, 0, 0, ''); //酿造失败
      if m_boMakeWine then begin //已经有酒在酿中
        if g_FunctionNPC <> nil then begin
          g_FunctionNPC.GotoLable(Self, '@MakeWineFail', False, False); //酿造失败
        end;
      end else begin
        if g_FunctionNPC <> nil then begin
          g_FunctionNPC.GotoLable(Self, '@MakeWineFail1', False, False); //酿造失败
        end;
      end;
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientPlayMakeWine Code:%d', [g_sExceptionVer, Check]));
  end;
end;
//-----------------------------------------------------------------------------
//收集泉水 20080624      n_InFountainTime:= 0;//站在泉水眼的时间 20080624
//先判断玩家毒符位是否有泉水罐,然后判断是否在泉眼上,最后记时,到时间加泉水

procedure TPlayObject.PlayGatherFountain;
var
  StdItem: pTStdItem;
begin
  if (m_UseItems[U_BUJUK].wIndex > 0) and (m_UseItems[U_BUJUK].Dura <> m_UseItems[U_BUJUK].DuraMax) then begin
    StdItem := UserEngine.GetStdItem(m_UseItems[U_BUJUK].wIndex);
    if StdItem <> nil then begin
      if (StdItem.StdMode = 2) and (StdItem.AniCount = 21) and (StdItem.Reserved = 56) then begin //有泉水罐
        if g_EventManager.GetEvent(m_PEnvir, m_nCurrX, m_nCurrY, ET_FOUNTAIN) <> nil then begin //判断玩家是在泉眼上
          Inc(n_InFountainTime); //累积站在泉眼上的时间
          if n_InFountainTime >= g_Config.nInFountainTime then begin //达到累积时间,则增加泉水罐的持久
            Inc(m_UseItems[U_BUJUK].Dura, 100);
            if m_MyGuild <> nil then begin
              TGUild(m_MyGuild).boChanged := True;
              Inc(TGUild(m_MyGuild).m_nGuildFountain); //累积行会泉水 20080625
            end;
            if m_UseItems[U_BUJUK].Dura > m_UseItems[U_BUJUK].DuraMax then m_UseItems[U_BUJUK].Dura := m_UseItems[U_BUJUK].DuraMax;
            SendMsg(self, RM_DURACHANGE, U_BUJUK, m_UseItems[U_BUJUK].Dura, m_UseItems[U_BUJUK].DuraMax, 0, '');
            SendRefMsg(RM_MYSHOW, 10, 0, 0, 0, ''); //采集到泉水动画  20080624
            if (m_MyGuild <> nil) and (g_FunctionNPC <> nil) then g_FunctionNPC.GotoLable(self, '@GatherWater', False, False); //接泉水触发 20110225
            n_InFountainTime := 0;
          end;
        end else n_InFountainTime := 0;
      end;
    end;
  end else
    if n_InFountainTime <> 0 then n_InFountainTime := 0;
end;
//------------------------------挑战系统---------------------------------------
//发送删除挑战框中物品后,给客户端更新

procedure TPlayObject.SendDelChallengeItem(UserItem: pTUserItem);
var
  StdItem: pTStdItem;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  sUserItemName: string;
begin
  SendDefMessage(SM_CHALLENGEDELITEM_OK, 0, 0, 0, 0, '');
  if m_ChallengeCreat <> nil then begin
    if m_ChallengeCreat.m_nSoftVersionDateEx = 0 then begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
        CopyStdItemToOStdItem(StdItem, @OClientItem.s);
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then OClientItem.s.Name := sUserItemName;

        OClientItem.MakeIndex := UserItem.MakeIndex;
        OClientItem.Dura := UserItem.Dura;
        OClientItem.DuraMax := UserItem.DuraMax;
      end;
      m_DefMsg := MakeDefaultMsg(SM_CHALLENGEREMOTEDELITEM, Integer(Self), 0, 0, 1, 0);
      m_ChallengeCreat.SendSocket(@m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
    end else begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
        ClientItem.s := StdItem^;
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then ClientItem.s.Name := sUserItemName;
        if (UserItem.btValue[12] = 1) and (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) then ClientItem.s.Reserved1 := 1 //物品发光 20080223
        else ClientItem.s.Reserved1 := 0;
{$IF M2Version <> 2}
        if (StdItem.StdMode = 5) or (StdItem.StdMode = 6) then begin //武器暴击等级 20100708
          ClientItem.s.NeedIdentify := _MIN(High(Byte), UserItem.btValue[11] + UserItem.btValue[20]);
          if CheckItemSpiritMedia(UserItem) then begin
            ClientItem.Aura := UserItem.btValue[12];
            ClientItem.MaxAura := g_Config.nMaxAuraValue;
          end;
        end else begin
          if CheckItemSpiritMedia(UserItem) or ((StdItem.StdMode = 44) and (StdItem.shape = 253)) then begin
            ClientItem.Aura := UserItem.btValue[11];
            ClientItem.MaxAura := g_Config.nMaxAuraValue;
          end;
        end;
        if (StdItem.StdMode = 44) and (StdItem.shape = 255) then begin //神秘卷轴
          ClientItem.s.NeedIdentify := UserItem.btValue[0];
        end;
{$IFEND}
        if (StdItem.StdMode = 60) and (StdItem.shape <> 0) then begin //酒类,除烧酒外 20080622
          if UserItem.btValue[0] <> 0 then ClientItem.s.AC := UserItem.btValue[0]; //酒的品质
          if UserItem.btValue[1] <> 0 then ClientItem.s.MAC := UserItem.btValue[1]; //酒的酒精度
          if UserItem.btValue[3] > 0 then ClientItem.s.NeedLevel := UserItem.btValue[3] //酒的等级 20091117
          else ClientItem.s.NeedLevel := 0;
        end;

        ClientItem.MakeIndex := UserItem.MakeIndex;
        ClientItem.Dura := UserItem.Dura;
        ClientItem.DuraMax := UserItem.DuraMax;
        //Modified By TasNat at: 2012-04-12 09:28:18
        ClientItem.btAppraisalLevel :=   UserItem.btAppraisalLevel;
        ClientItem.btUnKnowValueCount := UserItem.btUnKnowValueCount;
        Move(UserItem.btAppraisalValue, ClientItem.btAppraisalValue, SizeOf(UserItem.btAppraisalValue));

        Move(UserItem.btUnKnowValue, ClientItem.btUnKnowValue, SizeOf(ClientItem.btUnKnowValue)); //20100822
        ClientItem.BindValue := UserItem.AddValue[0]; //20110622
        ClientItem.MaxDate := UserItem.MaxDate; //20110622
        if ClientItem.BindValue = 0 then begin //禁止交易,扔物品,显示绑定 20110626
          if (CheckItemValue(UserItem, 1) and CheckItemValue(UserItem, 0)) or
            (GetCheckItemList(0, StdItem.Name) and GetCheckItemList(1, StdItem.Name)) then
            ClientItem.BindValue := 3;
        end;
      end;
      m_DefMsg := MakeDefaultMsg(SM_CHALLENGEREMOTEDELITEM, Integer(Self), 0, 0, 1, 0);
      TPlayObject(m_ChallengeCreat).SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(ClientItem)));
    end;
    m_ChallengeCreat.m_ChallengeLastTick := GetTickCount();
    m_ChallengeLastTick := GetTickCount();
  end;
end;

//发送抵押的挑战物品

procedure TPlayObject.SendAddChallengeItem(UserItem: pTUserItem);
var
  StdItem: pTStdItem;
  StdItem80: TStdItem;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  sUserItemName: string;
begin
  SendDefMessage(SM_CHALLENGEADDITEM_OK, 0, 0, 0, 0, '');
  if m_ChallengeCreat <> nil then begin
    if m_ChallengeCreat.m_nSoftVersionDateEx = 0 then begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
        StdItem80 := StdItem^;
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          StdItem80.Name := sUserItemName;

        ItemUnit.GetItemAddValue(UserItem, StdItem80);
        CopyStdItemToOStdItem(@StdItem80, @OClientItem.s);
        OClientItem.MakeIndex := UserItem.MakeIndex;
        OClientItem.Dura := UserItem.Dura;
        OClientItem.DuraMax := UserItem.DuraMax;
        m_DefMsg := MakeDefaultMsg(SM_CHALLENGEREMOTEADDITEM, Integer(Self), 0, 0, 1, 0);
        m_ChallengeCreat.SendSocket(@m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
        m_ChallengeCreat.m_ChallengeLastTick := GetTickCount();
        m_ChallengeLastTick := GetTickCount();
      end;
    end else begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
        StdItem80 := StdItem^;
        ItemUnit.GetItemAddValue(UserItem, StdItem80);

        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then StdItem80.Name := sUserItemName;
        if (UserItem.btValue[12] = 1) and (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) then StdItem80.Reserved1 := 1 //物品发光 20080223
        else StdItem80.Reserved1 := 0;

        ClientItem.s := StdItem80;

        if (StdItem.StdMode = 60) and (StdItem.shape <> 0) then begin //酒类,除烧酒外 20080622
          if UserItem.btValue[0] <> 0 then ClientItem.s.AC := UserItem.btValue[0]; //酒的品质
          if UserItem.btValue[1] <> 0 then ClientItem.s.MAC := UserItem.btValue[1]; //酒的酒精度
          if UserItem.btValue[3] > 0 then ClientItem.s.NeedLevel := UserItem.btValue[3] //酒的等级 20091117
          else ClientItem.s.NeedLevel := 0;
        end;
        if (StdItem.StdMode = 17) and (StdItem.Weight > 0) then ClientItem.s.Weight := UserItem.Dura; //拆加物品的重量 20090816
{$IF M2Version <> 2}
        if (StdItem.StdMode = 5) or (StdItem.StdMode = 6) then begin //武器暴击等级 20100708
          ClientItem.s.NeedIdentify := _MIN(High(Byte), UserItem.btValue[11] + UserItem.btValue[20]);
          if CheckItemSpiritMedia(UserItem) then begin
            ClientItem.Aura := UserItem.btValue[12];
            ClientItem.MaxAura := g_Config.nMaxAuraValue;
          end;
        end else begin
          if CheckItemSpiritMedia(UserItem) or ((StdItem.StdMode = 44) and (StdItem.shape = 253)) then begin
            ClientItem.Aura := UserItem.btValue[11];
            ClientItem.MaxAura := g_Config.nMaxAuraValue;
          end;
        end;
        if (StdItem.StdMode = 44) and (StdItem.shape = 255) then begin //神秘卷轴
          ClientItem.s.NeedIdentify := UserItem.btValue[0];
        end;
{$IFEND}
        ClientItem.MakeIndex := UserItem.MakeIndex;
        ClientItem.Dura := UserItem.Dura;
        ClientItem.DuraMax := UserItem.DuraMax;
        ClientItem.BindValue := UserItem.AddValue[0]; //20110622
        ClientItem.MaxDate := UserItem.MaxDate; //20110622
        if ClientItem.BindValue = 0 then begin //禁止交易,扔物品,显示绑定 20110626
          if (CheckItemValue(UserItem, 1) and CheckItemValue(UserItem, 0)) or
            (GetCheckItemList(0, StdItem.Name) and GetCheckItemList(1, StdItem.Name)) then
            ClientItem.BindValue := 3;
        end;
        //Modified By TasNat at: 2012-04-12 09:28:18
        ClientItem.btAppraisalLevel :=   UserItem.btAppraisalLevel;
        ClientItem.btUnKnowValueCount := UserItem.btUnKnowValueCount;
        Move(UserItem.btAppraisalValue, ClientItem.btAppraisalValue, SizeOf(ClientItem.btAppraisalValue));

        Move(UserItem.btUnKnowValue, ClientItem.btUnKnowValue, SizeOf(ClientItem.btUnKnowValue)); //20100822
        m_DefMsg := MakeDefaultMsg(SM_CHALLENGEREMOTEADDITEM, Integer(Self), 0, 0, 1, 0);
        m_ChallengeCreat.SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(ClientItem)));
        m_ChallengeCreat.m_ChallengeLastTick := GetTickCount();
        m_ChallengeLastTick := GetTickCount();
      end;
    end;
  end;
end;

//判断玩家是否面对面,是则弹出抵物品窗口 20080704

procedure TPlayObject.ClientChallenge;
var
  BaseObject: TBaseObject;
  PlayObject: TPlayObject;
begin
  if m_boChallengeing or (m_ChallengeCreat <> nil) then Exit; //如果正在挑战则退出
  if m_PEnvir.m_boNoFight4Zone then begin //禁止挑战
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '此地图禁止挑战！');
    Exit;
  end;
  if (GetTickCount - m_ChallengeLastTick < 3000) or m_boShop then begin //开启个人商店时不能扔物品 20100704
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sPleaseTryChallengeLaterMsg {'请稍后再挑战'});
    Exit;
  end;
  BaseObject := GetPoseCreate(); //取面前对像
  if (BaseObject <> nil) and (BaseObject <> Self) and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
    PlayObject := TPlayObject(BaseObject);
    if (PlayObject <> nil) and (PlayObject.GetPoseCreate = Self) and (not PlayObject.m_boChallengeing)
      and (PlayObject.m_ChallengeCreat = nil) and (not PlayObject.m_boShop)
      and (not PlayObject.m_boNotOnlineAddExp) and (not PlayObject.m_boAI) then begin
      OpenChallengeDlg(PlayObject); //打开挑战抵押物品窗口 20091025 修改
      PlayObject.OpenChallengeDlg(Self); //打开挑战抵押物品窗口
    end else begin
      SendDefMessage(SM_CHALLENGE_FAIL, 0, 0, 0, 0, '');
    end;
  end else begin
    SendDefMessage(SM_CHALLENGE_FAIL, 0, 0, 0, 0, '');
  end;
end;
//打开挑战抵押物品窗口

procedure TPlayObject.OpenChallengeDlg(PlayObject: TPlayObject);
begin
  m_boChallengeOK := False;
  m_boChallengeing := True;
  m_ChallengeCreat := PlayObject;
  GetBackChallengeItems();
  SendDefMessage(SM_CHALLENGEMENU, 0, 0, 0, 0, m_ChallengeCreat.m_sCharName);
  m_ChallengeLastTick := GetTickCount();
end;
//取回之前抵押物品

procedure TPlayObject.GetBackChallengeItems;
var
  I: Integer;
  UserItem: pTUserItem;
begin
  m_boChallengeOK := False;
  if m_ChallengeItemList.Count > 0 then begin
    for I := 0 to m_ChallengeItemList.Count - 1 do begin
      UserItem := m_ChallengeItemList.Items[I];
      if UserItem <> nil then begin
        m_ItemList.Add(UserItem);
        SendAddItem(UserItem);
      end;
    end;
  end;
  m_ChallengeItemList.Clear;
  Inc(m_nGold, m_nChallengeGolds);
  m_nChallengeGolds := 0;
  Inc(m_nGAMEDIAMOND, m_nChallengeGAMEDIAMOND);
  m_nChallengeGAMEDIAMOND := 0;
end;

//客户端增加抵押物品到挑战框中

procedure TPlayObject.ClientAddChallengeItem(nItemIdx: Integer; sItemName: string);
var
  I: Integer;
  bo11: Boolean;
  UserItem: pTUserItem;
  sUserItemName: string;
begin
  if (m_ChallengeCreat = nil) or (not m_boChallengeing) then Exit;
  m_boCanQueryBag := True; //增加挑战物品时,不能刷新包裹 20080917
  try
    if Pos(' ', sItemName) >= 0 then begin //折分物品名称(信件物品的名称后面加了使用次数)
      GetValidStr3(sItemName, sItemName, [' ']);
    end;
    bo11 := False;
    if not m_ChallengeCreat.m_boChallengeOK then begin
      for I := m_ItemList.Count - 1 downto 0 do begin
        if m_ItemList.Count <= 0 then Break;
        UserItem := m_ItemList.Items[I];
        if UserItem = nil then Continue;
        if UserItem.MakeIndex = nItemIdx then begin
          if (UserItem.AddValue[0] in [1..3]) then Break; //限时物品,绑定物品不能交易
          //取自定义物品名称
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sUserItemName = '' then
            sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

          if (CompareText(sUserItemName, sItemName) = 0) and (m_ChallengeItemList.Count < 5) then begin
            if CheckItemValue(UserItem, 1) then Break //20080314 禁止交易
            else if PlugOfCheckCanItem(1, sUserItemName, False, 0, 0) then Break; //禁止物品规则(管理插件功能) 20080729

            m_ChallengeItemList.Add(UserItem);
            TPlayObject(Self).SendAddChallengeItem(UserItem); //发送抵押的挑战物品
            m_ItemList.Delete(I);
            bo11 := True;
            Break;
          end;
        end;
      end;
    end;
    if not bo11 then SendDefMessage(SM_CHALLENGEADDITEM_FAIL, 0, 0, 0, 0, '');
  finally
    m_boCanQueryBag := False; //增加挑战物品时,不能刷新包裹 20080917
  end;
end;
//客户端删除抵押的挑战物品

procedure TPlayObject.ClientDelChallengeItem(nItemIdx: Integer; sItemName: string);
var
  I: Integer;
  bo11: Boolean;
  UserItem: pTUserItem;
  sUserItemName: string;
begin
  if (m_ChallengeCreat = nil) or (not m_boChallengeing) then Exit;
  if Pos(' ', sItemName) >= 0 then begin //折分物品名称(信件物品的名称后面加了使用次数)
    GetValidStr3(sItemName, sItemName, [' ']);
  end;
  bo11 := False;
  if not m_ChallengeCreat.m_boChallengeOK then begin
    for I := m_ChallengeItemList.Count - 1 downto 0 do begin
      if m_ChallengeItemList.Count <= 0 then Break;
      UserItem := m_ChallengeItemList.Items[I];
      if UserItem = nil then Continue;
      if UserItem.MakeIndex = nItemIdx then begin
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

        if CompareText(sUserItemName, sItemName) = 0 then begin
          m_ItemList.Add(UserItem);
          TPlayObject(Self).SendDelChallengeItem(UserItem); //发送删除抵押的挑战物品
          m_ChallengeItemList.Delete(I);
          bo11 := True;
          Break;
        end;
      end;
    end; //for
  end;
  if not bo11 then SendDefMessage(SM_CHALLENGEDELITEM_FAIL, 0, 0, 0, 0, '');
end;

//挑战取消

procedure TPlayObject.ChallengeCancel;
begin
  m_boChallengeOK := False;
  if not m_boChallengeing then Exit;
  m_boChallengeing := False;
  SendDefMessage(SM_CHALLENGECANCEL, 0, 0, 0, 0, '');
  if m_ChallengeCreat <> nil then m_ChallengeCreat.ChallengeCancel;
  m_ChallengeCreat := nil;
  GetBackChallengeItems();
  SysMsg(g_sChallengeActionCancelMsg {'挑战取消'}, c_Green, t_Hint);
  m_ChallengeLastTick := GetTickCount();
end;

//客户端取消挑战

procedure TPlayObject.ClientCancelChallenge;
begin
  ChallengeCancel;
end;

//客户端把金币放到挑战框中

procedure TPlayObject.ClientChangeChallengeGold(nGold: Integer);
var
  bo09: Boolean;
begin
  //禁止取回放入挑战栏内的金币
  if (m_nChallengeGolds > 0) and g_Config.boCanNotGetBackDeal then begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sChallengeItemsDenyGetBackMsg);
    SendDefMessage(SM_CHALLENGEDELITEM_FAIL, 0, 0, 0, 0, '');
    Exit;
  end;
  if nGold < 0 then begin
    SendDefMessage(SM_CHALLENCHGGOLD_FAIL, m_nChallengeGolds, LoWord(m_nGold), HiWord(m_nGold), 0, '');
    Exit;
  end;
  bo09 := False;
  if (m_ChallengeCreat <> nil) and (GetPoseCreate = m_ChallengeCreat) then begin
    if not m_ChallengeCreat.m_boChallengeOK then begin
      if (m_nGold + m_nChallengeGolds) >= nGold then begin
        m_nGold := (m_nGold + m_nChallengeGolds) - nGold;
        m_nChallengeGolds := nGold;
        SendDefMessage(SM_CHALLENCHGGOLD_OK, m_nChallengeGolds, LoWord(m_nGold), HiWord(m_nGold), 0, '');
        m_ChallengeCreat.SendDefMessage(SM_CHALLENREMOTECHGGOLD, m_nChallengeGolds, 0, 0, 0, '');
        m_ChallengeCreat.m_ChallengeLastTick := GetTickCount();
        bo09 := True;
        m_ChallengeLastTick := GetTickCount();
      end;
    end;
  end;
  if not bo09 then SendDefMessage(SM_CHALLENCHGGOLD_FAIL, m_nChallengeGolds, LoWord(m_nGold), HiWord(m_nGold), 0, '');
end;

//客户端把金刚石放到挑战框中

procedure TPlayObject.ClientChangeChallengeDIAMOND(nDIAMOND: Integer);
var
  bo09: Boolean;
begin
  if nDIAMOND < 0 then begin
    SendDefMessage(SM_CHALLENCHGDIAMOND_FAIL, m_nChallengeGAMEDIAMOND, LoWord(m_nGAMEDIAMOND), HiWord(m_nGAMEDIAMOND), 0, '');
    Exit;
  end;
  if PlugOfCheckCanItem(1, g_Config.sGameDiaMond, False, 0, 0) then Exit; //是否禁止交易 20110226
  bo09 := False;
  if (m_ChallengeCreat <> nil) and (GetPoseCreate = m_ChallengeCreat) then begin
    if not m_ChallengeCreat.m_boChallengeOK then begin
      if (m_nGAMEDIAMOND + m_nChallengeGAMEDIAMOND) >= nDIAMOND then begin
        m_nGAMEDIAMOND := (m_nGAMEDIAMOND + m_nChallengeGAMEDIAMOND) - nDIAMOND;
        m_nChallengeGAMEDIAMOND := nDIAMOND;
        SendDefMessage(SM_CHALLENCHGDIAMOND_OK, m_nChallengeGAMEDIAMOND, LoWord(m_nGAMEDIAMOND), HiWord(m_nGAMEDIAMOND), 0, '');
        m_ChallengeCreat.SendDefMessage(SM_CHALLENREMOTECHGDIAMOND, m_nChallengeGAMEDIAMOND, 0, 0, 0, '');
        m_ChallengeCreat.m_ChallengeLastTick := GetTickCount();
        bo09 := True;
        m_ChallengeLastTick := GetTickCount();
      end;
    end;
  end;
  if not bo09 then SendDefMessage(SM_CHALLENCHGDIAMOND_FAIL, m_nChallengeGAMEDIAMOND, LoWord(m_nGAMEDIAMOND), HiWord(m_nGAMEDIAMOND), 0, '');
end;

//挑战抵押物品结束

procedure TPlayObject.ClientChallengeEnd;
var
  bo11: Boolean;
begin
  m_boChallengeOK := True;
  if (m_ChallengeCreat = nil) or (m_ChallengeCreat.m_boNotOnlineAddExp) or
    (m_ChallengeCreat.m_boDeath) or (m_ChallengeCreat.m_boGhost) or
    (m_ChallengeCreat.m_boShop) or (m_boShop) then Exit;
  if ((GetTickCount - m_ChallengeLastTick) < 1000) or ((GetTickCount - m_ChallengeCreat.m_ChallengeLastTick) < 1000) then begin
    SysMsg(g_sChallengeOKTooFast {'过早按了确定按钮。'}, c_Red, t_Hint);
    ChallengeCancel();
    Exit;
  end;
  if m_ChallengeCreat.m_boChallengeOK then begin
    bo11 := True;
    if (MAXBAGITEM - m_ItemList.Count) < m_ChallengeCreat.m_ChallengeItemList.Count then begin
      bo11 := False;
      SysMsg(g_sChallengeYourBagSizeTooSmall, c_Red, t_Hint);
    end;
    if (m_nGoldMax - m_nGold) < m_ChallengeCreat.m_nChallengeGolds then begin
      SysMsg(g_sChallengeYourGoldLargeThenLimit, c_Red, t_Hint);
      bo11 := False;
    end;
    if (MAXBAGITEM - m_ChallengeCreat.m_ItemList.Count) < m_ChallengeItemList.Count then begin
      SysMsg(g_sChallengeHumanBagSizeTooSmall, c_Red, t_Hint);
      bo11 := False;
    end;
    if (m_ChallengeCreat.m_nGoldMax - m_ChallengeCreat.m_nGold) < m_nChallengeGolds then begin
      SysMsg(g_sChallengeHumanGoldLargeThenLimit, c_Red, t_Hint);
      bo11 := False;
    end;

    if bo11 then begin
      m_ChallengeCreat.m_boChallengeOK := False;
      m_boChallengeOK := False;
      SendDefMessage(SM_CLOSECHALLENGE, 0, 0, 0, 0, ''); //关闭挑战抵押物品窗口
      m_ChallengeCreat.SendDefMessage(SM_CLOSECHALLENGE, 0, 0, 0, 0, ''); //关闭挑战抵押物品窗口
      if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(self, '@Challenge', False, False); //进入触发段(传送挑战地图)
    end else begin
      ChallengeCancel();
    end;
  end else begin
    SysMsg(g_sYouChallengeOKMsg, c_Green, t_Hint);
    m_ChallengeCreat.SysMsg(g_sPoseChallengeOKMsg, c_Green, t_Hint);
  end;
end;
//胜方取得物品

procedure TPlayObject.WinGetChallengeItems;
var
  I: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
  if m_ChallengeCreat <> nil then begin
    m_ChallengeCreat.m_boChallengeing := False;
    m_boChallengeing := False;
    m_ChallengeCreat.m_ChallengeTime := 0;
    m_ChallengeTime := 0;
    if m_ChallengeCreat.m_ChallengeItemList.Count > 0 then begin
      for I := 0 to m_ChallengeCreat.m_ChallengeItemList.Count - 1 do begin
        UserItem := m_ChallengeCreat.m_ChallengeItemList.Items[I];
        if UserItem <> nil then begin
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem <> nil then begin
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('36' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 +
                IntToStr(UserItem.MakeIndex) + #9 +
                '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + m_ChallengeCreat.m_sCharName);
          end;
          if IsEnoughBag then begin //人物的包裹是否满了
            m_ItemList.Add(UserItem);
            SendAddItem(UserItem);
          end else
            if m_StorageItemList.Count < MAXBAGITEM then begin //保存到仓库里 20080713
              m_StorageItemList.Add(UserItem);
            end;
        end;
      end;
    end;
    m_ChallengeCreat.m_ChallengeItemList.Clear;
    if m_ChallengeCreat.m_nChallengeGolds > 0 then begin
      Inc(m_nGold, m_ChallengeCreat.m_nChallengeGolds);
      if g_boGameLogGold then
        AddGameDataLog('36' + #9 + m_sMapName + #9 +
          IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +
          sSTRING_GOLDNAME + #9 + IntToStr(m_ChallengeCreat.m_nChallengeGolds) + #9 + '1' + #9 + m_ChallengeCreat.m_sCharName);
      m_ChallengeCreat.m_nChallengeGolds := 0;
    end;
    if m_ChallengeCreat.m_nChallengeGAMEDIAMOND > 0 then begin
      Inc(m_nGAMEDIAMOND, m_ChallengeCreat.m_nChallengeGAMEDIAMOND);
      if g_boGameLogGold then
        AddGameDataLog('36' + #9 + m_sMapName + #9 +
          IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
          m_sCharName + #9 + g_Config.sGameDiaMond + #9 +
          IntToStr(m_ChallengeCreat.m_nChallengeGAMEDIAMOND) + #9 + '1' + #9 + m_ChallengeCreat.m_sCharName);
      m_ChallengeCreat.m_nChallengeGAMEDIAMOND := 0;
    end;
    m_ChallengeCreat.m_boChallengeOK := False;
    m_ChallengeCreat.m_WAbil.HP := m_ChallengeCreat.m_WAbil.MaxHP;
    m_ChallengeCreat.m_WAbil.MP := m_ChallengeCreat.m_WAbil.MaxMP;
    m_ChallengeCreat.HealthSpellChanged();
    m_ChallengeCreat.m_ChallengeCreat := nil;
    m_ChallengeCreat.m_ChallengeLastTick := GetTickCount();

    if m_ChallengeItemList.Count > 0 then begin
      for I := 0 to m_ChallengeItemList.Count - 1 do begin
        UserItem := m_ChallengeItemList.Items[I];
        if UserItem <> nil then begin
          if IsEnoughBag then begin //人物的包裹是否满了
            m_ItemList.Add(UserItem);
            SendAddItem(UserItem);
          end else
            if m_StorageItemList.Count < MAXBAGITEM then begin //保存到仓库里 20080713
              m_StorageItemList.Add(UserItem);
            end;
        end;
      end;
    end;
    m_ChallengeItemList.Clear;
    Inc(m_nGold, m_nChallengeGolds);
    m_nChallengeGolds := 0;
    Inc(m_nGAMEDIAMOND, m_nChallengeGAMEDIAMOND);
    m_nChallengeGAMEDIAMOND := 0;
    m_boChallengeOK := False;
    m_WAbil.HP := m_WAbil.MaxHP;
    m_WAbil.MP := m_WAbil.MaxMP;
    HealthSpellChanged();
    m_ChallengeCreat := nil;
    m_ChallengeLastTick := GetTickCount();
    GoldChanged();
    GameGoldChanged; //更新金刚石和金币
  end;
end;

{$IF M2Version <> 2}
//检查包裹是否有气血石，有则自动穿上 20090302

procedure TPlayObject.CheckItmeAutoItme(btWhere, btStdMode, btShape: Byte);
var
  I, nItemIdx: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  boFound: Boolean;
  sItemName: string;
begin
  if m_ItemList.Count > 0 then begin
    for I := 0 to m_ItemList.Count - 1 do begin
      UserItem := m_ItemList.Items[I];
      if UserItem <> nil then begin
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem <> nil then begin
          if (StdItem.StdMode = btStdMode) and (StdItem.Shape = btShape) then begin
            boFound := True;
            nItemIdx := UserItem.MakeIndex;
            sItemName := StdItem.Name;
            Break;
          end;
        end;
      end;
    end;
  end;
  if (nItemIdx >= 0) and boFound then begin
    ClientTakeOnItems(btWhere, nItemIdx, sItemName);
    SendUseitems(); //发送使用的物品
    ClientQueryBagItems;
  end;
end;

//气血石功能 20080729

procedure TPlayObject.PlaySuperRock;
var
  StdItem: pTStdItem;
  nTempDura: Integer;
begin
  try
    //气血石 魔血石                                                                                                  //20080611
    if (not m_boDeath) and (not m_boGhost) and (m_WAbil.HP > 0) then begin
      if (m_UseItems[U_CHARM].wIndex > 0) and (m_UseItems[U_CHARM].Dura > 0) then begin
        StdItem := UserEngine.GetStdItem(m_UseItems[U_CHARM].wIndex);
        if (StdItem <> nil) then begin
          if (StdItem.Shape > 0) and (StdItem.StdMode = 7) and m_PEnvir.AllowStdItems(StdItem.Name) then begin
            case StdItem.Shape of
              1: begin //气血石
                  if (m_WAbil.MaxHP - m_WAbil.HP) >= g_Config.nStartHPRock then begin //200081215 改成掉点数启用
                    if GetTickCount - dwRockAddHPTick > g_Config.nHPRockSpell then begin
                      dwRockAddHPTick := GetTickCount(); //气石加HP间隔
                      if m_UseItems[U_CHARM].Dura * 10 > g_Config.nHPRockDecDura then begin
                        Inc(m_WAbil.HP, g_Config.nRockAddHP);
                        nTempDura := m_UseItems[U_CHARM].Dura * 10;
                        Dec(nTempDura, g_Config.nHPRockDecDura);
                        m_UseItems[U_CHARM].Dura := Round(nTempDura / 10);
                        if m_UseItems[U_CHARM].Dura > 0 then begin
                          SendMsg(self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura, m_UseItems[U_CHARM].DuraMax, 0, '');
                        end else begin
                          SendDelItems(@m_UseItems[U_CHARM]);
                          m_UseItems[U_CHARM].wIndex := 0;
                          CheckItmeAutoItme(U_CHARM, StdItem.StdMode, StdItem.Shape); //检查包裹是否有气血石，有则自动穿上 20090302
                        end;
                      end else begin
                        Inc(m_WAbil.HP, g_Config.nRockAddHP);
                        m_UseItems[U_CHARM].Dura := 0;
                        SendDelItems(@m_UseItems[U_CHARM]);
                        m_UseItems[U_CHARM].wIndex := 0;
                        CheckItmeAutoItme(U_CHARM, StdItem.StdMode, StdItem.Shape); //检查包裹是否有气血石，有则自动穿上 20090302
                      end;
                      if m_WAbil.HP > m_WAbil.MaxHP then m_WAbil.HP := m_WAbil.MaxHP;
                      PlugHealthSpellChanged();
                    end;
                  end;
                end;
              2: begin
                  if (m_WAbil.MaxMP - m_WAbil.MP) >= g_Config.nStartMPRock then begin //200081215 改成掉点数启用
                    if GetTickCount - dwRockAddMPTick > g_Config.nMPRockSpell then begin
                      dwRockAddMPTick := GetTickCount; //气石加MP间隔
                      if m_UseItems[U_CHARM].Dura * 10 > g_Config.nMPRockDecDura then begin
                        Inc(m_WAbil.MP, g_Config.nRockAddMP);
                        nTempDura := m_UseItems[U_CHARM].Dura * 10;
                        Dec(nTempDura, g_Config.nMPRockDecDura);
                        m_UseItems[U_CHARM].Dura := Round(nTempDura / 10);
                        if m_UseItems[U_CHARM].Dura > 0 then begin
                          SendMsg(self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura, m_UseItems[U_CHARM].DuraMax, 0, '');
                        end else begin
                          SendDelItems(@m_UseItems[U_CHARM]);
                          m_UseItems[U_CHARM].wIndex := 0;
                          CheckItmeAutoItme(U_CHARM, StdItem.StdMode, StdItem.Shape); //检查包裹是否有气血石，有则自动穿上 20090302
                        end;
                      end else begin
                        Inc(m_WAbil.MP, g_Config.nRockAddMP);
                        m_UseItems[U_CHARM].Dura := 0;
                        SendDelItems(@m_UseItems[U_CHARM]);
                        m_UseItems[U_CHARM].wIndex := 0;
                        CheckItmeAutoItme(U_CHARM, StdItem.StdMode, StdItem.Shape); //检查包裹是否有气血石，有则自动穿上 20090302
                      end;
                      if m_WAbil.MP > m_WAbil.MaxMP then m_WAbil.MP := m_WAbil.MaxMP;
                      PlugHealthSpellChanged();
                    end;
                  end;
                end;
              3: begin
                  if (m_WAbil.MaxHP - m_WAbil.HP) >= g_Config.nStartHPMPRock then begin //200081215 改成掉点数启用
                    if GetTickCount - dwRockAddHPTick > g_Config.nHPMPRockSpell then begin
                      dwRockAddHPTick := GetTickCount; //气石加HP间隔
                      if m_UseItems[U_CHARM].Dura * 10 > g_Config.nHPMPRockDecDura then begin
                        Inc(m_WAbil.HP, g_Config.nRockAddHPMP);
                        nTempDura := m_UseItems[U_CHARM].Dura * 10;
                        Dec(nTempDura, g_Config.nHPMPRockDecDura);
                        m_UseItems[U_CHARM].Dura := Round(nTempDura / 10);
                        if m_UseItems[U_CHARM].Dura > 0 then begin
                          SendMsg(self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura, m_UseItems[U_CHARM].DuraMax, 0, '');
                        end else begin
                          SendDelItems(@m_UseItems[U_CHARM]);
                          m_UseItems[U_CHARM].wIndex := 0;
                          CheckItmeAutoItme(U_CHARM, StdItem.StdMode, StdItem.Shape); //检查包裹是否有气血石，有则自动穿上 20090302
                        end;
                      end else begin
                        Inc(m_WAbil.HP, g_Config.nRockAddHPMP);
                        m_UseItems[U_CHARM].Dura := 0;
                        SendDelItems(@m_UseItems[U_CHARM]);
                        m_UseItems[U_CHARM].wIndex := 0;
                        CheckItmeAutoItme(U_CHARM, StdItem.StdMode, StdItem.Shape); //检查包裹是否有气血石，有则自动穿上 20090302
                      end;
                      if m_WAbil.HP > m_WAbil.MaxHP then m_WAbil.HP := m_WAbil.MaxHP;
                      PlugHealthSpellChanged();
                    end;
                  end;
                //======================================================================
                  if (m_WAbil.MaxMP - m_WAbil.MP) >= g_Config.nStartHPMPRock then begin //200081215 改成掉点数启用
                    if GetTickCount - dwRockAddMPTick > g_Config.nHPMPRockSpell then begin
                      dwRockAddMPTick := GetTickCount; //气石加MP间隔
                      if m_UseItems[U_CHARM].Dura * 10 > g_Config.nHPMPRockDecDura then begin
                        Inc(m_WAbil.MP, g_Config.nRockAddHPMP);
                        nTempDura := m_UseItems[U_CHARM].Dura * 10;
                        Dec(nTempDura, g_Config.nHPMPRockDecDura);
                        m_UseItems[U_CHARM].Dura := Round(nTempDura / 10);
                        if m_UseItems[U_CHARM].Dura > 0 then begin
                          SendMsg(self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura, m_UseItems[U_CHARM].DuraMax, 0, '');
                        end else begin
                          SendDelItems(@m_UseItems[U_CHARM]);
                          m_UseItems[U_CHARM].wIndex := 0;
                          CheckItmeAutoItme(U_CHARM, StdItem.StdMode, StdItem.Shape); //检查包裹是否有气血石，有则自动穿上 20090302
                        end;
                      end else begin
                        Inc(m_WAbil.MP, g_Config.nRockAddHPMP);
                        m_UseItems[U_CHARM].Dura := 0;
                        SendDelItems(@m_UseItems[U_CHARM]);
                        m_UseItems[U_CHARM].wIndex := 0;
                        CheckItmeAutoItme(U_CHARM, StdItem.StdMode, StdItem.Shape); //检查包裹是否有气血石，有则自动穿上 20090302
                      end;
                      if m_WAbil.MP > m_WAbil.MaxMP then m_WAbil.MP := m_WAbil.MaxMP;
                      PlugHealthSpellChanged();
                    end;
                  end;
                end; //3 begin
              5: begin //天龙印
                  if (m_WAbil.MaxHP - m_WAbil.HP) >= g_Config.nStartHPMPRock1 then begin
                    if GetTickCount - dwRockAddHPTick > g_Config.nHPMPRockSpell1 then begin
                      dwRockAddHPTick := GetTickCount; //加HP间隔
                      if m_UseItems[U_CHARM].Dura * 10 > g_Config.nHPMPRockDecDura1 then begin
                        Inc(m_WAbil.HP, g_Config.nRockAddHPMP1);
                        nTempDura := m_UseItems[U_CHARM].Dura * 10;
                        Dec(nTempDura, g_Config.nHPMPRockDecDura1);
                        m_UseItems[U_CHARM].Dura := Round(nTempDura / 10);
                        if m_UseItems[U_CHARM].Dura > 0 then begin
                          SendMsg(self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura, m_UseItems[U_CHARM].DuraMax, 0, '');
                        end else begin
                          m_UseItems[U_CHARM].Dura := 0;
                          SendMsg(self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura, m_UseItems[U_CHARM].DuraMax, 0, '');
                          RecalcAbilitys();
                          CompareSuitItem(False);
                          SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                        end;
                      end else begin
                        Inc(m_WAbil.HP, g_Config.nRockAddHPMP1);
                        m_UseItems[U_CHARM].Dura := 0;
                        SendMsg(self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura, m_UseItems[U_CHARM].DuraMax, 0, '');
                        RecalcAbilitys();
                        CompareSuitItem(False);
                        SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                      end;
                      if m_WAbil.HP > m_WAbil.MaxHP then m_WAbil.HP := m_WAbil.MaxHP;
                      PlugHealthSpellChanged();
                    end;
                  end;

                //======================================================================
                  if (m_WAbil.MaxMP - m_WAbil.MP) >= g_Config.nStartHPMPRock1 then begin //200081215 改成掉点数启用
                    if GetTickCount - dwRockAddMPTick > g_Config.nHPMPRockSpell1 then begin
                      dwRockAddMPTick := GetTickCount; //气石加MP间隔
                      if m_UseItems[U_CHARM].Dura * 10 > g_Config.nHPMPRockDecDura1 then begin
                        Inc(m_WAbil.MP, g_Config.nRockAddHPMP1);
                        nTempDura := m_UseItems[U_CHARM].Dura * 10;
                        Dec(nTempDura, g_Config.nHPMPRockDecDura1);
                        m_UseItems[U_CHARM].Dura := Round(nTempDura / 10);
                        if m_UseItems[U_CHARM].Dura > 0 then begin
                          SendMsg(self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura, m_UseItems[U_CHARM].DuraMax, 0, '');
                        end else begin
                          m_UseItems[U_CHARM].Dura := 0;
                          SendMsg(self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura, m_UseItems[U_CHARM].DuraMax, 0, '');
                          RecalcAbilitys();
                          CompareSuitItem(False);
                          SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                        end;
                      end else begin
                        Inc(m_WAbil.MP, g_Config.nRockAddHPMP1);
                        m_UseItems[U_CHARM].Dura := 0;
                        SendMsg(self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura, m_UseItems[U_CHARM].DuraMax, 0, '');
                        RecalcAbilitys();
                        CompareSuitItem(False);
                        SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                      end;
                      if m_WAbil.MP > m_WAbil.MaxMP then m_WAbil.MP := m_WAbil.MaxMP;
                      PlugHealthSpellChanged();
                    end;
                  end;
                end; //5 begin
            end;
          end;
        end;
      end;
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.PlaySuperRock', [g_sExceptionVer]));
  end;
end;


//客户端强化怒之内功 20110604

procedure TPlayObject.ClientUpNGStrongSkill(wMagIdx {技能ID}: Integer);
  function CheckItemCount(nItemCount: Word): Boolean; //检查物品数量并删除物品
  var
    I, nCount: Integer;
    StdItem: pTStdItem;
    UserItem: pTUserItem;
    boItem: Boolean;
  begin
    Result := False;
    if nItemCount > 0 then begin
      if m_ItemList.Count > 0 then begin
        nCount := 0;
        boItem := False;
        for I := m_ItemList.Count - 1 downto 0 do begin
          if m_ItemList.Count <= 0 then Break;
          UserItem := m_ItemList.Items[I];
          if UserItem <> nil then begin
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if StdItem <> nil then begin
              if (CompareText(StdItem.Name, g_Config.sNGStrongItem) = 0) then begin
                if (StdItem.StdMode = 17) then begin
                  Inc(nCount, UserItem.Dura);
                  if nCount >= nItemCount then begin
                    boItem := True;
                    Break;
                  end;
                end else begin
                  Inc(nCount);
                  if nCount >= nItemCount then begin
                    boItem := True;
                    Break;
                  end;
                end;
              end;
            end;
          end;
        end;
        if boItem then begin //数量够，则删除物品并增加等级
          for I := m_ItemList.Count - 1 downto 0 do begin
            if m_ItemList.Count <= 0 then Break;
            UserItem := m_ItemList.Items[I];
            if UserItem <> nil then begin
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem <> nil then begin
                if (CompareText(StdItem.Name, g_Config.sNGStrongItem) = 0) then begin
                  if (StdItem.StdMode = 17) then begin
                    if UserItem.Dura >= nItemCount then begin
                      UserItem.Dura := UserItem.Dura - nItemCount;
                      Result := True;
                      if UserItem.Dura <= 0 then begin //删除物品
                        m_ItemList.Delete(I);
                        SendDelItems(UserItem);
                        UserItem.MakeIndex := 0;
                        UserItem.wIndex := 0;
                        Dispose(UserItem); //By TasNat
                        UserItem := nil;
                      end else begin
                        SendUpdateItem(UserItem); //更新物品
                      end;
                      Break;
                    end else begin
                      Dec(nItemCount, UserItem.Dura);
                      UserItem.Dura := 0;
                      m_ItemList.Delete(I);
                      SendDelItems(UserItem);
                      UserItem.MakeIndex := 0;
                      UserItem.wIndex := 0;
                      Dispose(UserItem); //By TasNat
                        UserItem := nil;
                    end;
                  end else begin
                    Dec(nItemCount);
                    m_ItemList.Delete(I);
                    SendDelItems(UserItem);
                    UserItem.MakeIndex := 0;
                    UserItem.wIndex := 0;
                    Dispose(UserItem); //By TasNat
                        UserItem := nil;
                    if nItemCount <= 0 then begin
                      Result := True;
                      Break;
                    end;
                  end;
                end;
              end;
            end;
          end;
        end else begin
          SysMsg('很抱歉，您没有足够的' + g_Config.sNGStrongItem, c_Red, t_Hint);
        end;
      end;
    end;
  end;
var
  nNeedNGLevel, nNeedItemCount: Word;
begin
  try
    if g_Config.sNGStrongItem <> '' then begin
      if (not m_boTrainingNG) or m_boDeath or m_boGhost then Exit;
      m_boCanQueryBag := True; //不能刷新包裹
      try
        case wMagIdx of
          SKILL_200: begin //怒之攻杀强化
              if m_MagicSkill_200 <> nil then begin
                if (m_MagicSkill_200.btLevel > 2) and (m_MagicSkill_200.btLevel < g_Config.nNGSkillMaxLevel) then begin
                  nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_200NGStrong[0] + (m_MagicSkill_200.btLevel - 3) * g_Config.nSKILL_200NGStrong[1]);
                  nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_200NGStrong[2] + (m_MagicSkill_200.btLevel - 3) * g_Config.nSKILL_200NGStrong[3]);
                  if (m_NGLevel >= nNeedNGLevel) and (nNeedItemCount > 0) then begin //判断内功等级是否达到
                    if CheckItemCount(nNeedItemCount) then begin //升级技能
                      Inc(m_MagicSkill_200.btLevel);
                      if (m_MagicSkill_200.btLevel > 2) and (m_MagicSkill_200.btLevel < g_Config.nNGSkillMaxLevel) then begin
                        nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_200NGStrong[0] + (m_MagicSkill_200.btLevel - 3) * g_Config.nSKILL_200NGStrong[1]);
                        nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_200NGStrong[2] + (m_MagicSkill_200.btLevel - 3) * g_Config.nSKILL_200NGStrong[3]);
                      end else begin
                        nNeedNGLevel := 0;
                        nNeedItemCount := 0;
                      end;
                      SendMsg(Self, RM_NGMAGIC_LVEXP, m_MagicSkill_200.MagicInfo.wMagicId, nNeedNGLevel, m_MagicSkill_200.btLevel, nNeedItemCount, '');
                    end;
                  end;
                end;
              end;
            end;
          Skill_202: begin //怒之半月强化
              if m_MagicSkill_202 <> nil then begin
                if (m_MagicSkill_202.btLevel > 2) and (m_MagicSkill_202.btLevel < g_Config.nNGSkillMaxLevel) then begin
                  nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_202NGStrong[0] + (m_MagicSkill_202.btLevel - 3) * g_Config.nSKILL_202NGStrong[1]);
                  nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_202NGStrong[2] + (m_MagicSkill_202.btLevel - 3) * g_Config.nSKILL_202NGStrong[3]);
                  if (m_NGLevel >= nNeedNGLevel) and (nNeedItemCount > 0) then begin //判断内功等级是否达到
                    if CheckItemCount(nNeedItemCount) then begin //升级技能
                      Inc(m_MagicSkill_202.btLevel);
                      if (m_MagicSkill_202.btLevel > 2) and (m_MagicSkill_202.btLevel < g_Config.nNGSkillMaxLevel) then begin
                        nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_202NGStrong[0] + (m_MagicSkill_202.btLevel - 3) * g_Config.nSKILL_202NGStrong[1]);
                        nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_202NGStrong[2] + (m_MagicSkill_202.btLevel - 3) * g_Config.nSKILL_202NGStrong[3]);
                      end else begin
                        nNeedNGLevel := 0;
                        nNeedItemCount := 0;
                      end;
                      SendMsg(Self, RM_NGMAGIC_LVEXP, m_MagicSkill_202.MagicInfo.wMagicId, nNeedNGLevel, m_MagicSkill_202.btLevel, nNeedItemCount, '');
                    end;
                  end;
                end;
              end;
            end;
          Skill_236: begin //怒之内功剑法强化
              if m_MagicSkill_236 <> nil then begin
                if (m_MagicSkill_236.btLevel > 2) and (m_MagicSkill_236.btLevel < g_Config.nNGSkillMaxLevel) then begin
                  nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_236NGStrong[0] + (m_MagicSkill_236.btLevel - 3) * g_Config.nSKILL_236NGStrong[1]);
                  nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_236NGStrong[2] + (m_MagicSkill_236.btLevel - 3) * g_Config.nSKILL_236NGStrong[3]);
                  if (m_NGLevel >= nNeedNGLevel) and (nNeedItemCount > 0) then begin //判断内功等级是否达到
                    if CheckItemCount(nNeedItemCount) then begin //升级技能
                      Inc(m_MagicSkill_236.btLevel);
                      if (m_MagicSkill_236.btLevel > 2) and (m_MagicSkill_236.btLevel < g_Config.nNGSkillMaxLevel) then begin
                        nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_236NGStrong[0] + (m_MagicSkill_236.btLevel - 3) * g_Config.nSKILL_236NGStrong[1]);
                        nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_236NGStrong[2] + (m_MagicSkill_236.btLevel - 3) * g_Config.nSKILL_236NGStrong[3]);
                      end else begin
                        nNeedNGLevel := 0;
                        nNeedItemCount := 0;
                      end;
                      SendMsg(Self, RM_NGMAGIC_LVEXP, m_MagicSkill_236.MagicInfo.wMagicId, nNeedNGLevel, m_MagicSkill_236.btLevel, nNeedItemCount, '');
                    end;
                  end;
                end;
              end;
            end;
          Skill_204: begin //怒之烈火强化
              if m_MagicSkill_204 <> nil then begin
                if (m_MagicSkill_204.btLevel > 2) and (m_MagicSkill_204.btLevel < g_Config.nNGSkillMaxLevel) then begin
                  nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_204NGStrong[0] + (m_MagicSkill_204.btLevel - 3) * g_Config.nSKILL_204NGStrong[1]);
                  nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_204NGStrong[2] + (m_MagicSkill_204.btLevel - 3) * g_Config.nSKILL_204NGStrong[3]);
                  if (m_NGLevel >= nNeedNGLevel) and (nNeedItemCount > 0) then begin //判断内功等级是否达到
                    if CheckItemCount(nNeedItemCount) then begin //升级技能
                      Inc(m_MagicSkill_204.btLevel);
                      if (m_MagicSkill_204.btLevel > 2) and (m_MagicSkill_204.btLevel < g_Config.nNGSkillMaxLevel) then begin
                        nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_204NGStrong[0] + (m_MagicSkill_204.btLevel - 3) * g_Config.nSKILL_204NGStrong[1]);
                        nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_204NGStrong[2] + (m_MagicSkill_204.btLevel - 3) * g_Config.nSKILL_204NGStrong[3]);
                      end else begin
                        nNeedNGLevel := 0;
                        nNeedItemCount := 0;
                      end;
                      SendMsg(Self, RM_NGMAGIC_LVEXP, m_MagicSkill_204.MagicInfo.wMagicId, nNeedNGLevel, m_MagicSkill_204.btLevel, nNeedItemCount, '');
                    end;
                  end;
                end;
              end;
            end;
          Skill_206: begin //怒之逐日强化
              if m_MagicSkill_206 <> nil then begin
                if (m_MagicSkill_206.btLevel > 2) and (m_MagicSkill_206.btLevel < g_Config.nNGSkillMaxLevel) then begin
                  nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_206NGStrong[0] + (m_MagicSkill_206.btLevel - 3) * g_Config.nSKILL_206NGStrong[1]);
                  nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_206NGStrong[2] + (m_MagicSkill_206.btLevel - 3) * g_Config.nSKILL_206NGStrong[3]);
                  if (m_NGLevel >= nNeedNGLevel) and (nNeedItemCount > 0) then begin //判断内功等级是否达到
                    if CheckItemCount(nNeedItemCount) then begin //升级技能
                      Inc(m_MagicSkill_206.btLevel);
                      if (m_MagicSkill_206.btLevel > 2) and (m_MagicSkill_206.btLevel < g_Config.nNGSkillMaxLevel) then begin
                        nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_206NGStrong[0] + (m_MagicSkill_206.btLevel - 3) * g_Config.nSKILL_206NGStrong[1]);
                        nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_206NGStrong[2] + (m_MagicSkill_206.btLevel - 3) * g_Config.nSKILL_206NGStrong[3]);
                      end else begin
                        nNeedNGLevel := 0;
                        nNeedItemCount := 0;
                      end;
                      SendMsg(Self, RM_NGMAGIC_LVEXP, m_MagicSkill_206.MagicInfo.wMagicId, nNeedNGLevel, m_MagicSkill_206.btLevel, nNeedItemCount, '');
                    end;
                  end;
                end;
              end;
            end;
          Skill_239: begin //怒之施毒术强化
{$IF M2Version = 1}
              if m_MagicSkill_239 <> nil then begin
                if (m_MagicSkill_239.btLevel > 2) and (m_MagicSkill_239.btLevel < g_Config.nNGSkillMaxLevel) then begin
                  nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_239NGStrong[0] + (m_MagicSkill_239.btLevel - 3) * g_Config.nSKILL_239NGStrong[1]);
                  nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_239NGStrong[2] + (m_MagicSkill_239.btLevel - 3) * g_Config.nSKILL_239NGStrong[3]);
                  if (m_NGLevel >= nNeedNGLevel) and (nNeedItemCount > 0) then begin //判断内功等级是否达到
                    if CheckItemCount(nNeedItemCount) then begin //升级技能
                      Inc(m_MagicSkill_239.btLevel);
                      if (m_MagicSkill_239.btLevel > 2) and (m_MagicSkill_239.btLevel < g_Config.nNGSkillMaxLevel) then begin
                        nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_239NGStrong[0] + (m_MagicSkill_239.btLevel - 3) * g_Config.nSKILL_239NGStrong[1]);
                        nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_239NGStrong[2] + (m_MagicSkill_239.btLevel - 3) * g_Config.nSKILL_239NGStrong[3]);
                      end else begin
                        nNeedNGLevel := 0;
                        nNeedItemCount := 0;
                      end;
                      SendMsg(Self, RM_NGMAGIC_LVEXP, m_MagicSkill_239.MagicInfo.wMagicId, nNeedNGLevel, m_MagicSkill_239.btLevel, nNeedItemCount, '');
                    end;
                  end;
                end;
              end;
{$IFEND}
            end;
          Skill_230: begin //怒之火符强化
              if m_MagicSkill_230 <> nil then begin
                if (m_MagicSkill_230.btLevel > 2) and (m_MagicSkill_230.btLevel < g_Config.nNGSkillMaxLevel) then begin
                  nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_230NGStrong[0] + (m_MagicSkill_230.btLevel - 3) * g_Config.nSKILL_230NGStrong[1]);
                  nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_230NGStrong[2] + (m_MagicSkill_230.btLevel - 3) * g_Config.nSKILL_230NGStrong[3]);
                  if (m_NGLevel >= nNeedNGLevel) and (nNeedItemCount > 0) then begin //判断内功等级是否达到
                    if CheckItemCount(nNeedItemCount) then begin //升级技能
                      Inc(m_MagicSkill_230.btLevel);
                      if (m_MagicSkill_230.btLevel > 2) and (m_MagicSkill_230.btLevel < g_Config.nNGSkillMaxLevel) then begin
                        nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_230NGStrong[0] + (m_MagicSkill_230.btLevel - 3) * g_Config.nSKILL_230NGStrong[1]);
                        nNeedItemCount := _MIN(High(Word), g_Config.nSkill_230NGStrong[2] + (m_MagicSkill_230.btLevel - 3) * g_Config.nSKILL_230NGStrong[3]);
                      end else begin
                        nNeedNGLevel := 0;
                        nNeedItemCount := 0;
                      end;
                      SendMsg(Self, RM_NGMAGIC_LVEXP, m_MagicSkill_230.MagicInfo.wMagicId, nNeedNGLevel, m_MagicSkill_230.btLevel, nNeedItemCount, '');
                    end;
                  end;
                end;
              end;
            end;
          Skill_232: begin //怒之噬血强化
              if m_MagicSkill_232 <> nil then begin
                if (m_MagicSkill_232.btLevel > 2) and (m_MagicSkill_232.btLevel < g_Config.nNGSkillMaxLevel) then begin
                  nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_232NGStrong[0] + (m_MagicSkill_232.btLevel - 3) * g_Config.nSKILL_232NGStrong[1]);
                  nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_232NGStrong[2] + (m_MagicSkill_232.btLevel - 3) * g_Config.nSKILL_232NGStrong[3]);
                  if (m_NGLevel >= nNeedNGLevel) and (nNeedItemCount > 0) then begin //判断内功等级是否达到
                    if CheckItemCount(nNeedItemCount) then begin //升级技能
                      Inc(m_MagicSkill_232.btLevel);
                      if (m_MagicSkill_232.btLevel > 2) and (m_MagicSkill_232.btLevel < g_Config.nNGSkillMaxLevel) then begin
                        nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_232NGStrong[0] + (m_MagicSkill_232.btLevel - 3) * g_Config.nSKILL_232NGStrong[1]);
                        nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_232NGStrong[2] + (m_MagicSkill_232.btLevel - 3) * g_Config.nSKILL_232NGStrong[3]);
                      end else begin
                        nNeedNGLevel := 0;
                        nNeedItemCount := 0;
                      end;
                      SendMsg(Self, RM_NGMAGIC_LVEXP, m_MagicSkill_232.MagicInfo.wMagicId, nNeedNGLevel, m_MagicSkill_232.btLevel, nNeedItemCount, '');
                    end;
                  end;
                end;
              end;
            end;
          Skill_241: begin //怒之月灵强化
{$IF M2Version = 1}
              if m_MagicSkill_241 <> nil then begin
                if (m_MagicSkill_241.btLevel > 2) and (m_MagicSkill_241.btLevel < g_Config.nNGSkillMaxLevel) then begin
                  nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_241NGStrong[0] + (m_MagicSkill_241.btLevel - 3) * g_Config.nSKILL_241NGStrong[1]);
                  nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_241NGStrong[2] + (m_MagicSkill_241.btLevel - 3) * g_Config.nSKILL_241NGStrong[3]);
                  if (m_NGLevel >= nNeedNGLevel) and (nNeedItemCount > 0) then begin //判断内功等级是否达到
                    if CheckItemCount(nNeedItemCount) then begin //升级技能
                      Inc(m_MagicSkill_241.btLevel);
                      if (m_MagicSkill_241.btLevel > 2) and (m_MagicSkill_241.btLevel < g_Config.nNGSkillMaxLevel) then begin
                        nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_241NGStrong[0] + (m_MagicSkill_241.btLevel - 3) * g_Config.nSKILL_241NGStrong[1]);
                        nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_241NGStrong[2] + (m_MagicSkill_241.btLevel - 3) * g_Config.nSKILL_241NGStrong[3]);
                      end else begin
                        nNeedNGLevel := 0;
                        nNeedItemCount := 0;
                      end;
                      SendMsg(Self, RM_NGMAGIC_LVEXP, m_MagicSkill_241.MagicInfo.wMagicId, nNeedNGLevel, m_MagicSkill_241.btLevel, nNeedItemCount, '');
                    end;
                  end;
                end;
              end;
{$IFEND}
            end;
          Skill_228: begin //怒之灭天火强化
              if m_MagicSkill_228 <> nil then begin
                if (m_MagicSkill_228.btLevel > 2) and (m_MagicSkill_228.btLevel < g_Config.nNGSkillMaxLevel) then begin
                  nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_228NGStrong[0] + (m_MagicSkill_228.btLevel - 3) * g_Config.nSKILL_228NGStrong[1]);
                  nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_228NGStrong[2] + (m_MagicSkill_228.btLevel - 3) * g_Config.nSKILL_228NGStrong[3]);
                  if (m_NGLevel >= nNeedNGLevel) and (nNeedItemCount > 0) then begin //判断内功等级是否达到
                    if CheckItemCount(nNeedItemCount) then begin //升级技能
                      Inc(m_MagicSkill_228.btLevel);
                      if (m_MagicSkill_228.btLevel > 2) and (m_MagicSkill_228.btLevel < g_Config.nNGSkillMaxLevel) then begin
                        nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_228NGStrong[0] + (m_MagicSkill_228.btLevel - 3) * g_Config.nSKILL_228NGStrong[1]);
                        nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_228NGStrong[2] + (m_MagicSkill_228.btLevel - 3) * g_Config.nSKILL_228NGStrong[3]);
                      end else begin
                        nNeedNGLevel := 0;
                        nNeedItemCount := 0;
                      end;
                      SendMsg(Self, RM_NGMAGIC_LVEXP, m_MagicSkill_228.MagicInfo.wMagicId, nNeedNGLevel, m_MagicSkill_228.btLevel, nNeedItemCount, '');
                    end;
                  end;
                end;
              end;
            end;
          Skill_234: begin //怒之流星火雨强化
              if m_MagicSkill_234 <> nil then begin
                if (m_MagicSkill_234.btLevel > 2) and (m_MagicSkill_234.btLevel < g_Config.nNGSkillMaxLevel) then begin
                  nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_234NGStrong[0] + (m_MagicSkill_234.btLevel - 3) * g_Config.nSKILL_234NGStrong[1]);
                  nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_234NGStrong[2] + (m_MagicSkill_234.btLevel - 3) * g_Config.nSKILL_234NGStrong[3]);
                  if (m_NGLevel >= nNeedNGLevel) and (nNeedItemCount > 0) then begin //判断内功等级是否达到
                    if CheckItemCount(nNeedItemCount) then begin //升级技能
                      Inc(m_MagicSkill_234.btLevel);
                      if (m_MagicSkill_234.btLevel > 2) and (m_MagicSkill_234.btLevel < g_Config.nNGSkillMaxLevel) then begin
                        nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_234NGStrong[0] + (m_MagicSkill_234.btLevel - 3) * g_Config.nSKILL_234NGStrong[1]);
                        nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_234NGStrong[2] + (m_MagicSkill_234.btLevel - 3) * g_Config.nSKILL_234NGStrong[3]);
                      end else begin
                        nNeedNGLevel := 0;
                        nNeedItemCount := 0;
                      end;
                      SendMsg(Self, RM_NGMAGIC_LVEXP, m_MagicSkill_234.MagicInfo.wMagicId, nNeedNGLevel, m_MagicSkill_234.btLevel, nNeedItemCount, '');
                    end;
                  end;
                end;
              end;
            end;
          Skill_208: begin //怒之火球强化
              if m_MagicSkill_208 <> nil then begin
                if (m_MagicSkill_208.btLevel > 2) and (m_MagicSkill_208.btLevel < g_Config.nNGSkillMaxLevel) then begin
                  nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_208NGStrong[0] + (m_MagicSkill_208.btLevel - 3) * g_Config.nSKILL_208NGStrong[1]);
                  nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_208NGStrong[2] + (m_MagicSkill_208.btLevel - 3) * g_Config.nSKILL_208NGStrong[3]);
                  if (m_NGLevel >= nNeedNGLevel) and (nNeedItemCount > 0) then begin //判断内功等级是否达到
                    if CheckItemCount(nNeedItemCount) then begin //升级技能
                      Inc(m_MagicSkill_208.btLevel);
                      if (m_MagicSkill_208.btLevel > 2) and (m_MagicSkill_208.btLevel < g_Config.nNGSkillMaxLevel) then begin
                        nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_208NGStrong[0] + (m_MagicSkill_208.btLevel - 3) * g_Config.nSKILL_208NGStrong[1]);
                        nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_208NGStrong[2] + (m_MagicSkill_208.btLevel - 3) * g_Config.nSKILL_208NGStrong[3]);
                      end else begin
                        nNeedNGLevel := 0;
                        nNeedItemCount := 0;
                      end;
                      SendMsg(Self, RM_NGMAGIC_LVEXP, m_MagicSkill_208.MagicInfo.wMagicId, nNeedNGLevel, m_MagicSkill_208.btLevel, nNeedItemCount, '');
                    end;
                  end;
                end;
              end;
            end;
          Skill_214: begin //怒之地狱火强化
              if m_MagicSkill_214 <> nil then begin
                if (m_MagicSkill_214.btLevel > 2) and (m_MagicSkill_214.btLevel < g_Config.nNGSkillMaxLevel) then begin
                  nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_214NGStrong[0] + (m_MagicSkill_214.btLevel - 3) * g_Config.nSKILL_214NGStrong[1]);
                  nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_214NGStrong[2] + (m_MagicSkill_214.btLevel - 3) * g_Config.nSKILL_214NGStrong[3]);
                  if (m_NGLevel >= nNeedNGLevel) and (nNeedItemCount > 0) then begin //判断内功等级是否达到
                    if CheckItemCount(nNeedItemCount) then begin //升级技能
                      Inc(m_MagicSkill_214.btLevel);
                      if (m_MagicSkill_214.btLevel > 2) and (m_MagicSkill_214.btLevel < g_Config.nNGSkillMaxLevel) then begin
                        nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_214NGStrong[0] + (m_MagicSkill_214.btLevel - 3) * g_Config.nSKILL_214NGStrong[1]);
                        nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_214NGStrong[2] + (m_MagicSkill_214.btLevel - 3) * g_Config.nSKILL_214NGStrong[3]);
                      end else begin
                        nNeedNGLevel := 0;
                        nNeedItemCount := 0;
                      end;
                      SendMsg(Self, RM_NGMAGIC_LVEXP, m_MagicSkill_214.MagicInfo.wMagicId, nNeedNGLevel, m_MagicSkill_214.btLevel, nNeedItemCount, '');
                    end;
                  end;
                end;
              end;
            end;
          Skill_218: begin //怒之爆裂火焰强化
              if m_MagicSkill_218 <> nil then begin
                if (m_MagicSkill_218.btLevel > 2) and (m_MagicSkill_218.btLevel < g_Config.nNGSkillMaxLevel) then begin
                  nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_218NGStrong[0] + (m_MagicSkill_218.btLevel - 3) * g_Config.nSKILL_218NGStrong[1]);
                  nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_218NGStrong[2] + (m_MagicSkill_218.btLevel - 3) * g_Config.nSKILL_218NGStrong[3]);
                  if (m_NGLevel >= nNeedNGLevel) and (nNeedItemCount > 0) then begin //判断内功等级是否达到
                    if CheckItemCount(nNeedItemCount) then begin //升级技能
                      Inc(m_MagicSkill_218.btLevel);
                      if (m_MagicSkill_218.btLevel > 2) and (m_MagicSkill_218.btLevel < g_Config.nNGSkillMaxLevel) then begin
                        nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_218NGStrong[0] + (m_MagicSkill_218.btLevel - 3) * g_Config.nSKILL_218NGStrong[1]);
                        nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_218NGStrong[2] + (m_MagicSkill_218.btLevel - 3) * g_Config.nSKILL_218NGStrong[3]);
                      end else begin
                        nNeedNGLevel := 0;
                        nNeedItemCount := 0;
                      end;
                      SendMsg(Self, RM_NGMAGIC_LVEXP, m_MagicSkill_218.MagicInfo.wMagicId, nNeedNGLevel, m_MagicSkill_218.btLevel, nNeedItemCount, '');
                    end;
                  end;
                end;
              end;
            end;
          Skill_222: begin //怒之雷电强化
              if m_MagicSkill_222 <> nil then begin
                if (m_MagicSkill_222.btLevel > 2) and (m_MagicSkill_222.btLevel < g_Config.nNGSkillMaxLevel) then begin
                  nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_222NGStrong[0] + (m_MagicSkill_222.btLevel - 3) * g_Config.nSKILL_222NGStrong[1]);
                  nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_222NGStrong[2] + (m_MagicSkill_222.btLevel - 3) * g_Config.nSKILL_222NGStrong[3]);
                  if (m_NGLevel >= nNeedNGLevel) and (nNeedItemCount > 0) then begin //判断内功等级是否达到
                    if CheckItemCount(nNeedItemCount) then begin //升级技能
                      Inc(m_MagicSkill_222.btLevel);
                      if (m_MagicSkill_222.btLevel > 2) and (m_MagicSkill_222.btLevel < g_Config.nNGSkillMaxLevel) then begin
                        nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_222NGStrong[0] + (m_MagicSkill_222.btLevel - 3) * g_Config.nSKILL_222NGStrong[1]);
                        nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_222NGStrong[2] + (m_MagicSkill_222.btLevel - 3) * g_Config.nSKILL_222NGStrong[3]);
                      end else begin
                        nNeedNGLevel := 0;
                        nNeedItemCount := 0;
                      end;
                      SendMsg(Self, RM_NGMAGIC_LVEXP, m_MagicSkill_222.MagicInfo.wMagicId, nNeedNGLevel, m_MagicSkill_222.btLevel, nNeedItemCount, '');
                    end;
                  end;
                end;
              end;
            end;
          Skill_210: begin //怒之大火球强化
              if m_MagicSkill_210 <> nil then begin
                if (m_MagicSkill_210.btLevel > 2) and (m_MagicSkill_210.btLevel < g_Config.nNGSkillMaxLevel) then begin
                  nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_210NGStrong[0] + (m_MagicSkill_210.btLevel - 3) * g_Config.nSKILL_210NGStrong[1]);
                  nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_210NGStrong[2] + (m_MagicSkill_210.btLevel - 3) * g_Config.nSKILL_210NGStrong[3]);
                  if (m_NGLevel >= nNeedNGLevel) and (nNeedItemCount > 0) then begin //判断内功等级是否达到
                    if CheckItemCount(nNeedItemCount) then begin //升级技能
                      Inc(m_MagicSkill_210.btLevel);
                      if (m_MagicSkill_210.btLevel > 2) and (m_MagicSkill_210.btLevel < g_Config.nNGSkillMaxLevel) then begin
                        nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_210NGStrong[0] + (m_MagicSkill_210.btLevel - 3) * g_Config.nSKILL_210NGStrong[1]);
                        nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_210NGStrong[2] + (m_MagicSkill_210.btLevel - 3) * g_Config.nSKILL_210NGStrong[3]);
                      end else begin
                        nNeedNGLevel := 0;
                        nNeedItemCount := 0;
                      end;
                      SendMsg(Self, RM_NGMAGIC_LVEXP, m_MagicSkill_210.MagicInfo.wMagicId, nNeedNGLevel, m_MagicSkill_210.btLevel, nNeedItemCount, '');
                    end;
                  end;
                end;
              end;
            end;
          Skill_212: begin //怒之火墙强化
              if m_MagicSkill_212 <> nil then begin
                if (m_MagicSkill_212.btLevel > 2) and (m_MagicSkill_212.btLevel < g_Config.nNGSkillMaxLevel) then begin
                  nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_212NGStrong[0] + (m_MagicSkill_212.btLevel - 3) * g_Config.nSKILL_212NGStrong[1]);
                  nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_212NGStrong[2] + (m_MagicSkill_212.btLevel - 3) * g_Config.nSKILL_212NGStrong[3]);
                  if (m_NGLevel >= nNeedNGLevel) and (nNeedItemCount > 0) then begin //判断内功等级是否达到
                    if CheckItemCount(nNeedItemCount) then begin //升级技能
                      Inc(m_MagicSkill_212.btLevel);
                      if (m_MagicSkill_212.btLevel > 2) and (m_MagicSkill_212.btLevel < g_Config.nNGSkillMaxLevel) then begin
                        nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_212NGStrong[0] + (m_MagicSkill_212.btLevel - 3) * g_Config.nSKILL_212NGStrong[1]);
                        nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_212NGStrong[2] + (m_MagicSkill_212.btLevel - 3) * g_Config.nSKILL_212NGStrong[3]);
                      end else begin
                        nNeedNGLevel := 0;
                        nNeedItemCount := 0;
                      end;
                      SendMsg(Self, RM_NGMAGIC_LVEXP, m_MagicSkill_212.MagicInfo.wMagicId, nNeedNGLevel, m_MagicSkill_212.btLevel, nNeedItemCount, '');
                    end;
                  end;
                end;
              end;
            end;
          Skill_216: begin //怒之疾光电影强化
              if m_MagicSkill_216 <> nil then begin
                if (m_MagicSkill_216.btLevel > 2) and (m_MagicSkill_216.btLevel < g_Config.nNGSkillMaxLevel) then begin
                  nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_216NGStrong[0] + (m_MagicSkill_216.btLevel - 3) * g_Config.nSKILL_216NGStrong[1]);
                  nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_216NGStrong[2] + (m_MagicSkill_216.btLevel - 3) * g_Config.nSKILL_216NGStrong[3]);
                  if (m_NGLevel >= nNeedNGLevel) and (nNeedItemCount > 0) then begin //判断内功等级是否达到
                    if CheckItemCount(nNeedItemCount) then begin //升级技能
                      Inc(m_MagicSkill_216.btLevel);
                      if (m_MagicSkill_216.btLevel > 2) and (m_MagicSkill_216.btLevel < g_Config.nNGSkillMaxLevel) then begin
                        nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_216NGStrong[0] + (m_MagicSkill_216.btLevel - 3) * g_Config.nSKILL_216NGStrong[1]);
                        nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_216NGStrong[2] + (m_MagicSkill_216.btLevel - 3) * g_Config.nSKILL_216NGStrong[3]);
                      end else begin
                        nNeedNGLevel := 0;
                        nNeedItemCount := 0;
                      end;
                      SendMsg(Self, RM_NGMAGIC_LVEXP, m_MagicSkill_216.MagicInfo.wMagicId, nNeedNGLevel, m_MagicSkill_216.btLevel, nNeedItemCount, '');
                    end;
                  end;
                end;
              end;
            end;
          Skill_224: begin //怒之地狱雷光强化
              if m_MagicSkill_224 <> nil then begin
                if (m_MagicSkill_224.btLevel > 2) and (m_MagicSkill_224.btLevel < g_Config.nNGSkillMaxLevel) then begin
                  nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_224NGStrong[0] + (m_MagicSkill_224.btLevel - 3) * g_Config.nSKILL_224NGStrong[1]);
                  nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_224NGStrong[2] + (m_MagicSkill_224.btLevel - 3) * g_Config.nSKILL_224NGStrong[3]);
                  if (m_NGLevel >= nNeedNGLevel) and (nNeedItemCount > 0) then begin //判断内功等级是否达到
                    if CheckItemCount(nNeedItemCount) then begin //升级技能
                      Inc(m_MagicSkill_224.btLevel);
                      if (m_MagicSkill_224.btLevel > 2) and (m_MagicSkill_224.btLevel < g_Config.nNGSkillMaxLevel) then begin
                        nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_224NGStrong[0] + (m_MagicSkill_224.btLevel - 3) * g_Config.nSKILL_224NGStrong[1]);
                        nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_224NGStrong[2] + (m_MagicSkill_224.btLevel - 3) * g_Config.nSKILL_224NGStrong[3]);
                      end else begin
                        nNeedNGLevel := 0;
                        nNeedItemCount := 0;
                      end;
                      SendMsg(Self, RM_NGMAGIC_LVEXP, m_MagicSkill_224.MagicInfo.wMagicId, nNeedNGLevel, m_MagicSkill_224.btLevel, nNeedItemCount, '');
                    end;
                  end;
                end;
              end;
            end;
          Skill_226: begin //怒之寒冰掌强化
              if m_MagicSkill_226 <> nil then begin
                if (m_MagicSkill_226.btLevel > 2) and (m_MagicSkill_226.btLevel < g_Config.nNGSkillMaxLevel) then begin
                  nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_226NGStrong[0] + (m_MagicSkill_226.btLevel - 3) * g_Config.nSKILL_226NGStrong[1]);
                  nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_226NGStrong[2] + (m_MagicSkill_226.btLevel - 3) * g_Config.nSKILL_226NGStrong[3]);
                  if (m_NGLevel >= nNeedNGLevel) and (nNeedItemCount > 0) then begin //判断内功等级是否达到
                    if CheckItemCount(nNeedItemCount) then begin //升级技能
                      Inc(m_MagicSkill_226.btLevel);
                      if (m_MagicSkill_226.btLevel > 2) and (m_MagicSkill_226.btLevel < g_Config.nNGSkillMaxLevel) then begin
                        nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_226NGStrong[0] + (m_MagicSkill_226.btLevel - 3) * g_Config.nSKILL_226NGStrong[1]);
                        nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_226NGStrong[2] + (m_MagicSkill_226.btLevel - 3) * g_Config.nSKILL_226NGStrong[3]);
                      end else begin
                        nNeedNGLevel := 0;
                        nNeedItemCount := 0;
                      end;
                      SendMsg(Self, RM_NGMAGIC_LVEXP, m_MagicSkill_226.MagicInfo.wMagicId, nNeedNGLevel, m_MagicSkill_226.btLevel, nNeedItemCount, '');
                    end;
                  end;
                end;
              end;
            end;
          Skill_220: begin //怒之冰咆哮强化
              if m_MagicSkill_220 <> nil then begin
                if (m_MagicSkill_220.btLevel > 2) and (m_MagicSkill_220.btLevel < g_Config.nNGSkillMaxLevel) then begin
                  nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_220NGStrong[0] + (m_MagicSkill_220.btLevel - 3) * g_Config.nSKILL_220NGStrong[1]);
                  nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_220NGStrong[2] + (m_MagicSkill_220.btLevel - 3) * g_Config.nSKILL_220NGStrong[3]);
                  if (m_NGLevel >= nNeedNGLevel) and (nNeedItemCount > 0) then begin //判断内功等级是否达到
                    if CheckItemCount(nNeedItemCount) then begin //升级技能
                      Inc(m_MagicSkill_220.btLevel);
                      if (m_MagicSkill_220.btLevel > 2) and (m_MagicSkill_220.btLevel < g_Config.nNGSkillMaxLevel) then begin
                        nNeedNGLevel := _MIN(High(Word), g_Config.nSKILL_220NGStrong[0] + (m_MagicSkill_220.btLevel - 3) * g_Config.nSKILL_220NGStrong[1]);
                        nNeedItemCount := _MIN(High(Word), g_Config.nSKILL_220NGStrong[2] + (m_MagicSkill_220.btLevel - 3) * g_Config.nSKILL_220NGStrong[3]);
                      end else begin
                        nNeedNGLevel := 0;
                        nNeedItemCount := 0;
                      end;
                      SendMsg(Self, RM_NGMAGIC_LVEXP, m_MagicSkill_220.MagicInfo.wMagicId, nNeedNGLevel, m_MagicSkill_220.btLevel, nNeedItemCount, '');
                    end;
                  end;
                end;
              end;
            end;
        end; //case wMagIdx
      finally
        m_boCanQueryBag := False; //不能刷新包裹
      end;
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientUpNGStrongSkill MagIdx:%d', [g_sExceptionVer, wMagIdx]));
  end;
end;

procedure TPlayObject.SendQueryDivision(nPage: Integer);
var
  sLog, sDivisionName: string;
  Division: TDivision;
  ClientDivisionInfo: TClientDivisionInfo;
  I, K: Integer;
  nType: Byte;
begin
  if nPage > g_DivisionManager.DivisionList.Count - 1 then Exit;
  sDivisionName := g_DivisionManager.LoadUserApplyInfo(m_sCharName); //查询是否正在进行申请
  nType := 0;
  if sDivisionName <> '' then nType := 1;
  if m_MyDivision <> nil then nType := 2; //已加入过门派
  K := 0;
  sLog := '';
  for I := nPage * 5 to g_DivisionManager.DivisionList.Count - 1 do begin
    if K > 4 then Break;
    Division := TDivision(g_DivisionManager.DivisionList.Items[I]);
    if Division <> nil then begin
      ClientDivisionInfo.sDivisionName := Division.sDivisionName;
      ClientDivisionInfo.sChrName := Division.GetChiefName();
      ClientDivisionInfo.nPopularity := Division.nPopularity;
      case nType of
        0, 2: ClientDivisionInfo.nStatus := nType;
        1: begin
            if ClientDivisionInfo.sDivisionName = sDivisionName then
              ClientDivisionInfo.nStatus := 1
            else ClientDivisionInfo.nStatus := 2;
          end;
      end;
      if Division.nDivisonType = 1 then ClientDivisionInfo.sChrName := ''; //公共门派无师父名
      sLog := sLog + EncodeBuffer(@ClientDivisionInfo, SizeOf(TClientDivisionInfo)) + '/';
      Inc(K);
    end;
  end;
  SendMsg(self, RM_QUERYDIVISIONLIST, 0, 0, 0, 0, sLog);
end;
//查看申请入门派窗口

procedure TPlayObject.ClientQueryDivision(nPage {0-上一页 1-下一页}: Byte);
  function GetPageCount(nListCount: Integer): Integer;
  begin
    Result := 0;
    if nListCount > 0 then begin
      Result := nListCount div 5;
      if (nListCount mod 5) > 0 then Inc(Result);
      Dec(Result);
    end;
  end;
begin
  try
    if m_boDeath or m_boGhost or m_boAI or m_boNotOnlineAddExp then Exit;
    case nPage of
      0: begin //上一页
          if m_nApplyDivisionPage > 0 then
            Dec(m_nApplyDivisionPage)
          else m_nApplyDivisionPage := 0;
        end;
      1: begin //下一页
          if GetPageCount(g_DivisionManager.DivisionList.Count) > m_nApplyDivisionPage then begin
            Inc(m_nApplyDivisionPage);
          end;
        end;
    end;
    SendQueryDivision(m_nApplyDivisionPage);
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientQueryDivision', [g_sExceptionVer]));
  end;
end;

//申请入门派窗口,按宗师名查询门派数据

procedure TPlayObject.ClientNameQueryDivision(sUserName: string);
var
  sLog, sDivisionName: string;
  Division: TDivision;
  ClientDivisionInfo: TClientDivisionInfo;
  nType: Byte; //0-全显示"申请加入" 1-根据结构字段显示"取消申请" 2-不显示"申请加入","取消申请"
begin
  try
    if m_boDeath or m_boGhost or m_boAI or m_boNotOnlineAddExp then Exit;
    if sUserName <> '' then begin
      sLog := '';
      sDivisionName := g_DivisionManager.LoadUserApplyInfo(m_sCharName); //查询是否正在进行申请
      if sDivisionName <> '' then nType := 1;
      if m_MyDivision <> nil then nType := 2; //已加入过门派
      Division := g_DivisionManager.FindDivisionEx(sUserName);
      if Division <> nil then begin
        ClientDivisionInfo.sDivisionName := Division.sDivisionName;
        ClientDivisionInfo.sChrName := Division.GetChiefName();
        ClientDivisionInfo.nPopularity := Division.nPopularity;
        case nType of
          0, 2: ClientDivisionInfo.nStatus := nType;
          1: begin
              if CompareText(ClientDivisionInfo.sDivisionName, sDivisionName) = 0 then
                ClientDivisionInfo.nStatus := 1
              else ClientDivisionInfo.nStatus := 2;
            end;
        end;
        if Division.nDivisonType = 1 then ClientDivisionInfo.sChrName := ''; //公共门派无师父名
        sLog := EncodeBuffer(@ClientDivisionInfo, SizeOf(TClientDivisionInfo)) + '/';
      end;
      SendMsg(self, RM_QUERYDIVISIONLIST, 0, 0, 0, 0, sLog);
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientNameQueryDivision', [g_sExceptionVer]));
  end;
end;
//申请(取消)入门派

procedure TPlayObject.ClientApplyDivision(sDivisionName: string);
var
  sName: string;
  Division: TDivision;
  nCode: Byte;
begin
  try
    nCode := 0;
    if m_boDeath or m_boGhost or m_boAI or m_boNotOnlineAddExp then Exit;
    if m_MyDivision <> nil then Exit; //已加入过门派
    if m_boTrainingNG then begin
      nCode := 1;
      sName := g_DivisionManager.LoadUserApplyInfo(m_sCharName); //查询是否正在进行申请
      nCode := 2;
      if (sName <> '') then begin //正在进行申请中
        if CompareText(sName, sDivisionName) = 0 then begin //名字一样则取消申请
          nCode := 3;
          Division := g_DivisionManager.FindDivision(sDivisionName);
          if Division <> nil then begin
            nCode := 4;
            if Division.DelApplyMember(m_sCharName) then
              g_DivisionManager.SaveUserApplyList(m_sCharName, ''); //保存申请入门的名单
          end;
        end;
      end else begin
        if (m_Abil.Level >= g_Config.nApplyDivisionLevel) then begin
          nCode := 5;
          Division := g_DivisionManager.FindDivision(sDivisionName);
          if Division <> nil then begin
            nCode := 6;
            if Division.ApplyMember(Self) = 1 then begin
              nCode := 7;
              g_DivisionManager.SaveUserApplyList(m_sCharName, sDivisionName); //保存申请入门的名单
            end;
          end;
        end else SysMsg(Format('您必须突破%d级并且学会内功才能加入门派', [g_Config.nApplyDivisionLevel]), c_Green, t_Say);
      end;
      SendQueryDivision(m_nApplyDivisionPage);
    end else SysMsg('您必须学会内功才能加入门派', c_Green, t_Say);
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientApplyDivision Code:%d', [g_sExceptionVer, nCode]));
  end;
end;
//门派老大同意加入门派

procedure TPlayObject.ClientAgreeDivisionApply(sUserName: string);
var
  PlayHum: TPlayObject;
  nC, I: Integer;
  TempList: TStringList;
  sName: string;
  //boRefList: Boolean;
begin
  try
    if m_boDeath or m_boGhost or m_boAI or m_boNotOnlineAddExp then Exit;
    if (m_MyDivision <> nil) and (sUserName <> '') then begin //已加入过门派
      nC := 1; //'你没有权利使用这个命令。'
      if CompareText(TDivision(m_MyDivision).GetChiefName, m_sCharName) = 0 then begin //是否为门派老大
        //boRefList:= False;
        TempList := TStringList.Create;
        try
          ExtractStrings(['|'], [], PChar(sUserName), TempList);
          for I := 0 to TempList.Count - 1 do begin
            sName := TempList.Strings[I];
            if not TDivision(m_MyDivision).IsMember(sName) then begin //是否在当前门派成员列表中
              if g_DivisionManager.MemberOfDivision(sName) = nil then begin
                if not TDivision(m_MyDivision).IsFull then begin
                  if TDivision(m_MyDivision).IsApplyUser(sName) then begin
                    PlayHum := UserEngine.GetPlayObjectEx1(sName);
                    if PlayHum <> nil then begin
                      if TDivision(m_MyDivision).AddMember(PlayHum, sName) then begin
                        if TDivision(m_MyDivision).DelApplyMember(sName) then //清除申请列表数据
                          g_DivisionManager.SaveUserApplyList(sName, ''); //保存申请入门的名单
                        PlayHum.m_MyDivision := TDivision(m_MyDivision);
                        if TDivision(m_MyDivision).nDivisonType = 0 then
                          PlayHum.SysMsg(Format('%s同意了你的入派的请求', [TDivision(m_MyDivision).GetChiefName]), c_Green, t_Hint)
                        else PlayHum.SysMsg(Format('%s同意了你的入派的请求', [TDivision(m_MyDivision).sDivisionName]), c_Green, t_Hint);
                        SysMsg(Format('%s加入门派成功！', [sName]), c_Green, t_Hint);
                        //boRefList:= True;
                      end;
                    end else begin //角色没在线
                      if TDivision(m_MyDivision).AddMember(nil, sName) then begin
                        if TDivision(m_MyDivision).DelApplyMember(sName) then //清除申请列表数据
                          g_DivisionManager.SaveUserApplyList(sName, ''); //保存申请入门的名单
                        SysMsg(Format('%s加入门派成功！', [sName]), c_Green, t_Hint);
                      end;
                    end;
                  end else begin
                    SysMsg(Format('%s没申请加入本门派！', [sName]), c_Green, t_Hint);
                    if TDivision(m_MyDivision).DelApplyMember(sName) then //清除申请列表数据
                      g_DivisionManager.SaveUserApplyList(sName, ''); //保存申请入门的名单
                  end;
                end else begin
                  nC := 2;
                  if TDivision(m_MyDivision).DelApplyMember(sName) then //清除申请列表数据
                    g_DivisionManager.SaveUserApplyList(sName, ''); //保存申请入门的名单
                end;
              end else begin
                SysMsg(Format('%s已有其它门派！', [TDivision(m_MyDivision).sDivisionName]), c_Green, t_Hint);
                if TDivision(m_MyDivision).DelApplyMember(sName) then //清除申请列表数据
                  g_DivisionManager.SaveUserApplyList(sName, ''); //保存申请入门的名单
              end;
            end else begin
              SysMsg(Format('%s已存在于门派中,不能重复加入！', [TDivision(m_MyDivision).sDivisionName]), c_Green, t_Hint);
              if TDivision(m_MyDivision).DelApplyMember(sName) then //清除申请列表数据
                g_DivisionManager.SaveUserApplyList(sName, ''); //保存申请入门的名单
            end;
          end;
          ClientDivisionApplyList; //取申请入门列表
          //if boRefList then ClientDivisionMemberList;//发送成员列表
        finally
          TempList.Free;
        end;
      end else SysMsg('非门派掌门不能执行此命令！', c_Green, t_Hint);
      if nC = 2 then SysMsg('接受入派失败，可能门派中申请人数已达上限！', c_Blue, t_Hint);
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientAgreeDivisionApply', [g_sExceptionVer]));
  end;
end;
//门派老大取消加入师门申请

procedure TPlayObject.ClientCancelDivisionApply(sUserName: string);
var
  PlayHum: TPlayObject;
  I: Integer;
  TempList: TStringList;
  sName: string;
begin
  try
    if m_boDeath or m_boGhost or m_boAI or m_boNotOnlineAddExp then Exit;
    if (m_MyDivision <> nil) and (sUserName <> '') then begin //已加入过门派
      if CompareText(TDivision(m_MyDivision).GetChiefName, m_sCharName) = 0 then begin //是否为门派老大
        TempList := TStringList.Create;
        try
          ExtractStrings(['|'], [], PChar(sUserName), TempList);
          for I := 0 to TempList.Count - 1 do begin
            sName := TempList.Strings[I];
            if TDivision(m_MyDivision).IsApplyUser(sName) then begin
              if TDivision(m_MyDivision).DelApplyMember(sName) then begin //清除申请列表数据
                g_DivisionManager.SaveUserApplyList(sName, ''); //保存申请入门的名单
                PlayHum := UserEngine.GetPlayObjectEx1(sName);
                if PlayHum <> nil then
                  PlayHum.SysMsg(Format('%s拒绝了你的入派的请求', [TDivision(m_MyDivision).GetChiefName]), c_Green, t_Hint);
                SysMsg(Format('您拒绝了%s的入派的请求', [sName]), c_Blue, t_Hint);
              end;
            end;
          end;
          ClientDivisionApplyList; //取申请入门列表
        finally
          TempList.Free;
        end;
      end;
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientCancelDivisionApply', [g_sExceptionVer]));
  end;
end;
//门派删除成员(老大把弟子逐出门派)

procedure TPlayObject.ClientDelDivisionUser(sUserName: string);
var
  nC: Integer;
  s14: string;
  PlayObject: TPlayObject;
begin
  try
    if m_boDeath or m_boGhost or m_boAI or m_boNotOnlineAddExp then Exit;
    if (m_MyDivision <> nil) and (sUserName <> '') then begin //已加入过门派
      nC := 1;
      if CompareText(TDivision(m_MyDivision).GetChiefName, m_sCharName) = 0 then begin //是否为门派老大
        if TDivision(m_MyDivision).IsMember(sUserName) then begin
          if m_sCharName <> sUserName then begin
            if TDivision(m_MyDivision).DelMember(sUserName) then begin
              PlayObject := UserEngine.GetPlayObjectEx1(sUserName);
              if PlayObject <> nil then begin
                PlayObject.SysMsg(Format('您退出了门派%s', [TDivision(m_MyDivision).sDivisionName]), c_Green, t_Hint);

                if (PlayObject.m_MagicSkill_105 = nil) then begin
                    PlayObject.m_sHeartName := ''; //心法名称
                    PlayObject.m_nHeartType := 0; //心法类型
                    PlayObject.DelItemSkill(7); //删除传承心法
                    PlayObject.m_MyDivision := nil;
                    PlayObject.ClearIncreaseSkillLevel(); //清除强化技能等级
                    PlayObject.m_dwStatusArrTimeOutTick[21] := 0;
                    PlayObject.RecalcAbilitys();
                    PlayObject.CompareSuitItem(False);
                    PlayObject.SendMsg(PlayObject, RM_ABILITY, 0, 0, 0, 0, '');
                end;
                PlayObject.m_Contribution := 0;
                PlayObject.CmdUserCmd('@ExitDivision'); //退出师门触发
              end;
              TDivision(m_MyDivision).SendDivisionMsg(sUserName + ' 已经正式离开了本门派');
              nC := 0;
              SendDefMessage(SM_DIVISIONDDELMEMBER_OK, 0, 0, 0, 0, '');
              ClientDivisionMemberList; //取门派成员列表
            end else nC := 4;
          end else begin
            nC := 3;
            s14 := TDivision(m_MyDivision).sDivisionName;
            if TDivision(m_MyDivision).CancelDivision(sUserName) then begin
              if g_DivisionManager.DelDivision(s14) then begin
                m_MyDivision := nil;
                SysMsg('门派' + s14 + '已被取消！', c_Red, t_Hint);
                nC := 0;
                SendDefMessage(SM_DIVISIONDDELMEMBER_OK1, 0, 0, 0, 0, '');
                CmdUserCmd('@ExitDivision'); //退出师门触发
              end;
            end
          end;
        end else nC := 2;
      end else begin //自动退出门派
        if TDivision(m_MyDivision).IsMember(m_sCharName) then begin
          if TDivision(m_MyDivision).DelMember(m_sCharName) then begin
            TDivision(m_MyDivision).SendDivisionMsg(m_sCharName + ' 已经正式离开了本门派');
            SysMsg(Format('您退出了门派%s', [TDivision(m_MyDivision).sDivisionName]), c_Green, t_Hint);
            m_MyDivision := nil;
            m_sHeartName := ''; //心法名称
            m_nHeartType := 0; //心法类型
            m_Contribution := 0;
            DelItemSkill(7); //删除传承心法
            ClearIncreaseSkillLevel(); //清除强化技能等级
            m_dwStatusArrTimeOutTick[21] := 0;
            RecalcAbilitys();
            CompareSuitItem(False);
            SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');                   
            SendDefMessage(SM_DIVISIONDDELMEMBER_OK1, 0, 0, 0, 0, '');
            nC := 0;
            CmdUserCmd('@ExitDivision'); //退出师门触发
          end else nC := 4;
        end;
      end;
      if nC <> 0 then begin
        SendDefMessage(SM_DIVISIONDELMEMBER_FAIL, nC, 0, 0, 0, '');
      end;
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientDelDivisionUser', [g_sExceptionVer]));
  end;
end;
//修改门派公告

procedure TPlayObject.ClientDivisionUpdateNotice(sNotict: string);
var
  SC: string;
begin
  if Length(sNotict) > 1000 then sNotict := Copy(sNotict, 1, 1000); //限制公告长度
  if (m_MyDivision = nil) then Exit;
  if CompareText(TDivision(m_MyDivision).GetChiefName, m_sCharName) = 0 then begin //是否为门派老大
    TDivision(m_MyDivision).NoticeList.Clear;
    while (sNotict <> '') do begin
      sNotict := GetValidStr3(sNotict, SC, [#$D]);
      TDivision(m_MyDivision).NoticeList.Add(SC);
    end; // while
    TDivision(m_MyDivision).SaveDivisionInfoFile();
    ClientOpenDivisionDlg(); //打开门派对话框
  end;
end;
//客户端打开门派对话框

procedure TPlayObject.ClientOpenDivisionDlg;
var
  I: Integer;
  SC: string;
begin
  if m_MyDivision <> nil then begin
    SC := TDivision(m_MyDivision).sDivisionName + #13; //门派名
    if CompareText(TDivision(m_MyDivision).GetChiefName, m_sCharName) = 0 then begin //是否为门派老大
      SC := SC + '1' + #13;
    end else begin
      SC := SC + '0' + #13;
    end;
    if TDivision(m_MyDivision).sHeartName <> '' then
      SC := SC + TDivision(m_MyDivision).sHeartName + #13 //心法名
    else SC := SC + ' ' + #13;
    case TDivision(m_MyDivision).nHeartTpye of //心法属性
      0: SC := SC + '紫金' + #13; //心法属性
      1: SC := SC + '乙木' + #13; //心法属性
      2: SC := SC + '大地' + #13; //心法属性
      3: SC := SC + '葵水' + #13; //心法属性
      4: SC := SC + '阳炎' + #13; //心法属性
    end;
    if TDivision(m_MyDivision).nDivisonType = 0 then begin
      SC := SC + IntToStr(TDivision(m_MyDivision).nPopularity) + #13; //人气
      SC := SC + TDivision(m_MyDivision).GetChiefName + #13; //师父名
      SC := SC + IntToStr(TDivision(m_MyDivision).Count) + '/' + inttostr(TDivision(m_MyDivision).m_nDivisionMemberCount) + #13; //人数
    end else begin //公共门派
      SC := SC + '0' + #13; //人气
      SC := SC + ' ' + #13; //师父名
      SC := SC + IntToStr(TDivision(m_MyDivision).Count) + #13; //人数
    end;
    SC := SC + IntToStr(TDivision(m_MyDivision).nHeartLevel) + #13; //传承心法等级
    //SC := SC + '<Notice>' + #13;
    if TDivision(m_MyDivision).NoticeList.Count > 0 then begin //
      for I := 0 to TDivision(m_MyDivision).NoticeList.Count - 1 do begin //门派公告
        if Length(SC) > 1000 then Break;
        SC := SC + Trim(TDivision(m_MyDivision).NoticeList.Strings[I]) + #13; //增加Trim函数，防止客户端不停循环空格
      end; // for
    end;
    m_DefMsg := MakeDefaultMsg(SM_OPENDIVISIONDLG, 0, 0, 0, 1, 0);
    SendSocket(@m_DefMsg, EncodeString(SC));
  end else begin
    SendDefMessage(SM_OPENDIVISIONDLG_FAIL, 0, 0, 0, 0, '');
  end;
end;
//取门派成员列表

procedure TPlayObject.ClientDivisionMemberList;
var
  DivisionRank: pTDivisionRank;
  ClientDivision: TClientDivisionMember;
  I, II: Integer;
  sSENDMSG: string;
begin
  try
    if m_MyDivision = nil then Exit;
    if TDivision(m_MyDivision).m_RankList.Count > 0 then begin
      for I := 0 to TDivision(m_MyDivision).m_RankList.Count - 1 do begin
        DivisionRank := TDivision(m_MyDivision).m_RankList.Items[I];
        if DivisionRank = nil then Continue;
        sSENDMSG := sSENDMSG + '#' + IntToStr(DivisionRank.nRankNo) + '/';
        if DivisionRank.MemberList.Count > 0 then begin
          for II := 0 to DivisionRank.MemberList.Count - 1 do begin
            if Length(sSENDMSG) > 3000 then Break;
            ClientDivision.sChrName := DivisionRank.MemberList.Strings[II]; //成员姓名
            ClientDivision.DivisionMember := pTDivisionMember(DivisionRank.MemberList.Objects[II])^;
            sSENDMSG := sSENDMSG + EncodeBuffer(@ClientDivision, SizeOf(TClientDivisionMember)) + '/';
          end;
        end;
      end;
    end;
    m_DefMsg := MakeDefaultMsg(SM_SENDDIVISIONMEMBERLIST, 0, 0, 0, 1, 0);
    SendSocket(@m_DefMsg, EncodeString(sSENDMSG));
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientDivisionMemberList', [g_sExceptionVer]));
  end;
end;
//取申请入门列表

procedure TPlayObject.ClientDivisionApplyList;
var
  I, II: Integer;
  sSENDMSG: string;
  ApplyDivision: pTApplyDivision;
begin
  try
    if m_MyDivision = nil then Exit;
    if CompareText(TDivision(m_MyDivision).GetChiefName, m_sCharName) = 0 then begin //是否为门派老大
      sSENDMSG := '';
      if TDivision(m_MyDivision).nDivisonType <> 1 then begin //不是公共门派
        II := 0;
        for I := 0 to TDivision(m_MyDivision).ApplyList.Count - 1 do begin
          if II > 4 then Break;
          ApplyDivision := pTApplyDivision(TDivision(m_MyDivision).ApplyList.Objects[I]);
          if ApplyDivision = nil then Continue;
          sSENDMSG := sSENDMSG + ApplyDivision.sChrName + '/';
          Inc(II);
        end;
      end;
      m_DefMsg := MakeDefaultMsg(SM_SENDDIVISIONAPPLYLIST, 0, 0, 0, 0, 0);
      SendSocket(@m_DefMsg, EncodeString(sSENDMSG));
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientDivisionApplyList', [g_sExceptionVer]));
  end;
end;
//领悟龙卫心法

procedure TPlayObject.ClientSavvyHeartSkill(nHeart: byte; sSkillName: string);
var
  Magic: pTMagic;
  UserMagic: pTUserMagic;
begin
  try
    if m_boDeath or m_boGhost or m_boAI or m_boNotOnlineAddExp then Exit;
    if (nHeart < 5) and (sSkillName <> '') and (Length(sSkillName) < 13) then begin
      if IsOKHeratSkillName(sSkillName) then begin
        if m_boTrainingNG then begin
          if (m_Abil.Level >= g_Config.nSavvyHeartNeedLevel) then begin
            if m_MyDivision = nil then begin
              if (not IsTrainingSkill(SKILL_105)) then begin
                Magic := UserEngine.FindMagic(SKILL_105);
                if Magic <> nil then begin
                  New(UserMagic);
                  UserMagic.MagicInfo := Magic;
                  UserMagic.wMagIdx := Magic.wMagicId;
                  UserMagic.btKey := 0;
                  UserMagic.btLevel := 1;
                  UserMagic.nTranPoint := 0;
                  UserMagic.btLevelEx := 0;
                  m_MagicList.Add(UserMagic);
                  m_sHeartName := sSkillName; //心法名称
                  m_nHeartType := nHeart; //心法类型
                  SendAddMagic(UserMagic);
                  RecalcAbilitys();
                  CompareSuitItem(False);
                  SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
                  AddSkillFunc(Magic.wMagicId); //人物学技能触发
                  SysMsg('您已成功领悟龙卫心法！', c_Green, t_Say);
                  DoSendHeartInfo(); //发送心法相关数据
                  SendRefMsg(RM_10205, 37, 0 {X}, 0 {Y}, 0, ''); //显示特殊效果(龙升天效果)
                end;
              end else SysMsg('您不能重复进行龙卫心法领悟！', c_Green, t_Say);
            end else SysMsg('您已加入其它门派，不能进行龙卫心法领悟！', c_Green, t_Say);
          end else SysMsg(Format('您的等级不足%d,不能进行龙卫心法领悟！', [g_Config.nSavvyHeartNeedLevel]), c_Green, t_Say);
        end else SysMsg('您没学过内功心法,不能进行龙卫心法领悟！', c_Green, t_Say);
      end else SysMsg('自定义名称不合法！', c_Red, t_Say);
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientSavvyHeartSkill', [g_sExceptionVer]));
  end;
end;
//更换龙卫心法类型

procedure TPlayObject.ClientChangeSavvyHeartSkill(nHeart: byte);
begin
  try
    if m_boDeath or m_boGhost or m_boAI or m_boNotOnlineAddExp then Exit;
    if (nHeart < 5) then begin
      if IsTrainingSkill(SKILL_105) then begin
        m_nHeartType := nHeart; //心法类型
        SysMsg('转换心法成功！', c_Green, t_Say);
        if m_MyDivision <> nil then begin
          if CompareText(TDivision(m_MyDivision).GetChiefName, m_sCharName) = 0 then begin //是否为门派老大
            TDivision(m_MyDivision).nHeartTpye := m_nHeartType;
            TDivision(m_MyDivision).SaveDivisionConfig(g_Config.sDivisionDir + TDivision(m_MyDivision).sDivisionName + '.ini');
          end;
        end;
        DoSendHeartInfo(); //发送心法相关数据
      end else SysMsg('未学过龙卫心法，不能进行转换！', c_Red, t_Say);
    end else SysMsg('转换的心法类型不合法！', c_Red, t_Say);
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientChangeSavvyHeartSkill', [g_sExceptionVer]));
  end;
end;
//门派界面点击"领取称号",进入脚本触发段

procedure TPlayObject.ClientDivisionGetFengHao();
begin
  try
    if m_boDeath or m_boGhost or m_boAI or m_boNotOnlineAddExp or (m_MyDivision = nil) then Exit;
    if CompareText(TDivision(m_MyDivision).GetChiefName, m_sCharName) = 0 then begin //是否为门派老大
      CmdUserCmd('@DivisionGetFengHao');
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientDivisionGetFengHao', [g_sExceptionVer]));
  end;
end;
//点击Exp按键，执行QF脚本段(999心法吸收功能)

procedure TPlayObject.ClientIncHeartPoint();
begin
  try
    if m_boDeath or m_boGhost or m_boAI or m_boNotOnlineAddExp or
      (m_MagicSkill_105 = nil) or (not m_boTrainingNG) then Exit;
    if m_MagicSkill_105.btLevel > 99 then Exit;
    if m_Abil.nExp < g_Config.nIncHeartPointNeedExp * 10000 then begin
      SysMsg(Format('已累积经验%u，相差%u经验，无法使用！', [m_Abil.nExp, (g_Config.nIncHeartPointNeedExp * 10000 - m_Abil.nExp)]), c_Green, t_Hint);
      Exit;
    end;
    CmdUserCmd('@IncHeartPoint');
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientIncHeartPoint', [g_sExceptionVer]));
  end;
end;
//进行技能强化

procedure TPlayObject.IncreaseSkillLevel(UserMagic: pTUserMagic);
var
  boIncSkill: Boolean;
begin
  try
    if ((m_MagicSkill_105 <> nil) or (m_MagicSkill_106 <> nil)) and m_boTrainingNG and
      (UserMagic <> nil) then begin
      boIncSkill := False;
      if (UserMagic.btLevelEx < 9) and (Random(5) = 0) then begin
        case UserMagic.wMagIdx of
          SKILL_91 {91}: begin //四级雷电术
              if (m_MagicSkill_105 <> nil) then begin
                if m_MagicSkill_105.btLevel >= g_Config.nSKILL_91Strong[UserMagic.btLevelEx] then begin
                  Inc(UserMagic.btLevelEx);
                  boIncSkill := True;
                end;
              end else
                if (m_MagicSkill_106 <> nil) then begin
                  if m_MagicSkill_106.btLevel >= g_Config.nSKILL_91Strong[UserMagic.btLevelEx] then begin
                    Inc(UserMagic.btLevelEx);
                    boIncSkill := True;
                  end;
                end;
            end;
          SKILL_89 {89}: begin
              if (m_MagicSkill_105 <> nil) then begin
                if m_MagicSkill_105.btLevel >= g_Config.nSKILL_89Strong[UserMagic.btLevelEx] then begin
                  Inc(UserMagic.btLevelEx);
                  boIncSkill := True;
                end;
              end else
                if (m_MagicSkill_106 <> nil) then begin
                  if m_MagicSkill_106.btLevel >= g_Config.nSKILL_89Strong[UserMagic.btLevelEx] then begin
                    Inc(UserMagic.btLevelEx);
                    boIncSkill := True;
                  end;
                end;
            end;
          SKILL_90 {90}: begin
              if (m_MagicSkill_105 <> nil) then begin
                if m_MagicSkill_105.btLevel >= g_Config.nSKILL_90Strong[UserMagic.btLevelEx] then begin
                  Inc(UserMagic.btLevelEx);
                  boIncSkill := True;
                end;
              end else
                if (m_MagicSkill_106 <> nil) then begin
                  if m_MagicSkill_106.btLevel >= g_Config.nSKILL_90Strong[UserMagic.btLevelEx] then begin
                    Inc(UserMagic.btLevelEx);
                    boIncSkill := True;
                  end;
                end;
            end;
          SKILL_92 {92}: begin
              if (m_MagicSkill_105 <> nil) then begin
                if m_MagicSkill_105.btLevel >= g_Config.nSKILL_92Strong[UserMagic.btLevelEx] then begin
                  Inc(UserMagic.btLevelEx);
                  boIncSkill := True;
                end;
              end else
                if (m_MagicSkill_106 <> nil) then begin
                  if m_MagicSkill_106.btLevel >= g_Config.nSKILL_92Strong[UserMagic.btLevelEx] then begin
                    Inc(UserMagic.btLevelEx);
                    boIncSkill := True;
                  end;
                end;
            end;
          SKILL_93 {93}: begin
              if (m_MagicSkill_105 <> nil) then begin
                if m_MagicSkill_105.btLevel >= g_Config.nSKILL_93Strong[UserMagic.btLevelEx] then begin
                  Inc(UserMagic.btLevelEx);
                  boIncSkill := True;
                end;
              end else
                if (m_MagicSkill_106 <> nil) then begin
                  if m_MagicSkill_106.btLevel >= g_Config.nSKILL_93Strong[UserMagic.btLevelEx] then begin
                    Inc(UserMagic.btLevelEx);
                    boIncSkill := True;
                  end;
                end;
            end;
          SKILL_94 {94}: begin
              if (m_MagicSkill_105 <> nil) then begin
                if m_MagicSkill_105.btLevel >= g_Config.nSKILL_94Strong[UserMagic.btLevelEx] then begin
                  Inc(UserMagic.btLevelEx);
                  boIncSkill := True;
                end;
              end else
                if (m_MagicSkill_106 <> nil) then begin
                  if m_MagicSkill_106.btLevel >= g_Config.nSKILL_94Strong[UserMagic.btLevelEx] then begin
                    Inc(UserMagic.btLevelEx);
                    boIncSkill := True;
                  end;
                end;
            end;
          SKILL_YEDO {7}: begin
              if UserMagic.btLevel > 2 then begin
                if (m_MagicSkill_105 <> nil) then begin
                  if m_MagicSkill_105.btLevel >= g_Config.nSKILL_7Strong[UserMagic.btLevelEx] then begin
                    Inc(UserMagic.btLevelEx);
                    boIncSkill := True;
                  end;
                end else
                  if (m_MagicSkill_106 <> nil) then begin
                    if m_MagicSkill_106.btLevel >= g_Config.nSKILL_7Strong[UserMagic.btLevelEx] then begin
                      Inc(UserMagic.btLevelEx);
                      boIncSkill := True;
                    end;
                  end;
              end;
            end;
          SKILL_74 {74}: begin
              if UserMagic.btLevel > 2 then begin
                if (m_MagicSkill_105 <> nil) then begin
                  if m_MagicSkill_105.btLevel >= g_Config.nSKILL_74Strong[UserMagic.btLevelEx] then begin
                    Inc(UserMagic.btLevelEx);
                    boIncSkill := True;
                  end;
                end else
                  if (m_MagicSkill_106 <> nil) then begin
                    if m_MagicSkill_106.btLevel >= g_Config.nSKILL_74Strong[UserMagic.btLevelEx] then begin
                      Inc(UserMagic.btLevelEx);
                      boIncSkill := True;
                    end;
                  end;
              end;
            end;
          SKILL_SHOOTLIGHTEN {10}: begin
              if UserMagic.btLevel > 2 then begin
                if (m_MagicSkill_105 <> nil) then begin
                  if m_MagicSkill_105.btLevel >= g_Config.nSKILL_10Strong[UserMagic.btLevelEx] then begin
                    Inc(UserMagic.btLevelEx);
                    boIncSkill := True;
                  end;
                end else
                  if (m_MagicSkill_106 <> nil) then begin
                    if m_MagicSkill_106.btLevel >= g_Config.nSKILL_10Strong[UserMagic.btLevelEx] then begin
                      Inc(UserMagic.btLevelEx);
                      boIncSkill := True;
                    end;
                  end;
              end;
            end;
          SKILL_EARTHFIRE {22}: begin
              if UserMagic.btLevel > 2 then begin
                if (m_MagicSkill_105 <> nil) then begin
                  if m_MagicSkill_105.btLevel >= g_Config.nSKILL_22Strong[UserMagic.btLevelEx] then begin
                    Inc(UserMagic.btLevelEx);
                    boIncSkill := True;
                  end;
                end else
                  if (m_MagicSkill_106 <> nil) then begin
                    if m_MagicSkill_106.btLevel >= g_Config.nSKILL_22Strong[UserMagic.btLevelEx] then begin
                      Inc(UserMagic.btLevelEx);
                      boIncSkill := True;
                    end;
                  end;
              end;
            end;
          SKILL_FIRESWORD {26}: begin
              if UserMagic.btLevel > 2 then begin
                if (m_MagicSkill_105 <> nil) then begin
                  if m_MagicSkill_105.btLevel >= g_Config.nSKILL_26Strong[UserMagic.btLevelEx] then begin
                    Inc(UserMagic.btLevelEx);
                    boIncSkill := True;
                  end;
                end else
                  if (m_MagicSkill_106 <> nil) then begin
                    if m_MagicSkill_106.btLevel >= g_Config.nSKILL_26Strong[UserMagic.btLevelEx] then begin
                      Inc(UserMagic.btLevelEx);
                      boIncSkill := True;
                    end;
                  end;
              end;
            end;
          SKILL_45 {45}: begin
              if UserMagic.btLevel > 2 then begin
                if (m_MagicSkill_105 <> nil) then begin
                  if m_MagicSkill_105.btLevel >= g_Config.nSKILL_45Strong[UserMagic.btLevelEx] then begin
                    Inc(UserMagic.btLevelEx);
                    boIncSkill := True;
                  end;
                end else
                  if (m_MagicSkill_106 <> nil) then begin
                    if m_MagicSkill_106.btLevel >= g_Config.nSKILL_45Strong[UserMagic.btLevelEx] then begin
                      Inc(UserMagic.btLevelEx);
                      boIncSkill := True;
                    end;
                  end;
              end;
            end;
          SKILL_FIRECHARM {13}: begin
              if UserMagic.btLevel > 2 then begin
                if (m_MagicSkill_105 <> nil) then begin
                  if m_MagicSkill_105.btLevel >= g_Config.nSKILL_13Strong[UserMagic.btLevelEx] then begin
                    Inc(UserMagic.btLevelEx);
                    boIncSkill := True;
                  end;
                end else
                  if (m_MagicSkill_106 <> nil) then begin
                    if m_MagicSkill_106.btLevel >= g_Config.nSKILL_13Strong[UserMagic.btLevelEx] then begin
                      Inc(UserMagic.btLevelEx);
                      boIncSkill := True;
                    end;
                  end;
              end;
            end;
          SKILL_SKELLETON {17}: begin
              if UserMagic.btLevel > 2 then begin
                if (m_MagicSkill_105 <> nil) then begin
                  if m_MagicSkill_105.btLevel >= g_Config.nSKILL_17Strong[UserMagic.btLevelEx] then begin
                    Inc(UserMagic.btLevelEx);
                    boIncSkill := True;
                  end;
                end else
                  if (m_MagicSkill_106 <> nil) then begin
                    if m_MagicSkill_106.btLevel >= g_Config.nSKILL_17Strong[UserMagic.btLevelEx] then begin
                      Inc(UserMagic.btLevelEx);
                      boIncSkill := True;
                    end;
                  end;
              end;
            end;
          SKILL_71 {71}: begin //召唤圣兽
              if UserMagic.btLevel > 98 then begin
                if (m_MagicSkill_105 <> nil) then begin
                  if m_MagicSkill_105.btLevel >= g_Config.nSKILL_71Strong[UserMagic.btLevelEx] then begin
                    Inc(UserMagic.btLevelEx);
                    boIncSkill := True;
                  end;
                end else
                  if (m_MagicSkill_106 <> nil) then begin
                    if m_MagicSkill_106.btLevel >= g_Config.nSKILL_71Strong[UserMagic.btLevelEx] then begin
                      Inc(UserMagic.btLevelEx);
                      boIncSkill := True;
                    end;
                  end;
              end;
            end;
          SKILL_FIREBOOM: begin //爆裂火焰
              if UserMagic.btLevel > 2 then begin
                if (m_MagicSkill_105 <> nil) then begin
                  if m_MagicSkill_105.btLevel >= g_Config.nSKILL_FIREBOOMStrong[UserMagic.btLevelEx] then begin
                    Inc(UserMagic.btLevelEx);
                    boIncSkill := True;
                  end;
                end else
                  if (m_MagicSkill_106 <> nil) then begin
                    if m_MagicSkill_106.btLevel >= g_Config.nSKILL_FIREBOOMStrong[UserMagic.btLevelEx] then begin
                      Inc(UserMagic.btLevelEx);
                      boIncSkill := True;
                    end;
                  end;
              end;
            end;
          SKILL_SNOWWIND: begin //冰咆哮
              if UserMagic.btLevel > 2 then begin
                if (m_MagicSkill_105 <> nil) then begin
                  if m_MagicSkill_105.btLevel >= g_Config.nSKILL_SNOWWINDStrong[UserMagic.btLevelEx] then begin
                    Inc(UserMagic.btLevelEx);
                    boIncSkill := True;
                  end;
                end else
                  if (m_MagicSkill_106 <> nil) then begin
                    if m_MagicSkill_106.btLevel >= g_Config.nSKILL_SNOWWINDStrong[UserMagic.btLevelEx] then begin
                      Inc(UserMagic.btLevelEx);
                      boIncSkill := True;
                    end;
                  end;
              end;
            end;
          SKILL_HANGMAJINBUB: begin //幽灵盾
              if UserMagic.btLevel > 2 then begin
                if (m_MagicSkill_105 <> nil) then begin
                  if m_MagicSkill_105.btLevel >= g_Config.nSKILL_HANGMAJINBUBStrong[UserMagic.btLevelEx] then begin
                    Inc(UserMagic.btLevelEx);
                    boIncSkill := True;
                  end;
                end else
                  if (m_MagicSkill_106 <> nil) then begin
                    if m_MagicSkill_106.btLevel >= g_Config.nSKILL_HANGMAJINBUBStrong[UserMagic.btLevelEx] then begin
                      Inc(UserMagic.btLevelEx);
                      boIncSkill := True;
                    end;
                  end;
              end;
            end;
          SKILL_DEJIWONHO: begin //神圣战甲术
              if UserMagic.btLevel > 2 then begin
                if (m_MagicSkill_105 <> nil) then begin
                  if m_MagicSkill_105.btLevel >= g_Config.nSKILL_DEJIWONHOStrong[UserMagic.btLevelEx] then begin
                    Inc(UserMagic.btLevelEx);
                    boIncSkill := True;
                  end;
                end else
                  if (m_MagicSkill_106 <> nil) then begin
                    if m_MagicSkill_106.btLevel >= g_Config.nSKILL_DEJIWONHOStrong[UserMagic.btLevelEx] then begin
                      Inc(UserMagic.btLevelEx);
                      boIncSkill := True;
                    end;
                  end;
              end;
            end;
        end; //case
        if boIncSkill then begin
          SendMsg(self, RM_MAGIC_UPLVEXPEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevelEx, 0, '');
          SysMsg(Format(sIncreaseSkillLevel, [UserMagic.MagicInfo.sMagicName, UserMagic.btLevelEx]), c_Blue, t_Hint);
        end;
      end;
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.IncreaseSkillLevel', [g_sExceptionVer]));
  end;
end;
//清除强化技能等级

procedure TPlayObject.ClearIncreaseSkillLevel();
var
  I: Integer;
  UserMagic: pTUserMagic;
  boSend: Boolean;
begin
  if m_MagicList.Count > 0 then begin
    boSend := False;
    for I := 0 to m_MagicList.Count - 1 do begin
      UserMagic := m_MagicList.Items[I];
      if UserMagic = nil then Continue;
      if UserMagic.btLevelEx > 0 then begin
        UserMagic.btLevelEx := 0;
        boSend := True;
      end;
    end; //for
    if boSend then SendUseMagic;
  end;
end;
//天雷攻击

procedure TPlayObject.MagGroupLighteningHit(nX, nY: Integer);
  function MPow(UserMagic: pTUserMagic): Integer;
  begin
    if UserMagic.MagicInfo.wMaxPower > UserMagic.MagicInfo.wPower then //20090807
      Result := UserMagic.MagicInfo.wPower + Random(UserMagic.MagicInfo.wMaxPower - UserMagic.MagicInfo.wPower)
    else Result := UserMagic.MagicInfo.wPower;
  end;
  function GetPower(nPower: Integer; UserMagic: pTUserMagic): Integer;
  begin
    if UserMagic.MagicInfo.btDefMaxPower > UserMagic.MagicInfo.btDefPower then //20090807
      Result := Round(nPower / (UserMagic.MagicInfo.btTrainLv + 1) * (UserMagic.btLevel + 1)) + (UserMagic.MagicInfo.btDefPower + Random(UserMagic.MagicInfo.btDefMaxPower - UserMagic.MagicInfo.btDefPower))
    else Result := Round(nPower / (UserMagic.MagicInfo.btTrainLv + 1) * (UserMagic.btLevel + 1)) + UserMagic.MagicInfo.btDefPower;
  end;
var
  I, nPower, K, nXX, nYY: Integer;
  BaseObjectList: TList;
  BaseObject: TBaseObject;
begin
  BaseObjectList := TList.Create;
  case Random(4) of
    0: begin nXX := (nX + 1); nYY := (nY + 1) end;
    1: begin nXX := (nX - 1); nYY := (nY - 1) end;
    2: begin nXX := (nX - 1); nYY := (nY + 1) end;
    3: begin nXX := (nX + 1); nYY := (nY - 1) end;
  end;
  K := 5;
  try
    m_PEnvir.GetMapBaseObjects(nXX, nYY, 2, BaseObjectList);
    if BaseObjectList.Count > 0 then begin
      for I := 0 to BaseObjectList.Count - 1 do begin
        if K <= 0 then Break;
        BaseObject := TBaseObject(BaseObjectList.Items[I]);
        if BaseObject.m_boDeath or (BaseObject.m_boGhost) then Continue;
        if IsProperTarget(BaseObject) then begin
          if (Random(10) >= BaseObject.m_nAntiMagic) then begin
            nPower := GetAttackPower(GetPower(MPow(m_MagicSkill_113), m_MagicSkill_113) + LoWord(m_WAbil.MC), SmallInt(HiWord(m_WAbil.MC) - LoWord(m_WAbil.MC)) + 1);
            if BaseObject.m_btLifeAttrib = LA_UNDEAD then nPower := Round(nPower * 1.5);

            SendDelayMsg(self, RM_DELAYMAGIC, nPower, MakeLong(BaseObject.m_nCurrX, BaseObject.m_nCurrY), 2, Integer(BaseObject), '', 600);
          end;
          if (BaseObject.m_nCurrX <> nXX) or (BaseObject.m_nCurrY <> nYY) then
            SendRefMsg(RM_10205, 39, BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0, '');
          Dec(K);
        end;
      end;
    end;
    if K > 0 then begin
      for I := 1 to K do begin
        case Random(4) of
          0: SendRefMsg(RM_10205, 39, (nX + 2) - Random(3), (nY + 2) - Random(3), 0, '');
          1: SendRefMsg(RM_10205, 39, (nX - 2) + Random(3), (nY - 2) + Random(3), 0, '');
          2: SendRefMsg(RM_10205, 39, (nX - 2) + Random(3), (nY + 2) - Random(3), 0, '');
          3: SendRefMsg(RM_10205, 39, (nX + 2) - Random(3), (nY - 2) + Random(3), 0, '');
        end;
      end;
    end;
  finally
    BaseObjectList.Free;
  end;
end;

//发送心法相关数据

procedure TPlayObject.DoSendHeartInfo();

  function GetNextCanSkillName(nLevel: Byte): string;
  var
    I, nID, K: Integer;
    Magic: pTMagic;
    LevelEx: Byte;
  begin
    Result := '';
    nID := 0;
    K := 0;
    if (nLevel > 0) and (nLevel < 100) then begin
      LevelEx := nLevel + 1;
      for I := Low(g_Config.nSKILL_7Strong) to High(g_Config.nSKILL_7Strong) do begin
        case m_btJob of
          0: begin //战
              if LevelEx = g_Config.nSKILL_89Strong[I] then begin
                nID := SKILL_89;
                K := I;
                Break;
              end;
              if LevelEx = g_Config.nSKILL_74Strong[I] then begin
                nID := SKILL_74;
                K := I;
                Break;
              end;
              if LevelEx = g_Config.nSKILL_90Strong[I] then begin
                nID := SKILL_90;
                K := I;
                Break;
              end;
              if LevelEx = g_Config.nSKILL_26Strong[I] then begin
                nID := SKILL_FIRESWORD;
                K := I;
                Break;
              end;
              if LevelEx = g_Config.nSKILL_7Strong[I] then begin
                nID := SKILL_YEDO;
                K := I;
                Break;
              end;
            end;
          1: begin
              if LevelEx = g_Config.nSKILL_92Strong[I] then begin
                nID := SKILL_92;
                K := I;
                Break;
              end;
              if LevelEx = g_Config.nSKILL_91Strong[I] then begin
                nID := SKILL_91;
                K := I;
                Break;
              end;
              if LevelEx = g_Config.nSKILL_45Strong[I] then begin
                nID := SKILL_45;
                K := I;
                Break;
              end;
              if LevelEx = g_Config.nSKILL_22Strong[I] then begin
                nID := SKILL_EARTHFIRE;
                K := I;
                Break;
              end;
              if LevelEx = g_Config.nSKILL_10Strong[I] then begin
                nID := SKILL_SHOOTLIGHTEN;
                K := I;
                Break;
              end;
            end;
          2: begin
              if LevelEx = g_Config.nSKILL_94Strong[I] then begin
                nID := SKILL_94;
                K := I;
                Break;
              end;
              if LevelEx = g_Config.nSKILL_93Strong[I] then begin
                nID := SKILL_93;
                K := I;
                Break;
              end;
              if LevelEx = g_Config.nSKILL_13Strong[I] then begin
                nID := SKILL_FIRECHARM;
                K := I;
                Break;
              end;
              if LevelEx = g_Config.nSKILL_71Strong[I] then begin
                nID := SKILL_71;
                K := I;
                Break;
              end;
              if LevelEx = g_Config.nSKILL_17Strong[I] then begin
                nID := SKILL_SKELLETON;
                K := I;
                Break;
              end;
            end;
        end; //case
      end;
      if nID > 0 then begin
        Magic := UserEngine.FindMagic(nID);
        if Magic <> nil then begin
          Result := Format('%d重强化%s', [K + 1, Magic.sMagicName]);
        end;
      end;
    end;
  end;
var
  ClientHeartAbility: TClientHeartAbility;
begin
  try
    ClientHeartAbility.boHeartTpye := (m_MagicSkill_105 <> nil);
    if ClientHeartAbility.boHeartTpye then begin //龙卫心法
      ClientHeartAbility.sUpLevelSKillName := GetNextCanSkillName(m_MagicSkill_105.btLevel); //可学的强化技能
      ClientHeartAbility.nHeartTpye := m_nHeartType; //心法类型 0-紫金 1-乙木 2-大地 3-葵水 4-阳炎

      {ClientHeartAbility.wMainPower := LoWord(m_dwHeartAddPower); //下一级 属性下限(龙卫心法)
      ClientHeartAbility.wMainMaxPower := HiWord(m_dwHeartAddPower); //下一级 属性上限(龙卫心)
      }
      ClientHeartAbility.wMainPower := Round(m_MagicSkill_105.MagicInfo.wPower/(m_MagicSkill_105.MagicInfo.btTrainLv + 1) * (m_MagicSkill_105.btLevel + 1)) + m_MagicSkill_105.MagicInfo.btDefPower;//下一级 属性下限(龙卫心法)
      ClientHeartAbility.wMainMaxPower:= Round(m_MagicSkill_105.MagicInfo.wMaxPower{wPower}/(m_MagicSkill_105.MagicInfo.btTrainLv + 1) * (m_MagicSkill_105.btLevel + 1)) + m_MagicSkill_105.MagicInfo.btDefMaxPower;//下一级 属性上限(
      ClientHeartAbility.wUpDefence := 0; //属性下限
      ClientHeartAbility.wUpMaxDefence := 0; //属性上限
      ClientHeartAbility.wUpPassHeartLevel := 0; //下一级传承心法师傅心法等级
      ClientHeartAbility.wUpLevel := 0; //下一级传承心法自己等级条件
      SendMsg(Self, RM_SENDHEARTINFO, 0, 0, 0, 0, EncodeBuffer(@ClientHeartAbility, SizeOf(TClientHeartAbility)));
    end else if (m_MagicSkill_106 <> nil) and (m_MyDivision <> nil) then begin //传承心法
        ClientHeartAbility.sUpLevelSKillName := ''; //可学的强化技能
        ClientHeartAbility.nHeartTpye := m_nHeartType; //心法类型 0-紫金 1-乙木 2-大地 3-葵水 4-阳炎
        ClientHeartAbility.wUpDefence := LoWord(m_dwHeartAddDefence);
        ClientHeartAbility.wUpMaxDefence := HiWord(m_dwHeartAddDefence);
        ClientHeartAbility.wMainPower := 0; //属性下限
        ClientHeartAbility.wMainMaxPower := m_dwHeartAddPower;

        if m_MagicSkill_106.btLevel < 9 then begin
          case m_MagicSkill_106.btLevel of //传承心法等级
            1: ClientHeartAbility.wUpPassHeartLevel := 5; //下一级传承心法师傅心法等级
            2: ClientHeartAbility.wUpPassHeartLevel := 10; //下一级传承心法师傅心法等级
            3: ClientHeartAbility.wUpPassHeartLevel := 20; //下一级传承心法师傅心法等级
            4: ClientHeartAbility.wUpPassHeartLevel := 30; //下一级传承心法师傅心法等级
            5: ClientHeartAbility.wUpPassHeartLevel := 40; //下一级传承心法师傅心法等级
            6: ClientHeartAbility.wUpPassHeartLevel := 50; //下一级传承心法师傅心法等级
            7: ClientHeartAbility.wUpPassHeartLevel := 60; //下一级传承心法师傅心法等级
            8: ClientHeartAbility.wUpPassHeartLevel := 70; //下一级传承心法师傅心法等级
          end;
          ClientHeartAbility.wUpLevel := g_Config.nUpHeartNeedLevel[m_MagicSkill_106.btLevel]; //下一级传承心法自己等级条件
        end else begin
          ClientHeartAbility.wUpPassHeartLevel := 0;
          ClientHeartAbility.wUpLevel := 0;
        end;
        SendMsg(Self, RM_SENDHEARTINFO, 0, 0, 0, 0, EncodeBuffer(@ClientHeartAbility, SizeOf(TClientHeartAbility)));
      end;
  except   
    MainOutMessage(format('{%s} TPlayObject.SendHeartInfo', [g_sExceptionVer]));
  end;
end;
{$IFEND}

//客户端取商铺物品列表 20080730

procedure TPlayObject.ClientGetShopItemList(nPage, nType: Integer);
  function GetPageCount(nItemListCount: Integer): Integer;
  begin
    Result := 0;
    if nItemListCount > 0 then begin
      Result := nItemListCount div 10;
      if (nItemListCount mod 10) > 0 then Inc(Result);
    end;
  end;
var
  I, nPageCount, n01, n02, n03: Integer;
  sSendStr, sSendStr1: string;
  pShopInfo: pTShopInfo;
  ShopInfo: TShopInfo;
  TempList: TList;
  nCode: Byte;
begin
  nCode := 0;
  if m_boCanQueryShopItme then Exit; //是否可以刷新商铺 20080907
  m_boCanQueryShopItme := True; //是否可以刷新商铺 20080907
  try
    try
      if g_ShopItemList = nil then Exit;
      nCode := 1;
      n01 := 0;
      n02 := 0;
      n03 := 0;
      sSendStr := '';
      sSendStr1 := '';
      nCode := 2;
      if g_ShopItemList.Count > 0 then begin //20080629
        for I := 0 to g_ShopItemList.Count - 1 do begin
          nCode := 3;
          pShopInfo := pTShopInfo(g_ShopItemList.Items[I]);
          ShopInfo := pShopInfo^;
          nCode := 4;
          if strtoint(ShopInfo.Idx) = nType then Inc(n03);
        end;
      end;
      nCode := 5;
      nPageCount := GetPageCount(n03);
      nCode := 6;
      if nPage > 0 then begin
        if g_ShopItemList.Count >= nPage * 10 then begin
          TempList := TList.Create;
          try
            nCode := 7;
            for I := 0 to g_ShopItemList.Count - 1 do begin
              pShopInfo := pTShopInfo(g_ShopItemList.Items[I]);
              ShopInfo := pShopInfo^;
              if StrToInt(ShopInfo.Idx) = nType then TempList.Add(pShopInfo);
            end;
            nCode := 8;
            if TempList.Count > 0 then begin //20091113 增加
              for I := nPage * 10 to TempList.Count - 1 do begin
                pShopInfo := pTShopInfo(TempList.Items[I]);
                ShopInfo := pShopInfo^;
                Inc(n01);
                sSendStr := sSendStr + EncodeBuffer(@ShopInfo, SizeOf(TShopInfo)) + '/';
                if n01 >= 10 then break;
              end;
            end;
          finally
            TempList.Free;
          end;
        end;
      end else begin
        nCode := 9;
        if g_ShopItemList.Count > 0 then begin //20080629
          for I := 0 to g_ShopItemList.Count - 1 do begin
            pShopInfo := pTShopInfo(g_ShopItemList.Items[I]);
            nCode := 10;
            ShopInfo := pShopInfo^;
            if strtoint(ShopInfo.Idx) = nType then begin
              nCode := 11;
              Inc(n01);
              sSendStr := sSendStr + EncodeBuffer(@ShopInfo, SizeOf(TShopInfo)) + '/';
              if n01 >= 10 then break;
            end;
          end;
        end;
      end;
      nCode := 12;
      if sSendStr <> '' then SendMsg(Self, RM_OPENSHOP, 0, nPageCount, nPage + 1, n01, sSendStr);
      nCode := 13;
      // 齐珍类型
      if g_ShopItemList.Count > 0 then begin //20080629
        for I := 0 to g_ShopItemList.Count - 1 do begin
          pShopInfo := pTShopInfo(g_ShopItemList.Items[I]);
          ShopInfo := pShopInfo^;
          nCode := 14;
          if strtoint(ShopInfo.Idx) = 5 then begin
            Inc(n02);
            nCode := 15;
            sSendStr1 := sSendStr1 + EncodeBuffer(@ShopInfo, SizeOf(TShopInfo)) + '/';
            if n02 >= 5 then break;
          end;
        end;
      end;
      nCode := 16;
      if sSendStr1 <> '' then SendMsg(Self, RM_OPENSHOPSPECIALLY, 0, nPageCount, nPage + 1, n02, sSendStr1);
    except   
      MainOutMessage(format('{%s} TPlayObject.ClientGetShopItemList Code:%d', [g_sExceptionVer, nCode]));
    end;
  finally
    m_boCanQueryShopItme := False; //是否可以刷新商铺 20080907
  end;
end;

//客户端购买商铺物品 20080730

procedure TPlayObject.ClientBuyShopItem(sItemName: string; nBuyType {付费类型0-元宝或金币 1-游戏点}: Byte);
var
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  I, nPrice, nCount: Integer;
  boBuyShopItem: Boolean;
begin
  if m_boBuyShopItem then Exit; //正在购买商铺物品中 20090114
  m_boBuyShopItem := True;
  boBuyShopItem := False;
  try
    try
      StdItem := UserEngine.GetShopStdItem(sItemName);
      if StdItem <> nil then begin
        nPrice := StdItem.Price div 100;
        nCount := StdItem.NeedLevel; //一次可以购买的数量 20090114
        if nCount <= 0 then nCount := 1; //防止死循环
        if m_ItemList.Count + nCount > MAXBAGITEM then begin //检查包裹是否有指定的个空位 20090813
          SendMsg(self, RM_BUYSHOPITEM_FAIL, 0, 4, 0, 0, sItemName); //没有多余的位置
          Exit;
        end;
        case nBuyType of
          0: begin
              if g_Config.g_boShopUseGold then begin //商铺使用金币交易 20100630
                if (nPrice >= 0) and (nCount > 0) and (nCount <= MAXBAGITEM) then begin
                  if DecGold(nPrice) then begin
                    GoldChanged(); //更新客户端金币数
                    if g_boGameLogGold then
                      AddGameDataLog('10' + #9 + m_sMapName + #9 +
                        IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 + sSTRING_GOLDNAME + #9 +
                        IntToStr(nPrice) + #9 + '-(' + inttostr(nPrice) + ')' + #9 + '商铺购买');
                    for I := 0 to nCount - 1 do begin
                      if m_ItemList.Count >= MAXBAGITEM then Break;
                      if IsEnoughBag then begin
                        New(UserItem);
                        if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
                          if (StdItem.StdMode = 60) and (StdItem.shape <> 0) and (StdItem.Anicount = 2) then begin //购买药酒时，品质低于5时，重新计算 20081210
                            if UserItem.btValue[0] < 5 then UserItem.btValue[0] := Random(3) + 5;
                          end;
                          if StdItem.StdMode = 17 then begin //叠加物品自动合并
                            if not AutoItemMerger(UserItem) then begin //自动合并物品
                              if AddItemToBag(UserItem) then begin
                                if StdItem.NeedIdentify = 1 then
                                  AddGameDataLog('30' + #9 + m_sMapName + #9 +
                                    IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                                    m_sCharName + #9 + StdItem.Name + #9 +
                                    IntToStr(UserItem.MakeIndex) + #9 +
                                    '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                                    '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                                    '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                                    '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                                    '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                                    IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                                    IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                                    IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                                    IntToStr(UserItem.btValue[14]) + #9 + IntToStr(UserItem.Dura) + '/' + IntToStr(UserItem.DuraMax));
                                SendAddItem(UserItem);
                                boBuyShopItem := True;
                              end else Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                            end else boBuyShopItem := True;
                          end else begin
                            if AddItemToBag(UserItem) then begin
                              if StdItem.NeedIdentify = 1 then
                                AddGameDataLog('30' + #9 + m_sMapName + #9 +
                                  IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                                  m_sCharName + #9 + StdItem.Name + #9 +
                                  IntToStr(UserItem.MakeIndex) + #9 +
                                  '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                                  '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                                  '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                                  '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                                  '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                                  IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                                  IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                                  IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                                  IntToStr(UserItem.btValue[14]) + #9 + IntToStr(UserItem.Dura) + '/' + IntToStr(UserItem.DuraMax));
                              SendAddItem(UserItem);
                              boBuyShopItem := True;
                            end else Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                          end;
                        end else DisPose(UserItem);
                      end else begin
                        SendMsg(self, RM_BUYSHOPITEM_FAIL, 0, 2, 0, 0, sItemName); //包裹满
                        Break;
                      end;
                    end; //for
                  end else SendMsg(self, RM_BUYSHOPITEM_FAIL, 0, 1, 0, 0, sItemName);
                end else SendMsg(self, RM_BUYSHOPITEM_FAIL, 0, 1, 0, 0, sItemName);
              end else begin
                if (m_nGameGold >= nPrice) and (nPrice >= 0) and (nCount > 0) and (nCount <= MAXBAGITEM) then begin
                  DecGameGold(nPrice); //先减元宝值，再给物品
                  GameGoldChanged;
                  if g_boGameLogGameGold then
                    AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, m_sMapName,
                      m_nCurrX, m_nCurrY, m_sCharName, g_Config.sGameGoldName,
                        m_nGameGold, '-(' + inttostr(nPrice) + ')', '商铺购买']));
                  for I := 0 to nCount - 1 do begin
                    if m_ItemList.Count >= MAXBAGITEM then Break;
                    if IsEnoughBag then begin
                      New(UserItem);
                      if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
                        if (StdItem.StdMode = 60) and (StdItem.shape <> 0) and (StdItem.Anicount = 2) then begin //购买药酒时，品质低于5时，重新计算 20081210
                          if UserItem.btValue[0] < 5 then UserItem.btValue[0] := Random(3) + 5;
                        end;
                        if StdItem.StdMode = 17 then begin //叠加物品自动合并
                          if not AutoItemMerger(UserItem) then begin //自动合并物品
                            if AddItemToBag(UserItem) then begin
                              if StdItem.NeedIdentify = 1 then
                                AddGameDataLog('30' + #9 + m_sMapName + #9 +
                                  IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                                  m_sCharName + #9 + StdItem.Name + #9 +
                                  IntToStr(UserItem.MakeIndex) + #9 +
                                  '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                                  '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                                  '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                                  '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                                  '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                                  IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                                  IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                                  IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                                  IntToStr(UserItem.btValue[14]) + #9 + IntToStr(UserItem.Dura) + '/' + IntToStr(UserItem.DuraMax));
                              SendAddItem(UserItem);
                              boBuyShopItem := True;
                            end else Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                          end else boBuyShopItem := True;
                        end else begin
                          if AddItemToBag(UserItem) then begin
                            if StdItem.NeedIdentify = 1 then
                              AddGameDataLog('30' + #9 + m_sMapName + #9 +
                                IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                                m_sCharName + #9 + StdItem.Name + #9 +
                                IntToStr(UserItem.MakeIndex) + #9 +
                                '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                                '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                                '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                                '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                                '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                                IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                                IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                                IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                                IntToStr(UserItem.btValue[14]) + #9 + IntToStr(UserItem.Dura) + '/' + IntToStr(UserItem.DuraMax));
                            SendAddItem(UserItem);
                            boBuyShopItem := True;
                          end else Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                        end;
                      end else DisPose(UserItem);
                    end else begin
                      SendMsg(self, RM_BUYSHOPITEM_FAIL, 0, 2, 0, 0, sItemName); //包裹满
                      Break;
                    end;
                  end; //for
                end else begin
                  SendMsg(self, RM_BUYSHOPITEM_FAIL, 0, 1, 0, 0, sItemName);
                end;
                if boBuyShopItem then begin //购买成功
                  m_BuyShopPrice := nPrice; //每次商铺花的元宝数量，$BuyShop变量使用 20090106
                  //增加购买的物品和接收者名字
                  m_sString[0] := sItemName;
                  m_sString[1] := m_sCharName;
                  if g_FunctionNPC <> nil then begin //商铺购买触发 20090106
                    g_FunctionNPC.GotoLable(self, '@BuyShop', False, False);
                  end;
                end;
              end;
            end; //0
          1: begin //游戏点付款
              if not g_Config.g_boShopGamePoint then begin
                SendMsg(self, RM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0, '[失败]对不起，本服务没有开放');
                Exit;
              end;
              if IsDisableGamePointShopItem(sItemName) then begin
                SendMsg(self, RM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0, '[失败]对不起，' + sItemName + ' 不能使用 ' + g_Config.sGamePointName + ' 购买');
                Exit;
              end;
              if (m_nGamePoint >= nPrice * 100) and (nPrice >= 0) and (nCount > 0)
                and (nCount <= MAXBAGITEM) then begin
                DecGamePoint(nPrice * 100); //先减游戏点，再给物品
                GameGoldChanged;
                if g_boGameLogGameGold then
                  AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, m_sMapName,
                    m_nCurrX, m_nCurrY, m_sCharName, g_Config.sGamePointName,
                      m_nGamePoint, '-(' + inttostr(nPrice * 100) + ')', '商铺购买']));
                for I := 0 to nCount - 1 do begin
                  if m_ItemList.Count >= MAXBAGITEM then Break;
                  if IsEnoughBag then begin
                    New(UserItem);
                    if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then begin
                      if (StdItem.StdMode = 60) and (StdItem.shape <> 0) and (StdItem.Anicount = 2) then begin //购买药酒时，品质低于5时，重新计算 20081210
                        if UserItem.btValue[0] < 5 then UserItem.btValue[0] := Random(3) + 5;
                      end;
                      if StdItem.StdMode = 17 then begin //叠加物品自动合并
                        if not AutoItemMerger(UserItem) then begin //自动合并物品
                          if AddItemToBag(UserItem) then begin
                            if StdItem.NeedIdentify = 1 then
                              AddGameDataLog('30' + #9 + m_sMapName + #9 +
                                IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                                m_sCharName + #9 + StdItem.Name + #9 +
                                IntToStr(UserItem.MakeIndex) + #9 +
                                '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                                '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                                '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                                '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                                '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                                IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                                IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                                IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                                IntToStr(UserItem.btValue[14]) + #9 + IntToStr(UserItem.Dura) + '/' + IntToStr(UserItem.DuraMax));
                            SendAddItem(UserItem);
                            boBuyShopItem := True;
                          end else Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                        end else boBuyShopItem := True;
                      end else begin
                        if AddItemToBag(UserItem) then begin
                          if StdItem.NeedIdentify = 1 then
                            AddGameDataLog('30' + #9 + m_sMapName + #9 +
                              IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                              m_sCharName + #9 + StdItem.Name + #9 +
                              IntToStr(UserItem.MakeIndex) + #9 +
                              '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                              '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                              '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                              '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                              '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                              IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                              IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                              IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                              IntToStr(UserItem.btValue[14]) + #9 + IntToStr(UserItem.Dura) + '/' + IntToStr(UserItem.DuraMax));
                          SendAddItem(UserItem);
                          boBuyShopItem := True;
                        end else Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                      end;
                    end else DisPose(UserItem);
                  end else begin
                    SendMsg(self, RM_BUYSHOPITEM_FAIL, 0, 2, 0, 0, sItemName); //包裹满
                    Break;
                  end;
                end; //for
              end else begin
                SendMsg(self, RM_BUYSHOPITEM_FAIL, 0, 8, 0, 0, sItemName);
              end;
              if boBuyShopItem then begin //购买成功
                m_BuyShopPrice := nPrice; //每次商铺花的元宝数量，$BuyShop变量使用 20090106
                m_sString[0] := sItemName;
                m_sString[1] := m_sCharName;
                if g_FunctionNPC <> nil then begin //商铺购买触发 20090106
                  g_FunctionNPC.GotoLable(self, '@BuyShop1', False, False);
                end;
              end;
            end; //1
        end; //case
      end else begin
        SendMsg(self, RM_BUYSHOPITEM_FAIL, 0, 3, 0, 0, sItemName);
      end;
    except   
      MainOutMessage(format('{%s} TPlayObject.ClientBuyShopItem', [g_sExceptionVer]));
    end;
  finally
    m_boBuyShopItem := False;
  end;
end;

//客户端商铺赠送 20080730

procedure TPlayObject.ClientBuyShopItemGive(sMsg: string; nBuyType {付费类型0-元宝或金币 1-游戏点}: Byte);
var
  GiveUseName, GiveItemName, GiveMyName: string;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  I, nPrice, nCount: Integer;
  PlayObjectGive: TPlayObject;
  boBuyShopItem: Boolean;
begin
  if m_boBuyShopItem then Exit; //正在购买商铺物品中 20090114
  m_boBuyShopItem := True;
  boBuyShopItem := False;
  try
    try
      sMsg := GetValidStr3(sMsg, GiveItemName, ['/']);
      sMsg := GetValidStr3(sMsg, GiveUseName, ['/']);
      sMsg := GetValidStr3(sMsg, GiveMyName, ['/']);

      GiveUseName := DeCodeString(GiveUseName); //赠送给的人
      GiveItemName := DeCodeString(GiveItemName); //物品名
      GiveMyName := DeCodeString(GiveMyName); //赠送人
      if PlugOfCheckCanItem(11, GiveItemName, False, 0, 0) then begin //禁止赠送 20090205
        SendMsg(self, RM_BUYSHOPITEMGIVE_FAIL, 0, 5, 0, 0, GiveItemName);
      end else begin
        if GiveMyName <> '' then begin
          StdItem := UserEngine.GetShopStdItem(GiveItemName);
          if StdItem <> nil then begin
            if GiveUseName = GiveMyName then begin //自己赠送给自己时 20090207
              SendMsg(self, RM_BUYSHOPITEMGIVE_FAIL, 0, 6, 0, 0, GiveUseName);
              Exit;
            end;
            PlayObjectGive := UserEngine.GetPlayObject(GiveUseName);
            if PlayObjectGive = nil then begin //角色没在线
              if CompareText(GiveUseName, copy(sUserKey13, 0, 30)) = 0 then m_boSendCanBatterTick := True;
              SendMsg(self, RM_BUYSHOPITEMGIVE_FAIL, 0, 4, 0, 0, GiveUseName); //赠送的人没在线
              Exit;
            end;
            nPrice := StdItem.Price div 100;
            nCount := StdItem.NeedLevel; //一次可以购买的数量 20090114
            if nCount <= 0 then nCount := 1; //防止死循环
            if PlayObjectGive.m_ItemList.Count + nCount > MAXBAGITEM then begin //检查包裹是否有指定的个空位 20090813
              SendMsg(self, RM_BUYSHOPITEMGIVE_FAIL, 0, 7, 0, 0, GiveItemName);
              Exit;
            end;
            case nBuyType of
              0: begin
                  if g_Config.g_boShopUseGold then begin //商铺使用金币交易 20100630
                    if (nPrice >= 0) and (nCount > 0) and (nCount <= MAXBAGITEM) then begin
                      if DecGold(nPrice) then begin
                        GoldChanged(); //更新客户端金币数
                        if g_boGameLogGold then
                          AddGameDataLog('10' + #9 + m_sMapName + #9 +
                            IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                            m_sCharName + #9 + sSTRING_GOLDNAME + #9 +
                            IntToStr(nPrice) + #9 + '-(' + inttostr(nPrice) + ')' + #9 + '商铺赠送');
                        for I := 0 to nCount - 1 do begin
                          if PlayObjectGive.m_ItemList.Count >= MAXBAGITEM then Break;
                          if PlayObjectGive.IsEnoughBag then begin //人物背包
                            New(UserItem);
                            if UserEngine.CopyToUserItemFromName(GiveItemName, UserItem) then begin
                              if PlayObjectGive.AddItemToBag(UserItem) then begin
                                if StdItem.NeedIdentify = 1 then
                                  AddGameDataLog('30' + #9 + m_sMapName + #9 +
                                    IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                                    PlayObjectGive.m_sCharName + #9 + StdItem.Name + #9 +
                                    IntToStr(UserItem.MakeIndex) + #9 +
                                    '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' + //攻
                                    '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' + //魔法
                                    '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' + //道术
                                    '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' + //防御
                                    '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' + //魔御
                                    IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                                    IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                                    IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                                    IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + m_sCharName + '(赠)');

                                PlayObjectGive.SendAddItem(UserItem);
                                boBuyShopItem := True;
                                SendMsg(self, RM_BUYSHOPITEMGIVE_SUCCESS, 0, 1, 0, 0, '[成功]赠送给 ' + GiveItemName + ' 物品 ' + GiveUseName + ' 成功！');
                                PlayObjectGive.SysMsg('[恭喜]你的朋友 ' + GiveMyName + ' 在商铺里给你买了 ' + GiveItemName + ' 请您查收！', c_Blue, t_Hint);
                              end else Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                            end else DisPose(UserItem);
                          end else begin //背包满
                            SendMsg(self, RM_BUYSHOPITEMGIVE_FAIL, 0, 3, 0, 0, GiveItemName);
                            Break;
                          end;
                        end; //for
                      end else SendMsg(self, RM_BUYSHOPITEMGIVE_FAIL, 0, 1, 0, 0, GiveItemName);
                    end else SendMsg(self, RM_BUYSHOPITEMGIVE_FAIL, 0, 1, 0, 0, GiveItemName);
                  end else begin
                    if (m_nGameGold >= nPrice) and (nPrice >= 0) and (nCount > 0) and (nCount <= MAXBAGITEM) then begin
                      DecGameGold(nPrice);
                      GameGoldChanged;
                      if g_boGameLogGameGold then
                        AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, m_sMapName,
                          m_nCurrX, m_nCurrY, m_sCharName, g_Config.sGameGoldName,
                            m_nGameGold, '-(' + inttostr(nPrice) + ')', '商铺赠送']));
                      for I := 0 to nCount - 1 do begin
                        if PlayObjectGive.m_ItemList.Count >= MAXBAGITEM then Break;
                        if PlayObjectGive.IsEnoughBag then begin //人物背包
                          New(UserItem);
                          if UserEngine.CopyToUserItemFromName(GiveItemName, UserItem) then begin
                            if PlayObjectGive.AddItemToBag(UserItem) then begin
                              if StdItem.NeedIdentify = 1 then
                                AddGameDataLog('30' + #9 + m_sMapName + #9 +
                                  IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                                  PlayObjectGive.m_sCharName + #9 + StdItem.Name + #9 +
                                  IntToStr(UserItem.MakeIndex) + #9 +
                                  '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' + //攻
                                  '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' + //魔法
                                  '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' + //道术
                                  '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' + //防御
                                  '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' + //魔御
                                  IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                                  IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                                  IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                                  IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + m_sCharName + '(赠)');

                              PlayObjectGive.SendAddItem(UserItem);
                              boBuyShopItem := True;
                              SendMsg(self, RM_BUYSHOPITEMGIVE_SUCCESS, 0, 1, 0, 0, '[成功]赠送给 ' + GiveItemName + ' 物品 ' + GiveUseName + ' 成功！');
                              PlayObjectGive.SysMsg('[恭喜]你的朋友 ' + GiveMyName + ' 在商铺里给你买了 ' + GiveItemName + ' 请您查收！', c_Blue, t_Hint);
                            end else Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                          end else DisPose(UserItem);
                        end else begin //背包满
                          SendMsg(self, RM_BUYSHOPITEMGIVE_FAIL, 0, 3, 0, 0, GiveItemName);
                          Break;
                        end;
                      end; //for
                    end else begin //元宝不够
                      SendMsg(self, RM_BUYSHOPITEMGIVE_FAIL, 0, 1, 0, 0, GiveItemName);
                    end;
                    if boBuyShopItem then begin //购买成功
                      m_BuyShopPrice := nPrice; //每次商铺花的元宝数量，$BuyShop变量使用 20090106
                      m_sString[0] := GiveItemName;
                      m_sString[1] := GiveUseName;
                      if g_FunctionNPC <> nil then begin //商铺购买触发 20090106
                        g_FunctionNPC.GotoLable(self, '@BuyShop', False, False);
                      end;
                    end;
                  end;
                end; //0
              1: begin //游戏点付款
                  if not g_Config.g_boShopGamePoint then begin
                    SendMsg(self, RM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0, '[失败]对不起，本服务没有开放');
                    Exit;
                  end;
                  if IsDisableGamePointShopItem(GiveItemName) then begin
                    SendMsg(self, RM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0, '[失败]对不起，' + GiveItemName + ' 不能使用 ' + g_Config.sGamePointName + ' 购买');
                    Exit;
                  end;
                  if (m_nGamePoint >= nPrice * 100) and (nPrice >= 0) and (nCount > 0)
                    and (nCount <= MAXBAGITEM) then begin
                    DecGamePoint(nPrice * 100);
                    GameGoldChanged;
                    if g_boGameLogGameGold then
                      AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, m_sMapName,
                        m_nCurrX, m_nCurrY, m_sCharName, g_Config.sGamePointName,
                          m_nGamePoint, '-(' + inttostr(nPrice * 100) + ')', '商铺赠送']));
                    for I := 0 to nCount - 1 do begin
                      if PlayObjectGive.m_ItemList.Count >= MAXBAGITEM then Break;
                      if PlayObjectGive.IsEnoughBag then begin //人物背包
                        New(UserItem);
                        if UserEngine.CopyToUserItemFromName(GiveItemName, UserItem) then begin
                          if PlayObjectGive.AddItemToBag(UserItem) then begin
                            if StdItem.NeedIdentify = 1 then
                              AddGameDataLog('30' + #9 + m_sMapName + #9 +
                                IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                                PlayObjectGive.m_sCharName + #9 + StdItem.Name + #9 +
                                IntToStr(UserItem.MakeIndex) + #9 +
                                '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' + //攻
                                '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' + //魔法
                                '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' + //道术
                                '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' + //防御
                                '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' + //魔御
                                IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                                IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                                IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                                IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + m_sCharName + '(赠)');

                            PlayObjectGive.SendAddItem(UserItem);
                            boBuyShopItem := True;
                            SendMsg(self, RM_BUYSHOPITEMGIVE_SUCCESS, 0, 1, 0, 0, '[成功]赠送给 ' + GiveItemName + ' 物品 ' + GiveUseName + ' 成功！');
                            PlayObjectGive.SysMsg('[恭喜]你的朋友 ' + GiveMyName + ' 在商铺里给你买了 ' + GiveItemName + ' 请您查收！', c_Blue, t_Hint);
                          end else Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
                        end else DisPose(UserItem);
                      end else begin //背包满
                        SendMsg(self, RM_BUYSHOPITEMGIVE_FAIL, 0, 3, 0, 0, GiveItemName);
                        Break;
                      end;
                    end; //for
                  end else begin //游戏点不够
                    SendMsg(self, RM_BUYSHOPITEMGIVE_FAIL, 0, 8, 0, 0, GiveItemName);
                  end;
                  if boBuyShopItem then begin //购买成功
                    m_BuyShopPrice := nPrice; //每次商铺花的元宝数量，$BuyShop变量使用 20090106
                    m_sString[0] := GiveItemName;
                    m_sString[1] := GiveUseName;
                    if g_FunctionNPC <> nil then begin //商铺购买触发 20090106
                      g_FunctionNPC.GotoLable(self, '@BuyShop1', False, False);
                    end;
                  end;
                end; //1
            end;
          end else begin //没有找到这个物品
            SendMsg(self, RM_BUYSHOPITEMGIVE_FAIL, 0, 2, 0, 0, GiveItemName);
          end;
        end;
      end;
    except   
      MainOutMessage(format('{%s} TPlayObject.ClientBuyShopItemGive', [g_sExceptionVer]));
    end;
  finally
    m_boBuyShopItem := False;
  end;
end;
{$IF M2Version <> 2}
//客户端商铺兑换灵符 20080730

procedure TPlayObject.ClientExchangeGameGird(nGameGird: Integer; nBuyType {付费类型0-元宝或金币 1-游戏点}: Byte);
begin
  try
    if not g_Config.g_boGameGird then begin
      SendMsg(self, RM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0, '[失败]对不起，本服务没有开放');
      Exit;
    end;
    if nGameGird <= 0 then Exit; //兑换数不能为0
    case nBuyType of
      0: begin //元宝兑换
          if m_nGameGold <= 0 then begin
            SendMsg(self, RM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0, '[失败]您的' + g_Config.sGameGoldName + '不足！ 本服' + IntToStr(g_Config.g_nGameGold) + '个' + g_Config.sGameGoldName + '兑换1个灵符！');
            Exit;
          end;
          if m_nGameGold >= nGameGird * g_Config.g_nGameGold then begin //当前元宝>兑换数量*每个灵符单价
            DecGameGold(nGameGird * g_Config.g_nGameGold); //给角色减元宝
            IncGameGird(nGameGird);
            GameGoldChanged;
            SendMsg(self, RM_EXCHANGEGAMEGIRD_SUCCESS, 0, 0, 0, 0, '[成功]您成功的兑换了 ' + IntToStr(nGameGird) + ' 个灵符');
          end else SendMsg(self, RM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0, '[失败]您的' + g_Config.sGameGoldName + '不足，请冲值！ 本服' + IntToStr(g_Config.g_nGameGold) + '个' + g_Config.sGameGoldName + '兑换1个灵符！'); //元宝不足
        end; //0
      1: begin //游戏点
          if not g_Config.g_boShopGamePoint then begin
            SendMsg(self, RM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0, '[失败]对不起，本服务没有开放');
            Exit;
          end;
          if m_nGamePoint <= 0 then begin
            SendMsg(self, RM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0, '[失败]您的' + g_Config.sGamePointName + '不足！');
            Exit;
          end;
          if m_nGamePoint >= (nGameGird * g_Config.g_nGameGold * 100) then begin //当前游戏点>兑换数量*每个灵符单价
            DecGamePoint(nGameGird * g_Config.g_nGameGold * 100); //给角色减游戏点
            IncGameGird(nGameGird);
            GameGoldChanged;
            SendMsg(self, RM_EXCHANGEGAMEGIRD_SUCCESS, 0, 0, 0, 0, '[成功]您成功的兑换了 ' + IntToStr(nGameGird) + ' 个灵符');
          end else SendMsg(self, RM_EXCHANGEGAMEGIRD_FAIL, 0, 0, 0, 0, '[失败]您的' + g_Config.sGamePointName + '不足！');
        end;
    end; //case
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientExchangeGameGird', [g_sExceptionVer]));
  end;
end;

//装备兑换卷轴碎片，把装备放到交易框中，取可兑换的数量 20100812

procedure TPlayObject.ClientMerchantQueryArmsExchangeCount(nParam1, nMakeIndex: Integer; sMsg: string);
var
  I: Integer;
  UserItem: pTUserItem;
  UserItem18: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
begin
  UserItem18 := nil;
  if m_ItemList.Count > 0 then begin
    for I := 0 to m_ItemList.Count - 1 do begin
      UserItem := m_ItemList.Items[I];
      if UserItem = nil then Continue;
      if UserItem.MakeIndex = nMakeIndex then begin
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
        if CompareText(sUserItemName, sMsg) = 0 then begin
          UserItem18 := UserItem;
          Break;
        end;
      end;
    end;
  end;
  if UserItem18 = nil then Exit;
  Merchant := UserEngine.FindMerchant(TObject(nParam1));
  if Merchant = nil then Exit;
  if ((Merchant.m_PEnvir = m_PEnvir) and (Merchant.m_boArmsExchange) and
    (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientQueryArmsExchangeCount(Self, UserItem18);
end;
//客户端用装备兑换卷轴碎片  20100812

procedure TPlayObject.ClientUserArmsExhange(nParam1, nMakeIndex: Integer; sMsg: string);
var
  I: Integer;
  UserItem: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
begin
  if (nMakeIndex <= 0) or (sMsg = '') then Exit;
  m_boCanQueryBag := True; //出售物品时,不能刷新包裹
  try
    for I := m_ItemList.Count - 1 downto 0 do begin
      if m_ItemList.Count <= 0 then Break;
      UserItem := m_ItemList.Items[I];
      if (UserItem <> nil) then begin
        if (UserItem.MakeIndex = nMakeIndex) then begin
          if (UserItem.AddValue[0] in [1..3]) then Break; //限时物品,绑定物品不能交易
          //取自定义物品名称
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sUserItemName = '' then sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
          if CompareText(sUserItemName, sMsg) = 0 then begin
            if CheckItemValue(UserItem, 4) or PlugOfCheckCanItem(1, sUserItemName, True, 0, 0) then begin //禁止物品规则(禁止交易)
              SendMsg(Self, RM_USERARMSEXCHANGE_FAIL, 1 {禁止交易}, 0, 0, 0, '');
              Exit;
            end;

            Merchant := UserEngine.FindMerchant(TObject(nParam1));
            if (Merchant <> nil) then begin
              if (Merchant.m_boArmsExchange) and ((Merchant.m_PEnvir = m_PEnvir) and
                (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then begin
                if Merchant.ClientArmsExhangeItem(Self, UserItem) then begin
                  m_ItemList.Delete(I);
                  Dispose(UserItem);
                  WeightChanged();
                end;
              end;
            end;
            Break;
          end;
        end;
      end;
    end; // for
  finally
    m_boCanQueryBag := False; //出售物品时,不能刷新包裹
  end;
end;
//自动修炼英雄强身术 20100818

function TPlayObject.ClientGameGirdUpSkill99(nCount: Integer): Boolean;
var
  nMaxExp: LongWord;
begin
  Result := False;
  try
    if m_MyHero <> nil then begin
      if (not m_MyHero.m_boDeath) and (not m_MyHero.m_boGhost) and (m_nGameGird >= nCount) and (nCount > 0) then begin
        if THeroObject(m_MyHero).m_Magic99Skill <> nil then begin //强身术
          if THeroObject(m_MyHero).m_Magic99Skill.btLevel < 99 then begin
            Dec(m_nGameGird, nCount);
            GoldGameGirdChanged(); //更新客户端金币，灵符
            Result := True;
            Inc(THeroObject(m_MyHero).m_Magic99Skill.nTranPoint, nCount);
            nMaxExp := 300 + (THeroObject(m_MyHero).m_Magic99Skill.btLevel * 200);
            if THeroObject(m_MyHero).m_Magic99Skill.nTranPoint >= nMaxExp then begin //超过升级经验,则升级技能
              Dec(THeroObject(m_MyHero).m_Magic99Skill.nTranPoint, nMaxExp);
              if THeroObject(m_MyHero).m_Magic99Skill.btLevel < 99 then begin
                Inc(THeroObject(m_MyHero).m_Magic99Skill.btLevel);
                THeroObject(m_MyHero).RecalcAbilitys();
                THeroObject(m_MyHero).CompareSuitItem(False);
                THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROABILITY, 0, 0, 0, 0, ''); //发送英雄属性
              end;
            end;
            if (THeroObject(m_MyHero).m_Magic99Skill.btLevel < 100) then begin
              nMaxExp := 300 + (THeroObject(m_MyHero).m_Magic99Skill.btLevel * 200);
              THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROMAGIC_LVEXP, THeroObject(m_MyHero).m_Magic99Skill.MagicInfo.wMagicId, nMaxExp, THeroObject(m_MyHero).m_Magic99Skill.btLevel, THeroObject(m_MyHero).m_Magic99Skill.nTranPoint, '');
            end;
            SysMsg(Format('您的英雄白日门强身术增强了%d点！', [nCount]), c_Red, t_Hint);
            m_UseGameGird := nCount; //灵符使用计数
            if g_FunctionNPC <> nil then begin //灵符使用触发
              g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
            end;
            if g_boGameLogGameGird then begin //记录灵符日志
              AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GameGird, m_sMapName,
                m_nCurrX, m_nCurrY, m_sCharName, g_Config.sGameGird,
                  m_nGameGird, '-' + inttostr(nCount), '强身术']));
            end;
          end;
        end;
      end;
    end;
  except
    Result := False;
  end;
end;
//解读神秘属性 20100826

procedure TPlayObject.ClientUserScrollChangeItem(nMakeIndex {装备制造ID}, nMakeIndex1 {卷轴制造ID}: Integer);
var
  I, n14, n15: Integer;
  UserItem, UserItem1: pTUserItem;
  StdItem: pTStdItem;
  boItme, boChangeOK, boTrainee, boTraineeItem: Boolean;
  nItmeProficiency: Word; //卷轴熟练度
  nCode: Byte;
begin
  try
    if (nMakeIndex <= 0) or (nMakeIndex1 <= 0) then Exit;
    nCode := 0;
    if (not m_boDeath) and (not m_boGhost) then begin
      n14 := 0;
      n15 := 65525;
      boItme := False;
      boChangeOK := False;
      boTrainee := False;
      boTraineeItem := False;
      nItmeProficiency := 0;
      if m_ItemList.Count > 0 then begin
        nCode := 1;
        for I := m_ItemList.Count - 1 downto 0 do begin
          if m_ItemList.Count <= 0 then Break;
          UserItem := m_ItemList.Items[I];
          nCode := 2;
          if UserItem = nil then Continue;
          if (UserItem.MakeIndex = nMakeIndex) then begin //得到物品，并判断是否存在未解读的神秘属性
            nCode := 3;
            if (UserItem.btUnKnowValueCount > 0) and ((UserItem.btUnKnowValueCount < 5)) then begin //判断是否存在神秘属性
              if UserItem.btUnKnowValue[6] = 255 then n14 := 1
              else if UserItem.btUnKnowValue[7] = 255 then n14 := 2
              else if UserItem.btUnKnowValue[8] = 255 then n14 := 3
              else if UserItem.btUnKnowValue[9] = 255 then n14 := 4;
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if (StdItem <> nil) then begin
                if (StdItem.StdMode = 5) and (StdItem.Need = 32767) then boTrainee := True; //见习宝物
              end;
            end;
            Break;
          end;
        end; //for
        nCode := 4;
        if (n14 in [1..4]) and (UserItem <> nil) then begin //存在未解读神秘的才判断卷轴是否对应
          for I := m_ItemList.Count - 1 downto 0 do begin
            if m_ItemList.Count <= 0 then Break;
            UserItem1 := m_ItemList.Items[I];
            nCode := 5;
            if UserItem1 = nil then Continue;
            if (UserItem1.MakeIndex = nMakeIndex1) then begin //得到卷轴，并判断是否可以使用 btValue[0]-等级 持久-熟练度
              StdItem := UserEngine.GetStdItem(UserItem1.wIndex);
              if (StdItem <> nil) then begin
                nCode := 6;
                if not boTrainee then begin
                  if (UserItem1.btValue[0] >= n14) and (StdItem.StdMode = 44) and (StdItem.Shape = 255) then begin
                    nItmeProficiency := UserItem1.DuraMax;
                    m_ItemList.Delete(I);
                    Dispose(UserItem1);
                    boItme := True;
                  end else begin
                    SendAddItem(UserItem1);
                  end;
                end else begin
                  if (StdItem.StdMode = 44) and (StdItem.Shape = 252) then begin
                    m_ItemList.Delete(I);
                    Dispose(UserItem1);
                    boTraineeItem := True;
                  end else begin
                    SendAddItem(UserItem1);
                  end;
                end;
              end;
              Break;
            end;
          end; //for
          nCode := 10;
          n15 := g_Config.nReadRate[n14] - nItmeProficiency;
          if n15 < 0 then n15 := 0;
          if (UserItem <> nil) then begin
            if boItme then begin //进行神性属性解读
              if (Random(n15) = 0) then begin
                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                nCode := 11;
                if (StdItem <> nil) then begin
                  case StdItem.StdMode of
                    5, 6: begin //武器
                        nCode := 12;
                        boChangeOK := ItemUnit.RandomScrollChangeWeapon(UserItem, n14);
                      end;
                    10, 11: begin //衣服
                        nCode := 13;
                        boChangeOK := ItemUnit.RandomScrollChangeDre(UserItem, n14);
                      end;
                    19, 20, 21, 28, 29: begin //项链
                        nCode := 14;
                        boChangeOK := ItemUnit.RandomScrollChangeNecklace(UserItem, n14);
                      end;
                    24, 26: begin //手镯
                        nCode := 15;
                        boChangeOK := ItemUnit.RandomScrollChangeBracelet(UserItem, n14);
                      end;
                    22, 23, 27: begin //戒指
                        nCode := 16;
                        boChangeOK := ItemUnit.RandomScrollChangeRing(UserItem, n14);
                      end;
                    15, 16: begin //头盔斗笠
                        nCode := 17;
                        boChangeOK := ItemUnit.RandomScrollChangeHelme(UserItem, n14);
                      end;
                    52, 54, 55, 62, 64: begin //鞋子、腰带
                        nCode := 18;
                        boChangeOK := ItemUnit.RandomScrollChangeShoes(UserItem, n14);
                      end;
                    30: begin //勋章
                        nCode := 19;
                        boChangeOK := ItemUnit.RandomScrollChangeMedal(UserItem, n14);
                      end;
                  end;
                  SendUpdateItem(UserItem); //更新物品属性
                end;
              end;
            end else begin //见习宝物
              if (n14 = 1) and boTraineeItem then begin
                boChangeOK := ItemUnit.TraineeItemScrollChangeWeapon(UserItem, n14);
                SendUpdateItem(UserItem); //更新物品属性
              end;
            end;
          end;
        end;
      end;
      nCode := 20;
      if boChangeOK then
        SendMsg(Self, RM_USERSCROLLCHANGEITME_OK, 0, 0, 0, 0, '')
      else SendMsg(Self, RM_USERSCROLLCHANGEITME_FAIL, 0, 0, 0, 0, '');
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientUserScrollChangeItem Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

//新鉴定 By TasNat at: 2012-04-13 18:03:06
procedure TPlayObject.ClientUserNewKamPoItems(nMakeIndex {装备制造ID}, nMakeIndex1 {卷轴制造ID}: Integer; sMsg : string);
var
  I, nCode, K, nCount: Integer;
  UserItem99, UserItem98: pTUserItem;
  DesUserItem: pTUserItem;
  StdItem: pTStdItem;
  boItme: Boolean;
  XinJianDingData : TXinJianDingData;
  boChangeOK : Boolean;
  Need99 : DWord;
  Need98 : DWord;
begin
  DesUserItem := nil;//初始化 By TasNat at: 2012-04-13 18:16:40
  UserItem99:= nil;//初始化 By TasNat at: 2012-04-13 18:16:40
  boItme := False;
  boChangeOK := False;
  try
    if (nMakeIndex <= 0) or (nMakeIndex1 <= 0) then Exit;
    FillChar(XinJianDingData, SizeOf(XinJianDingData), 0);
    DecodeBuffer(sMsg, @XinJianDingData, SizeOf(XinJianDingData));
    Need99 := g_Config.dwNewKamPoNeed1;
    Need98 := g_Config.dwNewKamPoNeed2;
    for I := 0 to 3 do if XinJianDingData.ItemValueRetainMarks[I] = 1 then begin
      Inc(Need99, g_Config.dwNewKamPoLockNeed1);
      Inc(Need98, g_Config.dwNewKamPoLockNeed2);             
    end;
    if (not m_boDeath) and (not m_boGhost) then begin
      if m_ItemList.Count > 0 then begin
        nCode := 1;
        for I := m_ItemList.Count - 1 downto 0 do begin
          if m_ItemList.Count <= 0 then Break;
          DesUserItem := m_ItemList.Items[I];
          nCode := 2;
          if DesUserItem = nil then Continue;
          if (DesUserItem.MakeIndex = nMakeIndex) then begin //得到物品，并判断是否可以鉴定
            nCode := 3;

            Break;
          end;
        end; //for
        nCode := 4;
        if (DesUserItem <> nil) then begin
          for I := m_ItemList.Count - 1 downto 0 do begin
            if m_ItemList.Count <= 0 then Break;
            UserItem99 := m_ItemList.Items[I];
            nCode := 5;
            if UserItem99 = nil then Continue;
            if (UserItem99.MakeIndex = nMakeIndex1) then begin //卷轴碎片
              nCode := 6;
              StdItem := UserEngine.GetStdItem(UserItem99.wIndex);
              if (StdItem <> nil) then begin
                nCode := 7;
                  if (StdItem.StdMode = 17) and ((StdItem.Shape) = 7) then begin //卷轴碎片
                    boItme := UserItem99.Dura >= Need99;
                    if boItme then begin
                      Dec(UserItem99.Dura, Need99);
                      if UserItem99.Dura = 0 then begin
                        m_ItemList.Delete(I);
                        nCode := 9;
                        Dispose(UserItem99);
                      end else SendUpdateItem(UserItem99); //更新物品属性
                    end;
                  end else begin
                    SendAddItem(UserItem99);
                  end;
              end;
              Break;
            end;
          end; //for
          nCode := 10;
          if boItme then begin
          boItme := False;
          for I := m_ItemList.Count - 1 downto 0 do begin
            if m_ItemList.Count <= 0 then Break;
            UserItem98 := m_ItemList.Items[I];
            nCode := 5;
            if UserItem98 = nil then Continue;
            if (UserItem98.MakeIndex = XinJianDingData.Item3MakeIndex) then begin //
              nCode := 6;
              StdItem := UserEngine.GetStdItem(UserItem98.wIndex);
              if (StdItem <> nil) then begin
                nCode := 7;
                  if (StdItem.StdMode = 17) and ((StdItem.Shape) = 99) then begin //残卷
                    boItme := UserItem98.Dura >= Need98;
                    if boItme then begin
                      Dec(UserItem98.Dura, Need98);
                      if UserItem98.Dura = 0 then begin
                        m_ItemList.Delete(I);
                        nCode := 9;
                        Dispose(UserItem98);
                      end else SendUpdateItem(UserItem98); //更新物品属性
                    end;
                  end else begin
                    SendAddItem(UserItem98);
                  end;
              end;
              Break;
            end;
          end; //for

          end;
          if not boItme then
            DesUserItem := nil;
          if (DesUserItem <> nil) then begin //进行物品鉴定,失败触发脚本段给经验
            if boItme then begin
              if DesUserItem.btAppraisalLevel < 1 then
                DesUserItem.btAppraisalLevel := 10;
              StdItem := UserEngine.GetStdItem(DesUserItem.wIndex);
              nCode := 11;
              if (StdItem <> nil) then begin
                boChangeOK := True;
                {for I := 2 to 5 do begin
                  if XinJianDingData.ItemValueRetainMarks[I - 2] <> 0 then continue;//保留属性
                  
                  K := Random(230);
                  if (K >= 8) and (K<= 10) then
                    K := 11;
                  DesUserItem.btAppraisalValue[I] := K;
                end; }


                //可能导致假死By TasNat at: 2012-11-06 14:03:26
                      case StdItem.StdMode of
                        5, 6: begin //武器
                            nCode := 12;
                            nCount := 0;
                           
                            while nCount < 4 do begin
                              if ItemUnit.RandomKamPoWeapon(DesUserItem, nCount, False, XinJianDingData.ItemValueRetainMarks[nCount] = 0, False) then
                                Inc(nCount);
                            end;
                            //Inc(DesUserItem.btAppraisalLevel);
                          end;
                        10, 11: begin //衣服
                            nCode := 13;
                            nCount := 0;
                            while nCount < 4 do begin
                              if ItemUnit.RandomKamPoDre(DesUserItem, nCount, False, XinJianDingData.ItemValueRetainMarks[nCount] = 0, False) then
                                Inc(nCount);
                            end;
                            //Inc(DesUserItem.btAppraisalLevel);
                          end;
                        19, 20, 21, 28, 29: begin //项链
                            nCode := 14;
                            nCount := 0;
                            while nCount < 4 do begin
                              if ItemUnit.RandomKamPoNecklace(DesUserItem, nCount, False, XinJianDingData.ItemValueRetainMarks[nCount] = 0, False) then
                                Inc(nCount);
                            end;
                            //Inc(DesUserItem.btAppraisalLevel);
                          end;
                        24, 26: begin //手镯
                            nCode := 15;
                            nCount := 0;
                            while nCount < 4 do begin
                              if ItemUnit.RandomKamPoBracelet(DesUserItem, nCount, False, XinJianDingData.ItemValueRetainMarks[nCount] = 0, False) then
                                Inc(nCount);
                            end;
                            //Inc(DesUserItem.btAppraisalLevel);
                          end;
                        22, 23, 27: begin //戒指
                            nCode := 16;
                            nCount := 0;
                            while nCount < 4 do begin
                              if ItemUnit.RandomKamPoRing(DesUserItem, nCount, False, XinJianDingData.ItemValueRetainMarks[nCount] = 0, False) then
                                Inc(nCount);
                            end;
                            //Inc(DesUserItem.btAppraisalLevel);
                          end;
                        15, 16: begin //头盔斗笠
                            nCode := 17;
                            nCount := 0;
                            while nCount < 4 do begin
                              if ItemUnit.RandomKamPoHelme (DesUserItem, nCount, False, XinJianDingData.ItemValueRetainMarks[nCount] = 0, False) then
                                Inc(nCount);
                            end;
                            //Inc(DesUserItem.btAppraisalLevel);
                          end;
                        52, 54, 55, 62, 64: begin //鞋子、腰带
                            nCode := 18;
                            nCount := 0;
                            while nCount < 4 do begin
                              if ItemUnit.RandomKamPoShoes (DesUserItem, nCount, False, XinJianDingData.ItemValueRetainMarks[nCount] = 0, False) then
                                Inc(nCount);
                            end;
                            //Inc(DesUserItem.btAppraisalLevel);
                          end;
                        30: begin //勋章
                            nCode := 19;
                            nCount := 0;
                            while nCount < 4 do begin
                              if ItemUnit.RandomKamPoMedal (DesUserItem, nCount, False, XinJianDingData.ItemValueRetainMarks[nCount] = 0, False) then
                                Inc(nCount);
                            end;
                            //Inc(DesUserItem.btAppraisalLevel);
                          end;
                      end; 
                nCode := 13;
              end;
            end;
          end;
        end;
      end;
      nCode := 15;
      if DesUserItem <> nil then
        SendMsg(Self, RM_NewUSERKAMPO_OK, DesUserItem.btAppraisalValue[2], DesUserItem.btAppraisalValue[3], DesUserItem.btAppraisalValue[4], DesUserItem.btAppraisalValue[5], '')
      else
        SendMsg(Self, RM_NewUSERKAMPO_Fail, 0, 0, 0, 0, '');
      {if DesUserItem <> nil then
        m_DefMsg := MakeDefaultMsg(SM_NewUSERKAMPO_OK, DesUserItem.btAppraisalValue[2], DesUserItem.btAppraisalValue[3], DesUserItem.btAppraisalValue[4], DesUserItem.btAppraisalValue[5], 0)
      else m_DefMsg := MakeDefaultMsg(SM_NewUSERKAMPO_Fail, 0, 0, 0, 0, 0);
      SendSocket(@m_DefMsg, '');     }
    end;//if (not m_boDeath) and (not m_boGhost) then begin
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientUserNewKamPoItems Code:%d', [g_sExceptionVer, nCode]));
  end;
end;
//鉴定装备物品 20100822

procedure TPlayObject.ClientUserKamPoItems(nMakeIndex {装备制造ID}, nMakeIndex1 {卷轴制造ID}: Integer; nType {0-普通鉴定 1-高级鉴定}: Byte);
var
  I, nCount, K: Integer;
  UserItem, UserItem1, NewUserItem: pTUserItem;
  StdItem: pTStdItem;
  boItme, boChangeOK, boTraineeItem, boTrainee: Boolean;
  nCode: Byte;
begin
  try
    if (nMakeIndex <= 0) or (nMakeIndex1 <= 0) or (nType > 1) then Exit;
    //FillChar(boItemValueRetainMarks, SizeOf(boItemValueRetainMarks), 0);
    //DecodeBuffer(sItemValueRetainMarks, @boItemValueRetainMarks, SizeOf(boItemValueRetainMarks));
    nCode := 0;
    if (not m_boDeath) and (not m_boGhost) then begin
      nCount := 0;
      boItme := False;
      boTraineeItem := False;
      boTrainee := False;
      boChangeOK := False;
      if m_ItemList.Count > 0 then begin
        nCode := 1;
        for I := m_ItemList.Count - 1 downto 0 do begin
          if m_ItemList.Count <= 0 then Break;
          UserItem := m_ItemList.Items[I];
          nCode := 2;
          if UserItem = nil then Continue;
          if (UserItem.MakeIndex = nMakeIndex) then begin //得到物品，并判断是否可以鉴定
            nCode := 3;
            case UserItem.btAppraisalLevel of //判断进行几鉴
              1, 11, 21, 31, 41, 51: nCount := 1; //进行一鉴
              2, 12, 22, 32, 42, 52: nCount := 2; //进行二鉴
              3, 13, 23, 33, 43, 53: nCount := 3; //进行三鉴
            end;
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if StdItem <> nil then begin
              if (StdItem.StdMode = 5) and (StdItem.Need = 32767) then boTrainee := True; //见习宝物
            end;
            Break;
          end;
        end; //for
        nCode := 4;
        if (nCount in [1, 2, 3]) and (UserItem <> nil) then begin //三鉴内的才判断卷轴是否对应
          for I := m_ItemList.Count - 1 downto 0 do begin
            if m_ItemList.Count <= 0 then Break;
            UserItem1 := m_ItemList.Items[I];
            nCode := 5;
            if UserItem1 = nil then Continue;
            if (UserItem1.MakeIndex = nMakeIndex1) then begin //得到卷轴
              nCode := 6;
              StdItem := UserEngine.GetStdItem(UserItem1.wIndex);
              if (StdItem <> nil) then begin
                nCode := 7;
                if not boTrainee then begin //非见习宝物
                  if (StdItem.StdMode = 17) and ((StdItem.Shape - 238) = nCount) then begin //判断使用的卷轴是否正确
                    if UserItem1.Dura > 0 then Dec(UserItem1.Dura);
                    nCode := 8;
                    SendUpdateItem(UserItem1); //更新物品属性
                    if UserItem1.Dura <= 0 then begin
                      m_ItemList.Delete(I);
                      nCode := 9;
                      Dispose(UserItem1);
                    end;
                    boItme := True;
                  end else begin
                    SendAddItem(UserItem1);
                  end;
                end else begin
                  if (StdItem.StdMode = 44) and ((StdItem.Shape - 248) = nCount) then begin //见习卷轴 20100916
                    m_ItemList.Delete(I);
                    Dispose(UserItem1);
                    boTraineeItem := True;
                  end else begin
                    SendAddItem(UserItem1);
                  end;
                end;
              end;
              Break;
            end;
          end; //for
          nCode := 10;
          if (UserItem <> nil) then begin //进行物品鉴定,失败触发脚本段给经验
            if boItme then begin
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              nCode := 11;
              if (StdItem <> nil) then begin
                case nType of
                  0: begin //普通鉴定
                      case StdItem.StdMode of
                        5, 6: begin //武器
                            nCode := 12;
                            boChangeOK := ItemUnit.RandomKamPoWeapon(UserItem, nCount);
                            if boChangeOK then begin //加星,根据分值判断星级 20110117
                              if UserItem.btAppraisalLevel in [1..3, 11..13, 21..23, 31..33, 41..43] then begin
                                K := UserEngine.GetItemPoint(UserItem^, StdItem^, True);
                                case K of
                                  1..49: if UserItem.btAppraisalLevel < 11 then Inc(UserItem.btAppraisalLevel, 10); //一星
                                  50..99: if UserItem.btAppraisalLevel < 21 then Inc(UserItem.btAppraisalLevel, 10); //二星
                                  100..149: if UserItem.btAppraisalLevel < 31 then Inc(UserItem.btAppraisalLevel, 10); //三星
                                  150..249: if UserItem.btAppraisalLevel < 41 then Inc(UserItem.btAppraisalLevel, 10); //四星
                                end;
                              end;
                            end;
                            Inc(UserItem.btAppraisalLevel);
                          end;
                        10, 11: begin //衣服
                            nCode := 13;
                            boChangeOK := ItemUnit.RandomKamPoDre(UserItem, nCount);
                            if boChangeOK then begin //加星
                              if UserItem.btAppraisalLevel in [1..3, 11..13, 21..23, 31..33, 41..43] then begin
                                K := UserEngine.GetItemPoint(UserItem^, StdItem^, True);
                                case K of
                                  1..49: if UserItem.btAppraisalLevel < 11 then Inc(UserItem.btAppraisalLevel, 10); //一星
                                  50..99: if UserItem.btAppraisalLevel < 21 then Inc(UserItem.btAppraisalLevel, 10); //二星
                                  100..149: if UserItem.btAppraisalLevel < 31 then Inc(UserItem.btAppraisalLevel, 10); //三星
                                  150..249: if UserItem.btAppraisalLevel < 41 then Inc(UserItem.btAppraisalLevel, 10); //四星
                                end;
                              end;
                            end;
                            Inc(UserItem.btAppraisalLevel);
                          end;
                        19, 20, 21, 28, 29: begin //项链
                            nCode := 14;
                            boChangeOK := ItemUnit.RandomKamPoNecklace(UserItem, nCount);
                            if boChangeOK then begin //加星
                              if UserItem.btAppraisalLevel in [1..3, 11..13, 21..23, 31..33, 41..43] then begin
                                K := UserEngine.GetItemPoint(UserItem^, StdItem^, True);
                                case K of
                                  1..49: if UserItem.btAppraisalLevel < 11 then Inc(UserItem.btAppraisalLevel, 10); //一星
                                  50..99: if UserItem.btAppraisalLevel < 21 then Inc(UserItem.btAppraisalLevel, 10); //二星
                                  100..149: if UserItem.btAppraisalLevel < 31 then Inc(UserItem.btAppraisalLevel, 10); //三星
                                  150..249: if UserItem.btAppraisalLevel < 41 then Inc(UserItem.btAppraisalLevel, 10); //四星
                                end;
                              end;
                            end;
                            Inc(UserItem.btAppraisalLevel);
                          end;
                        24, 26: begin //手镯
                            nCode := 15;
                            boChangeOK := ItemUnit.RandomKamPoBracelet(UserItem, nCount);
                            if boChangeOK then begin //加星
                              if UserItem.btAppraisalLevel in [1..3, 11..13, 21..23, 31..33, 41..43] then begin
                                K := UserEngine.GetItemPoint(UserItem^, StdItem^, True);
                                case K of
                                  1..49: if UserItem.btAppraisalLevel < 11 then Inc(UserItem.btAppraisalLevel, 10); //一星
                                  50..99: if UserItem.btAppraisalLevel < 21 then Inc(UserItem.btAppraisalLevel, 10); //二星
                                  100..149: if UserItem.btAppraisalLevel < 31 then Inc(UserItem.btAppraisalLevel, 10); //三星
                                  150..249: if UserItem.btAppraisalLevel < 41 then Inc(UserItem.btAppraisalLevel, 10); //四星
                                end;
                              end;
                            end;
                            Inc(UserItem.btAppraisalLevel);
                          end;
                        22, 23, 27: begin //戒指
                            nCode := 16;
                            boChangeOK := ItemUnit.RandomKamPoRing(UserItem, nCount);
                            if boChangeOK then begin //加星
                              if UserItem.btAppraisalLevel in [1..3, 11..13, 21..23, 31..33, 41..43] then begin
                                K := UserEngine.GetItemPoint(UserItem^, StdItem^, True);
                                case K of
                                  1..49: if UserItem.btAppraisalLevel < 11 then Inc(UserItem.btAppraisalLevel, 10); //一星
                                  50..99: if UserItem.btAppraisalLevel < 21 then Inc(UserItem.btAppraisalLevel, 10); //二星
                                  100..149: if UserItem.btAppraisalLevel < 31 then Inc(UserItem.btAppraisalLevel, 10); //三星
                                  150..249: if UserItem.btAppraisalLevel < 41 then Inc(UserItem.btAppraisalLevel, 10); //四星
                                end;
                              end;
                            end;
                            Inc(UserItem.btAppraisalLevel);
                          end;
                        15, 16: begin //头盔斗笠
                            nCode := 17;
                            boChangeOK := ItemUnit.RandomKamPoHelme(UserItem, nCount);
                            if boChangeOK then begin //加星
                              if UserItem.btAppraisalLevel in [1..3, 11..13, 21..23, 31..33, 41..43] then begin
                                K := UserEngine.GetItemPoint(UserItem^, StdItem^, True);
                                case K of
                                  1..49: if UserItem.btAppraisalLevel < 11 then Inc(UserItem.btAppraisalLevel, 10); //一星
                                  50..99: if UserItem.btAppraisalLevel < 21 then Inc(UserItem.btAppraisalLevel, 10); //二星
                                  100..149: if UserItem.btAppraisalLevel < 31 then Inc(UserItem.btAppraisalLevel, 10); //三星
                                  150..249: if UserItem.btAppraisalLevel < 41 then Inc(UserItem.btAppraisalLevel, 10); //四星
                                end;
                              end;
                            end;
                            Inc(UserItem.btAppraisalLevel);
                          end;
                        52, 54, 55, 62, 64: begin //鞋子、腰带
                            nCode := 18;
                            boChangeOK := ItemUnit.RandomKamPoShoes(UserItem, nCount);
                            if boChangeOK then begin //加星
                              if UserItem.btAppraisalLevel in [1..3, 11..13, 21..23, 31..33, 41..43] then begin
                                K := UserEngine.GetItemPoint(UserItem^, StdItem^, True);
                                case K of
                                  1..49: if UserItem.btAppraisalLevel < 11 then Inc(UserItem.btAppraisalLevel, 10); //一星
                                  50..99: if UserItem.btAppraisalLevel < 21 then Inc(UserItem.btAppraisalLevel, 10); //二星
                                  100..149: if UserItem.btAppraisalLevel < 31 then Inc(UserItem.btAppraisalLevel, 10); //三星
                                  150..249: if UserItem.btAppraisalLevel < 41 then Inc(UserItem.btAppraisalLevel, 10); //四星
                                end;
                              end;
                            end;
                            Inc(UserItem.btAppraisalLevel);
                          end;
                        30: begin //勋章
                            nCode := 19;
                            boChangeOK := ItemUnit.RandomKamPoMedal(UserItem, nCount);
                            if boChangeOK then begin //加星
                              if UserItem.btAppraisalLevel in [1..3, 11..13, 21..23, 31..33, 41..43] then begin
                                K := UserEngine.GetItemPoint(UserItem^, StdItem^, True);
                                case K of
                                  1..49: if UserItem.btAppraisalLevel < 11 then Inc(UserItem.btAppraisalLevel, 10); //一星
                                  50..99: if UserItem.btAppraisalLevel < 21 then Inc(UserItem.btAppraisalLevel, 10); //二星
                                  100..149: if UserItem.btAppraisalLevel < 31 then Inc(UserItem.btAppraisalLevel, 10); //三星
                                  150..249: if UserItem.btAppraisalLevel < 41 then Inc(UserItem.btAppraisalLevel, 10); //四星
                                end;
                              end;
                            end;
                            Inc(UserItem.btAppraisalLevel);
                          end;
                      end;
                      SendUpdateItem(UserItem); //更新物品属性
                    end;
                  1: begin //高级鉴定
                      if (CompareText(StdItem.Name, g_Config.sArmsReplace) <> 1) and
                        (CompareText(StdItem.Name, g_Config.sDreReplaceMan) <> 1) and
                        (CompareText(StdItem.Name, g_Config.sDreReplaceWoman) <> 1) and
                        (CompareText(StdItem.Name, g_Config.sNecklaceReplace) <> 1) and
                        (CompareText(StdItem.Name, g_Config.sBraceletReplace) <> 1) and
                        (CompareText(StdItem.Name, g_Config.sRingReplace) <> 1) and
                        (CompareText(StdItem.Name, g_Config.sHelmeReplace) <> 1) and
                        (CompareText(StdItem.Name, g_Config.sBeltReplace) <> 1) and
                        (CompareText(StdItem.Name, g_Config.sShoesReplace) <> 1) and
                        (CompareText(StdItem.Name, g_Config.sHatsReplace) <> 1) and
                        (CompareText(StdItem.Name, g_Config.sWashclothReplace) <> 1) and
                        (CompareText(StdItem.Name, g_Config.sMedalReplace) <> 1) and
                        (Random(g_Config.nAdvancedKamPo) = 0) then begin //替换成主宰装备
                        if DelBagItem(nMakeIndex, StdItem.Name) then begin //删除原物品成功
                          case StdItem.StdMode of
                            5, 6: begin //武器
                                New(NewUserItem);
                                if UserEngine.CopyToUserItemFromName(g_Config.sArmsReplace, NewUserItem) then begin
                                  AddGameDataLog('45' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                    IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + g_Config.sArmsReplace + #9 +
                                    IntToStr(NewUserItem.MakeIndex) + #9 + IntToStr(NewUserItem.Dura) + '/' + IntToStr(NewUserItem.DuraMax) + #9 + StdItem.Name + '(' + IntTostr(nMakeIndex) + ')');
                                  ItemUnit.RandomKamPoMysteryCount(NewUserItem, 1); //神秘属性
                                  m_ItemList.Add(NewUserItem);
                                  SendUpdateKamPoItem(NewUserItem);
                                  boChangeOK := True;
                                end else Dispose(NewUserItem);
                              end;
                            10: begin //男衣
                                New(NewUserItem);
                                if UserEngine.CopyToUserItemFromName(g_Config.sDreReplaceMan, NewUserItem) then begin
                                  AddGameDataLog('45' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                    IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + g_Config.sDreReplaceMan + #9 +
                                    IntToStr(NewUserItem.MakeIndex) + #9 + IntToStr(NewUserItem.Dura) + '/' + IntToStr(NewUserItem.DuraMax) + #9 + StdItem.Name + '(' + IntTostr(nMakeIndex) + ')');
                                  ItemUnit.RandomKamPoMysteryCount(NewUserItem, 1); //神秘
                                  m_ItemList.Add(NewUserItem);
                                  SendUpdateKamPoItem(NewUserItem);
                                  boChangeOK := True;
                                end else Dispose(NewUserItem);
                              end;
                            11: begin //女衣
                                New(NewUserItem);
                                if UserEngine.CopyToUserItemFromName(g_Config.sDreReplaceWoman, NewUserItem) then begin
                                  AddGameDataLog('45' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                    IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + g_Config.sDreReplaceWoman + #9 +
                                    IntToStr(NewUserItem.MakeIndex) + #9 + IntToStr(NewUserItem.Dura) + '/' + IntToStr(NewUserItem.DuraMax) + #9 + StdItem.Name + '(' + IntTostr(nMakeIndex) + ')');
                                  ItemUnit.RandomKamPoMysteryCount(NewUserItem, 1); //神秘
                                  m_ItemList.Add(NewUserItem);
                                  SendUpdateKamPoItem(NewUserItem);
                                  boChangeOK := True;
                                end else Dispose(NewUserItem);
                              end;
                            19, 20, 21, 28, 29: begin //项链
                                New(NewUserItem);
                                if UserEngine.CopyToUserItemFromName(g_Config.sNecklaceReplace, NewUserItem) then begin
                                  AddGameDataLog('45' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                    IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + g_Config.sNecklaceReplace + #9 +
                                    IntToStr(NewUserItem.MakeIndex) + #9 + IntToStr(NewUserItem.Dura) + '/' + IntToStr(NewUserItem.DuraMax) + #9 + StdItem.Name + '(' + IntTostr(nMakeIndex) + ')');
                                  ItemUnit.RandomKamPoMysteryCount(NewUserItem, 1); //神秘
                                  m_ItemList.Add(NewUserItem);
                                  SendUpdateKamPoItem(NewUserItem);
                                  boChangeOK := True;
                                end else Dispose(NewUserItem);
                              end;
                            24, 26: begin //手镯
                                New(NewUserItem);
                                if UserEngine.CopyToUserItemFromName(g_Config.sBraceletReplace, NewUserItem) then begin
                                  AddGameDataLog('45' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                    IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + g_Config.sBraceletReplace + #9 +
                                    IntToStr(NewUserItem.MakeIndex) + #9 + IntToStr(NewUserItem.Dura) + '/' + IntToStr(NewUserItem.DuraMax) + #9 + StdItem.Name + '(' + IntTostr(nMakeIndex) + ')');
                                  ItemUnit.RandomKamPoMysteryCount(NewUserItem, 1); //神秘
                                  m_ItemList.Add(NewUserItem);
                                  SendUpdateKamPoItem(NewUserItem);
                                  boChangeOK := True;
                                end else Dispose(NewUserItem);
                              end;
                            22, 23, 27: begin //戒指
                                New(NewUserItem);
                                if UserEngine.CopyToUserItemFromName(g_Config.sRingReplace, NewUserItem) then begin
                                  AddGameDataLog('45' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                    IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + g_Config.sRingReplace + #9 +
                                    IntToStr(NewUserItem.MakeIndex) + #9 + IntToStr(NewUserItem.Dura) + '/' + IntToStr(NewUserItem.DuraMax) + #9 + StdItem.Name + '(' + IntTostr(nMakeIndex) + ')');
                                  ItemUnit.RandomKamPoMysteryCount(NewUserItem, 1); //神秘
                                  m_ItemList.Add(NewUserItem);
                                  SendUpdateKamPoItem(NewUserItem);
                                  boChangeOK := True;
                                end else Dispose(NewUserItem);
                              end;
                            15: begin //头盔
                                New(NewUserItem);
                                if UserEngine.CopyToUserItemFromName(g_Config.sHelmeReplace, NewUserItem) then begin
                                  AddGameDataLog('45' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                    IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + g_Config.sHelmeReplace + #9 +
                                    IntToStr(NewUserItem.MakeIndex) + #9 + IntToStr(NewUserItem.Dura) + '/' + IntToStr(NewUserItem.DuraMax) + #9 + StdItem.Name + '(' + IntTostr(nMakeIndex) + ')');
                                  ItemUnit.RandomKamPoMysteryCount(NewUserItem, 1); //神秘
                                  m_ItemList.Add(NewUserItem);
                                  SendUpdateKamPoItem(NewUserItem);
                                  boChangeOK := True;
                                end else Dispose(NewUserItem);
                              end;
                            52, 62: begin //鞋子
                                New(NewUserItem);
                                if UserEngine.CopyToUserItemFromName(g_Config.sShoesReplace, NewUserItem) then begin
                                  AddGameDataLog('45' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                    IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + g_Config.sShoesReplace + #9 +
                                    IntToStr(NewUserItem.MakeIndex) + #9 + IntToStr(NewUserItem.Dura) + '/' + IntToStr(NewUserItem.DuraMax) + #9 + StdItem.Name + '(' + IntTostr(nMakeIndex) + ')');
                                  ItemUnit.RandomKamPoMysteryCount(NewUserItem, 1); //神秘
                                  m_ItemList.Add(NewUserItem);
                                  SendUpdateKamPoItem(NewUserItem);
                                  boChangeOK := True;
                                end else Dispose(NewUserItem);
                              end;
                            54, 64: begin //腰带
                                New(NewUserItem);
                                if UserEngine.CopyToUserItemFromName(g_Config.sBeltReplace, NewUserItem) then begin
                                  AddGameDataLog('45' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                    IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + g_Config.sBeltReplace + #9 +
                                    IntToStr(NewUserItem.MakeIndex) + #9 + IntToStr(NewUserItem.Dura) + '/' + IntToStr(NewUserItem.DuraMax) + #9 + StdItem.Name + '(' + IntTostr(nMakeIndex) + ')');
                                  ItemUnit.RandomKamPoMysteryCount(NewUserItem, 1); //神秘
                                  m_ItemList.Add(NewUserItem);
                                  SendUpdateKamPoItem(NewUserItem);
                                  boChangeOK := True;
                                end else Dispose(NewUserItem);
                              end;
                            16: begin //斗笠
                                if StdItem.Shape = 2 then begin //面巾
                                  New(NewUserItem);
                                  if UserEngine.CopyToUserItemFromName(g_Config.sWashclothReplace, NewUserItem) then begin
                                    AddGameDataLog('45' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                      IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + g_Config.sWashclothReplace + #9 +
                                      IntToStr(NewUserItem.MakeIndex) + #9 + IntToStr(NewUserItem.Dura) + '/' + IntToStr(NewUserItem.DuraMax) + #9 + StdItem.Name + '(' + IntTostr(nMakeIndex) + ')');
                                    ItemUnit.RandomKamPoMysteryCount(NewUserItem, 1); //神秘
                                    m_ItemList.Add(NewUserItem);
                                    SendUpdateKamPoItem(NewUserItem);
                                    boChangeOK := True;
                                  end else Dispose(NewUserItem);
                                end else begin
                                  New(NewUserItem);
                                  if UserEngine.CopyToUserItemFromName(g_Config.sHatsReplace, NewUserItem) then begin
                                    AddGameDataLog('45' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                      IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + g_Config.sHatsReplace + #9 +
                                      IntToStr(NewUserItem.MakeIndex) + #9 + IntToStr(NewUserItem.Dura) + '/' + IntToStr(NewUserItem.DuraMax) + #9 + StdItem.Name + '(' + IntTostr(nMakeIndex) + ')');
                                    ItemUnit.RandomKamPoMysteryCount(NewUserItem, 1); //神秘
                                    m_ItemList.Add(NewUserItem);
                                    SendUpdateKamPoItem(NewUserItem);
                                    boChangeOK := True;
                                  end else Dispose(NewUserItem);
                                end;
                              end;
                            30: begin //勋章
                                New(NewUserItem);
                                if UserEngine.CopyToUserItemFromName(g_Config.sMedalReplace, NewUserItem) then begin
                                  AddGameDataLog('45' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                                    IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + g_Config.sMedalReplace + #9 +
                                    IntToStr(NewUserItem.MakeIndex) + #9 + IntToStr(NewUserItem.Dura) + '/' + IntToStr(NewUserItem.DuraMax) + #9 + StdItem.Name + '(' + IntTostr(nMakeIndex) + ')');
                                  ItemUnit.RandomKamPoMysteryCount(NewUserItem, 1); //神秘属性
                                  m_ItemList.Add(NewUserItem);
                                  SendUpdateKamPoItem(NewUserItem);
                                  boChangeOK := True;
                                end else Dispose(NewUserItem);
                              end;
                          end; //case
                        end;
                      end else begin
                        case StdItem.StdMode of
                          5, 6: begin //武器
                              nCode := 12;
                              boChangeOK := ItemUnit.RandomKamPoWeapon(UserItem, nCount);
                              if boChangeOK then begin //加星
                                if UserItem.btAppraisalLevel in [1..3, 11..13, 21..23, 31..33, 41..43] then begin
                                  K := UserEngine.GetItemPoint(UserItem^, StdItem^, True);
                                  case K of
                                    1..49: if UserItem.btAppraisalLevel < 11 then Inc(UserItem.btAppraisalLevel, 10); //一星
                                    50..99: if UserItem.btAppraisalLevel < 21 then Inc(UserItem.btAppraisalLevel, 10); //二星
                                    100..149: if UserItem.btAppraisalLevel < 31 then Inc(UserItem.btAppraisalLevel, 10); //三星
                                    150..249: if UserItem.btAppraisalLevel < 41 then Inc(UserItem.btAppraisalLevel, 10); //四星
                                  end;
                                end;
                              end;
                              Inc(UserItem.btAppraisalLevel);
                            end;
                          10, 11: begin //衣服
                              nCode := 13;
                              boChangeOK := ItemUnit.RandomKamPoDre(UserItem, nCount);
                              if boChangeOK then begin //加星
                                if UserItem.btAppraisalLevel in [1..3, 11..13, 21..23, 31..33, 41..43] then begin
                                  K := UserEngine.GetItemPoint(UserItem^, StdItem^, True);
                                  case K of
                                    1..49: if UserItem.btAppraisalLevel < 11 then Inc(UserItem.btAppraisalLevel, 10); //一星
                                    50..99: if UserItem.btAppraisalLevel < 21 then Inc(UserItem.btAppraisalLevel, 10); //二星
                                    100..149: if UserItem.btAppraisalLevel < 31 then Inc(UserItem.btAppraisalLevel, 10); //三星
                                    150..249: if UserItem.btAppraisalLevel < 41 then Inc(UserItem.btAppraisalLevel, 10); //四星
                                  end;
                                end;
                              end;
                              Inc(UserItem.btAppraisalLevel);
                            end;
                          19, 20, 21, 28, 29: begin //项链
                              nCode := 14;
                              boChangeOK := ItemUnit.RandomKamPoNecklace(UserItem, nCount);
                              if boChangeOK then begin //加星
                                if UserItem.btAppraisalLevel in [1..3, 11..13, 21..23, 31..33, 41..43] then begin
                                  K := UserEngine.GetItemPoint(UserItem^, StdItem^, True);
                                  case K of
                                    1..49: if UserItem.btAppraisalLevel < 11 then Inc(UserItem.btAppraisalLevel, 10); //一星
                                    50..99: if UserItem.btAppraisalLevel < 21 then Inc(UserItem.btAppraisalLevel, 10); //二星
                                    100..149: if UserItem.btAppraisalLevel < 31 then Inc(UserItem.btAppraisalLevel, 10); //三星
                                    150..249: if UserItem.btAppraisalLevel < 41 then Inc(UserItem.btAppraisalLevel, 10); //四星
                                  end;
                                end;
                              end;
                              Inc(UserItem.btAppraisalLevel);
                            end;
                          24, 26: begin //手镯
                              nCode := 15;
                              boChangeOK := ItemUnit.RandomKamPoBracelet(UserItem, nCount);
                              if boChangeOK then begin //加星
                                if UserItem.btAppraisalLevel in [1..3, 11..13, 21..23, 31..33, 41..43] then begin
                                  K := UserEngine.GetItemPoint(UserItem^, StdItem^, True);
                                  case K of
                                    1..49: if UserItem.btAppraisalLevel < 11 then Inc(UserItem.btAppraisalLevel, 10); //一星
                                    50..99: if UserItem.btAppraisalLevel < 21 then Inc(UserItem.btAppraisalLevel, 10); //二星
                                    100..149: if UserItem.btAppraisalLevel < 31 then Inc(UserItem.btAppraisalLevel, 10); //三星
                                    150..249: if UserItem.btAppraisalLevel < 41 then Inc(UserItem.btAppraisalLevel, 10); //四星
                                  end;
                                end;
                              end;
                              Inc(UserItem.btAppraisalLevel);
                            end;
                          22, 23, 27: begin //戒指
                              nCode := 16;
                              boChangeOK := ItemUnit.RandomKamPoRing(UserItem, nCount);
                              if boChangeOK then begin //加星
                                if UserItem.btAppraisalLevel in [1..3, 11..13, 21..23, 31..33, 41..43] then begin
                                  K := UserEngine.GetItemPoint(UserItem^, StdItem^, True);
                                  case K of
                                    1..49: if UserItem.btAppraisalLevel < 11 then Inc(UserItem.btAppraisalLevel, 10); //一星
                                    50..99: if UserItem.btAppraisalLevel < 21 then Inc(UserItem.btAppraisalLevel, 10); //二星
                                    100..149: if UserItem.btAppraisalLevel < 31 then Inc(UserItem.btAppraisalLevel, 10); //三星
                                    150..249: if UserItem.btAppraisalLevel < 41 then Inc(UserItem.btAppraisalLevel, 10); //四星
                                  end;
                                end;
                              end;
                              Inc(UserItem.btAppraisalLevel);
                            end;
                          15, 16: begin //头盔斗笠
                              nCode := 17;
                              boChangeOK := ItemUnit.RandomKamPoHelme(UserItem, nCount);
                              if boChangeOK then begin //加星
                                if UserItem.btAppraisalLevel in [1..3, 11..13, 21..23, 31..33, 41..43] then begin
                                  K := UserEngine.GetItemPoint(UserItem^, StdItem^, True);
                                  case K of
                                    1..49: if UserItem.btAppraisalLevel < 11 then Inc(UserItem.btAppraisalLevel, 10); //一星
                                    50..99: if UserItem.btAppraisalLevel < 21 then Inc(UserItem.btAppraisalLevel, 10); //二星
                                    100..149: if UserItem.btAppraisalLevel < 31 then Inc(UserItem.btAppraisalLevel, 10); //三星
                                    150..249: if UserItem.btAppraisalLevel < 41 then Inc(UserItem.btAppraisalLevel, 10); //四星
                                  end;
                                end;
                              end;
                              Inc(UserItem.btAppraisalLevel);
                            end;
                          52, 54, 55, 62, 64: begin //鞋子、腰带
                              nCode := 18;
                              boChangeOK := ItemUnit.RandomKamPoShoes(UserItem, nCount);
                              if boChangeOK then begin //加星
                                if UserItem.btAppraisalLevel in [1..3, 11..13, 21..23, 31..33, 41..43] then begin
                                  K := UserEngine.GetItemPoint(UserItem^, StdItem^, True);
                                  case K of
                                    1..49: if UserItem.btAppraisalLevel < 11 then Inc(UserItem.btAppraisalLevel, 10); //一星
                                    50..99: if UserItem.btAppraisalLevel < 21 then Inc(UserItem.btAppraisalLevel, 10); //二星
                                    100..149: if UserItem.btAppraisalLevel < 31 then Inc(UserItem.btAppraisalLevel, 10); //三星
                                    150..249: if UserItem.btAppraisalLevel < 41 then Inc(UserItem.btAppraisalLevel, 10); //四星
                                  end;
                                end;
                              end;
                              Inc(UserItem.btAppraisalLevel);
                            end;
                          30: begin //勋章
                              nCode := 19;
                              boChangeOK := ItemUnit.RandomKamPoMedal(UserItem, nCount);
                              if boChangeOK then begin //加星
                                if UserItem.btAppraisalLevel in [1..3, 11..13, 21..23, 31..33, 41..43] then begin
                                  K := UserEngine.GetItemPoint(UserItem^, StdItem^, True);
                                  case K of
                                    1..49: if UserItem.btAppraisalLevel < 11 then Inc(UserItem.btAppraisalLevel, 10); //一星
                                    50..99: if UserItem.btAppraisalLevel < 21 then Inc(UserItem.btAppraisalLevel, 10); //二星
                                    100..149: if UserItem.btAppraisalLevel < 31 then Inc(UserItem.btAppraisalLevel, 10); //三星
                                    150..249: if UserItem.btAppraisalLevel < 41 then Inc(UserItem.btAppraisalLevel, 10); //四星
                                  end;
                                end;
                              end;
                              Inc(UserItem.btAppraisalLevel);
                            end;
                        end;
                        SendUpdateItem(UserItem); //更新物品属性
                      end;
                    end;
                end;
                nCode := 13;

                if (not boChangeOK) and (nCount in [1, 2, 3]) then begin //失败触发脚本段
                  nCode := 14;
                  if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(Self, '@KamPoFail' + IntToStr(nCount), False, False);
                end;
              end;
            end else
              if boTraineeItem then begin //见习物品+见习卷轴
                boChangeOK := ItemUnit.TraineeItemKamPoWeapon(UserItem, nCount);
                if (Random(10) = 0) and boChangeOK then begin //加星
                  if UserItem.btAppraisalLevel in [1..3, 11..13, 21..23, 31..33, 41..43] then Inc(UserItem.btAppraisalLevel, 10);
                end;
                Inc(UserItem.btAppraisalLevel);
                SendUpdateItem(UserItem); //更新物品属性
              end;
          end;
        end;
      end;
      nCode := 15;
      if boChangeOK then
        SendMsg(Self, RM_USERKAMPO_OK, 0, 0, 0, 0, '')
      else SendMsg(Self, RM_USERKAMPO_FAIL, 0, 0, 0, 0, '');
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientUserKamPoItems Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

//更新鉴定物品格物品(高级鉴定，普通物品鉴定为主宰装备时使用) 20100825

procedure TPlayObject.SendUpdateKamPoItem(UserItem: pTUserItem);
var
  pStdItem: pTStdItem;
  StdItem: TStdItem;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  sUserItemName: string;
begin
  if m_nSoftVersionDateEx = 0 then begin
    pStdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if pStdItem = nil then Exit;
    StdItem := pStdItem^;
    ItemUnit.GetItemAddValue(UserItem, StdItem);
    CopyStdItemToOStdItem(@StdItem, @OClientItem.s);
    //取自定义物品名称
    sUserItemName := '';
    if UserItem.btValue[13] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if sUserItemName <> '' then
      OClientItem.s.Name := sUserItemName;

    OClientItem.MakeIndex := UserItem.MakeIndex;
    OClientItem.Dura := UserItem.Dura;
    OClientItem.DuraMax := UserItem.DuraMax;

    if StdItem.StdMode in [15, 19, 20, 21, 22, 23, 24, 26, 27, 28, 29] then begin //20100513 修改 20100628 增加29分类(敏捷幸运型项链)
      if UserItem.btValue[8] = 0 then OClientItem.s.Shape := 0
      else OClientItem.s.Shape := 130;
    end;

    m_DefMsg := MakeDefaultMsg(SM_ADDITEM, Integer(Self), 0, 0, 1, 0);
    SendSocket(@m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
  end else begin
    pStdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if pStdItem = nil then Exit;
    StdItem := pStdItem^;
    ItemUnit.GetItemAddValue(UserItem, StdItem);
    Move(StdItem, ClientItem.s, SizeOf(TStdItem));
    //取自定义物品名称
    sUserItemName := '';
    if UserItem.btValue[13] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if (UserItem.btValue[12] = 1) and (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) then ClientItem.s.Reserved1 := 1 //物品发光 20080223
    else ClientItem.s.Reserved1 := 0;
    if sUserItemName <> '' then ClientItem.s.Name := sUserItemName;

    ClientItem.MakeIndex := UserItem.MakeIndex;
    ClientItem.Dura := UserItem.Dura;
    ClientItem.DuraMax := UserItem.DuraMax;
    //Modified By TasNat at: 2012-04-12 09:28:18
    ClientItem.btAppraisalLevel :=   UserItem.btAppraisalLevel;
    ClientItem.btUnKnowValueCount := UserItem.btUnKnowValueCount;
    Move(UserItem.btAppraisalValue, ClientItem.btAppraisalValue, SizeOf(ClientItem.btAppraisalValue));

    Move(UserItem.btUnKnowValue, ClientItem.btUnKnowValue, SizeOf(ClientItem.btUnKnowValue)); //20100822
    ClientItem.BindValue := UserItem.AddValue[0]; //20110622
    ClientItem.MaxDate := UserItem.MaxDate; //20110622
    if ClientItem.BindValue = 0 then begin //禁止交易,扔物品,显示绑定 20110626
      if (CheckItemValue(UserItem, 1) and CheckItemValue(UserItem, 0)) or
        (GetCheckItemList(0, StdItem.Name) and GetCheckItemList(1, StdItem.Name)) then
        ClientItem.BindValue := 3;
    end;
    case StdItem.StdMode of //20081009 修改
      5, 6: begin
          ClientItem.s.NeedIdentify := _MIN(High(Byte), UserItem.btValue[11] + UserItem.btValue[20]); //武器暴击等级 20100708
          if CheckItemSpiritMedia(UserItem) then begin
            ClientItem.Aura := UserItem.btValue[12];
            ClientItem.MaxAura := g_Config.nMaxAuraValue;
          end;
        end;
      44: begin
          if StdItem.Shape = 255 then ClientItem.s.NeedIdentify := UserItem.btValue[0];
          if StdItem.Shape = 253 then begin //除魔灵媒
            ClientItem.Aura := UserItem.btValue[11];
            ClientItem.MaxAura := g_Config.nMaxAuraValue;
          end;
        end;
      10, 11, 16, 30, 52, 54, 55, 62, 64: begin
          if CheckItemSpiritMedia(UserItem) then begin
            ClientItem.Aura := UserItem.btValue[11];
            ClientItem.MaxAura := g_Config.nMaxAuraValue;
          end;
        end;
      15, 19..24, 26..29: begin
          if UserItem.btValue[8] <> 0 then ClientItem.s.Shape := 130; //20100513 修改 20100628 增加29分类(敏捷幸运型项链)
          if CheckItemSpiritMedia(UserItem) then begin
            ClientItem.Aura := UserItem.btValue[11];
            ClientItem.MaxAura := g_Config.nMaxAuraValue;
          end;
        end;
    end;
    m_DefMsg := MakeDefaultMsg(SM_UPDATEKAMPOITME, Integer(Self), 0, 0, 1, 0);
    SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(ClientItem)));
  end;
end;

//更换鉴定物品 20100822

procedure TPlayObject.ClientChangeKamPoItems(nMakeIndex {装备制造ID}, nMakeIndex1 {幸运符制造ID}: Integer);
var
  I, n14, K: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  boItme, boChangeOK: Boolean;
  nCode: byte;
begin
  try
    if (nMakeIndex <= 0) or (nMakeIndex1 <= 0) then Exit;
    nCode := 0;
    if (not m_boDeath) and (not m_boGhost) then begin
      boItme := False;
      boChangeOK := False;
      n14 := -1;
      if m_ItemList.Count > 0 then begin
        nCode := 1;
        for I := m_ItemList.Count - 1 downto 0 do begin
          if m_ItemList.Count <= 0 then Break;
          UserItem := m_ItemList.Items[I];
          nCode := 2;
          if UserItem = nil then Continue;
          if (UserItem.MakeIndex = nMakeIndex1) then begin //得到幸运符
            nCode := 3;
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if (StdItem <> nil) then begin
              nCode := 4;
              if (StdItem.StdMode = 18) then begin
                boItme := True;
                n14 := I;
              end;
            end;
            Break;
          end;
        end; //for
        if boItme then begin
          nCode := 5;
          for I := m_ItemList.Count - 1 downto 0 do begin
            if m_ItemList.Count <= 0 then Break;
            UserItem := m_ItemList.Items[I];
            if UserItem = nil then Continue;
            nCode := 6;
            if (UserItem.MakeIndex = nMakeIndex) then begin //得到装备
              if UserItem.btAppraisalLevel in [2..4, 12..14, 22..24, 32..34, 42..44, 52..54] then begin //鉴定过的物品
                nCode := 7;
                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                if (StdItem <> nil) then begin
                  if not ((StdItem.StdMode = 5) and (StdItem.Need = 32767)) then begin //非见习宝物
                    if DelBagItem(n14) then begin //删除幸运符成功，则初始装备鉴定属性
                      nCode := 8;
                      //Modified By TasNat at: 2012-04-12 09:28:18
                      UserItem.btAppraisalLevel :=   0;
                      UserItem.btUnKnowValueCount := 0;
                      FillChar(UserItem.btAppraisalValue, SizeOf(UserItem.btAppraisalValue), 0);

                      FillChar(UserItem^.btUnKnowValue, SizeOf(UserItem^.btUnKnowValue), 0);
                      nCode := 9;
                      UserItem.btAppraisalLevel := 1;
                      K := UserEngine.GetItemPoint(UserItem^, StdItem^, False);
                      case K of
                        0: ;
                        1..49: UserItem.btAppraisalLevel := 11; //一星
                        50..99: UserItem.btAppraisalLevel := 21; //二星
                        100..149: UserItem.btAppraisalLevel := 31; //三星
                        150..249: UserItem.btAppraisalLevel := 41; //四星
                        250..65535: UserItem.btAppraisalLevel := 51; //五星
                      end;
                      boChangeOK := True;
                      nCode := 10;
                      SendUpdateItem(UserItem); //更新物品
                    end;
                  end;
                end;
              end;
              Break;
            end;
          end; //for
        end;
      end;
      nCode := 11;
      if boChangeOK then
        SendMsg(Self, RM_USERCHANGEKAMPO_OK, 0, 0, 0, 0, '')
      else SendMsg(Self, RM_USERCHANGEKAMPO_FAIL, 0, 0, 0, 0, '');
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientChangeKamPoItems Code:%d', [g_sExceptionVer, nCode]));
  end;
end;
//发送精力值和幸运值

procedure TPlayObject.SendEnergyAndLucky();
begin
  m_DefMsg := MakeDefaultMsg(SM_OPENSCROLLFRM, m_nEnergyValue {精力值}, m_nLuckyValue {幸运值}, 0, 0, 0);
  SendSocket(@m_DefMsg, '');
end;

//使用羊皮卷制造神秘卷轴 20100826

procedure TPlayObject.ClientUserMakeScrollItems(nMakeIndex: Integer; nType: Byte);
var
  I, n14, n15: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  boItme, boChangeOK: Boolean;
  nCode: byte;
begin
  nCode := 0;
  if (nMakeIndex <= 0) or (nType <= 0) or (nType > 4) then Exit;
  try
    if (not m_boDeath) and (not m_boGhost) then begin
      nCode := 1;
      if m_Magic100Skill <> nil then begin //学会神秘解读技能后，才能够制作神秘卷轴
        nCode := 2;
        if m_nEnergyValue > 0 then begin //精力值耗尽，不能制作神秘卷轴
          boItme := False;
          boChangeOK := False;
          n14 := -1;
          if m_ItemList.Count > 0 then begin
            for I := m_ItemList.Count - 1 downto 0 do begin
              if m_ItemList.Count <= 0 then Break;
              UserItem := m_ItemList.Items[I];
              if UserItem = nil then Continue;
              nCode := 3;
              if (UserItem.MakeIndex = nMakeIndex) then begin //得到羊皮卷
                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                if (StdItem <> nil) then begin
                  if (StdItem.StdMode = 44) and (StdItem.Shape = 254) then begin
                    boItme := True;
                    n14 := I;
                  end;
                end;
                Break;
              end;
            end; //for
            if boItme then begin
              nCode := 4;
              if DelBagItem(n14) then begin //删除羊皮卷成功
                Randomize; //播下随机种子
                nCode := 5;
                n15 := 65525;
                n15 := g_Config.nMakeScrollRate[nType] - (m_nLuckyValue div 20) - m_Magic100Skill.btLevel;
                if n15 < 0 then n15 := 0;
                if (Random(n15) = 0) then begin
                  StdItem := UserEngine.GetMakeWineStdItem(44, 255); //找出神秘卷轴
                  if (StdItem <> nil) then begin
                    New(UserItem);
                    if UserEngine.CopyToUserItemFromName(StdItem.Name, UserItem) then begin
                      UserItem.btValue[0] := nType; //神秘卷轴等级
                      case nType of
                        1: UserItem.DuraMax := _MIN(999, m_nProficiency {Random(50 + m_nProficiency) + 1}); //熟练度
                        2: UserItem.DuraMax := _MIN(999, m_nProficiency {Random(100 + m_nProficiency) + 1}); //熟练度
                        3: UserItem.DuraMax := _MIN(999, m_nProficiency {Random(150 + m_nProficiency) + 1}); //熟练度
                        4: UserItem.DuraMax := _MIN(999, m_nProficiency {Random(200 + m_nProficiency)  + 1}); //熟练度
                      end;
                      if StdItem.NeedIdentify = 1 then
                        AddGameDataLog('5' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                          IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 +
                          IntToStr(UserItem.MakeIndex) + #9 + IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.DuraMax) + #9 + '制造神秘卷轴');
                      boChangeOK := True;
                      m_nLuckyValue := 0; //成功则初始幸运值
                      m_ItemList.Add(UserItem);
                      SendAddItem(UserItem);
                    end else Dispose(UserItem);
                  end;
                end;
                if m_nProficiency < 999 then begin //不论成功失败，每次增加一点神秘解读熟练度
                  Inc(m_nProficiency);
                  SysMsg('您获得了1点神秘解读熟练度！', c_Blue, t_Say);
                end;
                if (not boChangeOK) and (m_nLuckyValue < 100) then begin //失败则增加10点幸运值
                  m_nLuckyValue := _MIN(100, m_nLuckyValue + 10);
                  SysMsg('您获得了10点神秘解读幸运值！', c_Blue, t_Say);
                end;
                Dec(m_nEnergyValue); //每次减一点精力值
                SendEnergyAndLucky(); //发送精力值和幸运值
              end;
            end;
          end;
        end;
      end;
      if boChangeOK then
        SendMsg(Self, RM_USERMAKESCROLL_OK, 0, 0, 0, 0, '')
      else SendMsg(Self, RM_USERMAKESCROLL_FAIL, 0, nCode, 0, 0, '');
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientUserMakeScrollItems Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

//发送灵媒装备物品

procedure TPlayObject.SendUseSpiritItems;
var
  Item: pTStdItem;
  sSENDMSG: string;
  ClientItem: TClientItem;
  StdItem: TStdItem;
  sUserItemName: string;
begin
  sSENDMSG := '';
  if m_SpiritMedia.wIndex > 0 then begin
    Item := UserEngine.GetStdItem(m_SpiritMedia.wIndex);
    if Item <> nil then begin
      StdItem := Item^;
      ItemUnit.GetItemAddValue(@m_SpiritMedia, StdItem);
      Move(StdItem, ClientItem.s, SizeOf(TStdItem));
      //取自定义物品名称
      sUserItemName := '';
      if m_SpiritMedia.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(m_SpiritMedia.MakeIndex, m_SpiritMedia.wIndex);
      if sUserItemName <> '' then ClientItem.s.Name := sUserItemName;
      if (m_SpiritMedia.btValue[12] = 1) and (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) then ClientItem.s.Reserved1 := 1 //物品发光 20080224
      else ClientItem.s.Reserved1 := 0;
      if (StdItem.StdMode = 5) or (StdItem.StdMode = 6) then begin //武器暴击等级 20100708
        ClientItem.s.NeedIdentify := _MIN(High(Byte), m_SpiritMedia.btValue[11] + m_SpiritMedia.btValue[20]);
        ClientItem.Aura := m_SpiritMedia.btValue[12];
        ClientItem.MaxAura := g_Config.nMaxAuraValue;
      end else begin
        ClientItem.Aura := m_SpiritMedia.btValue[11];
        ClientItem.MaxAura := g_Config.nMaxAuraValue;
      end;
      ClientItem.Dura := m_SpiritMedia.Dura;
      ClientItem.DuraMax := m_SpiritMedia.DuraMax;
      ClientItem.MakeIndex := m_SpiritMedia.MakeIndex;
      //Modified By TasNat at: 2012-04-12 09:28:18
      ClientItem.btAppraisalLevel :=   m_SpiritMedia.btAppraisalLevel;
      ClientItem.btUnKnowValueCount := m_SpiritMedia.btUnKnowValueCount;
      Move(m_SpiritMedia.btAppraisalValue, ClientItem.btAppraisalValue, SizeOf(m_SpiritMedia.btAppraisalValue));

      Move(m_SpiritMedia.btUnKnowValue, ClientItem.btUnKnowValue, SizeOf(ClientItem.btUnKnowValue));
      ClientItem.BindValue := m_SpiritMedia.AddValue[0]; //20110622
      ClientItem.MaxDate := m_SpiritMedia.MaxDate; //20110622
      if ClientItem.BindValue = 0 then begin //禁止交易,扔物品,显示绑定 20110626
        if (CheckItemValue(@m_SpiritMedia, 1) and CheckItemValue(@m_SpiritMedia, 0)) or
          (GetCheckItemList(0, StdItem.Name) and GetCheckItemList(1, StdItem.Name)) then
          ClientItem.BindValue := 3;
      end;
      sSENDMSG := EncodeBuffer(@ClientItem, SizeOf(ClientItem));
    end;
  end;
  if sSENDMSG <> '' then begin
    m_DefMsg := MakeDefaultMsg(SM_SENDUSESPIRITITEMS, 0, 0, 0, 0, 0);
    SendSocket(@m_DefMsg, sSENDMSG);
  end;
end;
//检查物品是否为灵媒物品

function TPlayObject.CheckItemSpiritMedia(UserItem: pTUserItem): Boolean;
begin
  Result := (UserItem.btAppraisalValue[2] in [231..250]) or (UserItem.btAppraisalValue[3] in [231..250]) or
    (UserItem.btAppraisalValue[4] in [231..250]) or (UserItem.btAppraisalValue[5] in [231..250]) or
    (UserItem.btUnKnowValue[6] in [231..250]) or (UserItem.btUnKnowValue[7] in [231..250]) or
    (UserItem.btUnKnowValue[8] in [231..250]) or (UserItem.btUnKnowValue[9] in [231..250]);
end;
//检查物品是否为灵媒物品

function TPlayObject.CheckItemSpiritMedia(UserItem: TUserItem): Boolean;
begin
  Result := (UserItem.btAppraisalValue[2] in [231..250]) or (UserItem.btAppraisalValue[3] in [231..250]) or
    (UserItem.btAppraisalValue[4] in [231..250]) or (UserItem.btAppraisalValue[5] in [231..250]) or
    (UserItem.btUnKnowValue[6] in [231..250]) or (UserItem.btUnKnowValue[7] in [231..250]) or
    (UserItem.btUnKnowValue[8] in [231..250]) or (UserItem.btUnKnowValue[9] in [231..250]);
end;

//修复灵媒需要的持久值

function TPlayObject.RepairSpiritMediaDura: Integer;
var
  StdItem: pTStdItem;
begin
  Result := 0;
  if m_SpiritMedia.wIndex > 0 then begin
    StdItem := UserEngine.GetStdItem(m_SpiritMedia.wIndex);
    if StdItem <> nil then begin
      if (StdItem.StdMode = 5) or (StdItem.StdMode = 6) then begin //武器
        Result := g_Config.nMaxAuraValue - m_SpiritMedia.btValue[12];
      end else begin
        Result := g_Config.nMaxAuraValue - m_SpiritMedia.btValue[11];
      end;
    end;
  end;
end;

//修复灵媒位灵气值

procedure TPlayObject.RepairSpiritMediaItem(DureCount: Integer);
var
  StdItem: pTStdItem;
begin
  if (m_SpiritMedia.wIndex > 0) and (DureCount > 0) then begin
    StdItem := UserEngine.GetStdItem(m_SpiritMedia.wIndex);
    if StdItem <> nil then begin
      if (StdItem.StdMode = 5) or (StdItem.StdMode = 6) then begin //武器
        m_SpiritMedia.btValue[12] := m_SpiritMedia.btValue[12] + DureCount;
        if m_SpiritMedia.btValue[12] > g_Config.nMaxAuraValue then m_SpiritMedia.btValue[12] := g_Config.nMaxAuraValue;
      end else begin
        m_SpiritMedia.btValue[11] := m_SpiritMedia.btValue[11] + DureCount;
        if m_SpiritMedia.btValue[11] > g_Config.nMaxAuraValue then m_SpiritMedia.btValue[11] := g_Config.nMaxAuraValue;
      end;
      SendUseSpiritItems; //发送灵媒装备物品
    end;
  end;
end;

//把物品放到灵媒位上 2010080827

procedure TPlayObject.ClientTakeOnSpiritItems(nItemIdx: Integer; sItemName: string);
var
  I, n14, n18: Integer;
  UserItem, TakeOffItem: pTUserItem;
  StdItem: pTStdItem;
  sUserItemName: string;
  nCode: Byte;
label FailExit;
begin
  nCode := 0;
  try
    if (not m_boDeath) and (not m_boGhost) then begin
      StdItem := nil;
      UserItem := nil;
      n14 := -1;
      if m_ItemList.Count > 0 then begin
        for I := 0 to m_ItemList.Count - 1 do begin
          nCode := 1;
          UserItem := m_ItemList.Items[I];
          if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then begin
            nCode := 2;
            //取自定义物品名称
            sUserItemName := '';
            if UserItem.btValue[13] = 1 then sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
            if sUserItemName = '' then sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
            nCode := 3;
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            nCode := 4;
            if StdItem <> nil then begin
              if CompareText(sUserItemName, sItemName) = 0 then begin
                n14 := I;
                Break;
              end;
            end;
          end;
          UserItem := nil;
        end;
      end;
      nCode := 5;
      n18 := 0;
      if (StdItem <> nil) and (UserItem <> nil) then begin
        nCode := 6;
        if CheckIsOKItem(UserItem) then begin //检查变态物品
          n18 := -1;
          goto FailExit;
        end;
        nCode := 7;
        if ((StdItem.StdMode = 44) and (StdItem.Shape = 253)) or CheckItemSpiritMedia(UserItem) then begin
          TakeOffItem := nil;
          if m_SpiritMedia.wIndex > 0 then begin
            nCode := 11;
            New(TakeOffItem);
            TakeOffItem^ := m_SpiritMedia;
          end;
          nCode := 13;
          m_SpiritMedia := UserItem^;
          nCode := 14;
          DelBagItem(n14);
          if TakeOffItem <> nil then begin
            nCode := 15;
            if AddItemToBag(TakeOffItem) then begin
            nCode := 16;
            SendAddItem(TakeOffItem);
            end else Dispose(UserItem);//修复内存泄露 By TasNat at: 2012-06-01 12:27:43
          end;
          nCode := 17;
          SendDefMessage(SM_TAKEONSPIRITITEM_OK, 0, 0, 0, 0, '');
          m_nJewelX := -1; //宝物X坐标
          m_nJewelY := -1; //宝物Y坐标
          n18 := 1;
        end else n18 := -1;
      end;
    end;
    FailExit:
    if n18 <= 0 then begin
      SendDefMessage(SM_TAKEONSPIRITITEM_FAIL, n18, 0, 0, 0, '');
    end;
  except   
    MainOutMessage(Format('{%s} TPlayObject.ClientTakeOnSpiritItems Code:%d', [g_sExceptionVer, nCode]));
  end;
end;
//从灵媒位脱物品 20100828

procedure TPlayObject.ClientTakeOffSpiritItems(nItemIdx: Integer; sItemName: string);
var
  n10: Integer;
  UserItem: pTUserItem;
  sUserItemName: string;
  nCode: Byte;
label FailExit;
begin
  n10 := 0;
  nCode := 0;
  try
    if (not m_boDeath) and (not m_boGhost) then begin
      if m_SpiritMedia.wIndex > 0 then begin
        if m_SpiritMedia.MakeIndex = nItemIdx then begin
          nCode := 1;
          //取自定义物品名称
          sUserItemName := '';
          if m_SpiritMedia.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(m_SpiritMedia.MakeIndex, m_SpiritMedia.wIndex);
          if sUserItemName = '' then sUserItemName := UserEngine.GetStdItemName(m_SpiritMedia.wIndex);
          nCode := 2;
          if CompareText(sUserItemName, sItemName) = 0 then begin
            New(UserItem);
            FillChar(UserItem^, SizeOf(TUserItem), #0);
            nCode := 3;
            UserItem^ := m_SpiritMedia;
            nCode := 4;
            if AddItemToBag(UserItem) then begin
              SendAddItem(UserItem);
              m_SpiritMedia.wIndex := 0;
              m_SpiritMedia.MakeIndex := 0;
              nCode := 5;
              SendDefMessage(SM_TAKEOFFSPIRITITEM_OK, 0, 0, 0, 0, '');
              if (m_nJewelX > -1) and (m_nJewelY > -1) then begin
                SysMsg('您取下了灵媒，与目标宝物的感应消失', c_Green, t_Hint);
                m_nJewelX := -1; //宝物X坐标
                m_nJewelY := -1; //宝物Y坐标
              end;
            end else begin
              nCode := 6;
              Dispose(UserItem);
              n10 := -3;
            end;
          end;
        end;
      end else n10 := -2;
    end;
    FailExit:
    if n10 <= 0 then SendDefMessage(SM_TAKEOFFSPIRITITEM_FAIL, n10, 0, 0, 0, '');
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientTakeOffSpiritItems Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

function compareScore(Item1, Item2: Pointer): Integer;
begin
  Result := pTItemLevelSort(Item2).wLevel - pTItemLevelSort(Item1).wLevel;
end;
//客户端品评物品 20100830

procedure TPlayObject.ClientJudgeItems(nItemIdx: Integer; sItemName: string);
  function GetSortList(var sList: TList; nPoint: Word; UserItem1: TUserItem; StdItem1: TStdItem; var nRank: Shortint): Boolean;
  var
    K: Integer;
    ItemLevelSort: pTItemLevelSort;
  begin
    Result := False;
    nRank := -1;
    EnterCriticalSection(HumanSortCriticalSection);
    try
      for K := sList.Count - 1 downto 0 do begin
        if sList.Count <= 0 then Break;
        ItemLevelSort := pTItemLevelSort(sList.Items[K]);
        if ItemLevelSort <> nil then begin
          if ItemLevelSort.Item.MakeIndex = nItemIdx then begin
            nRank := K + 1;
            ItemLevelSort.wLevel := nPoint;
            ItemLevelSort.sChrName := m_sCharName;
            ItemLevelSort.Item.Dura := UserItem1.Dura;
            ItemLevelSort.Item.DuraMax := UserItem1.DuraMax;
            //Modified By TasNat at: 2012-04-12 09:28:18
            ItemLevelSort.Item.btAppraisalLevel :=  UserItem1.btAppraisalLevel;
            ItemLevelSort.Item.btUnKnowValueCount := UserItem1.btUnKnowValueCount;
            Move(UserItem1.btAppraisalValue, ItemLevelSort.Item.btAppraisalValue, SizeOf(ItemLevelSort.Item.btAppraisalValue));


            Move(UserItem1.btUnKnowValue, ItemLevelSort.Item.btUnKnowValue, SizeOf(UserItem1.btUnKnowValue));
            Move(StdItem1, ItemLevelSort.Item.s, SizeOf(TStdItem));
            if (StdItem1.StdMode = 5) or (StdItem1.StdMode = 6) then begin //武器暴击等级
              ItemLevelSort.Item.s.NeedIdentify := _MIN(High(Byte), UserItem1.btValue[11] + UserItem1.btValue[20]);
              if CheckItemSpiritMedia(UserItem1) then begin
                ItemLevelSort.Item.Aura := UserItem1.btValue[12];
                ItemLevelSort.Item.MaxAura := g_Config.nMaxAuraValue;
              end;
            end else begin
              if CheckItemSpiritMedia(UserItem1) then begin
                ItemLevelSort.Item.Aura := UserItem1.btValue[11];
                ItemLevelSort.Item.MaxAura := g_Config.nMaxAuraValue;
              end;
            end;
            Break;
          end;
        end;
      end;
      if nRank = -1 then begin //不存在于原来排行榜中
        New(ItemLevelSort);
        ItemLevelSort.wLevel := nPoint;
        ItemLevelSort.sChrName := m_sCharName;
        ItemLevelSort.Item.MakeIndex := UserItem1.MakeIndex;
        ItemLevelSort.Item.Dura := UserItem1.Dura;
        ItemLevelSort.Item.DuraMax := UserItem1.DuraMax;
        //Modified By TasNat at: 2012-04-12 09:28:18
        ItemLevelSort.Item.btAppraisalLevel :=  UserItem1.btAppraisalLevel;
        ItemLevelSort.Item.btUnKnowValueCount := UserItem1.btUnKnowValueCount;
        Move(UserItem1.btAppraisalValue, ItemLevelSort.Item.btAppraisalValue, SizeOf(ItemLevelSort.Item.btAppraisalValue));

        Move(UserItem1.btUnKnowValue, ItemLevelSort.Item.btUnKnowValue, SizeOf(UserItem1.btUnKnowValue));
        Move(StdItem1, ItemLevelSort.Item.s, SizeOf(TStdItem));
        if (StdItem1.StdMode = 5) or (StdItem1.StdMode = 6) then begin //武器暴击等级
          ItemLevelSort.Item.s.NeedIdentify := _MIN(High(Byte), UserItem1.btValue[11] + UserItem1.btValue[20]);
          if CheckItemSpiritMedia(UserItem1) then begin
            ItemLevelSort.Item.Aura := UserItem1.btValue[12];
            ItemLevelSort.Item.MaxAura := g_Config.nMaxAuraValue;
          end;
        end else begin
          if CheckItemSpiritMedia(UserItem1) then begin
            ItemLevelSort.Item.Aura := UserItem1.btValue[11];
            ItemLevelSort.Item.MaxAura := g_Config.nMaxAuraValue;
          end;
        end;
        sList.Add(ItemLevelSort);
      end;
      sList.Sort(compareScore); //排序
      if nRank <> -1 then begin
        for K := sList.Count - 1 downto 0 do begin
          if sList.Count <= 0 then Break;
          ItemLevelSort := pTItemLevelSort(sList.Items[K]);
          if ItemLevelSort <> nil then begin
            if K >= MAXITEMORDERSCOUNT then begin
              sList.Delete(K);
              Dispose(ItemLevelSort);
            end else begin
              if ItemLevelSort.Item.MakeIndex = nItemIdx then begin
                nRank := K + 1;
                Result := True;
                Break;
              end;
            end;
          end;
        end;
      end else begin
        for K := sList.Count - 1 downto 0 do begin
          if sList.Count <= 0 then Break;
          if K >= MAXITEMORDERSCOUNT then begin
            ItemLevelSort := pTItemLevelSort(sList.Items[K]);
            sList.Delete(K);
            if ItemLevelSort <> nil then Dispose(ItemLevelSort);
          end else begin
            if ItemLevelSort.Item.MakeIndex = nItemIdx then begin
              nRank := K + 1;
              Break;
            end;
          end;
        end;
      end;
    finally
      LeaveCriticalSection(HumanSortCriticalSection);
    end;
  end;
var
  I, n18: Integer;
  nSortPoint: Word;
  nSortRank: Shortint;
  UserItem: pTUserItem;
  UserItem8: TUserItem;
  StdItem: pTStdItem;
  StdItem8: TStdItem;
  sUserItemName, sMsg: string;
  boIsItem, boHint, boDec: Boolean;
  nCode: Byte;
begin
  nCode := 0;
  try
    if (not m_boDeath) and (not m_boGhost) then begin
      StdItem := nil;
      UserItem := nil;
      boIsItem := False;
      if m_ItemList.Count > 0 then begin
        for I := 0 to m_ItemList.Count - 1 do begin
          nCode := 1;
          UserItem := m_ItemList.Items[I];
          if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then begin
            nCode := 2;
            //取自定义物品名称
            sUserItemName := '';
            if UserItem.btValue[13] = 1 then sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
            if sUserItemName = '' then sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
            nCode := 3;
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            nCode := 4;
            if StdItem <> nil then begin
              if CompareText(sUserItemName, sItemName) = 0 then begin
                UserItem8 := UserItem^;
                StdItem8 := StdItem^;
                boIsItem := True;
              end;
            end;
            Break;
          end;
          UserItem := nil;
        end;
      end;
      nCode := 5;
      n18 := 0;
      if (StdItem <> nil) and boIsItem then begin //计算物品分值，并写入排行榜
        boDec := False;
        if g_Config.boJudgeUseGold then begin //使用金币
          if (m_nGold >= g_Config.nJudgePrice) then begin //减金币
            Dec(m_nGold, g_Config.nJudgePrice);
            GoldChanged;
            boDec := True;
          end;
        end else begin //使用元宝
          if (m_nGameGold >= g_Config.nJudgePrice) then begin
            Dec(m_nGameGold, g_Config.nJudgePrice);
            GoldChanged;
            boDec := True;
          end;
        end;
        if boDec then begin
          nSortPoint := UserEngine.GetItemPoint(UserItem8, StdItem8, True); //计算分值
          if nSortPoint > 0 then begin
            case StdItem.StdMode of
              5, 6: begin //武器榜
                  boHint := GetSortList(g_ArmsSortList, nSortPoint, UserItem8, StdItem8, nSortRank);
                  g_boArmsSortChange := True;
                end;
              22, 23, 27: begin //戒指榜
                  boHint := GetSortList(g_RingSortList, nSortPoint, UserItem8, StdItem8, nSortRank);
                  g_boRingSortChange := True;
                end;
              10, 11: begin //衣甲榜
                  boHint := GetSortList(g_DreSortList, nSortPoint, UserItem8, StdItem8, nSortRank);
                  g_boDreSortChange := True;
                end;
              52, 62: begin //靴子榜
                  boHint := GetSortList(g_ShoesSortList, nSortPoint, UserItem8, StdItem8, nSortRank);
                  g_boShoesSortChange := True;
                end;
              15: begin //头盔榜
                  boHint := GetSortList(g_HelmeSortList, nSortPoint, UserItem8, StdItem8, nSortRank);
                  g_boHelmeSortChange := True;
                end;
              54, 64: begin //腰带榜
                  boHint := GetSortList(g_BootsSortList, nSortPoint, UserItem8, StdItem8, nSortRank);
                  g_boBootsSortChange := True;
                end;
              19, 20, 21, 28, 29: begin //项链榜
                  boHint := GetSortList(g_NecklaceSortList, nSortPoint, UserItem8, StdItem8, nSortRank);
                  g_boNecklaceSortChange := True;
                end;
              30: begin //勋章榜
                  boHint := GetSortList(g_MedalSortList, nSortPoint, UserItem8, StdItem8, nSortRank);
                  g_boMedalSortChange := True;
                end;
              24, 26: begin //护腕榜
                  boHint := GetSortList(g_BraceletSortList, nSortPoint, UserItem8, StdItem8, nSortRank);
                  g_boBraceletSortChange := True;
                end;
              16: begin //斗笠面巾榜
                  boHint := GetSortList(g_ZhuLiSortList, nSortPoint, UserItem8, StdItem8, nSortRank);
                  g_boZhuLiSortChange := True;
                end;
            end; //case
            if boHint and (sJudgeItemsMsg <> '') then begin
              sMsg := AnsiReplaceText(sJudgeItemsMsg, '%s', m_sCharName);
              sMsg := AnsiReplaceText(sMsg, '%item', sItemName);
              sMsg := AnsiReplaceText(sMsg, '%d', IntToStr(nSortRank));
              UserEngine.SendBroadCastMsgExt(sMsg, t_Say);
            end;
            if nSortRank <> -1 then SendDefMessage(SM_USERJUDGE_OK, 0, nSortPoint, 0, 0, '')
            else SendDefMessage(SM_USERJUDGE_FAIL, 0, nSortPoint, 0, 0, '');
          end else SendDefMessage(SM_USERJUDGE_FAIL, 0, 0, 0, 0, '');
        end else SendDefMessage(SM_USERJUDGE_FAIL, 0, 0, 1, 0, '');
      end;
    end;
  except   
    MainOutMessage(Format('{%s} TPlayObject.ClientJudgeItems Code:%d', [g_sExceptionVer, nCode]));
  end;
end;
//客户端使用灵媒搜索宝物 20100903

procedure TPlayObject.ClientFindJewelItems(nItemIdx: Integer; sItemName: string);
  function GetRandXY(Envir: TEnvirnoment; var nX, nY: Integer): Boolean;
  var
    n14, n18, n1C: Integer;
  begin
    Result := False;
    if Envir.m_nWidth < 80 then n18 := 3
    else n18 := 10;
    if Envir.m_nHeight < 150 then begin
      if Envir.m_nHeight < 50 then n1C := 2
      else n1C := 15;
    end else n1C := 50;
    n14 := 0;
    while (True) do begin
      try //20101126 防止死循环
        if Envir.CanWalk(nX, nY, True) then begin
          Result := True;
          Break;
        end;
        if nX < (Envir.m_nWidth - n1C - 1) then Inc(nX, n18)
        else begin
          nX := Random(Envir.m_nWidth);
          if nY < (Envir.m_nHeight - n1C - 1) then Inc(nY, n18)
          else nY := Random(Envir.m_nHeight);
        end;
      except
      end;
      Inc(n14);
      if n14 >= 5 then Break;
    end;
  end;
  function GetDirForXY(nX, nY: Integer): Integer; //根据宝物坐标得到对应的方向值
  begin
    Result := DR_DOWN;
    if nX > m_nCurrX then begin
      Result := DR_RIGHT;
      if nY > m_nCurrY then Result := DR_DOWNRIGHT;
      if nY < m_nCurrY then Result := DR_UPRIGHT;
    end else begin
      if nX < m_nCurrX then begin
        Result := DR_LEFT;
        if nY > m_nCurrY then Result := DR_DOWNLEFT;
        if nY < m_nCurrY then Result := DR_UPLEFT;
      end else begin
        if nY > m_nCurrY then Result := DR_DOWN
        else if nY < m_nCurrY then Result := DR_UP;
      end;
    end;
  end;
var
  StdItem: pTStdItem;
  sUserItemName: string;
  nDir: Integer;
  nMaxExp: LongWord;
  nCode: Byte;
begin
  try
    if (not m_boDeath) and (not m_boGhost) and (nItemIdx > 0) and (sItemName <> '') then begin
      nCode := 1;
      if m_SpiritMedia.wIndex > 0 then begin
        if m_SpiritMedia.MakeIndex = nItemIdx then begin
          if IsEnoughBag then begin
            //取自定义物品名称
            sUserItemName := '';
            if m_SpiritMedia.btValue[13] = 1 then
              sUserItemName := ItemUnit.GetCustomItemName(m_SpiritMedia.MakeIndex, m_SpiritMedia.wIndex);
            if sUserItemName = '' then sUserItemName := UserEngine.GetStdItemName(m_SpiritMedia.wIndex);
            nCode := 2;
            if CompareText(sUserItemName, sItemName) = 0 then begin
              StdItem := UserEngine.GetStdItem(m_SpiritMedia.wIndex);
              if StdItem <> nil then begin
                if (StdItem.StdMode = 5) or (StdItem.StdMode = 6) then begin //武器
                  if m_SpiritMedia.btValue[12] > 0 then begin
                    Dec(m_SpiritMedia.btValue[12]); //掉灵气值
                    if m_PEnvir.m_boDigJewel then begin
                      if (m_nJewelX < 0) or (m_nJewelY < 0) then begin
                        if (Random(g_Config.nFindJewelRave) = 0) then begin //使用灵媒探索宝物成功率
                          m_nJewelX := Random(m_PEnvir.m_nWidth);
                          m_nJewelY := Random(m_PEnvir.m_nHeight);
                          if not GetRandXY(m_PEnvir, m_nJewelX, m_nJewelY) then begin //判断宝物XY坐标是否可以安全走到
                            m_nJewelX := -1; //宝物X坐标
                            m_nJewelY := -1; //宝物Y坐标
                          end;
                        end;
                      end;
                      if (m_nJewelX > -1) and (m_nJewelY > -1) then begin //取得宝物XY坐标
                        if (abs(m_nCurrX - m_nJewelX) > 3) or (abs(m_nCurrY - m_nJewelY) > 3) then begin //与宝物坐标相离大于3格时显示方向箭头
                          nDir := GetDirForXY(m_nJewelX, m_nJewelY);
                          SendDefMessage(SM_USERFINDJEWEL_OK, 0, nDir {方向}, 4 {动画类型}, 0, ''); //动画类型 1-小圈 2-中圈 3-大圈 4-箭头
                        end else begin
                          if (abs(m_nCurrX - m_nJewelX) = 3) or (abs(m_nCurrY - m_nJewelY) = 3) then begin //3格显示大圈
                            SendDefMessage(SM_USERFINDJEWEL_OK, 0, 0 {方向}, 3 {动画类型}, 0, ''); //动画类型 1-小圈 2-中圈 3-大圈 4-箭头
                          end else
                            if (abs(m_nCurrX - m_nJewelX) = 2) or (abs(m_nCurrY - m_nJewelY) = 2) then begin //2格显示中圈
                              SendDefMessage(SM_USERFINDJEWEL_OK, 0, 0 {方向}, 2 {动画类型}, 0, ''); //动画类型 1-小圈 2-中圈 3-大圈 4-箭头
                            end else
                              if (abs(m_nCurrX - m_nJewelX) <= 1) or (abs(m_nCurrY - m_nJewelY) <= 1) then begin //1格显示小圈
                                SendDefMessage(SM_USERFINDJEWEL_OK, 0, 0 {方向}, 1 {动画类型}, 0, ''); //动画类型 1-小圈 2-中圈 3-大圈 4-箭头
                              end;
                        end;
                        if m_Magic100Skill <> nil then begin //学过神秘解读
                          if m_Magic100Skill.btLevel < 15 then begin
                            Inc(m_Magic100Skill.nTranPoint, Random(5) + 1);
                            nMaxExp := 500 + (m_Magic100Skill.btLevel * 700);
                            if m_Magic100Skill.nTranPoint >= nMaxExp then begin //超过升级经验,则升级技能
                              Dec(m_Magic100Skill.nTranPoint, nMaxExp);
                              if m_Magic100Skill.btLevel < 15 then begin
                                Inc(m_Magic100Skill.btLevel);
                                RecalcAbilitys();
                                CompareSuitItem(False);
                                SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                              end else m_Magic100Skill.btLevel := 15;
                            end;
                            if m_Magic100Skill.btLevel < 16 then begin
                              nMaxExp := 500 + (m_Magic100Skill.btLevel * 700);
                              SendMsg(self, RM_MAGIC_LVEXP, m_Magic100Skill.MagicInfo.wMagicId, nMaxExp, m_Magic100Skill.btLevel, m_Magic100Skill.nTranPoint, '');
                            end;
                          end;
                        end;
                      end else begin
                        SendDefMessage(SM_USERFINDJEWEL_FAIL, 0, 0, 0, 0, '');
                        if m_Magic100Skill <> nil then begin //学过神秘解读
                          if m_Magic100Skill.btLevel < 15 then begin
                            Inc(m_Magic100Skill.nTranPoint, 1);
                            nMaxExp := 500 + (m_Magic100Skill.btLevel * 700);
                            if m_Magic100Skill.nTranPoint >= nMaxExp then begin //超过升级经验,则升级技能
                              Dec(m_Magic100Skill.nTranPoint, nMaxExp);
                              if m_Magic100Skill.btLevel < 15 then begin
                                Inc(m_Magic100Skill.btLevel);
                                RecalcAbilitys();
                                CompareSuitItem(False);
                                SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                              end else m_Magic100Skill.btLevel := 15;
                            end;
                            if m_Magic100Skill.btLevel < 16 then begin
                              nMaxExp := 500 + (m_Magic100Skill.btLevel * 700);
                              SendMsg(self, RM_MAGIC_LVEXP, m_Magic100Skill.MagicInfo.wMagicId, nMaxExp, m_Magic100Skill.btLevel, m_Magic100Skill.nTranPoint, '');
                            end;
                          end;
                        end;
                        m_nJewelX := -1; //宝物X坐标
                        m_nJewelY := -1; //宝物Y坐
                      end;
                    end else begin //非挖宝地图只增加一点技能点
                      SendDefMessage(SM_USERFINDJEWEL_FAIL, 0, 0, 0, 0, '');
                      if m_Magic100Skill <> nil then begin //学过神秘解读
                        if m_Magic100Skill.btLevel < 15 then begin
                          Inc(m_Magic100Skill.nTranPoint, 1);
                          nMaxExp := 500 + (m_Magic100Skill.btLevel * 700);
                          if m_Magic100Skill.nTranPoint >= nMaxExp then begin //超过升级经验,则升级技能
                            Dec(m_Magic100Skill.nTranPoint, nMaxExp);
                            if m_Magic100Skill.btLevel < 15 then begin
                              Inc(m_Magic100Skill.btLevel);
                              RecalcAbilitys();
                              CompareSuitItem(False);
                              SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                            end else m_Magic100Skill.btLevel := 15;
                          end;
                          if m_Magic100Skill.btLevel < 16 then begin
                            nMaxExp := 500 + (m_Magic100Skill.btLevel * 700);
                            SendMsg(self, RM_MAGIC_LVEXP, m_Magic100Skill.MagicInfo.wMagicId, nMaxExp, m_Magic100Skill.btLevel, m_Magic100Skill.nTranPoint, '');
                          end;
                        end;
                      end;
                      m_nJewelX := -1; //宝物X坐标
                      m_nJewelY := -1; //宝物Y坐标
                    end;
                    SendUseSpiritItems; //发送灵媒装备物品(更新)
                  end else begin
                    m_nJewelX := -1; //宝物X坐标
                    m_nJewelY := -1; //宝物Y坐标
                  end;
                end else begin //非武器类
                  if m_SpiritMedia.btValue[11] > 0 then begin
                    Dec(m_SpiritMedia.btValue[11]); //掉灵气值
                    if m_PEnvir.m_boDigJewel then begin
                      if (m_nJewelX < 0) or (m_nJewelY < 0) then begin
                        if (Random(g_Config.nFindJewelRave) = 0) then begin //使用灵媒探索宝物成功率
                          m_nJewelX := Random(m_PEnvir.m_nWidth);
                          m_nJewelY := Random(m_PEnvir.m_nHeight);
                          if not GetRandXY(m_PEnvir, m_nJewelX, m_nJewelY) then begin //判断宝物XY坐标是否可以安全走到
                            m_nJewelX := -1; //宝物X坐标
                            m_nJewelY := -1; //宝物Y坐标
                          end;
                        end;
                      end;
                      if (m_nJewelX > -1) and (m_nJewelY > -1) then begin //取得宝物XY坐标
                        if (abs(m_nCurrX - m_nJewelX) > 3) or (abs(m_nCurrY - m_nJewelY) > 3) then begin //与宝物坐标相离大于3格时显示方向箭头
                          nDir := GetDirForXY(m_nJewelX, m_nJewelY);
                          SendDefMessage(SM_USERFINDJEWEL_OK, 0, nDir {方向}, 4 {动画类型}, 0, ''); //动画类型 1-小圈 2-中圈 3-大圈 4-箭头
                        end else begin
                          if (abs(m_nCurrX - m_nJewelX) = 3) or (abs(m_nCurrY - m_nJewelY) = 3) then begin //3格显示大圈
                            SendDefMessage(SM_USERFINDJEWEL_OK, 0, 0 {方向}, 3 {动画类型}, 0, ''); //动画类型 1-小圈 2-中圈 3-大圈 4-箭头
                          end else
                            if (abs(m_nCurrX - m_nJewelX) = 2) or (abs(m_nCurrY - m_nJewelY) = 2) then begin //2格显示中圈
                              SendDefMessage(SM_USERFINDJEWEL_OK, 0, 0 {方向}, 2 {动画类型}, 0, ''); //动画类型 1-小圈 2-中圈 3-大圈 4-箭头
                            end else
                              if (abs(m_nCurrX - m_nJewelX) <= 1) or (abs(m_nCurrY - m_nJewelY) <= 1) then begin //1格显示小圈
                                SendDefMessage(SM_USERFINDJEWEL_OK, 0, 0 {方向}, 1 {动画类型}, 0, ''); //动画类型 1-小圈 2-中圈 3-大圈 4-箭头
                              end;
                        end;
                        if m_Magic100Skill <> nil then begin //学过神秘解读
                          if m_Magic100Skill.btLevel < 15 then begin
                            Inc(m_Magic100Skill.nTranPoint, Random(5) + 1);
                            nMaxExp := 500 + (m_Magic100Skill.btLevel * 700);
                            if m_Magic100Skill.nTranPoint >= nMaxExp then begin //超过升级经验,则升级技能
                              Dec(m_Magic100Skill.nTranPoint, nMaxExp);
                              if m_Magic100Skill.btLevel < 15 then begin
                                Inc(m_Magic100Skill.btLevel);
                                RecalcAbilitys();
                                CompareSuitItem(False);
                                SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                              end else m_Magic100Skill.btLevel := 15;
                            end;
                            if m_Magic100Skill.btLevel < 16 then begin
                              nMaxExp := 500 + (m_Magic100Skill.btLevel * 700);
                              SendMsg(self, RM_MAGIC_LVEXP, m_Magic100Skill.MagicInfo.wMagicId, nMaxExp, m_Magic100Skill.btLevel, m_Magic100Skill.nTranPoint, '');
                            end;
                          end;
                        end;
                      end else begin
                        SendDefMessage(SM_USERFINDJEWEL_FAIL, 0, 0, 0, 0, '');
                        if m_Magic100Skill <> nil then begin //学过神秘解读
                          if m_Magic100Skill.btLevel < 15 then begin
                            Inc(m_Magic100Skill.nTranPoint, 1);
                            nMaxExp := 500 + (m_Magic100Skill.btLevel * 700);
                            if m_Magic100Skill.nTranPoint >= nMaxExp then begin //超过升级经验,则升级技能
                              Dec(m_Magic100Skill.nTranPoint, nMaxExp);
                              if m_Magic100Skill.btLevel < 15 then begin
                                Inc(m_Magic100Skill.btLevel);
                                RecalcAbilitys();
                                CompareSuitItem(False);
                                SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                              end else m_Magic100Skill.btLevel := 15;
                            end;
                            if m_Magic100Skill.btLevel < 16 then begin
                              nMaxExp := 500 + (m_Magic100Skill.btLevel * 700);
                              SendMsg(self, RM_MAGIC_LVEXP, m_Magic100Skill.MagicInfo.wMagicId, nMaxExp, m_Magic100Skill.btLevel, m_Magic100Skill.nTranPoint, '');
                            end;
                          end;
                        end;
                        m_nJewelX := -1; //宝物X坐标
                        m_nJewelY := -1; //宝物Y坐
                      end;
                    end else begin //非挖宝地图只增加一点技能点
                      SendDefMessage(SM_USERFINDJEWEL_FAIL, 0, 0, 0, 0, '');
                      if m_Magic100Skill <> nil then begin //学过神秘解读
                        if m_Magic100Skill.btLevel < 15 then begin
                          Inc(m_Magic100Skill.nTranPoint, 1);
                          nMaxExp := 500 + (m_Magic100Skill.btLevel * 700);
                          if m_Magic100Skill.nTranPoint >= nMaxExp then begin //超过升级经验,则升级技能
                            Dec(m_Magic100Skill.nTranPoint, nMaxExp);
                            if m_Magic100Skill.btLevel < 15 then begin
                              Inc(m_Magic100Skill.btLevel);
                              RecalcAbilitys();
                              CompareSuitItem(False);
                              SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                            end else m_Magic100Skill.btLevel := 15;
                          end;
                          if m_Magic100Skill.btLevel < 16 then begin
                            nMaxExp := 500 + (m_Magic100Skill.btLevel * 700);
                            SendMsg(self, RM_MAGIC_LVEXP, m_Magic100Skill.MagicInfo.wMagicId, nMaxExp, m_Magic100Skill.btLevel, m_Magic100Skill.nTranPoint, '');
                          end;
                        end;
                      end;
                      m_nJewelX := -1; //宝物X坐标
                      m_nJewelY := -1; //宝物Y坐标
                    end;
                    SendUseSpiritItems; //发送灵媒装备物品(更新)
                  end else begin
                    m_nJewelX := -1; //宝物X坐标
                    m_nJewelY := -1; //宝物Y坐
                  end;
                end;
              end;
            end;
          end else SysMsg('您的包裹已满，将不会挖到宝物!', c_Red, t_Hint);
        end else begin
          m_nJewelX := -1; //宝物X坐标
          m_nJewelY := -1; //宝物Y坐标
        end;
      end;
    end;
  except   
    MainOutMessage(Format('{%s} TPlayObject.ClientFindJewelItems Code:%d', [g_sExceptionVer, nCode]));
  end;
end;
//客户端挖宝 20100904

procedure TPlayObject.ClientDigJewelItems(nX, nY: Integer);
  function GetSpiritMediaQuality(UserItem: TUserItem): Word; //取装备灵媒的品质
  var
    I: Integer;
  begin
    Result := 0;
    for I := 2 to 5 do begin
      if UserItem.btAppraisalValue[I] in [231..250] then begin
        Result := Round(11.4 * (UserItem.btAppraisalValue[I] - 230));
        Break;
      end;
    end;
    for I := 6 to 9 do begin
      if UserItem.btUnKnowValue[I] in [231..250] then begin
        Result := Round(11.4 * (UserItem.btUnKnowValue[I] - 230));
        Break;
      end;
    end;

  end;
  function DecSpiritMediaQuality(var UserItem: TUserItem): Boolean; //减装备灵媒的品质
  var
    I: Integer;
  begin
    Result := False;
    for I := 2 to 5 do begin
      if UserItem.btAppraisalValue[I] in [231..250] then begin
        UserItem.btAppraisalValue[I] := _MAX(234, UserItem.btAppraisalValue[I] - 1);
        Result := True;
        Break;
      end;
    end;

    for I := 6 to 9 do begin
      if UserItem.btUnKnowValue[I] in [231..250] then begin
        UserItem.btUnKnowValue[I] := _MAX(234, UserItem.btUnKnowValue[I] - 1);
        Result := True;
        Break;
      end;
    end;
  end;
  function GetJewelItem(Quality: Integer): Boolean; //选择物品，并给玩家物品
  var
    DigJewelItemInfo: pTDigJewelItemInfo;
    I, K : Integer;
    nCount: Int64;
    sName: string;
    List: TList;
    StdItem: pTStdItem;
    UserItem: pTUserItem;
    boHithOK: Boolean;
  begin
    Result := False;
    List := nil;
    case Quality of //根据品质选择物品列表
      1..50: List := g_DigJewelItemList1;
      51..100: List := g_DigJewelItemList2;
      101..150: List := g_DigJewelItemList3;
      151..228: List := g_DigJewelItemList4;
    end;
    if List <> nil then begin
      if List.Count > 0 then begin
        sName := '';
        K := 65536;
        nCount := 0;
        for I := 0 to List.Count - 1 do begin
          DigJewelItemInfo := pTDigJewelItemInfo(List.Items[I]);
          if DigJewelItemInfo <> nil then begin
            if Random(DigJewelItemInfo.nItemRace) = 0 then begin
              sName := DigJewelItemInfo.Name;
              nCount := DigJewelItemInfo.nItemNum;
              Break;
            end;
            if DigJewelItemInfo.nItemRace < K then begin
              K := DigJewelItemInfo.nItemRace;
              sName := DigJewelItemInfo.Name;
              nCount := DigJewelItemInfo.nItemNum;
            end;
          end;
        end;
        if (sName <> '') and (nCount > 0) then begin
          StdItem := UserEngine.GetStdItem(sName);
          if (StdItem <> nil) then begin
            for I := 0 to nCount - 1 do begin //支持物品的多数量获取
              New(UserItem);
              if UserEngine.CopyToUserItemFromName(StdItem.Name, UserItem) then begin
                case StdItem.StdMode of
                  5: begin //武器-单手
                      if (StdItem.Shape <> 75) and (StdItem.Shape <> 76) and (StdItem.Shape <> 77) then begin
                        if ItemUnit.RandomKamPoMysteryCount(UserItem, 0) then begin //附加神性属性
                          case UserItem.btAppraisalLevel of //直接显示三鉴
                            1..3: UserItem.btAppraisalLevel := 4;
                            11..13: UserItem.btAppraisalLevel := 14;
                            21..23: UserItem.btAppraisalLevel := 24;
                            31..33: UserItem.btAppraisalLevel := 34;
                            41..43: UserItem.btAppraisalLevel := 44;
                            51..53: UserItem.btAppraisalLevel := 54;
                          end;
                        end;
                      end;
                    end;
                  6, 10, 11, 15, 16, 19..24, 26..30, 52, 54, 55, 62, 64: begin
                      if ItemUnit.RandomKamPoMysteryCount(UserItem, 0) then begin //附加神性属性
                        case UserItem.btAppraisalLevel of //直接显示三鉴
                          1..3: UserItem.btAppraisalLevel := 4;
                          11..13: UserItem.btAppraisalLevel := 14;
                          21..23: UserItem.btAppraisalLevel := 24;
                          31..33: UserItem.btAppraisalLevel := 34;
                          41..43: UserItem.btAppraisalLevel := 44;
                          51..53: UserItem.btAppraisalLevel := 54;
                        end;
                      end;
                    end;
                end;
                if IsEnoughBag and IsAddWeightAvailable(StdItem.Weight) then begin //包裹有位置则放到包裹里,没有则扔出物品
                  if StdItem.StdMode = 17 then begin //叠加物品自动合并
                    boHithOK := True;
                    if not AutoItemMerger(UserItem) then begin //自动合并物品
                      m_ItemList.Add(UserItem);
                      SendAddItem(UserItem);
                      if StdItem.NeedIdentify = 1 then
                        AddGameDataLog('46' + #9 + m_sMapName + #9 +
                          IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                          m_sCharName + #9 + StdItem.Name + #9 +
                          IntToStr(UserItem.MakeIndex) + #9 +
                          '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + '0');
                    end;
                  end else begin
                    m_ItemList.Add(UserItem);
                    if StdItem.NeedIdentify = 1 then
                      AddGameDataLog('46' + #9 + m_sMapName + #9 +
                        IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 + StdItem.Name + #9 +
                        IntToStr(UserItem.MakeIndex) + #9 +
                        '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                        '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                        '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                        '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                        '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                        IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                        IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                        IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                        IntToStr(UserItem.btValue[14]) + '[' + IntToStr(UserItem.Dura) + '/' + inttostr(UserItem.DuraMax) + ']' + #9 + '0');

                    SendAddItem(UserItem);
                    boHithOK := True;
                    Result := True;
                  end;
                end else begin //包裹满了,则退出 20101128
                  Result := True;
                  Dispose(UserItem);
                  Break;
                end;
              end else begin
                Dispose(UserItem);
                Break;
              end;
            end; //for
            if boHithOK then begin
              if not PlugOfCheckCanItem(15, sName, False, nCount, 0) then begin //禁止物品规则(没有设置全F提示的物品)
                SysMsg(Format('恭喜：你获得了：%s:%d', [sName, nCount]), c_Blue, t_Say);
              end;
            end;
          end else begin //非数据库物品
            if CompareText(Trim(sName), '经验') = 0 then begin
              Result := True;
              if not PlugOfCheckCanItem(15, sName, False, nCount, 0) then begin //禁止物品规则(没有设置全F提示的物品)
                SysMsg(Format('恭喜：你获得了：%s:%d', [sName, nCount]), c_Blue, t_Say);
              end;

              if m_MyHero <> nil then begin
                if m_MyHero.m_Abil.Level < g_Config.nLimitExpLevelHero then begin //20110116 增加
                  THeroObject(m_MyHero).GetExp(abs(Round((g_Config.nHeroNoKillMonExpRate / 100) * nCount)), 0);
                  nCount := abs(Round(((100 - g_Config.nHeroNoKillMonExpRate) / 100) * nCount));
                end;
              end;
              if m_Abil.nExp >= uInt64(nCount) then begin
                if (High(uInt64) - m_Abil.nExp) < uInt64(nCount) then begin
                  nCount := High(uInt64) - m_Abil.nExp;
                end;
              end else begin
                if (High(uInt64) - uInt64(nCount)) < m_Abil.nExp then begin
                  nCount := High(uInt64) - uInt64(nCount);
                end;
              end;
              m_GetExp := nCount; //人物取得的经验,$GetExp变量使用
              if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(self, '@GetExp', False, False); //取经验触发
              Inc(m_Abil.nExp, nCount);
              SendMsg(self, RM_WINEXP, 0, 0, 0, 0, EncodeExp(m_Abil.nExp, nCount));
              if (m_Abil.Level < MAXUPLEVEL) and
                (m_Abil.Level < g_Config.nLimitExpLevel) then begin //20110925 达到等级上限时
                if g_Config.boContinuousUpLevel then begin
                  K := 0;
                  while (m_Abil.nExp >= m_Abil.nMaxExp) do begin //循环处理升级
                    if K >= 8 then Break;
                    Inc(K);
                    if m_Abil.nExp <= 0 then begin
                      m_Abil.nExp := 0;
                      Break;
                    end;
                    Dec(m_Abil.nExp, m_Abil.nMaxExp);
                    if (m_Abil.Level < MAXUPLEVEL) and (m_Abil.Level < g_Config.nLimitExpLevel) then begin
                      Inc(m_Abil.Level);
                      if (m_sMasterName <> '') and not m_boMaster then begin //自动出师
                        if m_Abil.Level >= g_Config.nMasterOKLevel then CheckMaster(True);
                      end;
                    end;
                    if m_Abil.Level < g_Config.nLimitExpLevel then begin
                      HasLevelUp(m_Abil.Level - 1); //增加限制等级
                      if not m_boAI then begin
                        AddGameDataLog('12' + #9 + m_sMapName + #9 + //人物升级记录日志
                          IntToStr(m_nCurrX) + #9 +
                          IntToStr(m_nCurrY) + #9 +
                          m_sCharName + #9 + IntToStr(m_Abil.nExp) + '/' + IntToStr(m_Abil.nMaxExp) + #9 + IntToStr(m_Abil.Level) + #9 + '1' + #9 + '(挖宝经验)');
                      end;
                    end;
                  end;
                end else begin
                  if m_Abil.nExp >= m_Abil.nMaxExp then begin //检查升级
                    Dec(m_Abil.nExp, m_Abil.nMaxExp);
                    if (m_Abil.Level < MAXUPLEVEL) and (m_Abil.Level < g_Config.nLimitExpLevel) then begin
                      Inc(m_Abil.Level);
                      if (m_sMasterName <> '') and not m_boMaster then begin //自动出师
                        if m_Abil.Level >= g_Config.nMasterOKLevel then CheckMaster(True);
                      end;
                    end;
                    if m_Abil.Level < g_Config.nLimitExpLevel then begin
                      HasLevelUp(m_Abil.Level - 1); //增加限制等级
                      if not m_boAI then begin
                        AddGameDataLog('12' + #9 + m_sMapName + #9 + //人物升级记录日志
                          IntToStr(m_nCurrX) + #9 +
                          IntToStr(m_nCurrY) + #9 +
                          m_sCharName + #9 + IntToStr(m_Abil.nExp) + '/' + IntToStr(m_Abil.nMaxExp) + #9 + IntToStr(m_Abil.Level) + #9 + '1' + #9 + '(箱子经验)');
                      end;
                    end;
                  end;
                end;
              end;
            end else
              if (CompareText(Trim(sName), '声望') = 0) then begin
                Result := True;
                Inc(m_btCreditPoint, nCount);
                GameGoldChanged();
                if not PlugOfCheckCanItem(15, sName, False, nCount, 0) then begin //禁止物品规则(没有设置全F提示的物品)
                  SysMsg(Format('恭喜：你获得了：%s:%d', [sName, nCount]), c_Blue, t_Say);
                end;
              end else
                if CompareText(Trim(sName), g_Config.sGameGird) = 0 then begin
                  Result := True;
                  Inc(m_nGAMEGIRD, nCount);
                  GameGoldChanged; //更新灵符数量
                  if not PlugOfCheckCanItem(15, sName, False, nCount, 0) then begin //禁止物品规则(没有设置全F提示的物品)
                    SysMsg(Format('恭喜：你获得了：%s:%d', [sName, nCount]), c_Blue, t_Say);
                  end;
                end else
                  if (CompareText(Trim(sName), g_Config.sGameDiaMond) = 0) then begin
                    Result := True;
                    Inc(m_nGAMEDIAMOND, nCount);
                    GameGoldChanged; //更新金刚石数量
                    if not PlugOfCheckCanItem(15, sName, False, nCount, 0) then begin //禁止物品规则(没有设置全F提示的物品)
                      SysMsg(Format('恭喜：你获得了：%s:%d', [sName, nCount]), c_Blue, t_Say);
                    end;
                  end else
                    if (CompareText(Trim(sName), '内功') = 0) then begin //内功经验
                      if m_boTrainingNG then begin
                        Result := True;
                        GetNGExp(nCount, 1); //取得内功经验
                        if not PlugOfCheckCanItem(15, sName, False, nCount, 0) then begin //禁止物品规则(没有设置全F提示的物品)
                          SysMsg(Format('恭喜：你获得了：内功经验:%d', [nCount]), c_Blue, t_Say);
                        end;
                      end;
                    end;
          end;
        end;
      end;
    end;
  end;
var
  StdItem: pTStdItem;
  nQuality: Word;
  nCode: byte;
begin
  try
    if m_boGiveJewelIteming or m_boDeath or m_boGhost then Exit;
    m_boGiveJewelIteming := True;
    try
      if (m_UseItems[U_WEAPON].Dura > 0) and (nX > 0) and (nY > 0) and (abs(nX - m_nCurrX) < 9) and (abs(nY - m_nCurrY) < 7) then begin
        StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
        if (StdItem <> nil) then begin
          if (StdItem.StdMode = 5) and ((StdItem.Shape = 75) or (StdItem.Shape = 76) or (StdItem.Shape = 77)) and (StdItem.AniCount < 4) then begin //是挖宝铲子
            if m_PEnvir.m_boDigJewel and (m_nJewelX > -1) and (m_nJewelY > -1) and (m_SpiritMedia.wIndex > 0) then begin
              if IsEnoughBag then begin
                if Random(g_Config.nDigJewelHitRate) = 0 then begin //命中机率
                  if (abs(m_nCurrX - m_nJewelX) <= StdItem.AniCount) and (abs(m_nCurrY - m_nJewelY) <= StdItem.AniCount) then begin
                    if Random(g_Config.nGetDigJewelRave) = 0 then begin //得宝机率
                      StdItem := UserEngine.GetStdItem(m_SpiritMedia.wIndex); //判断灵媒位是否为除魔灵媒
                      if (StdItem <> nil) then begin
                        if (StdItem.StdMode = 44) and (StdItem.Shape = 253) then begin //除魔灵媒
                          nQuality := StdItem.Reserved;
                          if GetJewelItem(nQuality) then begin //给物品成功
                            m_nJewelX := -1; //宝物X坐标
                            m_nJewelY := -1; //宝物Y坐标
                          end else SysMsg('宝物就在你脚下，坚持就是胜利', c_Green, t_Hint); //提示
                        end else begin
                          nQuality := GetSpiritMediaQuality(m_SpiritMedia);
                          if GetJewelItem(nQuality) then begin //给物品成功
                            m_nJewelX := -1; //宝物X坐标
                            m_nJewelY := -1; //宝物Y坐标
                            if g_Config.nDecDigJewelDuraRate <> 65535 then begin //挖到宝物减装备持久 20110210
                              if Random(g_Config.nDecDigJewelDuraRate) = 0 then begin
                                if DecSpiritMediaQuality(m_SpiritMedia) then begin
                                  SendMsg(Self, RM_SENDUSESPIRITITEMS, 0, 0, 0, 0, ''); //发送灵媒装备物品
                                end;
                              end;
                            end;
                          end else SysMsg('宝物就在你脚下，坚持就是胜利', c_Green, t_Hint); //提示
                        end;
                      end;
                    end else SysMsg('宝物就在你脚下，坚持就是胜利', c_Green, t_Hint); //提示
                  end else SysMsg('宝物好像不在这个位置', c_Green, t_Hint); //提示
                end;
              end else SysMsg('您的包裹已满，将不会挖到宝物!', c_Red, t_Hint);
            end;
            SendRefMsg(RM_10205, 21, 0 {X}, 0 {Y}, 0, ''); //挖宝特效
            DoDamageWeapon(Random(20) + 5); //减铲子的持久
            SendRefMsg(RM_BUTCH, m_btDirection, m_nCurrX, m_nCurrY, 0, ''); //让别人看到挖的动作
          end;
        end;
      end;
    finally
      m_boGiveJewelIteming := False;
    end;
  except   
    MainOutMessage(Format('{%s} TPlayObject.ClientDigJewelItems Code:%d', [g_sExceptionVer, nCode]));
  end;
end;
{$IFEND}
//{$REGION '清理包裹和仓库复制物品 20080816'}

procedure TPlayObject.ClearCopyItem(nCode: Byte; wIndex, MakeIndex: Integer);
var
  I: Integer;
  UserItem: pTUserItem;
  nCheckCode: Byte;
begin
  nCheckCode := 0;
  if m_boGhost then Exit; //20090807 增加
  try
    m_boOperationItemList := True; //20080928 防止同时操作背包列表时保存
    case nCode of
      0: begin //检查背包中是否有复制品
          for I := m_ItemList.Count - 1 downto 0 do begin
            nCheckCode := 1;
            if m_ItemList.Count <= 0 then Break;
            nCheckCode := 2;
            UserItem := m_ItemList.Items[I];
            nCheckCode := 3;
            if UserItem <> nil then begin //20090306
              nCheckCode := 4;
              if (UserItem.wIndex = wIndex) and (UserItem.MakeIndex = MakeIndex) then begin
                nCheckCode := 5;
                SendDelItems(UserItem);
                MainOutMessage('[清理包裹复制品](' + m_sCharName + ')' + UserEngine.GetStdItemName(UserItem.wIndex) + '(' + IntToStr(UserItem.MakeIndex) + ')[' +
                  IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                  IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                  IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                  IntToStr(UserItem.btValue[14]));
                nCheckCode := 6;
                m_ItemList.Delete(I);
                Dispose(UserItem); //20100928 增加
                Break; //20081014 只找到一件则退出，提高效率
              end;
            end;
          end;
        end; //0
      1: begin
          nCheckCode := 7;
          for I := m_StorageItemList.Count - 1 downto 0 do begin
            nCheckCode := 8;
            if m_StorageItemList.Count <= 0 then Break;
            nCheckCode := 9;
            UserItem := m_StorageItemList.Items[I];
            nCheckCode := 10;
            if UserItem <> nil then begin //20090306
              nCheckCode := 11;
              if (UserItem.wIndex = wIndex) and (UserItem.MakeIndex = MakeIndex) then begin
                nCheckCode := 12;
                MainOutMessage('[清理仓库复制品](' + m_sCharName + ')' + UserEngine.GetStdItemName(UserItem.wIndex) + '(' + IntToStr(UserItem.MakeIndex) + ')[' +
                  IntToStr(UserItem.btValue[0]) + '/' + IntToStr(UserItem.btValue[1]) + '/' + IntToStr(UserItem.btValue[2]) + '/' +
                  IntToStr(UserItem.btValue[3]) + '/' + IntToStr(UserItem.btValue[4]) + '/' + IntToStr(UserItem.btValue[5]) + '/' +
                  IntToStr(UserItem.btValue[6]) + '/' + IntToStr(UserItem.btValue[7]) + '/' + IntToStr(UserItem.btValue[8]) + '/' +
                  IntToStr(UserItem.btValue[14]));
                nCheckCode := 13;
                m_StorageItemList.Delete(I);
                Dispose(UserItem); //20100928 增加
                Break; //20081014 只找到一件则退出，提高效率
              end;
            end;
          end; //for I
        end; //1
    end;
    m_boOperationItemList := False; //20080928 防止同时操作背包列表时保存
  except
    begin
    MainOutMessage(format('{%s} TPlayObject.ClearCopyItem Code:%d', [g_sExceptionVer, nCheckCode]));
    m_boOperationItemList := False; //20080928 防止同时操作背包列表时保存
    end;
  end;
end;
//{$ENDREGION}
//检查人物装备死亡物品是否爆 20081127

function TPlayObject.CheckItemBindDieNoDrop(UserItem: pTUserItem): Boolean;
var
  I: Integer;
  ItemBind: pTItemBind;
begin
  Result := False;
  g_ItemBindDieNoDropName.Lock;
  try
    if g_ItemBindDieNoDropName.Count > 0 then begin
      for I := 0 to g_ItemBindDieNoDropName.Count - 1 do begin
        ItemBind := g_ItemBindDieNoDropName.Items[I];
        if ItemBind <> nil then begin
          if ItemBind.nItemIdx = UserItem.wIndex then begin
            if (CompareText(ItemBind.sBindName, m_sCharName) = 0) then Result := True;
            Exit;
          end;
        end;
      end;
    end;
  finally
    g_ItemBindDieNoDropName.UnLock;
  end;
end;
//取牛气管当前等级的牛气值上限值 20090518

function TPlayObject.GetExpCattle(nLevel: Byte; var nMaxCattleExp: LongWord): Boolean;
begin
  Result := True;
  if (nLevel < 5) and (nLevel > 0) then begin
    nMaxCattleExp := 0;
    case nLevel of
      1: begin
          nMaxCattleExp := g_Config.dwCattleGasvalueNeedExps;
        end;
      2: begin
          nMaxCattleExp := g_Config.dwCattleGasvalueNeedExps * 3;
        end;
      3: begin
          nMaxCattleExp := g_Config.dwCattleGasvalueNeedExps * 6;
        end;
      4: begin
          nMaxCattleExp := g_Config.dwCattleGasvalueNeedExps * 10;
        end;
    end; //case
  end;
end;

//取天地结晶当前等级的经验，内功上限值 20090131
//nMaxExp-当前经验上限  Result-内功经验上限

function TPlayObject.GetExpCrystal(nLevel: Byte; var nMaxExp, nMaxNGExp: LongWord): Boolean;
begin
  Result := True;
  if nLevel < 5 then begin
    nMaxExp := 0;
    nMaxNGExp := 0;
    nMaxExp := g_Config.dwExpCrystalNeedExps[nLevel];
    nMaxNGExp := g_Config.dwNGExpCrystalNeedExps[nLevel];
  end;
end;
//客户端点击天地结晶，返回经验等信息 20090201

procedure TPlayObject.ClientGetExpCrystalData;
begin
  if m_boShowExpCrystal and m_boGetExpCrystalExp then begin //天地结晶图标为显示，并且可以提取经验时
    if (m_nGetCrystalExp > 0) and (m_nGetCrystalNGExp > 0) and (m_CrystalLevel < 6) and (m_CrystalLevel > 0) then begin
      if g_FunctionNPC <> nil then begin
        g_FunctionNPC.GotoLable(Self, '@GetCrystalData', False, False); //返回经验等信息触发
      end;
    end;
  end;
end;

//客户端攻击富贵兽、宠物 20090517

function TPlayObject.ClientUseItmeToWealthAnimalMon(nItemIdx, nX, nY: Integer; TargeTBaseObject: TBaseObject): Boolean;
  function CheckWealthAnimalMon(Reserved {机率}: Byte; nDamage {杀伤力}: Integer; var boToMon: Boolean): Boolean;
  var
    I: Integer;
    //MonList: TList;
    WealthAnimalMon: TBaseObject;
  begin
    Result := False;
    //MonList := TList.Create;
    //try
    //  m_PEnvir.GetRangeBaseObject(nX, nY, 2, False, MonList);//查指定XY范围内的怪
    SendRefMsg(RM_SPELL, 10, nX, nY, 60000, '');
    if {(MonList.Count > 0) and} m_boShowCattleGas then begin
        //for I := 0 to MonList.Count - 1 do begin
      WealthAnimalMon := {TBaseObject(MonList.Items[I])} TargeTBaseObject;
      if WealthAnimalMon <> nil then begin
        if (not WealthAnimalMon.m_boDeath) and (not WealthAnimalMon.m_boGhost) then begin //20090527
          if IsProperTarget(WealthAnimalMon) then begin
            if (WealthAnimalMon.m_btRaceServer = 79) then begin //目标为富贵兽
              Result := True;
              if Random(Reserved) = 0 then begin //是否机率可以打怪掉血
                WealthAnimalMon.SetLastHiter(self);
                TWealthAnimalMon(WealthAnimalMon).StruckDamage1(nDamage); //富贵兽掉血
              end;
              if WealthAnimalMon.m_boCrazyMode then boToMon := True;
              WealthAnimalMon.SendDelayMsg(TBaseObject(RM_STRUCK1), RM_10101, nDamage, WealthAnimalMon.m_WAbil.HP, WealthAnimalMon.m_WAbil.MaxHP, Integer(Self), '',
                _MAX(abs(m_nCurrX - WealthAnimalMon.m_nCurrX), abs(m_nCurrY - WealthAnimalMon.m_nCurrY)) * 50);
              SendRefMsg(RM_MAGICFIRE, 0, MakeWord(8, 99), MakeLong(WealthAnimalMon.m_nCurrX, WealthAnimalMon.m_nCurrY), Integer(WealthAnimalMon), ''); //发消息给客户端显示打中怪的效果
                  //break;
            end;
          end;
        end;
      end;
        //end;//for
    end;
    //finally
    //  MonList.Free;
    //end;
    if not Result then begin
      WealthAnimalMon := nil;
      SendRefMsg(RM_MAGICFIRE, 0, MakeWord(8, 99), MakeLong(nX, nY), Integer(WealthAnimalMon), ''); //发消息给客户端显示打中怪的效果
      if m_boShowCattleGas then SysMsg('你周围并没有富贵兽', c_Blue, t_Say);
    end;
  end;
  function CheckPetsMon(boToMon {T-喂 F-鞭打}: Boolean; sItemName: string; nDamgee: Integer): Boolean; //喂养宠物怪
  var
    I: Integer;
  begin
    Result := False;
    SendRefMsg(RM_SPELL, 10, nX, nY, 60000, '');
    if (nDamgee > 0) then begin
      if TargeTBaseObject <> nil then begin
        if (not TargeTBaseObject.m_boDeath) and (not TargeTBaseObject.m_boGhost) then begin
          if (TargeTBaseObject.m_btRaceServer = 158) then begin //目标为宠物
            Result := True;
            if boToMon then begin //喂养,怪向目标移动3步
              if (g_Config.dwPetsMonIncMaxHapp - TPetsMon(TargeTBaseObject).m_dwPetsMonIncMaxHapp) < nDamgee then begin
                nDamgee := g_Config.dwPetsMonIncMaxHapp - TPetsMon(TargeTBaseObject).m_dwPetsMonIncMaxHapp;
              end;
              if TPetsMon(TargeTBaseObject).m_dwPetsMonIncMaxHapp < g_Config.dwPetsMonIncMaxHapp then begin
                if (High(LongWord) - TPetsMon(TargeTBaseObject).m_nHappiness) < nDamgee then begin
                  TPetsMon(TargeTBaseObject).m_nHappiness := High(LongWord);
                end else Inc(TPetsMon(TargeTBaseObject).m_nHappiness, nDamgee);
                Inc(TPetsMon(TargeTBaseObject).m_dwPetsMonIncMaxHapp, nDamgee);

                if TargeTBaseObject.m_Master <> nil then begin
                  if (not TargeTBaseObject.m_Master.m_boDeath) and (not TargeTBaseObject.m_Master.m_boGhost) then begin
                    TPlayObject(TargeTBaseObject.m_Master).m_nPetsMonHappiness := TPetsMon(TargeTBaseObject).m_nHappiness;
                    TPlayObject(TargeTBaseObject.m_Master).SendMsg(TargeTBaseObject.m_Master, RM_UPPETSMONHAPP, 0, TPlayObject(TargeTBaseObject.m_Master).m_nPetsMonHappiness, 0, 0, '');
                  end;
                end;
                if TPetsMon(TargeTBaseObject).m_sMasterName <> m_sCharName then
                  TPetsMon(TargeTBaseObject).SaveMasterList(format('%s对你的宠物使用了%s,快乐度+%d', [m_sCharName, sItemName, nDamgee]))
                else TPetsMon(TargeTBaseObject).SaveMasterList(format('你对你的宠物使用了%s,快乐度+%d', [sItemName, nDamgee]));
              end;
              if (TargeTBaseObject.m_wAppr = 331) or (TargeTBaseObject.m_wAppr = 332) then begin //兔子才发送吃萝卜的动作
                TargeTBaseObject.SendDelayMsg(TBaseObject(RM_STRUCK1), RM_FLYAXE, TargeTBaseObject.m_btDirection, TargeTBaseObject.m_nCurrX, TargeTBaseObject.m_nCurrY, Integer(Self), '',
                  _MAX(abs(m_nCurrX - TargeTBaseObject.m_nCurrX), abs(m_nCurrY - TargeTBaseObject.m_nCurrY)) * 50);
              end else begin
                TargeTBaseObject.SendDelayMsg(TBaseObject(RM_STRUCK1), RM_10101, 10, TargeTBaseObject.m_WAbil.HP, TargeTBaseObject.m_WAbil.MaxHP, Integer(Self), '',
                  _MAX(abs(m_nCurrX - TargeTBaseObject.m_nCurrX), abs(m_nCurrY - TargeTBaseObject.m_nCurrY)) * 50);
              end;
              SendRefMsg(RM_MAGICFIRE, 0, MakeWord(8, 198), MakeLong(TargeTBaseObject.m_nCurrX, TargeTBaseObject.m_nCurrY), Integer(TargeTBaseObject), ''); //发消息给客户端显示打中怪的效果
            end else begin
              if (g_Config.dwPetsMonDecMaxHapp - TPetsMon(TargeTBaseObject).m_dwPetsMonDecMaxHapp) < nDamgee then begin
                nDamgee := g_Config.dwPetsMonDecMaxHapp - TPetsMon(TargeTBaseObject).m_dwPetsMonDecMaxHapp;
              end;
              if TPetsMon(TargeTBaseObject).m_dwPetsMonDecMaxHapp < g_Config.dwPetsMonDecMaxHapp then begin
                if TPetsMon(TargeTBaseObject).m_nHappiness >= nDamgee then Dec(TPetsMon(TargeTBaseObject).m_nHappiness, nDamgee)
                else TPetsMon(TargeTBaseObject).m_nHappiness := 0;
                Inc(TPetsMon(TargeTBaseObject).m_dwPetsMonDecMaxHapp, nDamgee);
                if TPetsMon(TargeTBaseObject).m_sMasterName <> m_sCharName then
                  TPetsMon(TargeTBaseObject).SaveMasterList(format('%s对你的宠物使用了%s,快乐度-%d', [m_sCharName, sItemName, nDamgee]))
                else TPetsMon(TargeTBaseObject).SaveMasterList(format('你对你的宠物使用了%s,快乐度-%d', [sItemName, nDamgee]));
              end;

              if TPetsMon(TargeTBaseObject).m_dwPetsMonIncMaxHapp >= nDamgee then begin //20110728
                Dec(TPetsMon(TargeTBaseObject).m_dwPetsMonIncMaxHapp, nDamgee);
              end;

              TPetsMon(TargeTBaseObject).m_nHappiness := _MAX(TargeTBaseObject.m_Abil.MaxMP, TPetsMon(TargeTBaseObject).m_nHappiness);
              if TargeTBaseObject.m_Master <> nil then begin
                if (not TargeTBaseObject.m_Master.m_boDeath) and (not TargeTBaseObject.m_Master.m_boGhost) then begin
                  TPlayObject(TargeTBaseObject.m_Master).m_nPetsMonHappiness := TPetsMon(TargeTBaseObject).m_nHappiness;
                  TPlayObject(TargeTBaseObject.m_Master).SendMsg(TargeTBaseObject.m_Master, RM_UPPETSMONHAPP, 0, TPlayObject(TargeTBaseObject.m_Master).m_nPetsMonHappiness, 0, 0, '');
                end;
              end;
              TargeTBaseObject.SendDelayMsg(TBaseObject(RM_STRUCK1), RM_10101, TargeTBaseObject.m_btDirection, TargeTBaseObject.m_WAbil.HP, TargeTBaseObject.m_WAbil.MaxHP, Integer(Self), '',
                _MAX(abs(m_nCurrX - TargeTBaseObject.m_nCurrX), abs(m_nCurrY - TargeTBaseObject.m_nCurrY)) * 50);
              SendRefMsg(RM_MAGICFIRE, 0, MakeWord(8, 99), MakeLong(TargeTBaseObject.m_nCurrX, TargeTBaseObject.m_nCurrY), Integer(TargeTBaseObject), ''); //发消息给客户端显示打中怪的效果
            end;
          end;
        end;
      end;
    end;
    if not Result then begin
      if boToMon then SendRefMsg(RM_MAGICFIRE, 0, MakeWord(8, 198), MakeLong(nX, nY), Integer(TargeTBaseObject), '')
      else SendRefMsg(RM_MAGICFIRE, 0, MakeWord(8, 99), MakeLong(nX, nY), Integer(TargeTBaseObject), ''); //发消息给客户端显示打中怪的效果
      SysMsg('你周围并没有宠物', c_Blue, t_Say);
    end else begin //喂养成功进入触发段
      if g_FunctionNPC <> nil then begin
        if boToMon then g_FunctionNPC.GotoLable(TPlayObject(self), '@PetsMonStruck', False, False) //萝卜触发
        else g_FunctionNPC.GotoLable(TPlayObject(self), '@PetsMonStruck1', False, False); //鞭炮触发
      end;
    end;
  end;
var
  I: Integer;
  UserItem: pTUserItem;
  UserItem34: TUserItem;
  StdItem: pTStdItem;
  boEatOK, boSendUpDate, boUseItmeToMon, boUseItmeToMon1: Boolean;
  nCode: byte;
begin
  nCode := 0;
  Result := False;
  boEatOK := False;
  boSendUpDate := False;
  boUseItmeToMon := False;
  boUseItmeToMon1 := False;
  StdItem := nil;
  try
    if (nX >= 0) and (nY >= 0) and (not m_boDeath) and (not m_boGhost) and (nItemIdx >= 0) then begin //物品合法才检查坐标上的目标
      if m_boCanUseItem then begin //能使用物品
        nCode := 1;
        for I := m_ItemList.Count - 1 downto 0 do begin
          if m_ItemList.Count <= 0 then Break;
          UserItem := m_ItemList.Items[I];
          if UserItem = nil then Continue;
          if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then begin
            UserItem34 := UserItem^;
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            nCode := 2;
            if StdItem <> nil then begin
              if (StdItem.StdMode = 2) then begin
                case StdItem.Shape of
                  10: begin //霹雳弹
                      nCode := 3;
                      if CheckWealthAnimalMon(StdItem.Reserved {机率}, StdItem.AC {杀伤力}, boUseItmeToMon1) then begin
                        if UserItem.Dura >= 1000 then begin
                          boUseItmeToMon := True;
                          Dec(UserItem.Dura, 1000);
                          boEatOK := True;
                          if UserItem.Dura > 0 then begin
                            boSendUpDate := True;
                            boEatOK := False;
                          end else begin
                            if UserItem <> nil then begin
                              UserItem.wIndex := 0;
                              m_ItemList.Delete(I);
                              Dispose(UserItem); //By TasNat
                        UserItem := nil;
                            end;
                          end;
                        end else begin
                          UserItem.Dura := 0;
                          if UserItem <> nil then begin
                            UserItem.wIndex := 0;
                            m_ItemList.Delete(I);
                            Dispose(UserItem); //By TasNat
                        UserItem := nil;
                          end;
                        end;
                        nCode := 5;
                        if boEatOK then begin
                          WeightChanged();
                          SendDefMessage(SM_EAT_OK, 0, 0, 0, 0, '');
                          if StdItem.NeedIdentify = 1 then
                            AddGameDataLog('11' + #9 + m_sMapName + #9 +
                              IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                              m_sCharName + #9 + StdItem.Name + #9 +
                              IntToStr(UserItem34.MakeIndex) + #9 +
                              '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                              '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                              '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                              '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                              '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                              IntToStr(UserItem34.btValue[0]) + '/' + IntToStr(UserItem34.btValue[1]) + '/' + IntToStr(UserItem34.btValue[2]) + '/' +
                              IntToStr(UserItem34.btValue[3]) + '/' + IntToStr(UserItem34.btValue[4]) + '/' + IntToStr(UserItem34.btValue[5]) + '/' +
                              IntToStr(UserItem34.btValue[6]) + '/' + IntToStr(UserItem34.btValue[7]) + '/' + IntToStr(UserItem34.btValue[8]) + '/' +
                              IntToStr(UserItem34.btValue[14]) + #9 + '0');
                        end else begin
                          SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                        end;
                        nCode := 6;
                        if (UserItem <> nil) and boSendUpDate then SendUpdateItem(UserItem);
                        Break;
                      end else begin
                        SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                      end;
                    end; //10
                  11: begin //萝卜喂养宠物
                      boUseItmeToMon := False;
                      if CheckPetsMon(True, StdItem.Name, LoWord(StdItem.AC)) then begin
                        if UserItem.Dura >= 1000 then begin
                          Dec(UserItem.Dura, 1000);
                          boEatOK := True;
                          if UserItem.Dura > 0 then begin
                            boSendUpDate := True;
                            boEatOK := False;
                          end else begin
                            if UserItem <> nil then begin
                              UserItem.wIndex := 0;
                              m_ItemList.Delete(I);
                              Dispose(UserItem); //By TasNat
                        UserItem := nil;
                            end;
                          end;
                        end else begin
                          UserItem.Dura := 0;
                          if UserItem <> nil then begin
                            UserItem.wIndex := 0;
                            m_ItemList.Delete(I);
                            Dispose(UserItem); //By TasNat
                        UserItem := nil;
                          end;
                        end;
                        nCode := 5;
                        if boEatOK then begin
                          WeightChanged();
                          SendDefMessage(SM_EAT_OK, 0, 0, 0, 0, '');
                          if StdItem.NeedIdentify = 1 then
                            AddGameDataLog('11' + #9 + m_sMapName + #9 +
                              IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                              m_sCharName + #9 + StdItem.Name + #9 +
                              IntToStr(UserItem34.MakeIndex) + #9 +
                              '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                              '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                              '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                              '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                              '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                              IntToStr(UserItem34.btValue[0]) + '/' + IntToStr(UserItem34.btValue[1]) + '/' + IntToStr(UserItem34.btValue[2]) + '/' +
                              IntToStr(UserItem34.btValue[3]) + '/' + IntToStr(UserItem34.btValue[4]) + '/' + IntToStr(UserItem34.btValue[5]) + '/' +
                              IntToStr(UserItem34.btValue[6]) + '/' + IntToStr(UserItem34.btValue[7]) + '/' + IntToStr(UserItem34.btValue[8]) + '/' +
                              IntToStr(UserItem34.btValue[14]) + #9 + '0');
                        end else begin
                          SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                        end;
                        nCode := 6;
                        if (UserItem <> nil) and boSendUpDate then SendUpdateItem(UserItem);
                        Break;
                      end else begin
                        SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                      end;
                    end; //11
                  12: begin //鞭炮攻击宠物
                      boUseItmeToMon := False;
                      if CheckPetsMon(False, StdItem.Name, LoWord(StdItem.AC)) then begin
                        if UserItem.Dura >= 1000 then begin
                          Dec(UserItem.Dura, 1000);
                          boEatOK := True;
                          if UserItem.Dura > 0 then begin
                            boSendUpDate := True;
                            boEatOK := False;
                          end else begin
                            if UserItem <> nil then begin
                              UserItem.wIndex := 0;
                              m_ItemList.Delete(I);
                              Dispose(UserItem); //By TasNat
                        UserItem := nil;
                            end;
                          end;
                        end else begin
                          UserItem.Dura := 0;
                          if UserItem <> nil then begin
                            UserItem.wIndex := 0;
                            m_ItemList.Delete(I);
                            Dispose(UserItem); //By TasNat
                        UserItem := nil;
                          end;
                        end;
                        nCode := 5;
                        if boEatOK then begin
                          WeightChanged();
                          SendDefMessage(SM_EAT_OK, 0, 0, 0, 0, '');
                          if StdItem.NeedIdentify = 1 then
                            AddGameDataLog('11' + #9 + m_sMapName + #9 +
                              IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                              m_sCharName + #9 + StdItem.Name + #9 +
                              IntToStr(UserItem34.MakeIndex) + #9 +
                              '(' + IntToStr(LoWord(StdItem.DC)) + '/' + IntToStr(HiWord(StdItem.DC)) + ')' +
                              '(' + IntToStr(LoWord(StdItem.MC)) + '/' + IntToStr(HiWord(StdItem.MC)) + ')' +
                              '(' + IntToStr(LoWord(StdItem.SC)) + '/' + IntToStr(HiWord(StdItem.SC)) + ')' +
                              '(' + IntToStr(LoWord(StdItem.AC)) + '/' + IntToStr(HiWord(StdItem.AC)) + ')' +
                              '(' + IntToStr(LoWord(StdItem.MAC)) + '/' + IntToStr(HiWord(StdItem.MAC)) + ')' +
                              IntToStr(UserItem34.btValue[0]) + '/' + IntToStr(UserItem34.btValue[1]) + '/' + IntToStr(UserItem34.btValue[2]) + '/' +
                              IntToStr(UserItem34.btValue[3]) + '/' + IntToStr(UserItem34.btValue[4]) + '/' + IntToStr(UserItem34.btValue[5]) + '/' +
                              IntToStr(UserItem34.btValue[6]) + '/' + IntToStr(UserItem34.btValue[7]) + '/' + IntToStr(UserItem34.btValue[8]) + '/' +
                              IntToStr(UserItem34.btValue[14]) + #9 + '0');
                        end else begin
                          SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                        end;
                        nCode := 6;
                        if (UserItem <> nil) and boSendUpDate then SendUpdateItem(UserItem);
                        Break;
                      end else begin
                        SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                      end;
                    end; //12
                end; //case
              end;
            end;
            Break;
          end;
        end; //for
        nCode := 7;
        if boUseItmeToMon then begin //随机给牛气值，
          if Random(g_Config.nUseItmeToMonRate) = 0 then begin //一定机率触发脚本段给经验
            if g_FunctionNPC <> nil then begin
              nCode := 8;
              if not boUseItmeToMon1 then g_FunctionNPC.GotoLable(Self, '@UseItmeToMon', False, False)
              else g_FunctionNPC.GotoLable(Self, '@UseItmeToMon1', False, False);
            end;
          end;
          nCode := 9;
          if not boUseItmeToMon1 then GetCattleGasExp(g_Config.nGetCattleGasvalue); //取得牛气值 20090519
        end;
      end else begin
        SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotUseItemMsg);
        Exit;
      end;
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientUseItmeToWealthAnimalMon Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

//--------------------------------连击相关--------------------------------------
//客户端拆分物品 20090615

procedure TPlayObject.ClientItemSplit(nItemMakeIdx {制造ID}: Integer; nDura {拆分数量}: Integer);
var
  I: Integer;
  UserItem, UserItem1: pTUserItem;
  StdItem: pTStdItem;
begin
  if m_boMergerIteming then Exit; //是否正在合并物品 20090616
  m_boMergerIteming := True;
  m_boCanQueryBag := True; //不能刷新包裹
  try
    if (nItemMakeIdx > 0) and (nDura > 0) and (nDura < High(Word)) then begin //20090816 增加
      try
        if IsEnoughBag then begin //包裹未满时
          if m_ItemList.Count > 0 then begin
            for I := 0 to m_ItemList.Count - 1 do begin
              UserItem := m_ItemList.Items[I];
              if (UserItem <> nil) then begin
                if (UserItem.MakeIndex = nItemMakeIdx) then begin
                  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                  if StdItem <> nil then begin
                    if (StdItem.StdMode = 17) and (UserItem.Dura > nDura) then begin
                      UserItem.Dura := UserItem.Dura - nDura;
                      SendUpdateItem(UserItem); //更新物品
                      New(UserItem1);
                      if UserEngine.CopyToUserItemFromName(StdItem.Name, UserItem1) then begin
                        UserItem1.AddValue[0] := UserItem.AddValue[0]; //20110911 增加
                        UserItem1.MaxDate := UserItem.MaxDate; //解绑时间  //20110911 增加
                        UserItem1.btValue[14] := UserItem.btValue[14]; //20110928 增加
                        UserItem1.Dura := nDura;
                        if UserItem1.Dura > UserItem1.DuraMax then UserItem1.Dura := UserItem1.DuraMax;
                        m_ItemList.Add(UserItem1);
                        SendAddItem(UserItem1);
                        if StdItem.NeedIdentify = 1 then begin
                          AddGameDataLog('42' + #9 + m_sMapName + #9 +
                            IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                            m_sCharName + #9 + StdItem.Name + #9 +
                            IntToStr(UserItem.MakeIndex) + #9 +
                            IntToStr(UserItem.Dura) + '/' + IntToStr(UserItem.DuraMax) + #9 + '拆分物品');

                          AddGameDataLog('42' + #9 + m_sMapName + #9 +
                            IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                            m_sCharName + #9 + StdItem.Name + #9 +
                            IntToStr(UserItem1.MakeIndex) + #9 +
                            IntToStr(UserItem1.Dura) + '/' + IntToStr(UserItem1.DuraMax) + #9 + '拆分获得');
                        end;
                      end else Dispose(UserItem1);
                      Break;
                    end;
                  end;
                end;
              end;
            end;
          end;
        end;
      except   
        MainOutMessage(format('{%s} TPlayObjectSplit', [g_sExceptionVer]));
      end;
    end;
  finally
    m_boCanQueryBag := False; //不能刷新包裹
    m_boMergerIteming := False;
  end;
end;
//自动合并叠加物品 20091126

function TPlayObject.AutoItemMerger(UserItem {合并的物品}: pTUserItem): Boolean;
var
  II: integer;
  UserItem1: pTUserItem;
  StdItem, StdItem1: pTStdItem;
  boMergerOK: Byte;
begin
  Result := False;
  if m_boMergerIteming then Exit; //是否正在合并物品
  m_boMergerIteming := True;
  m_boCanQueryBag := True; //不能刷新包裹
  boMergerOK := 0;
  UserItem1 := nil;
  try
    if UserItem <> nil then begin
      try
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem <> nil then begin
          if StdItem.StdMode = 17 then begin
            for II := m_ItemList.Count - 1 downto 0 do begin
              if m_ItemList.Count <= 0 then Break;
              UserItem1 := m_ItemList.Items[II];
              if UserItem1 <> nil then begin
                StdItem1 := UserEngine.GetStdItem(UserItem1.wIndex);
                if StdItem1 <> nil then begin
                  if (StdItem1.StdMode = 17) and (StdItem.Shape = StdItem1.Shape)
                    and (StdItem.Name = StdItem1.Name) and (UserItem1.Dura < UserItem1.DuraMax)
                    and (UserItem1.AddValue[0] = UserItem.AddValue[0])
                    and (((128 shr 1) and (UserItem1.btValue[14])) = ((128 shr 1) and (UserItem.btValue[14])))
                    and (((128 shr 0) and (UserItem1.btValue[14])) = ((128 shr 0) and (UserItem.btValue[14]))) then begin //20110830 修改
                    if UserItem1.Dura + UserItem.Dura > UserItem1.DuraMax then begin
                      UserItem.Dura := UserItem1.Dura + UserItem.Dura - UserItem1.DuraMax;
                      UserItem1.Dura := UserItem1.DuraMax;
                      SendUpdateItem(UserItem1); //更新物品
                      if StdItem.NeedIdentify = 1 then
                        AddGameDataLog('43' + #9 + m_sMapName + #9 +
                          IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                          m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem1.MakeIndex) + #9 +
                          IntToStr(UserItem1.Dura) + '/' + IntToStr(UserItem1.DuraMax) + #9 + '合并物品1(' + IntToStr(UserItem.MakeIndex) + '/' + IntToStr(UserItem.Dura) + ')');
                    end else begin
                      UserItem1.Dura := UserItem1.Dura + UserItem.Dura;
                      SendUpdateItem(UserItem1); //更新物品
                      if StdItem.NeedIdentify = 1 then
                        AddGameDataLog('43' + #9 + m_sMapName + #9 +
                          IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                          m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem1.MakeIndex) + #9 +
                          IntToStr(UserItem1.Dura) + '/' + IntToStr(UserItem1.DuraMax) + #9 + '合并物品(' + IntToStr(UserItem.MakeIndex) + '/' + IntToStr(UserItem.Dura) + ')');
                      UserItem.MakeIndex := 0;
                      UserItem.wIndex := 0;
                      Result := True;
                      Dispose(UserItem); //By TasNat
                        UserItem := nil;
                      Break;
                    end;
                  end;
                end;
              end;
            end; //for
          end;
        end;
      except   
        MainOutMessage(format('{%s} TPlayObject.AutoItemMerger', [g_sExceptionVer]));
      end;
    end;
  finally
    m_boCanQueryBag := False; //不能刷新包裹
    m_boMergerIteming := False;
  end;
end;

//客户端合并物品 20090615

procedure TPlayObject.ClientItemMerger(nItemMakeIdx {需要合并的物品制造ID}: Integer; sMakeIdx {合并到的物品}: string);
var
  I, II, nMakeIdx: integer;
  UserItem, UserItem1: pTUserItem;
  StdItem, StdItem1: pTStdItem;
  boMergerOK: Byte;
begin
  if m_boMergerIteming then Exit; //是否正在合并物品 20090616
  m_boMergerIteming := True;
  m_boCanQueryBag := True; //不能刷新包裹
  boMergerOK := 0;
  UserItem := nil;
  UserItem1 := nil;
  try
    nMakeIdx := Str_ToInt(sMakeIdx, 0);
    if (nItemMakeIdx > 0) and (nMakeIdx > 0) and (nItemMakeIdx <> nMakeIdx) then begin
      try
        for I := m_ItemList.Count - 1 downto 0 do begin
          if m_ItemList.Count <= 0 then Break;
          UserItem := m_ItemList.Items[I];
          if UserItem <> nil then begin
            if (UserItem.MakeIndex = nItemMakeIdx) then begin
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem <> nil then begin
                if StdItem.StdMode = 17 then begin
                  for II := m_ItemList.Count - 1 downto 0 do begin
                    if m_ItemList.Count <= 0 then Break; //20091113 增加
                    UserItem1 := m_ItemList.Items[II];
                    if UserItem1 <> nil then begin
                      if (UserItem1.MakeIndex = nMakeIdx) then begin
                        StdItem1 := UserEngine.GetStdItem(UserItem1.wIndex);
                        if StdItem1 <> nil then begin
                          if (StdItem1.StdMode = 17) and (StdItem.Shape = StdItem1.Shape) and
                            (StdItem.Name = StdItem1.Name) and (UserItem1.AddValue[0] = UserItem.AddValue[0])
                            and (((128 shr 1) and (UserItem1.btValue[14])) = ((128 shr 1) and (UserItem.btValue[14])))
                            and (((128 shr 0) and (UserItem1.btValue[14])) = ((128 shr 0) and (UserItem.btValue[14]))) then begin //20110830 修改
                            if UserItem1.Dura + UserItem.Dura > UserItem1.DuraMax then begin
                              UserItem.Dura := UserItem1.Dura + UserItem.Dura - UserItem1.DuraMax;
                              UserItem1.Dura := UserItem1.DuraMax;
                              boMergerOK := 2;
                              SendDefMessage(SM_MERGER_FAIL, 0, 0, 0, 0, '');
                              SendUpdateItem(UserItem); //更新物品
                              SendUpdateItem(UserItem1); //更新物品
                              if StdItem.NeedIdentify = 1 then
                                AddGameDataLog('43' + #9 + m_sMapName + #9 +
                                  IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                                  m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem1.MakeIndex) + #9 +
                                  IntToStr(UserItem1.Dura) + '/' + IntToStr(UserItem1.DuraMax) + #9 + '合并物品1(' + IntToStr(UserItem.MakeIndex) + '/' + IntToStr(UserItem.Dura) + ')');
                            end else begin
                              UserItem1.Dura := UserItem1.Dura + UserItem.Dura;
                              SendUpdateItem(UserItem1); //更新物品
                              if StdItem.NeedIdentify = 1 then
                                AddGameDataLog('43' + #9 + m_sMapName + #9 +
                                  IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                                  m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem1.MakeIndex) + #9 +
                                  IntToStr(UserItem1.Dura) + '/' + IntToStr(UserItem1.DuraMax) + #9 + '合并物品(' + IntToStr(UserItem.MakeIndex) + '/' + IntToStr(UserItem.Dura) + ')');
                              UserItem.MakeIndex := 0;
                              UserItem.wIndex := 0;
                              boMergerOK := 1;
                              m_ItemList.Delete(I);
                              SendDelItems(UserItem);
                            Dispose(UserItem); //By TasNat
                        UserItem := nil;
                            end;
                          end;
                        end;
                        Break;
                      end;
                    end;
                  end; //for
                end;
              end;
              Break;
            end;
          end;
        end;
      except   
        MainOutMessage(format('{%s} TPlayObjectMerger', [g_sExceptionVer]));
      end;
    end;
    case boMergerOK of
      0: SendDefMessage(SM_MERGER_FAIL, 0, 0, 0, 0, '');
      1: SendDefMessage(SM_MERGER_OK, 0, 0, 0, 0, '');
    end;
  finally
    m_boCanQueryBag := False; //不能刷新包裹
    m_boMergerIteming := False;
  end;
end;

//客户端开始锻练金针 20090616

procedure TPlayObject.ClientExerciseKimNeedle(nItemMakeIdx {第一个金针的制造ID}: Integer; sMsg: string);
var
  nItemId, nItemId1, nItemId2, nItemId3, nItemId4, nItemId5, nItemId6: Integer;
  Str, Str1, Str2, Str3, Str4, Str5, Str6: string;
  StdItem, StdItem1, StdItem2, StdItem3, StdItem4, StdItem5, StdItem6, StdItem7: pTStdItem;
  UserItem: pTUserItem;
  I, nSuccessRate, nItemLevel, nCount: Integer;
  boExerciseOK, boExerciseOK1: Boolean;
  nItemCount, nSuccessCode: Byte; //放的物品数量
begin
  if m_boMergerKimNeedle or m_boGhost then Exit;
  m_boMergerKimNeedle := True;
  boExerciseOK1 := False;
  nSuccessRate := 0; //成功率
  nItemLevel := 0; //物品等级
  nSuccessCode := 0;
  //很严重啊 变量没有初始化 By TasNat at: 2012-03-22 17:15:47
  StdItem := nil;
  StdItem1 := nil;
  StdItem2 := nil;
  StdItem3 := nil;
  StdItem4 := nil;
  StdItem5 := nil;
  StdItem6 := nil;
  StdItem7 := nil;
  try
    try
      if (nItemMakeIdx > 0) then begin
        nItemCount := 1;
        if sMsg <> '' then begin
          sMsg := GetValidStr3(sMsg, Str, ['/', #9]);
          sMsg := GetValidStr3(sMsg, Str1, ['/', #9]);
          sMsg := GetValidStr3(sMsg, Str2, ['/', #9]);
          sMsg := GetValidStr3(sMsg, Str3, ['/', #9]);
          sMsg := GetValidStr3(sMsg, Str4, ['/', #9]);
          sMsg := GetValidStr3(sMsg, Str5, ['/', #9]);
          sMsg := GetValidStr3(sMsg, Str6, ['/', #9]);
        end;
        nItemId := Str_ToInt(Str, 0);
        if nItemId > 0 then Inc(nItemCount);
        nItemId1 := Str_ToInt(Str1, 0);
        if nItemId1 > 0 then Inc(nItemCount);
        nItemId2 := Str_ToInt(Str2, 0);
        if nItemId2 > 0 then Inc(nItemCount);
        nItemId3 := Str_ToInt(Str3, 0);
        if nItemId3 > 0 then Inc(nItemCount);
        nItemId4 := Str_ToInt(Str4, 0);
        if nItemId4 > 0 then Inc(nItemCount);
        nItemId5 := Str_ToInt(Str5, 0);
        if nItemId5 > 0 then Inc(nItemCount);
        nItemId6 := Str_ToInt(Str6, 0);
        if nItemId6 > 0 then Inc(nItemCount);
        if m_ItemList.Count > 0 then begin
          for I := m_ItemList.Count - 1 downto 0 do begin
            if m_ItemList.Count <= 0 then Break;
            UserItem := m_ItemList.Items[I];
            if UserItem <> nil then begin
              if UserItem.MakeIndex > 0 then begin
                if UserItem.MakeIndex = nItemId then begin
                  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                  Inc(nCount);
                  m_ItemList.Delete(I);
                  SendDelItems(UserItem);
                  Dispose(UserItem);
                end else if UserItem.MakeIndex = nItemId1 then begin
                  StdItem1 := UserEngine.GetStdItem(UserItem.wIndex);
                  Inc(nCount);
                  m_ItemList.Delete(I);
                  SendDelItems(UserItem);
                  Dispose(UserItem);
                end else if UserItem.MakeIndex = nItemId2 then begin
                  StdItem2 := UserEngine.GetStdItem(UserItem.wIndex);
                  Inc(nCount);
                  m_ItemList.Delete(I);
                  SendDelItems(UserItem);
                  Dispose(UserItem);
                end else if UserItem.MakeIndex = nItemId3 then begin
                  StdItem3 := UserEngine.GetStdItem(UserItem.wIndex);
                  Inc(nCount);
                  m_ItemList.Delete(I);
                  SendDelItems(UserItem);
                  Dispose(UserItem);
                end else if UserItem.MakeIndex = nItemId4 then begin
                  StdItem4 := UserEngine.GetStdItem(UserItem.wIndex);
                  Inc(nCount);
                  m_ItemList.Delete(I);
                  SendDelItems(UserItem);
                  Dispose(UserItem);
                end else if UserItem.MakeIndex = nItemId5 then begin
                  StdItem5 := UserEngine.GetStdItem(UserItem.wIndex);
                  Inc(nCount);
                  m_ItemList.Delete(I);
                  SendDelItems(UserItem);
                  Dispose(UserItem);
                end else if UserItem.MakeIndex = nItemId6 then begin
                  StdItem6 := UserEngine.GetStdItem(UserItem.wIndex);
                  Inc(nCount);
                  m_ItemList.Delete(I);
                  SendDelItems(UserItem);
                  Dispose(UserItem);
                end else if UserItem.MakeIndex = nItemMakeIdx then begin
                  StdItem7 := UserEngine.GetStdItem(UserItem.wIndex);
                  Inc(nCount);
                  m_ItemList.Delete(I);
                  SendDelItems(UserItem);
                  Dispose(UserItem);
                end;
                if nCount >= nItemCount then Break;
              end;
            end;
          end; //for I := m_ItemList.Count - 1 downto 0 do begin
        end;
        if StdItem7 <> nil then begin //累加各物品的成功率
          if (StdItem7.StdMode = 17) and (StdItem7.Shape > 0) and (StdItem7.Shape < 7) then begin //第一个物品为金针类物品 20091026 修改
            nItemLevel := StdItem7.Shape;
            nSuccessRate := StdItem7.Anicount;
            boExerciseOK := True;
            if (StdItem <> nil) and boExerciseOK then begin
              if (StdItem.StdMode = 17) or (StdItem.StdMode = 18) then begin
                if StdItem.Shape = nItemLevel then begin //检查金针的等级是否一致
                  Inc(nSuccessRate, StdItem.Anicount);
                end else boExerciseOK := False;
              end;
            end;
            if (StdItem1 <> nil) and boExerciseOK then begin
              if (StdItem1.StdMode = 17) or (StdItem1.StdMode = 18) then begin
                if StdItem1.Shape = nItemLevel then begin //检查金针的等级是否一致
                  Inc(nSuccessRate, StdItem1.Anicount);
                end else boExerciseOK := False;
              end;
            end;
            if (StdItem2 <> nil) and boExerciseOK then begin
              if (StdItem2.StdMode = 17) or (StdItem2.StdMode = 18) then begin
                if StdItem2.Shape = nItemLevel then begin //检查金针的等级是否一致
                  Inc(nSuccessRate, StdItem2.Anicount);
                end else boExerciseOK := False;
              end;
            end;
            if (StdItem3 <> nil) and boExerciseOK then begin
              if (StdItem3.StdMode = 17) or (StdItem3.StdMode = 18) then begin
                if StdItem3.Shape = nItemLevel then begin //检查金针的等级是否一致
                  Inc(nSuccessRate, StdItem3.Anicount);
                end else boExerciseOK := False;
              end;
            end;
            if (StdItem4 <> nil) and boExerciseOK then begin
              if (StdItem4.StdMode = 17) or (StdItem4.StdMode = 18) then begin
                if StdItem4.Shape = nItemLevel then begin //检查金针的等级是否一致
                  Inc(nSuccessRate, StdItem4.Anicount);
                end else boExerciseOK := False;
              end;
            end;
            if (StdItem5 <> nil) and boExerciseOK then begin
              if (StdItem5.StdMode = 17) or (StdItem5.StdMode = 18) then begin
                if StdItem5.Shape = nItemLevel then begin //检查金针的等级是否一致
                  Inc(nSuccessRate, StdItem5.Anicount);
                end else boExerciseOK := False;
              end;
            end;
            if (StdItem6 <> nil) and boExerciseOK then begin
              if (StdItem6.StdMode = 17) or (StdItem6.StdMode = 18) then begin
                if StdItem6.Shape = nItemLevel then begin //检查金针的等级是否一致
                  Inc(nSuccessRate, StdItem6.Anicount);
                end else boExerciseOK := False;
              end;
            end;
            if boExerciseOK then begin //计算成功率
              Randomize(); //随机种子
              nCount := Random(100);
              if nCount <= nSuccessRate then begin //成功
                nSuccessCode := StdItem7.Reserved;
                StdItem6 := UserEngine.GetMakeWineStdItem(17, StdItem7.Reserved);
                if (StdItem6 <> nil) then begin
                  New(UserItem);
                  if UserEngine.CopyToUserItemFromName(StdItem6.Name, UserItem) then begin
                    if StdItem6.NeedIdentify = 1 then
                      AddGameDataLog('44' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 +
                        IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem6.Name + #9 +
                        IntToStr(UserItem.MakeIndex) + #9 + IntToStr(UserItem.Dura) + '/' + IntToStr(UserItem.DuraMax) + #9 + '锻练成功');
                    m_ItemList.Add(UserItem);
                    SendAddItem(UserItem);
                    boExerciseOK1 := True;
                  end else Dispose(UserItem);
                end;
              end;
            end;
          end; //第一个物品为金针类物品
        end; //累加各物品的成功率
      end;
    except   
      MainOutMessage(format('{%s} TPlayObject.ClientExerciseKimNeedle', [g_sExceptionVer]));
    end;
    if boExerciseOK1 then SendDefMessage(SM_EXERCISEKIMNEEDLE_OK, 0, nSuccessCode, 0, 0, '')
    else SendDefMessage(SM_EXERCISEKIMNEEDLE_FAIL, 0, 0, 0, 0, '');
  finally
    m_boMergerKimNeedle := False;
  end;
end;
{$IF M2Version = 1}
//登陆时发送脉穴数据 20090621

procedure TPlayObject.SendUserPulseArr;
var
  sSENDMSG: string;
begin
  if m_boTrainingNG then begin //学过内功
    sSENDMSG := EncodeBuffer(@m_wHumanPulseArr, SizeOf(THumanPulseInfo));
    if sSENDMSG <> '' then begin
      SendMsg(Self, RM_SENDUSERPULSEARR, 0, 0, 0, 0, sSENDMSG);
    end;
    SendUserPulsePulsePoint(0, False);
  end;
end;
//发送脉穴对应穴位发亮以及所需的内功等级 20090624

procedure TPlayObject.SendUserPulsePulsePoint(nPulse {经络页}: byte; boOK: Boolean);
var
  nPoint, m_nPulse, nLevel: Byte;
begin
  if m_boTrainingNG then begin //学过内功
    case nPulse of
      0..3: begin
          if boOK then begin
            if m_wHumanPulseArr[nPulse].boOpenPulse then begin //当前经络已通时
              if nPulse < 3 then begin
                nPoint := 1; //对应的穴位
                nLevel := g_Config.dwPulsePointNGLevel[(nPulse + 1) * 5]; //内功等级
                m_nPulse := nPulse + 1; //经络页
                SendMsg(Self, RM_SENDUSERPULSESHINY, 0, nPoint, nLevel, m_nPulse, '');
              end;
            end else begin
              if m_wHumanPulseArr[nPulse].nPulsePoint < 5 then begin
                nPoint := m_wHumanPulseArr[nPulse].nPulsePoint + 1;
                nLevel := g_Config.dwPulsePointNGLevel[nPulse * 5 + m_wHumanPulseArr[nPulse].nPulsePoint];
                m_nPulse := nPulse; //经络页
                SendMsg(Self, RM_SENDUSERPULSESHINY, 0, nPoint, nLevel, m_nPulse, '');
              end;
            end;
          end else begin
            if not m_wHumanPulseArr[0].boOpenPulse then begin
              if m_wHumanPulseArr[0].nPulsePoint < 5 then begin
                nLevel := g_Config.dwPulsePointNGLevel[m_wHumanPulseArr[0].nPulsePoint];
                nPoint := m_wHumanPulseArr[0].nPulsePoint + 1;
                SendMsg(Self, RM_SENDUSERPULSESHINY, 0, nPoint, nLevel, 0, '');
              end;
            end else
              if not m_wHumanPulseArr[1].boOpenPulse then begin
                if m_wHumanPulseArr[1].nPulsePoint < 5 then begin
                  nLevel := g_Config.dwPulsePointNGLevel[5 + m_wHumanPulseArr[1].nPulsePoint];
                  nPoint := m_wHumanPulseArr[1].nPulsePoint + 1;
                  SendMsg(Self, RM_SENDUSERPULSESHINY, 0, nPoint, nLevel, 1, '');
                end;
              end else
                if not m_wHumanPulseArr[2].boOpenPulse then begin
                  if m_wHumanPulseArr[2].nPulsePoint < 5 then begin
                    nLevel := g_Config.dwPulsePointNGLevel[10 + m_wHumanPulseArr[2].nPulsePoint];
                    nPoint := m_wHumanPulseArr[2].nPulsePoint + 1;
                    SendMsg(Self, RM_SENDUSERPULSESHINY, 0, nPoint, nLevel, 2, '');
                  end;
                end else
                  if not m_wHumanPulseArr[3].boOpenPulse then begin
                    if m_wHumanPulseArr[3].nPulsePoint < 5 then begin
                      nLevel := g_Config.dwPulsePointNGLevel[15 + m_wHumanPulseArr[3].nPulsePoint];
                      nPoint := m_wHumanPulseArr[3].nPulsePoint + 1;
                      SendMsg(Self, RM_SENDUSERPULSESHINY, 0, nPoint, nLevel, 3, '');
                    end;
                  end;
          end;
        end;
    end; //case
  end;
end;
//客户端点击穴位,执行脚本，打通穴位 20090621

procedure TPlayObject.ClientOpenPulsePoint(nPulse {经络页}, nPoint {穴位}: byte);
begin
  if m_boTrainingNG and (nPoint < 6) then begin //学过内功
    case nPulse of
      0..3: begin //冲脉,阴跷,阴维,任脉
        //检查穴位是否已打通
          if (m_wHumanPulseArr[nPulse].nPulsePoint >= nPoint) or m_wHumanPulseArr[nPulse].boOpenPulse then begin //穴位已打通时,或经络已打通时
            if g_BatterNPC <> nil then g_BatterNPC.GotoLable(self, '@穴位已通', False, False);
            Exit;
          end;
        //检查上一经络是打通 20090718
          if nPulse > 0 then begin
            if not m_wHumanPulseArr[nPulse - 1].boOpenPulse then Exit;
          end;
          if g_BatterNPC <> nil then g_BatterNPC.GotoLable(self, '@Pulse' + inttostr(nPulse) + '-' + inttostr(nPoint), False, False);
        end;
      4: begin //奇经
          if (m_wHumanPulseArr[nPulse].nPulsePoint < 6) then begin
            case nPoint of
              1: begin //神冲
                  if (m_wHumanPulseArr[nPulse].nPulsePoint >= nPoint) then Exit; //如果已打通，则退出
                  if g_BatterNPC <> nil then g_BatterNPC.GotoLable(self, '@Pulse' + inttostr(nPulse) + '-' + inttostr(nPoint), False, False);
                end;
              2: begin //夹脊
                  Exit;
                end;
              3: begin //二百
                  Exit;
                end;
              4: begin //八风
                  Exit;
                end;
              5: begin //涌泉
                  Exit;
                end;
            end;
          end;
        end; //4
    end;
  end;
end;
//客户端修炼经络 20090623

procedure TPlayObject.ClientPracticePulse(nPulse {经络页}: byte);
begin
  if m_boTrainingNG and (nPulse < 4) then begin //学过内功
    if m_wHumanPulseArr[nPulse].boOpenPulse then begin //穴位已打通
      if m_wHumanPulseArr[nPulse].nPulseLevel < 5 then begin
        if g_BatterNPC <> nil then g_BatterNPC.GotoLable(self, '@经络修炼' + IntToStr(nPulse) + '-' + inttostr(m_wHumanPulseArr[nPulse].nPulseLevel), False, False);
      end;
    end;
  end;
end;

//客户端英雄修炼经络 20090911

procedure TPlayObject.ClientHeroPracticePulse(nPulse {经络页}: byte);
begin
{$IF HEROVERSION = 1}
  if (m_MyHero <> nil) and (nPulse < 4) then begin
    if THeroObject(m_MyHero).m_boTrainingNG and THeroObject(m_MyHero).m_boOpenHumanPulseArr and (not m_MyHero.m_boGhost) and (not m_MyHero.m_boDeath) then begin
      if THeroObject(m_MyHero).m_wHumanPulseArr[nPulse].boOpenPulse then begin //穴位已打通
        if (THeroObject(m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel < 5) then begin
          case nPulse of
            0: begin
                if THeroObject(m_MyHero).m_ExpPuls >= g_Config.dwExpHeroPulsNeedExps0[THeroObject(m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel] then begin
                  Dec(THeroObject(m_MyHero).m_ExpPuls, g_Config.dwExpHeroPulsNeedExps0[THeroObject(m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel]);
                  if g_BatterNPC <> nil then g_BatterNPC.GotoLable(self, '@Hero修炼' + IntToStr(nPulse) + '-' + inttostr(THeroObject(m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel), False, False);
                end;
              end; //0
            1: begin
                if THeroObject(m_MyHero).m_ExpPuls >= g_Config.dwExpHeroPulsNeedExps1[THeroObject(m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel] then begin
                  Dec(THeroObject(m_MyHero).m_ExpPuls, g_Config.dwExpHeroPulsNeedExps1[THeroObject(m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel]);
                  if g_BatterNPC <> nil then g_BatterNPC.GotoLable(self, '@Hero修炼' + IntToStr(nPulse) + '-' + inttostr(THeroObject(m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel), False, False);
                end;
              end; //1
            2: begin
                if THeroObject(m_MyHero).m_ExpPuls >= g_Config.dwExpHeroPulsNeedExps2[THeroObject(m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel] then begin
                  Dec(THeroObject(m_MyHero).m_ExpPuls, g_Config.dwExpHeroPulsNeedExps2[THeroObject(m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel]);
                  if g_BatterNPC <> nil then g_BatterNPC.GotoLable(self, '@Hero修炼' + IntToStr(nPulse) + '-' + inttostr(THeroObject(m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel), False, False);
                end;
              end; //2
            3: begin
                if THeroObject(m_MyHero).m_ExpPuls >= g_Config.dwExpHeroPulsNeedExps3[THeroObject(m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel] then begin
                  Dec(THeroObject(m_MyHero).m_ExpPuls, g_Config.dwExpHeroPulsNeedExps3[THeroObject(m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel]);
                  if g_BatterNPC <> nil then g_BatterNPC.GotoLable(self, '@Hero修炼' + IntToStr(nPulse) + '-' + inttostr(THeroObject(m_MyHero).m_wHumanPulseArr[nPulse].nPulseLevel), False, False);
                end;
              end; //3
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;
//客户端打通斗转99级

procedure TPlayObject.ClientOpenupSkill95(nMakeIndex: Integer; nType: Byte);
var
  I: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
  try
    case nType of
      0: begin //主体
          if (m_Magic95Skill <> nil) and (not m_boOpenupSkill95) and (nMakeIndex > 0) then begin
            for I := m_ItemList.Count - 1 downto 0 do begin
              if m_ItemList.Count <= 0 then Break;
              UserItem := m_ItemList.Items[I];
              if (UserItem <> nil) then begin
                if (UserItem.MakeIndex = nMakeIndex) then begin
                  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                  if StdItem <> nil then begin
                    if (StdItem.StdMode = 44) and (StdItem.Shape = 248) then begin
                      if m_Magic95Skill.btLevel >= StdItem.NeedLevel then begin
                        m_boOpenupSkill95 := True;
                        SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
                        SendMsg(Self, RM_SKILLTOJINGQING_OK, 0, 0, 0, 0, '');
                        SysMsg('恭喜，你的斗转星移技能可修炼上限已经提高到99级！', c_Blue, t_Say);
                        m_ItemList.Delete(I);
                        Dispose(UserItem); //By TasNat
                        UserItem := nil;
                      end else begin
                        SendMsg(Self, RM_OPENUPSKILL95_FAIL, 0, 0, 0, 0, '');
                        SysMsg(Format('%s等级需达到：%d级后才可以使用！', [m_Magic95Skill.MagicInfo.sMagicName, StdItem.NeedLevel]), c_Red, t_Hint);
                      end;
                    end;
                  end;
                  Break;
                end;
              end;
            end; // for
          end;
        end;
      1: begin //英雄
          if m_MyHero <> nil then begin
            if (not m_MyHero.m_boDeath) and (not m_MyHero.m_boGhost) and (THeroObject(m_MyHero).m_Magic95Skill <> nil)
              and (not THeroObject(m_MyHero).m_boOpenupSkill95) and (nMakeIndex > 0) then begin
              for I := m_MyHero.m_ItemList.Count - 1 downto 0 do begin
                if m_MyHero.m_ItemList.Count <= 0 then Break;
                UserItem := m_MyHero.m_ItemList.Items[I];
                if (UserItem <> nil) then begin
                  if (UserItem.MakeIndex = nMakeIndex) then begin
                    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                    if StdItem <> nil then begin
                      if (StdItem.StdMode = 44) and (StdItem.Shape = 248) then begin
                        if THeroObject(m_MyHero).m_Magic95Skill.btLevel >= StdItem.NeedLevel then begin
                          THeroObject(m_MyHero).m_boOpenupSkill95 := True;
                          THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROABILITY, 0, 0, 0, 0, '');
                          THeroObject(m_MyHero).SendMsg(m_MyHero, RM_SKILLTOJINGQING_OK, 0, 1, 0, 0, '');
                          THeroObject(m_MyHero).SysMsg('(英雄) 恭喜，你的斗转星移技能可修炼上限已经提高到99级！', c_Blue, t_Say);
                          m_MyHero.m_ItemList.Delete(I);
                          Dispose(UserItem); //By TasNat
                        UserItem := nil;
                        end else begin
                          SendMsg(Self, RM_OPENUPSKILL95_FAIL, 0, 1, 0, 0, '');
                          THeroObject(m_MyHero).SysMsg(Format('(英雄) %s等级需达到：%d级后才可以使用！', [m_Magic95Skill.MagicInfo.sMagicName, StdItem.NeedLevel]), c_Red, t_Hint);
                        end;
                      end;
                    end;
                    Break;
                  end;
                end;
              end; // for
            end;
          end;
        end;
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientOpenupSkill95', [g_sExceptionVer]));
  end;
end;

//messagebox命令发送后，客户端点击“确定”后，跳转到BatterNPC脚本段 20090623

procedure TPlayObject.ClientBatterNPCGoto(sLable: string);
begin
  if (g_BatterNPC <> nil) and m_boTrainingNG and (sLable <> '') then begin //20091008 修改
    if (CompareText(sLable, m_sMessageBoxStr1) = 0) or (CompareText(sLable, m_sMessageBoxStr2) = 0) then begin //MESSAGEBOX命令的脚本
      m_sMessageBoxStr1 := '';
      m_sMessageBoxStr2 := '';
      g_BatterNPC.GotoLable(Self, sLable, False, False);
    end;
  end;
end;

//发送更新脉穴数据 20090623

procedure TPlayObject.SendUpdataPulseArr(nPulse {经络页}: byte);
var
  sSENDMSG: string;
begin
  if m_boTrainingNG and (nPulse < 5) then begin //学过内功
    sSENDMSG := EncodeBuffer(@m_wHumanPulseArr[nPulse], SizeOf(TPulseInfo));
    if sSENDMSG <> '' then begin
      m_DefMsg := MakeDefaultMsg(SM_SENDUPDATAPULSEARR, nPulse, 0, 0, 0, 0);
      SendSocket(@m_DefMsg, sSENDMSG);
    end;
  end;
end;

//客户端使用连击 20090624

procedure TPlayObject.ClientUseBatterSpell(TargeTBaseObject: TBaseObject; nTargetX, nTargetY: Integer; sMagicID: string);
var
  Str, Str1, Str2: string;
  n14: Integer;
begin
  if m_boDeath or ((m_wStatusTimeArr[POISON_STONE {5}] <> 0) and not g_ClientConf.boParalyCanHit)
    or (m_wStatusTimeArr[POISON_LOCKSPELL {7}] <> 0) or (m_wStatusArrValue[23] <> 0) or
    (not m_boCanSpell) then begin //防麻 //20100316增加非锁定才能使用连击
    m_nUseBatterTick := GetTickCount(); //使用连击的计时
    m_boSendCanBatterMsg := False;
    m_boUseBatter := False; //20110308 增加
    m_nBatterMagIdx1 := 0; //连击技能ID1
    m_nBatterMagIdx2 := 0; //连击技能ID2
    m_nBatterMagIdx3 := 0; //连击技能ID3
    m_nBatterMagIdx4 := 0; //连击技能ID4
    Exit;
  end;
  if m_boTrainingNG and m_boTrainBatterSkill and (not m_boUseBatter) then begin //学过内功,学过连击技能
    ShopCancel; //取消个人商店
    if GetTickCount() - m_nUseBatterTick > g_Config.dwUseBatterTick then begin //连击间隔
      if sMagicID <> '' then begin
        m_nUseBatterTick := GetTickCount(); //使用连击的计时
        m_boSendCanBatterMsg := False;
        n14 := GetNextDirection(m_nCurrX, m_nCurrY, nTargetX, nTargetY);
        m_btDirection := n14;
        if CretInNearXY(TargeTBaseObject, nTargetX, nTargetY) then begin
          SetTargetCreat(TargeTBaseObject);
          nTargetX := TargeTBaseObject.m_nCurrX;
          nTargetY := TargeTBaseObject.m_nCurrY;
        end;
        m_nTargetX := nTargetX; //目标X
        m_nTargetY := nTargetY; //目标Y
        //取出魔法ID
        m_nBatterMagIdx1 := 0; //连击技能ID1 20090701
        m_nBatterMagIdx2 := 0; //连击技能ID2 20090701
        m_nBatterMagIdx3 := 0; //连击技能ID3 20090701
        m_nBatterMagIdx4 := 0; //连击技能ID4 20100719
        sMagicID := GetValidStr3(sMagicID, Str, ['/']);
        sMagicID := GetValidStr3(sMagicID, Str1, ['/']);
        sMagicID := GetValidStr3(sMagicID, Str2, ['/']);
        m_nBatterMagIdx1 := Str_ToInt(Str, 0);
        m_nBatterMagIdx2 := Str_ToInt(Str1, 0);
        m_nBatterMagIdx3 := Str_ToInt(Str2, 0);
        m_nBatterMagIdx4 := Str_ToInt(sMagicID, 0);
        if not m_boUser4BatterSkill then m_nBatterMagIdx4 := 0; //未开启第四格连击 20100720
        if (m_nBatterMagIdx4 = m_nBatterMagIdx1) or (m_nBatterMagIdx4 = m_nBatterMagIdx2) or (m_nBatterMagIdx4 = m_nBatterMagIdx3) then begin
          m_nBatterMagIdx4 := 0;
        end;
        if (m_nBatterMagIdx3 = m_nBatterMagIdx1) or (m_nBatterMagIdx3 = m_nBatterMagIdx2) then begin
          m_nBatterMagIdx3 := 0;
        end;
        if (m_nBatterMagIdx2 = m_nBatterMagIdx1) or (m_nBatterMagIdx2 = m_nBatterMagIdx3) then begin
          m_nBatterMagIdx2 := 0;
        end;
        m_nUseBatterTime := 0;
        m_boUseBatter := True; //使用连击 20090630
        if m_btJob = 0 then begin //战
          m_boWarUseBatter := False;
          m_dwLatestWarUseBatterTick := GetTickCount();
        end else begin //道法
          m_nDecDamageRate := Random(g_Config.dwBatterRandDecDamageRate) + g_Config.dwBatterDecDamageRate; //吸伤比率 20090808
        end;
        SysMsg(g_sUseBatterSummoned, c_Green, t_Hint);
      end;
    end else begin
      if g_sUseBatterFail <> '' then
        SysMsg(Format_ToStr(g_sUseBatterFail {'连击技冷却时间还有%d'}, [(g_Config.dwUseBatterTick - (GetTickCount() - m_nUseBatterTick)) div 1000]), c_Green, t_Hint); //提示用户
    end;
  end;
end;
//放连击

procedure TPlayObject.UseBatterSpell(nMagicID {技能ID}, StormsHit {暴击率}: Byte);
var
  UserMagic: pTUserMagic;
  nSpellPoint: Integer;
  boTrain: Boolean;
  nCode: Byte;
begin
  nCode := 0;
  try
    if m_boDeath or m_boGhost then Exit; //20091124 增加
    nCode := 101;
    m_nUseBatterTick := GetTickCount(); //使用连击的计时
    nCode := 100;
    UserMagic := GetMagicInfo(nMagicID);
    nCode := 1;
    if (m_PEnvir <> nil) then begin //地图是否禁止使用魔法
      nCode := 2;
      if (UserMagic <> nil) then begin //20091018
        nCode := 21;
        if not m_PEnvir.AllowMagics(UserMagic.MagicInfo.sMagicName) then begin
          nCode := 3;
          m_nUseBatterTick := GetTickCount(); //使用连击的计时
          m_nBatterMagIdx1 := 0; //连击技能ID1 20090701
          m_nBatterMagIdx2 := 0; //连击技能ID2 20090701
          m_nBatterMagIdx3 := 0; //连击技能ID3 20090701
          m_nBatterMagIdx4 := 0; //连击技能ID4 20100719
          if (m_btJob = 0) then begin
            SendSocket(nil, '+UBAT');
            m_boUseBatter := False;
            m_boWarUseBatter := False;
            m_dwLatestWarUseBatterTick := GetTickCount();
          end;
          SysMsg(Format('当前地图不允许使用：%s', [UserMagic.MagicInfo.sMagicName]), c_Red, t_Notice);
          Exit;
        end;
      end;
      nCode := 4;
      if m_PEnvir.m_boMISSION then begin
        m_nUseBatterTick := GetTickCount(); //使用连击的计时
        m_nBatterMagIdx1 := 0; //连击技能ID1 20090701
        m_nBatterMagIdx2 := 0; //连击技能ID2 20090701
        m_nBatterMagIdx3 := 0; //连击技能ID3 20090701
        m_nBatterMagIdx4 := 0; //连击技能ID4 20100719
        if (m_btJob = 0) then begin
          SendSocket(nil, '+UBAT');
          m_boUseBatter := False;
          m_boWarUseBatter := False;
          m_dwLatestWarUseBatterTick := GetTickCount();
        end;
        SysMsg('当前地图不允许使用技能', c_Red, t_Notice);
        Exit;
      end;
    end;
    nCode := 5;
    if (UserMagic = nil) or m_boDeath or ((m_wStatusTimeArr[POISON_STONE {5}] <> 0) and not g_ClientConf.boParalyCanHit)
      or (m_wStatusTimeArr[POISON_LOCKSPELL {7}] <> 0) or (m_wStatusArrValue[23] <> 0) then begin
      m_nUseBatterTick := GetTickCount(); //使用连击的计时
      m_nBatterMagIdx1 := 0; //连击技能ID1 20090701
      m_nBatterMagIdx2 := 0; //连击技能ID2 20090701
      m_nBatterMagIdx3 := 0; //连击技能ID3 20090701
      m_nBatterMagIdx4 := 0; //连击技能ID4 20100719
      if (m_btJob = 0) then begin
        SendSocket(nil, '+UBAT');
        m_boUseBatter := False;
        m_boWarUseBatter := False;
        m_dwLatestWarUseBatterTick := GetTickCount();
      end;
      Exit;
    end;
    nCode := 6;
    nSpellPoint := GetSpellPoint(UserMagic); //取放技能所需要的内力值
    if (nSpellPoint > 0) and m_boTrainingNG then begin
      nCode := 7;
      if (m_Skill69NH < nSpellPoint) then begin
        m_nUseBatterTick := GetTickCount(); //使用连击的计时
        m_nBatterMagIdx1 := 0; //连击技能ID1 20090701
        m_nBatterMagIdx2 := 0; //连击技能ID2 20090701
        m_nBatterMagIdx3 := 0; //连击技能ID3 20090701
        m_nBatterMagIdx4 := 0; //连击技能ID4 20100719
        if (m_btJob = 0) then begin
          SendSocket(nil, '+UBAT');
          m_boUseBatter := False;
          m_boWarUseBatter := False;
          m_dwLatestWarUseBatterTick := GetTickCount();
        end;
        SysMsg('内力不足', c_Green, t_Hint);
        Exit;
      end;
      m_Skill69NH := _MAX(0, m_Skill69NH - nSpellPoint);
      nCode := 8;
      SendRefMsg(RM_MAGIC69SKILLNH, 0, m_Skill69NH, m_Skill69MaxNH, 0, '');
      if m_btJob > 0 then begin //道法职业
        SendRefMsg(RM_10205, 15, 0, 0, 0, ''); //保护盾特效 20090628
        nCode := 9;
        if m_TargetCret <> nil then begin
          m_nTargetX := m_TargetCret.m_nCurrX;
          m_nTargetY := m_TargetCret.m_nCurrY;
        end;
        nCode := 10;
        m_btDirection := GetNextDirection(m_nCurrX, m_nCurrY, m_nTargetX, m_nTargetY);
        nCode := 11;
        SendRefMsg(RM_SPELL, UserMagic.MagicInfo.btEffect, m_nTargetX, m_nTargetY, UserMagic.MagicInfo.wMagicId, '');
        case UserMagic.MagicInfo.wMagicId of
          SKILL_77: begin //双龙破{法}
              if MagicManager.MagMakeSkillFire_77(self, UserMagic, m_nTargetX, m_nTargetY, m_TargetCret, StormsHit) then boTrain := True;
            end;
          SKILL_80: begin //凤舞祭{法}
              if MagicManager.MagMakeSkillFire_80(self, UserMagic, m_nTargetX, m_nTargetY, m_TargetCret, StormsHit) then boTrain := True;
            end;
          SKILL_83: begin //惊雷爆{法}
              if MagicManager.MagMakeSkillFire_83(self, UserMagic, m_nTargetX, m_nTargetY, m_TargetCret, StormsHit) then boTrain := True;
            end;
          SKILL_86: begin //冰天雪地{法}
              if MagicManager.MagMakeSkillFire_86(self, UserMagic, m_nTargetX, m_nTargetY, StormsHit) then boTrain := True;
            end;
          SKILL_78: begin //虎啸诀{道}
              if MagicManager.MagMakeSkillFire_78(self, UserMagic, m_nTargetX, m_nTargetY, m_TargetCret, StormsHit) then boTrain := True;
            end;
          SKILL_81: begin //八卦掌{道}
              if MagicManager.MagMakeSkillFire_81(self, UserMagic, m_nTargetX, m_nTargetY, m_TargetCret, StormsHit) then boTrain := True;
            end;
          SKILL_84: begin //三焰咒{道}
              if MagicManager.MagMakeSkillFire_84(self, UserMagic, m_nTargetX, m_nTargetY, m_TargetCret, StormsHit) then boTrain := True;
            end;
          SKILL_87: begin //万剑归宗{道}
              if MagicManager.MagMakeSkillFire_87(self, UserMagic, m_nTargetX, m_nTargetY, StormsHit) then boTrain := True;
            end;
        end; //Case
        nCode := 12;
        SendRefMsg(RM_MAGICFIRE, 0, MakeWord(UserMagic.MagicInfo.btEffectType, UserMagic.MagicInfo.btEffect),
          MakeLong(m_nTargetX, m_nTargetY), Integer(m_TargetCret), '');
        nCode := 13;
        SendSocket(nil, sSTATUS_GOOD);
        if (UserMagic.btLevel < 5) and (boTrain) then begin
          nCode := 14;
          case UserMagic.MagicInfo.wMagicId of
            SKILL_77, SKILL_78: begin //双龙破{法} 虎啸诀{道}
                if UserMagic.btLevel < m_wHumanPulseArr[0].nPulseLevel then begin
                  TrainSkill(UserMagic, Random(3) + 1); ///增加技能的修练值
                  if not CheckMagicLevelup(UserMagic) then begin
                    SendDelayMsg(self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 1000);
                  end;
                end;
              end;
            SKILL_80, SKILL_81: begin //凤舞祭{法} 八卦掌{道}
                if UserMagic.btLevel < m_wHumanPulseArr[1].nPulseLevel then begin
                  TrainSkill(UserMagic, Random(3) + 1); ///增加技能的修练值
                  if not CheckMagicLevelup(UserMagic) then begin
                    SendDelayMsg(self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 1000);
                  end;
                end;
              end;
            SKILL_83, SKILL_84: begin //惊雷爆{法} 三焰咒{道}
                if UserMagic.btLevel < m_wHumanPulseArr[2].nPulseLevel then begin
                  TrainSkill(UserMagic, Random(3) + 1); ///增加技能的修练值
                  if not CheckMagicLevelup(UserMagic) then begin
                    SendDelayMsg(self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 1000);
                  end;
                end;
              end;
            SKILL_86, SKILL_87: begin //冰天雪地{法} 万剑归宗{道}
                if UserMagic.btLevel < m_wHumanPulseArr[3].nPulseLevel then begin
                  TrainSkill(UserMagic, Random(3) + 1); ///增加技能的修练值
                  if not CheckMagicLevelup(UserMagic) then begin
                    SendDelayMsg(self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId, 0, UserMagic.btLevel, UserMagic.nTranPoint, '', 1000);
                  end;
                end;
              end;
          end; //case
        end;
      end else begin //战
        nCode := 18;
        case UserMagic.MagicInfo.wMagicId of
          SKILL_79: begin //追心刺
              SendSocket(nil, '+BAT1');
            end;
          SKILL_76: begin //三绝杀
              SendSocket(nil, '+BAT2');
            end;
          SKILL_82: begin //断岳斩
              SendSocket(nil, '+BAT4');
            end;
          SKILL_85: begin //横扫千军
              SendSocket(nil, '+BAT3');
            end;
        end;
      end;
    end else begin
      nCode := 19;
      m_nUseBatterTick := GetTickCount(); //使用连击的计时
      m_nBatterMagIdx1 := 0; //连击技能ID1 20090701
      m_nBatterMagIdx2 := 0; //连击技能ID2 20090701
      m_nBatterMagIdx3 := 0; //连击技能ID3 20090701
      m_nBatterMagIdx4 := 0; //连击技能ID4 20100719
      if (m_btJob = 0) then begin
        SendSocket(nil, '+UBAT');
        m_boUseBatter := False;
        m_boWarUseBatter := False;
        m_dwLatestWarUseBatterTick := GetTickCount();
      end;
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.UseBatterSpell Code:%d', [g_sExceptionVer, nCode]));
  end;
end;

//战连击处理 20090704

procedure TPlayObject.BatterAttackDir(TargeTBaseObject: TBaseObject; wHitMode: Word; nDir: Integer; StormsHit {暴击率}: Byte);
  function MPow(UserMagic: pTUserMagic): Integer; //计算技能威力
  var nPower: Integer;
  begin
    if UserMagic.MagicInfo.wMaxPower > UserMagic.MagicInfo.wPower then
      nPower := UserMagic.MagicInfo.wPower + Random(UserMagic.MagicInfo.wMaxPower - UserMagic.MagicInfo.wPower)
    else nPower := UserMagic.MagicInfo.wPower;
    if UserMagic.MagicInfo.btDefMaxPower > UserMagic.MagicInfo.btDefPower then
      Result := Round(nPower / (UserMagic.MagicInfo.btTrainLv + 1) * (UserMagic.btLevel + 1)) + (UserMagic.MagicInfo.btDefPower + Random(UserMagic.MagicInfo.btDefMaxPower - UserMagic.MagicInfo.btDefPower))
    else Result := Round(nPower / (UserMagic.MagicInfo.btTrainLv + 1) * (UserMagic.btLevel + 1)) + UserMagic.MagicInfo.btDefPower;
  end;
  function DirectAttack(BaseObject: TBaseObject; nSecPwr: Integer; boStorm: Boolean): Boolean; //攻击角色
  begin
    Result := False;
    if BaseObject <> nil then begin //20090731
    //if not (InSafeZone and BaseObject.InSafeZone) then begin//20090730 注释
      if (Random(BaseObject.m_btSpeedPoint) <= (m_btHitPoint + 10)) or boStorm then begin //20090725 +10
        BaseObject.StruckDamage(nSecPwr);
        BaseObject.SendDelayMsg(TBaseObject(RM_STRUCK), {RM_10101} RM_10102, nSecPwr, BaseObject.m_WAbil.HP, BaseObject.m_WAbil.MaxHP, Integer(Self), '', 500);
        if (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) and (BaseObject.m_btRaceServer <> RC_HEROOBJECT) then begin
          BaseObject.SendMsg(BaseObject, RM_STRUCK, nSecPwr, BaseObject.m_WAbil.HP, BaseObject.m_WAbil.MaxHP, Integer(Self), '');
        end;
        Result := True;
      end;
    //end;
    end;
  end;
  function Attack_79(nSecPwr, nMagicLevel: Integer; nDir: Byte): Boolean; //追心刺
    function CanMotaebo1(BaseObject: TBaseObject; nMagicLevel: Integer): Boolean;
    var
      nC: Integer;
    begin
      Result := False;
      if (m_Abil.Level > BaseObject.m_Abil.Level) and (not BaseObject.m_boStickMode) then begin
        nC := m_Abil.Level - BaseObject.m_Abil.Level;
        if Random(20) < ((nMagicLevel * 4) + 6 + nC) then begin
          {if IsProperTarget(BaseObject) then }Result := True; //20090730 修改
        end;
      end;
    end;
    function CharPushed_79(Target: TBaseObject; nDir, nPushCount: Integer): Integer;
    var
      I, nX, nY, olddir, nBackDir: Integer;
    begin
      Result := 0;
      olddir := Target.m_btDirection;
      Target.m_btDirection := nDir;
      nBackDir := GetBackDir(nDir);
      if nPushCount > 0 then begin
        for I := 0 to nPushCount - 1 do begin
          Target.GetFrontPosition(nX, nY);
          if Target.m_PEnvir.CanWalk(nX, nY, False) then begin
            if Target.m_PEnvir.MoveToMovingObject(Target.m_nCurrX, Target.m_nCurrY, Target, nX, nY, False) > 0 then begin
              Target.m_nCurrX := nX;
              Target.m_nCurrY := nY;
              Inc(Result);
            end else Break;
          end else Break;
        end; //for
        if Result > 0 then begin
          Target.SendRefMsg(RM_PUSH, nBackDir, Target.m_nCurrX, Target.m_nCurrY, 0, '');
          if Target.m_btRaceServer >= RC_ANIMAL then Target.m_dwWalkTick := Target.m_dwWalkTick + 800;
        end;
      end;
      Target.m_btDirection := nBackDir;
      if Result = 0 then Target.m_btDirection := olddir;
    end;
  var
    {bo35,}bo34: Boolean;
    I, n20, n24, K: Integer;
    PoseCreate: TBaseObject;
    BaseObject_30: TBaseObject;
    BaseObject_34: TBaseObject;
    nX, nY: Integer;
  begin
    SendRefMsg(RM_BATTERHIT1, m_btDirection, m_nCurrX, m_nCurrY, 0, ''); //追心刺 20090707
    Result := False;
    //bo35 := True;
    bo34 := True;
    m_btDirection := nDir;
    BaseObject_34 := nil;
    n24 := 0;
    PoseCreate := GetPoseCreate(); //取对面的角色
    if PoseCreate <> nil then begin
      if IsProperTarget(PoseCreate) then begin //20090730 增加
        BaseObject_34 := PoseCreate;
        if CanMotaebo1(PoseCreate, nMagicLevel) then begin
          if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, 2, nX, nY) then begin
            BaseObject_30 := m_PEnvir.GetMovingObject(nX, nY, True);
            if (BaseObject_30 <> nil) then bo34 := False; //后面有人则不能撞
          end;
          if bo34 then begin
            K := CharPushed_79(PoseCreate, m_btDirection, _MAX(3, nMagicLevel + 2));
            if K <= 0 then K := 1; //20091113 增加
            for I := 0 to K - 1 do begin
              if PoseCreate <> nil then begin
                GetFrontPosition(nX, nY);
                if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nX, nY, False) > 0 then begin
                  m_nCurrX := nX;
                  m_nCurrY := nY;
                  SendRefMsg(RM_RUSH79, nDir, m_nCurrX, m_nCurrY, 0, '');
                  //bo35 := False;
                end else Break;
                Inc(n24);
              end else Break; //if PoseCreate <> nil  then begin
            end; //for i:=0 to K do begin
          end;
        end;
      end;
    end;
    if (BaseObject_34 <> nil) then begin //目标掉血
      if n24 < 0 then n24 := 0;
      if n24 > 3 then n24 := 3;
      n20 := Random((n24 + 1) * 5) + nSecPwr;
      n20 := BaseObject_34.GetHitStruckDamage(Self, n20);
      BaseObject_34.StruckDamage(n20);
      BaseObject_34.SendRefMsg(RM_STRUCK, n20, BaseObject_34.m_WAbil.HP, BaseObject_34.m_WAbil.MaxHP, Integer(Self), '');
      if BaseObject_34.m_btRaceServer <> RC_PLAYOBJECT then begin
        BaseObject_34.SendMsg(BaseObject_34, RM_STRUCK, n20, BaseObject_34.m_WAbil.HP, BaseObject_34.m_WAbil.MaxHP, Integer(Self), '');
      end;
      BaseObject_34.m_wStatusTimeArr[POISON_DONTMOVE] := 1; //被打中,不可移动 20090903
      BaseObject_34.m_dwStatusArrTick[POISON_DONTMOVE] := GetTickCount();
      Result := True;
    end;
  end;
  function Attack_85(nSecPwr: Integer; boStorm: Boolean): Boolean; //横扫千军
  var
    BaseObjectList: TList;
    TargeTBaseObject: TBaseObject;
    I, nPower: Integer;
  begin
    Result := False;
    BaseObjectList := TList.Create;
    try
      m_PEnvir.GetMapBaseObjects(m_nCurrX, m_nCurrY, g_Config.nBatterSkillFireRange_85, BaseObjectList);
      if BaseObjectList.Count > 0 then begin
        for I := 0 to BaseObjectList.Count - 1 do begin
          TargeTBaseObject := TBaseObject(BaseObjectList.Items[I]);
          if TargeTBaseObject <> nil then begin
            if IsProperTarget(TargeTBaseObject) and (TargeTBaseObject.m_btRaceServer <> 79) then begin //是否是适当的目标
              nPower := TargeTBaseObject.GetHitStruckDamage(Self, nSecPwr);
              Result := DirectAttack(TargeTBaseObject, nPower, boStorm);
              if (TargeTBaseObject <> nil) and Result then begin
                TargeTBaseObject.m_wStatusTimeArr[POISON_DONTMOVE] := 1; //被打中,不可移动 20090903
                TargeTBaseObject.m_dwStatusArrTick[POISON_DONTMOVE] := GetTickCount();
              end;
            end;
          end;
        end; //for
      end;
    finally
      BaseObjectList.Free;
    end;
  end;
  function Attack_82(nSecPwr: Integer; boStorm: Boolean): Boolean; //断岳斩
  var
    I, nPower: Integer;
    BaseObjectList: TList;
    TargeTBaseObject: TBaseObject;
  begin
    Result := False;
    BaseObjectList := TList.Create;
    try
      GetDirectionBaseObjects(m_btDirection, g_Config.nBatterSkillFireRange_82 {3}, BaseObjectList); //同个方向的怪 3格
      if BaseObjectList.Count > 0 then begin //20080629
        for I := 0 to BaseObjectList.Count - 1 do begin
          TargeTBaseObject := TBaseObject(BaseObjectList.Items[I]);
          if TargeTBaseObject <> nil then begin
            if IsProperTarget(TargeTBaseObject) and (TargeTBaseObject.m_btRaceServer <> 79) then begin
              nPower := TargeTBaseObject.GetHitStruckDamage(Self, nSecPwr);
              Result := DirectAttack(TargeTBaseObject, nPower, boStorm);
              if (TargeTBaseObject <> nil) and Result then begin
                TargeTBaseObject.m_wStatusTimeArr[POISON_DONTMOVE] := 1; //被打中,不可移动 20090903
                TargeTBaseObject.m_dwStatusArrTick[POISON_DONTMOVE] := GetTickCount();
              end;
            end;
          end;
        end;
      end;
    finally
      BaseObjectList.Free;
    end;
  end;
  function _BatterAttack(var wHitMode: Word; AttackTarget: TBaseObject; StormsHitRate: Byte): Boolean;
  var
    nPower, nWeaponDamage, n20: Integer;
    nCode: Byte;
    boBatterStorm: Boolean; //是否暴击 20090903
  begin
    Result := False;
    boBatterStorm := False; //是否暴击 20090903
    nWeaponDamage := 0;
    nPower := 0;
    nCode := 0;
    try
      case wHitMode of //计算技能威力
        14: begin //追心刺
            if m_Magic79Skill <> nil then nPower := GetAttackPower(MPow(m_Magic79Skill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC)))); //追心刺
            if (m_Magic79Skill <> nil) and (m_Magic79Skill.btLevel > 0) and (m_Magic79Skill.btLevel < 6) then begin
              Randomize(); //随机种子
              if Random(100) <= (m_wHumanPulseArr[1].nStormsHit + StormsHitRate) then begin //20090726 修改
                nPower := nPower + Round(nPower * (g_Config.nStormsHitRate[m_Magic79Skill.btLevel] / 100));
                boBatterStorm := True; //是否暴击 20090903
              end;
            end;
            nPower := nPower + m_wStatusArrValue[15]; //连击伤害增加
            nCode := 2;
            if IsProperTarget(AttackTarget) and (AttackTarget.m_btRaceServer <> 79) then begin
              if (Random(AttackTarget.m_btSpeedPoint) >= m_btHitPoint) and (not boBatterStorm) then nPower := 0;
            end else nPower := 0;
            nCode := 3;
            if nPower > 0 then begin
              nCode := 4;
              nPower := AttackTarget.GetHitStruckDamage(Self, nPower);
              nWeaponDamage := (Random(5) + 2) - m_AddAbil.btWeaponStrong; //武器强度
              if (nWeaponDamage > 0) and (m_UseItems[U_WEAPON].wIndex > 0) then DoDamageWeapon(nWeaponDamage);
              if m_nHongMoSuite > 0 then begin //虹魔，吸血
                m_db3B0 := nPower / 1.E2 * m_nHongMoSuite;
                if m_db3B0 >= 2.0 then begin
                  n20 := Trunc(m_db3B0);
                  m_db3B0 := n20;
                  DamageHealth(-n20);
                end;
              end;
{$IF M2Version = 1}
              if (nPower > 0) then begin //虎威装备吸血
                if (m_nVampirePoint > 0) and ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) then begin
                  if Random(100) <= m_nVampireRate then begin
                    n20 := 0;
                    n20 := Random(m_nVampirePoint);
                    if n20 > 0 then DamageHealth(-n20);
                  end;
                end;
              end;
{$IFEND}
            end;
            nCode := 5;
            if boBatterStorm then begin
              SendRefMsg(RM_10205, 14, 0, 0, 0, ''); //暴击特效
              SysMsg(Format_ToStr(g_sUseBatterStorms, [m_Magic79Skill.MagicInfo.sMagicName]), c_Green, t_Hint); //暴击提示
            end;
            if Attack_79(nPower, m_Magic79Skill.btLevel, m_btDirection) then begin
              nCode := 6;
              if (m_Magic79Skill <> nil) then begin //追心刺升级
                nCode := 18;
                if (m_Magic79Skill.btLevel < 5) and (m_Magic79Skill.btLevel < m_wHumanPulseArr[1].nPulseLevel) then begin //20110115 修改
              //if (m_Magic79Skill.btLevel < 3) and (m_Magic79Skill.MagicInfo.TrainLevel[m_Magic79Skill.btLevel] <= m_NGLevel) then begin
                  nCode := 19;
                  TrainSkill(m_Magic79Skill, Random(3) + 1);
                  nCode := 20;
                  if not CheckMagicLevelup(m_Magic79Skill) then begin
                    nCode := 21;
                    SendDelayMsg(Self, RM_MAGIC_LVEXP, m_Magic79Skill.MagicInfo.wMagicId, 0, m_Magic79Skill.btLevel, m_Magic79Skill.nTranPoint, '', 3000);
                  end;
                end;
              end;
            end;
            Result := True;
          end; //14
        15: begin //三绝杀
            if m_Magic76Skill <> nil then nPower := GetAttackPower(MPow(m_Magic76Skill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC)))); //三绝杀
            if (m_Magic76Skill <> nil) and (m_Magic76Skill.btLevel > 0) and (m_Magic76Skill.btLevel < 6) then begin
              Randomize(); //随机种子
              if Random(100) <= (m_wHumanPulseArr[0].nStormsHit + StormsHitRate) then begin //20090726 修改
                nPower := nPower + Round(nPower * (g_Config.nStormsHitRate[m_Magic76Skill.btLevel] / 100));
                boBatterStorm := True; //是否暴击 20090903
              end;
            end;
            nPower := nPower + m_wStatusArrValue[15]; //连击伤害增加
            nCode := 8;
            if IsProperTarget(AttackTarget) and (AttackTarget.m_btRaceServer <> 79) then begin
              if (Random(AttackTarget.m_btSpeedPoint) >= m_btHitPoint) and (not boBatterStorm) then nPower := 0;
            end else nPower := 0;
            nCode := 9;
            if (nPower > 0) and (AttackTarget <> nil) then begin
              nPower := AttackTarget.GetHitStruckDamage(Self, nPower);
              nWeaponDamage := (Random(5) + 2) - m_AddAbil.btWeaponStrong; //武器强度
              if (nWeaponDamage > 0) and (m_UseItems[U_WEAPON].wIndex > 0) then DoDamageWeapon(nWeaponDamage);
              if m_nHongMoSuite > 0 then begin //虹魔，吸血
                m_db3B0 := nPower / 1.E2 * m_nHongMoSuite;
                if m_db3B0 >= 2.0 then begin
                  n20 := Trunc(m_db3B0);
                  m_db3B0 := n20;
                  DamageHealth(-n20);
                end;
              end;
{$IF M2Version = 1}
              if (nPower > 0) then begin //虎威装备吸血
                if (m_nVampirePoint > 0) and ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) then begin
                  if Random(100) <= m_nVampireRate then begin
                    n20 := 0;
                    n20 := Random(m_nVampirePoint);
                    if n20 > 0 then DamageHealth(-n20);
                  end;
                end;
              end;
{$IFEND}
              if boBatterStorm then begin
                SendRefMsg(RM_10205, 14, 0, 0, 0, ''); ////暴击特效
                SysMsg(Format_ToStr(g_sUseBatterStorms, [m_Magic76Skill.MagicInfo.sMagicName]), c_Green, t_Hint); //暴击提示
              end;
              nCode := 10;
              DirectAttack(AttackTarget, nPower, boBatterStorm);
              if AttackTarget <> nil then begin
                AttackTarget.m_wStatusTimeArr[POISON_DONTMOVE] := 1; //被打中,不可移动 20090903
                AttackTarget.m_dwStatusArrTick[POISON_DONTMOVE] := GetTickCount();
              end;
              nCode := 11;
              if (m_Magic76Skill <> nil) then begin //三绝杀升级
                nCode := 22;
                if (m_Magic76Skill.btLevel < 5) and (m_Magic76Skill.btLevel < m_wHumanPulseArr[0].nPulseLevel) then begin //20110115 修改
                  nCode := 23;
                  TrainSkill(m_Magic76Skill, Random(3) + 1);
                  nCode := 24;
                  if not CheckMagicLevelup(m_Magic76Skill) then begin
                    nCode := 25;
                    SendDelayMsg(Self, RM_MAGIC_LVEXP, m_Magic76Skill.MagicInfo.wMagicId, 0, m_Magic76Skill.btLevel, m_Magic76Skill.nTranPoint, '', 3000);
                  end;
                end;
              end;
            end;
            Result := True;
          end; //15
        16: begin //横扫千军
            if m_Magic85Skill <> nil then nPower := GetAttackPower(MPow(m_Magic85Skill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC)))); //横扫千军
            if (m_Magic85Skill <> nil) and (m_Magic85Skill.btLevel > 0) and (m_Magic85Skill.btLevel < 6) then begin
              Randomize(); //随机种子
              if Random(100) <= (m_wHumanPulseArr[3].nStormsHit + StormsHitRate) then begin //20090726 修改
                nPower := nPower + Round(nPower * (g_Config.nStormsHitRate[m_Magic85Skill.btLevel] / 100));
                SendRefMsg(RM_10205, 14, 0, 0, 0, ''); ////暴击特效
                SysMsg(Format_ToStr(g_sUseBatterStorms, [m_Magic85Skill.MagicInfo.sMagicName]), c_Green, t_Hint); //暴击提示
                boBatterStorm := True; //是否暴击 20090903
              end;
            end;
            nPower := nPower + m_wStatusArrValue[15]; //连击伤害增加
            nCode := 13;
            if Attack_85(nPower, boBatterStorm) then begin
              if m_nHongMoSuite > 0 then begin //虹魔，吸血
                m_db3B0 := nPower / 1.E2 * m_nHongMoSuite;
                if m_db3B0 >= 2.0 then begin
                  n20 := Trunc(m_db3B0);
                  m_db3B0 := n20;
                  DamageHealth(-n20);
                end;
              end;
{$IF M2Version = 1}
              if (nPower > 0) then begin //虎威装备吸血
                if (m_nVampirePoint > 0) and ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) then begin
                  if Random(100) <= m_nVampireRate then begin
                    n20 := 0;
                    n20 := Random(m_nVampirePoint);
                    if n20 > 0 then DamageHealth(-n20);
                  end;
                end;
              end;
{$IFEND}
              nCode := 14;
              if (m_Magic85Skill <> nil) then begin //横扫千军升级
                nCode := 26;
                if (m_Magic85Skill.btLevel < 5) and (m_Magic85Skill.btLevel < m_wHumanPulseArr[3].nPulseLevel) then begin //20110115 修改
              //if (m_Magic85Skill.btLevel < 3) and (m_Magic85Skill.MagicInfo.TrainLevel[m_Magic85Skill.btLevel] <= m_NGLevel) then begin
                  nCode := 27;
                  TrainSkill(m_Magic85Skill, Random(3) + 1);
                  nCode := 28;
                  if not CheckMagicLevelup(m_Magic85Skill) then begin
                    nCode := 29;
                    SendDelayMsg(Self, RM_MAGIC_LVEXP, m_Magic85Skill.MagicInfo.wMagicId, 0, m_Magic85Skill.btLevel, m_Magic85Skill.nTranPoint, '', 3000);
                  end;
                end;
              end;
            end;
            Result := True;
          end; //16
        17: begin //断岳斩
            if m_Magic82Skill <> nil then nPower := GetAttackPower(MPow(m_Magic82Skill) + LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC)))); //断岳斩
            if (m_Magic82Skill <> nil) and (m_Magic82Skill.btLevel > 0) and (m_Magic82Skill.btLevel < 6) then begin
              Randomize(); //随机种子
              if Random(100) <= (m_wHumanPulseArr[2].nStormsHit + StormsHitRate) then begin //20090726 修改
                nPower := nPower + Round(nPower * (g_Config.nStormsHitRate[m_Magic82Skill.btLevel] / 100));
                SendRefMsg(RM_10205, 14, 0, 0, 0, ''); ////暴击特效
                SysMsg(Format_ToStr(g_sUseBatterStorms, [m_Magic82Skill.MagicInfo.sMagicName]), c_Green, t_Hint); //暴击提示
                boBatterStorm := True; //是否暴击 20090903
              end;
            end;
            nPower := nPower + m_wStatusArrValue[15]; //连击伤害增加
            nCode := 16;
            if Attack_82(nPower, boBatterStorm) then begin
              if m_nHongMoSuite > 0 then begin //虹魔，吸血
                m_db3B0 := nPower / 1.E2 * m_nHongMoSuite;
                if m_db3B0 >= 2.0 then begin
                  n20 := Trunc(m_db3B0);
                  m_db3B0 := n20;
                  DamageHealth(-n20);
                end;
              end;
{$IF M2Version = 1}
              if (nPower > 0) then begin //虎威装备吸血
                if (m_nVampirePoint > 0) and ((m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT)) then begin
                  if Random(100) <= m_nVampireRate then begin
                    n20 := 0;
                    n20 := Random(m_nVampirePoint);
                    if n20 > 0 then DamageHealth(-n20);
                  end;
                end;
              end;
{$IFEND}
              nCode := 17;
              if (m_Magic82Skill <> nil) then begin //断岳斩升级
                nCode := 30;
                if (m_Magic82Skill.btLevel < 5) and (m_Magic82Skill.btLevel < m_wHumanPulseArr[2].nPulseLevel) then begin //20110115 修改
              //if (m_Magic82Skill.btLevel < 3) and (m_Magic82Skill.MagicInfo.TrainLevel[m_Magic82Skill.btLevel] <= m_NGLevel) then begin
                  nCode := 31;
                  TrainSkill(m_Magic82Skill, Random(3) + 1);
                  nCode := 32;
                  if not CheckMagicLevelup(m_Magic82Skill) then begin
                    nCode := 33;
                    SendDelayMsg(Self, RM_MAGIC_LVEXP, m_Magic82Skill.MagicInfo.wMagicId, 0, m_Magic82Skill.btLevel, m_Magic82Skill.nTranPoint, '', 3000);
                  end;
                end;
              end;
            end;
            Result := True;
          end; //17
      end;
    except
      on E: Exception do begin
        MainOutMessage(Format('{%s} TPlayObject._BatterAttack Code:%d', [g_sExceptionVer, nCode]));
      end;
    end;
  end;
var
  AttackTarget: TBaseObject;
  nX, nY: integer;
begin
  try
    m_btDirection := _MIN(7, nDir); //20101123 判断方向是否大于7
    if TargeTBaseObject = nil then begin
      AttackTarget := GetPoseCreate();
      if (AttackTarget = nil) and ((wHitMode = 15) or (wHitMode = 16) or (wHitMode = 17)) then begin //20090726 取两格位置的目标
        if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, 2, nX, nY) then begin
          AttackTarget := m_PEnvir.GetMovingObject(nX, nY, True);
        end;
      end;
    end else AttackTarget := TargeTBaseObject;

    if _BatterAttack(wHitMode, AttackTarget, StormsHit) then begin //处理目标掉血以级技能升级点数
      if AttackTarget <> nil then SetTargetCreat(AttackTarget); //20090731 修改
    end;
    case wHitMode of
      15: SendAttackMsg(RM_BATTERHIT2, m_btDirection, 0, m_nCurrX, m_nCurrY); //三绝杀 20090703
      16: SendAttackMsg(RM_BATTERHIT3, m_btDirection, 0, m_nCurrX, m_nCurrY); //横扫千军 20090703
      17: SendAttackMsg(RM_BATTERHIT4, m_btDirection, 0, m_nCurrX, m_nCurrY); //断岳斩 20090703
    end;
  except
    on E: Exception do begin
      MainOutMessage(format('{%s} TPlayObject.BatterAttackDir', [g_sExceptionVer]));
    end;
  end;
end;

//英雄取经络经验 20090911

procedure TPlayObject.HeroGetPulsExp(dwExp: LongWord);
begin
  if (m_GroupOwner <> nil) then Exit; //组队不能取到经验
  if (m_MyHero <> nil) then begin
    if THeroObject(m_MyHero).m_boOpenHumanPulseArr then THeroObject(m_MyHero).GetPulsExp(dwExp, 0);
  end;
end;

//战士连击处理 20090706

function TPlayObject.ClientBatterHitXY(wIdent: Word; nX, nY, nDir: Integer): Boolean;
begin
  Result := False;
  try //20090805 增加
    if (not m_boUseBatter) or (not m_boCanHit) or m_boDeath or ((m_wStatusTimeArr[POISON_STONE {5}] <> 0) and not g_ClientConf.boParalyCanHit)
      or (m_wStatusTimeArr[POISON_LOCKSPELL {7}] <> 0) or (m_wStatusArrValue[23] <> 0) then begin
      m_nUseBatterTick := GetTickCount(); //使用连击的计时
      m_nBatterMagIdx1 := 0; //连击技能ID1 20090701
      m_nBatterMagIdx2 := 0; //连击技能ID2 20090701
      m_nBatterMagIdx3 := 0; //连击技能ID3 20090701
      m_nBatterMagIdx4 := 0; //连击技能ID4 20100719
      if (m_btJob = 0) then begin
        SendSocket(nil, '+UBAT');
        m_boUseBatter := False;
        m_boWarUseBatter := False;
        m_dwLatestWarUseBatterTick := GetTickCount();
      end;
      Exit;
    end;
    if (wIdent = CM_BATTERHIT1) then begin //追心刺 20090625
      if m_nBatterMagIdx1 = SKILL_79 then begin
        m_nBatterMagIdx1 := 0;
        m_boWarUseBatter := False;
        BatterAttackDir(nil, 14, nDir, 10);
      end else
        if m_nBatterMagIdx2 = SKILL_79 then begin
          m_nBatterMagIdx2 := 0;
          m_boWarUseBatter := False;
          BatterAttackDir(nil, 14, nDir, 15);
        end else
          if m_nBatterMagIdx3 = SKILL_79 then begin
            m_nBatterMagIdx3 := 0;
            m_boWarUseBatter := False;
            BatterAttackDir(nil, 14, nDir, 25);
          end else
            if m_nBatterMagIdx4 = SKILL_79 then begin
              m_nBatterMagIdx4 := 0;
              m_boWarUseBatter := False;
              BatterAttackDir(nil, 14, nDir, 30);
            end;
    end;
    if (wIdent = CM_BATTERHIT2) then begin //三绝杀 20090703
      if m_nBatterMagIdx1 = SKILL_76 then begin
        m_nBatterMagIdx1 := 0;
        m_boWarUseBatter := False;
        BatterAttackDir(nil, 15, nDir, 10);
      end else
        if m_nBatterMagIdx2 = SKILL_76 then begin
          m_nBatterMagIdx2 := 0;
          m_boWarUseBatter := False;
          BatterAttackDir(nil, 15, nDir, 15);
        end else
          if m_nBatterMagIdx3 = SKILL_76 then begin
            m_nBatterMagIdx3 := 0;
            m_boWarUseBatter := False;
            BatterAttackDir(nil, 15, nDir, 25);
          end else
            if m_nBatterMagIdx4 = SKILL_76 then begin
              m_nBatterMagIdx4 := 0;
              m_boWarUseBatter := False;
              BatterAttackDir(nil, 15, nDir, 30);
            end;
    end;
    if (wIdent = CM_BATTERHIT3) then begin //横扫千军 20090703
      if m_nBatterMagIdx1 = SKILL_85 then begin
        m_nBatterMagIdx1 := 0;
        m_boWarUseBatter := False;
        BatterAttackDir(nil, 16, nDir, 10);
      end else
        if m_nBatterMagIdx2 = SKILL_85 then begin
          m_nBatterMagIdx2 := 0;
          m_boWarUseBatter := False;
          BatterAttackDir(nil, 16, nDir, 15);
        end else
          if m_nBatterMagIdx3 = SKILL_85 then begin
            m_nBatterMagIdx3 := 0;
            m_boWarUseBatter := False;
            BatterAttackDir(nil, 16, nDir, 25);
          end else
            if m_nBatterMagIdx4 = SKILL_85 then begin
              m_nBatterMagIdx4 := 0;
              m_boWarUseBatter := False;
              BatterAttackDir(nil, 16, nDir, 30);
            end;
    end;
    if (wIdent = CM_BATTERHIT4) then begin //断岳斩 20090703
      if m_nBatterMagIdx1 = SKILL_82 then begin
        m_nBatterMagIdx1 := 0;
        m_boWarUseBatter := False;
        BatterAttackDir(nil, 17, nDir, 10);
      end else
        if m_nBatterMagIdx2 = SKILL_82 then begin
          m_nBatterMagIdx2 := 0;
          m_boWarUseBatter := False;
          BatterAttackDir(nil, 17, nDir, 15);
        end else
          if m_nBatterMagIdx3 = SKILL_82 then begin
            m_nBatterMagIdx3 := 0;
            m_boWarUseBatter := False;
            BatterAttackDir(nil, 17, nDir, 25);
          end else
            if m_nBatterMagIdx4 = SKILL_82 then begin
              m_nBatterMagIdx4 := 0;
              m_boWarUseBatter := False;
              BatterAttackDir(nil, 17, nDir, 30);
            end;
    end;
    Result := True;
    m_dwIncNHTick := GetTickCount();
    Dec(m_nHealthTick, 30);
    Dec(m_nSpellTick, 100);
    m_nSpellTick := _MAX(0, m_nSpellTick);
    Dec(m_nPerHealth, 2);
    Dec(m_nPerSpell, 2);
  except
    on E: Exception do MainOutMessage(format('{%s} TPlayObject.ClientBatterHitXY', [g_sExceptionVer]));
  end;
end;

//斗转星移 取等级升级所需经验

function TPlayObject.GetSkill95Exp(nLevel: Byte): LongWord;
begin
  Result := 0;
  if nLevel = 0 then nLevel := 1;
  if (m_btRaceServer = RC_PLAYOBJECT) then begin
    if nLevel < 100 then begin //最高99级
      Result := g_Config.dwSkill95NeedExps[nLevel];
    end else Result := High(LongWord);
  end else Result := High(LongWord);
end;

//计算斗转值上限

function TPlayObject.GetSkill_95Value(nAC, nAMC: Integer; nLevel: Byte): Word;
  function GetValue(Key, nLevel: Integer): Integer;
  const
    BASE_KEY = 20;
    BASE_VALUE = 306;
  var
    iKey, iMod, iDiv: Integer;
  begin
    iKey := Key - BASE_KEY;
    iDiv := iKey div 10;
    iMod := iKey mod 10;

    Result := BASE_VALUE + iDiv * 9 + iMod + nLevel * 3;
    if iMod > 0 then Result := Result - 1;
  end;
begin
  Result := 0;
  case m_btJob of
    0: Result := _MIN(High(Word), GetValue(nAC + nAMC, nLevel));
    1: Result := _MIN(High(Word), Round(0.598 * (nAC + nAMC) + 45.652 + nLevel));
    2: Result := _MIN(High(Word), Round((nAC + nAMC + 253.46937) / 0.69312) + (nLevel - 17) * 5);
  end;
  if m_wStatusArrValue[18] > 0 then Result := _MIN(High(Word), Result + m_wStatusArrValue[18]); //培元酒增加上限
end;
//自动修炼斗转星移

function TPlayObject.ClientGameGirdUpSkill95(nType: Byte; nCount: Integer): Boolean;
var
  nExp, nMaxExp: LongWord;
begin
  Result := False;
  if IncSkill95Exping then Exit; //正在取得斗转星移经验
  IncSkill95Exping := True;
  try
    try
      case nType of
        0: begin
            if (not m_boDeath) and (not m_boGhost) and (m_nGameGird >= nCount) and (nCount > 0) then begin
              if m_Magic95Skill <> nil then begin //斗转星移
                if (m_Magic95Skill.btLevel < 64) or (m_boOpenupSkill95 and (m_Magic95Skill.btLevel < 100)) then begin
                  Dec(m_nGameGird, nCount);
                  GoldGameGirdChanged(); //更新客户端金币，灵符
                  Result := True;
                  if Random(3) = 0 then begin
                    nExp := g_Config.nAutoExpSkill95 * 10000;
                    Inc(m_Magic95Skill.nTranPoint, nExp);
                    nMaxExp := GetSkill95Exp(m_Magic95Skill.btLevel);
                    if m_Magic95Skill.nTranPoint >= nMaxExp then begin //超过升级经验,则升级技能
                      Dec(m_Magic95Skill.nTranPoint, nMaxExp);
                      if (m_Magic95Skill.btLevel < 64) or (m_boOpenupSkill95 and (m_Magic95Skill.btLevel < 100)) then begin
                        Inc(m_Magic95Skill.btLevel);
                      //计算升级后的斗转值上限
                        m_WAbil.MaxTransferValue := GetSkill_95Value(HiWord(m_WAbil.AC), HiWord(m_WAbil.MAC), m_Magic95Skill.btLevel);
                        if m_WAbil.TransferValue > m_WAbil.MaxTransferValue then m_WAbil.TransferValue := m_WAbil.MaxTransferValue;
                        SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                      end;
                    end;
                    if (m_Magic95Skill.btLevel < 100) then begin
                      nMaxExp := GetSkill95Exp(m_Magic95Skill.btLevel);
                      SendMsg(Self, RM_MAGIC_LVEXP, m_Magic95Skill.MagicInfo.wMagicId, nMaxExp, m_Magic95Skill.btLevel, m_Magic95Skill.nTranPoint, '');
                    end;
                    SysMsg(Format('您获得了%d点奇经修炼点！', [nExp]), c_Red, t_Hint);
                  end else begin
                    if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(Self, '@AutoLianqi', False, False);
                  end;
                  m_UseGameGird := nCount; //灵符使用计数
                  if g_FunctionNPC <> nil then begin //灵符使用触发
                    g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                  end;
                  if g_boGameLogGameGird then begin //记录灵符日志
                    AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GameGird, m_sMapName,
                      m_nCurrX, m_nCurrY, m_sCharName, g_Config.sGameGird,
                        m_nGameGird, '-' + inttostr(nCount), '斗转星移']));
                  end;
                end;
              end;
            end;
          end;
        1: begin
            if m_MyHero <> nil then begin
              if (not m_MyHero.m_boDeath) and (not m_MyHero.m_boGhost) and (m_nGameGird >= nCount) and (nCount > 0) then begin
                if THeroObject(m_MyHero).m_Magic95Skill <> nil then begin //斗转星移
                  if (THeroObject(m_MyHero).m_Magic95Skill.btLevel < 64) or
                    (THeroObject(m_MyHero).m_boOpenupSkill95 and (THeroObject(m_MyHero).m_Magic95Skill.btLevel < 100)) then begin
                    Dec(m_nGameGird, nCount);
                    GoldGameGirdChanged(); //更新客户端金币，灵符
                    Result := True;
                    if Random(3) = 0 then begin
                      nExp := g_Config.nAutoExpSkill95 * 10000;
                      Inc(THeroObject(m_MyHero).m_Magic95Skill.nTranPoint, nExp);
                      nMaxExp := THeroObject(m_MyHero).GetSkill95Exp(THeroObject(m_MyHero).m_Magic95Skill.btLevel);
                      if THeroObject(m_MyHero).m_Magic95Skill.nTranPoint >= nMaxExp then begin //超过升级经验,则升级技能
                        Dec(THeroObject(m_MyHero).m_Magic95Skill.nTranPoint, nMaxExp);
                        if (THeroObject(m_MyHero).m_Magic95Skill.btLevel < 64) or
                          (THeroObject(m_MyHero).m_boOpenupSkill95 and (THeroObject(m_MyHero).m_Magic95Skill.btLevel < 100)) then begin
                          Inc(THeroObject(m_MyHero).m_Magic95Skill.btLevel);
                        //计算升级后的斗转值上限
                          m_WAbil.MaxTransferValue := THeroObject(m_MyHero).GetSkill_95Value(HiWord(m_WAbil.AC), HiWord(m_WAbil.MAC), THeroObject(m_MyHero).m_Magic95Skill.btLevel);
                          if m_WAbil.TransferValue > m_WAbil.MaxTransferValue then m_WAbil.TransferValue := m_WAbil.MaxTransferValue;
                          THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROABILITY, 0, 0, 0, 0, ''); //斗转星移则更新斗转值
                        end;
                      end;
                      if (THeroObject(m_MyHero).m_Magic95Skill.btLevel < 100) then begin
                        nMaxExp := THeroObject(m_MyHero).GetSkill95Exp(THeroObject(m_MyHero).m_Magic95Skill.btLevel);
                        THeroObject(m_MyHero).SendMsg(m_MyHero, RM_HEROMAGIC_LVEXP, THeroObject(m_MyHero).m_Magic95Skill.MagicInfo.wMagicId, nMaxExp, THeroObject(m_MyHero).m_Magic95Skill.btLevel, THeroObject(m_MyHero).m_Magic95Skill.nTranPoint, '');
                      end;
                      SysMsg(Format('(英雄) 您获得了%d点奇经修炼点！', [nExp]), c_Red, t_Hint);
                    end else begin
                      if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(Self, '@AutoLianqi', False, False);
                    end;
                    m_UseGameGird := nCount; //灵符使用计数
                    if g_FunctionNPC <> nil then begin //灵符使用触发
                      g_FunctionNPC.GotoLable(self, '@USEGAMEGIRD', False, False);
                    end;
                    if g_boGameLogGameGird then begin //记录灵符日志
                      AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GameGird, m_sMapName,
                        m_nCurrX, m_nCurrY, m_sCharName, g_Config.sGameGird,
                          m_nGameGird, '-' + inttostr(nCount), '斗转星移']));
                    end;
                  end;
                end;
              end;
            end;
          end;
      end;
    except
      Result := False;
    end;
  finally
    IncSkill95Exping := False; //正在取得斗转星移经验
  end;
end;
//检查炼气条件是否达到

procedure TPlayObject.ClientCheckLianQiConditions(nType: Byte);
var
  nCode: Byte; //1-内功精元不足 2-您的金币不足 3-您的灵符不足
begin
  nCode := 0;
  if m_JingYuanValue >= 100 then begin //当前精元值达到100
    if m_nGold >= g_Config.nLianqiGold then begin //判断金币条件是否达到
      case nType of
        0: begin //普通炼气
            m_boLianQiConditions := True; //是否可以炼气
          end;
        1: begin //强化炼气
            if m_nGAMEGIRD >= g_Config.nLianqiGameGird then begin
              m_boLianQiConditions := True; //是否可以炼气
            end else nCode := 3;
          end;
      end;
    end else nCode := 2;
  end else nCode := 1;
  SendMsg(Self, RM_LIANQIPRACTICE, 0, nCode, 0, 0, '')
end;
//提取炼气所得物品

procedure TPlayObject.ClientGetLianQiPractice(nType: Byte);
begin
  if m_boLianQiing then Exit; //炼气正在提取
  m_boLianQiing := True; //炼气正在提取
  try
    if m_boLianQiConditions then begin
      m_boLianQiConditions := False;
      if m_JingYuanValue >= 100 then begin //当前精元值达到100
        if m_nGold >= g_Config.nLianqiGold then begin //判断金币条件是否达到
          Dec(m_JingYuanValue, 100);
          case nType of
            0: begin //普通炼气
                Dec(m_nGold, g_Config.nLianqiGold);
                if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(Self, '@Lianqi', False, False); //普通炼气触发
              end;
            1: begin //强化炼气
                if m_nGAMEGIRD >= g_Config.nLianqiGameGird then begin
                  Dec(m_nGold, g_Config.nLianqiGold);
                  Dec(m_nGAMEGIRD, g_Config.nLianqiGameGird);
                  if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(Self, '@Lianqi1', False, False); //强化炼触发
                end;
              end;
          end;
          SendMsg(Self, RM_SENDJINGYUANVALUE, 0, 0, 0, 0, ''); //更新人物精元值
          GoldGameGirdChanged(); //更新客户端金币，灵符
        end;
      end;
    end;
  finally
    m_boLianQiing := False; //炼气正在提取
  end;
end;

//客户端修炼奇经技能  nPage-修炼页,0-神冲, nMakeIndex-制造ID

procedure TPlayObject.ClientUserSkillToJingQing(nPage: Byte; nMakeIndex: Integer);
var
  I: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  nPoint, nMaxExp: LongWord;
  boSkill: Boolean;
begin
  if IncSkill95Exping then Exit;
  IncSkill95Exping := True;
  try
    if (nMakeIndex > 0) then begin
      m_dwDecGameGirdTick := m_dwDecGameGirdTick + 3000; //20110202
      case nPage of
        0: begin //神冲
            nPoint := 0;
            boSkill := False;
            if m_Magic95Skill <> nil then begin
              if (m_Magic95Skill.btLevel < 64) or (m_boOpenupSkill95 and (m_Magic95Skill.btLevel < 100)) then begin
                for I := m_ItemList.Count - 1 downto 0 do begin
                  if m_ItemList.Count <= 0 then Break;
                  UserItem := m_ItemList.Items[I];
                  if (UserItem <> nil) then begin
                    if (UserItem.MakeIndex = nMakeIndex) then begin
                      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                      if StdItem <> nil then begin
                        if (StdItem.StdMode = 17) and (StdItem.Shape = 238) and (StdItem.AniCount > 0) then begin
                          boSkill := True;
                          nPoint := StdItem.AniCount * 1000 * UserItem.Dura;
                          Inc(m_Magic95Skill.nTranPoint, nPoint);
                          SysMsg(Format('您获得了%d点奇经修炼点！', [nPoint]), c_Red, t_Hint);
                          nMaxExp := GetSkill95Exp(m_Magic95Skill.btLevel);
                          if m_Magic95Skill.nTranPoint >= nMaxExp then begin
                            Dec(m_Magic95Skill.nTranPoint, nMaxExp);
                            Inc(m_Magic95Skill.btLevel);
                            SysMsg(Format('恭喜您,突破神冲穴的禁锢，提升修为到%d重!“斗转星移”技能提升到%d级！', [m_Magic95Skill.btLevel, m_Magic95Skill.btLevel]), c_Red, t_Hint);
                          //计算升级后的斗转值上限
                            m_WAbil.MaxTransferValue := GetSkill_95Value(HiWord(m_WAbil.AC), HiWord(m_WAbil.MAC), m_Magic95Skill.btLevel);
                            if m_WAbil.TransferValue > m_WAbil.MaxTransferValue then m_WAbil.TransferValue := m_WAbil.MaxTransferValue;
                            SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                          end;
                          nMaxExp := GetSkill95Exp(m_Magic95Skill.btLevel);
                          SendMsg(Self, RM_MAGIC_LVEXP, m_Magic95Skill.MagicInfo.wMagicId, nMaxExp, m_Magic95Skill.btLevel, m_Magic95Skill.nTranPoint, '');
                          m_ItemList.Delete(I);
                          Dispose(UserItem); //By TasNat
                        UserItem := nil;
                        end;
                      end;
                      Break;
                    end;
                  end;
                end; // for
              end;
            end;
            if boSkill then SendMsg(Self, RM_SKILLTOJINGQING_OK, 0, 0, 0, 0, '')
            else SendMsg(Self, RM_SKILLTOJINGQING_FAIL, 0, 0, 0, 0, '');
          end; //0
      end;
    end;
  finally
    IncSkill95Exping := False;
  end;
end;
{$IFEND}
//{$REGION '个人商店'}
//--------------------------------个人商店--------------------------------------

function TPlayObject.GetBagItemsEx(nItemIdx: Integer): pTUserItem;
var
  i: integer;
  UserItem: pTUserItem;
begin
  try
    Result := nil;
    if m_ItemList.Count > 0 then begin
      for i := 0 to m_ItemList.Count - 1 do begin
        UserItem := m_ItemList.Items[I];
        if UserItem.MakeIndex = nItemIdx then begin
          Result := UserItem;
          break;
        end;
      end;
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.GetBagItemsEx', [g_sExceptionVer]));
  end;
end;

//删除个人商店物品

procedure TPlayObject.SendDelShopItem(UserItem: pTUserItem);
begin
  try
    SendDefMessage(SM_DELSHOPITEM, UserItem.MakeIndex, 0, 0, 0, '');
  except   
    MainOutMessage(format('{%s} TPlayObject.SendDelShopItem', [g_sExceptionVer]));
  end;
end;

//通知客户端，个人商店发生改变

procedure TPlayObject.SendChangeShop(BaseObject: TBaseObject; boShop: Boolean);
begin
  try
    SendDefMessage(SM_ISSHOP, Integer(BaseObject), Integer(boShop), 0, 0, BaseObject.m_sShopMsg);
  except   
    MainOutMessage(format('{%s} TPlayObject.SendChangeShop', [g_sExceptionVer]));
  end;
end;
//取回摆摊物品

procedure TPlayObject.GetBackShopItems();
var
  I: Integer;
  UserShopItem: pTUserShopItem;
begin
  try
    if m_ShopItemList.Count > 0 then begin
      for I := 0 to m_ShopItemList.Count - 1 do begin
        UserShopItem := m_ShopItemList.Items[i];
        Dispose(UserShopItem);
      end;
    end;
    m_ShopItemList.Clear;
    m_boShop := False;
    m_sShopMsg := '';
  except   
    MainOutMessage(format('{%s} TPlayObject.GetBackShopItems', [g_sExceptionVer]));
  end;
end;
//取消个人商店

procedure TPlayObject.ShopCancel();
begin
  try
    if m_boShop then begin
      GetBackShopItems;
      SendRefMsg(RM_ISSHOP, 0, 0, 0, 0, '');
      SendChangeShop(self, False);
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ShopCancel', [g_sExceptionVer]));
  end;
end;
//收摊

procedure TPlayObject.ClientGetCloseShop();
begin
  try
    if m_boShop then begin
      m_boShop := False;
      GetBackShopItems;
      SendRefMsg(RM_ISSHOP, 0, 0, 0, 0, '');
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientGetCloseShop', [g_sExceptionVer]));
  end;
end;
//开始摆摊

procedure TPlayObject.ClientGetShopItems(Msg: string);
var
  n10, I: integer;
  body, Str: string;
  ClientShopItem: TClientShopItem;
  UserShopItem: pTUserShopItem;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  boAdd: Boolean;
begin
  try
    if (not m_boDeath) and (m_wStatusTimeArr[POISON_STONE {5}] = 0) and
      (m_wStatusTimeArr[POISON_LOCKSPELL {7}] = 0) and (not m_boShop) and (Msg <> '') then begin
      if not g_Config.boOpenSelfShop then begin
        SendChangeShop(Self, False);
        SysMsg('服务器暂时关闭摆摊功能！', c_Red, t_Hint);
        exit;
      end;
      if g_Config.boSafeZoneShop and not InSafeZone then begin
        SendChangeShop(Self, False);
        SysMsg('安全区以外的地方不能进行摆摊！', c_Red, t_Hint);
        exit;
      end;
      if g_Config.boMapShop and not m_PEnvir.m_boSHOP then begin
        SendChangeShop(Self, False);
        SysMsg('本地图禁止摆摊！', c_Red, t_Hint);
        exit;
      end;
      if m_MyHero <> nil then begin
        SendChangeShop(Self, False);
        SysMsg('请把英雄召回再进行摆摊！', c_Red, t_Hint);
        exit;
      end;
      if m_boOnHorse then begin
        SendChangeShop(Self, False);
        SysMsg('请先下马！', c_Red, t_Hint);
        exit;
      end;
      if m_Abil.Level < g_Config.nCanShopLevel then begin
        SendChangeShop(Self, False);
        SysMsg(Format('等级未达到%d，不能进行摆摊！', [g_Config.nCanShopLevel]), c_Red, t_Hint);
        exit;
      end;

      if GetMapCanShop(m_PEnvir, m_nCurrX, m_nCurrY, 1) then begin //判断周围1格是否有位置摆摊
        SendChangeShop(Self, False);
        SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '[失败] 你周围没有位置摆摊');
        exit;
      end;
      body := Msg;
      n10 := 0;
      while True do begin
        if body = '' then break;
        if n10 > 10 then Exit; //限制只能出售10个物品
        body := GetValidStr3(body, str, ['/']);
        if n10 = 0 then
          m_sShopMsg := DecodeString(str)
        else begin
          if Str = '' then break;
          DecodeBuffer(str, @ClientShopItem, sizeof(TClientShopItem));
          UserItem := GetBagItemsEx(ClientShopItem.nItemIdx);
          if UserItem <> nil then begin
            if (UserItem.AddValue[0] in [1..3]) then Break; //限时物品,绑定物品不能交易
            boAdd := False;
            for i := 0 to m_ShopItemList.Count - 1 do begin //防止同一件物品卖两个价格
              UserShopItem := m_ShopItemList.Items[i];
              if UserShopItem.Item = UserItem.MakeIndex then begin
                boAdd := True;
                break;
              end;
            end;
            if boAdd then Continue;
            //判断是否禁止出售
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if StdItem <> nil then begin
              if CheckItemValue(UserItem, 4) or PlugOfCheckCanItem(1, StdItem.Name, True, 0, 0) then begin //禁止物品规则(禁止交易) 20080913
                SendDelShopItem(UserItem);
                SendAddItem(UserItem);
                SysMsg('您摆摊中的物品[' + StdItem.Name + ']禁止出售！', c_Red, t_System);
                Continue; //已绑定过的物品不允许出售
              end;
              if ClientShopItem.nPic > 0 then begin //判断价格是否合法 20100912
                New(UserShopItem);
                UserShopItem.Item := UserItem.MakeIndex;
                UserShopItem.nPic := ClientShopItem.nPic;
                UserShopItem.boCls := ClientShopItem.boCls;
                m_ShopItemList.Add(UserShopItem);
                m_boShop := True;
              end else SysMsg('您摆摊中的物品[' + StdItem.Name + ']禁止出售！', c_Red, t_System);
            end else Continue;
          end;
        end;
        Inc(n10);
      end;
      if m_boOnHorse then begin
        m_boOnHorse := False;
        FeatureChanged();
      end;
      if m_boShop then begin
        SendRefMsg(RM_ISSHOP, 0, 1, 0, 0, m_sShopMsg);
        Exit;
      end else SysMsg('至少需要摆放一件物品！', c_Red, t_System);
    end;
    SendChangeShop(Self, False);
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientGetShopItems', [g_sExceptionVer]));
  end;
end;

//人物登陆，发送个人商店列表

procedure TPlayObject.ClientGetShopList();
var
  ShopItem: TShopItem;
  UserShopItem: pTUserShopItem;
  UserItem: pTUserItem;
  sSendMsg, sUserItemName: string;
  StdItem: pTStdItem;
  StdItem80: TStdItem;
  I: integer;
begin
  try
    sSendMsg := '';
    if m_ShopItemList.Count > 0 then begin
      for I := 0 to m_ShopItemList.Count - 1 do begin
        UserShopItem := m_ShopItemList.Items[I];
        UserItem := GetBagItemsEx(UserShopItem.Item);
        if UserItem = nil then Continue;
        if CheckItemValue(UserItem, 4) then Continue;
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        FillChar(ShopItem, SizeOf(TShopItem), #0);
        if StdItem <> nil then begin
          if PlugOfCheckCanItem(1, StdItem.Name, True, 0, 0) then Continue; //禁止物品规则(禁止交易)
          StdItem80 := StdItem^;
          ItemUnit.GetItemAddValue(UserItem, StdItem80);
          Move(StdItem80, ShopItem.Item.S, SizeOf(TStdItem));

          //取自定义物品名称
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sUserItemName <> '' then ShopItem.Item.s.Name := sUserItemName;
          if (UserItem.btValue[12] = 1) and (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) then ShopItem.Item.s.Reserved1 := 1 //物品发光
          else ShopItem.Item.s.Reserved1 := 0;

          ShopItem.Item.Dura := UserItem.Dura;
          ShopItem.Item.DuraMax := UserItem.DuraMax;
          ShopItem.Item.MakeIndex := UserItem.MakeIndex;
          //Modified By TasNat at: 2012-04-12 09:28:18
          ShopItem.Item.btAppraisalLevel :=   UserItem.btAppraisalLevel;
          ShopItem.Item.btUnKnowValueCount := UserItem.btUnKnowValueCount;
          Move(UserItem.btAppraisalValue, ShopItem.Item.btAppraisalValue, SizeOf(ShopItem.Item.btAppraisalValue)); 
          
          Move(UserItem.btUnKnowValue, ShopItem.Item.btUnKnowValue, SizeOf(ShopItem.Item.btUnKnowValue)); //20100824
          ShopItem.nPic := UserShopItem.nPic;
          ShopItem.boCls := UserShopItem.boCls;
          case StdItem.StdMode of //20081009 修改
{$IF M2Version <> 2}
            5, 6: begin
                ShopItem.Item.s.NeedIdentify := _MIN(High(Byte), UserItem.btValue[11] + UserItem.btValue[20]); //武器暴击等级 20100708
                if CheckItemSpiritMedia(UserItem) then begin
                  ShopItem.Item.Aura := UserItem.btValue[12];
                  ShopItem.Item.MaxAura := g_Config.nMaxAuraValue;
                end;
              end;
            44: begin
                if StdItem.Shape = 255 then ShopItem.Item.s.NeedIdentify := UserItem.btValue[0];
                if StdItem.Shape = 253 then begin //除魔灵媒
                  ShopItem.Item.Aura := UserItem.btValue[11];
                  ShopItem.Item.MaxAura := g_Config.nMaxAuraValue;
                end;
              end;
            10, 11, 16, 30, 52, 54, 55, 62, 64: begin
                if CheckItemSpiritMedia(UserItem) then begin
                  ShopItem.Item.Aura := UserItem.btValue[11];
                  ShopItem.Item.MaxAura := g_Config.nMaxAuraValue;
                end;
              end;
{$IFEND}
            8: if UserItem.btValue[0] <> 0 then ShopItem.Item.s.AC := UserItem.btValue[0]; //材料的品质
            15, 19..24, 26..29: begin
                if UserItem.btValue[8] <> 0 then ShopItem.Item.s.Shape := 130; //20100513 修改 20100628 增加29分类(敏捷幸运型项链)
{$IF M2Version <> 2}
                if CheckItemSpiritMedia(UserItem) then begin
                  ShopItem.Item.Aura := UserItem.btValue[11];
                  ShopItem.Item.MaxAura := g_Config.nMaxAuraValue;
                end;
{$IFEND}
              end;
            51: if (StdItem.Shape = 0) then ShopItem.Item.s.Need := StdItem.AniCount * 24; //如果是聚灵珠,则换成小时数 20080323
            60: begin
                if (StdItem.shape <> 0) then begin //酒类,除烧酒外 20080622
                  if UserItem.btValue[0] <> 0 then ShopItem.Item.s.AC := UserItem.btValue[0]; //酒的品质
                  if UserItem.btValue[1] <> 0 then ShopItem.Item.s.MAC := UserItem.btValue[1]; //酒的酒精度
                  if UserItem.btValue[3] > 0 then ShopItem.Item.s.NeedLevel := UserItem.btValue[3] //酒的等级 20091117
                  else ShopItem.Item.s.NeedLevel := 0;
                end;
              end;
            17: if StdItem.Weight > 0 then ShopItem.Item.s.Weight := UserItem.Dura; //拆加物品的重量 20090816
          end;
          sSendMsg := sSendMsg + EncodeBuffer(@ShopItem, SizeOf(TShopItem)) + '/';
        end;
      end;
      SendDefMessage(SM_SELLSHOPTITLE, 0, 0, 0, 0, m_sShopMsg);
      m_DefMsg := MakeDefaultMsg(SM_SELLSHOPLIST, Integer(Self), 0, 0, 0, 0);
      SendSocket(@m_DefMsg, sSendMsg);
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientGetShopList', [g_sExceptionVer]));
  end;
end;

//别人查看个人商店物品

procedure TPlayObject.ClientClickPlay(BaseObject: TPlayObject; nX, nY: Integer);
var
  ShopItem: TShopItem;
  UserShopItem: pTUserShopItem;
  UserItem: pTUserItem;
  sSendMsg, sUserItemName: string;
  StdItem: pTStdItem;
  StdItem80: TStdItem;
  I: integer;
  PlayObject: TPlayObject;
begin
  try
    if not CretInNearXY(BaseObject, nX, nY) then exit;
    if (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) or (BaseObject.m_MyHero <> nil) then exit;
    PlayObject := TPlayObject(BaseObject);
    if PlayObject.m_boShop then begin
      sSendMsg := '';
      if PlayObject.m_ShopItemList.Count > 0 then begin
        for I := 0 to PlayObject.m_ShopItemList.Count - 1 do begin
          UserShopItem := PlayObject.m_ShopItemList.Items[I];
          UserItem := PlayObject.GetBagItemsEx(UserShopItem.Item);
          if UserItem = nil then Continue;
          if (UserItem.AddValue[0] in [1..3]) then Continue; //限时物品,绑定物品不能交易
          if CheckItemValue(UserItem, 4) then Continue;
          if UserShopItem.nPic <= 0 then Continue; //价格不合法则不发送 20100912
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          FillChar(ShopItem, SizeOf(TShopItem), #0);
          if StdItem <> nil then begin
            if PlugOfCheckCanItem(1, StdItem.Name, True, 0, 0) then Continue; //禁止物品规则(禁止交易)
            StdItem80 := StdItem^;
            ItemUnit.GetItemAddValue(UserItem, StdItem80);
            Move(StdItem80, ShopItem.Item.S, SizeOf(TStdItem));
            //取自定义物品名称
            sUserItemName := '';
            if UserItem.btValue[13] = 1 then
              sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
            if sUserItemName <> '' then ShopItem.Item.s.Name := sUserItemName;
            if (UserItem.btValue[12] = 1) and (StdItem.StdMode <> 5) and (StdItem.StdMode <> 6) then ShopItem.Item.s.Reserved1 := 1 //物品发光
            else ShopItem.Item.s.Reserved1 := 0;

            ShopItem.Item.MakeIndex := UserItem.MakeIndex;
            ShopItem.Item.Dura := UserItem.Dura;
            ShopItem.Item.DuraMax := UserItem.DuraMax;
            //Modified By TasNat at: 2012-04-12 09:28:18
            ShopItem.Item.btAppraisalLevel :=   UserItem.btAppraisalLevel;
            ShopItem.Item.btUnKnowValueCount := UserItem.btUnKnowValueCount;
            Move(UserItem.btAppraisalValue, ShopItem.Item.btAppraisalValue, SizeOf(UserItem.btAppraisalValue));

            Move(UserItem.btUnKnowValue, ShopItem.Item.btUnKnowValue, SizeOf(ShopItem.Item.btUnKnowValue)); //2010082
            ShopItem.nPic := UserShopItem.nPic;
            ShopItem.boCls := UserShopItem.boCls;

            case StdItem.StdMode of //20081009 修改
{$IF M2Version <> 2}
              5, 6: begin
                  ShopItem.Item.s.NeedIdentify := _MIN(High(Byte), UserItem.btValue[11] + UserItem.btValue[20]); //武器暴击等级 20100708
                  if CheckItemSpiritMedia(UserItem) then begin
                    ShopItem.Item.Aura := UserItem.btValue[12];
                    ShopItem.Item.MaxAura := g_Config.nMaxAuraValue;
                  end;
                end;
              44: begin
                  if StdItem.Shape = 255 then ShopItem.Item.s.NeedIdentify := UserItem.btValue[0];
                  if StdItem.Shape = 253 then begin //除魔灵媒
                    ShopItem.Item.Aura := UserItem.btValue[11];
                    ShopItem.Item.MaxAura := g_Config.nMaxAuraValue;
                  end;
                end;
              10, 11, 16, 30, 52, 54, 55, 62, 64: begin
                  if CheckItemSpiritMedia(UserItem) then begin
                    ShopItem.Item.Aura := UserItem.btValue[11];
                    ShopItem.Item.MaxAura := g_Config.nMaxAuraValue;
                  end;
                end;
{$IFEND}
              8: if UserItem.btValue[0] <> 0 then ShopItem.Item.s.AC := UserItem.btValue[0]; //材料的品质
              15, 19..24, 26..29: begin
                  if UserItem.btValue[8] <> 0 then ShopItem.Item.s.Shape := 130; //20100513 修改 20100628 增加29分类(敏捷幸运型项链)
{$IF M2Version <> 2}
                  if CheckItemSpiritMedia(UserItem) then begin
                    ShopItem.Item.Aura := UserItem.btValue[11];
                    ShopItem.Item.MaxAura := g_Config.nMaxAuraValue;
                  end;
{$IFEND}
                end;
              51: if (StdItem.Shape = 0) then ShopItem.Item.s.Need := StdItem.AniCount * 24; //如果是聚灵珠,则换成小时数 20080323
              60: begin
                  if (StdItem.shape <> 0) then begin //酒类,除烧酒外 20080622
                    if UserItem.btValue[0] <> 0 then ShopItem.Item.s.AC := UserItem.btValue[0]; //酒的品质
                    if UserItem.btValue[1] <> 0 then ShopItem.Item.s.MAC := UserItem.btValue[1]; //酒的酒精度
                    if UserItem.btValue[3] > 0 then ShopItem.Item.s.NeedLevel := UserItem.btValue[3] //酒的等级 20091117
                    else ShopItem.Item.s.NeedLevel := 0;
                  end;
                end;
              17: if StdItem.Weight > 0 then ShopItem.Item.s.Weight := UserItem.Dura; //拆加物品的重量 20090816
            end;
            sSendMsg := sSendMsg + EncodeBuffer(@ShopItem, SizeOf(TShopItem)) + '/';
          end;
        end;
      end;
      m_DefMsg := MakeDefaultMsg(SM_PLAYSHOPLIST, Integer(PlayObject), 0, 0, 0, 0);
      SendSocket(@m_DefMsg, sSendMsg);
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientClickPlayShop', [g_sExceptionVer]));
  end;
end;

//购买摆摊物品

procedure TPlayObject.ClientBuySelfShopItem(BaseObject: TPlayObject; nX, nY: Integer; sMsg: string);
var
  boBuy: Boolean;
  nItemIdx: Integer;
  nCode, I, II: Integer;
  UserShopItem: pTUserShopItem;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  SellPlay: TPlayObject;
  function CheckGold(nCount: Integer; boGameGold: Boolean): Boolean;
  begin
    Result := False;
    if nCount <= 0 then Exit; //20100912 判断价格是否合法
    if boGameGold then begin
      //if (m_nGameGold >= nCount) and ((PlayObject.m_nGameGold + nCount) < High(m_nGameGold)) then begin
      if (m_nGameGold >= nCount) and (SellPlay.m_nGameGold < (High(m_nGameGold) - nCount)) then begin //20100805 修改，判断元宝是否达到上限
        Result := True;
      end;
    end else begin
      //if (m_nGold >= nCount) and (((PlayObject.m_nGameGold + nCount) < g_Config.nHumanMaxGold) then begin
      if (m_nGold >= nCount) and (SellPlay.m_nGold < (g_Config.nHumanMaxGold - nCount)) then begin //20100805 修改，判断游戏币是否达到上限
        Result := True;
      end;
    end;
  end;
  procedure AddGold(nCount: Integer; boGameGold: Boolean);
  begin
    if boGameGold then begin
      Inc(SellPlay.m_nGameGold, nCount);
      Dec(m_nGameGold, nCount);
      if g_boGameLogGameGold then
        AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD,
          SellPlay.m_sMapName,
            SellPlay.m_nCurrX,
            SellPlay.m_nCurrY,
            SellPlay.m_sCharName,
            g_Config.sGameGoldName,
            SellPlay.m_nGameGold,
            '摆摊' + '(' + inttostr(nCount) + ')',
            m_sCharName]));
    end else begin
      Inc(SellPlay.m_nGold, nCount);
      Dec(m_nGold, nCount);
      if g_boGameLogGold then
        AddGameDataLog(Format(g_sGameLogMsg1, [LOG_GAMEGOLD,
          SellPlay.m_sMapName,
            SellPlay.m_nCurrX,
            SellPlay.m_nCurrY,
            SellPlay.m_sCharName,
            sSTRING_GOLDNAME,
            SellPlay.m_nGold,
            '摆摊' + '(' + inttostr(nCount) + ')',
            m_sCharName]));
    end;
    GoldChanged;
    SellPlay.GoldChanged;
  end;
begin
  try
    boBuy := False;
    nCode := -1;
    nItemIdx := Str_ToInt(sMsg, -1);
    if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and CretInNearXY(BaseObject, nX, nY) and (BaseObject.m_MyHero = nil) and (nItemIdx > 0) then begin
      SellPlay := TPlayObject(BaseObject);
      nCode := 0;
      if (SellPlay.m_boShop) then begin
        nCode := 1; //购买的物品不存在
        if SellPlay.m_ShopItemList.Count > 0 then begin
          for I := 0 to SellPlay.m_ShopItemList.Count - 1 do begin
            UserShopItem := SellPlay.m_ShopItemList.Items[I];
            if UserShopItem.Item = nItemIdx then begin
              if SellPlay.m_ItemList.Count > 0 then begin
                for ii := 0 to SellPlay.m_ItemList.Count - 1 do begin
                  UserItem := SellPlay.m_ItemList.Items[II];
                  if UserItem.MakeIndex = nItemIdx then begin
                    if (UserItem.AddValue[0] in [1..3]) then break; //限时物品,绑定物品不能交易
                    if CheckItemValue(UserItem, 4) then break;
                    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                    if StdItem <> nil then begin
                      if PlugOfCheckCanItem(1, StdItem.Name, True, 0, 0) then break; //禁止物品规则(禁止交易)
                      nCode := 2; //钱不够，或卖东西的钱太多
                      if CheckGold(UserShopItem.nPic, UserShopItem.boCls) then begin
                        nCode := 3; //背包物品已满
                        if AddItemToBag(UserItem) then begin
                          boBuy := True;
                          AddGold(UserShopItem.nPic, UserShopItem.boCls);
                          SellPlay.SendDelShopItem(UserItem);
                          if StdItem.NeedIdentify = 1 then
                            AddGameDataLog('34' + #9 + m_sCharName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
                              SellPlay.m_sCharName + #9 + StdItem.Name + #9 + IntToStr(nItemIdx) + #9 +
                              IntToStr(UserShopItem.nPic) + '-' + BoolToStr(UserShopItem.boCls) + #9 + '购买');
                          Dispose(UserShopItem);
                          SellPlay.m_ShopItemList.Delete(I);
                          SellPlay.m_ItemList.Delete(II);
                        end;
                      end;
                    end;
                    break;
                  end;
                end;
              end;
              break;
            end;
          end;
        end;
      end;
    end;
    if boBuy then SendDefMessage(SM_PLAYSHOP_OK, 0, 0, 0, 0, '')
    else SendDefMessage(SM_PLAYSHOP_FALL, nCode, 0, 0, 0, '');
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientBuySelfShopItem', [g_sExceptionVer]));
  end;
end;
//{$ENDREGION}
//客户端QMission NPC跳转 20100801

procedure TPlayObject.ClientQMissionGoto(sLabel: string; nType: Byte);
var
  boMmission: Boolean;
begin
{$IF M2Version <> 2}
  if (sLabel <> '') and (g_MissionNPC <> nil) then begin
    boMmission := nType <> 1; //成长任务消息标实(0-显示在上部分框 1-内容显在下部分框)
    g_MissionNPC.GotoLable(Self, sLabel, False, boMmission);
  end;
{$IFEND}
end;
//使用魔血石填充天龙印 20110116

procedure TPlayObject.RepairDragonIndia(nItemIdx: Integer; sItemName: string);
var
  I, n14: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  sUserItemName, sDragonIndiaName: string;
  boRepairOK: Boolean;
  OldDura: Word;
begin
  boRepairOK := False;
  StdItem := nil;
  UserItem := nil;
  n14 := -1;
  OldDura := 0;
  sDragonIndiaName := '';
  if (m_UseItems[U_CHARM].wIndex > 0) and (m_UseItems[U_CHARM].Dura < m_UseItems[U_CHARM].DuraMax) then begin
    StdItem := UserEngine.GetStdItem(m_UseItems[U_CHARM].wIndex);
    if (StdItem <> nil) and (StdItem.StdMode = 7) and (StdItem.Shape = 5) then begin //天龙印物品
      sDragonIndiaName := StdItem.Name;
      StdItem := nil;
      OldDura := m_UseItems[U_CHARM].Dura;
      if m_ItemList.Count > 0 then begin
        for I := 0 to m_ItemList.Count - 1 do begin
          UserItem := m_ItemList.Items[I];
          if (UserItem <> nil) then begin
            if (UserItem.MakeIndex = nItemIdx) then begin
              //取自定义物品名称
              sUserItemName := '';
              if UserItem.btValue[13] = 1 then
                sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
              if sUserItemName = '' then sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem <> nil then begin
                if CompareText(sUserItemName, sItemName) = 0 then begin
                  n14 := I;
                  Break;
                end;
              end;
            end;
          end;
          UserItem := nil;
        end;
      end;
      if (StdItem <> nil) and (UserItem <> nil) and (n14 > -1) then begin
        if (StdItem.StdMode = 7) and (StdItem.Shape = 3) then begin //魔血石物品
          m_UseItems[U_CHARM].Dura := _MIN(High(Word), m_UseItems[U_CHARM].Dura + UserItem.Dura);
          if m_UseItems[U_CHARM].Dura > m_UseItems[U_CHARM].DuraMax then m_UseItems[U_CHARM].Dura := m_UseItems[U_CHARM].DuraMax;
          if sDragonIndiaName <> '' then SysMsg(Format('您为%s中填充了1个%s，持久增加了%d！', [sDragonIndiaName, StdItem.Name, UserItem.Dura * 10]), c_Blue, t_Hint);
          boRepairOK := True;
          DelBagItem(n14);
        end;
      end;
    end;
  end;
  if boRepairOK then begin
    if OldDura <> m_UseItems[U_CHARM].Dura then
      SendMsg(Self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura, m_UseItems[U_CHARM].DuraMax, 0, '');
    SendDefMessage(SM_REPAIRDRAGONINDIA_OK, 0 {主体}, 0, 0, 0, '');
  end else begin
    SendDefMessage(SM_REPAIRDRAGONINDIA_FAIL, 0 {主体}, 0, 0, 0, '');
  end;
end;
//传送到宠物身旁

procedure TPlayObject.ClientMoveToPetsMon();
var
  I, nX, nY, n1C, oleDir: Integer;
  BaseObject: TBaseObject;
begin
  try
    if m_boDeath or m_boGhost or m_boAI or m_boNotOnlineAddExp then Exit;
    if (m_sPetsMonName <> '') then begin
      if m_SlaveList.Count > 0 then begin
        for I := 0 to m_SlaveList.Count - 1 do begin
          BaseObject := TBaseObject(m_SlaveList.Items[I]);
          if CompareText(m_sPetsMonName, BaseObject.m_sCharName) = 0 then begin
            if (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) and
              (BaseObject.m_PEnvir <> nil) then begin
              oleDir := BaseObject.m_btDirection;
              n1C := 0;
              BaseObject.GetFrontPosition(nX, nY);
              while (True) do begin
                try
                  if not BaseObject.m_PEnvir.CanWalk(nX, nY, False) then begin //如果坐标无法走，计算可以走到的坐标上
                    BaseObject.m_btDirection := (oleDir + n1C) mod 8;
                    BaseObject.GetFrontPosition(nX, nY);
                  end else Break;
                except
                end;
                Inc(n1C);
                if n1C >= 9 then Break;
              end;
              SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
              SpaceMove(BaseObject.m_sMapName, nX, nY, 0);
              SendDefMessage(SM_MOVETOPETSMON, 0, 0, 0, 0, '');
            end;
            Break;
          end;
        end;
      end;
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientMoveToPetsMon', [g_sExceptionVer]));
  end;
end;
//查看宠物喂养日志

procedure TPlayObject.ClientPetsMonHappLog(nPage {0-上一页 1-下一页}: Byte);
var
  sLog, sFileName: string;
  LoadList: TStringList;
  I, K: Integer;
  function GetPageCount(nListCount: Integer): Integer;
  begin
    Result := 0;
    if nListCount > 0 then begin
      Result := nListCount div 10;
      if (nListCount mod 10) > 0 then Inc(Result);
      Dec(Result);
    end;
  end;
begin
  try
    if m_boDeath or m_boGhost or m_boAI or m_boNotOnlineAddExp then Exit;
    sFileName := Format('%sPetsMon\%d\Log\%s.txt', [g_Config.sEnvirDir, g_Config.GlobalVal[High(g_Config.GlobalVal)], m_sCharName]);
    if FileExists(sFileName) and (m_sPetsMonName <> '') then begin //文件存在则读取
      sLog := '';
      LoadList := TStringList.Create;
      try
        LoadList.LoadFromFile(sFileName);
        case nPage of
          0: begin //上一页
              if m_nPetsMonHappLogPage > 0 then
                Dec(m_nPetsMonHappLogPage)
              else m_nPetsMonHappLogPage := 0;
            end;
          1: begin //下一页
              if GetPageCount(LoadList.Count) > m_nPetsMonHappLogPage then begin
                Inc(m_nPetsMonHappLogPage);
              end;
            end;
        end;
        if m_nPetsMonHappLogPage > LoadList.Count - 1 then Exit;
        K := 0;
        for I := m_nPetsMonHappLogPage * 10 to LoadList.Count - 1 do begin
          if (K >= 9) or (I >= LoadList.Count) or//增加范围检测 By TasNat at: 2012-04-07 14:08:23
          (Trim(LoadList.Strings[I]) = '') then Break;
          sLog := sLog + Trim(LoadList.Strings[I]) + '\';
          Inc(K);
        end;
      finally
        LoadList.Free;
      end;
      SendMsg(self, RM_PETSMONHAPPLOG, 0, m_nPetsMonHappiness, 0, 0, sLog);
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.ClientPetsMonHappLog', [g_sExceptionVer]));
  end;
end;
//{$REGION '禁止物品规则(管理插件功能) 20080729'}
//------------------------------------------------------------------------------
//禁止物品规则(管理插件功能) 20080729
//boCanHit:掉落是否需要提示
//nCode:0-物品禁止扔 1-物品禁止交易 2-物品禁止存  3-物品禁止修 4-物品掉落提示  5-开启宝箱提示
//      6-永不暴出 7-挖取提示  8-禁止英雄使用 9-禁止捡起(除GM外) 10-死亡掉落 11-禁止商铺赠送
//      12-禁止挖的物品  13-淬练成功提示 14-物品爆出，隔一定时间才能捡起 15-挖宝提示
//      16-24时消失(当天有效物品)

function TBaseObject.PlugOfCheckCanItem(nCode: Byte; ItemName: string; boCanHit: Boolean; dx, dy: Integer): Boolean;
var
  sMsg: string;
  boItemRules: Boolean;
begin
  Result := False;
  try
    if (not m_boGhost) then begin
      boItemRules := GetCheckItemList(nCode, ItemName);
      case nCode of
        0: Result := boItemRules; //物品禁止扔
        1: begin //物品禁止交易  *
            if boItemRules then begin
              if (g_ManageNPC <> nil) and (not boCanHit) then //20080913 修改
                SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(self), 0, 0, '此物品禁止交易！');
              Result := True;
            end;
          end; //1
        2: begin //物品禁止存
            if boItemRules then begin
              if g_ManageNPC <> nil then
                SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(self), 0, 0, '此物品禁止存仓库！');
              Result := True;
            end;
          end; //2
        3: Result := boItemRules; //物品禁止修
        4: begin //物品掉落提示 *
            if boItemRules and boCanHit and (m_PEnvir <> nil) then begin //20090129 增加 m_PEnvir <> nil
              sMsg := AnsiReplaceText(g_sItmeDropHintMsg, '%X', IntTostr(dx));
              sMsg := AnsiReplaceText(sMsg, '%Y', IntTostr(dy));
              sMsg := AnsiReplaceText(sMsg, '%map', m_PEnvir.sMapDesc);
              sMsg := AnsiReplaceText(sMsg, '%item', ItemName);
              sMsg := AnsiReplaceText(sMsg, '%name', m_sCharName);
              UserEngine.SendBroadCastMsgExt1(sMsg, t_Say, g_Config.btItemMsgFColor, g_Config.btItemMsgBColor);
              Result := True;
            end;
          end; //4
        5: begin //开启宝箱提示,全F提示  *
            if boItemRules then begin
              case dy of
                0: begin //普通箱子
                    sMsg := AnsiReplaceText(g_sBoxsItemHintMsg, '%name', m_sCharName);
                    sMsg := AnsiReplaceText(sMsg, '%s', ItemName);
                    sMsg := AnsiReplaceText(sMsg, '%d', IntToStr(dx)); //20090524 增加
                    UserEngine.SendBroadCastMsgExt(sMsg, t_Say);
                  end;
                1: begin //牛气箱子 20091117
                    sMsg := AnsiReplaceText(g_sBoxsItemHintMsg2, '%name', m_sCharName);
                    sMsg := AnsiReplaceText(sMsg, '%s', ItemName);
                    sMsg := AnsiReplaceText(sMsg, '%d', IntToStr(dx));
                    UserEngine.SendBroadCastMsgExt(sMsg, t_Say);
                  end;
              end;
              Result := True;
            end;
          end; //5
        6: Result := boItemRules; //永不暴出
        7: begin //挖取提示 *
            if boItemRules then begin
              sMsg := AnsiReplaceText(g_sButchItemHintMsg, '%s', m_sCharName);
              sMsg := AnsiReplaceText(sMsg, '%map', m_PEnvir.sMapDesc);
              sMsg := AnsiReplaceText(sMsg, '%item', ItemName);
              sMsg := AnsiReplaceText(sMsg, '%x', IntToStr(m_nCurrX));
              sMsg := AnsiReplaceText(sMsg, '%y', IntToStr(m_nCurrY));
              UserEngine.SendBroadCastMsgExt(sMsg, t_Say);
              Result := True;
            end;
          end; //7
{$IF HEROVERSION = 1}
        8: begin //禁止英雄使用
            if boItemRules then begin
              if m_btRaceServer = RC_PLAYOBJECT then begin
                SysMsg('此物品禁止英雄使用!', c_Red, t_Hint);
              end else
                if m_btRaceServer = RC_HEROOBJECT then begin
                  THeroObject(self).SysMsg('此物品禁止英雄使用!', c_Red, t_Hint);
                end;
              Result := True;
            end;
          end; //8
{$IFEND}
        9: Result := boItemRules; //禁止捡起(除GM外) *
        10: Result := boItemRules; //死亡掉落  *
        11: Result := boItemRules; //禁止赠送
        12: Result := boItemRules; //禁止挖的物品
{$IF M2Version <> 2}
        13: Result := boItemRules; //淬练成功提示
        15: begin //挖宝提示
            if boItemRules then begin
              if sDigJewelItemMsg <> '' then begin
                sMsg := AnsiReplaceText(sDigJewelItemMsg, '%s', m_sCharName);
                sMsg := AnsiReplaceText(sMsg, '%map', m_PEnvir.sMapDesc);
                sMsg := AnsiReplaceText(sMsg, '%item', ItemName);
                sMsg := AnsiReplaceText(sMsg, '%d', IntToStr(dx));
                UserEngine.SendBroadCastMsgExt(sMsg, t_Say);
              end;
              Result := True;
            end;
          end;
{$IFEND}
        14: Result := boItemRules; //物品爆出，隔一定时间才能捡起 20100530
        16: Result := boItemRules; //24时消失
        17: Result := boItemRules; //永久绑定
        18: Result := boItemRules; //绑定48时
      end; //Case
    end;
  except   
    MainOutMessage(format('{%s} TPlayObject.PlugOfCheckCanItem Code:%d', [g_sExceptionVer, nCode]));
  end;
end;
//{$ENDREGION}
end.
